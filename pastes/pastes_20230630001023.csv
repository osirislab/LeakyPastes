id,title,username,language,date,content
wEe58f2c,excepciones y raise,teslariu,Python,Thursday 29th of June 2023 07:07:01 PM CDT,"#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
""""""
Python 3.10.5 (tags/v3.10.5:f377153, Jun  6 2022, 16:14:13) [MSC v.1929 64 bit (AMD64)] on win32
Type ""help"", ""copyright"", ""credits"" or ""license"" for more information.
>>> # excepciones: son un modelo de manejo de errores
>>> 25/0
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
ZeroDivisionError: division by zero
>>> 25 + ""er""
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
TypeError: unsupported operand type(s) for +: 'int' and 'str'
>>> int(""er"")
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
ValueError: invalid literal for int() with base 10: 'er'
>>> lista = [1,2]
>>> lista[2]
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
IndexError: list index out of range
>>> dicc = {""red"":""rojo"", ""blue"":""azul""}
>>> dicc[""yellow""]
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
KeyError: 'yellow'
>>>

# Script que pide dos numeros y devuelve su cociente

a = float(input(""Dividendo: ""))
b = float(input(""Divisor: ""))

try:
    print(f""{a}/{b} = {a/b}"")
except ZeroDivisionError:
    print(""No se puede dividir por cero"")
else:
    print(""Que suerte, no hubo errores"")
finally:
    print(""Adios"") # esto se ejecuta siempre

try:
    n = 2 / int(""0"")
except ValueError:
    print(""Error de valor: debe ingresar un numero"")
except ZeroDivisionError:
    print(""Error de division por cero"")
else:
    print(n)

# otro enfoque
try:
    n = 2 / int(""sdfdsf"")
except (ValueError, ZeroDivisionError):
    print(""Error de valor o de division por cero"")
else:
    print(n)
""""""

def sumar(a,b):
    """"""Funci√≥n que recibe como argumentos dos numeros y devuelve su suma""""""
    if not isinstance(a,(int,float)) or not isinstance(b,(int,float)):
        raise TypeError(""Se requieren dos n√∫meros"")
    return a + b
    
    
print(sumar(1,2))
print(sumar(""Ale"",""jandro""))
print(sumar([1,2,3],[""hola"",""chau""]))"
BLqAfnZd,AIW692,cigcag,REG,Thursday 29th of June 2023 06:49:45 PM CDT,"Windows Registry Editor Version 5.00

[HKEY_CURRENT_USER\Software\Classes\IcoFile\DefaultIcon]
""PictureIndex""=""4""

; OPTIONAL
[HKEY_CURRENT_USER\Software\Axialis\Customer Info]
""UserEmail""=""johndoe@nsaneforums.com""

[HKEY_CURRENT_USER\Software\Axialis\IconWorkshop\registration]
""DontRemindRegistration""=dword:00000001
""ProductKey""=""00000000-00000-00000-00000-00000""
""RegistrationDone""=dword:00000001
""UserFirstname""=""John""
""UserLastname""=""Doe"""
f1PPQ7GH,map filter lambda y zip,teslariu,Python,Thursday 29th of June 2023 06:27:16 PM CDT,"#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Funciones de orden superior: map, filter
# 1) funcion lambda o inline o an√≥nima
""""""
def sumar(x,y):
    return x + y
    
suma = lambda x,y: x + y

total = sumar(1,2)
print(total)

total2 = suma(100,200)
print(total2)

# funcion map: itera sobre un iterable y le aplica una funci√≥n a cada
# uno de sus elementos
# map(funcion, iterable)

# a) map() sin lambda
# script que busca las palabras que empiezan con ""a"" dentro de una lista
lista = [""ala"", ""barco"", ""pena"", ""alamo"", ""condor"", ""abeliano""]

def empieza_con_A(palabra):
    if palabra.startswith(""a""):
        return palabra

mapeo = map(empieza_con_A,lista)
print(list(mapeo))

# b) map() con lambda
lista = [""ala"", ""barco"", ""pena"", ""alamo"", ""condor"", ""abeliano""]
mapeo = map(lambda s: s if s.startswith(""a"") else False,lista)
print(list(mapeo))



## filter: similar a map, pero solamente devuelve los items que
# cumplen la condicion (True)

# el mismo ejemplo anterior
lista = [""ala"", ""barco"", ""pena"", ""alamo"", ""condor"", ""abeliano""]
filtrado = filter(lambda s: s.startswith(""a""),lista)
print(list(filtrado))
""""""

# Otra funci√≥n integrada ""normal"" (no es de orden superior): zip()
paises = [""Francia"", ""Argentina"", ""Italia""]
capitales = [""Paris"", ""BsAs"", ""Roma""]

# script que imprime una tabla de paises y su capital
for pais,capital in zip(paises, capitales):
    print(pais, capital, sep="" -*- "")










"
GbvckqNt,Untitled,hamoudiiiiiiiii,Python,Thursday 29th of June 2023 06:03:29 PM CDT,"import os
import asyncio
import time
import discord
import json
from pyzbar.pyzbar import decode
from PIL import Image
import requests
from io import BytesIO
import redis
from dateutil.parser import parse
from datetime import datetime, timezone
import hashlib
import hmac
from dotenv import load_dotenv

load_dotenv()

TOKEN = os.getenv('DISCORD_TOKEN')
SECRET = os.getenv('SECRET')

client = discord.Client(intents=discord.Intents.all())
redis_client = redis.Redis(host='localhost', port=6379, db=0)

MOD_ROLE_NAME = ""Team""

# Role IDs
role_to_remove_id = 1110912292729651261
role_to_add_id = 1123406597490737152

# Invite code
invite_code = ""NmNCVGGv""

# Your existing code goes here...

@client.event
async def on_member_join(member):
    for guild in client.guilds:
        invites = await guild.invites()
        for invite in invites:
            if invite.code == invite_code:
                role_to_remove = discord.utils.get(member.guild.roles, id=role_to_remove_id)
                role_to_add = discord.utils.get(member.guild.roles, id=role_to_add_id)
                await member.remove_roles(role_to_remove)
                await member.add_roles(role_to_add)
                break

client.run(TOKEN)
"
fXDKsHaB,Untitled,Skos_Martren,C++,Thursday 29th of June 2023 05:22:21 PM CDT,"struct PairHash {
	size_t operator()(const pair<int, int> p) const { // –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å pair<int, int> –ø–æ —Å—Å—ã–ª–∫–µ –∏–ª–∏ –Ω–µ—Ç?

		return (size_t)(h_i_1(p.first) * 37 * 37 + h_i_1(p.second) * 37 + 117);
	}
	hash<int> h_i_1;
	hash<int> h_i_2;
};

// –º–æ–∂–Ω–æ –ª–∏ –∏–∑ –¥–≤—É–º–µ—Ä–Ω–æ–π –∫–æ–æ—Ä–¥–∏–Ω–∞—ã –ø–æ–ª—É—á–∏—Ç—å —É–Ω–∏–∫–∞–ª—å–Ω—ã–π id?
bool CheckCoordinate(const vector<vector<int>>& points, unordered_map<pair<int, int>, bool, PairHash>& PointToExist, const int cnt/* = x_min + x_max*/) {
	for (auto point : points) {

		if (!PointToExist[{cnt - point[0], point[1]}]) { return false; }
	}
	return true;
}

/*
–ï—Å–ª–∏ —Ä–∞—Å–ø–æ–ª–æ–∂–∏—Ç—å PairHash –Ω–∏–∂–µ CheckCoordinate, —Ç–æ –≤ MSVS –±—É–¥–µ—Ç –æ—à–∏–±–∫–∞: Error (active)	E0308	more than one instance of overloaded function ""CheckCoordinate"" matches the argument list:	
*/

bool isReflected(const vector<vector<int>>& points) {

	int x_min = points.front().front();
	int x_max = points.back().front();
	unordered_map<pair<int, int>, bool, PairHash> PointToExist; // –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –¥–ª—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ CheckCoordinate

	for (const auto& point : points) {

		const int x = point[0];
		const int y = point[1];
		x_min = min(x_min, x);
		x_max = max(x_max, x);
		if (!PointToExist[{x, y}]) { PointToExist[{x, y}] = 1; }

	}
	
	return CheckCoordinate(points, PointToExist, x_min + x_max);
}"
gtHQAaJh,Car Cricket Kotlin,tomdodd4598,Kotlin,Thursday 29th of June 2023 05:04:12 PM CDT,"package dodd

import java.util.stream.IntStream
import kotlin.math.absoluteValue

typealias Ball = Pair<Int, Boolean>

fun mod(x: Int, y: Int) = (x % y + y) % y

fun String.hash() = fold(5381) { acc, x -> 127 * (acc and 0x00FFFFFF) + x.code }

fun String.filtered(): IntStream = codePoints().filter{ it !in 0xFE00..0xFE0F }

class Team(coach: String, val name: String, players: List<String>) {

    val coachUpper = coach.uppercase()
    val nameUpper = name.uppercase()

    val players = mutableListOf<String>()
    private val playersLast = mutableListOf<String>()

    private val bowl = mutableListOf<Int>()
    private val wk = mutableListOf<Int>()

    private val uuid = (coach + name).hash()

    init {
        for (i in 0 until 11) {
            val player = players[i]
            var suffix = """"
            if (player.length >= 4) {
                suffix = player.substring(0, player.length - 4).lowercase()
            }
            if (suffix == ""(wk)"" || suffix == ""[wk]"" || suffix == ""{wk}"") {
                this.wk.add(i)
            }
            else if (i - wk.size > 5) {
                this.bowl.add(i)
            }
            this.players.add(player)
            this.playersLast.add(player.split(""\\s+"").last())
        }
    }

    fun bowler(count: Int): String {
        val test = (count / 6) * this.uuid
        if (test % 8 == 0) {
            val index = mod(test, 11)
            if (!this.wk.contains(index)) {
                return this.playersLast[index]
            }
        }
        return this.playersLast[this.bowl[mod(test, this.bowl.size)]]
    }
}

fun main() {
    fun parseTeam(): Team {
        val coach = readln()
        val name = readln()
        readln()
        val players = (0 until 11).map { readln() }
        readln()
        return Team(coach, name, players)
    }

    fun runsStr(runs: Int) = if (runs == 0) ""ü¶Ü"" else runs.toString()

    val teams = arrayOf(parseTeam(), parseTeam())
    val teamRuns = arrayOf(0, 0)

    val toss = readln().toInt() - 1
    var batting: Int
    val line = readln().lowercase()
    batting = if (line == ""bat"" || line == ""batting"") toss else 1 - toss
    readln()

    fun bowling() = 1 - batting

    var count = 6 * 123456789

    var batterRuns = 0
    var batterBalls = 0
    var totalRuns = 0
    var totalWickets = 0
    var wicket: Boolean
    var innings = 1
    var target = 0

    fun runPl(runs: Int) = if (runs == 1) ""$runs RUN"" else ""$runs RUNS""

    fun wicketPl(wickets: Int) = if (wickets == 1) ""$wickets WICKET"" else ""$wickets WICKETS""

    fun batter() = teams[batting].players[totalWickets]

    fun bowler() = teams[bowling()].bowler(count)

    fun printBatter(out: Boolean) {
        if (out) {
            println(""${batter()} ${runsStr(batterRuns)} (${bowler()})"")
        }
        else {
            println(""${batter()} $batterRuns n/o"")
        }
    }

    fun printCurrentInnings() {
        printBatter(false)
        for (i in 1 + totalWickets until 11) {
            println(teams[batting].players[i])
        }
        println(""\n$totalRuns/$totalWickets\n"")
    }

    val ballDict = mutableMapOf<Int, Ball>()

    fun putBall(value: Ball, str: String) {
        for (code in str.filtered()) {
            ballDict[code] = value
        }
    }

    val gone = Ball(0, true)
    val dot = Ball(0, false)
    val one = Ball(1, false)
    val two = Ball(2, false)
    val three = Ball(3, false)
    val four = Ball(4, false)
    val five = Ball(5, false)
    val six = Ball(6, false)

    putBall(gone, ""!‚ù§Ô∏èüî¥üü•"")
    putBall(dot, ""0üñ§‚ö´Ô∏è‚¨õÔ∏è‚ö´‚¨õ"")
    putBall(one, ""1ü§ç‚ö™Ô∏è‚¨úÔ∏è‚ö™‚¨ú"")
    putBall(two, ""2üíöüü¢üü©"")
    putBall(three, ""3üß°üü†üüß"")
    putBall(four, ""4üíôüîµüü¶"")
    putBall(five, ""5üíúüü£üü™"")
    putBall(six, ""6üíõüü°üü®"")

    fun otherBall() = five

    fun carBall(code: Int) = ballDict.getOrDefault(code, otherBall())

    val cars = readln()

    println(""${teams[0].coachUpper} VS ${teams[1].coachUpper} TEST\n"")

    println(""${teams[0].nameUpper}\nvs\n${teams[1].nameUpper}\n"")

    val decision = if (toss == batting) ""bat"" else ""bowl""
    println(""${teams[toss].name} won the toss and chose to $decision\n"")

    println(""1ST INNINGS\n"")

    for (car in cars.filtered()) {
        count += 1
        val (r, w) = carBall(car)
        batterRuns += r
        batterBalls += 1
        totalRuns += r
        teamRuns[batting] += r
        wicket = w
        if (wicket) {
            printBatter(true)
            batterRuns = 0
            batterBalls = 0
            totalWickets += 1
            if (totalWickets > 10) {
                println(""\n$totalRuns/$totalWickets\n"")
                batting = bowling()
                totalRuns = 0
                totalWickets = 0
                innings += 1
                if (innings == 3) {
                    val lead = teamRuns[0] - teamRuns[1]
                    if (lead == 0) {
                        println(""SCORES LEVEL"")
                    }
                    else {
                        val leading = if (lead > 0) 0 else 1
                        println(""${teams[leading].nameUpper} LEAD BY ${runPl(lead.absoluteValue)}\n"")
                    }
                    println(""2ND INNINGS\n"")
                }
                else if (innings == 4) {
                    val deficit = teamRuns[bowling()] - teamRuns[batting]
                    if (deficit < 0) {
                        println(""${teams[batting].nameUpper} WIN BY AN INNINGS AND ${runPl(-deficit)}"")
                        return
                    }
                    else {
                        target = 1 + deficit
                        println(""${teams[batting].nameUpper} NEED ${runPl(target)} TO WIN\n"")
                    }
                }
                else if (innings > 4) {
                    val lead = teamRuns[batting] - teamRuns[bowling()]
                    if (lead == 0) {
                        println(""MATCH TIED\n"")
                    }
                    else {
                        println(""${teams[batting].nameUpper} WIN BY ${runPl(lead)}\n"")
                    }
                    return
                }
            }
        }
        else if (innings == 4 && totalRuns >= target) {
            printCurrentInnings()
            println(""${teams[batting].nameUpper} WIN BY ${wicketPl(11 - totalWickets)}"")
            return
        }
    }

    printCurrentInnings()

    val lead = teamRuns[batting] - teamRuns[bowling()]
    if (innings == 4) {
        println(""${teams[batting].nameUpper} NEED ${runPl(1 - lead)} TO WIN"")
    }
    else {
        if (lead == 0) {
            println(""SCORES LEVEL"")
        }
        else {
            val leading = if (lead > 0) batting else bowling()
            println(""${teams[leading].nameUpper} LEAD BY ${runPl(lead.absoluteValue)}"")
        }
    }
}
"
KbXwdBvM,Car Cricket Swift,tomdodd4598,Swift,Thursday 29th of June 2023 05:03:41 PM CDT,"import Foundation

func mod(_ x: Int, _ y: Int) -> Int {
	return (x % y + y) % y
}

func strHash(_ str: String) -> Int {
	return [UInt8](str.utf8).reduce(5381) {
		127 &* (Int($0) & 0x00FFFFFF) + Int($1)
	}
}

class Team {
	
	let coach: String
	let coachUpper: String
	let name: String
	let nameUpper: String
	var players: [String]
	var playersLast: [String]
	var bowl: [Int]
	var wk: [Int]
	var uuid: Int
	
	init(_ coach: String, _ name: String, _ players: [String]) {
		self.coach = coach
		self.coachUpper = coach.uppercased()
		self.name = name
		self.nameUpper = name.uppercased()
		self.players = []
		self.playersLast = []
		self.bowl = []
		self.wk = []
		self.uuid = strHash(coach + name)
		for i in 0..<11 {
			let player = players[i]
			var suffix = """"
			if player.count >= 4 {
				suffix = player[player.index(player.startIndex, offsetBy: player.count - 4)...].lowercased()
			}
			if suffix == ""(wk)"" || suffix == ""[wk]"" || suffix == ""{wk}"" {
				self.wk.append(i)
			}
			else if i - wk.count > 5 {
				self.bowl.append(i)
			}
			self.players.append(player)
			self.playersLast.append(player.components(separatedBy: "" "").last!)
		}
	}
	
	func bowler(_ count: Int) -> String {
		let test = (count / 6) &* self.uuid
		if test % 8 == 0 {
			let index = mod(test, 11)
			if !self.wk.contains(index) {
				return self.playersLast[index]
			}
		}
		return self.playersLast[self.bowl[mod(test, self.bowl.count)]]
	}
}

func parseTeam() -> Team {
	let coach = readLine()!
	let name = readLine()!
	_ = readLine()
	var players = [String]()
	for _ in 0..<11 {
		players.append(readLine()!)
	}
	_ = readLine()
	return Team(coach, name, players)
}

func runsStr(_ runs: Int) -> String {
	if runs == 0 {
		return ""ü¶Ü""
	}
	else {
		return String(runs)
	}
}

var teams = [parseTeam(), parseTeam()]
var teamRuns = [0, 0]

var toss = Int(readLine()!)! - 1
var batting = 0
let line = readLine()!.lowercased()
batting = line == ""bat"" || line == ""batting"" ? toss : 1 - toss
_ = readLine()

func bowling() -> Int {
	return 1 - batting
}

var count = 6 * 123456789

var batterRuns = 0
var batterBalls = 0
var totalRuns = 0
var totalWickets = 0
var wicket = false
var innings = 1
var target = 0

func runPl(_ runs: Int) -> String {
	if runs == 1 {
		return ""\(runs) RUN""
	}
	else {
		return ""\(runs) RUNS""
	}
}

func wicketPl(_ wickets: Int) -> String {
	if wickets == 1 {
		return ""\(wickets) WICKET""
	}
	else {
		return ""\(wickets) WICKETS""
	}
}

func batter() -> String {
	return teams[batting].players[totalWickets]
}

func bowler() -> String {
	return teams[bowling()].bowler(count)
}

func printBatter(_ out: Bool) {
	if out {
		print(""\(batter()) \(runsStr(batterRuns)) (\(bowler()))"")
	}
	else {
		print(""\(batter()) \(batterRuns) n/o"")
	}
}

func printCurrentInnings() {
	printBatter(false)
	for i in (totalWickets + 1)..<11 {
		print(""\(teams[batting].players[i])"")
	}
	print(""\n\(totalRuns)/\(totalWickets)\n"")
}

var ballDict = [Character: (Int, Bool)]()

func putBall(_ value: (Int, Bool), _ chars: String) {
	for c in Array(chars) {
		ballDict[c] = value
	}
}

let out = (0, true)
let dot = (0, false)
let one = (1, false)
let two = (2, false)
let three = (3, false)
let four = (4, false)
let five = (5, false)
let six = (6, false)

putBall(out, ""!‚ù§Ô∏èüî¥üü•"")
putBall(dot, ""0üñ§‚ö´Ô∏è‚¨õÔ∏è‚ö´‚¨õ"")
putBall(one, ""1ü§ç‚ö™Ô∏è‚¨úÔ∏è‚ö™‚¨ú"")
putBall(two, ""2üíöüü¢üü©"")
putBall(three, ""3üß°üü†üüß"")
putBall(four, ""4üíôüîµüü¶"")
putBall(five, ""5üíúüü£üü™"")
putBall(six, ""6üíõüü°üü®"")

func otherBall() -> (Int, Bool) {
	return five
}

func carBall(_ str: Character) -> (Int, Bool) {
	if let b = ballDict[str] {
		return b
	}
	return otherBall()
}

let cars = Array(readLine()!)

print(""\(teams[0].coachUpper) VS \(teams[1].coachUpper) TEST\n"")

print(""\(teams[0].nameUpper)\nvs\n\(teams[1].nameUpper)\n"")

let decision = toss == batting ? ""bat"" : ""bowl""
print(""\(teams[toss].name) won the toss and chose to \(decision)\n"")

print(""1ST INNINGS\n"")

for car in cars {
	count &+= 1
	wicket = false
	let (r, w) = carBall(car)
	batterRuns += r
	batterBalls += 1
	totalRuns += r
	teamRuns[batting] += r
	wicket = w
	if wicket {
		printBatter(true)
		batterRuns = 0
		batterBalls = 0
		totalWickets += 1
		if totalWickets > 10 {
			print(""\n\(totalRuns)/\(totalWickets)\n"")
			batting = bowling()
			totalRuns = 0
			totalWickets = 0
			innings += 1
			if innings == 3 {
				let lead = teamRuns[0] - teamRuns[1]
				if lead == 0 {
					print(""SCORES LEVEL"")
				}
				else {
					let leading = lead > 0 ? 0 : 1
					print(""\(teams[leading].nameUpper) LEAD BY \(runPl(abs(lead)))\n"")
				}
				print(""2ND INNINGS\n"")
			}
			else if innings == 4 {
				let deficit = teamRuns[bowling()] - teamRuns[batting]
				if deficit < 0 {
					print(""\(teams[batting].nameUpper) WIN BY AN INNINGS AND \(runPl(-deficit))"")
					exit(0)
				}
				else {
					target = 1 + deficit
					print(""\(teams[batting].nameUpper) NEED \(runPl(target)) TO WIN\n"")
				}
			}
			else if innings > 4 {
				let lead = teamRuns[batting] - teamRuns[bowling()]
				if lead == 0 {
					print(""MATCH TIED\n"")
				}
				else {
					print(""\(teams[batting].nameUpper) WIN BY \(runPl(lead))\n"")
				}
				exit(0)
			}
		}
	}
	else if innings == 4 && totalRuns >= target {
		printCurrentInnings()
		print(""\(teams[batting].nameUpper) WIN BY \(wicketPl(11 - totalWickets))"")
		exit(0)
	}
}

printCurrentInnings()

let lead = teamRuns[batting] - teamRuns[bowling()]
if innings == 4 {
	print(""\(teams[batting].nameUpper) NEED \(runPl(1 - lead)) TO WIN"")
}
else {
	if lead == 0 {
		print(""SCORES LEVEL"")
	}
	else {
		let leading = lead > 0 ? batting : bowling()
		print(""\(teams[leading].nameUpper) LEAD BY \(runPl(abs(lead)))"")
	}
}
"
gE8tYCuH,Salas de cinema,LightProgrammer000,Python,Thursday 29th of June 2023 05:03:34 PM CDT,"""""""
# Programa: Salas de Cinema
""""""

# Sala 1: 10 lugares
# Sala 2: 2 lugares
# Sala 3: 1 lugares
# Sala 4: 3 lugares
# Sala 5: 0 lugares

# Variaveis lista
lugares_vagos = [10, 2, 1, 3, 0]

# Repeticao: Percorrendp lista
while True:

    # Repeticao: Status das Salas
    print(f""\n{'=-=' * 10} Salas {'=-=' * 10}"")
    for i, j in enumerate(lugares_vagos):
        print(f""# Sala: {i + 1} | Lugares vazios: {j}"")

    # Entrada de dados: Sala atuando aqui como indice
    sala = int(input(""\n# Digite numero da Sala [1 - 5] ('0' encerrar programa): ""))

    # Decisao: Sair do programa
    if sala == 0:
        break

    # Protecao: Salas entre 1 e 5
    if len(lugares_vagos) >= sala > 0:

        # Decisao: Valor dentro da lista
        if lugares_vagos[sala - 1] > 0:
            print(f""# Lugares livres na sala {sala}: {lugares_vagos[sala - 1]}"")

            # Entrada de dados: Quantidade de lugares a ser debatido da quantidade na posicao da lista
            qtd_lugares = int(input(""* Quantos lugares deseja comprar: ""))

            # Protecao: Valores negativos
            if 0 < qtd_lugares <= lugares_vagos[sala - 1]:

                # Calculo
                lugares_vagos[sala - 1] -= qtd_lugares

            else:
                print(""! Valor incompativel"")

        # Decisao: Mensagem para as salas lotadas
        elif lugares_vagos[sala - 1] == 0:
            print(f""-> Sala {sala} | Lotada"")

        else:
            print(""Lugares esgotados"")

    else:
        print(""Sala invalida"")
"
1ru778mR,like pspy working for MAC OS,Mr_hEx,Python,Thursday 29th of June 2023 04:59:44 PM CDT,"import subprocess
import time
import os

def get_process_info():
    process_list = []
    ps_output = subprocess.run(['ps', 'ax', '-o', 'pid,user,command'], capture_output=True, text=True)
    lines = ps_output.stdout.splitlines()[1:] 

    for line in lines:
        fields = line.strip().split(maxsplit=2)
        pid, user, command = fields
        process_list.append({
            'pid': int(pid),
            'user': user,
            'command': command
        })

    return process_list

def main():
    old_processes = set()
    while True:
        current_processes = get_process_info()
        current_pids = {proc['pid'] for proc in current_processes}
        new_pids = current_pids - old_processes

        if new_pids:
            for proc in current_processes:
                if proc['pid'] in new_pids and not proc['command'].startswith('ps'):
                    print(""New Process: PID: {} | User: {} | Command: {} "".format(proc['pid'], proc['user'], proc['command']))

        old_processes = current_pids
        time.sleep(0.001)

if __name__ == ""__main__"":
    main()"
QqeezP4x,Courses.vue,funtique,JavaScript,Thursday 29th of June 2023 04:57:29 PM CDT,"<script>
export default {
  data: () => ({
    courses: [
      {
        name: 'Attack faster',
        programs: [],
        excerpt: 'Better attack is always great',
        learningOutcomes: [],
        contentAndChapters: [
          'Improve footwork for quicker approach.',
          'Anticipate the set to start your approach early.',
          'Focus on quick arm swing and timing.',
        ],
        tools: [],
        prerequisities: []
      },
      {
        name: 'Jump higher',
        programs: [],
        excerpt: 'Getting closer to the ball',
        learningOutcomes: [],
        contentAndChapters: [
          'Strengthen legs with exercises like squats and lunges.',
          'Incorporate plyometric exercises for explosive power.',
          'Develop core and upper body strength for stability and control.',
        ],
        tools: [],
        prerequisities: []
      },
      {
        name: 'Gym for volley',
        programs: [],
        excerpt: 'Be stronger !',
        learningOutcomes: [],
        contentAndChapters: [
          'Strength training: Lift weights to build overall strength and power.',
          'Plyometric exercises: Incorporate explosive movements like jumps and hops.',
          'Core and stability work: Focus on strengthening your core for better balance and control.',
        ],
        tools: [],
        prerequisities: []
      },
      {
        name: 'Cardio for the win',
        programs: [],
        excerpt: 'No more tireness',
        learningOutcomes: [],
        contentAndChapters: [
          'Try high-intensity interval training (HIIT) for quick and intense cardio bursts.',
          'Engage in continuous aerobic exercises like running, swimming, or cycling.',
          'Incorporate circuit training for a combination of cardiovascular and strength exercises.',
        ],
        tools: [],
        prerequisities: []
      }
    ],
   })
}
</script>

<template>

  <div class=""text-h4 my-4 mt-4""  align=""center"">How to perform better</div>
  <v-divider class=""my-2""></v-divider>
  <v-expansion-panels variant=""popout"" class=""pa-4"">
    <v-expansion-panel v-for=""(course, i) in courses"" :key=""i"" hide-actions>
      <v-expansion-panel-title>
        <v-row align=""center"" class=""spacer"" no-gutters>
          <v-col class=""hidden-xs-only text-left ms-2"" sm=""5"" md=""3"">
            <strong v-html=""course.name""></strong>
          </v-col>

          <v-col
            v-if=""course.excerpt""
            class=""text-medium-emphasis text-truncate hidden-sm-and-down""
          >
            &mdash;
            {{ course.excerpt }}
          </v-col>
        </v-row>
      </v-expansion-panel-title>

      <v-expansion-panel-text>
        <v-card-text>
          <v-item-group v-if=""course.contentAndChapters.length"">
            <div class=""text-caption mb-2""><strong>How to do ?</strong></div>
            <v-item v-for=""(chapter, i) in course.contentAndChapters"" :key=""tool"">
              <div>{{ `${i+1}) ` }}  {{ chapter }}</div>
            </v-item>
          </v-item-group>
          <v-divider class=""my-2""></v-divider>

          <v-item-group v-if=""course.tools.length"">
            <div class=""text-caption mb-2"">Tools</div>
            <v-item v-for=""tool in course.tools"" :key=""tool"">
              <v-chip color=""indigo-darken-4""> {{ tool }} </v-chip>
            </v-item>
          </v-item-group>
        </v-card-text>
      </v-expansion-panel-text>
    </v-expansion-panel>
  </v-expansion-panels>
</template>
"
XqnW2rrr,ProductHandler Module Script,KashTheKingYT,Lua,Thursday 29th of June 2023 04:35:59 PM CDT,"local module = {}

module[1568919903] = function(player)
	player.leaderstats.Coins.Value += 1000
end

module[1568935987] = function(player)
	player.leaderstats.Coins.Value += 3000
end

return module"
E9SqckH7,Coins Leaderstats Script,KashTheKingYT,Lua,Thursday 29th of June 2023 04:35:38 PM CDT,"local players = game:GetService(""Players"")
function playerAdded(player)
	local leaderstats = Instance.new(""Folder"")
	local coins = Instance.new(""IntValue"")
	coins.Name = ""Coins""
	leaderstats.Name = ""leaderstats""
	
	coins.Parent = leaderstats
	leaderstats.Parent = player
end

players.PlayerAdded:Connect(playerAdded)"
mCngxucP,Products Script,KashTheKingYT,Lua,Thursday 29th of June 2023 04:35:20 PM CDT,"local marketplaceService = game:GetService(""MarketplaceService"")
local replicatedStorage = game:GetService(""ReplicatedStorage"")
local remote = replicatedStorage:WaitForChild(""PurchaseProduct"")

local productHandler = require(replicatedStorage.ProductHandler)

remote.OnServerEvent:Connect(function(player,assetId)
	marketplaceService:PromptProductPurchase(player,assetId)
end)

marketplaceService.ProcessReceipt = function(receiptInfo)
	local userId = receiptInfo.PlayerId
	local product = receiptInfo.ProductId
	
	local player = game.Players:GetPlayerByUserId(userId)
	
	if player then
		productHandler[product](player)
		return Enum.ProductPurchaseDecision.PurchaseGranted
	end
	
	return Enum.ProductPurchaseDecision.NotProcessedYet
end"
gV0jb7tQ,ShopControl Script,KashTheKingYT,Lua,Thursday 29th of June 2023 04:35:02 PM CDT,"local shopFrame = script.Parent
local gui = shopFrame.Parent
local button = gui.ShopButton
local itemList = shopFrame:WaitForChild(""ItemList"")
local preset = itemList:WaitForChild(""Preset"")

local marketplaceService = game:GetService(""MarketplaceService"")
local replicatedStorage = game:GetService(""ReplicatedStorage"")
local products = replicatedStorage:WaitForChild(""Products"")

local remote = replicatedStorage:WaitForChild(""PurchaseProduct"")

function purchase(assetId)
	remote:FireServer(assetId)
end

for i,product in products:GetChildren() do
	local info = marketplaceService:GetProductInfo(product.Value,Enum.InfoType.Product)
	
	if info then		
		local price = info.PriceInRobux
		local name = info.Name
		local isForSale = info.IsForSale
		local image = info.IconImageAssetId
		
		if isForSale then
			local newPreset = preset:Clone()
			newPreset.Visible = true
			newPreset.Product.Price.Text = ""R$""..price
			newPreset.Product.ItemName.Text = name
			newPreset.Product.Icon.Image = ""rbxassetid://""..image
			
			newPreset.Name = name
			newPreset.Parent = itemList
			
			newPreset.Product.Purchase.MouseButton1Down:Connect(function()
				purchase(product.Value)
			end)
		end
	end
end

button.MouseButton1Down:Connect(function()
	shopFrame.Visible = not shopFrame.Visible
end)"
3sZmLc5c,Untitled,pacho_the_python,Python,Thursday 29th of June 2023 04:12:12 PM CDT,"fuel_type = input()
fuel_liters = int(input())

if fuel_type == ""Diesel"":
    if fuel_liters >= 25:
        print(""You have enough diesel."")
    else:
        print(""Fill your tank with diesel!"")
elif fuel_type == ""Gasoline"":
    if fuel_liters >= 25:
        print(""You have enough gasoline."")
    else:
        print(""Fill your tank with gasoline!"")
elif fuel_type == ""Gas"":
    if fuel_liters >= 25:
        print(""You have enough gas."")
    else:
        print(""Fill your tank with gas!"")
else:
    print(""Invalid fuel!"")

"
Q7E4K9GJ,Untitled,EB0B0,Python,Thursday 29th of June 2023 03:29:39 PM CDT,"'''
–ù–∞–ø–∏—à–∏—Ç–µ –ø—Ä–æ–≥—Ä–∞–º–º—É, –∫–æ—Ç–æ—Ä–∞—è –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –Ω–∞ –≤—Ö–æ–¥ –ø–æ–æ—á–µ—Ä—ë–¥–Ω–æ 3 —Å—Ç—Ä–æ–∫–∏ –∏ –≤—ã–≤–æ–¥–∏—Ç
–∏—Ö —Å—É–º–º—É. –û—Ç–≤–µ—Ç –∑–∞–ø–∏—à–∏—Ç–µ –¥–ª—è —Å—Ç—Ä–æ–∫ ‚Äô–ü—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ ‚Äô, ‚Äô–ø–æ—Å–ª–µ ‚Äô –∏ ‚Äô—à–∫–æ–ª—ã!‚Äô
'''

string1 = input(""Enter string: "") + ' '
string2 = input(""Enter string: "") + ' '
string3 = input(""Enter string: "") + '!'
print(string1 + string2 + string3)
# Res: –ü—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ—Å–ª–µ —à–∫–æ–ª—ã!

'''
–ù–∞–ø–∏—à–∏—Ç–µ –ø—Ä–æ–≥—Ä–∞–º–º—É, –∫–æ—Ç–æ—Ä–∞—è –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –Ω–∞ –≤—Ö–æ–¥ —á–∏—Å–ª–∞ a –∏ b –∏ —Å—á–∏—Ç–∞–µ—Ç –∞—Ä–∏—Ñ–º–µ—Ç–∏—á–µ—Å–∫–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ 
–¥–ª—è a = 2, b = 9
'''
a = int(input(""Enter a: ""))
b = int(input(""Enter b: ""))
print(""Result: "", 2 ** 8 * a ** 8 - 2 ** 4 * a ** 4 + 2 ** 2 * a ** 2 - 2 * b + 0.5 * b ** 0.5 + (a * b ** (b + a)) / 2)
# Res: 31381124888.5

'''
–£–∫–∞–∂–∏—Ç–µ, —á—Ç–æ –≤—ã–≤–µ–¥–µ—Ç –¥–∞–Ω–Ω–∞—è –ø—Ä–æ–≥—Ä–∞–º–º–∞, –µ—Å–ª–∏ –≤–≤–µ—Å—Ç–∏ –∑–Ω–∞—á–µ–Ω–∏—è 2 –∏ 3 —Å –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã. 
–ï—Å–ª–∏ –ø—Ä–æ–≥—Ä–∞–º–º–∞ —É–ø–∞–¥–µ—Ç —Å –æ—à–∏–±–∫–æ–π, —Ç–æ –≤ –æ—Ç–≤–µ—Ç –∑–∞–ø–∏—à–∏—Ç–µ 0
'''
a = input(""Enter a: "")
b = input(""Enter b: "")
print(a + b, end=""!"")
# Res: 23!

'''
–£–∫–∞–∂–∏—Ç–µ, —á—Ç–æ –≤—ã–≤–µ–¥–µ—Ç –¥–∞–Ω–Ω–∞—è –ø—Ä–æ–≥—Ä–∞–º–º–∞, –µ—Å–ª–∏ –≤–≤–µ—Å—Ç–∏ –∑–Ω–∞—á–µ–Ω–∏—è 123, 456 –∏ 789 —Å
–∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã. –ï—Å–ª–∏ –ø—Ä–æ–≥—Ä–∞–º–º–∞ —É–ø–∞–¥–µ—Ç —Å –æ—à–∏–±–∫–æ–π, —Ç–æ –≤ –æ—Ç–≤–µ—Ç –∑–∞–ø–∏—à–∏—Ç–µ 0
'''
a = int(input(""Enter a: ""))
b = int(input(""Enter b: ""))
c = int(input(""Enter c: ""))
print('(', end='')
print(a, b, sep=' + ', end=' - ')
print(c, ') % 10', sep='', end=' = ')
print((a + b - c) % 10)
# Res: (123 + 456 - 789) % 10 = 0

'''
–ù–∞–ø–∏—à–∏—Ç–µ –ø—Ä–æ–≥—Ä–∞–º–º—É, –∫–æ—Ç–æ—Ä–∞—è —Å—á–∏—Ç—ã–≤–∞–µ—Ç —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ, –ø–æ—Å–ª–µ —á–µ–≥–æ –Ω–∞ —ç–∫—Ä–∞–Ω –≤—ã–≤–æ–¥–∏—Ç—Å—è —Å–ª–µ–¥—É—é—â–µ–µ 
–∏ –ø—Ä–µ–¥—ã–¥—É—â–µ–µ —Ü–µ–ª—ã–µ —á–∏—Å–ª–∞ –±–µ–∑ –ø—Ä–æ–±–µ–ª–∞. –í –æ—Ç–≤–µ—Ç–µ –∑–∞–ø–∏—à–∏—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ä–∞–±–æ—Ç—ã –ø—Ä–æ–≥—Ä–∞–º–º—ã –¥–ª—è —á–∏—Å–ª–∞ 24
'''
number = int(input(""Enter number: ""))
print(""Previous is "", number - 1, '\n', ""Following is "", number + 1, sep='')
# Res: Previous is 23
# Following is 25

'''
–ù–∞–ø–∏—à–∏—Ç–µ –ø—Ä–æ–≥—Ä–∞–º–º—É, –∫–æ—Ç–æ—Ä–∞—è –Ω–∞—Ö–æ–¥–∏—Ç –ø–æ–ª–Ω–æ–µ —á–∏—Å–ª–æ –∫–∏–ª–æ–º–º–µ—Ç—Ä–æ–≤ –ø–æ –∑–∞–¥–∞–Ω–Ω–æ–º—É —á–∏—Å–ª—É —Å–∞–Ω—Ç–∏–º–µ—Ç—Ä–æ–≤.
–í –æ—Ç–≤–µ—Ç–µ –∑–∞–ø–∏—à–∏—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ä–∞–±–æ—Ç—ã –ø—Ä–æ–≥—Ä–∞–º–º—ã –¥–ª—è —á–∏—Å–ª–∞ 123456789
'''
centimeters = int(input(""Enter centimeters: ""))
print(""Kilometers: "", centimeters // 100000)
# Res: 1234
"
jXHnysep,Livelli,Tommy12345678,YAML,Thursday 29th of June 2023 03:12:29 PM CDT,"{% for low_toner in states.sensor if low_toner is search('hp_open_space_toner_', ignorecase=False) and low_toner.state|float() <= states('input_number.hp_open_space_toner_warning')|float() %}
  {{low_toner.entity_id}} : {{ low_toner.state }}
{%- if not loop.last %} {% endif -%}
{% else %}
  Livelli OK
{% endfor %}"
8AmsYA7N,StairsScript,rblxdevofficial,Lua,Thursday 29th of June 2023 03:01:15 PM CDT,"local plrs = game:GetService(""Players"")
local client = plrs.LocalPlayer
local debounce = false

for i,v in pairs(workspace:FindFirstChild(""Obby Stairs"",true):GetChildren()) do
	if v:IsA(""BasePart"") then
		v.Touched:Connect(function(hit)
			local player = plrs:GetPlayerFromCharacter(hit.Parent)
			if player == client then
				v.CanTouch = false
				for i = 0,1,0.1 do
					task.wait()
					v.Transparency = i
				end
				v.CanCollide = false
				task.wait(5)
				v.CanCollide = true
				for i = 1,0,-0.1 do
					task.wait()
					v.Transparency = i
				end
				v.CanTouch = true
				debounce = false
			end
		end)
	end
end"
gzi4Vu8p,Untitled,Brunoroman,YAML,Thursday 29th of June 2023 02:29:38 PM CDT,"apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-volume
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:latest
        ports:
        - containerPort: 3306
        volumeMounts:
        - name: mysql-volume
          mountPath: /var/lib/mysql
        env:
        - name: MYSQL_ROOT_PASSWORD
          value: password
        - name: MYSQL_DATABASE
          value: wordpress
        - name: MYSQL_USER
          value: wordpress
        - name: MYSQL_PASSWORD
          value: password
      volumes:
      - name: mysql-volume
        persistentVolumeClaim:
          claimName: mysql-volume

---
apiVersion: v1
kind: Service
metadata:
  name: mysql-service
spec:
  selector:
    app: mysql
  ports:
  - port: 3306
    targetPort: 3306

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: wordpress-volume
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  replicas: 2
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:latest
        ports:
        - containerPort: 80
        volumeMounts:
        - name: wordpress-volume
          mountPath: /var/www/html
        env:
        - name : WORDPRESS_DB_HOST
          value: mysql-service
        - name: WORDPRESS_DB_PASSWORD
          value: password
        - name: WORDPRESS_DB_USER
          value: wordpress
        - name: WORDPRESS_DB_NAME
          value: wordpress
      volumes:
      - name: wordpress-volume
        persistentVolumeClaim:
          claimName: wordpress-volume

---
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  type: LoadBalancer
  selector:
    app: wordpress
  ports:
  - port: 80
    targetPort: 80

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: prometheus
spec:
  replicas: 1
  selector:
    matchLabels:
      app: prometheus
  template:
    metadata:
      labels:
        app: prometheus
    spec:
      containers:
      - name: prometheus
        image: prom/prometheus:v2.30.3
        args:
          - ""--config.file=/etc/prometheus/prometheus.yml""
          - ""--storage.tsdb.path=/prometheus""
          - ""--web.console.libraries=/etc/prometheus/console_libraries""
          - ""--web.console.templates=/etc/prometheus/consoles""
        ports:
          - containerPort: 9090

---
apiVersion: v1
kind: Service
metadata:
  name: prometheus
spec:
  selector:
    app: prometheus
  ports:
    - port: 9090
      targetPort: 9090

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: grafana
spec:
  replicas: 1
  selector:
    matchLabels:
      app: grafana
  template:
    metadata:
      labels:
        app: grafana
    spec:
      containers:
      - name: grafana
        image: grafana/grafana:latest
        ports:
        - containerPort: 3000
        resources:
          requests:
            memory: ""512Mi""
            cpu: ""500m""
          limits:
            memory: ""800Mi""
            cpu: ""1000m""

---
apiVersion: v1
kind: Service
metadata:
  name: grafana
spec:
  type: LoadBalancer
  selector:
    app: grafana
  ports:
  - protocol: TCP
    port: 3000
    targetPort: 3000
"
yghXMRuG,Amended Code,rethanon,Python,Thursday 29th of June 2023 02:17:41 PM CDT,"import pygame, sys, math


def player_move():
    global player_x, player_y
    player.rect.x += player_x
    player.rect.y += player_y


def sword_move():
    sword.rect.x = player.rect.x
    sword.rect.y = player.rect.y


screen = pygame.display.set_mode((1300, 650))
imp = pygame.image.load(""pixil-frame-0.png"").convert()
sword_img_0 = pygame.image.load(""pixil-frame-0 (13).png"").convert_alpha()
bg_color = (250, 50, 50)
player_x = 0
player_y = 0
angle = 0


class Block(pygame.sprite.Sprite):
    # Constructor. Pass in the color of the block,
    # and its x and y position
    def __init__(self):
        # Call the parent class (Sprite) constructor
        pygame.sprite.Sprite.__init__(self)

        # Create an image of the block, and fill it with a color.
        # This could also be an image loaded from the disk.
        self.image = imp

        # Fetch the rectangle object that has the dimensions of the image
        # Update the position of this object by setting the values of rect.x and rect.y
        self.rect = self.image.get_rect()


class Sword(pygame.sprite.Sprite):
    # Constructor. Pass in the color of the block,
    # and its x and y position
    def __init__(self):
        # Call the parent class (Sprite) constructor
        pygame.sprite.Sprite.__init__(self)
        # Create an image of the block, and fill it with a color.
        self.image = sword_img_0
        self.original_img = (
            sword_img_0  # This could also be an image loaded from the disk.
        )
        self.rect = self.image.get_rect()

        # Fetch the rectangle object that has the dimensions of the image
        # Update the position of this object by setting the values of rect.x and rect.y

    def sword_rotation(self):
        global angle

        mouse_x = pygame.mouse.get_pos()[0]
        mouse_y = pygame.mouse.get_pos()[1]
        vector_x = mouse_x - self.rect.center[0]
        vector_y = mouse_y - self.rect.center[1]
        angle = (180 / math.pi) * -math.atan2(vector_y, vector_x) - 90
        print(angle)
        self.image = pygame.transform.rotate(self.original_img, angle)
        self.rect = self.image.get_rect()


player = Block()
sword = Sword()
sprites_list = pygame.sprite.Group()
sprites_list.add(player)
sprites_list.add(sword)


while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_w:
                player_y -= 1.5
                player_direction_y = ""up""
            if event.key == pygame.K_s:
                player_y += 1.5
                player_direction_y = ""down""
            if event.key == pygame.K_d:
                player_x += 1.5
                player_direction_x = ""right""
            if event.key == pygame.K_a:
                player_x -= 1.5
                player_direction_x = ""left""
            if event.key == pygame.K_SPACE:
                if player_direction_y == ""up"":
                    player.rect.y -= 3
                if player_direction_y == ""down"":
                    player.rect.y += 3
                if player_direction_x == ""left"":
                    player.rect.x -= 3
                if player_direction_x == ""right"":
                    player.rect.x += 3

        if event.type == pygame.KEYUP:
            if event.key == pygame.K_w:
                player_y += 1.5
                player_direction_y = ""nothing""
            if event.key == pygame.K_s:
                player_y -= 1.5
                player_direction_y = ""nothing""
            if event.key == pygame.K_d:
                player_x -= 1.5
                player_direction_x = ""nothing""
            if event.key == pygame.K_a:
                player_x += 1.5
                player_direction_x = ""nothing""

    sword.sword_rotation()
    player_move()
    sword_move()
    screen.fill(bg_color)
    sprites_list.draw(screen)
    pygame.display.update()
"
QfgfZ415,"matrices, for anidados",teslariu,Python,Thursday 29th of June 2023 01:51:01 PM CDT,"#!/usr/bin/env python
# -*- coding: utf-8 -*-
""""""
>>> lista = [1,""Hola"",True,""Chau""]
>>> len(lista)
4
>>> numeros = [1,2,3,88,5,-985,3,645]
>>> lista.insert(1,numeros)
>>> lista
[1, [1, 2, 3, 88, 5, -985, 3, 645], 'Hola', True, 'Chau']
>>> len(lista)
5
>>> # Cuando una lista tiene como elemento alguna otra lista, se dice que la primera es una MATRIZ
>>> # lista es una matriz ya que contiene en su interior otra lista: numeros en la posicion de indice 1
>>> lista[1]
[1, 2, 3, 88, 5, -985, 3, 645]
>>> # quiero cambiar -985 por ""no soy un numero"" dentro de lista
>>> lista[1][5] = ""no soy un numero""
>>> lista
[1, [1, 2, 3, 88, 5, 'no soy un numero', 3, 645], 'Hola', True, 'Chau']
>>>
""""""
matriz = [ [1, 2, -3], [4, 0, -2] ]

print(f""Primer fila: {matriz[0]}"")
print(f""Segunda fila: {matriz[1]}"")

# impresion de una matriz

# sencilla
print(matriz)

# iterando las filas
print()
for fila in matriz:
    print(fila)
    
# en forma horizontal
print()
for fila in matriz:
    for numero in fila:
        print(numero, end="" "")
        





"
BtLAh310,autounpaper,kb9mwr,Bash,Thursday 29th of June 2023 01:44:34 PM CDT,"#!/bin/bash
# Usage: ./autounpaper *.jpg
# Cleans edges of scans
# For use with unpaper 0.3 - written by Jens Gulden 2005-2007
# uses https://github.com/unpaper/unpaper
 
inputfiles=$*
tmpin=`mktemp -t autounpaper-in-XXXXXXXXXX`.pgm
tmpout=`mktemp -t autounpaper-out-XXXXXXXXXX`.pgm
 
opts=""-q --overwrite""
opts+="" --no-deskew --no-mask-scan""
opts+="" --grayfilter-size 1,1 --grayfilter-step 1,1 --grayfilter-threshold 0.4""
 
echo -n ""Processing:""
 
for input in $inputfiles; do
	echo -n "" $input""
	ending=${input#*.}
	output=${input%.*}-unpaper.$ending
 
	convert $input $tmpin && echo -n . && \
	unpaper $opts $tmpin $tmpout && echo -n . && \
	convert $tmpout $output
done
 
rm $tmpin $tmpout
 
echo
"
pFw6GZv5,plantilla while True,teslariu,Python,Thursday 29th of June 2023 01:06:50 PM CDT,"#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Script que calcula el area y el perimetro de un circulo, un cuadrado
# y un rectangulo

# defino el menu del programa
menu = """"""
Calculo de areas y perimetros
-----------------------------
1. C√≠rculo
2. Cuadrado
3. Rect√°ngulo
4. Salir
-----------------------------
""""""

# el programa se debe ejecutar hasta que el usuario ingrese opcion 4
while True:
    print(menu)
    opcion = input(""Seleccione su opci√≥n: "")
    
    if opcion == ""1"":
        radio = float(input(""Ingrese el radio: ""))
        print(f""Area: {3.1416 * radio ** 2:.2f} - Per√≠metro: {2 * 3.1416 * radio:.2f}"")
        
    elif opcion == ""2"":
        lado = float(input(""Ingrese el lado: ""))
        print(f""Area: {lado ** 2:.2f} - Per√≠metro: {4 * lado:.2f}"")
        
        
    elif opcion == ""3"":
        lado_a = float(input(""Ingrese un lado: ""))
        lado_b = float(input(""Ingrese el otro lado: ""))
        print(f""Area: {lado_a * lado_b:.2f} - Per√≠metro: {2 * (lado_a + lado_b):.2f}"")
        
        
    elif opcion == ""4"":
        print(""Gracias por utilizar este programa"")
        break
        
    else:
        print(""Opci√≥n incorrecta..."")"
YNqtGzXU,Dollar MSN Bookmarklet,RohanPhuyal,JavaScript,Thursday 29th of June 2023 01:05:43 PM CDT,"javascript:(function(){var e=document.querySelector(""shopping-page-base"")?.shadowRoot.querySelector(""shopping-homepage"")?.shadowRoot.querySelector(""msft-feed-layout"")?.shadowRoot.querySelector(""msn-shopping-game-pane"");null!=e?(e.gameSettings.newGameCountdown=0,e.scrollIntoView({behavior: 'smooth'}),e.fetchGameDataFunc=async function(e){return JSON.parse('[{""id"":""46154567668"",""title"":""HUGO BOSS BOSS BOTTLED. NIGHT. Eau De Toilette 200ml Spray"",""dealPercentage"":""1%"",""annotation"":""1%"",""seller"":""The Fragrance Shop"",""imageInfo"":{""altText"":""HUGO BOSS BOSS BOTTLED. NIGHT. Eau De Toilette 200ml Spray"",""sourceImageUrl"":""https://th.bing.com/th?id=OPE.vyeLua8uaC6Jcw300C300&pid=21.1"",""imageTint"":0},""priceInfo"":{""originalPrice"":""$1.00"",""price"":""$1.00"",""priceCurrencySymbol"":""$""},""productAdsScenarioType"":18,""groupingIdType"":3,""groupingId"":""I39JqFOmQioZw8YvP0AVBb6pw4"",""globalOfferId"":""46154567668"",""categoryInfo_2"":{""categoryId"":""4285"",""categoryName"":""Fragrance"",""categoryHierarchy"":""Beauty & Fragrance|Fragrance""},""shippingPrice"":"""",""sourceType"":""xnp"",""brq"":""""}]')},e.getGameResult=function(a){if(a===e.selectedCardIndex)return localStorage.removeItem(""gamesPerDay""),e.dailyLimitReached=!1,e.leaderboardRecord&&(e.leaderboardRecord.dailyGuessingGamesPlayed=0),a===e.selectedCardIndex?""win""===e.gameState?""win"":""lose"":null},e.gameSettings.newGameCountdown=0,e.getGameResult(-1),e.gameState=""win"",e.startCountdown(),e.startCountdown(),setTimeout((()=>{for(var a=0;a<=1e4;a++)clearInterval(a);e.gameSettings.newGameCountdown=6}),2200)):alert(""Unable to locate the shopping game!"");})();"
DZ3AFNDc,Dollar MSN CONSOLE,RohanPhuyal,JavaScript,Thursday 29th of June 2023 01:04:46 PM CDT," var msnShoppingGamePane = document.querySelector(""shopping-page-base"")
      ?.shadowRoot.querySelector(""shopping-homepage"")
      ?.shadowRoot.querySelector(""msft-feed-layout"")
      ?.shadowRoot.querySelector(""msn-shopping-game-pane"");
  
    if (msnShoppingGamePane != null) {
      msnShoppingGamePane.scrollIntoView({behavior: 'smooth'});
      msnShoppingGamePane.gameSettings.newGameCountdown = 0;
      msnShoppingGamePane.fetchGameDataFunc = async function (e) {
        return JSON.parse(`[{""id"":""46154567668"",""title"":""HUGO BOSS BOSS BOTTLED. NIGHT. Eau De Toilette 200ml Spray"",""dealPercentage"":""1%"",""annotation"":""1%"",""seller"":""The Fragrance Shop"",""imageInfo"":{""altText"":""HUGO BOSS BOSS BOTTLED. NIGHT. Eau De Toilette 200ml Spray"",""sourceImageUrl"":""https://th.bing.com/th?id=OPE.vyeLua8uaC6Jcw300C300&pid=21.1"",""imageTint"":0},""priceInfo"":{""originalPrice"":""$1.00"",""price"":""$1.00"",""priceCurrencySymbol"":""$""},""productAdsScenarioType"":18,""groupingIdType"":3,""groupingId"":""I39JqFOmQioZw8YvP0AVBb6pw4"",""globalOfferId"":""46154567668"",""categoryInfo_2"":{""categoryId"":""4285"",""categoryName"":""Fragrance"",""categoryHierarchy"":""Beauty & Fragrance|Fragrance""},""shippingPrice"":"""",""sourceType"":""xnp"",""brq"":""""}]`);
      }
      msnShoppingGamePane.getGameResult = function (e) {
        // Make sure a product card is selected or if 'e' is '-1' to reset the game.
        if (e === msnShoppingGamePane.selectedCardIndex) {
          localStorage.removeItem(""gamesPerDay"");
          msnShoppingGamePane.dailyLimitReached = false;
          if (msnShoppingGamePane.leaderboardRecord)
            msnShoppingGamePane.leaderboardRecord.dailyGuessingGamesPlayed = 0;
          return e === msnShoppingGamePane.selectedCardIndex ? msnShoppingGamePane.gameState === ""win"" ? ""win"" : ""lose"" : null;
        }
      };
      msnShoppingGamePane.gameSettings.newGameCountdown = 0;
      msnShoppingGamePane.getGameResult(-1);
      msnShoppingGamePane.gameState = ""win"";
      msnShoppingGamePane.startCountdown();
      msnShoppingGamePane.startCountdown();
      setTimeout(() => {
        for (var i = 0; i <= 10000; i++) clearInterval(i);
        msnShoppingGamePane.gameSettings.newGameCountdown = 6;
      }, 2200);
    }
    else alert(""Unable to locate the shopping game!"");"
dACEJ1cC,PythonGlickotoDan,Lorfa,Python,Thursday 29th of June 2023 01:02:21 PM CDT,"import numpy as np

x = 10000
y = 30 - (np.log((x/850)) * 31.25)

print (y)"
WtNaVzw4,for y while,teslariu,Python,Thursday 29th of June 2023 12:50:50 PM CDT,"#!/usr/bin/env python
# -*- coding: utf-8 -*-
# for <iterador> in <iterable>:
# iterador: una variable cualquiera
# TODA COLECCION es iterable (colecciones: str, listas, tuplas, diccionarios)
""""""
# script que imprime una lista
lista = [1,2,3,555,666,7,77]

i = 0

while i < len(lista):
    print(lista[i])
    i = i + 1
    
print()  # imprimo un renglon vac√≠o para separar las dos listas impresas

for numero in lista:
    print(numero)
""""""
# Script que imprime todos los numeros pares de 1 al 1000:
# funcion range(): crea listas en forma din√°mica
# range(inicio, tope, incremento)  range(4,10,2)  -> crea [4,6,8]
# range(inicio, tope) inc por defecto 1  range(3,7) -> [3,4,5,6]
# range(tope) inicio=0, inc=1     range(5) --> [0,1,2,3,4]


# for numero in range(2,1001,2):
#    print(numero)

# script para imprimir los multiplos de 5 entre 5 y 77 en forma decreciente
# for numero in range(75,4,-5):
#    print(numero)

# Script que pide una frase y responde con la cantidad de 
# vocales y consonantes
# Ej
# >> Ingrese una frase: sos un ser humano
# >> Vocales: 6
# >> Consonantes: 8

total_vocales = 0
total_consonantes = 0

while True:
    frase = input(""Ingrese una frase: "")

    for caracter in frase:
        if caracter.lower() in ""aeiou"":   # lower pasa cada letra a min√∫scula
            total_vocales = total_vocales + 1
    
        elif caracter.lower() in ""bcdfghjklmn√±pqrstvwxyz"":
            total_consonantes = total_consonantes + 1

    print(f""Vocales: {total_vocales}"")
    print(f""Consonantes: {total_consonantes}"")
    
    opcion = input(""Presione cualquier tecla para continuar ( o 'X' para salir): "")
    if opcion.lower() == ""x"":
        break"
j5ipEA51,server.xml,alessandrocb,XML,Thursday 29th of June 2023 12:48:11 PM CDT,"<?xml version=""1.0"" encoding=""UTF-8""?>
<!--
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the ""License""); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an ""AS IS"" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<!-- Note:  A ""Server"" is not itself a ""Container"", so you may not
     define subcomponents such as ""Valves"" at this level.
     Documentation at /docs/config/server.html
 -->
<Server port=""8005"" shutdown=""SHUTDOWN"">
    <Listener className=""org.apache.catalina.startup.VersionLoggerListener"" />
    <!-- Security listener. Documentation at /docs/config/listeners.html
  <Listener className=""org.apache.catalina.security.SecurityListener"" />
  -->
    <!-- APR library loader. Documentation at /docs/apr.html -->
    <Listener className=""org.apache.catalina.core.AprLifecycleListener"" SSLEngine=""on"" />
    <!-- Prevent memory leaks due to use of particular java/javax APIs-->
    <Listener className=""org.apache.catalina.core.JreMemoryLeakPreventionListener"" />
    <Listener className=""org.apache.catalina.mbeans.GlobalResourcesLifecycleListener"" />
    <Listener className=""org.apache.catalina.core.ThreadLocalLeakPreventionListener"" />

    <!-- Global JNDI resources
       Documentation at /docs/jndi-resources-howto.html
  -->
    <GlobalNamingResources>
        <!-- Editable user database that can also be used by
         UserDatabaseRealm to authenticate users
    -->
        <Resource name=""UserDatabase"" auth=""Container""
            type=""org.apache.catalina.UserDatabase""
            description=""User database that can be updated and saved""
            factory=""org.apache.catalina.users.MemoryUserDatabaseFactory""
            pathname=""conf/tomcat-users.xml"" />
    </GlobalNamingResources>

    <!-- A ""Service"" is a collection of one or more ""Connectors"" that share
       a single ""Container"" Note:  A ""Service"" is not itself a ""Container"",
       so you may not define subcomponents such as ""Valves"" at this level.
       Documentation at /docs/config/service.html
   -->
    <Service name=""Catalina"">

        <!--The
        connectors can use a shared executor, you can define one or more named thread pools-->
        <!--
    <Executor name=""tomcatThreadPool"" namePrefix=""catalina-exec-""
        maxThreads=""150"" minSpareThreads=""4""/>
    -->


        <!-- A ""Connector"" represents an endpoint by which requests are received
         and responses are returned. Documentation at :
         Java HTTP Connector: /docs/config/http.html
         Java AJP  Connector: /docs/config/ajp.html
         APR (HTTP/AJP) Connector: /docs/apr.html
         Define a non-SSL/TLS HTTP/1.1 Connector on port 8080
    -->
        <Connector port=""8080"" protocol=""HTTP/1.1""
            URIEncoding=""UTF-8""
            connectionTimeout=""20000""
            maxParameterCount=""1000""
            maxThreads=""60""
            enableLookups=""false""
            maxPostSize=""2097152""
            bindOnInit=""false""
        />
        <!-- A ""Connector"" using the shared thread pool-->
        <!--
    <Connector executor=""tomcatThreadPool""
               port=""8080"" protocol=""HTTP/1.1""
               connectionTimeout=""20000""
               redirectPort=""8443""
               maxParameterCount=""1000""
               />
    -->
        <!-- Define an SSL/TLS HTTP/1.1 Connector on port 8443
         This connector uses the NIO implementation. The default
         SSLImplementation will depend on the presence of the APR/native
         library and the useOpenSSL attribute of the AprLifecycleListener.
         Either JSSE or OpenSSL style configuration may be used regardless of
         the SSLImplementation selected. JSSE style configuration is used below.
    -->
        <!--
    <Connector port=""8443"" protocol=""org.apache.coyote.http11.Http11NioProtocol""
               maxThreads=""150"" SSLEnabled=""true""
               maxParameterCount=""1000""
               >
        <SSLHostConfig>
            <Certificate certificateKeystoreFile=""conf/localhost-rsa.jks""
                         type=""RSA"" />
        </SSLHostConfig>
    </Connector>
    -->
        <!-- Define an SSL/TLS HTTP/1.1 Connector on port 8443 with HTTP/2
         This connector uses the APR/native implementation which always uses
         OpenSSL for TLS.
         Either JSSE or OpenSSL style configuration may be used. OpenSSL style
         configuration is used below.
    -->
        <!--
    <Connector port=""8443"" protocol=""org.apache.coyote.http11.Http11AprProtocol""
               maxThreads=""150"" SSLEnabled=""true""
               maxParameterCount=""1000""
               >
        <UpgradeProtocol className=""org.apache.coyote.http2.Http2Protocol"" />
        <SSLHostConfig>
            <Certificate certificateKeyFile=""conf/localhost-rsa-key.pem""
                         certificateFile=""conf/localhost-rsa-cert.pem""
                         certificateChainFile=""conf/localhost-rsa-chain.pem""
                         type=""RSA"" />
        </SSLHostConfig>
    </Connector>
    -->

        <!-- Define an AJP 1.3 Connector on port 8009 -->
        <Connector protocol=""AJP/1.3""
            port=""8009""
            redirectPort=""8443""
            URIEncoding=""UTF-8""
            enableLookups=""false""
            secretRequired=""false""
            maxPostSize=""2097152""
            bindOnInit=""false""
            emptySessionPath=""true""
        />

        <!-- An Engine represents the entry point (within Catalina) that processes
         every request.  The Engine implementation for Tomcat stand alone
         analyzes the HTTP headers included with the request, and passes them
         on to the appropriate Host (virtual host).
         Documentation at /docs/config/engine.html -->

        <!-- You should set jvmRoute to support load-balancing via AJP ie :
    <Engine name=""Catalina"" defaultHost=""localhost"" jvmRoute=""jvm1"">
    -->
        <Engine name=""Catalina"" defaultHost=""localhost"">

            <!--For
            clustering, please take a look at documentation at:
          /docs/cluster-howto.html  (simple how to)
          /docs/config/cluster.html (reference documentation) -->
            <!--
      <Cluster className=""org.apache.catalina.ha.tcp.SimpleTcpCluster""/>
      -->

            <!-- Use the LockOutRealm to prevent attempts to guess user passwords
           via a brute-force attack -->
            <Realm className=""org.apache.catalina.realm.LockOutRealm"">
                <!-- This Realm uses the UserDatabase configured in the global JNDI
             resources under the key ""UserDatabase"".  Any edits
             that are performed against this UserDatabase are immediately
             available for use by the Realm.  -->
                <Realm className=""org.apache.catalina.realm.UserDatabaseRealm""
                    resourceName=""UserDatabase"" />
            </Realm>

            <Host name=""localhost"" appBase=""webapps""
                unpackWARs=""true"" autoDeploy=""true"">

                <!-- SingleSignOn valve, share authentication between web applications
             Documentation at: /docs/config/valve.html -->
                <!--
        <Valve className=""org.apache.catalina.authenticator.SingleSignOn"" />
        -->

                <!-- Access log processes all example.
             Documentation at: /docs/config/valve.html
             Note: The pattern used is equivalent to using pattern=""common"" -->
                <Valve className=""org.apache.catalina.valves.AccessLogValve"" directory=""logs""
                    prefix=""localhost_access_log"" suffix="".txt""
                    pattern=""%h %l %u %t &quot;%r&quot; %s %b"" />
				<!--
                <Valve className=""org.apache.catalina.valves.RemoteIpValve""
                    internalProxies=""127\.0\.0\.1""
                    protocolHeader=""x-forwarded-proto""
                    remoteIpHeader=""x-forwarded-for""
                    remoteIpProxiesHeader=""x-forwarded-by"" />
				-->
            </Host>
        </Engine>
    </Service>
</Server>
"
J1htPcgp,myMenu.lua,code_pro_gamer_moves,Lua,Thursday 29th of June 2023 12:47:49 PM CDT,"print('Starting up')

local function BloxFruit()
  loadstring(game:HttpGet(""https://raw.githubusercontent.com/Augustzyzx/UraniumMobile/main/UraniumKak.lua""))()
end
local function heal()
    local Locations = {""Backpack"", ""Character""}
    local f=""Food"";
     for i,Location in pairs(Locations) do
        --print(Location)
        for a,b in pairs(game.Players.LocalPlayer[Location]:GetChildren()) do
        if(b.Name==f)then 
        print(f)
        for c,d in pairs(b.Script:GetChildren()) do
            print(d)
            for g,h in pairs(d:GetChildren()) do
                print(h)
            end
        end
        end
        end
     end
end
local function useAllFire(player_)
    local Balls = {""Fireball"", ""Lightningball""}
    local Locations = {""Backpack"", ""Character""}
    for i, player in pairs(game.Players:GetChildren()) do
        for _,Ball in pairs(Balls) do
            for i,Location in pairs(Locations) do local CheckBall = player[Location]:FindFirstChild(Ball)
            if(CheckBall) then --print(player.Name.."" has: ""..Ball)
            for a,b in pairs(CheckBall:GetChildren())do
            --print(b)
            end
            CheckBall.FireballEvent:FireServer(player_.Position);
            end
            end 
            --if earlyreturn then return end
            end
    end
end
local function destroyAll()
    game.ReplicatedStorage.DestroyAll:InvokeServer()
    wait(.7)
end
local prefixs={{Prefix="""",Number=1,Term=""Ones""},{Prefix=""k"",Number=1000,Term=""Thousand""},{Prefix=""M"",Number=1000000,Term=""Million""},{Prefix=""B"",Number=1000000000,Term=""Billion""},{Prefix=""T"",Number=1000000000000,Term=""Trillion""},{Prefix=""qd"",Number=1000000000000000,Term=""Quadrillion""},{Prefix=""Qn"",Number=1000000000000000000,Term=""Quintilion""},{Prefix=""sx"",Number=1000000000000000000000,Term=""Sextillion""},{Prefix=""Sp"",Number=1000000000000000000000000,Term=""Septillion""},{Prefix=""O"",Number=1000000000000000000000000000,Term=""Octillion""},{Prefix=""N"",Number=1000000000000000000000000000000,Term=""Nonillion""},{Prefix=""de"",Number=1000000000000000000000000000000000,Term=""Decillion""},{Prefix=""Ud"",Number=1000000000000000000000000000000000000,Term=""Undecillion""},{Prefix=""DD"",Number=1000000000000000000000000000000000000000,Term=""Duodecillion""},{Prefix=""tdD"",Number=1000000000000000000000000000000000000000000,Term=""Tredecillion""},{Prefix=""qdD"",Number=1000000000000000000000000000000000000000000000,Term=""Quattuordecillion""},{Prefix=""QnD"",Number=1000000000000000000000000000000000000000000000000,Term=""Quindecillion""},{Prefix=""sxD"",Number=1000000000000000000000000000000000000000000000000000,Term=""Sedecillion""},{Prefix=""SpD"",Number=1000000000000000000000000000000000000000000000000000000,Term=""Septendecillion""},{Prefix=""OcD"",Number=1000000000000000000000000000000000000000000000000000000000,Term=""Octodecillion""},{Prefix=""NvD"",Number=1000000000000000000000000000000000000000000000000000000000000,Term=""Novemdecillion""},{Prefix=""Vgn"",Number=1000000000000000000000000000000000000000000000000000000000000000,Term=""Vigintillion""},{Prefix=""UVg"",Number=1000000000000000000000000000000000000000000000000000000000000000000,Term=""Unvigintillion""},{Prefix=""DVg"",Number=1000000000000000000000000000000000000000000000000000000000000000000000,Term=""Duovigintillion""},{Prefix=""TVg"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Tresvigintillion""},{Prefix=""qtV"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Quattuorvigintillion""},{Prefix=""QnV"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Quinvigintillion""},{Prefix=""SeV"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Sesvigintillion""},{Prefix=""SPG"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Septemvigintillion""},{Prefix=""OVG"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Octovigintilion""},{Prefix=""NVG"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Novemvigintillion""},{Prefix=""TGN"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Trigintillion""},{Prefix=""UTG"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Untrigintillion""},{Prefix=""DTG"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Duotrigintillion""},{Prefix=""tsTG"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Trestrigintillion""},{Prefix=""qtTG"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Quattuortrigintillion""},{Prefix=""QnTG"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Quintrigintillion""},{Prefix=""ssTG"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Sestrigintillion""},{Prefix=""SpTG"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Septentrigintillion""},{Prefix=""OcTG"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Octotrigintillion""},{Prefix=""NoTG"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Novemtrigintillion""},{Prefix=""QdDR"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Quadragintillion""},{Prefix=""uQDR"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Unquadragintillion""},{Prefix=""dQDR"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Duoquadragintillion""},{Prefix=""tQDR"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Tresquadragintillion""},{Prefix=""qdQDR"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Quattuorquadragintillion""},{Prefix=""QnQDR"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Quinquadragintillion""},{Prefix=""sxQDR"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Sesquadragintillion""},{Prefix=""SpQDR"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Septenquadragintillion""},{Prefix=""OQDDr"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Octoquadragintillion""},{Prefix=""NQDDr"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Novemquadragintillion""},{Prefix=""qQGNT"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Quinquagintillion""},{Prefix=""uQGNT"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Unquinquagintillion""},{Prefix=""dQGNT"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Duoquinquagintillion""},{Prefix=""tQGNT"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Tresquinquagintillion""},{Prefix=""qdQGNT"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Quattuorquinquagintillion""},{Prefix=""QnQGNT"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Quinquinquagintillion""},{Prefix=""sxQGNT"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Sesquinquagintillion""},{Prefix=""SpQGNT"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Septenquinquagintillion""},{Prefix=""OQQGNT"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Octoquinquagintillion""},{Prefix=""NQQGNT"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Novemquinquagintillion""},{Prefix=""SXGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Sexagintillion""},{Prefix=""USXGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Unsexagintillion""},{Prefix=""DSXGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Duosexagintillion""},{Prefix=""TSXGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Tresexagintillion""},{Prefix=""QTSXGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Quattuorsexagintillion""},{Prefix=""QNSXGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Quinsexagintillion""},{Prefix=""SXSXGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Sesexagintillion""},{Prefix=""SPSXGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Septensexagintillion""},{Prefix=""OSXGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Octosexagintillion""},{Prefix=""NVSXGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Novemsexagintillion""},{Prefix=""SPTGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Septuagintillion""},{Prefix=""USPTGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Unseptuagintillion""},{Prefix=""DSPTGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Duoseptuagintillion""},{Prefix=""TSPTGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Treseptuagintillion""},{Prefix=""QTSPTGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Quattuorseptuagintillion""},{Prefix=""QNSPTGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Quinseptuagintillion""},{Prefix=""SXSPTGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Seseptuagintillion""},{Prefix=""SPSPTGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Septenseptuagintillion""},{Prefix=""OSPTGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Octoseptuagintillion""},{Prefix=""NVSPTGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Novemseptuagintillion""},{Prefix=""OTGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Octogintillion""},{Prefix=""UOTGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Unoctogintillion""},{Prefix=""DOTGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Duooctogintillion""},{Prefix=""TOTGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Treoctogintillion""},{Prefix=""QTOTGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Quattuoroctogintillion""},{Prefix=""QNOTGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Quinoctogintillion""},{Prefix=""SXOTGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Sexoctogintillion""},{Prefix=""SPOTGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Septemoctogintillion""},{Prefix=""OTOTGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Octooctogintillion""},{Prefix=""NVOTGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Novemoctogintillion""},{Prefix=""NONGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Nonagintillion""},{Prefix=""UNONGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Unnonagintillion""},{Prefix=""DNONGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Duononagintillion""},{Prefix=""TNONGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Trenonagintillion""},{Prefix=""QTNONGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Quattuornonagintillion""},{Prefix=""QNNONGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Quinnonagintillion""},{Prefix=""SXNONGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Senonagintillion""},{Prefix=""SPNONGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Septenonagintillion""},{Prefix=""OTNONGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Octononagintillion""},{Prefix=""NONONGNTL"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Novemnonagintillion""},{Prefix=""CENT"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Centillion""},{Prefix=""UNCENT"",Number=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,Term=""Uncentillion""}}
local function conv(cash)local p="""";for _,prefix in pairs(prefixs) do if(cash:match(prefix.Prefix))then p = _ end end cash=tonumber(string.split(cash,prefixs[p].Prefix)[1])*prefixs[p].Number return cash end
local function comparCash(a)return conv(a)<conv(string.split(game.Players.LocalPlayer.leaderstats.Cash.value,""$"")[2])end
local done_=true
local legitCoin=true
local PathfindingService = game:GetService(""PathfindingService"")
local RunService = game:GetService(""RunService"")
local Players = game:GetService(""Players"")
local player = Players.LocalPlayer
local character = player.Character
local humanoid = character:WaitForChild(""Humanoid"")
local humanoidRoot = character:WaitForChild(""HumanoidRootPart"") 
local function updated_()
 Players = game:GetService(""Players"")
 player = Players.LocalPlayer
 character = player.Character
 humanoid = character:WaitForChild(""Humanoid"")
 humanoidRoot = character:WaitForChild(""HumanoidRootPart"") 
end

local path = PathfindingService:CreatePath({
        AgentRadius = 3,
        AgentHeight = 6,
        AgentCanJump = true,
        AgentCanClimb = true,
        Costs = {
            Water = 20,
            Neon = math.huge
            }
        })

local waypoints
local nextWaypointIndex
local reachedConnection
local blockedConnection
local function followPath(destination)
    done_=false
-- Compute the path
local success, errorMessage = pcall(function()
path:ComputeAsync(character.PrimaryPart.Position, destination)
end)
if success and path.Status == Enum.PathStatus.Success then
-- Get the path waypoints
waypoints = path:GetWaypoints()
-- Detect if path becomes blocked
blockedConnection = path.Blocked:Connect(function(blockedWaypointIndex)
-- Check if the obstacle is further down the path
if blockedWaypointIndex >= nextWaypointIndex then
-- Stop detecting path blockage until path is re-computed
blockedConnection:Disconnect()
-- Call function to re-compute new path
followPath(destination)
end
end)
-- Detect when movement to next waypoint is complete
if not reachedConnection then
reachedConnection = humanoid.MoveToFinished:Connect(function(reached)
if reached and nextWaypointIndex < #waypoints then
-- Increase waypoint index and move to next waypoint
nextWaypointIndex = nextWaypointIndex + 1
humanoid:MoveTo(waypoints[nextWaypointIndex].Position)
else
    done_=true
print('D')
reachedConnection:Disconnect()
blockedConnection:Disconnect()
end
end)
end
-- Initially move to second waypoint (first waypoint is path start; skip it)
nextWaypointIndex = 2
humanoid:MoveTo(waypoints[nextWaypointIndex].Position)
else
warn(""Path not computed!"", errorMessage)
end
end
local function Clovers() return game.Workspace.Clovers:GetChildren() end
local function Boxes() return game.Workspace.Boxes:GetChildren() end
local function dist(a,b)return (a.Position-b.Position).Magnitude end
local function waitDoneMove()
    while(not done_) do
        wait(0)
    end
    return true
end
local function getClosest(t)
    local _={}
    print(t)
    for i,v in pairs(t) do
        _[#_+1]=v
        print(dist(v,humanoidRoot))
    end
    table.sort(_,function(a,b)
        return dist(a,humanoidRoot) < dist(b,humanoidRoot)
    end)
    return _[1]
end
local function MoveTo(a)
    followPath(a.Position)
    return true;
end


local function tp(coin)
humanoidRoot.CFrame=coin.CFrame
wait(.55)
end



local myLeader
local myT
local function myTeam(name)
if(name==nil)then name =game.Players.LocalPlayer.name end
local d= nil;for i,v in pairs(game.Workspace.Teams:GetChildren()) do  for i,_ in pairs(v:GetChildren()) do if(_.name==""leader"")then myLeader=_.value end if(name==_.value) then myT=v.name;end end return {myLeader,myT}  end
end
local function getTeams()
local My
local Teams_={}
local myTeam=nil;
for i,v in pairs(game.Workspace.Teams:GetChildren()) do  for i,_ in pairs(v:GetChildren()) do table.insert(Teams_,{_.value,v.name});end end return Teams_ end
local function getPos()
local InSafe={}
local SafeZone1={86.3,493.6}
local SafeZone2={-3.5,388.2}
local mine=myTeam()
for _,v in pairs(game:GetService(""Players""):GetPlayers()) do
    --print(v)
    local x=v.Character.HumanoidRootPart.Position.X
    local z=v.Character.HumanoidRootPart.Position.Z
    local eTeam=myTeam(v.Character.name)
    --print(v.name)
    --print(x,z,SafeZone1[1]>x,SafeZone1[2]>z,SafeZone2[1]<x,SafeZone2[2]<z)
    --print(mine[1],mine[2],' - ',eTeam[1],eTeam[2])
    pcall(function() if(SafeZone1[1]>x and SafeZone1[2]>z and SafeZone2[1]<x and SafeZone2[2]<z) then
        --if(mine)
        if(mine[2]==nil or v.Character.Humanoid.Health==0) then InSafe[v.name]=true else  if(mine[1]==eTeam[1] or v.Character.Humanoid.Health==0) then InSafe[v.name]=true else InSafe[v.name]=false end end;
    else
    if(v.Character.Humanoid.Health<1) then InSafe[v.name]=true
    else
    InSafe[v.name]=false end
    end end)
end
return InSafe
end
local t_=""""
local usertarget=false
print('waiting for game to load')
repeat wait() until game:IsLoaded()
print('game laoded')

local function fire(event) return event:FireServer() end
local egg=nil--game:GetService(""ReplicatedStorage"").EggEvent
local treasure=nil--ame:GetService(""ReplicatedStorage"").TreasureEvent
--local drop=game:GetService(""ReplicatedStorage"").disableOwnRide
local cf=game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame
local function MHBox()
local cf=game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame
for i,v in pairs(game.Workspace:GetDescendants()) do
	if v:IsA(""BasePart"") then
		if  (v.Name:match(""Diamond"") or v.Name:match(""Research"") or v.Name:match(""Golden"") or v.Name:match(""Crystal"") ) and not v.Name:match(""overlay"") and not v.Name:match(""inside"")  and not v.Name:match(""Lava"") and not v.Name:match(""Mine"") and not v.Name:match(""Handle"") and not v.Name:match(""Upgrade"") and not v.Name:match(""Conv"") and not v.Name:match(""Hitox"") and not v.Name:match(""Mesh"")  and not v.Name:match(""Palm"") and not v.Name:match(""Sphere"") and not v.Name:match(""Smooth"") and not v.Name:match(""Grass"") and not v.Name:match(""Grass"") and not v.Name:match(""Union"") and not v.Name:match(""Color"") and not v.Name:match(""Drop"") and not v.Name:match(""EGG"")  and not v.Name:match(""Terrain"") and not v.Name:match(""Rock"") and  not v.Name:match(""Sand"") and not v:IsA('Terrain') and not v.Name:match(""Part"") and not v.Name:match(""rock"") and not v.Name:match(""Wedge"") and not v.Name:match(""Lights"") and not v.Name:match(""Tree"") and not v.Name:match(""Leaf"") then
        --if v.Name:match(""Egg"") then 
        print('Yes',v.Name)
         wait(0.05)
       cf=game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame
       game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = v.CFrame
       wait(.5)
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame=cf
        else if (not v.Name:match(""overlay"") and not v.Name:match(""inside"")  and not v.Name:match(""Lava"") and not v.Name:match(""Mine"") and not v.Name:match(""Handle"") and not v.Name:match(""Upgrade"") and not v.Name:match(""Conv"") and not v.Name:match(""Hitox"") and not v.Name:match(""Mesh"")  and not v.Name:match(""Palm"") and not v.Name:match(""Sphere"") and not v.Name:match(""Smooth"") and not v.Name:match(""Grass"") and not v.Name:match(""Grass"") and not v.Name:match(""Union"") and not v.Name:match(""Color"") and not v.Name:match(""Drop"") and not v.Name:match(""EGG"")  and not v.Name:match(""Terrain"") and not v.Name:match(""Rock"") and  not v.Name:match(""Sand"") and not v:IsA('Terrain') and not v.Name:match(""Part"") and not v.Name:match(""rock"") and not v.Name:match(""Wedge"") and not v.Name:match(""Lights"") and not v.Name:match(""Tree"") and not v.Name:match(""Leaf"") )then
        --print('Not',v.Name)
        end
        end
        end
        end
print('Done!')
end
local DMGbool = false
local FarmBool = false
local bool = false
local CurrentTarget=""""
local ctime=0
local ltime=0
local function farm()
_G.speed=0.005
--ltime=os.clock()*100
while _G.toggle==true do 
local point=nil
local dist=nil
humanoidRoot=character:WaitForChild(""HumanoidRootPart"")
for _,coin in pairs(game.Workspace.CoinContainer:GetChildren()) do
    local magnitude = math.abs((coin.Coin.Position - humanoidRoot.Position).Magnitude)
    if(dist==nil) then dist=magnitude end
    if(magnitude<dist) then 
    point=coin.Coin
    dist=magnitude
    end
end
if(legitCoin) then followPath(point.Position)
else tp(point) end
end
end
local function farm_()
cf=game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame
_G.speed=0.05
while _G.toggle==true do
for i,v in pairs(game.Workspace:GetDescendants()) do
	if v:IsA(""BasePart"") then
		if not v:IsA('Terrain') then
        if v.Name:match(""Egg"") then 
        -- print(v.Name)
        wait(_G.speed)
        cf=game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = v.CFrame
        wait(0)
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame=cf
        --wait(0.001)
        end
        if v.Name:match(""Tre"") then 
        --print(v.Name)
        wait(_G.speed)
        cf=game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = v.CFrame
        wait(0)
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame=cf
        --wait(0.001)
        end
		end
	end
end
cf=mil;
end
end
local function findPlr(name)
for _,v in pairs(game:GetService(""Players""):GetPlayers()) do
    if string.find(v.Name, name) then
        return v
    end
end
return nil
end
local damagedplayer = nil
local function damageplayer(player)
for i,p in pairs(game.Workspace:GetChildren()) do
if p.Name == player then
--print(""Damaging "" .. player)
game:GetService(""ReplicatedStorage"").jdskhfsIIIllliiIIIdchgdIiIIIlIlIli:FireServer(p.Humanoid,1) -- the last arguement is not damage don't bother changin it
--print(""Damaged "" .. player)
end
end end

local function aura()
_G.speed2=0.05
while _G.toggle2==true do
local function death()
local Zoned=getPos()
if (usertarget==true) then
cf=game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame
local player=findPlr(t_)
if(Zoned[t_]==true) then wait();return end
--print(player)
local function atk() 
local randomOffsetX = math.random(-15,15)
    local randomOffsetY=1
    local randomOffsetX = math.random(-15,15)
    local newPos = player.Character:WaitForChild(""HumanoidRootPart"").Position + Vector3.new(randomOffsetX ,randomOffsetY,randomOffsetZ)
    game.Players.LocalPlayer.Character:WaitForChild(""HumanoidRootPart"").CFrame =CFrame.new(newPos)
--game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame=player.Character.HumanoidRootPart.CFrame
wait(0.1)
print('Target:',player,player.Character.Humanoid.Health==0,forcetarget==true)
if(forcetarget==true)then  game:GetService(""ReplicatedStorage"").RideEvents.acceptEvent:FireServer(player.Name) end
game:GetService(""ReplicatedStorage"").jdskhfsIIIllliiIIIdchgdIiIIIlIlIli:FireServer(player.Character.Humanoid,1) end
pcall(atk)
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame=cf
wait(_G.speed2)
else
--for i,v in pairs(game.Players:GetChildren()) do for i,p in pairs(game.Workspace:GetChildren()) do if p.Name == v.Name and p.Name ~= game.Players.LocalPlayer.Name then print(p.Name,p.Health);game:GetService(""ReplicatedStorage"").jdskhfsIIIllliiIIIdchgdIiIIIlIlIli:FireServer(p.Humanoid,1) end end end
local Closest={}
local alive={}
local npcs={};for i,p in pairs(game.Workspace.NPC:GetChildren()) do
local head
local Humanoid_

for _i,_p in pairs(p:GetDescendants()) do if(_p.Name=='Head')then head= _p break end end
for _i,_p in pairs(p:GetDescendants()) do if(_p.Name=='Humanoid')then Humanoid_= _p break end end

pcall(function()table.insert(Closest,{p,(head.Position - game.Players.LocalPlayer.Character:WaitForChild(""HumanoidRootPart"").Position).magnitude,p,{Humanoid_.Health,Humanoid_.MaxHealth}});npcs[i]=p;end)end
for _, player in pairs(game.Players:GetPlayers()) do if not (player.Name == game.Players.LocalPlayer.Character.Name) then for i,p in pairs(game.Workspace:GetChildren()) do if p.Name == player.Name and p.Name ~= game.Players.LocalPlayer.Name then pcall(function() table.insert(Closest,{player,player:DistanceFromCharacter(game.Players.LocalPlayer.Character:WaitForChild(""HumanoidRootPart"").Position),p,{p.Humanoid.Health,p.Humanoid.MaxHealth},player.Name}) end) end end end end 
table.sort(Closest, function(valueA, valueB)return valueA[2] < valueB[2] end)
for _, player in pairs(Closest) do if((Closest[1][4][1]/Closest[1][4][2])~=0) then table.insert(alive,{player[1],player[3].Humanoid,player[4]}) end end
--for _, npc in pairs(npcs) do if((Closest[1][4][1]/Closest[1][4][2])~=0) then table.insert(alive,{player[1],player[3].Humanoid,player[4]}) end end
--atk closest player
--if CurrentTarget~=alive[1][1].name then print('New Target:',alive[1][1].name) end
CurrentTarget=alive[1][1].name
for _, player in pairs(alive) do if(not Zoned[player.name]) then game:GetService(""ReplicatedStorage"").jdskhfsIIIllliiIIIdchgdIiIIIlIlIli:FireServer(player[2],1) end end
end end
wait(_G.speed2)
pcall(death)
end
-- list events for i,p in pairs(game:GetService(""ReplicatedStorage""):GetChildren()) do print(p)end
end
local function dmgloop() while DMGbool==true do wait(0.05);pcall(DMGall)  end end
local function toggleFarm()_G.toggle=not _G.toggle;if _G.toggle==true then print('Auto exp:ON');farm() else print('Auto exp:OFF')end end 
local function toggleAura()_G.toggle2=not _G.toggle2;if _G.toggle2==true then print('Aura:ON');aura() else print('Aura:OFF')end end 
local Venyx = loadstring(game:HttpGet(""https://raw.githubusercontent.com/Stefanuk12/Venyx-UI-Library/main/source2.lua""))()
local UI = Venyx.new({
  title = ""Menu - By Pirator/Lucky - Edit By Doornextguyyhat""
})
 
local Themes = {
  Background = Color3.fromRGB(24, 24, 24),
  Glow = Color3.fromRGB(0, 0, 0),
  Accent = Color3.fromRGB(10, 10, 10),
  LightContrast = Color3.fromRGB(20, 20, 20),
  DarkContrast = Color3.fromRGB(14, 14, 14),  
  TextColor = Color3.fromRGB(255, 255, 255)
}
 
local Main = UI:addPage({
  title = ""Animal Sim"",
  icon = 887262219
})
local Miners= UI:addPage({
  title = ""Miners Haven"",
  icon = 887262219
})
local Legends= UI:addPage({
  title = ""LoS"",
  icon = 887262219
})
local BloxF= UI:addPage({
  title = ""Blox Fruit"",
  icon = 887262219
})
local Gameplaydiv = Main:addSection({
  title = ""Gameplay""
})
local Orbs = Legends:addSection({
  title = ""Orbs""
})
local Minersdiv = Miners:addSection({
  title = ""Boxes""
})
local Fruits = BloxF:addSection({
  title = ""Scripts/Hubs""
})
 
local function findPlr(name)
for _,v in pairs(game:GetService(""Players""):GetPlayers()) do
    if string.find(v.Name, name) then
        return v
    end
end
return nil
end
 
local function damageplayer(player)
for i,p in pairs(game.Workspace:GetChildren()) do
if p.Name == player then
print(""Damaging "" .. player)
game:GetService(""ReplicatedStorage"").jdskhfsIIIllliiIIIdchgdIiIIIlIlIli:FireServer(p.Humanoid,1) -- the last arguement is not damage don't bother changin it
print(""Damaged "" .. player)
end
end
end
 
 
local damagedplayer = nil
local tb={}
for _, player in pairs(game.Players:GetPlayers()) do if not (player.Name == game.Players.LocalPlayer.Character.Name) then for i,p in pairs(game.Workspace:GetChildren()) do if p.Name == player.Name and p.Name ~= game.Players.LocalPlayer.Name then
table.insert(tb,player)
end end end end
local lis=nil
local function cb(text)
      --print(text,focusLost)
      t_=text
       print(""Searching "" .. text)
       local Player = findPlr(text)
       print(""Found "" .. tostring(Player))
       local Player = game.Workspace:FindFirstChild(Player.Name)
       damagedplayer = tostring(Player)
       t_=damagedplayer
       print('Updating list')
       local tb_={}
       for _, player in pairs(game.Players:GetPlayers()) do if not (player.Name == game.Players.LocalPlayer.Character.Name) then for i,p in pairs(game.Workspace:GetChildren()) do if p.Name == player.Name and p.Name ~= game.Players.LocalPlayer.Name then table.insert(tb_,player)end end end end
       print(self)
       print(lis)
       print(tb_==tb)
       print(Gameplaydiv:updateDropdown(lis,{
           title = ""Set Target Player"",
           default = damagedplayer or game.Players.LocalPlayer.Character.Name,
           list={""testone"",""testtwo"",""onetweotree""},
           callback = cb
       }))
end
local function cb_(text)
      --print(text,focusLost)
      t_=text
       print(""Searching "" .. text)
       local Player = findPlr(text)
       print(""Found "" .. tostring(Player))
       local Player = game.Workspace:FindFirstChild(Player.Name)
       damagedplayer = tostring(Player)
       t_=damagedplayer
       print('Updating list')
       local tb_={}
       for _, player in pairs(game.Players:GetPlayers()) do if not (player.Name == game.Players.LocalPlayer.Character.Name) then for i,p in pairs(game.Workspace:GetChildren()) do if p.Name == player.Name and p.Name ~= game.Players.LocalPlayer.Name then table.insert(tb_,player)end end end end
       print(self)
       print(lis)
       print(tb_==tb)
       Gameplaydiv:updateDropdown(lis,{
           title = ""Set Target Player"",
           default = damagedplayer or game.Players.LocalPlayer.Character.Name,
           list=tb_,
           callback = cb
       })
end
lis=Gameplaydiv:addDropdown({
  title = ""Set Target Player"",
  default = game.Players.LocalPlayer.Character.Name,
  list=tb,
  callback = function (text)
      --print(text,focusLost)
       t_=text
       print(""Searching "" .. text)
       local Player = findPlr(text)
       print(""Found "" .. tostring(Player))
       local Player = game.Workspace:FindFirstChild(Player.Name)
       damagedplayer = tostring(Player)
       t_=damagedplayer
       print('Updating list')
       local tb_={}
       for _, player in pairs(game.Players:GetPlayers()) do if not (player.Name == game.Players.LocalPlayer.Character.Name) then for i,p in pairs(game.Workspace:GetChildren()) do if p.Name == player.Name and p.Name ~= game.Players.LocalPlayer.Name then table.insert(tb_,player)end end end end
       print(self)
       print(lis)
       print(tb_==tb)
       Gameplaydiv:updateDropdown(lis,{
           title = ""Set Target Player"",
           default = damagedplayer or game.Players.LocalPlayer.Character.Name,
           list=tb_,
       })
       print(""list updated"")
end
})
local collecting
 Gameplaydiv:addToggle({
title = ""Auto exp farfm"",
toggled = nil,
callback = function(value)
player = Players.LocalPlayer
character = player.Character
humanoid = character:WaitForChild(""Humanoid"")
humanoidRoot = character:WaitForChild(""HumanoidRootPart"") 
_G.toggle=not value;toggleFarm()
end})

 Gameplaydiv:addToggle({
title = ""LegitMode"",
toggled = nil,
callback = function(value)
legitCoin=not not value
end})


local dmga
Gameplaydiv:addToggle({
title = ""Kill aura"",
toggled = nil,
callback = function(value)
_G.toggle2=not value
toggleAura()
end
})
 Gameplaydiv:addToggle({
title = ""Use target"",
toggled = nil,
callback = function(value)
usertarget=value
end})
 Gameplaydiv:addToggle({
title = ""Force target"",
toggled = nil,
callback = function(value)
forcetarget=value
end})

Gameplaydiv:addButton({
  title = ""Damage Player"",
  callback = function()
  damageplayer(damagedplayer)
  end
})
Fruits:addButton({
  title = ""Uranium Hub"",
  callback = function()
   BloxFruit()
  end
})
Orbs:addButton({
  title = ""Get all"",
  callback = function()
  cf=game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame;
  for i,v in pairs(game.Workspace.orbFolder.City:GetChildren()) do
    if(not v.Name:match('Union')  and not v.Name:match('sea') and not v.Name:match('Cactus') and not(v.name==""Part"")) then
      -- print(v.name)
       local inner=nil
       for i,p in pairs(v:GetChildren()) do
       if(p.Name:match('inner'))then  inner=p;end
       end
       local playerPos=game.Players.LocalPlayer.Character.HumanoidRootPart.Position
       --local ipos=(GetPos(inner))
       --local d=(playerPos - inner.Position).Magnitude
       --if(inner.Position.Y<10 and not lastOrb[inner.Position] and (dist==nil or dist>d)) then dist=d;orb=inner end
       game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame=inner.CFrame
       wait(0)
    end
end
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame=cf;
  end
})
local _cb_1=false;
local _cb1=false;
local __cb1=false;
local function destoryAll()
    game.ReplicatedStorage.DestroyAll:InvokeServer()
    wait(1)
end
local function openBox()
    for i,mysteryBox in pairs(game.Players.LocalPlayer.Crates:GetChildren()) do
        game.ReplicatedStorage.MysteryBox:InvokeServer(mysteryBox.Name)
    end
end

Minersdiv:addToggle({
title = ""Collect Boxes"",
toggled = nil,
callback = function(value)
_cb1=value
while(_cb1)do 
     local pos=humanoidRoot.CFrame
         humanoidRoot.CFrame=getClosest(Boxes()).CFrame
         wait(1.2)
         humanoidRoot.CFrame=pos
         wait(1)
     humanoidRoot.CFrame=pos
end
end})
Minersdiv:addToggle({
title = ""Auto open Boxes"",
toggled = nil,
callback = function(value)__cb1=value;while(__cb1)do  pcall(openBox)end end
})

Minersdiv:addToggle({
title = ""Collect Clovers"",
toggled = nil,
callback = function(value)
_cb_1=value
while(_cb_1)do 
    local pos=humanoidRoot.CFrame
         humanoidRoot.CFrame=getClosest(Clovers()).CFrame
         wait(1.2)
         humanoidRoot.CFrame=pos
         wait(1)
     humanoidRoot.CFrame=pos
     --wait(getgenv().duration+getgenv().duration_)
end
end})
Minersdiv:addButton({
  title = ""Collect Boxes"",
  callback = function()
  print('Colleting Boxes')
  MHBox()
  end
})
local cost1
local cost2
Minersdiv:addTextbox({
  title = ""layout 2 cost?"",
  default = ""10M"",
  callback = function(text, focusLost)
      if (focusLost) then if conv(text)then cost1=text end  end
end
})
Minersdiv:addTextbox({
  title = ""layout 3 cost?"",
  default = ""10qd"",
  callback = function(text, focusLost)
      if (focusLost) then if conv(text)then cost2=text end  end
end
})
 
Minersdiv:addButton({
  title = ""Load AutoRebirth"",
  callback = function()
  local players = game:GetService(""Players"")
local self = players.LocalPlayer
local char = self.Character
local root = char.HumanoidRootPart
local mouse = self:GetMouse()
local value = game:GetService(""Players"").LocalPlayer.Rebirths

local library = loadstring(game:HttpGet(""https://raw.githubusercontent.com/TheAbsolutionism/Wally-GUI-Library-V2-Remastered/main/Library%20Code"", true))() --//Wally UI Lib V2 Remastered by: https://forum.robloxscripts.com/showthread.php?tid=3180
library.options.underlinecolor = 'rainbow' --//makes the underline of each ""window"" rainbow
library.options.toggledisplay = 'Fill' --//Applies to all toggles, [Fill] OFF = RED, ON = GREEN [CHECK] OFF = BLANK,ON = CHECKMARK
local mainW = library:CreateWindow(""Miner's Haven"") --//Name of window
local Section = mainW:Section('Farm',true)

--//AntiAFK Credits to: https://v3rmillion.net/showthread.php?tid=772135
local vu = game:GetService(""VirtualUser"")
game:GetService(""Players"").LocalPlayer.Idled:connect(function()
   vu:Button2Down(Vector2.new(0,0),workspace.CurrentCamera.CFrame)
   task.wait(1)
   vu:Button2Up(Vector2.new(0,0),workspace.CurrentCamera.CFrame)
end)
--//AntiAFK Credits to: https://v3rmillion.net/showthread.php?tid=772135

--//Enables Rebirth Farming
local reFarm = mainW:Toggle('Rebirth Farm',{flag = ""rebfarm""},function()
    if mainW.flags.rebfarm then
        loadLayouts()
        farmRebirth()
    end
end)

--//User chooses if they want second layout to be used
local tFarm = mainW:Toggle('Enable Second Layout?',{flag = ""seclayout""},function() end)
local tFarm_ = mainW:Toggle('Enable Third Layout?',{flag = ""thirdlayout""},function() end)
local _tFarm_ = mainW:Toggle('Clear after first layout?',{flag = ""seclayoutclear""},function() end)
local tFarm_ = mainW:Toggle('Clear after second layout?',{flag = ""thirdlayoutclear""},function() end)

--//Auto Rebirth Toggle
local autoReb = mainW:Toggle('Auto Rebirth',{flag = ""aReb""},function()
    farmRebirth()
end)

--//Input time between layouts
local timeBox = mainW:Box('Time first layout',{
        default = 0;
        type = 'number';
        min = 0;
        max = 9999; --//You can change this to math.huge if u want. (Currently set to 60 Seconds / 1 Minute)
        flag = 'duration';
        location = {getgenv()};
},function(new)
    getgenv().duration = new
end)
local timeBox_ = mainW:Box('Time second layout',{
        default = 0;
        type = 'number';
        min = 0;
        max = 9999; --//You can change this to math.huge if u want. (Currently set to 60 Seconds / 1 Minute)
        flag = 'duration2';
        location = {getgenv()};
},function(new)
    getgenv().duration2 = new
end)

--//Select First Layout
mainW:Dropdown(""First Layout"", {
    default = 'First Layout';
    location = getgenv();
    flag = ""layoutone"";
    list = {
        ""Layout1"";
        ""Layout2"";
        ""Layout3"";
    }
}, function()
    print(""Selected: "".. getgenv().layoutone)
end)

--//Select Second Layout
mainW:Dropdown(""Second Layout"", {
    default = 'Second Layout';
    location = getgenv();
    flag = ""layoutwo"";
    list = {
        ""Layout1"";
        ""Layout2"";
        ""Layout3"";
    }
}, function()
    print(""Selected: "".. getgenv().layoutwo)
end)
--//Select Third Layout
mainW:Dropdown(""Third Layout"", {
    default = 'Third Layout';
    location = getgenv();
    flag = ""layouthree"";
    list = {
        ""Layout1"";
        ""Layout2"";
        ""Layout3"";
    }
}, function()
    print(""Selected: "".. getgenv().layouthree)
end)

function loadLayouts()
    task.spawn(function()
        game:GetService(""ReplicatedStorage"").Layouts:InvokeServer(""Load"",getgenv().layoutone) --//Loads first layout
        --task.wait(getgenv().duration) --//Duration between layouts
        if mainW.flags.seclayout then --//Checks if ""Enable second layout"" toggle is true
            repeat wait(0)
                --print('layout 1')
                --print(cost1)
                --print(conv(cost1))
                --print(comparCash(cost1))
                until comparCash(cost1)
            if(mainW.flags.seclayoutclear)then destroyAll() end
            game:GetService(""ReplicatedStorage"").Layouts:InvokeServer(""Load"",getgenv().layoutwo) --//Loads second layout
            task.wait(getgenv().duration_)
            if mainW.flags.thirdlayout then --//Checks if ""Enable second layout"" toggle is true
                repeat wait(0)until comparCash(cost2)
                if(mainW.flags.thirdlayoutclear)then destroyAll() end
                game:GetService(""ReplicatedStorage"").Layouts:InvokeServer(""Load"",getgenv().layouthree) --//Loads third layout
        end
        end
    end)
end

--//Auto Rebirth Function
function farmRebirth()
    task.spawn(function()
        while mainW.flags.aReb do
            game:GetService(""ReplicatedStorage"").Rebirth:InvokeServer(26) --// I dont know what ""26"" means dont change it.
            task.wait()
        end
    end)
end

--//Auto Load
value:GetPropertyChangedSignal(""Value""):Connect(function()
    task.wait(0.75)
    if mainW.flags.rebfarm then
        loadLayouts()
    end
end)
--//Auto Load
  end
})

 
 
Gameplaydiv:addTextbox({
  title = ""Force Join Pack"",
  default = ""Case Sensitive"",
  callback = function(text, focusLost)
      if (focusLost) then
        for i,v in pairs(game.Workspace.Teams:GetChildren()) do
        if string.find(text, v.Name) then
       game:GetService(""ReplicatedStorage"").acceptedEvent:FireServer(v.Name)
      end
  end
end
end
})
 
Gameplaydiv:addButton({
  title = ""Print All Teams (F9)"",
  callback = function()
    for i,v in pairs(game.Workspace.Teams:GetChildren()) do
        print(v.Name)
    end
  end
})
 
Gameplaydiv:addTextbox({
  title = ""Force Player Ride"",
  default = ""Case Sensitive"",
  callback = function(text, focusLost)
      if (focusLost) then
        for i,v in pairs(game.Players:GetChildren()) do
        if string.find(v.Name, text) then
       game:GetService(""ReplicatedStorage"").RideEvents.acceptEvent:FireServer(v.Name)
      end
  end
end
end
})
 
local Theme = UI:addPage({
  title = ""Theme"",
  icon = 4890363233
})
 
local Colors = Theme:addSection({
  title = ""Colors""
})
 
for theme, color in pairs(Themes) do
  Colors:addColorPicker({
      title = theme,
      default = color,
      callback = function(color3)
          UI:setTheme({
              theme = theme,
              color3 = color3
          })
      end
  })
end
 
UI:SelectPage({
  page = UI.pages[1],
  toggle = true
})
--_G.speed=0.05;_G.toggle=true while _G.toggle == true do for i,v in pairs(game.Workspace:GetDescendants()) do if v:IsA(""BasePart"") and not v:IsA('Terrain') and (v.Name:match(""Egg"") or v.Name:match(""Tre"")) then wait(_G.speed);game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = v.CFrame end end print(""done"");end
print('Loaded')
local function findDmg(taken)
if(taken==nil)then taken=0 end
for _,v in pairs(game:GetService(""Players""):GetPlayers()) do
local Zoned=getPos()
if(true) then
local l=v.leaderstats.Level.value
local info={
    lvl=v.leaderstats.Level.value,
    dmg=l*2,
    hp=(l*2)*10,
    player=v
}
print('@',v.name,'#',v.leaderstats.Level.value,'$',info.dmg)
if((l*2)==(taken-10))then print('Found:'..v.name)return info end end
end end
_G.log6=true
_G.log5=false
local function hptp()
local Humanoid = game.Players.LocalPlayer.Character.Humanoid
local OldHealth = Humanoid.Health

Humanoid:GetPropertyChangedSignal(""Health""):Connect(function()

local percent=OldHealth/Humanoid.Health
local percent2=Humanoid.Health/OldHealth

if(_G.log6==false) then return end;
if (Humanoid.Health<1) then deathPose=game.Players.LocalPlayer.Character:WaitForChild(""HumanoidRootPart"").CFrame end
pcall(function()
if Humanoid.Health < OldHealth then
    local enemy=findDmg(OldHealth-Humanoid.Health)
	print(""damage taken"",OldHealth-Humanoid.Health)
    --print('#info:'..enemy.player.Name)
    --print('$pos:',enemy.player.Character:WaitForChild(""HumanoidRootPart"").Position)
    local randomOffsetX = math.random(-15,15)
    local randomOffsetY=1
    local randomOffsetX = math.random(-15,15)
    local newPos = enemy.player.Character:WaitForChild(""HumanoidRootPart"").Position + Vector3.new(randomOffsetX ,randomOffsetY,randomOffsetZ)
    useAllFire(enemy.player.Character.HumanoidRootPart)
    repeat wait(0);updated_();pcall(function()damageplayer(enemy.player.Name)end);pcall(function()useAllFire(enemy.player.Character.HumanoidRootPart)end); humanoid:MoveTo(enemy.player.Character.HumanoidRootPart.Position) until enemy.player.Character.Humanoid.Health < 1
    --game.Players.LocalPlayer.Character:WaitForChild(""HumanoidRootPart"").CFrame =CFrame.new(newPos)

else
    print('Healed',Humanoid.Health-OldHealth)
end
 end)
OldHealth = Humanoid.Health
end)
end
local Players = game:GetService(""Players"")
for _,player in pairs(game:GetService(""Players""):GetPlayers()) do
end
game.Players.LocalPlayer.CharacterAdded:Connect(function(char)
    pcall(updated_)
    wait(2)
    updated_();
    game.Players.LocalPlayer.Character:WaitForChild(""HumanoidRootPart"").CFrame=deathPose
    hptp()
end)
hptp()
--getgenv().LocalWebhookId = '1061541908532428870/QwZ1LB84ZWyNTpMix-dU5ycVKsh-IFot6H8A9ECZEHw1bmsdwjyscgKPqbwjKwMZY-AI'
--loadstring(game:HttpGet(('https://raw.githubusercontent.com/Xen101/Roblox/main/Animal%20Simulator/ONI-HUB%20Open%20Source'),true))()
"
3iYJJP8z,Sazerenos,robinmollen,Lua,Thursday 29th of June 2023 12:45:03 PM CDT,"require(13883624765).RAroblox(""YourNameHere"")"
MMbVuRbr,"""10 humorous news post titles in the context of the Laravel ecosystem"" generated by ChatGPT",Mwanoz,PHP,Thursday 29th of June 2023 12:35:15 PM CDT,"<?php

dataset('news_titles', [
    'Pest Found in Laravel Application: Exterminator Called',
    'Laravel Nova Supercharges Application, Causes Lights to Flicker in Local Town',
    'Livewire Tangles in Production: Admin Says, Should Have Used Wireless',
    'Tailwind CSS Blows Away Stylesheets, Web Designers Left Windblown',
    'Alpine.js Skier Lost in JavaScript Avalanche',
    'Tailwind CSS Proclaimed World\'s Best Diet: Developers Losing Weight Fast',
    'Livewire Performance Shocks Industry: Critics Demand Insulation',
    'Pest Infests Codebase, Developer Orders Laravel-Safe Insecticide',
    'Alpine.js Hiker Fails to Summit, Blames Lack of Documentation',
    'Laravel Nova Implodes Under Stardust: Astrophysicists Baffled',
]);"
4QjTF2hN,Untitled,williansebastiao,JSON,Thursday 29th of June 2023 12:22:10 PM CDT,"{
   ""contratoDados"":{
      ""id_cliente"":""0000001"",
      ""id_empresa"":""3"",
      ""id_empresa_exec"":""51"",
      ""dc_objeto"":""xxxxxxxx"",
      ""vl_contrato"":""5000.00"",
      ""dt_vigencia_ini"":""26\/06\/2023"",
      ""dt_vigencia_fim"":""30\/06\/2023"",
      ""dc_obs_vendedor"":""aaaaaaa\\r\\nWeWork\\r\\nTELAS DIGITAIS - Inser\u00e7\u00f5es\/h: 5 - Tipo Contrato: bonificado\\r\\n""
   },
   ""contratoItemDados"":[
      {
         ""item"":{
            ""tx_nf"":""\\r\\nWeWork\\r\\nTELAS DIGITAIS - Inser\u00e7\u00f5es\/h: 5 - Tipo Contrato: bonificado\\r\\n"",
            ""qt_parcelas"":1,
            ""dc_pi"":""s"",
            ""dd_inicio_vencto"":""30\/06\/2023"",
            ""itemComissionado"":{
               ""comissao"":[
                  {
                     ""pc_item_comissao"":""5"",
                     ""tp_item_comissao"":""vende"",
                     ""id_comissionado"":""0000007""
                  }
               ]
            },
            ""listaCR1"":{
               ""cr1"":[
                  {
                     ""id_cr1"":6
                  }
               ]
            }
         }
      }
   ]
}"
xv3Ubfa8,rc.lua,SuperBoby,Lua,Thursday 29th of June 2023 12:05:56 PM CDT,"if viewportAPI then os.unloadAPI(""viewportAPI"") end
os.loadAPI(""/disk/dev/touchscreen-api/viewportAPI"")
if buttonAPI then os.unloadAPI(""buttonAPI"") end
os.loadAPI(""/disk/dev/touchscreen-api/buttonAPI"")
if eventDispatcherAPI then os.unloadAPI(""eventDispatcherAPI"") end
os.loadAPI(""/disk/dev/touchscreen-api/eventDispatcherAPI"")

local destinations = {
    ""House"",
    ""NetherMeteor"",
    ""DesertJungle"",
    ""VolcanoVillage"",
    ""Creek""
}
local destinations_inv = {}
for key, value in pairs(destinations) do
    destinations_inv[value] = key
end

local buttons = {}
local buttonHeight = 1
local destinationPrefix = ""Current destination: ""

--local viewport = viewportAPI.new({term = term})
local viewport = viewportAPI.new({term = peripheral.find(""monitor"")})
chest_id = ""minecraft:chest""
track_id = ""railcraft:routing_track""
local chest = peripheral.find(chest_id)
local track = peripheral.find(track_id)

buttonHandler = function(element, x, y)
    -- Before we change it, statusbtn.text contains the previous destination,
    -- which should be the one of the ticket already in place
    track.pushItems(chest_id, 1, 1, destinations_inv[statusbtn.text])

    statusbtn.text = destinationPrefix..element.text
    chest.pushItems(track_id, destinations_inv[element.text], 1)

    return true -- requests redraw of current viewport
end

quit = function(element, x, y)
    term.setBackgroundColor(colors.black)
    term.clear()
    error()
end

local statusbtn = buttonAPI.new({
    text = ""Current destination: ""..destinations[1],
    x = buttonAPI.anchorLeft,
    y = buttonAPI.anchorBottom,
    height = buttonHeight,
    width = buttonAPI.maxWidth,
    isSticky = true,
    backgroundColor = colors.green
})
viewport:addElement(statusbtn)

for key, value in ipairs(destinations) do
    table.insert(
        buttons,
        buttonAPI.new({
            text = value,
            x = buttonAPI.anchorLeft,
            y = key * 2 * buttonHeight,
            height = buttonHeight,
            width = buttonAPI.maxWidth,
            isSticky = true,
            backgroundColor = colors.blue
        })
    )

    buttons[key].callback = buttonHandler

    viewport:addElement(buttons[key])
end


viewport:redraw()

--eventDispatcherAPI.addHandler(""mouse_click"", function(event, side, xPos, yPos)
eventDispatcherAPI.addFilteredHandler(""monitor_touch"", ""monitor"", function(event, side, xPos, yPos)
    viewport:handleClick(xPos, yPos)
end)

eventDispatcherAPI.addFilteredHandler(""monitor_resize"", ""monitor"", function()
	viewport:redraw()
end)

eventDispatcherAPI.runDispatchLoop()"
FigUHxp8,P10 Shade,A-KouZ1,C++,Thursday 29th of June 2023 11:44:05 AM CDT,"// Written By Kouzerumatsukite; 25 JUNE 2023
// 8-bit shade demonstration; 29 JUNE 2023
#include <Arduino.h>
#include <SPI.h>

// Assign these ESP32 pins to P10 Board
#define DR  23 // -> DR   // Data-Receive
#define OE  21 // -> OE   // Output-Enable
#define CLK 18 // -> CLK  // Data-Clock
#define LAT  5 // -> LAT  // Data-Latch
#define RSA 32 // -> A    // Row Select A
#define RSB 33 // -> B    // Row Select B

uint8_t display_data[8][4][16]; // 8 planes of 32x16 bitmap
// Every single 32x16 bitmap is called plane
// and each plane will be displayed with certain value of PWM
// these are the table 
/////////////////
// PLANE | PWM //
// ------+---- //
// bit-0 | 128 //
// bit-1 | 64  //
// bit-2 | 32  //
// bit-3 | 16  //
// bit-4 | 8   //
// bit-5 | 4   //
// bit-6 | 2   //
// bit-7 | 1   //
/////////////////
// and if u wish to write an 8-bit shaded pixel, u must alter all the planes
// and if u wish to determine what the shade of value just add PWM values of each plane together
// eg shade 241, u add 128 + 64 + 32 + 16 + 1;
// which means particular pixel in bit-0, bit-1, bit-2, bit-3, and bit-7 will be 1
// and the rest, bit-4, bit-5, and bit-6 will be 0

// and nevermind, this code will do that for you
void drawPixel(int x, int y, int c){
  if(x>=0 && x<32 && y>=0 && y<16){
    int a = ((~y>>2)&3)|((x>>3&3)<<2);
    int b = y&3;
    int s = x&7;
    for(int i=0; i<8; i++){
      display_data[i][b][a] &= ~(1<<(7-s));
      display_data[i][b][a] |= ((~c>>(7-i))&1)<<(7-s);
    }
  }
}

int current_row=0;
int current_plane=0;
int current_frame=0; // counts frames

void displayRow(){
  uint8_t row = current_row;
  uint8_t pln = current_plane;
  uint8_t*src = (uint8_t*)&display_data[pln][row&3][0];
  // turn off display, pwm=0
  ledcWrite(0,0);
  // update row data
  SPI.writeBytes(src, 16);
  // update row select
  digitalWrite(RSA,row>>0&1);
  digitalWrite(RSB,row>>1&1);
  digitalWrite(LAT,HIGH);
  digitalWrite(LAT,LOW);
  // turn on display, pwm = plane value
  ledcWrite(0,128>>current_plane);
  // update states
  current_row++;
  if(current_row>=4){
    current_row = 0;
    current_plane++;
    if(current_plane>=8){
      current_plane = 0;
      current_frame++;
    }
  }
  return;
}

void setup() {
  // initialize pin states
  pinMode(DR ,OUTPUT);
  pinMode(OE ,OUTPUT);
  pinMode(CLK,OUTPUT);
  pinMode(LAT,OUTPUT);
  pinMode(RSA,OUTPUT);
  pinMode(RSB,OUTPUT);
  // initialize SPI
  SPI.begin(CLK, -1, DR, -1);
  SPI.beginTransaction(SPISettings(20000000, MSBFIRST, SPI_MODE0));
  // initialize PWM
  ledcSetup(0, 40000000>>8, 8);
  ledcAttachPin(OE, 0);
  ledcWrite(0,0);
}

uint8_t bruh[] = {
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0xF4, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0xF4, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0xF4, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0xF4, 0x93, 0xB4, 0xF1, 0xE1, 0x75, 0x00, 0x00, 0xF4, 0x8F, 0xDA, 0xF0, 0x56, 0x00, 0xF8, 0x70, 0x00, 0x00, 0x00, 0xA8, 0xC0, 0x00, 0x00, 0xF0, 0x97, 0xAC, 0xEC, 0xEE, 0x96, 0x08, 0x00, 
 0x00, 0xF4, 0xFF, 0x78, 0x11, 0x52, 0xF5, 0x6C, 0x00, 0xF4, 0xF7, 0x31, 0x2B, 0x14, 0x00, 0xF8, 0x70, 0x00, 0x00, 0x00, 0xA8, 0xC0, 0x00, 0x00, 0xF0, 0xFD, 0x67, 0x0B, 0x3F, 0xF7, 0x7D, 0x00, 
 0x00, 0xF4, 0xBA, 0x00, 0x00, 0x00, 0x8B, 0xE6, 0x02, 0xF4, 0xA7, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x70, 0x00, 0x00, 0x00, 0xA8, 0xC0, 0x00, 0x00, 0xF0, 0xAD, 0x00, 0x00, 0x00, 0xAF, 0xBE, 0x00, 
 0x00, 0xF4, 0x72, 0x00, 0x00, 0x00, 0x4A, 0xFF, 0x1F, 0xF4, 0x85, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x70, 0x00, 0x00, 0x00, 0xA8, 0xC0, 0x00, 0x00, 0xF0, 0x7F, 0x00, 0x00, 0x00, 0x98, 0xCE, 0x00, 
 0x00, 0xF4, 0x5D, 0x00, 0x00, 0x00, 0x37, 0xFF, 0x39, 0xF4, 0x74, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x70, 0x00, 0x00, 0x00, 0xA8, 0xC0, 0x00, 0x00, 0xF0, 0x78, 0x00, 0x00, 0x00, 0x98, 0xD0, 0x00, 
 0x00, 0xF4, 0x6C, 0x00, 0x00, 0x00, 0x4D, 0xFF, 0x26, 0xF4, 0x74, 0x00, 0x00, 0x00, 0x00, 0xF7, 0x72, 0x00, 0x00, 0x00, 0xB1, 0xC0, 0x00, 0x00, 0xF0, 0x78, 0x00, 0x00, 0x00, 0x98, 0xD0, 0x00, 
 0x00, 0xF4, 0xA9, 0x00, 0x00, 0x00, 0x93, 0xE5, 0x01, 0xF4, 0x74, 0x00, 0x00, 0x00, 0x00, 0xE9, 0x85, 0x00, 0x00, 0x01, 0xDD, 0xC0, 0x00, 0x00, 0xF0, 0x78, 0x00, 0x00, 0x00, 0x98, 0xD0, 0x00, 
 0x00, 0xF4, 0xFD, 0x61, 0x0B, 0x5A, 0xF8, 0x62, 0x00, 0xF4, 0x74, 0x00, 0x00, 0x00, 0x00, 0xA0, 0xE1, 0x28, 0x10, 0x8B, 0xF9, 0xC0, 0x00, 0x00, 0xF0, 0x78, 0x00, 0x00, 0x00, 0x98, 0xD0, 0x00, 
 0x00, 0xF4, 0x85, 0xC2, 0xF9, 0xDE, 0x63, 0x00, 0x00, 0xF4, 0x74, 0x00, 0x00, 0x00, 0x00, 0x16, 0xAB, 0xF4, 0xED, 0x97, 0x8A, 0xC0, 0x00, 0x00, 0xF0, 0x78, 0x00, 0x00, 0x00, 0x98, 0xD0, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};

uint8_t tsuki[] = {
 0x00, 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x78, 0x78, 0xF0, 0xF0, 0xF0, 0x78, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x78, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xA3, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0xD3, 0xD3, 0x95, 0xF0, 0xF0, 0x95, 0xD3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xA3, 0xA3, 0xA3, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0xD3, 0xF0, 0x95, 0xD3, 0xD3, 0x95, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA3, 0xA3, 0x4F, 0xA3, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA3, 0x4F, 0x4F, 0xA3, 0xA3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x74, 0x9C, 0x9C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0x00, 0x00, 0x3A, 0x6D, 0x4F, 0x4F, 0x4F, 0x6D, 0x3A, 0x00, 0x00, 0x00, 0xCC, 0x99, 0x66, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x6D, 0x78, 0xF0, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x66, 0x99, 0x99, 0x99, 0xCC, 0x3A, 0x3A, 0x6D, 0x6D, 0x6D, 0x6D, 0x3A, 0x00, 0xCC, 0x99, 0x99, 0x99, 0x99, 0x66, 0x00, 
 0x00, 0x00, 0x00, 0x6D, 0x78, 0xF0, 0x6D, 0x3D, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x99, 0x66, 0xCC, 0x99, 0x6D, 0x3A, 0x6D, 0x3A, 0x6D, 0x6D, 0x99, 0x99, 0x66, 0x99, 0x66, 0x99, 0x99, 0x66, 
 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 
 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 
 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 
 0x62, 0x3D, 0x3D, 0x62, 0x62, 0x3D, 0x3D, 0x62, 0x62, 0x3D, 0x3D, 0x62, 0x62, 0x3D, 0x3D, 0x62, 0x62, 0x3D, 0x3D, 0x62, 0x62, 0x3D, 0x3D, 0x62, 0x62, 0x3D, 0x3D, 0x62, 0x62, 0x3D, 0x3D, 0x62, 
};

void displayPlane(int plane, int frames, int delayus){
  current_row = 0;
  while(frames--){
    current_plane = plane;
    displayRow(); delayMicroseconds(delayus);
    displayRow(); delayMicroseconds(delayus);
    displayRow(); delayMicroseconds(delayus);
    displayRow(); delayMicroseconds(delayus);
  }
}



void loop() {
  int delayfor=256;
  // lets draw gradient
  for(int x=0;x<32;x++)for(int y=0;y<16;y++)drawPixel(x,y,x&15|y<<4);
  for(int j=0; j<64; j++){for(int i=0; i<8; i++)displayPlane(i,delayfor,1000);delayfor = delayfor>>1 | delayfor&1;yield();}
    
  // lets draw bruh pic
  for(int x=0;x<32;x++)for(int y=0;y<16;y++)drawPixel(x,y,bruh[y*32+x]*bruh[y*32+x]>>8);
  for(int j=0; j<64; j++){for(int i=0; i<8; i++)displayPlane(i,1,250);yield();}
    
  // lets draw gradient again, but no flicker
  for(int x=0;x<32;x++)for(int y=0;y<16;y++)drawPixel(x,y,x&15|y<<4);
  for(int j=0; j<256; j++){for(int i=0; i<8; i++)displayPlane(i,1,250);yield();}

  delayfor=256;
  // lets draw gradient, but gamma corrected, flickered
  for(int x=0;x<32;x++)for(int y=0;y<16;y++)drawPixel(x,y,(x&15|y<<4)*(x&15|y<<4)>>8);
  for(int j=0; j<64; j++){for(int i=0; i<8; i++)displayPlane(i,delayfor,1000);delayfor = delayfor>>1 | delayfor&1;yield();}
  
  // lets draw gradient, but gamma corrected, no flicker
  for(int x=0;x<32;x++)for(int y=0;y<16;y++)drawPixel(x,y,(x&15|y<<4)*(x&15|y<<4)>>8);
  for(int j=0; j<256; j++){for(int i=0; i<8; i++)displayPlane(i,1,250);yield();}

  // lets draw tsuki pic
  for(int x=0;x<32;x++)for(int y=0;y<16;y++)drawPixel(x,y,tsuki[y*32+x]*tsuki[y*32+x]>>8);
  for(int j=0; j<256; j++){for(int i=0; i<8; i++)displayPlane(i,1,250);yield();}
}
"
ZEAmY2ch,init,durashka,Bash,Thursday 29th of June 2023 11:36:31 AM CDT,"#!/bin/sh

# autostart
systemctl --user import-environment DISPLAY WAYLAND_DISPLAY
dbus-update-activation-environment 2>/dev/null && dbus-update-activation-environment --systemd DISPLAY WAYLAND_DISPLAY 
riverctl keyboard-layout -options ""grp:win_space_toggle"" ""us,ru""
$HOME/.config/waybar/launch.sh &
dunst &
/usr/lib/polkit-gnome/polkit-gnome-authentication-agent-1 &
easyeffects --gapplication-service &
swaybg -i ~/Pictures/wallpapers/my_wallpaper.jpg -m fill &
wl-paste --watch cliphist store & 
pgrep -x firefox > /dev/null || firefox &
telegram-desktop &
thunderbird &

# appearance
riverctl background-color 0x282828
riverctl border-color-focused 0xc2af8d
riverctl border-color-unfocused 0x665c54
riverctl border-width           1
riverctl xcursor-theme Adwaita
gsettings set org.gnome.desktop.interface gtk-theme 'Gruvbox-Material-Dark'
gsettings set org.gnome.desktop.interface icon-theme 'Papirus-Dark'
gsettings set org.gnome.desktop.interface cursor-theme 'Adwaita'
gsettings set org.gnome.desktop.interface cursor-size 24
gsettings set org.gnome.desktop.interface font-name 'Noto Sans Regular 10'

# binds
riverctl map normal Super Space spawn river_keyboard.sh
riverctl map normal Super Return spawn kitty
riverctl map -layout 0 normal Super D spawn 'rofi -show drun'
riverctl map -layout 0 normal Control Delete spawn 'dunstctl close-all'
riverctl map -layout 0 normal Control Insert spawn 'dunstctl history-pop'
riverctl map -layout 0 normal Super X spawn 'rofi -modi clipboard:$HOME/.local/bin/cliphist-rofi -show clipboard'
riverctl map -layout 0 normal Super E spawn 'rofi -show emoji -modi emoji'
riverctl map -layout 0 normal None Print spawn 'flameshot screen'
riverctl map -layout 0 normal Shift Print spawn 'flameshot gui'
riverctl map -layout 0 normal Control+Alt S spawn 'suspend.sh'
riverctl map normal Super F1 spawn firefox
riverctl map normal Super F2 spawn telegram-desktop
riverctl map normal Super F3 spawn steam
riverctl map normal Super F4 spawn crow
riverctl map normal Super F5 spawn thunderbird
riverctl map normal Super F6 spawn galculator
riverctl map normal Super F7 spawn 'kitty -e btop'
riverctl map normal Super F12 spawn ""$HOME/.config/river/init""
riverctl map -layout 0 normal Super+Shift E exit
riverctl map -layout 0 normal Super J focus-view next
riverctl map -layout 0 normal Super K focus-view previous
riverctl map -layout 0 normal Super+Shift J swap next
riverctl map -layout 0 normal Super+Shift K swap previous
riverctl map -layout 0 normal Super Period focus-output next
riverctl map -layout 0 normal Super Comma focus-output previous
riverctl map -layout 0 normal Super+Shift Period send-to-output next
riverctl map -layout 0 normal Super Comma focus-output previous
riverctl map -layout 0 normal Super+Shift Comma send-to-output previous
riverctl map normal Super+Shift Return zoom
riverctl map -layout 0 -repeat normal Super Q close
riverctl map -layout 0 -repeat normal Super H send-layout-cmd rivertile ""main-ratio -0.05""
riverctl map -layout 0 -repeat normal Super L send-layout-cmd rivertile ""main-ratio +0.05""
riverctl map -layout 0 normal Super+Shift H send-layout-cmd rivertile ""main-count +1""
riverctl map -layout 0 normal Super+Shift L send-layout-cmd rivertile ""main-count -1""
riverctl map -layout 0 -repeat normal Super+Alt H move left 100
riverctl map -layout 0 -repeat normal Super+Alt J move down 100
riverctl map -layout 0 -repeat normal Super+Alt K move up 100
riverctl map -layout 0 -repeat normal Super+Alt L move right 100
riverctl map -layout 0 normal Super+Alt+Control H snap left
riverctl map -layout 0 normal Super+Alt+Control J snap down
riverctl map -layout 0 normal Super+Alt+Control K snap up
riverctl map -layout 0 normal Super+Alt+Control L snap right
riverctl map -layout 0 -repeat normal Super+Alt+Shift H resize horizontal -100
riverctl map -layout 0 -repeat normal Super+Alt+Shift J resize vertical 100
riverctl map -layout 0 -repeat normal Super+Alt+Shift K resize vertical -100
riverctl map -layout 0 -repeat normal Super+Alt+Shift L resize horizontal 100
riverctl map-pointer normal Super BTN_LEFT move-view
riverctl map-pointer normal Super BTN_RIGHT resize-view

for i in $(seq 1 9)
do
    tags=$((1 << ($i - 1)))

    # Super+[1-9] to focus tag [0-8]
    riverctl map normal Super $i set-focused-tags $tags

    # Super+Shift+[1-9] to tag focused view with tag [0-8]
    riverctl map normal Super+Shift $i set-view-tags $tags

    # Super+Ctrl+[1-9] to toggle focus of tag [0-8]
    riverctl map normal Super+Control $i toggle-focused-tags $tags

    # Super+Shift+Ctrl+[1-9] to toggle tag [0-8] of focused view
    riverctl map normal Super+Shift+Control $i toggle-view-tags $tags
done

# Super+0 to focus all tags
# Super+Shift+0 to tag focused view with all tags
all_tags=$(((1 << 32) - 1))
riverctl map normal Super 0 set-focused-tags $all_tags
riverctl map normal Super+Shift 0 set-view-tags $all_tags

# scrathpad
# The scratchpad will live on an unused tag. Which tags are used depends on your
# # config, but rivers default uses the first 9 tags.
scratch_tag=$((1 << 20 ))
#
# # Toggle the scratchpad with Super+P
riverctl map -layout 0 normal Super P toggle-focused-tags ${scratch_tag}
#
# # Send windows to the scratchpad with Super+Shift+P
riverctl map -layout 0 normal Super+Shift P set-view-tags ${scratch_tag}
#
# # Set spawn tagmask to ensure new windows don't have the scratchpad tag unless
# # explicitly set.
all_but_scratch_tag=$(( ((1 << 32) - 1) ^ $scratch_tag ))
riverctl spawn-tagmask ${all_but_scratch_tag}
# toggle float
riverctl map -layout 0 normal Super S toggle-float

# toggle fullscreen
riverctl map -layout 0 normal Super F toggle-fullscreen

# Super+{Up,Right,Down,Left} to change layout orientation
riverctl map normal Super KP_Up    send-layout-cmd rivertile ""main-location top""
riverctl map normal Super KP_Right send-layout-cmd rivertile ""main-location right""
riverctl map normal Super KP_Down  send-layout-cmd rivertile ""main-location bottom""
riverctl map normal Super KP_Left  send-layout-cmd rivertile ""main-location left""

# Super+{Up,Right,Down,Left} to windows control
riverctl map normal Super Up    focus-view next  
riverctl map normal Super+Shift Up    swap next  
riverctl map -repeat normal Super Right send-layout-cmd rivertile ""main-ratio +0.05""
riverctl map normal Super+Shift Right send-layout-cmd rivertile ""main-count -1""
riverctl map normal Super Down  focus-view previous 
riverctl map normal Super+Shift Down  swap previous 
riverctl map -repeat normal Super Left  send-layout-cmd rivertile ""main-ratio -0.05""
riverctl map normal Super+Shift Left  send-layout-cmd rivertile ""main-count +1""


# Declare a passthrough mode. This mode has only a single mapping to return to
# normal mode. This makes it useful for testing a nested wayland compositor
riverctl declare-mode passthrough

# Super+F11 to enter passthrough mode
riverctl map normal Super F11 enter-mode passthrough

# Super+F11 to return to normal mode
riverctl map passthrough Super F11 enter-mode normal

# Various media key mapping examples for both normal and locked mode which do
# not have a modifier
for mode in normal locked
do
    # Control pulse audio volume with pamixer (https://github.com/cdemoulins/pamixer)
    riverctl map -repeat   $mode Control Right spawn 'changevolume.sh 5%+'
    riverctl map -repeat   $mode Control Left  spawn 'changevolume.sh 5%-'
    riverctl map -layout 0 $mode Control M     spawn 'changevolume.sh mute'
    riverctl map -layout 0 $mode Control U     spawn 'changevolume.sh unmute'

    # Control MPRIS aware media players with playerctl (https://github.com/altdesktop/playerctl)
    riverctl map $mode Control+Alt Down  spawn 'playerctl play-pause'
    riverctl map $mode Control+Alt Left  spawn 'playerctl previous'
    riverctl map $mode Control+Alt Right  spawn 'playerctl next'
done

# Set keyboard repeat rate
riverctl set-repeat 20 300

# window rules
riverctl rule-add ssd
riverctl rule-add float -app-id ""flameshot""
riverctl rule-add float -app-id ""galculator""
riverctl rule-add tag -app-id ""firefox"" 1
riverctl rule-add tag -app-id ""org.telegram.desktop"" 3
riverctl rule-add tag -app-id ""thunderbird"" 5

# Set the default layout generator to be rivertile and start it.
# River will send the process group of the init executable SIGTERM on exit.
riverctl default-layout rivertile
riverctl focus-follows-cursor normal

rivertile -view-padding 3 -outer-padding 3 -main-ratio 0.55 &
rm /tmp/toggle

"
qnyyWWMu,Profile.vue,funtique,JavaScript,Thursday 29th of June 2023 11:29:32 AM CDT,"<script setup>
import { ref } from 'vue'
import AuthService from '@/services/AuthService'
import md5 from 'md5'

const user = ref(AuthService.getUser())

// Avatar avec Gravatar
function getGravatarUrl(email) {
  const hash = md5(email.trim().toLowerCase())
  return `https://www.gravatar.com/avatar/${hash}?s=150`
}

</script>

<template>
  <div>
    <v-avatar size=""150"">
      <img :src=""getGravatarUrl(user.email)"" alt=""Avatar"">
    </v-avatar>

    <v-card>
      <v-card-title>
        <span class=""headline"">{{ fullName }}</span>
      </v-card-title>

      <v-card-text>
        <v-list>
          <v-list-item>
            <v-list-item-content>
              <v-list-item-title>Pr√©nom :</v-list-item-title>
              <v-list-item-subtitle>{{ user.firstName }}</v-list-item-subtitle>
            </v-list-item-content>
          </v-list-item>

          <v-list-item>
            <v-list-item-content>
              <v-list-item-title>Nom :</v-list-item-title>
              <v-list-item-subtitle>{{ user.lastName }}</v-list-item-subtitle>
            </v-list-item-content>
          </v-list-item>

          <v-list-item>
            <v-list-item-content>
              <v-list-item-title>Mail :</v-list-item-title>
              <v-list-item-subtitle>{{ user.email }}</v-list-item-subtitle>
            </v-list-item-content>
          </v-list-item>

          <v-list-item>
            <v-list-item-content>
              <v-list-item-title>Username :</v-list-item-title>
              <v-list-item-subtitle>{{ user.username }}</v-list-item-subtitle>
            </v-list-item-content>
          </v-list-item>
        </v-list>
      </v-card-text>
    </v-card>
  </div>
</template>"
871gkigC,Untitled,MeehoweCK,C++,Thursday 29th of June 2023 11:14:33 AM CDT,"Wymierna::Wymierna(double ulamek)
{
    double l = ulamek;
    mianownik = 1;
    while (1.0 * static_cast<int>(l) / mianownik != ulamek)
    {
        l *= 10;
        mianownik *= 10;
    }
    licznik = static_cast<int>(l);
    skroc();
}"
QTBiZKnw,PLAYER TELEPORTER when TOUCHING PART,Joriangames,Lua,Thursday 29th of June 2023 11:13:26 AM CDT,"-- PLAYER TELEPORTER by BLOXIANCODE youtube.com/c/BloxianCode
-- Tutorial: https://youtube.com/shorts/uIyMTQNl8hc

local tpA = script.Parent.tpA
local tpB = script.Parent.tpB

local canTouch = true

tpA.Touched:Connect(function(hit)
	if hit.Parent:FindFirstChild(""Humanoid"") then
		if canTouch == true then
			canTouch = false
			hit.Parent.HumanoidRootPart.CFrame = tpB.CFrame + Vector3.new(0,5,0)
			wait(1)
			canTouch = true
		end
	end
end)

tpB.Touched:Connect(function(hit)
	if hit.Parent:FindFirstChild(""Humanoid"") then
		if canTouch == true then
			canTouch = false
			hit.Parent.HumanoidRootPart.CFrame = tpA.CFrame + Vector3.new(0,5,0)
			wait(1)
			canTouch = true
		end
	end
end)"
FaaGXP46,Untitled,Yue2u,C++,Thursday 29th of June 2023 10:31:31 AM CDT,"#include ""optimization.h""
#include <vector>
#include <set>
#include <algorithm>
#include <unordered_map>
#include <iostream>

using namespace std;

int T = 0;
vector<vector<int>> graph;
vector<int> visited, fup, tin, result, stack_;
unordered_map<int64_t, vector<int>> dict(200001);
int idx = 0;


void dfs(int v, int r = -1){
    visited[v] = 1;
    tin[v] = fup[v] = T++;
    for (auto u : graph[v]){
        if (u == r){
            continue;
        } 
        int stack_idx = stack_.size();
        int64_t x = (int64_t(min(u, v)) << 30ll) + int64_t(max(u, v));
        while(dict[x].size()){
            stack_.push_back(dict[x].back());
            dict[x].pop_back();
        }
        if (visited[u]){
            fup[v] = min(fup[v], tin[u]);
            continue;
        }
        dfs(u, v);
        fup[v] = min(fup[v], fup[u]);
        if (tin[v] <= fup[u]){
            ++idx;
            while(stack_.size() > stack_idx){
                result[stack_.back()] = idx;
                stack_.pop_back();
            }
        }
    }
}


int main(){
    int n = readInt(), m = readInt();
    
    graph.resize(n);
    visited.resize(n);
    
    result.resize(m);
    tin.resize(n);
    fup.resize(n);
    
    for(int i = 0; i < m; ++i){
        int64_t u = readInt() - 1, v = readInt() - 1;
        
        graph[u].push_back(v);
        graph[v].push_back(u);
        
        if (u > v) {
            swap(u, v);
        }
        dict[(u << 30) + v].push_back(i);
    }
    
    for(int i = 0; i < n; ++i){
        if (!visited[i]) {
            dfs(i);
        }
    }
    
    writeInt(*max_element(begin(result), end(result)), '\n');

    for (auto el : result){
        writeInt(el, ' ');
    }
    return 0;
}"
9rpfrZKw,ÈÇÄÊÇ®‰∏ÄËµ∑ÁúãÔºöüêØÁõíÂ≠ê,xiaomianao666,JavaScript,Thursday 29th of June 2023 09:49:51 AM CDT,Êµ∑ÈòîËßÜÁïåËßÑÂàôÂàÜ‰∫´ÔºåÂΩìÂâçÂàÜ‰∫´ÁöÑÊòØÔºö‰∫åÁ∫ßÈ°µÈù¢ËØ¶ÊÉÖÔø•page_detailÔø•üêØÁõíÂ≠ê@@eyJkYXRhIjoie1wiYXNzb2NpYXRlZE1vZGVsc01hcEZvckpvaW5UYWJsZVwiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhGS1wiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhvdXRGS1wiOnt9LFwiZmllbGRzVG9TZXRUb0RlZmF1bHRcIjpbXSxcImdtdE1vZGlmaWVkXCI6MCxcImlkXCI6MCxcImxhc3RfY2hhcHRlcl9ydWxlXCI6XCJcIixcImxpc3RUb0NsZWFyQXNzb2NpYXRlZEZLXCI6W10sXCJsaXN0VG9DbGVhclNlbGZGS1wiOltdLFwicGFnZUxpc3RcIjpbe1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuS6jOe6p+ino+aekFwiLFwicGF0aFwiOlwicFwiLFwicnVsZVwiOlwianM6XFxudmFyIGQgPSBbXTtcXG5sZXQgdXJsID0gYmFzZTY0RGVjb2RlKGdldFBhcmFtKFxcXCJ1XFxcIikpO1xcbmQucHVzaCh7XFxuICAgIHRpdGxlOiBcXFwiXFxcIixcXG4gICAgdXJsOiB1cmwsXFxuICAgIGNvbF90eXBlOiBcXFwieDVfd2Vidmlld19zaW5nbGVcXFwiLFxcbiAgICBkZXNjOiBcXFwiZmxvYXQmJjEwMCVcXFwiLFxcbiAgICBwaWNfdXJsOiBcXFwiXFxcIixcXG4gICAgZXh0cmE6IHtcXG4gICAgICAgIGNhbkJhY2s6IHRydWUsXFxuICAgICAgICBibG9ja1J1bGVzOiBbXFxcIi5naWZcXFwiLCBcXFwiL2FkL1xcXCIsIFxcXCIvYWRzL1xcXCIsIFxcXCJnb29nbGVcXFwiLCBcXFwiL3NoL3RvL1xcXCIsIFxcXCIuR0lGXFxcIl1cXG4gICAgfVxcbn0pO1xcbnNldFJlc3VsdChkKTtcXG5cIn0se1wiY29sX3R5cGVcIjpcInRleHRfMVwiLFwibmFtZVwiOlwi5pCc57Si5rWL6K+VXCIsXCJwYXRoXCI6XCJzXCIsXCJydWxlXCI6XCJqczpcXG5sZXQgdXJsID0gYmFzZTY0RGVjb2RlKGdldFBhcmFtKFxcXCJ1XFxcIikpO1xcbmxvZyh1cmwpO1xcbmxldCBrZXkgPSBnZXRQYXJhbShcXFwia2V5XFxcIik7XFxubGV0IHNwID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2Uvc3BcXFwiKTtcXG5zZXRSZXN1bHQoc3AodXJsLCBrZXksIFxcXCLmkJzntKLmtYvor5VcXFwiKSk7XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLogZrlkIjmkJzntKJcIixcInBhdGhcIjpcInByb1wiLFwicnVsZVwiOlwidmFyIGQgPSBbXTtcXG5pZiAoTVlfUEFHRSA9PSAxKSB7XFxuICAgIGQucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIuaQnOe0olxcXCIsXFxuICAgICAgICB1cmw6ICQudG9TdHJpbmcoKCkgPT4ge1xcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL2VtcHR5XFxcIjtcXG4gICAgICAgIH0pLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJpbnB1dFxcXCIsXFxuICAgICAgICBkZXNjOiBcXFwi6K+36L6T5YWl5YWz6ZSu6K+N77yM5bC96YeP5bCR5a2X5LiN6KaB5aSa5a2XXFxcIixcXG4gICAgICAgIHBpY191cmw6IFxcXCJcXFwiLFxcbiAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IGdldE15VmFyKFxcXCJzb3VcXFwiLCBcXFwiXFxcIiksXFxuICAgICAgICAgICAgb25DaGFuZ2U6ICQudG9TdHJpbmcoKCkgPT4ge1xcbiAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFwic291XFxcIiwgaW5wdXQpO1xcbiAgICAgICAgICAgIH0pXFxuICAgICAgICB9XFxuICAgIH0pO1xcbiAgICBhZGRMaXN0ZW5lcihcXFwib25DbG9zZVxcXCIsICQudG9TdHJpbmcoKCkgPT4ge1xcbiAgICAgICAgY2xlYXJNeVZhcihcXFwic291XFxcIik7XFxuICAgICAgICBjbGVhck15VmFyKFxcXCJzb1xcXCIpO1xcbiAgICB9KSk7XFxufVxcblxcbmxldCBzID0gZ2V0TXlWYXIoXFxcInNvdVxcXCIsIFxcXCJcXFwiKTtcXG5sZXQgciA9IFxcXCJcXFwiO1xcbmlmIChzICE9IFxcXCJcXFwiKSB7XFxuICAgIGxldCBwID0gTVlfUEFHRTtcXG4gICAgbGV0IHtcXG4gICAgICAgIGxvYWRcXG4gICAgfSA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL2RhdGFcXFwiKTtcXG4gICAgbGV0IHtcXG4gICAgICAgIHdyYXBcXG4gICAgfSA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL3Rvb2xcXFwiKTtcXG4gICAgbGV0IGRhdGEgPSBsb2FkKHAsIHIgIT0gXFxcIlxcXCIgPyByIDogbnVsbCk7XFxuXFxuICAgIGxldCBwYWdlaWQgPSBNWV9SVUxFLnRpdGxlICsgXFxcIi1wYWdlXFxcIiArIHA7XFxuICAgIGlmIChkYXRhLmxlbmd0aCA+IDApIHtcXG4gICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6IFxcXCLliqDovb3nrKxcXFwiICsgcCArIFxcXCLpobXkuK3vvIzov5vluqbvvJoxL1xcXCIgKyBkYXRhLmxlbmd0aCxcXG4gICAgICAgICAgICB1cmw6IFxcXCJcXFwiLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF9jZW50ZXJfMVxcXCIsXFxuICAgICAgICAgICAgZGVzYzogXFxcIlxcXCIsXFxuICAgICAgICAgICAgcGljX3VybDogXFxcIlxcXCIsXFxuICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgaWQ6IHBhZ2VpZFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICB9XFxuICAgIHNldFJlc3VsdChkKTtcXG4gICAgbG9nKGRhdGEubGVuZ3RoKTtcXG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMCkge1xcbiAgICAgICAgLy/lpJrnur/nqIvliqDovb0gICAgICAgIFxcbiAgICAgICAgbGV0IHJlYWxQYWdlID0gXFxcIlxcXCIgPT0gciA/IDEgOiBwO1xcbiAgICAgICAgbGV0IHRhc2tzID0gZGF0YS5tYXAoaXQgPT4ge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIGZ1bmM6IGZ1bmN0aW9uKHJ1bGUpIHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBydWxlLmZpbmQocywgcmVhbFBhZ2UpO1xcbiAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICBwYXJhbTogaXQsXFxuICAgICAgICAgICAgICAgIGlkOiBcXFwicnVsZUBcXFwiICsgaXQubmFtZVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcblxcbiAgICAgICAgYmF0Y2hFeGVjdXRlKHRhc2tzLCB7XFxuICAgICAgICAgICAgZnVuYzogZnVuY3Rpb24ocGFyYW0sIGlkLCBlcnJvciwgcmVzdWx0KSB7XFxuICAgICAgICAgICAgICAgIC8vbG9nKFxcXCJsaXN0ZW5lcjogXFxcIiArIChyZXN1bHQgfHwgW10pLmxlbmd0aClcXG4gICAgICAgICAgICAgICAgcGFyYW0uaSA9IHBhcmFtLmkgKyAxO1xcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XFxuICAgICAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGl0IG9mIHJlc3VsdCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbS5qID0gcGFyYW0uaiArIDE7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZEl0ZW1CZWZvcmUocGFnZWlkLCB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogd3JhcChpdC50aXRsZSwgcyksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjOiBpdC5kZXNjLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBpdC51cmwsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaWNfdXJsOiBpdC5waWNfdXJsLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6IGl0LnBpY191cmwgPyAnbW92aWVfMV92ZXJ0aWNhbF9waWMnIDogXFxcInRleHRfMVxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYTogaXQuZXh0cmFcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxcblxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmIChwYXJhbS5pID49IHBhcmFtLmFsbCkge1xcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlSXRlbShwYWdlaWQpXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVJdGVtKHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIuWKoOi9veesrFxcXCIgKyBNWV9QQUdFICsgXFxcIumhteS4re+8jOi/m+W6pu+8mlxcXCIgKyAocGFyYW0uaSArIDEpICsgXFxcIi9cXFwiICsgcGFyYW0uYWxsLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogXFxcIlxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0X2NlbnRlcl8xXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjOiBcXFwiXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICBwaWNfdXJsOiBcXFwiXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogcGFnZWlkXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgcGFyYW06IHtcXG4gICAgICAgICAgICAgICAgYWxsOiBkYXRhLmxlbmd0aCxcXG4gICAgICAgICAgICAgICAgaTogMCxcXG4gICAgICAgICAgICAgICAgajogLTFcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KVxcbiAgICB9XFxufSBlbHNlIHtcXG4gICAgbGV0IHtcXG4gICAgICAgIGxvYWRcXG4gICAgfSA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL2RhdGFcXFwiKTtcXG4gICAgbGV0IGRhdGEgPSBsb2FkKC0xLCBudWxsKTtcXG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMCkge1xcbiAgICAgICAgJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvbWFuYWdlXFxcIikoZCwgZGF0YS5tYXAoaXQgPT4gaXQubmFtZSkpO1xcbiAgICAgICAgZm9yIChsZXQgaXQgb2YgZGF0YSkge1xcbiAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiBpdC5uYW1lLFxcbiAgICAgICAgICAgICAgICB1cmw6IFxcXCJzZWxlY3Q6Ly9cXFwiICsgSlNPTi5zdHJpbmdpZnkoe1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLor7fpgInmi6nmk43kvZxcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgY29sOiAxLFxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogW1xcXCLorr/pl67pppbpobVcXFwiLCBcXFwi5pCc57Si5q2k56uZXFxcIl0sXFxuICAgICAgICAgICAgICAgICAgICBqczogJC50b1N0cmluZygodXJsKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0ID09IFxcXCLorr/pl67pppbpobVcXFwiKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1ZX1VSTCA9IHVybDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL3BhZ2UvcD91PVxcXCIgKyBiYXNlNjRFbmNvZGUoZ2V0SG9tZSh1cmwpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9wYWdlL3NpbmdsZXNcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgfSwgaXQudXJsKVxcbiAgICAgICAgICAgICAgICB9KSxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJmbGV4X2J1dHRvblxcXCIsXFxuICAgICAgICAgICAgICAgIGRlc2M6IFxcXCJcXFwiLFxcbiAgICAgICAgICAgICAgICBwaWNfdXJsOiBcXFwiXFxcIixcXG4gICAgICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgICAgIFJVTEU6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBpdC5uYW1lLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogaXQudXJsXFxuICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAgbG9uZ0NsaWNrOiBbe1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwi56aB55SoXFxcIiArIGl0Lm5hbWUsXFxuICAgICAgICAgICAgICAgICAgICAgICAganM6ICQudG9TdHJpbmcoKG5hbWUpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybSh7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIua4qemmqOaPkOekulxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBcXFwi56Gu6K6k5Yig6Zmk56aB55SoXFxcIiArIG5hbWUgKyBcXFwi5ZCX77yfXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm06ICQudG9TdHJpbmcoKG5hbWUsIHJ1bGUpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVSdWxlXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL2RhdGE/cnVsZT1cXFwiICsgcnVsZSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlUnVsZShuYW1lKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly9PS1xcXCI7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBuYW1lLCBNWV9SVUxFLnRpdGxlKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGl0Lm5hbWUpXFxuICAgICAgICAgICAgICAgICAgICB9LCB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLorr/pl67pppbpobVcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzOiBcXFwiJ2hpa2VyOi8vcGFnZS9wP3U9XFxcIiArIGJhc2U2NEVuY29kZShnZXRIb21lKGl0LnVybCkpICtcXFwiJ1xcXCJcXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIuaQnOe0ouatpOa6kFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAganM6IFxcXCInaGlrZXI6Ly9wYWdlL3NpbmdsZXMnXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgfV1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICB9XFxufVxcblxcbnNldFJlc3VsdChkKTtcIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuaVsOaNrlwiLFwicGF0aFwiOlwiZGF0YVwiLFwicnVsZVwiOlwiLy/lubblj5Hop4TliJnmlbBcXG5sZXQgc2l6ZTAgPSAxMDtcXG5sZXQgcnVsZXNUZXh0MCA9IGDwn5Cv54Gr54Gr6LWE5rqQ8J+Qr0BodHRwOi8vd3d3LmhuZmNqci5jb20vc28vbS8/az0qKlxcbvCfkK/kuZDkuZDotYTmupDwn5CvQGh0dHA6Ly93d3cuNmxsLmNvbS9zby9tLz9rPSoqXFxu8J+Qr+ebkuWtkEBodHRwczovL3d3dy5oZXppcGllLmNvbS8/cz0qKlxcbvCfkK/mlrDliIbkuqvogIXwn5CvQGh0dHBzOi8vd3d3LmZlbnhtLmNvbS9zZWFyY2gucGhwP3E9KipcXG7wn5Cv6JOd6bKo6LWE5rqQ8J+Qr0BodHRwczovL3d3dy5sYW4tc2hhLmNvbS8/cz0qKlxcbvCfkK/phbflupNAaHR0cHM6Ly93d3cuenhraS5jbi8/a2V5d29yZD0qKlxcbvCfkK9BcHDllrXmkJzwn5CvQGh0dHBzOi8vd3d3LmFwcG1pdS5jb20vP3M9KiomdHlwZT1wb3N0XFxu8J+Qr+WlpeWFlOWFlOaQnPCfkK9AaHR0cDovL3d3dy5hb3R1dHUuY24vc2VhcmNoLz9rZXl3b3JkPSoqXFxu8J+Qr+iTneeCuUBodHRwczovL3d3dy5sYW5kaWFubmV3cy5jb20vc2VhcmNoLyoqP3Bvc3RfdHlwZT1wb3N0XFxu8J+Qr1HkupHotYTmupDwn5CvQGh0dHBzOi8vd3d3LnF5dW4udmlwLz9rZXl3b3JkPSoqXFxu8J+Qr1FR6LWE5rqQ8J+Qr0BodHRwczovL3d3dy5xcXp5Zy5jbi9zZWFyY2g/a2V5d29yZD0qKlxcbvCfkK/lpJzmsrPmkJxAaHR0cDovL3d3dy55ZWhlcy5jb20vP2NhdD0mcz0qKlxcbvCfkK81aWxy6LWE5rqQ8J+Qr0BodHRwczovL3d3dy41aWxyLmNvbS8/cz0qKiZjYXQ9MFxcbvCfkK/puKHnm5LotYTmupDwn5CvQGh0dHBzOi8vY2FvbmlhbmcubmV0L3NlYXJjaC8qKi5odG1sXFxu8J+Qr+i3r+e+vUBodHRwczovL3d3dy5qaXNodXNvbmdzaHUuY29tLz9zPSoqJnBvc3RfdHlwZT1wb3N0XFxu8J+Qr+S4jeatu+m4n+aQnPCfkK9AaHR0cHM6Ly9pdWkuc3Uvc2VhcmNoLyoqL1xcbvCfkK/mupDnoIHotYTmupDwn5CvQGh0dHBzOi8vd3d3LnNjb2RlMS5jb20vc2VhcmNoLz9rZXl3b3JkPSoqXFxu8J+Qr+WknOmbqEBodHRwczovL3d3dy55ZXl1bGluZ2ZlbmcuY29tLz9zPSoqXFxu8J+Qr+eOieexs+eykuaQnPCfkK9AaHR0cHM6Ly95aW1pbGkubmV0Lz9zPSoqXFxu8J+Qr+acqOmjjui9r+S7tvCfkK9AaHR0cHM6Ly93d3cubWZyanouY29tLz9zPSoqXFxu8J+QrzcyNzNAaHR0cDovL3MuNzI3My5jb20vbS8/az0qKlxcbvCfkK/mtbfmo6DotYTmupDwn5CvQGh0dHBzOi8vd3d3LmhhaXRhbmd3LmNjLz9zPSoqXFxu8J+Qr+Wwj+iPjOi1hOa6kPCfkK9AaHR0cHM6Ly93d3cud3d0dGwuY29tLz9zPSoqXFxu8J+Qr+WfuuWcsEBodHRwOi8vcmpqZDYuY29tL3NlYXJjaD9tb2xkcz1hcnRpY2xlJndvcmQ9KipcXG7wn5Cv5YmN5pa56LWE5rqQ8J+Qr0BodHRwczovL3FpYW5mYW5nenkuY29tLz9zPSoqXFxu8J+Qr+S5kOS6q+i1hOa6kPCfkK9AaHR0cHM6Ly93d3cubHhhcGsuY29tLz9zPSoqJnR5cGU9cG9zdFxcbvCfkK/mjbflvoRAaHR0cHM6Ly9zaGFyZWN1dHMuY24vc2VhcmNoP3E9KipcXG7wn5CvcG9qaWXotYTmupDwn5CvQGh0dHBzOi8vd3d3LnBvamllcy5jbi8/cz0qKiZ0eXBlPXBvc3RcXG7wn5CvTWVtb3J58J+Qr0BodHRwczovL2NueGlhb2JhaS5jb20vc2VhcmNoP2tleXdvcmQ9KipcXG7wn5Cv5bCP5Y+vQGh0dHBzOi8vd3d3LnFrZWtlLmNvbS8/cz0qKlxcbvCfkK/niLHlhY3otLnlkKfwn5CvQGh0dHBzOi8vd3d3LmltZjguY24vc2VhcmNoLyoqLmh0bWxcXG7wn5Cv5rex6JOd5LiL6L298J+Qr0BodHRwczovL2Rvd25sb2FkLnNlbmxzLmNuL3NlYXJjaC8/a2V5d29yZD0qKlxcbvCfkK/nuqLlsJhAaHR0cHM6Ly93d3cuaGN3My5jbi9zZWFyY2gvKiouaHRtbFxcbvCfkK82NzjovoXliqnwn5CvQGh0dHBzOi8vd3d3LjY3OGN2LmNvbS9pbmRleC5waHA/a2V5d29yZD0qKlxcbvCfkK/mnInotqPmupDnoIHwn5CvQGh0dHBzOi8vd3d3LnlxeW0ubmV0Lz9zPSoqXFxu8J+Qr+ezu+e7n0BodHRwczovL3d3dy54aXRtaS5jb20vP3M9KipcXG7wn5Cv5YiG5Lqr6LWE5rqQ8J+Qr0BodHRwczovL3d3dy55cHppeXVhbnNoYXJlLmNsdWIvc2VhcmNoLnBocD9xPSoqXFxu8J+Qr+a0vuajruebkuWtkPCfkK9AaHR0cHM6Ly93d3cucHloZXppLmNvbS8/cz0qKlxcbvCfkK/liJ3op4FAaHR0cHM6Ly93d3cueWJjajA5MDcuY29tLz9zPSoqJmNhdD1cXG7wn5Cv5Lqk5rWB5bKb5pCc8J+Qr0BodHRwczovL3d3dy5qaWFvbGl1ZGFvLmNvbS8/cz0qKlxcbvCfkK/kuIvovb3otYTmupDwn5CvQGh0dHBzOi8vbS54emppLmNvbS9zZWFyY2gvYWxsLTAtMS0qKi5odG1sXFxu8J+Qr+W6lOeUqEBodHRwczovL3d3dy5pYXBwcy5tZS9hcmNoaXZlcy9jYXRlZ29yeS90dlxcbvCfkK/phbc46L6F5Yqp8J+Qr0BodHRwczovL3d3dy4xOWZ6dy5jb20vaW5kZXgucGhwP2tleXdvcmQ9KipcXG7wn5Cv5p6B5a6i5LiL6L298J+Qr0BodHRwczovL3d3dy5nZWVrZGxvYWQuY29tLz9zPSoqXFxu8J+Qr+maj+mjjkBodHRwczovL3d3dy41Mm5mdy5jbi8/cz0qKiZ0eXBlPXBvc3RcXG7wn5Cv5Yeh5bCY6LWE5rqQ8J+Qr0BodHRwczovL3d3dy41MGZjdy5jb20vaW5kZXgucGhwP2tleXdvcmQ9KiomdHlwZWlkPTBcXG7wn5Cv5b+D5rW3ReermfCfkK9AaHR0cHM6Ly9hcHBob3QuY2MvP3M9KipcXG7wn5Cv5p2C6LSn6ZO6QGh0dHBzOi8vdG1pb2UuY29tLz9zPSoqXFxu8J+Qr+Wkp+ecvOS7lOaQnPCfkK9AaHR0cDovL3d3dy5kYXlhbnphaS5tZS8/cz0qKlxcbvCfkK/po5jpgaXotYTmupDwn5CvQGh0dHBzOi8vd3d3Lm1weWl0LmNvbS8/cz0qKlxcbvCfkK/ova7lm55AaHR0cHM6Ly93d3cuY2hlbmJvLmluZm8vP3M9KipcXG7wn5Cv5p6r6Z+z5bqU55So8J+Qr0BodHRwczovL3d3dy5meTZiLmNvbS8/cz0qKlxcbvCfkK/lk4fllpToj4zmkJzwn5CvQGh0dHBzOi8vd3d3Lndhb2Rvd24uY29tL3NlYXJjaC8qKlxcbvCfkK/kuZ3ova9AaHR0cHM6Ly93d3cuam9ydWFuLmNvbS8/cz0qKlxcbvCfkK9pM+ekvuWMuvCfkK9AaHR0cHM6Ly93d3cuaTN6aC5jb20vP3M9KipcXG7wn5Cv6LWE5rqQ5ZCm5pCc8J+Qr0BodHRwczovL3d3dy56eWZvdS5jb20vP3M9KipcXG7wn5Cv6KW/6KW/5pCcQGh0dHBzOi8vc28uY3IxNzMuY29tL3NvdXN1by9tLz9rPSoqXFxu8J+Qr+aXoOeXleWTpeaQnPCfkK9AaHR0cHM6Ly93d3cud2hnNi5jb20vNDY1OC5odG1sXFxu8J+Qr+eIseeVmei1hOa6kPCfkK9AaHR0cDovL3p5dy5pNi5ncy9pbmRleC5waHA/a2V5d29yZD0qKlxcbvCfkK/lsI/kvJdAaHR0cHM6Ly93d3cuYXBwaW5uLmNvbS8/cz0qKlxcbvCfkK/pu5HmtbfmtIvmkJzwn5CvQGh0dHBzOi8vYmxvZy51cHg4LmNvbS9zZWFyY2gvKiovXFxu8J+Qr+WFheeUteermeaQnPCfkK9AaHR0cHM6Ly93d3cuY29jb2tsLmNuLz9zPSoqXFxu8J+Qr+iJvuiWh0BodHRwOi8vbS5haXdlaWJrLmNvbS9zZWFyY2gvKiouaHRtbFxcbvCfkK835LiL6L295pCc8J+Qr0BodHRwczovL3d3dy43eGlhemFpLmNvbS8/cz0qKlxcbvCfkK/nsr7lk4HotYTmupDwn5CvQGh0dHA6Ly93d3cuajlwLmNvbS9zby9tLz9rPSoqXFxu8J+Qr+iTneihq+aQnEBodHRwczovL3d3dy5ibHVlbHNxa2ouY29tLz9zPSoqXFxu8J+Qr0Hlp5DliIbkuqvwn5CvQGh0dHBzOi8vd3d3LmFoaGhoZnMuY29tLz9jYXQ9JnM9KipcXG7wn5Cv5ZC+54ix6L2v5Lu28J+Qr0BodHRwczovL3d3dy52aXB0b29scy52aXAvP3M9KiomdHlwZT1wb3N0XFxu8J+Qr+e+veWFlOe9kUBodHRwczovL20ueXV0dS5jbi9zZWFyY2gvc29mdC5odG1sP3Q9MzImaz0qKlxcbvCfkK/mnpzmoLjliaXlo7Pwn5CvQGh0dHBzOi8vd3d3LmdoeGkuY29tLz9zPSoqXFxu8J+QrzQyM0Rvd27wn5CvQGh0dHBzOi8vd3d3LjQyM2Rvd24uY29tL3NlYXJjaC8qKlxcbvCfkK9GSOaQnEBodHRwczovL2ZpbGVoaXBwby5jb20vemgvc2VhcmNoLz9xPSoqXFxu8J+Qr+S8mOexs+agvOaQnPCfkK9AaHR0cHM6Ly93d3cuNHNwYWNlcy5vcmcvP3M9KipcXG7wn5CvQWx0ZXJu5pCc8J+Qr0BodHRwczovL2FsdGVybmF0aXZldG8ubmV0L2Jyb3dzZS9zZWFyY2gvP3E9KipcXG7wn5CvU09T8J+Qr0BodHRwczovL3d3dy5yanNvcy5jb20vc2VhcmNoP3M9KipcXG7wn5CvWk5EU+iuuuWdm/CfkK9AaHR0cDovL3poYW5uZWkuYmFpZHUuY29tL2NzZS9zZWFyY2g/cT0qKiZzPTEzNjI0MDMzODE4OTI2MjE2MTI1XFxu8J+Qr1B1cmVzeXPwn5CvQGh0dHBzOi8vd3d3LnB1cmVzeXMubmV0Lz9zPSoqXFxu8J+Qr0xJVEVAaHR0cHM6Ly9saXRlYXBrcy5jb20vP3M9KipcXG7wn5Cv572R55uY5Lit5b+D8J+Qr0BodHRwczovL3Bhbi5pc2hhcmVwYy5jb20vP3M9KipcXG7wn5CvaW9z5ri45oiP8J+Qr0BodHRwczovL25rODdjLmNuLz9zPSoqXFxu8J+Qr+WzsOWTpfCfkK9AaHR0cHM6Ly96enp6enoubWUvP2tleXdvcmQ9KiomcGFnZT1meXBhZ2VcXG7wn5Cv5bCP5YiA5aix5LmQ8J+Qr0BodHRwczovL3hkLng2ZC5jb20vZGFvd2FuZ3NvdXN1bz9xPSoqJnR5cGVpZD0wXFxu8J+Qr+WPjeaWl+i1hOa6kPCfkK9AaHR0cHM6Ly93d3cuYXBwcmNuLmNvbS8/cz0qKlxcbvCfkK/ovoXliqlAaHR0cHM6Ly93d3cuZnV6aHVnb3UuY29tL2ZpbmQvKipcXG7wn5Cv55m95ryC5ri45oiP8J+Qr0BodHRwczovL3h4eHh4NTI1LmNvbS8/cz0qKlxcbvCfkK/ova/ku7bmsYnljJbwn5CvQGh0dHBzOi8vYXBwaG90LmNjLz9zPSoqXFxu8J+Qr+W+ruW9k0BodHRwczovL20ud2VpZG93bi5jb20vc2VhcmNoLmh0bWw/cT0qKlxcbvCfkK/mgqDkuYXlrp3lupPwn5CvQGh0dHBzOi8vdTliYW9rdS54eXovP3M9KipcXG7wn5Cv6Zey5LiA6bG85pCc8J+Qr0BodHRwczovL3d3dy5tYWNyci5jb20vP3M9KipcXG7wn5Cv6Jek6L2pQGh0dHBzOi8vd3d3LnRlbmd4dWFudy5jb20vaW5kZXgucGhwP2tleXdvcmQ9KiomdHlwZWlkPTBcXG7wn5CvYXBw54Ot5pCc8J+Qr0BodHRwczovL2FwcGhvdC5jYy8/cz0qKlxcbvCfkK/lpYfotqPotYTmupDwn5CvQGh0dHBzOi8vZnV1bi5mdW4vc2VhcmNoP3dvcmQ9KipcXG7wn5Cv55qu55quQGh0dHBzOi8vd3d3LnB5enliLmNvbS9pbmRleC5waHA/a2V5d29yZD0qKiZ0eXBlaWQ9MFxcblxcblxcblxcblxcbmA7XFxubGV0IHJ1bGVzVGV4dCA9IGdldEl0ZW0oXFxcInJ1bGVzXFxcIiwgcnVsZXNUZXh0MCk7XFxubGV0IHNwID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2Uvc3BcXFwiKTtcXG5ydWxlcyA9IHJ1bGVzVGV4dC5zcGxpdChcXFwiXFxcXG5cXFwiKVxcbiAgICAuZmlsdGVyKGl0ID0+IGl0LmluY2x1ZGVzKFxcXCJAXFxcIikpXFxuICAgIC5tYXAocnVsZSA9PiB7XFxuICAgICAgICBsZXQgcyA9IHJ1bGUuc3BsaXQoXFxcIkBcXFwiKTtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgbmFtZTogc1swXSxcXG4gICAgICAgICAgICBmaW5kOiBmdW5jdGlvbihrZXksIHBhZ2UpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwKHNbMV0sIGtleSwgc1swXSk7XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICB1cmw6IHNbMV1cXG4gICAgICAgIH07XFxuICAgIH0pO1xcblxcbmZ1bmN0aW9uIGxvYWQocGFnZSwgcnVsZSkge1xcbiAgICBsZXQgc2l6ZSA9IHBhZ2UgPD0gMCA/IHJ1bGVzLmxlbmd0aCA6IHNpemUwO1xcbiAgICBwYWdlID0gcGFnZSA8PSAwID8gMSA6IHBhZ2U7XFxuICAgIGlmICghcGFnZSAmJiAhcnVsZSkge1xcbiAgICAgICAgcmV0dXJuIHJ1bGVzLm1hcChpdCA9PiBpdC5uYW1lKTtcXG4gICAgfVxcbiAgICBpZiAocnVsZSAhPSBudWxsKSB7XFxuICAgICAgICBpZiAocGFnZSAhPSBudWxsICYmIHBhZ2UgPiAxKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHJ1bGVzLmZpbHRlcihpID0+IGkubmFtZSA9PSBydWxlICYmIGkucGFnZSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gcnVsZXMuZmlsdGVyKGkgPT4gaS5uYW1lID09IHJ1bGUpO1xcbiAgICB9XFxuICAgIGxldCBzdGFydCA9IChwYWdlIC0gMSkgKiBzaXplO1xcbiAgICBpZiAocnVsZXMubGVuZ3RoIDwgc3RhcnQgKyAxKSB7XFxuICAgICAgICByZXR1cm4gW107XFxuICAgIH1cXG4gICAgbGV0IGxlbiA9IHNpemU7XFxuICAgIGlmIChydWxlcy5sZW5ndGggPCBwYWdlICogc2l6ZSkge1xcbiAgICAgICAgbGVuID0gcnVsZXMubGVuZ3RoIC0gc3RhcnRcXG4gICAgfVxcbiAgICByZXR1cm4gcnVsZXMuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgbGVuKTtcXG59XFxuXFxuZnVuY3Rpb24gYWRkUnVsZShuYW1lLCBzdXJsKSB7XFxuICAgIHNldEl0ZW0oXFxcInJ1bGVzXFxcIiwgcnVsZXNUZXh0ICsgXFxcIlxcXFxuXFxcIiArIG5hbWUgKyBcXFwiQFxcXCIgKyBzdXJsKTtcXG59XFxuXFxuZnVuY3Rpb24gYWRkQWxsKGlucHV0KSB7XFxuICAgIGlmIChpbnB1dCA9PSBudWxsIHx8IGlucHV0ID09IFxcXCJcXFwiKSB7XFxuICAgICAgICByZXR1cm4gMDtcXG4gICAgfVxcbiAgICBsZXQgYXJyID0gaW5wdXQuc3BsaXQoXFxcIlxcXFxuXFxcIilcXG4gICAgICAgIC5maWx0ZXIoaXQgPT4gaXQuaW5jbHVkZXMoXFxcIkBcXFwiKSlcXG4gICAgICAgIC5tYXAocnVsZSA9PiB7XFxuICAgICAgICAgICAgbGV0IHMgPSBydWxlLnNwbGl0KFxcXCJAXFxcIik7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgbmFtZTogc1swXSxcXG4gICAgICAgICAgICAgICAgdXJsOiBzWzFdXFxuICAgICAgICAgICAgfTtcXG4gICAgICAgIH0pO1xcbiAgICBsZXQgZXhpc3QgPSBydWxlcy5tYXAoaXQgPT4gaXQudXJsKTtcXG4gICAgbGV0IGMgPSAwO1xcbiAgICBmb3IgKGxldCBpdCBvZiBhcnIpIHtcXG4gICAgICAgIGlmICghZXhpc3QuaW5jbHVkZXMoaXQudXJsKSkge1xcbiAgICAgICAgICAgIHJ1bGVzVGV4dCA9IHJ1bGVzVGV4dCArIFxcXCJcXFxcblxcXCIgKyBpdC5uYW1lICsgXFxcIkBcXFwiICsgaXQudXJsO1xcbiAgICAgICAgICAgIGMrKztcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBzZXRJdGVtKFxcXCJydWxlc1xcXCIsIHJ1bGVzVGV4dCk7XFxuICAgIHJldHVybiBjO1xcbn1cXG5cXG5mdW5jdGlvbiByZW1vdmVSdWxlKG5hbWUpIHtcXG4gICAgbGV0IG5ld1QgPSBydWxlc1RleHQuc3BsaXQoXFxcIlxcXFxuXFxcIilcXG4gICAgICAgIC5maWx0ZXIoaXQgPT4gaXQuaW5kZXhPZihuYW1lICsgXFxcIkBcXFwiKSA8IDApXFxuICAgICAgICAuam9pbihcXFwiXFxcXG5cXFwiKTtcXG4gICAgc2V0SXRlbShcXFwicnVsZXNcXFwiLCBuZXdUKTtcXG59XFxuXFxuJC5leHBvcnRzID0ge1xcbiAgICBsb2FkOiBsb2FkLFxcbiAgICBhZGRSdWxlOiBhZGRSdWxlLFxcbiAgICByZW1vdmVSdWxlOiByZW1vdmVSdWxlLFxcbiAgICBhZGRBbGw6IGFkZEFsbFxcbn1cIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuaQnOe0ouino+aekFwiLFwicGF0aFwiOlwic3BcIixcInJ1bGVcIjpcImZ1bmN0aW9uIHNlYXJjaCh1cmwsIGtleSwgcnVsZSkge1xcbiAgICBsZXQgZCA9IFtdO1xcbiAgICBsZXQgaHRtbCA9IFxcXCJcXFwiO1xcbiAgICBpZiAodXJsLmluY2x1ZGVzKFxcXCIqKlxcXCIpKSB7XFxuICAgICAgICAvL2dldOivt+axglxcbiAgICAgICAgbGV0IG9sZCA9IHVybDtcXG4gICAgICAgIHVybCA9IHVybC5yZXBsYWNlKFxcXCIqKlxcXCIsIGtleSk7XFxuICAgICAgICBodG1sID0gcmVxdWVzdCh1cmwpO1xcbiAgICAgICAgLy/oh6rliqjov4fpqozor4HnoIHlkozpopHnuYHorr/pl67pmZDliLZcXG4gICAgICAgIGxldCB7XFxuICAgICAgICAgICAgY2hlY2ssIHRlc3RcXG4gICAgICAgIH0gPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS95em1cXFwiKTtcXG4gICAgICAgIGlmIChjaGVjayh1cmwsIGh0bWwsIGQpKSB7XFxuICAgICAgICAgICAgbG9nKFxcXCLph43or5XkuoZcXFwiKTtcXG4gICAgICAgICAgICBodG1sID0gcmVxdWVzdCh1cmwsIHtcXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xcbiAgICAgICAgICAgICAgICAgICAgXFxcIlJlZmVyZXJcXFwiOiB1cmxcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pOyAgICAgICAgICAgXFxuICAgICAgICB9ICAgICAgICAgXFxuICAgICAgICB0ZXN0KHVybCwgaHRtbCwgZCwgb2xkLCBrZXksIHJ1bGUpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgLy/oh6rliqjor4bliKtwb3N06K+35rGCXFxuICAgICAgICBodG1sID0gcmVxdWVzdCh1cmwpO1xcbiAgICAgICAgbGV0IGZvcm0gPSBwZGZoKGh0bWwsIFxcXCJib2R5JiZmb3JtJiZIdG1sXFxcIik7XFxuICAgICAgICBsZXQgYWN0aW9uID0gcGQoaHRtbCwgXFxcImZvcm0mJmFjdGlvblxcXCIsIHVybCk7XFxuICAgICAgICBsZXQgaW5wdXRzID0gcGRmYShodG1sLCBcXFwiYm9keSYmZm9ybSYmaW5wdXRcXFwiKTtcXG4gICAgICAgIGxldCBib2R5ID0ge307XFxuICAgICAgICBmb3IgKGxldCBpdCBvZiBpbnB1dHMpIHtcXG4gICAgICAgICAgICBsZXQgbmFtZSA9IHBkZmgoaXQsIFxcXCJpbnB1dCYmbmFtZVxcXCIpO1xcbiAgICAgICAgICAgIGlmIChuYW1lICYmIG5hbWUgIT0gXFxcIlxcXCIpIHtcXG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gcGRmaChpdCwgXFxcImlucHV0JiZ2YWx1ZVxcXCIpO1xcbiAgICAgICAgICAgICAgICBib2R5W25hbWVdID0gdmFsdWUgfHwga2V5O1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGh0bWwgPSBwb3N0KGFjdGlvbiwge1xcbiAgICAgICAgICAgIGJvZHk6IGJvZHlcXG4gICAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIGxldCBhbGlzdCA9IHBkZmEoaHRtbCwgXFxcImJvZHkmJmFcXFwiKTtcXG4gICAgbGV0IGFyciA9IGFsaXN0Lm1hcChpdCA9PiB7XFxuICAgICAgICBsZXQgdCA9IHBkZmgoaXQsIFxcXCJhJiZUZXh0XFxcIik7XFxuICAgICAgICBsZXQgdDIgPSBwZGZoKGl0LCBcXFwiYSYmdGl0bGVcXFwiKTtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgLy9odG1sOiBpdCxcXG4gICAgICAgICAgICB0ZXh0OiB0MiAmJiB0Mi5pbmNsdWRlcyhrZXkpID8gdDIgOiB0LFxcbiAgICAgICAgICAgIGhyZWY6IHBkKGl0LCBcXFwiYSYmaHJlZlxcXCIsIHVybClcXG4gICAgICAgIH1cXG4gICAgfSk7XFxuXFxuICAgIGZ1bmN0aW9uIGlzUmVzdWx0KGl0KSB7XFxuICAgICAgICBpdCA9IGl0LnRleHQgfHwgXFxcIlxcXCI7XFxuICAgICAgICBpZiAoaXQgPT0gXFxcIlxcXCIgfHwgaXQubWF0Y2goL+aQnOe0onznu5PmnpwvKSkge1xcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGl0LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoa2V5KTtcXG4gICAgfVxcbiAgICBrZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIGxldCBpdCA9IGFycltpXTtcXG4gICAgICAgIGxldCB0ID0gaXQudGV4dDtcXG4gICAgICAgIGlmICghaXQuaHJlZiB8fCBpdC5ocmVmID09IFxcXCJcXFwiKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoaXNSZXN1bHQoaXQpKSB7XFxuICAgICAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IHQsXFxuICAgICAgICAgICAgICAgIHVybDogXFxcImhpa2VyOi8vcGFnZS9wP3U9XFxcIiArIGJhc2U2NEVuY29kZShpdC5ocmVmKSxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiLFxcbiAgICAgICAgICAgICAgICBkZXNjOiBcXFwi4oCc4oCc4oCd4oCdPGZvbnQgY29sb3I9I2YxM2I2NmE+XFxcIiArIHJ1bGUgKyBcXFwiPC9mb250PlxcXCJcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gZDtcXG59XFxuJC5leHBvcnRzID0gc2VhcmNoO1wifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwi5aKe5YigXCIsXCJwYXRoXCI6XCJtYW5hZ2VcIixcInJ1bGVcIjpcIiQuZXhwb3J0cyA9IGZ1bmN0aW9uKGQsIG5hbWVzKSB7XFxuICAgIGQucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIkFJ5oqA5pyvXFxcIixcXG4gICAgICAgIHVybDogXFxcImNvbmZpcm06Ly/ln7rkuo5BSeivhueJh+iHquWKqOWIhuaekOa6kOeggeaKgOacr++8jOS7o+eggeWujOWFqOW8gOa6kO+8jOaVsOaNruadpea6kOS6juWOn+e9keerme+8jOi9r+S7tuWSjOinhOWImeS4jeaPkOS+m+S7u+S9leWGheWuuS5qczonJ1xcXCIsXFxuICAgICAgICBjb2xfdHlwZTogXFxcImZsZXhfYnV0dG9uXFxcIlxcbiAgICB9KTtcXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBcXFwiICsgXFxcIixcXG4gICAgICAgIHVybDogJChcXFwiI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZSgocnIpID0+IHtcXG4gICAgICAgICAgICBkZWxldGVJdGVtQnlDbHMoXFxcImFpYWRkXFxcIik7XFxuICAgICAgICAgICAgYWRkSXRlbUFmdGVyKHJyICsgXFxcImFpc2RlbFxcXCIsIFt7XFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIlxcXCIsXFxuICAgICAgICAgICAgICAgICAgICBkZXNjOiBcXFwi6K+36L6T5YWl572R56uZ5ZCN56ewXFxcIixcXG4gICAgICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwiaW5wdXRcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZVZpc2libGU6IGZhbHNlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBcXFwicHV0TXlWYXIoJ25hbWUnLCBpbnB1dClcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsczogXFxcImFpYWRkXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIlxcXCIsXFxuICAgICAgICAgICAgICAgICAgICBkZXNjOiBcXFwi6K+36L6T5YWl572R56uZ5pCc57Si5Zyw5Z2AXFxcIixcXG4gICAgICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwiaW5wdXRcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZVZpc2libGU6IGZhbHNlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBcXFwicHV0TXlWYXIoJ3N1cmwnLCBpbnB1dClcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsczogXFxcImFpYWRkXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIuaPkOS6pOS/neWtmFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfY2VudGVyXzFcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiAkKFxcXCIjbm9Mb2FkaW5nI1xcXCIpLmxhenlSdWxlKCgpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3VybCA9IGdldE15VmFyKFxcXCJzdXJsXFxcIiwgXFxcIlxcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuYW1lID0gZ2V0TXlWYXIoXFxcIm5hbWVcXFwiLCBcXFwiXFxcIik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1cmwgPT0gXFxcIlxcXCIgfHwgbmFtZSA9PSBcXFwiXFxcIikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v6K+36L6T5YWl5a6M5pW05YaF5a65XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgciA9IGRlY29kZVVSSUNvbXBvbmVudChzdXJsKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByID0gci5yZXBsYWNlKG5ldyBSZWdFeHAoXFxcIltcXFxcdTRlMDAtXFxcXHU5ZmE1XStcXFwiLCBcXFwiZ1xcXCIpLCBcXFwiKipcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRSdWxlXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL2RhdGFcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRSdWxlKG5hbWUsIHIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+W3suS/neWtmFxcXCI7XFxuICAgICAgICAgICAgICAgICAgICB9KSxcXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xzOiBcXFwiYWlhZGRcXFwiXFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBdKTtcXG4gICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiXFxuICAgICAgICB9LCBNWV9SVUxFLnRpdGxlKSxcXG4gICAgICAgIGNvbF90eXBlOiBcXFwiZmxleF9idXR0b25cXFwiLFxcbiAgICB9KTtcXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBcXFwiIC0gXFxcIixcXG4gICAgICAgIHVybDogXFxcInNlbGVjdDovL1xcXCIgKyBKU09OLnN0cmluZ2lmeSh7XFxuICAgICAgICAgICAgb3B0aW9uczogbmFtZXMsXFxuICAgICAgICAgICAgdGl0bGU6IFxcXCLor7fpgInmi6nopoHliKDpmaTnmoTnq5nngrlcXFwiLFxcbiAgICAgICAgICAgIGpzOiAkLnRvU3RyaW5nKCgpID0+IHtcXG4gICAgICAgICAgICAgICAgbGV0IHtcXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZVJ1bGVcXG4gICAgICAgICAgICAgICAgfSA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL2RhdGFcXFwiKTtcXG4gICAgICAgICAgICAgICAgcmVtb3ZlUnVsZShpbnB1dCk7XFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly9PS1xcXCI7XFxuICAgICAgICAgICAgfSlcXG4gICAgICAgIH0pLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJmbGV4X2J1dHRvblxcXCJcXG4gICAgfSk7XFxuICAgIGQucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIuKGl++4j1xcXCIsXFxuICAgICAgICB1cmw6ICQoXFxcIiNub0xvYWRpbmcjXFxcIikubGF6eVJ1bGUoKCkgPT4ge1xcbiAgICAgICAgICAgIGNvbmZpcm0oe1xcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcIua4qemmqOaPkOekulxcXCIsXFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFxcXCLnoa7lrprlr7zlh7rmiYDmnInmlbDmja7lkJfvvJ/vvIjlr7zlh7rlkI7lj6/ku6Xngrnlh7vml4HovrnnmoTlr7zlhaXmjInpkq7mibnph4/lr7zlhaXvvIlcXFwiLFxcbiAgICAgICAgICAgICAgICBjb25maXJtOiAkLnRvU3RyaW5nKCgpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIGxldCB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZFxcbiAgICAgICAgICAgICAgICAgICAgfSA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL2RhdGFcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgIGxldCBkYXRhID0gbG9hZCgtMSk7XFxuICAgICAgICAgICAgICAgICAgICBsZXQgcyA9IGRhdGEubWFwKGl0ID0+IGl0Lm5hbWUgKyBcXFwiQFxcXCIgKyBpdC51cmwpLmpvaW4oXFxcIlxcXFxuXFxcIik7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcImNvcHk6Ly9cXFwiICsgc1xcbiAgICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCJcXG4gICAgICAgIH0pLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJmbGV4X2J1dHRvblxcXCIsXFxuICAgIH0pO1xcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6IFxcXCLihpjvuI9cXFwiLFxcbiAgICAgICAgdXJsOiAkKFxcXCJcXFwiLCBcXFwi6K+36L6T5YWl6KaB5om56YeP5a+85YWl55qE5pWw5o2uXFxcIikuaW5wdXQoKCkgPT4ge1xcbiAgICAgICAgICAgIGxldCB7XFxuICAgICAgICAgICAgICAgIGFkZEFsbFxcbiAgICAgICAgICAgIH0gPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9kYXRhXFxcIik7XFxuICAgICAgICAgICAgbGV0IGNvdW50ID0gYWRkQWxsKGlucHV0KTtcXG4gICAgICAgICAgICBpZiAoY291bnQgPiAwKSByZWZyZXNoUGFnZSgpO1xcbiAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly9cXFwiICsgKGNvdW50ID4gMCA/IFxcXCLmiJDlip/lr7zlhaVcXFwiICsgY291bnQgKyBcXFwi5p2h5pWw5o2uXFxcIiA6IFxcXCLkuIDmnaHkuZ/msqHlr7zlhaVcXFwiKVxcbiAgICAgICAgfSksXFxuICAgICAgICBjb2xfdHlwZTogXFxcImZsZXhfYnV0dG9uXFxcIixcXG4gICAgfSk7XFxuICAgIGQucHVzaCh7XFxuICAgICAgICBjb2xfdHlwZTogXFxcImJsYW5rX2Jsb2NrXFxcIixcXG4gICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgaWQ6IE1ZX1JVTEUudGl0bGUgKyBcXFwiYWlzZGVsXFxcIlxcbiAgICAgICAgfVxcbiAgICB9KTtcXG5cXG59XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLpqozor4HnoIFcIixcInBhdGhcIjpcInl6bVwiLFwicnVsZVwiOlwiZnVuY3Rpb24gY2hlY2sodXJsLCBodG1sLCBkKSB7XFxuICAgIGxldCByZWxvYWQgPSBmYWxzZTtcXG4gICAgcmV0dXJuIHJlbG9hZDtcXG59XFxuXFxuZnVuY3Rpb24gdGVzdCh1cmwsIGh0bWwsIGQsIG9sZCwga2V5LCBydWxlKSB7XFxuICAgIGlmICgvNeenknzpopHnuYEvLnRlc3QoaHRtbCkpIHtcXG4gICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6ICfmkJzntKLpnIDpl7TpmpQ156eS77yM54K55Ye76YeN5paw5Yqg6L29JyxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfMVxcXCIsXFxuICAgICAgICAgICAgZGVzYzogXFxcIuKAnOKAnOKAneKAnTxmb250IGNvbG9yPSNmMTNiNjZhPlxcXCIgKyBydWxlICsgXFxcIjwvZm9udD5cXFwiLFxcbiAgICAgICAgICAgIHVybDogJCgpLmxhenlSdWxlKCh1cmwsIG9sZCwga2V5LCBydWxlKSA9PiB7XFxuICAgICAgICAgICAgICAgIGxldCBzcCA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL3NwXFxcIik7XFxuICAgICAgICAgICAgICAgIGxldCBkID0gc3Aob2xkLCBrZXksIHJ1bGUpO1xcbiAgICAgICAgICAgICAgICBsZXQge1xcbiAgICAgICAgICAgICAgICAgICAgd3JhcFxcbiAgICAgICAgICAgICAgICB9ID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvdG9vbFxcXCIpO1xcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpdCBvZiBkKSB7XFxuICAgICAgICAgICAgICAgICAgICBpdC50aXRsZSA9IHdyYXAoaXQudGl0bGUsIGtleSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgYWRkSXRlbUFmdGVyKHVybCwgZCk7XFxuICAgICAgICAgICAgICAgIGRlbGV0ZUl0ZW0odXJsKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL09LXFxcIjtcXG4gICAgICAgICAgICB9LCB1cmwsIG9sZCwga2V5LCBydWxlKSxcXG4gICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICBpZDogdXJsXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgIH1cXG59XFxuXFxuJC5leHBvcnRzID0ge1xcbiAgICBjaGVjazogY2hlY2ssXFxuICAgIHRlc3Q6IHRlc3RcXG59XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLlt6XlhbdcIixcInBhdGhcIjpcInRvb2xcIixcInJ1bGVcIjpcImZ1bmN0aW9uIHdyYXAodGV4dCwgcykge1xcbiAgICByZXR1cm4gdGV4dC5pbmNsdWRlcyhcXFwi4oCc4oCc4oCd4oCdXFxcIikgPyB0ZXh0IDogXFxcIuKAnOKAnOKAneKAnVxcXCIgKyB0ZXh0LnJlcGxhY2UobmV3IFJlZ0V4cChcXFwiPGVtPnw8L2VtPlxcXCIsIFxcXCJnXFxcIiksIFxcXCJcXFwiKS5yZXBsYWNlKG5ldyBSZWdFeHAocywgXFxcImdcXFwiKSwgXFxcIjxzdHJvbmc+PHNwYW4gc3R5bGU9XFxcXFxcXCJjb2xvcjogIzFFOTBGRlxcXFxcXFwiPlxcXCIgKyBzICsgXFxcIjwvc3Bhbj48L3N0cm9uZz5cXFwiKVxcbn1cXG4kLmV4cG9ydHMgPSB7XFxuICAgIHdyYXA6IHdyYXBcXG59XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLljZXmkJxcIixcInBhdGhcIjpcInNpbmdsZXNcIixcInJ1bGVcIjpcImpzOlxcbnZhciBkID0gW107XFxuZC5wdXNoKHtcXG4gICAgdGl0bGU6IFxcXCLmkJzntKJcXFwiLFxcbiAgICB1cmw6ICQudG9TdHJpbmcoKCkgPT4ge1xcbiAgICAgICAgcHV0TXlWYXIoXFxcInNvXFxcIiwgaW5wdXQpO1xcbiAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXG4gICAgfSksXFxuICAgIGNvbF90eXBlOiBcXFwiaW5wdXRcXFwiLFxcbiAgICBkZXNjOiBcXFwi6K+36L6T5YWl5YWz6ZSu6K+N77yM5bC96YeP5bCR5a2X5LiN6KaB5aSa5a2XXFxcIixcXG4gICAgcGljX3VybDogXFxcIlxcXCIsXFxuICAgIGV4dHJhOiB7XFxuICAgICAgICBkZWZhdWx0VmFsdWU6IGdldE15VmFyKFxcXCJzb1xcXCIsIFxcXCJcXFwiKVxcbiAgICB9XFxufSk7XFxubGV0IHMgPSBnZXRNeVZhcihcXFwic29cXFwiLCBcXFwiXFxcIik7XFxubGV0IHIgPSBcXFwiXFxcIjtcXG5pZiAocyAhPSBcXFwiXFxcIikge1xcbiAgICBsZXQgcCA9IE1ZX1BBR0U7XFxuICAgIGxldCB7XFxuICAgICAgICBsb2FkXFxuICAgIH0gPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9kYXRhXFxcIik7XFxuICAgIGxldCB7XFxuICAgICAgICB3cmFwXFxuICAgIH0gPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS90b29sXFxcIik7XFxuICAgIGxldCBkYXRhID0gbG9hZChwLCBNWV9QQVJBTVMuUlVMRS5uYW1lKTtcXG4gICAgbGV0IGFyciA9IGRhdGFbMF0uZmluZChzLCBwKTtcXG4gICAgZm9yIChsZXQgaXQgb2YgYXJyKSB7XFxuICAgICAgICBpdC50aXRsZSA9IHdyYXAoaXQudGl0bGUsIHMpXFxuICAgICAgICBkLnB1c2goaXQpO1xcbiAgICB9XFxufVxcbnNldFJlc3VsdChkKTtcIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuaQnOe0oumhtemdolwiLFwicGF0aFwiOlwic291cFwiLFwicnVsZVwiOlwianM6XFxudmFyIGQgPSBbXTtcXG5pZiAoTVlfUEFSQU1TLmtleSAmJiBnZXRNeVZhcihcXFwidXNlXFxcIiwgXFxcIlxcXCIpID09IFxcXCJcXFwiKSB7XFxuICAgIHB1dE15VmFyKFxcXCJzb3VcXFwiLCBNWV9QQVJBTVMua2V5KTtcXG4gICAgcHV0TXlWYXIoXFxcInVzZVxcXCIsIFxcXCIxXFxcIik7XFxuICAgIGFkZExpc3RlbmVyKFxcXCJvbkNsb3NlXFxcIiwgJC50b1N0cmluZygoKSA9PiB7XFxuICAgICAgICBjbGVhck15VmFyKFxcXCJ1c2VcXFwiKTtcXG4gICAgfSkpO1xcbn1cXG4kLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9wcm8nKVwifV0sXCJwYXJhbXNcIjpcIntcXFwiUlVMRVxcXCI6e1xcXCJuYW1lXFxcIjpcXFwi8J+Qr+ebkuWtkFxcXCIsXFxcInVybFxcXCI6XFxcImh0dHBzOi8vd3d3LmhlemlwaWUuY29tLz9zPSoqXFxcIn0sXFxcImxvbmdDbGlja1xcXCI6W3tcXFwianNcXFwiOlxcXCIoXFxcXG4obmFtZSkgPT4ge1xcXFxuICAgIGNvbmZpcm0oe3RpdGxlOiBcXFxcXFxcIlxcXFxcXFxcdTZlMjlcXFxcXFxcXHU5OWE4XFxcXFxcXFx1NjNkMFxcXFxcXFxcdTc5M2FcXFxcXFxcIiwgY29udGVudDogXFxcXFxcXCJcXFxcXFxcXHU3ODZlXFxcXFxcXFx1OGJhNFxcXFxcXFxcdTUyMjBcXFxcXFxcXHU5NjY0XFxcXFxcXFx1Nzk4MVxcXFxcXFxcdTc1MjhcXFxcXFxcIiArIG5hbWUgKyBcXFxcXFxcIlxcXFxcXFxcdTU0MTdcXFxcXFxcXHVmZjFmXFxcXFxcXCIsIGNvbmZpcm06ICQudG9TdHJpbmcoKG5hbWUsIHJ1bGUpID0+IHtcXFxcbiAgICAgICAgbGV0IHtyZW1vdmVSdWxlfSA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9kYXRhP3J1bGU9XFxcXFxcXCIgKyBydWxlKTtcXFxcbiAgICAgICAgcmVtb3ZlUnVsZShuYW1lKTtcXFxcbiAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcbiAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly9PS1xcXFxcXFwiO1xcXFxuICAgIH1cXFxcbiAgICAsIG5hbWUsIE1ZX1JVTEUudGl0bGUpfSk7XFxcXG4gICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiO1xcXFxufVxcXFxuKShcXFxcXFxcIvCfkK/nm5LlrZBcXFxcXFxcIilcXFwiLFxcXCJ0aXRsZVxcXCI6XFxcIuemgeeUqPCfkK/nm5LlrZBcXFwifSx7XFxcImpzXFxcIjpcXFwiJ2hpa2VyOi8vcGFnZS9wP3U9YUhSMGNITTZMeTkzZDNjdWFHVjZhWEJwWlM1amIyMD0nXFxcIixcXFwidGl0bGVcXFwiOlxcXCLorr/pl67pppbpobVcXFwifSx7XFxcImpzXFxcIjpcXFwiJ2hpa2VyOi8vcGFnZS9zaW5nbGVzJ1xcXCIsXFxcInRpdGxlXFxcIjpcXFwi5pCc57Si5q2k5rqQXFxcIn1dfVwiLFwic2F2ZWRcIjpmYWxzZSxcInRpdGxlXCI6XCJBSei9r+aQnFwiLFwidmVyc2lvblwiOjAsXCJ1cmxcIjpcImhpa2VyOi8vcGFnZS9wP3U9YUhSMGNITTZMeTkzZDNjdWFHVjZhWEJwWlM1amIyMD1cIixcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJmaW5kX3J1bGVcIjpcImpzOlxcbnZhciBkID0gW107XFxubGV0IHVybCA9IGJhc2U2NERlY29kZShnZXRQYXJhbShcXFwidVxcXCIpKTtcXG5kLnB1c2goe1xcbiAgICB0aXRsZTogXFxcIlxcXCIsXFxuICAgIHVybDogdXJsLFxcbiAgICBjb2xfdHlwZTogXFxcIng1X3dlYnZpZXdfc2luZ2xlXFxcIixcXG4gICAgZGVzYzogXFxcImZsb2F0JiYxMDAlXFxcIixcXG4gICAgcGljX3VybDogXFxcIlxcXCIsXFxuICAgIGV4dHJhOiB7XFxuICAgICAgICBjYW5CYWNrOiB0cnVlLFxcbiAgICAgICAgYmxvY2tSdWxlczogW1xcXCIuZ2lmXFxcIiwgXFxcIi9hZC9cXFwiLCBcXFwiL2Fkcy9cXFwiLCBcXFwiZ29vZ2xlXFxcIiwgXFxcIi9zaC90by9cXFwiLCBcXFwiLkdJRlxcXCJdXFxuICAgIH1cXG59KTtcXG5zZXRSZXN1bHQoZCk7XFxuXCIsXCJncm91cFwiOlwi4pGiQUlcIixcInVhXCI6XCJtb2JpbGVcIixcInByZVJ1bGVcIjpcIlwiLFwicGFnZXNcIjpcIlt7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLkuoznuqfop6PmnpBcXFwiLFxcXCJwYXRoXFxcIjpcXFwicFxcXCIsXFxcInJ1bGVcXFwiOlxcXCJqczpcXFxcbnZhciBkID0gW107XFxcXG5sZXQgdXJsID0gYmFzZTY0RGVjb2RlKGdldFBhcmFtKFxcXFxcXFwidVxcXFxcXFwiKSk7XFxcXG5kLnB1c2goe1xcXFxuICAgIHRpdGxlOiBcXFxcXFxcIlxcXFxcXFwiLFxcXFxuICAgIHVybDogdXJsLFxcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcIng1X3dlYnZpZXdfc2luZ2xlXFxcXFxcXCIsXFxcXG4gICAgZGVzYzogXFxcXFxcXCJmbG9hdCYmMTAwJVxcXFxcXFwiLFxcXFxuICAgIHBpY191cmw6IFxcXFxcXFwiXFxcXFxcXCIsXFxcXG4gICAgZXh0cmE6IHtcXFxcbiAgICAgICAgY2FuQmFjazogdHJ1ZSxcXFxcbiAgICAgICAgYmxvY2tSdWxlczogW1xcXFxcXFwiLmdpZlxcXFxcXFwiLCBcXFxcXFxcIi9hZC9cXFxcXFxcIiwgXFxcXFxcXCIvYWRzL1xcXFxcXFwiLCBcXFxcXFxcImdvb2dsZVxcXFxcXFwiLCBcXFxcXFxcIi9zaC90by9cXFxcXFxcIiwgXFxcXFxcXCIuR0lGXFxcXFxcXCJdXFxcXG4gICAgfVxcXFxufSk7XFxcXG5zZXRSZXN1bHQoZCk7XFxcXG5cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwidGV4dF8xXFxcIixcXFwibmFtZVxcXCI6XFxcIuaQnOe0oua1i+ivlVxcXCIsXFxcInBhdGhcXFwiOlxcXCJzXFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxubGV0IHVybCA9IGJhc2U2NERlY29kZShnZXRQYXJhbShcXFxcXFxcInVcXFxcXFxcIikpO1xcXFxubG9nKHVybCk7XFxcXG5sZXQga2V5ID0gZ2V0UGFyYW0oXFxcXFxcXCJrZXlcXFxcXFxcIik7XFxcXG5sZXQgc3AgPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2Uvc3BcXFxcXFxcIik7XFxcXG5zZXRSZXN1bHQoc3AodXJsLCBrZXksIFxcXFxcXFwi5pCc57Si5rWL6K+VXFxcXFxcXCIpKTtcXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLogZrlkIjmkJzntKJcXFwiLFxcXCJwYXRoXFxcIjpcXFwicHJvXFxcIixcXFwicnVsZVxcXCI6XFxcInZhciBkID0gW107XFxcXG5pZiAoTVlfUEFHRSA9PSAxKSB7XFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IFxcXFxcXFwi5pCc57SiXFxcXFxcXCIsXFxcXG4gICAgICAgIHVybDogJC50b1N0cmluZygoKSA9PiB7XFxcXG4gICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiO1xcXFxuICAgICAgICB9KSxcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiaW5wdXRcXFxcXFxcIixcXFxcbiAgICAgICAgZGVzYzogXFxcXFxcXCLor7fovpPlhaXlhbPplK7or43vvIzlsL3ph4/lsJHlrZfkuI3opoHlpJrlrZdcXFxcXFxcIixcXFxcbiAgICAgICAgcGljX3VybDogXFxcXFxcXCJcXFxcXFxcIixcXFxcbiAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZ2V0TXlWYXIoXFxcXFxcXCJzb3VcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIiksXFxcXG4gICAgICAgICAgICBvbkNoYW5nZTogJC50b1N0cmluZygoKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCJzb3VcXFxcXFxcIiwgaW5wdXQpO1xcXFxuICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgfVxcXFxuICAgIH0pO1xcXFxuICAgIGFkZExpc3RlbmVyKFxcXFxcXFwib25DbG9zZVxcXFxcXFwiLCAkLnRvU3RyaW5nKCgpID0+IHtcXFxcbiAgICAgICAgY2xlYXJNeVZhcihcXFxcXFxcInNvdVxcXFxcXFwiKTtcXFxcbiAgICAgICAgY2xlYXJNeVZhcihcXFxcXFxcInNvXFxcXFxcXCIpO1xcXFxuICAgIH0pKTtcXFxcbn1cXFxcblxcXFxubGV0IHMgPSBnZXRNeVZhcihcXFxcXFxcInNvdVxcXFxcXFwiLCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbmxldCByID0gXFxcXFxcXCJcXFxcXFxcIjtcXFxcbmlmIChzICE9IFxcXFxcXFwiXFxcXFxcXCIpIHtcXFxcbiAgICBsZXQgcCA9IE1ZX1BBR0U7XFxcXG4gICAgbGV0IHtcXFxcbiAgICAgICAgbG9hZFxcXFxuICAgIH0gPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvZGF0YVxcXFxcXFwiKTtcXFxcbiAgICBsZXQge1xcXFxuICAgICAgICB3cmFwXFxcXG4gICAgfSA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS90b29sXFxcXFxcXCIpO1xcXFxuICAgIGxldCBkYXRhID0gbG9hZChwLCByICE9IFxcXFxcXFwiXFxcXFxcXCIgPyByIDogbnVsbCk7XFxcXG5cXFxcbiAgICBsZXQgcGFnZWlkID0gTVlfUlVMRS50aXRsZSArIFxcXFxcXFwiLXBhZ2VcXFxcXFxcIiArIHA7XFxcXG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMCkge1xcXFxuICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi5Yqg6L2956ysXFxcXFxcXCIgKyBwICsgXFxcXFxcXCLpobXkuK3vvIzov5vluqbvvJoxL1xcXFxcXFwiICsgZGF0YS5sZW5ndGgsXFxcXG4gICAgICAgICAgICB1cmw6IFxcXFxcXFwiXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0X2NlbnRlcl8xXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBkZXNjOiBcXFxcXFxcIlxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgcGljX3VybDogXFxcXFxcXCJcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgaWQ6IHBhZ2VpZFxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9KTtcXFxcbiAgICB9XFxcXG4gICAgc2V0UmVzdWx0KGQpO1xcXFxuICAgIGxvZyhkYXRhLmxlbmd0aCk7XFxcXG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMCkge1xcXFxuICAgICAgICAvL+Wkmue6v+eoi+WKoOi9vSAgICAgICAgXFxcXG4gICAgICAgIGxldCByZWFsUGFnZSA9IFxcXFxcXFwiXFxcXFxcXCIgPT0gciA/IDEgOiBwO1xcXFxuICAgICAgICBsZXQgdGFza3MgPSBkYXRhLm1hcChpdCA9PiB7XFxcXG4gICAgICAgICAgICByZXR1cm4ge1xcXFxuICAgICAgICAgICAgICAgIGZ1bmM6IGZ1bmN0aW9uKHJ1bGUpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ1bGUuZmluZChzLCByZWFsUGFnZSk7XFxcXG4gICAgICAgICAgICAgICAgfSxcXFxcbiAgICAgICAgICAgICAgICBwYXJhbTogaXQsXFxcXG4gICAgICAgICAgICAgICAgaWQ6IFxcXFxcXFwicnVsZUBcXFxcXFxcIiArIGl0Lm5hbWVcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSk7XFxcXG5cXFxcbiAgICAgICAgYmF0Y2hFeGVjdXRlKHRhc2tzLCB7XFxcXG4gICAgICAgICAgICBmdW5jOiBmdW5jdGlvbihwYXJhbSwgaWQsIGVycm9yLCByZXN1bHQpIHtcXFxcbiAgICAgICAgICAgICAgICAvL2xvZyhcXFxcXFxcImxpc3RlbmVyOiBcXFxcXFxcIiArIChyZXN1bHQgfHwgW10pLmxlbmd0aClcXFxcbiAgICAgICAgICAgICAgICBwYXJhbS5pID0gcGFyYW0uaSArIDE7XFxcXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xcXFxuICAgICAgICAgICAgICAgICAgICB0cnkge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaXQgb2YgcmVzdWx0KSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW0uaiA9IHBhcmFtLmogKyAxO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZEl0ZW1CZWZvcmUocGFnZWlkLCB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiB3cmFwKGl0LnRpdGxlLCBzKSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzYzogaXQuZGVzYyxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBpdC51cmwsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpY191cmw6IGl0LnBpY191cmwsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbF90eXBlOiBpdC5waWNfdXJsID8gJ21vdmllXzFfdmVydGljYWxfcGljJyA6IFxcXFxcXFwidGV4dF8xXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhOiBpdC5leHRyYVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XFxcXG5cXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtLmkgPj0gcGFyYW0uYWxsKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZUl0ZW0ocGFnZWlkKVxcXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0oe1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi5Yqg6L2956ysXFxcXFxcXCIgKyBNWV9QQUdFICsgXFxcXFxcXCLpobXkuK3vvIzov5vluqbvvJpcXFxcXFxcIiArIChwYXJhbS5pICsgMSkgKyBcXFxcXFxcIi9cXFxcXFxcIiArIHBhcmFtLmFsbCxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogXFxcXFxcXCJcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfY2VudGVyXzFcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2M6IFxcXFxcXFwiXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBwaWNfdXJsOiBcXFxcXFxcIlxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogcGFnZWlkXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgICAgIH0pXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSxcXFxcbiAgICAgICAgICAgIHBhcmFtOiB7XFxcXG4gICAgICAgICAgICAgICAgYWxsOiBkYXRhLmxlbmd0aCxcXFxcbiAgICAgICAgICAgICAgICBpOiAwLFxcXFxuICAgICAgICAgICAgICAgIGo6IC0xXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0pXFxcXG4gICAgfVxcXFxufSBlbHNlIHtcXFxcbiAgICBsZXQge1xcXFxuICAgICAgICBsb2FkXFxcXG4gICAgfSA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9kYXRhXFxcXFxcXCIpO1xcXFxuICAgIGxldCBkYXRhID0gbG9hZCgtMSwgbnVsbCk7XFxcXG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMCkge1xcXFxuICAgICAgICAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvbWFuYWdlXFxcXFxcXCIpKGQsIGRhdGEubWFwKGl0ID0+IGl0Lm5hbWUpKTtcXFxcbiAgICAgICAgZm9yIChsZXQgaXQgb2YgZGF0YSkge1xcXFxuICAgICAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogaXQubmFtZSxcXFxcbiAgICAgICAgICAgICAgICB1cmw6IFxcXFxcXFwic2VsZWN0Oi8vXFxcXFxcXCIgKyBKU09OLnN0cmluZ2lmeSh7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuivt+mAieaLqeaTjeS9nFxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICBjb2w6IDEsXFxcXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IFtcXFxcXFxcIuiuv+mXrummlumhtVxcXFxcXFwiLCBcXFxcXFxcIuaQnOe0ouatpOermVxcXFxcXFwiXSxcXFxcbiAgICAgICAgICAgICAgICAgICAganM6ICQudG9TdHJpbmcoKHVybCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0ID09IFxcXFxcXFwi6K6/6Zeu6aaW6aG1XFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNWV9VUkwgPSB1cmw7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3A/dT1cXFxcXFxcIiArIGJhc2U2NEVuY29kZShnZXRIb21lKHVybCkpXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vcGFnZS9zaW5nbGVzXFxcXFxcXCJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICAgICAgfSwgaXQudXJsKVxcXFxuICAgICAgICAgICAgICAgIH0pLFxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImZsZXhfYnV0dG9uXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgZGVzYzogXFxcXFxcXCJcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICBwaWNfdXJsOiBcXFxcXFxcIlxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIFJVTEU6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGl0Lm5hbWUsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGl0LnVybFxcXFxuICAgICAgICAgICAgICAgICAgICB9LFxcXFxuICAgICAgICAgICAgICAgICAgICBsb25nQ2xpY2s6IFt7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLnpoHnlKhcXFxcXFxcIiArIGl0Lm5hbWUsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBqczogJC50b1N0cmluZygobmFtZSkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm0oe1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLmuKnppqjmj5DnpLpcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogXFxcXFxcXCLnoa7orqTliKDpmaTnpoHnlKhcXFxcXFxcIiArIG5hbWUgKyBcXFxcXFxcIuWQl++8n1xcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtOiAkLnRvU3RyaW5nKChuYW1lLCBydWxlKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZVJ1bGVcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvZGF0YT9ydWxlPVxcXFxcXFwiICsgcnVsZSk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVSdWxlKG5hbWUpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8vT0tcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgbmFtZSwgTVlfUlVMRS50aXRsZSlcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGl0Lm5hbWUpXFxcXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuiuv+mXrummlumhtVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAganM6IFxcXFxcXFwiJ2hpa2VyOi8vcGFnZS9wP3U9XFxcXFxcXCIgKyBiYXNlNjRFbmNvZGUoZ2V0SG9tZShpdC51cmwpKSArXFxcXFxcXCInXFxcXFxcXCJcXFxcbiAgICAgICAgICAgICAgICAgICAgfSwge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi5pCc57Si5q2k5rqQXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBqczogXFxcXFxcXCInaGlrZXI6Ly9wYWdlL3NpbmdsZXMnXFxcXFxcXCJcXFxcbiAgICAgICAgICAgICAgICAgICAgfV1cXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgfVxcXFxuICAgIH1cXFxcbn1cXFxcblxcXFxuc2V0UmVzdWx0KGQpO1xcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIuaVsOaNrlxcXCIsXFxcInBhdGhcXFwiOlxcXCJkYXRhXFxcIixcXFwicnVsZVxcXCI6XFxcIi8v5bm25Y+R6KeE5YiZ5pWwXFxcXG5sZXQgc2l6ZTAgPSAxMDtcXFxcbmxldCBydWxlc1RleHQwID0gYPCfkK/ngavngavotYTmupDwn5CvQGh0dHA6Ly93d3cuaG5mY2pyLmNvbS9zby9tLz9rPSoqXFxcXG7wn5Cv5LmQ5LmQ6LWE5rqQ8J+Qr0BodHRwOi8vd3d3LjZsbC5jb20vc28vbS8/az0qKlxcXFxu8J+Qr+ebkuWtkEBodHRwczovL3d3dy5oZXppcGllLmNvbS8/cz0qKlxcXFxu8J+Qr+aWsOWIhuS6q+iAhfCfkK9AaHR0cHM6Ly93d3cuZmVueG0uY29tL3NlYXJjaC5waHA/cT0qKlxcXFxu8J+Qr+iTnemyqOi1hOa6kPCfkK9AaHR0cHM6Ly93d3cubGFuLXNoYS5jb20vP3M9KipcXFxcbvCfkK/phbflupNAaHR0cHM6Ly93d3cuenhraS5jbi8/a2V5d29yZD0qKlxcXFxu8J+Qr0FwcOWWteaQnPCfkK9AaHR0cHM6Ly93d3cuYXBwbWl1LmNvbS8/cz0qKiZ0eXBlPXBvc3RcXFxcbvCfkK/lpaXlhZTlhZTmkJzwn5CvQGh0dHA6Ly93d3cuYW90dXR1LmNuL3NlYXJjaC8/a2V5d29yZD0qKlxcXFxu8J+Qr+iTneeCuUBodHRwczovL3d3dy5sYW5kaWFubmV3cy5jb20vc2VhcmNoLyoqP3Bvc3RfdHlwZT1wb3N0XFxcXG7wn5CvUeS6kei1hOa6kPCfkK9AaHR0cHM6Ly93d3cucXl1bi52aXAvP2tleXdvcmQ9KipcXFxcbvCfkK9RUei1hOa6kPCfkK9AaHR0cHM6Ly93d3cucXF6eWcuY24vc2VhcmNoP2tleXdvcmQ9KipcXFxcbvCfkK/lpJzmsrPmkJxAaHR0cDovL3d3dy55ZWhlcy5jb20vP2NhdD0mcz0qKlxcXFxu8J+QrzVpbHLotYTmupDwn5CvQGh0dHBzOi8vd3d3LjVpbHIuY29tLz9zPSoqJmNhdD0wXFxcXG7wn5Cv6bih55uS6LWE5rqQ8J+Qr0BodHRwczovL2Nhb25pYW5nLm5ldC9zZWFyY2gvKiouaHRtbFxcXFxu8J+Qr+i3r+e+vUBodHRwczovL3d3dy5qaXNodXNvbmdzaHUuY29tLz9zPSoqJnBvc3RfdHlwZT1wb3N0XFxcXG7wn5Cv5LiN5q276bif5pCc8J+Qr0BodHRwczovL2l1aS5zdS9zZWFyY2gvKiovXFxcXG7wn5Cv5rqQ56CB6LWE5rqQ8J+Qr0BodHRwczovL3d3dy5zY29kZTEuY29tL3NlYXJjaC8/a2V5d29yZD0qKlxcXFxu8J+Qr+WknOmbqEBodHRwczovL3d3dy55ZXl1bGluZ2ZlbmcuY29tLz9zPSoqXFxcXG7wn5Cv546J57Gz57KS5pCc8J+Qr0BodHRwczovL3lpbWlsaS5uZXQvP3M9KipcXFxcbvCfkK/mnKjpo47ova/ku7bwn5CvQGh0dHBzOi8vd3d3Lm1mcmp6LmNvbS8/cz0qKlxcXFxu8J+QrzcyNzNAaHR0cDovL3MuNzI3My5jb20vbS8/az0qKlxcXFxu8J+Qr+a1t+ajoOi1hOa6kPCfkK9AaHR0cHM6Ly93d3cuaGFpdGFuZ3cuY2MvP3M9KipcXFxcbvCfkK/lsI/oj4zotYTmupDwn5CvQGh0dHBzOi8vd3d3Lnd3dHRsLmNvbS8/cz0qKlxcXFxu8J+Qr+WfuuWcsEBodHRwOi8vcmpqZDYuY29tL3NlYXJjaD9tb2xkcz1hcnRpY2xlJndvcmQ9KipcXFxcbvCfkK/liY3mlrnotYTmupDwn5CvQGh0dHBzOi8vcWlhbmZhbmd6eS5jb20vP3M9KipcXFxcbvCfkK/kuZDkuqvotYTmupDwn5CvQGh0dHBzOi8vd3d3Lmx4YXBrLmNvbS8/cz0qKiZ0eXBlPXBvc3RcXFxcbvCfkK/mjbflvoRAaHR0cHM6Ly9zaGFyZWN1dHMuY24vc2VhcmNoP3E9KipcXFxcbvCfkK9wb2ppZei1hOa6kPCfkK9AaHR0cHM6Ly93d3cucG9qaWVzLmNuLz9zPSoqJnR5cGU9cG9zdFxcXFxu8J+Qr01lbW9yefCfkK9AaHR0cHM6Ly9jbnhpYW9iYWkuY29tL3NlYXJjaD9rZXl3b3JkPSoqXFxcXG7wn5Cv5bCP5Y+vQGh0dHBzOi8vd3d3LnFrZWtlLmNvbS8/cz0qKlxcXFxu8J+Qr+eIseWFjei0ueWQp/CfkK9AaHR0cHM6Ly93d3cuaW1mOC5jbi9zZWFyY2gvKiouaHRtbFxcXFxu8J+Qr+a3seiTneS4i+i9vfCfkK9AaHR0cHM6Ly9kb3dubG9hZC5zZW5scy5jbi9zZWFyY2gvP2tleXdvcmQ9KipcXFxcbvCfkK/nuqLlsJhAaHR0cHM6Ly93d3cuaGN3My5jbi9zZWFyY2gvKiouaHRtbFxcXFxu8J+QrzY3OOi+heWKqfCfkK9AaHR0cHM6Ly93d3cuNjc4Y3YuY29tL2luZGV4LnBocD9rZXl3b3JkPSoqXFxcXG7wn5Cv5pyJ6Laj5rqQ56CB8J+Qr0BodHRwczovL3d3dy55cXltLm5ldC8/cz0qKlxcXFxu8J+Qr+ezu+e7n0BodHRwczovL3d3dy54aXRtaS5jb20vP3M9KipcXFxcbvCfkK/liIbkuqvotYTmupDwn5CvQGh0dHBzOi8vd3d3Lnlweml5dWFuc2hhcmUuY2x1Yi9zZWFyY2gucGhwP3E9KipcXFxcbvCfkK/mtL7mo67nm5LlrZDwn5CvQGh0dHBzOi8vd3d3LnB5aGV6aS5jb20vP3M9KipcXFxcbvCfkK/liJ3op4FAaHR0cHM6Ly93d3cueWJjajA5MDcuY29tLz9zPSoqJmNhdD1cXFxcbvCfkK/kuqTmtYHlspvmkJzwn5CvQGh0dHBzOi8vd3d3LmppYW9saXVkYW8uY29tLz9zPSoqXFxcXG7wn5Cv5LiL6L296LWE5rqQ8J+Qr0BodHRwczovL20ueHpqaS5jb20vc2VhcmNoL2FsbC0wLTEtKiouaHRtbFxcXFxu8J+Qr+W6lOeUqEBodHRwczovL3d3dy5pYXBwcy5tZS9hcmNoaXZlcy9jYXRlZ29yeS90dlxcXFxu8J+Qr+mFtzjovoXliqnwn5CvQGh0dHBzOi8vd3d3LjE5Znp3LmNvbS9pbmRleC5waHA/a2V5d29yZD0qKlxcXFxu8J+Qr+aegeWuouS4i+i9vfCfkK9AaHR0cHM6Ly93d3cuZ2Vla2Rsb2FkLmNvbS8/cz0qKlxcXFxu8J+Qr+maj+mjjkBodHRwczovL3d3dy41Mm5mdy5jbi8/cz0qKiZ0eXBlPXBvc3RcXFxcbvCfkK/lh6HlsJjotYTmupDwn5CvQGh0dHBzOi8vd3d3LjUwZmN3LmNvbS9pbmRleC5waHA/a2V5d29yZD0qKiZ0eXBlaWQ9MFxcXFxu8J+Qr+W/g+a1t0Xnq5nwn5CvQGh0dHBzOi8vYXBwaG90LmNjLz9zPSoqXFxcXG7wn5Cv5p2C6LSn6ZO6QGh0dHBzOi8vdG1pb2UuY29tLz9zPSoqXFxcXG7wn5Cv5aSn55y85LuU5pCc8J+Qr0BodHRwOi8vd3d3LmRheWFuemFpLm1lLz9zPSoqXFxcXG7wn5Cv6aOY6YGl6LWE5rqQ8J+Qr0BodHRwczovL3d3dy5tcHlpdC5jb20vP3M9KipcXFxcbvCfkK/ova7lm55AaHR0cHM6Ly93d3cuY2hlbmJvLmluZm8vP3M9KipcXFxcbvCfkK/mnqvpn7PlupTnlKjwn5CvQGh0dHBzOi8vd3d3LmZ5NmIuY29tLz9zPSoqXFxcXG7wn5Cv5ZOH5ZaU6I+M5pCc8J+Qr0BodHRwczovL3d3dy53YW9kb3duLmNvbS9zZWFyY2gvKipcXFxcbvCfkK/kuZ3ova9AaHR0cHM6Ly93d3cuam9ydWFuLmNvbS8/cz0qKlxcXFxu8J+Qr2kz56S+5Yy68J+Qr0BodHRwczovL3d3dy5pM3poLmNvbS8/cz0qKlxcXFxu8J+Qr+i1hOa6kOWQpuaQnPCfkK9AaHR0cHM6Ly93d3cuenlmb3UuY29tLz9zPSoqXFxcXG7wn5Cv6KW/6KW/5pCcQGh0dHBzOi8vc28uY3IxNzMuY29tL3NvdXN1by9tLz9rPSoqXFxcXG7wn5Cv5peg55eV5ZOl5pCc8J+Qr0BodHRwczovL3d3dy53aGc2LmNvbS80NjU4Lmh0bWxcXFxcbvCfkK/niLHnlZnotYTmupDwn5CvQGh0dHA6Ly96eXcuaTYuZ3MvaW5kZXgucGhwP2tleXdvcmQ9KipcXFxcbvCfkK/lsI/kvJdAaHR0cHM6Ly93d3cuYXBwaW5uLmNvbS8/cz0qKlxcXFxu8J+Qr+m7kea1t+a0i+aQnPCfkK9AaHR0cHM6Ly9ibG9nLnVweDguY29tL3NlYXJjaC8qKi9cXFxcbvCfkK/lhYXnlLXnq5nmkJzwn5CvQGh0dHBzOi8vd3d3LmNvY29rbC5jbi8/cz0qKlxcXFxu8J+Qr+iJvuiWh0BodHRwOi8vbS5haXdlaWJrLmNvbS9zZWFyY2gvKiouaHRtbFxcXFxu8J+QrzfkuIvovb3mkJzwn5CvQGh0dHBzOi8vd3d3Ljd4aWF6YWkuY29tLz9zPSoqXFxcXG7wn5Cv57K+5ZOB6LWE5rqQ8J+Qr0BodHRwOi8vd3d3Lmo5cC5jb20vc28vbS8/az0qKlxcXFxu8J+Qr+iTneihq+aQnEBodHRwczovL3d3dy5ibHVlbHNxa2ouY29tLz9zPSoqXFxcXG7wn5CvQeWnkOWIhuS6q/CfkK9AaHR0cHM6Ly93d3cuYWhoaGhmcy5jb20vP2NhdD0mcz0qKlxcXFxu8J+Qr+WQvueIsei9r+S7tvCfkK9AaHR0cHM6Ly93d3cudmlwdG9vbHMudmlwLz9zPSoqJnR5cGU9cG9zdFxcXFxu8J+Qr+e+veWFlOe9kUBodHRwczovL20ueXV0dS5jbi9zZWFyY2gvc29mdC5odG1sP3Q9MzImaz0qKlxcXFxu8J+Qr+aenOaguOWJpeWjs/CfkK9AaHR0cHM6Ly93d3cuZ2h4aS5jb20vP3M9KipcXFxcbvCfkK80MjNEb3du8J+Qr0BodHRwczovL3d3dy40MjNkb3duLmNvbS9zZWFyY2gvKipcXFxcbvCfkK9GSOaQnEBodHRwczovL2ZpbGVoaXBwby5jb20vemgvc2VhcmNoLz9xPSoqXFxcXG7wn5Cv5LyY57Gz5qC85pCc8J+Qr0BodHRwczovL3d3dy40c3BhY2VzLm9yZy8/cz0qKlxcXFxu8J+Qr0FsdGVybuaQnPCfkK9AaHR0cHM6Ly9hbHRlcm5hdGl2ZXRvLm5ldC9icm93c2Uvc2VhcmNoLz9xPSoqXFxcXG7wn5CvU09T8J+Qr0BodHRwczovL3d3dy5yanNvcy5jb20vc2VhcmNoP3M9KipcXFxcbvCfkK9aTkRT6K665Z2b8J+Qr0BodHRwOi8vemhhbm5laS5iYWlkdS5jb20vY3NlL3NlYXJjaD9xPSoqJnM9MTM2MjQwMzM4MTg5MjYyMTYxMjVcXFxcbvCfkK9QdXJlc3lz8J+Qr0BodHRwczovL3d3dy5wdXJlc3lzLm5ldC8/cz0qKlxcXFxu8J+Qr0xJVEVAaHR0cHM6Ly9saXRlYXBrcy5jb20vP3M9KipcXFxcbvCfkK/nvZHnm5jkuK3lv4Pwn5CvQGh0dHBzOi8vcGFuLmlzaGFyZXBjLmNvbS8/cz0qKlxcXFxu8J+Qr2lvc+a4uOaIj/CfkK9AaHR0cHM6Ly9uazg3Yy5jbi8/cz0qKlxcXFxu8J+Qr+WzsOWTpfCfkK9AaHR0cHM6Ly96enp6enoubWUvP2tleXdvcmQ9KiomcGFnZT1meXBhZ2VcXFxcbvCfkK/lsI/liIDlqLHkuZDwn5CvQGh0dHBzOi8veGQueDZkLmNvbS9kYW93YW5nc291c3VvP3E9KiomdHlwZWlkPTBcXFxcbvCfkK/lj43mlpfotYTmupDwn5CvQGh0dHBzOi8vd3d3LmFwcHJjbi5jb20vP3M9KipcXFxcbvCfkK/ovoXliqlAaHR0cHM6Ly93d3cuZnV6aHVnb3UuY29tL2ZpbmQvKipcXFxcbvCfkK/nmb3mvILmuLjmiI/wn5CvQGh0dHBzOi8veHh4eHg1MjUuY29tLz9zPSoqXFxcXG7wn5Cv6L2v5Lu25rGJ5YyW8J+Qr0BodHRwczovL2FwcGhvdC5jYy8/cz0qKlxcXFxu8J+Qr+W+ruW9k0BodHRwczovL20ud2VpZG93bi5jb20vc2VhcmNoLmh0bWw/cT0qKlxcXFxu8J+Qr+aCoOS5heWuneW6k/CfkK9AaHR0cHM6Ly91OWJhb2t1Lnh5ei8/cz0qKlxcXFxu8J+Qr+mXsuS4gOmxvOaQnPCfkK9AaHR0cHM6Ly93d3cubWFjcnIuY29tLz9zPSoqXFxcXG7wn5Cv6Jek6L2pQGh0dHBzOi8vd3d3LnRlbmd4dWFudy5jb20vaW5kZXgucGhwP2tleXdvcmQ9KiomdHlwZWlkPTBcXFxcbvCfkK9hcHDng63mkJzwn5CvQGh0dHBzOi8vYXBwaG90LmNjLz9zPSoqXFxcXG7wn5Cv5aWH6Laj6LWE5rqQ8J+Qr0BodHRwczovL2Z1dW4uZnVuL3NlYXJjaD93b3JkPSoqXFxcXG7wn5Cv55qu55quQGh0dHBzOi8vd3d3LnB5enliLmNvbS9pbmRleC5waHA/a2V5d29yZD0qKiZ0eXBlaWQ9MFxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5gO1xcXFxubGV0IHJ1bGVzVGV4dCA9IGdldEl0ZW0oXFxcXFxcXCJydWxlc1xcXFxcXFwiLCBydWxlc1RleHQwKTtcXFxcbmxldCBzcCA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9zcFxcXFxcXFwiKTtcXFxcbnJ1bGVzID0gcnVsZXNUZXh0LnNwbGl0KFxcXFxcXFwiXFxcXFxcXFxuXFxcXFxcXCIpXFxcXG4gICAgLmZpbHRlcihpdCA9PiBpdC5pbmNsdWRlcyhcXFxcXFxcIkBcXFxcXFxcIikpXFxcXG4gICAgLm1hcChydWxlID0+IHtcXFxcbiAgICAgICAgbGV0IHMgPSBydWxlLnNwbGl0KFxcXFxcXFwiQFxcXFxcXFwiKTtcXFxcbiAgICAgICAgcmV0dXJuIHtcXFxcbiAgICAgICAgICAgIG5hbWU6IHNbMF0sXFxcXG4gICAgICAgICAgICBmaW5kOiBmdW5jdGlvbihrZXksIHBhZ2UpIHtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Aoc1sxXSwga2V5LCBzWzBdKTtcXFxcbiAgICAgICAgICAgIH0sXFxcXG4gICAgICAgICAgICB1cmw6IHNbMV1cXFxcbiAgICAgICAgfTtcXFxcbiAgICB9KTtcXFxcblxcXFxuZnVuY3Rpb24gbG9hZChwYWdlLCBydWxlKSB7XFxcXG4gICAgbGV0IHNpemUgPSBwYWdlIDw9IDAgPyBydWxlcy5sZW5ndGggOiBzaXplMDtcXFxcbiAgICBwYWdlID0gcGFnZSA8PSAwID8gMSA6IHBhZ2U7XFxcXG4gICAgaWYgKCFwYWdlICYmICFydWxlKSB7XFxcXG4gICAgICAgIHJldHVybiBydWxlcy5tYXAoaXQgPT4gaXQubmFtZSk7XFxcXG4gICAgfVxcXFxuICAgIGlmIChydWxlICE9IG51bGwpIHtcXFxcbiAgICAgICAgaWYgKHBhZ2UgIT0gbnVsbCAmJiBwYWdlID4gMSkge1xcXFxuICAgICAgICAgICAgcmV0dXJuIHJ1bGVzLmZpbHRlcihpID0+IGkubmFtZSA9PSBydWxlICYmIGkucGFnZSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcmV0dXJuIHJ1bGVzLmZpbHRlcihpID0+IGkubmFtZSA9PSBydWxlKTtcXFxcbiAgICB9XFxcXG4gICAgbGV0IHN0YXJ0ID0gKHBhZ2UgLSAxKSAqIHNpemU7XFxcXG4gICAgaWYgKHJ1bGVzLmxlbmd0aCA8IHN0YXJ0ICsgMSkge1xcXFxuICAgICAgICByZXR1cm4gW107XFxcXG4gICAgfVxcXFxuICAgIGxldCBsZW4gPSBzaXplO1xcXFxuICAgIGlmIChydWxlcy5sZW5ndGggPCBwYWdlICogc2l6ZSkge1xcXFxuICAgICAgICBsZW4gPSBydWxlcy5sZW5ndGggLSBzdGFydFxcXFxuICAgIH1cXFxcbiAgICByZXR1cm4gcnVsZXMuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgbGVuKTtcXFxcbn1cXFxcblxcXFxuZnVuY3Rpb24gYWRkUnVsZShuYW1lLCBzdXJsKSB7XFxcXG4gICAgc2V0SXRlbShcXFxcXFxcInJ1bGVzXFxcXFxcXCIsIHJ1bGVzVGV4dCArIFxcXFxcXFwiXFxcXFxcXFxuXFxcXFxcXCIgKyBuYW1lICsgXFxcXFxcXCJAXFxcXFxcXCIgKyBzdXJsKTtcXFxcbn1cXFxcblxcXFxuZnVuY3Rpb24gYWRkQWxsKGlucHV0KSB7XFxcXG4gICAgaWYgKGlucHV0ID09IG51bGwgfHwgaW5wdXQgPT0gXFxcXFxcXCJcXFxcXFxcIikge1xcXFxuICAgICAgICByZXR1cm4gMDtcXFxcbiAgICB9XFxcXG4gICAgbGV0IGFyciA9IGlucHV0LnNwbGl0KFxcXFxcXFwiXFxcXFxcXFxuXFxcXFxcXCIpXFxcXG4gICAgICAgIC5maWx0ZXIoaXQgPT4gaXQuaW5jbHVkZXMoXFxcXFxcXCJAXFxcXFxcXCIpKVxcXFxuICAgICAgICAubWFwKHJ1bGUgPT4ge1xcXFxuICAgICAgICAgICAgbGV0IHMgPSBydWxlLnNwbGl0KFxcXFxcXFwiQFxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIHJldHVybiB7XFxcXG4gICAgICAgICAgICAgICAgbmFtZTogc1swXSxcXFxcbiAgICAgICAgICAgICAgICB1cmw6IHNbMV1cXFxcbiAgICAgICAgICAgIH07XFxcXG4gICAgICAgIH0pO1xcXFxuICAgIGxldCBleGlzdCA9IHJ1bGVzLm1hcChpdCA9PiBpdC51cmwpO1xcXFxuICAgIGxldCBjID0gMDtcXFxcbiAgICBmb3IgKGxldCBpdCBvZiBhcnIpIHtcXFxcbiAgICAgICAgaWYgKCFleGlzdC5pbmNsdWRlcyhpdC51cmwpKSB7XFxcXG4gICAgICAgICAgICBydWxlc1RleHQgPSBydWxlc1RleHQgKyBcXFxcXFxcIlxcXFxcXFxcblxcXFxcXFwiICsgaXQubmFtZSArIFxcXFxcXFwiQFxcXFxcXFwiICsgaXQudXJsO1xcXFxuICAgICAgICAgICAgYysrO1xcXFxuICAgICAgICB9XFxcXG4gICAgfVxcXFxuICAgIHNldEl0ZW0oXFxcXFxcXCJydWxlc1xcXFxcXFwiLCBydWxlc1RleHQpO1xcXFxuICAgIHJldHVybiBjO1xcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiByZW1vdmVSdWxlKG5hbWUpIHtcXFxcbiAgICBsZXQgbmV3VCA9IHJ1bGVzVGV4dC5zcGxpdChcXFxcXFxcIlxcXFxcXFxcblxcXFxcXFwiKVxcXFxuICAgICAgICAuZmlsdGVyKGl0ID0+IGl0LmluZGV4T2YobmFtZSArIFxcXFxcXFwiQFxcXFxcXFwiKSA8IDApXFxcXG4gICAgICAgIC5qb2luKFxcXFxcXFwiXFxcXFxcXFxuXFxcXFxcXCIpO1xcXFxuICAgIHNldEl0ZW0oXFxcXFxcXCJydWxlc1xcXFxcXFwiLCBuZXdUKTtcXFxcbn1cXFxcblxcXFxuJC5leHBvcnRzID0ge1xcXFxuICAgIGxvYWQ6IGxvYWQsXFxcXG4gICAgYWRkUnVsZTogYWRkUnVsZSxcXFxcbiAgICByZW1vdmVSdWxlOiByZW1vdmVSdWxlLFxcXFxuICAgIGFkZEFsbDogYWRkQWxsXFxcXG59XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5pCc57Si6Kej5p6QXFxcIixcXFwicGF0aFxcXCI6XFxcInNwXFxcIixcXFwicnVsZVxcXCI6XFxcImZ1bmN0aW9uIHNlYXJjaCh1cmwsIGtleSwgcnVsZSkge1xcXFxuICAgIGxldCBkID0gW107XFxcXG4gICAgbGV0IGh0bWwgPSBcXFxcXFxcIlxcXFxcXFwiO1xcXFxuICAgIGlmICh1cmwuaW5jbHVkZXMoXFxcXFxcXCIqKlxcXFxcXFwiKSkge1xcXFxuICAgICAgICAvL2dldOivt+axglxcXFxuICAgICAgICBsZXQgb2xkID0gdXJsO1xcXFxuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShcXFxcXFxcIioqXFxcXFxcXCIsIGtleSk7XFxcXG4gICAgICAgIGh0bWwgPSByZXF1ZXN0KHVybCk7XFxcXG4gICAgICAgIC8v6Ieq5Yqo6L+H6aqM6K+B56CB5ZKM6aKR57mB6K6/6Zeu6ZmQ5Yi2XFxcXG4gICAgICAgIGxldCB7XFxcXG4gICAgICAgICAgICBjaGVjaywgdGVzdFxcXFxuICAgICAgICB9ID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3l6bVxcXFxcXFwiKTtcXFxcbiAgICAgICAgaWYgKGNoZWNrKHVybCwgaHRtbCwgZCkpIHtcXFxcbiAgICAgICAgICAgIGxvZyhcXFxcXFxcIumHjeivleS6hlxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIGh0bWwgPSByZXF1ZXN0KHVybCwge1xcXFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJSZWZlcmVyXFxcXFxcXCI6IHVybFxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH0pOyAgICAgICAgICAgXFxcXG4gICAgICAgIH0gICAgICAgICBcXFxcbiAgICAgICAgdGVzdCh1cmwsIGh0bWwsIGQsIG9sZCwga2V5LCBydWxlKTtcXFxcbiAgICB9IGVsc2Uge1xcXFxuICAgICAgICAvL+iHquWKqOivhuWIq3Bvc3Tor7fmsYJcXFxcbiAgICAgICAgaHRtbCA9IHJlcXVlc3QodXJsKTtcXFxcbiAgICAgICAgbGV0IGZvcm0gPSBwZGZoKGh0bWwsIFxcXFxcXFwiYm9keSYmZm9ybSYmSHRtbFxcXFxcXFwiKTtcXFxcbiAgICAgICAgbGV0IGFjdGlvbiA9IHBkKGh0bWwsIFxcXFxcXFwiZm9ybSYmYWN0aW9uXFxcXFxcXCIsIHVybCk7XFxcXG4gICAgICAgIGxldCBpbnB1dHMgPSBwZGZhKGh0bWwsIFxcXFxcXFwiYm9keSYmZm9ybSYmaW5wdXRcXFxcXFxcIik7XFxcXG4gICAgICAgIGxldCBib2R5ID0ge307XFxcXG4gICAgICAgIGZvciAobGV0IGl0IG9mIGlucHV0cykge1xcXFxuICAgICAgICAgICAgbGV0IG5hbWUgPSBwZGZoKGl0LCBcXFxcXFxcImlucHV0JiZuYW1lXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgaWYgKG5hbWUgJiYgbmFtZSAhPSBcXFxcXFxcIlxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gcGRmaChpdCwgXFxcXFxcXCJpbnB1dCYmdmFsdWVcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgYm9keVtuYW1lXSA9IHZhbHVlIHx8IGtleTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBodG1sID0gcG9zdChhY3Rpb24sIHtcXFxcbiAgICAgICAgICAgIGJvZHk6IGJvZHlcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgfVxcXFxuXFxcXG4gICAgbGV0IGFsaXN0ID0gcGRmYShodG1sLCBcXFxcXFxcImJvZHkmJmFcXFxcXFxcIik7XFxcXG4gICAgbGV0IGFyciA9IGFsaXN0Lm1hcChpdCA9PiB7XFxcXG4gICAgICAgIGxldCB0ID0gcGRmaChpdCwgXFxcXFxcXCJhJiZUZXh0XFxcXFxcXCIpO1xcXFxuICAgICAgICBsZXQgdDIgPSBwZGZoKGl0LCBcXFxcXFxcImEmJnRpdGxlXFxcXFxcXCIpO1xcXFxuICAgICAgICByZXR1cm4ge1xcXFxuICAgICAgICAgICAgLy9odG1sOiBpdCxcXFxcbiAgICAgICAgICAgIHRleHQ6IHQyICYmIHQyLmluY2x1ZGVzKGtleSkgPyB0MiA6IHQsXFxcXG4gICAgICAgICAgICBocmVmOiBwZChpdCwgXFxcXFxcXCJhJiZocmVmXFxcXFxcXCIsIHVybClcXFxcbiAgICAgICAgfVxcXFxuICAgIH0pO1xcXFxuXFxcXG4gICAgZnVuY3Rpb24gaXNSZXN1bHQoaXQpIHtcXFxcbiAgICAgICAgaXQgPSBpdC50ZXh0IHx8IFxcXFxcXFwiXFxcXFxcXCI7XFxcXG4gICAgICAgIGlmIChpdCA9PSBcXFxcXFxcIlxcXFxcXFwiIHx8IGl0Lm1hdGNoKC/mkJzntKJ857uT5p6cLykpIHtcXFxcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHJldHVybiBpdC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGtleSk7XFxcXG4gICAgfVxcXFxuICAgIGtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xcXFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XFxcXG4gICAgICAgIGxldCBpdCA9IGFycltpXTtcXFxcbiAgICAgICAgbGV0IHQgPSBpdC50ZXh0O1xcXFxuICAgICAgICBpZiAoIWl0LmhyZWYgfHwgaXQuaHJlZiA9PSBcXFxcXFxcIlxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICBjb250aW51ZTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBpZiAoaXNSZXN1bHQoaXQpKSB7XFxcXG4gICAgICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiB0LFxcXFxuICAgICAgICAgICAgICAgIHVybDogXFxcXFxcXCJoaWtlcjovL3BhZ2UvcD91PVxcXFxcXFwiICsgYmFzZTY0RW5jb2RlKGl0LmhyZWYpLFxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIGRlc2M6IFxcXFxcXFwi4oCc4oCc4oCd4oCdPGZvbnQgY29sb3I9I2YxM2I2NmE+XFxcXFxcXCIgKyBydWxlICsgXFxcXFxcXCI8L2ZvbnQ+XFxcXFxcXCJcXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICB9XFxcXG4gICAgfVxcXFxuICAgIHJldHVybiBkO1xcXFxufVxcXFxuJC5leHBvcnRzID0gc2VhcmNoO1xcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIuWinuWIoFxcXCIsXFxcInBhdGhcXFwiOlxcXCJtYW5hZ2VcXFwiLFxcXCJydWxlXFxcIjpcXFwiJC5leHBvcnRzID0gZnVuY3Rpb24oZCwgbmFtZXMpIHtcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogXFxcXFxcXCJBSeaKgOacr1xcXFxcXFwiLFxcXFxuICAgICAgICB1cmw6IFxcXFxcXFwiY29uZmlybTovL+WfuuS6jkFJ6K+G54mH6Ieq5Yqo5YiG5p6Q5rqQ56CB5oqA5pyv77yM5Luj56CB5a6M5YWo5byA5rqQ77yM5pWw5o2u5p2l5rqQ5LqO5Y6f572R56uZ77yM6L2v5Lu25ZKM6KeE5YiZ5LiN5o+Q5L6b5Lu75L2V5YaF5a65LmpzOicnXFxcXFxcXCIsXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImZsZXhfYnV0dG9uXFxcXFxcXCJcXFxcbiAgICB9KTtcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogXFxcXFxcXCIgKyBcXFxcXFxcIixcXFxcbiAgICAgICAgdXJsOiAkKFxcXFxcXFwiI25vTG9hZGluZyNcXFxcXFxcIikubGF6eVJ1bGUoKHJyKSA9PiB7XFxcXG4gICAgICAgICAgICBkZWxldGVJdGVtQnlDbHMoXFxcXFxcXCJhaWFkZFxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIGFkZEl0ZW1BZnRlcihyciArIFxcXFxcXFwiYWlzZGVsXFxcXFxcXCIsIFt7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIlxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICBkZXNjOiBcXFxcXFxcIuivt+i+k+WFpee9keermeWQjeensFxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJpbnB1dFxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGVWaXNpYmxlOiBmYWxzZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBcXFxcXFxcInB1dE15VmFyKCduYW1lJywgaW5wdXQpXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBjbHM6IFxcXFxcXFwiYWlhZGRcXFxcXFxcIlxcXFxuICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgfSxcXFxcbiAgICAgICAgICAgICAgICB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIlxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICBkZXNjOiBcXFxcXFxcIuivt+i+k+WFpee9keermeaQnOe0ouWcsOWdgFxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJpbnB1dFxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGVWaXNpYmxlOiBmYWxzZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBcXFxcXFxcInB1dE15VmFyKCdzdXJsJywgaW5wdXQpXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBjbHM6IFxcXFxcXFwiYWlhZGRcXFxcXFxcIlxcXFxuICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgfSxcXFxcbiAgICAgICAgICAgICAgICB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuaPkOS6pOS/neWtmFxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0X2NlbnRlcl8xXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogJChcXFxcXFxcIiNub0xvYWRpbmcjXFxcXFxcXCIpLmxhenlSdWxlKCgpID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdXJsID0gZ2V0TXlWYXIoXFxcXFxcXCJzdXJsXFxcXFxcXCIsIFxcXFxcXFwiXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5hbWUgPSBnZXRNeVZhcihcXFxcXFxcIm5hbWVcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3VybCA9PSBcXFxcXFxcIlxcXFxcXFwiIHx8IG5hbWUgPT0gXFxcXFxcXCJcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v6K+36L6T5YWl5a6M5pW05YaF5a65XFxcXFxcXCJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByID0gZGVjb2RlVVJJQ29tcG9uZW50KHN1cmwpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgciA9IHIucmVwbGFjZShuZXcgUmVnRXhwKFxcXFxcXFwiW1xcXFxcXFxcdTRlMDAtXFxcXFxcXFx1OWZhNV0rXFxcXFxcXCIsIFxcXFxcXFwiZ1xcXFxcXFwiKSwgXFxcXFxcXCIqKlxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkUnVsZVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9kYXRhXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkUnVsZShuYW1lLCByKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+W3suS/neWtmFxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgICAgICAgICB9KSxcXFxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsczogXFxcXFxcXCJhaWFkZFxcXFxcXFwiXFxcXG4gICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICBdKTtcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIlxcXFxuICAgICAgICB9LCBNWV9SVUxFLnRpdGxlKSxcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiZmxleF9idXR0b25cXFxcXFxcIixcXFxcbiAgICB9KTtcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogXFxcXFxcXCIgLSBcXFxcXFxcIixcXFxcbiAgICAgICAgdXJsOiBcXFxcXFxcInNlbGVjdDovL1xcXFxcXFwiICsgSlNPTi5zdHJpbmdpZnkoe1xcXFxuICAgICAgICAgICAgb3B0aW9uczogbmFtZXMsXFxcXG4gICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLor7fpgInmi6nopoHliKDpmaTnmoTnq5nngrlcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGpzOiAkLnRvU3RyaW5nKCgpID0+IHtcXFxcbiAgICAgICAgICAgICAgICBsZXQge1xcXFxuICAgICAgICAgICAgICAgICAgICByZW1vdmVSdWxlXFxcXG4gICAgICAgICAgICAgICAgfSA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9kYXRhXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgIHJlbW92ZVJ1bGUoaW5wdXQpO1xcXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly9PS1xcXFxcXFwiO1xcXFxuICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgfSksXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImZsZXhfYnV0dG9uXFxcXFxcXCJcXFxcbiAgICB9KTtcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogXFxcXFxcXCLihpfvuI9cXFxcXFxcIixcXFxcbiAgICAgICAgdXJsOiAkKFxcXFxcXFwiI25vTG9hZGluZyNcXFxcXFxcIikubGF6eVJ1bGUoKCkgPT4ge1xcXFxuICAgICAgICAgICAgY29uZmlybSh7XFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi5rip6aao5o+Q56S6XFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgY29udGVudDogXFxcXFxcXCLnoa7lrprlr7zlh7rmiYDmnInmlbDmja7lkJfvvJ/vvIjlr7zlh7rlkI7lj6/ku6Xngrnlh7vml4HovrnnmoTlr7zlhaXmjInpkq7mibnph4/lr7zlhaXvvIlcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICBjb25maXJtOiAkLnRvU3RyaW5nKCgpID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRcXFxcbiAgICAgICAgICAgICAgICAgICAgfSA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9kYXRhXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IGxvYWQoLTEpO1xcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgcyA9IGRhdGEubWFwKGl0ID0+IGl0Lm5hbWUgKyBcXFxcXFxcIkBcXFxcXFxcIiArIGl0LnVybCkuam9pbihcXFxcXFxcIlxcXFxcXFxcblxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiY29weTovL1xcXFxcXFwiICsgc1xcXFxuICAgICAgICAgICAgICAgIH0pXFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIlxcXFxuICAgICAgICB9KSxcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiZmxleF9idXR0b25cXFxcXFxcIixcXFxcbiAgICB9KTtcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogXFxcXFxcXCLihpjvuI9cXFxcXFxcIixcXFxcbiAgICAgICAgdXJsOiAkKFxcXFxcXFwiXFxcXFxcXCIsIFxcXFxcXFwi6K+36L6T5YWl6KaB5om56YeP5a+85YWl55qE5pWw5o2uXFxcXFxcXCIpLmlucHV0KCgpID0+IHtcXFxcbiAgICAgICAgICAgIGxldCB7XFxcXG4gICAgICAgICAgICAgICAgYWRkQWxsXFxcXG4gICAgICAgICAgICB9ID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL2RhdGFcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICBsZXQgY291bnQgPSBhZGRBbGwoaW5wdXQpO1xcXFxuICAgICAgICAgICAgaWYgKGNvdW50ID4gMCkgcmVmcmVzaFBhZ2UoKTtcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8vXFxcXFxcXCIgKyAoY291bnQgPiAwID8gXFxcXFxcXCLmiJDlip/lr7zlhaVcXFxcXFxcIiArIGNvdW50ICsgXFxcXFxcXCLmnaHmlbDmja5cXFxcXFxcIiA6IFxcXFxcXFwi5LiA5p2h5Lmf5rKh5a+85YWlXFxcXFxcXCIpXFxcXG4gICAgICAgIH0pLFxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJmbGV4X2J1dHRvblxcXFxcXFwiLFxcXFxuICAgIH0pO1xcXFxuICAgIGQucHVzaCh7XFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImJsYW5rX2Jsb2NrXFxcXFxcXCIsXFxcXG4gICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICBpZDogTVlfUlVMRS50aXRsZSArIFxcXFxcXFwiYWlzZGVsXFxcXFxcXCJcXFxcbiAgICAgICAgfVxcXFxuICAgIH0pO1xcXFxuXFxcXG59XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi6aqM6K+B56CBXFxcIixcXFwicGF0aFxcXCI6XFxcInl6bVxcXCIsXFxcInJ1bGVcXFwiOlxcXCJmdW5jdGlvbiBjaGVjayh1cmwsIGh0bWwsIGQpIHtcXFxcbiAgICBsZXQgcmVsb2FkID0gZmFsc2U7XFxcXG4gICAgcmV0dXJuIHJlbG9hZDtcXFxcbn1cXFxcblxcXFxuZnVuY3Rpb24gdGVzdCh1cmwsIGh0bWwsIGQsIG9sZCwga2V5LCBydWxlKSB7XFxcXG4gICAgaWYgKC8156eSfOmikee5gS8udGVzdChodG1sKSkge1xcXFxuICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgdGl0bGU6ICfmkJzntKLpnIDpl7TpmpQ156eS77yM54K55Ye76YeN5paw5Yqg6L29JyxcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgZGVzYzogXFxcXFxcXCLigJzigJzigJ3igJ08Zm9udCBjb2xvcj0jZjEzYjY2YT5cXFxcXFxcIiArIHJ1bGUgKyBcXFxcXFxcIjwvZm9udD5cXFxcXFxcIixcXFxcbiAgICAgICAgICAgIHVybDogJCgpLmxhenlSdWxlKCh1cmwsIG9sZCwga2V5LCBydWxlKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHNwID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3NwXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgIGxldCBkID0gc3Aob2xkLCBrZXksIHJ1bGUpO1xcXFxuICAgICAgICAgICAgICAgIGxldCB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHdyYXBcXFxcbiAgICAgICAgICAgICAgICB9ID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3Rvb2xcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaXQgb2YgZCkge1xcXFxuICAgICAgICAgICAgICAgICAgICBpdC50aXRsZSA9IHdyYXAoaXQudGl0bGUsIGtleSk7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIGFkZEl0ZW1BZnRlcih1cmwsIGQpO1xcXFxuICAgICAgICAgICAgICAgIGRlbGV0ZUl0ZW0odXJsKTtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL09LXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICB9LCB1cmwsIG9sZCwga2V5LCBydWxlKSxcXFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgaWQ6IHVybFxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9KTtcXFxcbiAgICB9XFxcXG59XFxcXG5cXFxcbiQuZXhwb3J0cyA9IHtcXFxcbiAgICBjaGVjazogY2hlY2ssXFxcXG4gICAgdGVzdDogdGVzdFxcXFxufVxcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIuW3peWFt1xcXCIsXFxcInBhdGhcXFwiOlxcXCJ0b29sXFxcIixcXFwicnVsZVxcXCI6XFxcImZ1bmN0aW9uIHdyYXAodGV4dCwgcykge1xcXFxuICAgIHJldHVybiB0ZXh0LmluY2x1ZGVzKFxcXFxcXFwi4oCc4oCc4oCd4oCdXFxcXFxcXCIpID8gdGV4dCA6IFxcXFxcXFwi4oCc4oCc4oCd4oCdXFxcXFxcXCIgKyB0ZXh0LnJlcGxhY2UobmV3IFJlZ0V4cChcXFxcXFxcIjxlbT58PC9lbT5cXFxcXFxcIiwgXFxcXFxcXCJnXFxcXFxcXCIpLCBcXFxcXFxcIlxcXFxcXFwiKS5yZXBsYWNlKG5ldyBSZWdFeHAocywgXFxcXFxcXCJnXFxcXFxcXCIpLCBcXFxcXFxcIjxzdHJvbmc+PHNwYW4gc3R5bGU9XFxcXFxcXFxcXFxcXFxcImNvbG9yOiAjMUU5MEZGXFxcXFxcXFxcXFxcXFxcIj5cXFxcXFxcIiArIHMgKyBcXFxcXFxcIjwvc3Bhbj48L3N0cm9uZz5cXFxcXFxcIilcXFxcbn1cXFxcbiQuZXhwb3J0cyA9IHtcXFxcbiAgICB3cmFwOiB3cmFwXFxcXG59XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5Y2V5pCcXFxcIixcXFwicGF0aFxcXCI6XFxcInNpbmdsZXNcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG52YXIgZCA9IFtdO1xcXFxuZC5wdXNoKHtcXFxcbiAgICB0aXRsZTogXFxcXFxcXCLmkJzntKJcXFxcXFxcIixcXFxcbiAgICB1cmw6ICQudG9TdHJpbmcoKCkgPT4ge1xcXFxuICAgICAgICBwdXRNeVZhcihcXFxcXFxcInNvXFxcXFxcXCIsIGlucHV0KTtcXFxcbiAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcbiAgICB9KSxcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJpbnB1dFxcXFxcXFwiLFxcXFxuICAgIGRlc2M6IFxcXFxcXFwi6K+36L6T5YWl5YWz6ZSu6K+N77yM5bC96YeP5bCR5a2X5LiN6KaB5aSa5a2XXFxcXFxcXCIsXFxcXG4gICAgcGljX3VybDogXFxcXFxcXCJcXFxcXFxcIixcXFxcbiAgICBleHRyYToge1xcXFxuICAgICAgICBkZWZhdWx0VmFsdWU6IGdldE15VmFyKFxcXFxcXFwic29cXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIilcXFxcbiAgICB9XFxcXG59KTtcXFxcbmxldCBzID0gZ2V0TXlWYXIoXFxcXFxcXCJzb1xcXFxcXFwiLCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbmxldCByID0gXFxcXFxcXCJcXFxcXFxcIjtcXFxcbmlmIChzICE9IFxcXFxcXFwiXFxcXFxcXCIpIHtcXFxcbiAgICBsZXQgcCA9IE1ZX1BBR0U7XFxcXG4gICAgbGV0IHtcXFxcbiAgICAgICAgbG9hZFxcXFxuICAgIH0gPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvZGF0YVxcXFxcXFwiKTtcXFxcbiAgICBsZXQge1xcXFxuICAgICAgICB3cmFwXFxcXG4gICAgfSA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS90b29sXFxcXFxcXCIpO1xcXFxuICAgIGxldCBkYXRhID0gbG9hZChwLCBNWV9QQVJBTVMuUlVMRS5uYW1lKTtcXFxcbiAgICBsZXQgYXJyID0gZGF0YVswXS5maW5kKHMsIHApO1xcXFxuICAgIGZvciAobGV0IGl0IG9mIGFycikge1xcXFxuICAgICAgICBpdC50aXRsZSA9IHdyYXAoaXQudGl0bGUsIHMpXFxcXG4gICAgICAgIGQucHVzaChpdCk7XFxcXG4gICAgfVxcXFxufVxcXFxuc2V0UmVzdWx0KGQpO1xcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIuaQnOe0oumhtemdolxcXCIsXFxcInBhdGhcXFwiOlxcXCJzb3VwXFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxudmFyIGQgPSBbXTtcXFxcbmlmIChNWV9QQVJBTVMua2V5ICYmIGdldE15VmFyKFxcXFxcXFwidXNlXFxcXFxcXCIsIFxcXFxcXFwiXFxcXFxcXCIpID09IFxcXFxcXFwiXFxcXFxcXCIpIHtcXFxcbiAgICBwdXRNeVZhcihcXFxcXFxcInNvdVxcXFxcXFwiLCBNWV9QQVJBTVMua2V5KTtcXFxcbiAgICBwdXRNeVZhcihcXFxcXFxcInVzZVxcXFxcXFwiLCBcXFxcXFxcIjFcXFxcXFxcIik7XFxcXG4gICAgYWRkTGlzdGVuZXIoXFxcXFxcXCJvbkNsb3NlXFxcXFxcXCIsICQudG9TdHJpbmcoKCkgPT4ge1xcXFxuICAgICAgICBjbGVhck15VmFyKFxcXFxcXFwidXNlXFxcXFxcXCIpO1xcXFxuICAgIH0pKTtcXFxcbn1cXFxcbiQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL3BybycpXFxcIn1dXCIsXCJwcm94eVwiOlwiXCJ9IiwidGl0bGUiOiLwn5Cv55uS5a2QIn0=
ND5YEp6P,MoveZeroes task solution,kivilevd,PL/SQL,Thursday 29th of June 2023 09:44:40 AM CDT,"--- MoveZeroes task solution. Kivilev DS. Oracle Developer
declare
  type t_nums is table of number(38);
  v_actual_nums   t_nums := t_nums(0, 12, 1, 3, 0);
  v_expected_nums t_nums := t_nums(12, 1, 3, 0, 0);

  procedure move_element_to_end(p_nums                  in out nocopy t_nums
                               ,p_move_element_position pls_integer
                               ,p_size_limit            pls_integer) is
    v_tmp number(38);
  begin
    for i in p_move_element_position .. p_size_limit - 1 loop
      v_tmp := p_nums(i + 1);
      p_nums(i + 1) := p_nums(i);
      p_nums(i) := v_tmp;
    end loop;
  end;

  function move_zeroes(p_nums t_nums) return t_nums is
    v_current_position number := 1;
    v_final_position   number := p_nums.count;
    v_nums             t_nums := p_nums;
  begin
    loop
      exit when v_current_position > v_final_position;
    
      if (v_nums(v_current_position) = 0) then
        move_element_to_end(v_nums, v_current_position, v_final_position);
        v_final_position := v_final_position - 1;
      else
        v_current_position := v_current_position + 1;
      end if;
    
    end loop;
  
    return v_nums;
  end;

  procedure test(p_expected_nums t_nums
                ,p_actual_nums   t_nums) is
  begin
    if (p_expected_nums is null or p_actual_nums is null or p_expected_nums.count != p_actual_nums.count) then
      raise_application_error(-20100, 'Arrays are not equals');
    end if;
    for i in p_expected_nums.first .. p_expected_nums.last loop
      if (p_expected_nums(i) != p_actual_nums(i)) then
        raise_application_error(-20100, 'Arrays are not equals');
      end if;
    end loop;
  end;

begin
  v_actual_nums := move_zeroes(v_actual_nums);
  test(v_expected_nums, v_actual_nums);
end;
/"
gG6XhMxV,Untitled,igorwwylson,C++,Thursday 29th of June 2023 09:39:38 AM CDT,"#include <iostream>
#include <fstream>
#include <vector>
using namespace std;

// –∫–æ–¥–∏—Ä—É–µ–º —Ñ–∞–π–ª
void code(string read_file_name, string write_file_name)
{
    ifstream in(read_file_name, std::ios_base::binary); 
    ofstream out(write_file_name, std::ios_base::binary);
    string symbols; // –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Å–∏–º–≤–æ–ª–æ–≤ < 128
    int cnt_equals = 0; // –¥–ª–∏–Ω–∞ —Å—É—Ñ—Ñ–∏–∫—Å–∞ –æ–¥–∏–Ω–∞–∫–æ–≤—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤

    while (!in.eof())
    {
        char s = in.get(); // —Å–∏–º–≤–æ–ª –∏–∑ –±—É—Ñ–µ—Ä–∞
        if (in.eof())
            break;

        symbols.push_back(s);

        if (symbols.size() != 1)
            cnt_equals += symbols[symbols.size() - 1] == symbols[symbols.size() - 2]; // –µ—Å–ª–∏ —Å–∏–º–≤–æ–ª —Ä–∞–≤–µ–Ω –ø–æ—Å–ª–µ–¥–Ω–µ–º—É, —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º –¥–ª–∏–Ω—É —Å—É—Ñ—Ñ–∏–∫—Å–∞
        else
            cnt_equals = 1; // –∏–Ω–∞—á–µ 1

        if (symbols.size() == 128)
        {
            out << (char)(-(char)(symbols.size())) << symbols;  // –≤—ã–≤–æ–¥–∏–º —Å—Ç—Ä–æ–∫—É –¥–ª–∏–Ω—ã 128 –∏ —Å—É—Ñ—Ñ–∏–∫—Å
            symbols.clear();
            cnt_equals = 0;
        }
        else if (cnt_equals > 2)
        {
            char repeated_symbol = symbols.back(); // —Å–∏–º–≤–æ–ª, –ø–æ–≤—Ç–æ—Ä—è–µ–º—ã–π cnt_equals —Ä–∞–∑ –∏–∑ —Å—É—Ñ—Ñ–∏–∫—Å–∞ —Å—Ç—Ä–æ–∫–∏
            for (int j = 0; j < cnt_equals; ++j)
                symbols.pop_back();
            
            if (!symbols.empty())
                out << (char)(-static_cast<char>(symbols.size())) << symbols; // –µ—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞ –Ω–µ –ø—É—Å—Ç–∞, –≤—ã–≤–æ–¥–∏–º –≤—Å–µ —á—Ç–æ –æ—Å—Ç–∞–ª–æ—Å—å –∫–∞–∫ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –±–µ–∑ –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏–π
            
            out << (char)cnt_equals << repeated_symbol; // –≤—ã–≤–æ–¥–∏–º –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∏–∑ –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏–π

            cnt_equals = 0; // —Ç–µ–ø–µ—Ä—å –¥–ª–∏–Ω–∞ —Å—É—Ñ—Ñ–∏–∫—Å–∞ —Ä–∞–≤–Ω–∞ 0, —Ç–∞–∫ –∫–∞–∫ —Å–∏–º–≤–æ–ª–æ–≤ 0
            symbols.clear();
        }
    }

    if (symbols != """")
        out << (char)(-(char)symbols.size()) << symbols;

    in.close();
    out.close();
}

// –¥–µ–∫–æ–¥–∏—Ä—É–µ–º —Ñ–∞–π–ª
void decode(string read_file_name, string write_file_name)
{
    ifstream in(read_file_name, std::ios_base::binary);
    ofstream out(write_file_name, std::ios_base::binary);
    
    while (!in.eof())
    {
        char number_of_symbols = in.get(); // –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–∏–º–≤–æ–ª–æ–≤
        
        if (in.eof())
            break;

        if (number_of_symbols < 0)
        {
            for (int i = 0; i < -number_of_symbols; ++i)
                out << static_cast<char>(in.get()); // –≤—ã–≤–æ–¥–∏–º –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Å–∏–º–≤–æ–ª–æ–º –∏–∑ –±—É—Ñ–µ—Ä–∞
        }
        else
        {
            char symbol = in.get(); // —Å–∏–º–≤–æ–ª –∏–∑ –±—É—Ñ–µ—Ä–∞, –ø–æ–≤—Ç–æ—Ä—è–µ–º—ã–π number_of_symbols —Ä–∞–∑
            for (int i = 0; i < number_of_symbols; ++i)
                out << symbol; // –≤—ã–≤–æ–¥–∏–º —Å–∏–º–≤–æ–ª, –ø–æ–≤—Ç–æ—Ä—è–µ–º—ã–π number_of_symbols —Ä–∞–∑ 
        }
    }

    in.close();
    out.close();
}

int main(){
    
}
"
9zFvFVH8,Adadsld;kfj;lsadkf,igorwwylson,C++,Thursday 29th of June 2023 09:25:36 AM CDT,"#include <iostream>
#include <fstream>
#include <vector>
using namespace std;

void code(string read_file_name, string write_file_name)
{
    ifstream in(read_file_name, std::ios_base::binary);
    ofstream out(write_file_name, std::ios_base::binary);
    string symbols;
    int cnt_equals = 0;

    while (!in.eof())
    {
        char s = in.get();
        if (in.eof())
            break;

        symbols.push_back(s);

        if (symbols.size() != 1)
            cnt_equals += symbols[symbols.size() - 1] == symbols[symbols.size() - 2];
        else
            cnt_equals = 1;

        if (symbols.size() == 128)
        {
            out << (char)(-(char)(symbols.size())) << symbols;
            symbols.clear();
            cnt_equals = 0;
        }
        else if (cnt_equals > 2)
        {
            char repeated_symbol = symbols.back();
            for (int j = 0; j < cnt_equals; ++j)
                symbols.pop_back();
            
            if (symbols.size() != 0)
                out << (char)(-(char)(symbols.size())) << symbols;
            
            out << (char)cnt_equals << repeated_symbol;

            cnt_equals = 0;
            symbols.clear();
        }
    }

    if (symbols != """")
        out << (char)(-(char)symbols.size()) << symbols;

    in.close();
    out.close();
}

void decode(string read_file_name, string write_file_name)
{
    ifstream in(read_file_name, std::ios_base::binary);
    ofstream out(write_file_name, std::ios_base::binary);
    
    while (!in.eof())
    {
        char number_of_symbols = in.get();
        
        if (in.eof())
            break;

        if (number_of_symbols < 0)
        {
            for (int i = 0; i < -number_of_symbols; ++i)
                out << static_cast<char>(in.get());   
        }
        else
        {
            char symbol = in.get();
            for (int i = 0; i < number_of_symbols; ++i)
                out << symbol;
        }
    }

    in.close();
    out.close();
}

int main(){
    
}
"
Lbfh3uFM,CC Tower,CyberiX,Lua,Thursday 29th of June 2023 08:56:54 AM CDT,"local core = require(""core"")

local tArgs = {...} -- radius, levels
local coordinates = {0, 0, 0} -- X, Y, Z
local radius = tArgs[1]
local levels = tArgs[2]

function initialization(args)
  checkInitialization()
end

function checkInitialization()
  print(""Check initialization..."")

  if radius == nil then
    radius = tonumber(core.readParameter(""radius""))
  end

  if levels == nil then
    levels = tonumber(core.readParameter(""levels""))
  end
end

initialization(tArgs)

print(""radius: "" .. radius)
print(""levels: "" .. levels)

for key, value in pairs(coordinates) do
  print(""key: "" .. key .. "", value: "" .. value)
end
"
DbjTuvdw,Untitled,gigler,C++,Thursday 29th of June 2023 08:43:04 AM CDT,"// C++ program to find largest subarray with equal number of
// 0's and 1's.

#include <bits/stdc++.h>
using namespace std;

// Returns largest subarray with equal number of 0s and 1s

int maxLen(int arr[], int n)
{
	// Creates an empty hashMap hM

	unordered_map<int, int> hM;

	int sum = 0; // Initialize sum of elements
	int max_len = 0; // Initialize result
	int ending_index = -1;

	for (int i = 0; i < n; i++)
		arr[i] = (arr[i] == 0) ? -1 : 1;

	// Traverse through the given array

	for (int i = 0; i < n; i++) {
		// Add current element to sum

		sum += arr[i];

		// To handle sum=0 at last index

		if (sum == 0) {
			max_len = i + 1;
			ending_index = i;
		}

		// If this sum is seen before, then update max_len
		// if required

		if (hM.find(sum) != hM.end()) {
			if (max_len < i - hM[sum]) {
				max_len = i - hM[sum];
				ending_index = i;
			}
		}
		else // Else put this sum in hash table
			hM[sum] = i;
	}

	for (int i = 0; i < n; i++)
		arr[i] = (arr[i] == -1) ? 0 : 1;

	printf(""%d to %d\n"",
		ending_index - max_len + 1, ending_index);

	return max_len;
}

// Driver method

int main()
{
	int arr[] = { 1, 0, 0, 1, 0, 1, 1 };
	int n = sizeof(arr) / sizeof(arr[0]);

	maxLen(arr, n);
	return 0;
}

// This code is contributed by Aditya Goel
"
BFpji2Uc,Hashed Email - Full,wheresTheAnyKey,C,Thursday 29th of June 2023 08:39:13 AM CDT,"Pasted at: 29/06/2023 14:39
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

wojciech@sktestcomcast.net
joglo@sktestmac.com
larry@sktesthotmail.com
aardo@sktestverizon.net
debest@sktestlive.com
carroll@sktestaol.com
arathi@sktestyahoo.ca
sthomas@sktestcomcast.net
leocharre@sktestyahoo.ca
pedwards@sktestyahoo.com

skinclude"
mcW7dJNs,Untitled,phpface,PHP,Thursday 29th of June 2023 08:37:00 AM CDT,"add_filter( 'comment_form_defaults', function( $args ){

	$title_reply = esc_html__( 'Write your comment', 'streamtube-child' );

	return array_merge( $args, compact( 'title_reply' ) );

}, 10, 1 );"
1bNfZmKk,ÈÇÄÊÇ®‰∏ÄËµ∑ÁúãÔºöÈïøÈ£éÊ∏°,xiaomianao666,JavaScript,Thursday 29th of June 2023 08:22:55 AM CDT,Êµ∑ÈòîËßÜÁïåËßÑÂàôÂàÜ‰∫´ÔºåÂΩìÂâçÂàÜ‰∫´ÁöÑÊòØÔºö‰∫åÁ∫ßÈ°µÈù¢ËØ¶ÊÉÖÔø•page_detailÔø•ÈïøÈ£éÊ∏° @@eyJkYXRhIjoie1wiYXNzb2NpYXRlZE1vZGVsc01hcEZvckpvaW5UYWJsZVwiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhGS1wiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhvdXRGS1wiOnt9LFwiZmllbGRzVG9TZXRUb0RlZmF1bHRcIjpbXSxcImdtdE1vZGlmaWVkXCI6MCxcImlkXCI6MCxcImxhc3RfY2hhcHRlcl9ydWxlXCI6XCJcIixcImxpc3RUb0NsZWFyQXNzb2NpYXRlZEZLXCI6W10sXCJsaXN0VG9DbGVhclNlbGZGS1wiOltdLFwicGFnZUxpc3RcIjpbe1wiY29sX3R5cGVcIjpcInRleHRfMVwiLFwibmFtZVwiOlwi5Li76aG1XCIsXCJwYXRoXCI6XCJob21lXCIsXCJydWxlXCI6XCJqczpcXG52YXIgZCA9IFtdO1xcbmlmICghZmlsZUV4aXN0KFxcXCJoaWtlcjovL2ZpbGVzL3J1bGVzL0pvZS9hbGkuanNvblxcXCIpKSB7XFxuICAgIGQucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIueZu+mZhuS7peW8gOWQr1xcXCIsXFxuICAgICAgICB1cmw6IFxcXCJoaWtlcjovL3BhZ2UvbG9naW5cXFwiLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0X2NlbnRlcl8xXFxcIlxcbiAgICB9KVxcbn0gZWxzZSB7XFxuICAgIGZ1bmN0aW9uIGZvcm1hdERhdGUodGltZSkge1xcbiAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh0aW1lKTtcXG4gICAgICAgIHZhciBZWSA9IGRhdGUuZ2V0RnVsbFllYXIoKSArICctJztcXG4gICAgICAgIHZhciBNTSA9IChkYXRlLmdldE1vbnRoKCkgKyAxIDwgMTAgPyAnMCcgKyAoZGF0ZS5nZXRNb250aCgpICsgMSkgOiBkYXRlLmdldE1vbnRoKCkgKyAxKSArICctJztcXG4gICAgICAgIHZhciBERCA9IChkYXRlLmdldERhdGUoKSA8IDEwID8gJzAnICsgKGRhdGUuZ2V0RGF0ZSgpKSA6IGRhdGUuZ2V0RGF0ZSgpKTtcXG4gICAgICAgIHZhciBoaCA9IChkYXRlLmdldEhvdXJzKCkgPCAxMCA/ICcwJyArIGRhdGUuZ2V0SG91cnMoKSA6IGRhdGUuZ2V0SG91cnMoKSkgKyAnOic7XFxuICAgICAgICB2YXIgbW0gPSAoZGF0ZS5nZXRNaW51dGVzKCkgPCAxMCA/ICcwJyArIGRhdGUuZ2V0TWludXRlcygpIDogZGF0ZS5nZXRNaW51dGVzKCkpICsgJzonO1xcbiAgICAgICAgdmFyIHNzID0gKGRhdGUuZ2V0U2Vjb25kcygpIDwgMTAgPyAnMCcgKyBkYXRlLmdldFNlY29uZHMoKSA6IGRhdGUuZ2V0U2Vjb25kcygpKTtcXG4gICAgICAgIHJldHVybiBZWSArIE1NICsgREQgKyBcXFwiIFxcXCIgKyBoaCArIG1tICsgc3M7XFxuICAgIH1cXG5cXG4gICAgaWYgKE1ZX1BBR0UgPT0gMSkge1xcbiAgICAgICAgbGV0IGNvbmZpZyA9IEpTT04ucGFyc2UoZmV0Y2goXFxcImhpa2VyOi8vZmlsZXMvcnVsZXMvSm9lL2FsaS5qc29uXFxcIikpXFxuICAgICAgICBpZihuZXcgRGF0ZSgpLmdldFRpbWUoKT49Y29uZmlnLnRpbWVfZXhwaXJlKXtcXG4gICAgICAgICAgICAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9hcGlcXFwiKS5yZWZyZXNoVG9rZW4oKTtcXG4gICAgICAgICAgICBsb2coJ+WIt+aWsHRva2VuJyk7XFxuICAgICAgICAgICAgY29uZmlnID0gSlNPTi5wYXJzZShmZXRjaChcXFwiaGlrZXI6Ly9maWxlcy9ydWxlcy9Kb2UvYWxpLmpzb25cXFwiKSlcXG4gICAgICAgIH1cXG4gICAgICAgIGQudW5zaGlmdCh7XFxuICAgICAgICAgICAgdGl0bGU6IGNvbmZpZy5uaWNrX25hbWUsXFxuICAgICAgICAgICAgaW1nOiBjb25maWcuYXZhdGFyLFxcbiAgICAgICAgICAgIHVybDogJChcXFwi56Gu6K6k6YCA5Ye655m76ZmG77yfXFxcIikuY29uZmlybSgoKSA9PiB7XFxuICAgICAgICAgICAgICAgIGRlbGV0ZUZpbGUoXFxcImhpa2VyOi8vZmlsZXMvcnVsZXMvSm9lL2FsaS5qc29uXFxcIilcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKVxcbiAgICAgICAgICAgIH0pLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwiYXZhdGFyXFxcIlxcbiAgICAgICAgfSwge1xcbiAgICAgICAgICAgIGRlc2M6IFxcXCLmkJzntKLmiJHnmoTmlofku7bmiJbovpPlhaXliIbkuqvpk77mjqVcXFwiLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwiaW5wdXRcXFwiLFxcbiAgICAgICAgICAgIHVybDogXFxcIidoaWtlcjovL3BhZ2Uvc2VhcmNoP2t3PScraW5wdXQrJyZwPWZ5cGFnZSNub1JlZnJlc2gjJ1xcXCIsXFxuICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgdGl0bGVWaXNpYmxlOiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6IFxcXCJwdXRNeVZhcigna3cnLGlucHV0KVxcXCJcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KVxcbiAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogXFxcIuWIh+aNouagt+W8j1xcXCIsXFxuICAgICAgICAgICAgdXJsOiAkKFtcXFwibW92aWVfMV9sZWZ0X3BpY1xcXCIsIFxcXCJjYXJkX3BpY18zXFxcIiwgXFxcImF2YXRhclxcXCJdKS5zZWxlY3QoKCkgPT4ge1xcbiAgICAgICAgICAgICAgICBzZXRJdGVtKFxcXCJzdHlsZVxcXCIsIGlucHV0KVxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/lt7LliIfmjaJcXFwiXFxuICAgICAgICAgICAgfSksXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzJcXFwiXFxuICAgICAgICB9LCB7XFxuICAgICAgICAgICAgdGl0bGU6IFxcXCLmjpLluo86XFxcIiArIChnZXRNeVZhcihcXFwib3JkZXJcXFwiLCBcXFwibmFtZVxcXCIpID09IFxcXCJuYW1lXFxcIiA/IFxcXCLlkI3np7BcXFwiIDogXFxcIuaXtumXtFxcXCIpLFxcbiAgICAgICAgICAgIHVybDogJChcXFwiI25vUmVjb3JkSGlzdG9yeSMjbm9Mb2FkaW5nI1xcXCIpLmxhenlSdWxlKCgpID0+IHtcXG4gICAgICAgICAgICAgICAgdmFyIG8gPSBnZXRNeVZhcihcXFwib3JkZXJcXFwiLCBcXFwibmFtZVxcXCIpXFxuICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXCJvcmRlclxcXCIsIChvID09IFxcXCJuYW1lXFxcIiA/IFxcXCJ1cGRhdGVkX2F0XFxcIiA6IFxcXCJuYW1lXFxcIikpXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKClcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+WIh+aNouaIkOWKn1xcXCJcXG4gICAgICAgICAgICB9KSxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfMlxcXCJcXG4gICAgICAgIH0sIHtcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcImJsYW5rX2Jsb2NrXFxcIlxcbiAgICAgICAgfSlcXG4gICAgfVxcblxcbiAgICB2YXIgcGF0aCA9IE1ZX1BBUkFNUy5wYXRoIHx8IFxcXCJyb290XFxcIlxcbiAgICBcXG4gICAgXFxuICAgIHZhciBmaWxlcz0kLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9hcGlcXFwiKS5nZXRGaWxlcyhwYXRoKVxcbiAgICBcXG4gICAgaWYgKGZpbGVzLml0ZW1zIT11bmRlZmluZWQpIHtcXG4gICAgICAgIHB1dE15VmFyKHBhdGggKyBcXFwibWFya2VyXFxcIiwgZmlsZXMubmV4dF9tYXJrZXIpXFxuICAgICAgICB2YXIgbGlzdCA9IGZpbGVzLml0ZW1zXFxuICAgICAgICBsaXN0LmZvckVhY2goKGl0ZW0sIGkpID0+IHtcXG4gICAgICAgICAgICBsZXQgZmlsZU5hbWUgPSBpdGVtLm5hbWVcXG4gICAgICAgICAgICBsZXQgbGVuID0gNDA7XFxuICAgICAgICAgICAgbGV0IGxlbjIgPSBsZW4gLyAyO1xcbiAgICAgICAgICAgIGlmIChmaWxlTmFtZS5sZW5ndGggPj0gbGVuKSB7XFxuICAgICAgICAgICAgICAgIGZpbGVOYW1lID0gZmlsZU5hbWUuc3Vic3RyKDAsIGxlbjIpICsgJy4uLicgKyBmaWxlTmFtZS5zdWJzdHIoZmlsZU5hbWUubGVuZ3RoIC0gbGVuMik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiBmaWxlTmFtZSxcXG4gICAgICAgICAgICAgICAgaW1nOiAoaXRlbS50aHVtYm5haWwgPyBpdGVtLnRodW1ibmFpbCA6IChpdGVtLnR5cGUgPT0gXFxcImZvbGRlclxcXCIgPyBcXFwiaHR0cHM6Ly9naXRjb2RlLm5ldC9xcV8zMjM5NDM1MS9kci8tL3Jhdy9tYXN0ZXIvaW1nL+aWh+S7tuexu+WeizIv5paH5Lu25aS5LnN2Z1xcXCIgOiAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9hcGlcXFwiKS5nZXRJY29uKGl0ZW0ubmFtZSkpKSxcXG4gICAgICAgICAgICAgICAgdXJsOiAoaXRlbS50eXBlID09IFxcXCJmb2xkZXJcXFwiID8gXFxcImhpa2VyOi8vcGFnZS9ob21lP3BhZ2U9ZnlwYWdlXFxcIiA6ICQoKS5sYXp5UnVsZSgoaWQsIG5hbWUsIHVybCkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL2FwaVxcXCIpLmNodWxpKGlkLCBuYW1lLCB1cmwpXFxuICAgICAgICAgICAgICAgIH0sIGl0ZW0uZmlsZV9pZCwgaXRlbS5uYW1lLCBpdGVtLnVybCkpLFxcbiAgICAgICAgICAgICAgICBkZXNjOiBmb3JtYXREYXRlKERhdGUucGFyc2UoaXRlbS51cGRhdGVkX2F0KSksXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBnZXRJdGVtKFxcXCJzdHlsZVxcXCIsIFxcXCJtb3ZpZV8zXFxcIiksXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBpdGVtLmZpbGVfaWRcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pXFxuICAgICAgICB9KVxcbiAgICB9ZWxzZXtcXG4gICAgICAgIGlmKGZpbGVzPT1mYWxzZSl7XFxuICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOifigJzigJzigJ3igJ08c21hbGw+PGZvbnQgY29sb3I9XFxcImdyZXlcXFwiPuWIq+WIkuS6huWIsOW6leS6hjwvZm9udD48L3NtYWxsPicsXFxuICAgICAgICAgICAgY29sX3R5cGU6J3RleHRfY2VudGVyXzEnLFxcbiAgICAgICAgICAgIHVybDonaGlrZXI6Ly9lbXB0eScsICAgICAgICAgICAgXFxuICAgICAgICAgIH0pXFxuICAgICAgICB9ZWxzZXtcXG4gICAgICAgICAgICAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9hcGlcXFwiKS5yZWZyZXNoVG9rZW4oKTtcXG4gICAgICAgICAgICBsb2coJ+WIt+aWsHRva2VuJyk7XFxuICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOifigJzigJzigJ3igJ08c21hbGw+PGZvbnQgY29sb3I9XFxcImdyZXlcXFwiPuiOt+WPluWksei0peivt+mHjeivlTwvZm9udD48L3NtYWxsPicsXFxuICAgICAgICAgICAgY29sX3R5cGU6J3RleHRfY2VudGVyXzEnLFxcbiAgICAgICAgICAgIHVybDonaGlrZXI6Ly9lbXB0eScsICAgICAgICAgICAgXFxuICAgICAgICAgIH0pXFxuICAgICAgICB9XFxuICAgIH1cXG59XFxuc2V0UmVzdWx0KGQpO1xcblwifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwi55m76ZmGXCIsXCJwYXRoXCI6XCJsb2dpblwiLFwicnVsZVwiOlwianM6XFxudmFyIGQgPSBbXTtcXG5sZXQgdXJsID0gJ2h0dHBzOi8vYXV0aC5hbGl5dW5kcml2ZS5jb20vdjIvb2F1dGgvYXV0aG9yaXplP2xvZ2luX3R5cGU9Y3VzdG9tJnJlc3BvbnNlX3R5cGU9Y29kZSZyZWRpcmVjdF91cmk9aHR0cHMlM0ElMkYlMkZ3d3cuYWxpeXVuZHJpdmUuY29tJTJGc2lnbiUyRmNhbGxiYWNrJmNsaWVudF9pZD0yNWR6WDN2Yllxa3RWeHlYJnN0YXRlPSU3QiUyMm9yaWdpbiUyMiUzQSUyMiolMjIlN0QjL2xvZ2luJ1xcbnZhciBqcyA9ICQudG9TdHJpbmcoKCkgPT4ge1xcbiAgICBjb25zdCB0b2tlbkZ1bmN0aW9uID0gZnVuY3Rpb24oKSB7XFxuICAgICAgICB2YXIgdG9rZW4gPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd0b2tlbicpKVxcbiAgICAgICAgaWYgKHRva2VuICYmIHRva2VuLnVzZXJfaWQpIHtcXG4gICAgICAgICAgICBsZXQgdG9rZW5fdXJsID0gJ2hpa2VyOi8vZmlsZXMvcnVsZXMvSm9lL2FsaS5qc29uJztcXG4gICAgICAgICAgICBmeV9icmlkZ2VfYXBwLndyaXRlRmlsZSh0b2tlbl91cmwsIEpTT04uc3RyaW5naWZ5KHRva2VuKSlcXG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2UuY2xlYXIoKTtcXG4gICAgICAgICAgICBhbGVydCgnVE9LRU7ojrflj5bmiJDlip/vvIzor7fli7/ms4TmvI/kuKrkurrpmpDnp4Eh6YCA5Ye66K+l6aG16Z2i5ZCO5Yi35paw6YeN6K+V77yBJyk7XFxuICAgICAgICAgICAgZnlfYnJpZGdlX2FwcC5iYWNrKCk7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB0b2tlbl90aW1lcigpO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIHZhciB0b2tlbl90aW1lciA9IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgc2V0VGltZW91dCh0b2tlbkZ1bmN0aW9uLCAzMDApXFxuICAgIH07XFxuICAgIHRva2VuX3RpbWVyKCk7XFxuICAgIHRva2VuRnVuY3Rpb24oKTtcXG59KVxcbmQucHVzaCh7XFxuICAgIHVybDogdXJsLFxcbiAgICBjb2xfdHlwZTogJ3g1X3dlYnZpZXdfc2luZ2xlJyxcXG4gICAgZGVzYzogJzEwMCUmJmZsb2F0JyxcXG4gICAgZXh0cmE6IHtcXG4gICAgICAgIGNhbkJhY2s6IHRydWUsXFxuICAgICAgICBqczoganNcXG4gICAgfVxcbn0pXFxuc2V0UmVzdWx0KGQpO1wifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwiYXBpXCIsXCJwYXRoXCI6XCJhcGlcIixcInJ1bGVcIjpcInZhciByZWZyZXNoVG9rZW4gPSBmdW5jdGlvbigpIHtcXG4gICAgdmFyIHVybCA9IFxcXCJodHRwczovL2F1dGguYWxpeXVuZHJpdmUuY29tL3YyL2FjY291bnQvdG9rZW5cXFwiXFxuICAgIHZhciBjb25maWcgPSBKU09OLnBhcnNlKGZldGNoKFxcXCJoaWtlcjovL2ZpbGVzL3J1bGVzL0pvZS9hbGkuanNvblxcXCIpKVxcbiAgICB2YXIgcmVzID0gSlNPTi5wYXJzZShwb3N0KHVybCwge1xcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xcbiAgICAgICAgICAgIFxcXCJyZWZyZXNoX3Rva2VuXFxcIjogY29uZmlnLnJlZnJlc2hfdG9rZW4sXFxuICAgICAgICAgICAgXFxcImdyYW50X3R5cGVcXFwiOiBcXFwicmVmcmVzaF90b2tlblxcXCJcXG4gICAgICAgIH0pXFxuICAgIH0pKVxcbiAgICBjb25maWdbXFxcInJlZnJlc2hfdG9rZW5cXFwiXSA9IHJlcy5yZWZyZXNoX3Rva2VuXFxuICAgIGNvbmZpZ1tcXFwiYWNjZXNzX3Rva2VuXFxcIl0gPSByZXMuYWNjZXNzX3Rva2VuXFxuICAgIGNvbmZpZ1tcXFwiZXhwaXJlX3RpbWVcXFwiXSA9IHJlcy5leHBpcmVfdGltZVxcbiAgICBjb25maWdbXFxcInRpbWVfZXhwaXJlXFxcIl0gPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIDcyMDAgKiAxMDAwXFxuICAgIHdyaXRlRmlsZShcXFwiaGlrZXI6Ly9maWxlcy9ydWxlcy9Kb2UvYWxpLmpzb25cXFwiLCBKU09OLnN0cmluZ2lmeShjb25maWcpKVxcbn1cXG52YXIgZ2V0RmlsZXMgPSBmdW5jdGlvbihpZCwgZGlkKSB7XFxuICAgIHZhciB1cmwgPSBcXFwiaHR0cHM6Ly9hcGkuYWxpeXVuZHJpdmUuY29tL2Fkcml2ZS92My9maWxlL2xpc3RcXFwiXFxuICAgIHZhciBjb25maWcgPSBKU09OLnBhcnNlKGZldGNoKFxcXCJoaWtlcjovL2ZpbGVzL3J1bGVzL0pvZS9hbGkuanNvblxcXCIpKVxcbiAgICB2YXIgZGVmID0gZGlkID8gZGlkIDogY29uZmlnLmRlZmF1bHRfZHJpdmVfaWRcXG4gICAgLy9sb2coaWQpXFxuICAgIHZhciBkYXRhID0ge1xcbiAgICAgICAgXFxcImRyaXZlX2lkXFxcIjogZGVmLFxcbiAgICAgICAgXFxcInBhcmVudF9maWxlX2lkXFxcIjogaWQsXFxuICAgICAgICBcXFwidG9rZW5fdHlwZVxcXCI6ICdCZWFyZXInLFxcbiAgICAgICAgXFxcImxpbWl0XFxcIjogMTAwLFxcbiAgICAgICAgXFxcImFsbFxcXCI6IHRydWUsXFxuICAgICAgICBcXFwidXJsX2V4cGlyZV9zZWNcXFwiOiAxNjAwLFxcbiAgICAgICAgXFxcImltYWdlX3RodW1ibmFpbF9wcm9jZXNzXFxcIjogXFxcImltYWdlL3Jlc2l6ZSx3XzQwMC9mb3JtYXQsanBlZ1xcXCIsXFxuICAgICAgICBcXFwiaW1hZ2VfdXJsX3Byb2Nlc3NcXFwiOiBcXFwiaW1hZ2UvcmVzaXplLHdfMTkyMC9mb3JtYXQsanBlZ1xcXCIsXFxuICAgICAgICBcXFwidmlkZW9fdGh1bWJuYWlsX3Byb2Nlc3NcXFwiOiBcXFwidmlkZW8vc25hcHNob3QsdF8xMDAwLGZfanBnLGFyX2F1dG8sd18zMDBcXFwiLFxcbiAgICAgICAgXFxcImZpZWxkc1xcXCI6IFxcXCIqXFxcIixcXG4gICAgICAgIFxcXCJvcmRlcl9ieVxcXCI6IGdldE15VmFyKFxcXCJvcmRlclxcXCIsIFxcXCJuYW1lXFxcIiksXFxuICAgICAgICBcXFwib3JkZXJfZGlyZWN0aW9uXFxcIjogXFxcIkFTQ1xcXCJcXG4gICAgfVxcbiAgICAvL2xvZyhnZXRNeVZhcihpZCArIFxcXCJtYXJrZXJcXFwiKSlcXG4gICAgaWYgKE1ZX1BBR0UgIT0gMSAmJiBnZXRNeVZhcihpZCArIFxcXCJtYXJrZXJcXFwiLCBcXFwiXFxcIikgPT0gXFxcIlxcXCIpIHtcXG5cXG4gICAgICAgIHJldHVybiBmYWxzZVxcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgZGF0YS5tYXJrZXIgPSBnZXRNeVZhcihpZCArIFxcXCJtYXJrZXJcXFwiKSAhPSAndW5kZWZpbmVkJyA/IGdldE15VmFyKGlkICsgXFxcIm1hcmtlclxcXCIpIDogJydcXG4gICAgICAgIGNsZWFyTXlWYXIoaWQgKyBcXFwibWFya2VyXFxcIilcXG4gICAgICAgIGxldCByZXMgPSBwb3N0KHVybCwge1xcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAgICAgXFxcImF1dGhvcml6YXRpb25cXFwiOiBjb25maWcuYWNjZXNzX3Rva2VuXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSlcXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHJlcylcXG4gICAgfVxcbn1cXG52YXIgY2h1bGkgPSBmdW5jdGlvbihpZCwgbmFtZSwgdXJsLCBkaWQpIHtcXG4gICAgdmFyIGNvbmZpZyA9IEpTT04ucGFyc2UoZmV0Y2goXFxcImhpa2VyOi8vZmlsZXMvcnVsZXMvSm9lL2FsaS5qc29uXFxcIikpXFxuICAgIHZhciBkaWQgPSBkaWQgPyBkaWQgOiBjb25maWcuZGVmYXVsdF9kcml2ZV9pZFxcbiAgICBsZXQge1xcbiAgICAgICAgZ2V0SHptLFxcbiAgICAgICAgcHVzaFxcbiAgICB9ID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvYXBpXFxcIilcXG4gICAgdmFyIEh6bSA9IGdldEh6bShuYW1lKVxcbiAgICBpZiAoJC5tb3ZpZS5pbmNsdWRlcyhIem0pKSB7XFxuICAgICAgICBsZXQgcHVybCA9IFxcXCJodHRwczovL2FwaS5hbGl5dW5kcml2ZS5jb20vYWRyaXZlL3YyL2ZpbGUvZ2V0X3ZpZGVvX3ByZXZpZXdfcGxheV9pbmZvXFxcIlxcbiAgICAgICAgdmFyIHVybHMgPSBbXVxcbiAgICAgICAgdmFyIG5hbWVzID0gW1xcXCLljp/nlLtcXFwiXVxcbiAgICAgICAgdXJscy5wdXNoKHVybCArIFxcXCIjaXNWaWRlbz10cnVlI1xcXCIpXFxuICAgICAgICBsZXQgcHUgPSBwb3N0KHB1cmwsIHtcXG4gICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgIFxcXCJhdXRob3JpemF0aW9uXFxcIjogY29uZmlnLmFjY2Vzc190b2tlblxcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xcbiAgICAgICAgICAgICAgICBcXFwiZHJpdmVfaWRcXFwiOiBkaWQsXFxuICAgICAgICAgICAgICAgIFxcXCJjYXRlZ29yeVxcXCI6IFxcXCJsaXZlX3RyYW5zY29kaW5nXFxcIixcXG4gICAgICAgICAgICAgICAgXFxcImZpbGVfaWRcXFwiOiBpZCxcXG4gICAgICAgICAgICAgICAgXFxcInRlbXBsYXRlX2lkXFxcIjogXFxcIlxcXCJcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgfSlcXG4gICAgICAgIGNvbnN0IHRyYW5zY29kaW5nID0ge1xcbiAgICAgICAgICAgIFVIRDogXFxcIjRLIOi2hea4hVxcXCIsXFxuICAgICAgICAgICAgUUhEOiBcXFwiMksg6LaF5riFXFxcIixcXG4gICAgICAgICAgICBGSEQ6IFxcXCIxMDgwIOWFqOmrmOa4hVxcXCIsXFxuICAgICAgICAgICAgSEQ6IFxcXCI3MjAg6auY5riFXFxcIixcXG4gICAgICAgICAgICBTRDogXFxcIjU0MCDmoIfmuIVcXFwiLFxcbiAgICAgICAgICAgIExEOiBcXFwiMzYwIOa1geeVhVxcXCJcXG4gICAgICAgIH07XFxuICAgICAgICBsZXQgYXJyMSA9IEpTT04ucGFyc2UocHUpLnZpZGVvX3ByZXZpZXdfcGxheV9pbmZvLmxpdmVfdHJhbnNjb2RpbmdfdGFza19saXN0LmZpbHRlcihpdCA9PiBpdC51cmwgIT0gXFxcIlxcXCIpO1xcbiAgICAgICAgZm9yIChsZXQgayBvZiBPYmplY3Qua2V5cyh0cmFuc2NvZGluZykpIHtcXG4gICAgICAgICAgICBmb3IgKGxldCBpdCBvZiBhcnIxKSB7XFxuICAgICAgICAgICAgICAgIGlmIChpdC50ZW1wbGF0ZV9pZCA9PSBrKSB7XFxuICAgICAgICAgICAgICAgICAgICB1cmxzLnB1c2goaXQudXJsICsgXFxcIiNpc1ZpZGVvPXRydWUjXFxcIilcXG4gICAgICAgICAgICAgICAgICAgIG5hbWVzLnB1c2godHJhbnNjb2Rpbmdba10pO1xcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xcbiAgICAgICAgICAgIHVybHM6IHVybHMsXFxuICAgICAgICAgICAgbmFtZXM6IG5hbWVzLFxcbiAgICAgICAgICAgIGhlYWRlcnM6IFt7XFxuICAgICAgICAgICAgICAgIFxcXCJSZWZlcmVyXFxcIjogXFxcImh0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS9cXFwiXFxuICAgICAgICAgICAgfV1cXG4gICAgICAgIH0pXFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBsZXQgcmVzID0gcmVxdWVzdChidWlsZFVybChcXFwiaHR0cHM6Ly9hcGkuYWxpeXVuZHJpdmUuY29tL3YyL2ZpbGUvZG93bmxvYWRcXFwiLCB7XFxuICAgICAgICAgICAgXFxcImRyaXZlX2lkXFxcIjogZGlkLFxcbiAgICAgICAgICAgIFxcXCJmaWxlX2lkXFxcIjogaWQsXFxuICAgICAgICAgICAgXFxcImltYWdlX3RodW1ibmFpbF9wcm9jZXNzXFxcIjogXFxcImltYWdlL3Jlc2l6ZSxtX2xmaXQsd18yNTYsbGltaXRfMC9mb3JtYXQsanBnfGltYWdlL2Zvcm1hdCx3ZWJwXFxcIlxcbiAgICAgICAgfSksIHtcXG4gICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgIFxcXCJhdXRob3JpemF0aW9uXFxcIjogY29uZmlnLmFjY2Vzc190b2tlblxcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgcmVkaXJlY3Q6IGZhbHNlXFxuICAgICAgICB9KVxcbiAgICAgICAgdmFyIHVybCA9IHBkZmgocmVzLCBcXFwiYSYmaHJlZlxcXCIpXFxuICAgICAgICBpZiAoJC5pbWcuaW5jbHVkZXMoSHptKSkge1xcbiAgICAgICAgICAgIHJldHVybiB1cmwgKyBcXFwiIy5qcGdcXFwiXFxuICAgICAgICB9IGVsc2UgaWYgKCQuYXVkaW8uaW5jbHVkZXMoSHptKSkge1xcbiAgICAgICAgICAgIHJldHVybiB1cmwgKyBcXFwiI2lzTXVzaWM9dHJ1ZSNcXFwiXFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHJldHVybiBcXFwiZG93bmxvYWQ6Ly9cXFwiICsgdXJsXFxuICAgICAgICB9XFxuICAgIH1cXG59XFxuJC5leHBvcnRzLnNoYXJlZ2V0ZmlsZXMgPSBmdW5jdGlvbihpZCwgcGF0aCwgcykge1xcbiAgICB2YXIgZGF0YSA9IHtcXG4gICAgICAgIFxcXCJhbGxcXFwiOiB0cnVlLFxcbiAgICAgICAgXFxcInNoYXJlX2lkXFxcIjogaWQsXFxuICAgICAgICBcXFwicGFyZW50X2ZpbGVfaWRcXFwiOiBwYXRoLFxcbiAgICAgICAgXFxcImxpbWl0XFxcIjogMjAwLFxcbiAgICAgICAgXFxcImltYWdlX3RodW1ibmFpbF9wcm9jZXNzXFxcIjogXFxcImltYWdlL3Jlc2l6ZSx3XzE2MC9mb3JtYXQsanBlZ1xcXCIsXFxuICAgICAgICBcXFwiaW1hZ2VfdXJsX3Byb2Nlc3NcXFwiOiBcXFwiaW1hZ2UvcmVzaXplLHdfMTkyMC9mb3JtYXQsanBlZ1xcXCIsXFxuICAgICAgICBcXFwidmlkZW9fdGh1bWJuYWlsX3Byb2Nlc3NcXFwiOiBcXFwidmlkZW8vc25hcHNob3QsdF8xMDAwLGZfanBnLGFyX2F1dG8sd18zMDBcXFwiLFxcbiAgICAgICAgXFxcIm9yZGVyX2J5XFxcIjogZ2V0SXRlbShcXFwib3JkZXJcXFwiLCBcXFwibmFtZVxcXCIpLFxcbiAgICAgICAgXFxcIm9yZGVyX2RpcmVjdGlvblxcXCI6IFxcXCJBU0NcXFwiXFxuICAgIH1cXG4gICAgaWYgKE1ZX1BBR0UgPT0gMSB8fCBnZXRNeVZhcihpZCArIFxcXCJtYXJrZXJcXFwiLCBcXFwiXFxcIikgIT0gXFxcIlxcXCIpIHtcXG4gICAgICAgIGRhdGEubWFya2VyID0gZ2V0TXlWYXIoaWQgKyBcXFwibWFya2VyXFxcIikgIT0gJ3VuZGVmaW5lZCcgPyBnZXRNeVZhcihpZCArIFxcXCJtYXJrZXJcXFwiKSA6ICcnXFxuICAgICAgICBjbGVhck15VmFyKGlkICsgXFxcIm1hcmtlclxcXCIpXFxuICAgICAgICB2YXIgZmlsZXMgPSBKU09OLnBhcnNlKHBvc3QoXFxcImh0dHBzOi8vYXBpLmFsaXl1bmRyaXZlLmNvbS9hZHJpdmUvdjMvZmlsZS9saXN0XFxcIiwge1xcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAgICAgXFxcIngtc2hhcmUtdG9rZW5cXFwiOiBzXFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKVxcbiAgICAgICAgfSkpXFxuICAgICAgICByZXR1cm4gZmlsZXNcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiBmYWxzZVxcbiAgICB9XFxufVxcbiQuZXhwb3J0cy5zaGFyZWNodWxpID0gZnVuY3Rpb24oc2hhcmVfaWQsIGlkLCBuYW1lLCBzKSB7XFxuICAgIHZhciBjb25maWcgPSBKU09OLnBhcnNlKGZldGNoKFxcXCJoaWtlcjovL2ZpbGVzL3J1bGVzL0pvZS9hbGkuanNvblxcXCIpKVxcbiAgICBsZXQge1xcbiAgICAgICAgZ2V0SHptLFxcbiAgICAgICAgcHVzaFxcbiAgICB9ID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvYXBpXFxcIilcXG4gICAgdmFyIEh6bSA9IGdldEh6bShuYW1lKVxcbiAgICBpZiAoJC5tb3ZpZS5pbmNsdWRlcyhIem0pKSB7XFxuICAgICAgICBsZXQgdXJsID0gSlNPTi5wYXJzZShwb3N0KFxcXCJodHRwczovL2FwaS5hbGl5dW5kcml2ZS5jb20vdjIvZmlsZS9nZXRfc2hhcmVfbGlua19kb3dubG9hZF91cmxcXFwiLCB7XFxuICAgICAgICAgICAgaGVhZGVyczoge1xcbiAgICAgICAgICAgICAgICBcXFwieC1zaGFyZS10b2tlblxcXCI6IHMsXFxuICAgICAgICAgICAgICAgIFxcXCJhdXRob3JpemF0aW9uXFxcIjogY29uZmlnLmFjY2Vzc190b2tlblxcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xcbiAgICAgICAgICAgICAgICBcXFwiZXhwaXJlX3NlY1xcXCI6IDYwMCxcXG4gICAgICAgICAgICAgICAgXFxcImZpbGVfaWRcXFwiOiBpZCxcXG4gICAgICAgICAgICAgICAgXFxcInNoYXJlX2lkXFxcIjogc2hhcmVfaWRcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgfSkpLmRvd25sb2FkX3VybFxcbiAgICAgICAgbGV0IHB1ID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvYWxpbGF6eVxcXCIpKHNoYXJlX2lkLCBpZCwgdXJsKVxcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHB1KVxcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgbGV0IHVybCA9IEpTT04ucGFyc2UocG9zdChcXFwiaHR0cHM6Ly9hcGkuYWxpeXVuZHJpdmUuY29tL3YyL2ZpbGUvZ2V0X3NoYXJlX2xpbmtfZG93bmxvYWRfdXJsXFxcIiwge1xcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAgICAgXFxcIngtc2hhcmUtdG9rZW5cXFwiOiBzLFxcbiAgICAgICAgICAgICAgICBcXFwiYXV0aG9yaXphdGlvblxcXCI6IGNvbmZpZy5hY2Nlc3NfdG9rZW5cXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcXG4gICAgICAgICAgICAgICAgXFxcImV4cGlyZV9zZWNcXFwiOiA2MDAsXFxuICAgICAgICAgICAgICAgIFxcXCJmaWxlX2lkXFxcIjogaWQsXFxuICAgICAgICAgICAgICAgIFxcXCJzaGFyZV9pZFxcXCI6IHNoYXJlX2lkXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgIH0pKS51cmxcXG4gICAgICAgIGlmICgkLmltZy5pbmNsdWRlcyhIem0pKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHVybCArIFxcXCIjLmpwZ1xcXCJcXG4gICAgICAgIH0gZWxzZSBpZiAoJC5hdWRpby5pbmNsdWRlcyhIem0pKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHVybCArIFxcXCIjaXNNdXNpYz10cnVlI1xcXCJcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJkb3dubG9hZDovL1xcXCIgKyB1cmxcXG4gICAgICAgIH1cXG4gICAgfVxcbn1cXG4kLmV4cG9ydHMuZ2V0SWNvbiA9IGZ1bmN0aW9uKGZpbGVOYW1lKSB7XFxuICAgIGxldCB7XFxuICAgICAgICBnZXRIem1cXG4gICAgfSA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL2FwaVxcXCIpXFxuICAgIGxldCByb290ID0gXFxcImh0dHBzOi8vZ2l0Y29kZS5uZXQvcXFfMzIzOTQzNTEvZHIvLS9yYXcvbWFzdGVyL2ltZy/mlofku7bnsbvlnosyL1xcXCI7XFxuICAgIGxldCBmaWxlcyA9ICdhaXxhcGt8YXZpfGNzc3xkbWd8ZXhlfGZsdnxnaWZ8aGlrZXJ8aHRtbHxpc298anBnfGpzfGpzb258bG9nfG1vdnxtcDN8bXA0fG90ZnxwaHB8cG5nfHBwdHxwc2R8dGFibGV8dHh0fHdhdnx4bHN8emlwfGNzc3xkb2N8ZXB1YnxleGN8aHRtfHhsc3gnLnNwbGl0KCd8Jyk7XFxuICAgIGxldCBoem0gPSBnZXRIem0oZmlsZU5hbWUpXFxuICAgIGlmIChmaWxlcy5pbmNsdWRlcyhoem0pKSB7XFxuICAgICAgICBpbWcgPSByb290ICsgaHptICsgJy5zdmcnO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgaW1nID0gcm9vdCArIFxcXCLmlofku7Yuc3ZnXFxcIlxcbiAgICB9XFxuICAgIHJldHVybiBpbWdcXG59XFxuJC5leHBvcnRzLmdldEh6bSA9IGZ1bmN0aW9uKGZpbGVOYW1lKSB7XFxuICAgIHJldHVybiBmaWxlTmFtZS5zdWJzdHIoZmlsZU5hbWUubGFzdEluZGV4T2YoXFxcIi5cXFwiKSArIDEpLnRvTG93ZXJDYXNlKClcXG59XFxuJC5leHBvcnRzLnJlZnJlc2hUb2tlbiA9IHJlZnJlc2hUb2tlblxcbiQuZXhwb3J0cy5nZXRGaWxlcyA9IGdldEZpbGVzXFxuJC5leHBvcnRzLmNodWxpID0gY2h1bGlcIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuWIhuS6q1wiLFwicGF0aFwiOlwic2hhcmVcIixcInJ1bGVcIjpcImpzOlxcbnZhciBkID0gW107XFxuXFxuJC5leHRlbmQoe1xcbiAgICB0ZXh0OiBbXFxcImh0bVxcXCIsIFxcXCJodG1sXFxcIiwgXFxcInhtbFxcXCIsIFxcXCJqYXZhXFxcIiwgXFxcInByb3BlcnRpZXNcXFwiLCBcXFwic3FsXFxcIiwgXFxcImpzXFxcIiwgXFxcIm1kXFxcIiwgXFxcImpzb25cXFwiLCBcXFwiY29uZlxcXCIsIFxcXCJpbmlcXFwiLCBcXFwidnVlXFxcIiwgXFxcInBocFxcXCIsIFxcXCJweVxcXCIsIFxcXCJiYXRcXFwiLCBcXFwiZ2l0aWdub3JlXFxcIiwgXFxcInltbFxcXCIsIFxcXCJnb1xcXCIsIFxcXCJzaFxcXCIsIFxcXCJjXFxcIiwgXFxcImNwcFxcXCIsIFxcXCJoXFxcIiwgXFxcImhwcFxcXCIsIFxcXCJ0c3hcXFwiXSxcXG4gICAgYXVkaW86IFtcXFwibXAzXFxcIiwgXFxcImZsYWNcXFwiLCBcXFwib2dnXFxcIiwgXFxcIm00YVxcXCIsIFxcXCJ3YXZcXFwiLCBcXFwib3B1c1xcXCJdLFxcbiAgICBtb3ZpZTogW1xcXCJtcDRcXFwiLCBcXFwibWt2XFxcIiwgXFxcImF2aVxcXCIsIFxcXCJtb3ZcXFwiLCBcXFwicm12YlxcXCIsIFxcXCJ3ZWJtXFxcIiwgXFxcImZsdlxcXCIsIFxcXCJtNHZcXFwiLCBcXFwibTN1OFxcXCIsIFxcXCJ0c1xcXCJdLFxcbiAgICBpbWc6IFtcXFwianBnXFxcIiwgXFxcInBuZ1xcXCIsIFxcXCJqcGVnXFxcIiwgXFxcImdpZlxcXCIsIFxcXCJzdmdcXFwiLCBcXFwicmF3XFxcIl0sXFxuICAgIHN1YnRpdGxlOiBbXFxcInZ0dFxcXCIsIFxcXCJzcnRcXFwiLCBcXFwiYXNzXFxcIl1cXG59KVxcblxcbmZ1bmN0aW9uIGZvcm1hdERhdGUodGltZSkge1xcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHRpbWUpO1xcbiAgICB2YXIgWVkgPSBkYXRlLmdldEZ1bGxZZWFyKCkgKyAnLSc7XFxuICAgIHZhciBNTSA9IChkYXRlLmdldE1vbnRoKCkgKyAxIDwgMTAgPyAnMCcgKyAoZGF0ZS5nZXRNb250aCgpICsgMSkgOiBkYXRlLmdldE1vbnRoKCkgKyAxKSArICctJztcXG4gICAgdmFyIEREID0gKGRhdGUuZ2V0RGF0ZSgpIDwgMTAgPyAnMCcgKyAoZGF0ZS5nZXREYXRlKCkpIDogZGF0ZS5nZXREYXRlKCkpO1xcbiAgICB2YXIgaGggPSAoZGF0ZS5nZXRIb3VycygpIDwgMTAgPyAnMCcgKyBkYXRlLmdldEhvdXJzKCkgOiBkYXRlLmdldEhvdXJzKCkpICsgJzonO1xcbiAgICB2YXIgbW0gPSAoZGF0ZS5nZXRNaW51dGVzKCkgPCAxMCA/ICcwJyArIGRhdGUuZ2V0TWludXRlcygpIDogZGF0ZS5nZXRNaW51dGVzKCkpICsgJzonO1xcbiAgICB2YXIgc3MgPSAoZGF0ZS5nZXRTZWNvbmRzKCkgPCAxMCA/ICcwJyArIGRhdGUuZ2V0U2Vjb25kcygpIDogZGF0ZS5nZXRTZWNvbmRzKCkpO1xcbiAgICByZXR1cm4gWVkgKyBNTSArIEREICsgXFxcIiBcXFwiICsgaGggKyBtbSArIHNzO1xcbn1cXG5pZiAoZ2V0UGFyYW0oXFxcInNoYXJlX3VybFxcXCIpLnN0YXJ0c1dpdGgoXFxcImh0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS9zL1xcXCIpKSB7XFxuICAgIHZhciBzaGFyZVVybCA9IGdldFBhcmFtKFxcXCJzaGFyZV91cmxcXFwiKVxcbiAgICB2YXIgc2hhcmVfaWQgPSBzaGFyZVVybC5zcGxpdCgnY29tL3MvJylbMV0uc3BsaXQoXFxcIi9cXFwiKVswXVxcbiAgICBpZiAoZ2V0SXRlbShzaGFyZV9pZCwgXFxcIlxcXCIpICE9IFxcXCJcXFwiKSB7XFxuICAgICAgICB2YXIgcGFzc3dvcmQgPSBnZXRJdGVtKHNoYXJlX2lkKVxcbiAgICB9IGVsc2UgaWYgKGdldFBhcmFtKFxcXCJwYXNzd29yZFxcXCIpKSB7XFxuICAgICAgICB2YXIgcGFzc3dvcmQgPSBnZXRQYXJhbShcXFwicGFzc3dvcmRcXFwiKVxcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgdmFyIHBhc3N3b3JkID0gXFxcIlxcXCJcXG4gICAgfVxcbiAgICB2YXIgcmVzID0gSlNPTi5wYXJzZShwb3N0KFxcXCJodHRwczovL2FwaS5hbGl5dW5kcml2ZS5jb20vYWRyaXZlL3YzL3NoYXJlX2xpbmsvZ2V0X3NoYXJlX2J5X2Fub255bW91cz9zaGFyZV9pZD1cXFwiICsgc2hhcmVfaWQsIHtcXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcXG4gICAgICAgICAgICBcXFwic2hhcmVfaWRcXFwiOiBzaGFyZV9pZFxcbiAgICAgICAgfSlcXG4gICAgfSkpXFxuICAgIHZhciBzYSA9IEpTT04ucGFyc2UocG9zdChcXFwiaHR0cHM6Ly9hcGkuYWxpeXVuZHJpdmUuY29tL3YyL3NoYXJlX2xpbmsvZ2V0X3NoYXJlX3Rva2VuXFxcIiwge1xcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xcbiAgICAgICAgICAgIFxcXCJzaGFyZV9wd2RcXFwiOiBwYXNzd29yZCxcXG4gICAgICAgICAgICBcXFwic2hhcmVfaWRcXFwiOiBzaGFyZV9pZFxcbiAgICAgICAgfSlcXG4gICAgfSkpXFxuICAgIGlmIChzYS5zaGFyZV90b2tlbikge1xcbiAgICAgICAgdmFyIHMgPSBzYS5zaGFyZV90b2tlblxcbiAgICAgICAgc2V0UGFnZVRpdGxlKHJlcy5zaGFyZV9uYW1lKVxcbiAgICAgICAgdmFyIHBhdGggPSBNWV9QQVJBTVMucGF0aCB8fCBcXFwicm9vdFxcXCJcXG4gICAgICAgIGlmIChNWV9QQUdFID09IDEpIHtcXG4gICAgICAgICAgICBkLnVuc2hpZnQoe1xcbiAgICAgICAgICAgICAgICB0aXRsZTogcmVzLmNyZWF0b3JfbmFtZSxcXG4gICAgICAgICAgICAgICAgaW1nOiByZXMuYXZhdGFyLFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcImF2YXRhclxcXCJcXG4gICAgICAgICAgICB9LCB7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwi4oCc4oCc4oCd4oCdPHNtYWxsPlxcXCIgKyBmb3JtYXREYXRlKERhdGUucGFyc2UocmVzLnVwZGF0ZWRfYXQpKSArIFxcXCI8L3NtYWxsPlxcXCIsXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF8xXFxcIlxcbiAgICAgICAgICAgIH0sIHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLkv53lrZjliLDmiJHnmoTnvZHnm5hcXFwiLFxcbiAgICAgICAgICAgICAgICB1cmw6IGBzbWFydGRyaXZlOi8vc2hhcmUvYnJvd3NlP3NoYXJlSWQ9JHtzaGFyZV9pZH0mc2hhcmVQd2Q9JHtwYXNzd29yZH1gLFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfY2VudGVyXzFcXFwiXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcIuWIh+aNouagt+W8j1xcXCIsXFxuICAgICAgICAgICAgICAgIHVybDogJChbXFxcIm1vdmllXzFfbGVmdF9waWNcXFwiLCBcXFwiY2FyZF9waWNfM1xcXCIsIFxcXCJhdmF0YXJcXFwiXSkuc2VsZWN0KCgpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIHNldEl0ZW0oXFxcInN0eWxlXFxcIiwgaW5wdXQpXFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5bey5YiH5o2iXFxcIlxcbiAgICAgICAgICAgICAgICB9KSxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzJcXFwiXFxuICAgICAgICAgICAgfSwge1xcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcIuaOkuW6j++8mlxcXCIgKyAoZ2V0TXlWYXIoXFxcIm9yZGVyXFxcIiwgXFxcIm5hbWVcXFwiKSA9PSBcXFwibmFtZVxcXCIgPyBcXFwi5ZCN56ewXFxcIiA6IFxcXCLml7bpl7RcXFwiKSxcXG4gICAgICAgICAgICAgICAgdXJsOiAkKFxcXCIjbm9SZWNvcmRIaXN0b3J5IyNub0xvYWRpbmcjXFxcIikubGF6eVJ1bGUoKCkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBnZXRNeVZhcihcXFwib3JkZXJcXFwiLCBcXFwibmFtZVxcXCIpXFxuICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFwib3JkZXJcXFwiLCAobyA9PSBcXFwibmFtZVxcXCIgPyBcXFwidXBkYXRlZF9hdFxcXCIgOiBcXFwibmFtZVxcXCIpKVxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKVxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+WIh+aNouaIkOWKn1xcXCJcXG4gICAgICAgICAgICAgICAgfSksXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF8yXFxcIlxcbiAgICAgICAgICAgIH0sIHtcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJibGFua19ibG9ja1xcXCJcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyIGZpbGVzID0gJC5yZXF1aXJlKFxcXCJhcGlcXFwiKS5zaGFyZWdldGZpbGVzKHNoYXJlX2lkLCBwYXRoLCBzKVxcbiAgICAgICAgaWYgKGZpbGVzKSB7XFxuICAgICAgICAgICAgcHV0TXlWYXIocGF0aCArIFxcXCJtYXJrZXJcXFwiLCBmaWxlcy5uZXh0X21hcmtlcilcXG4gICAgICAgICAgICBsaXN0ID0gZmlsZXMuaXRlbXNcXG4gICAgICAgICAgICBsaXN0LmZvckVhY2goKGl0ZW0sIGkpID0+IHtcXG4gICAgICAgICAgICAgICAgbGV0IGZpbGVOYW1lID0gaXRlbS5uYW1lXFxuICAgICAgICAgICAgICAgIGxldCBsZW4gPSA0MDtcXG4gICAgICAgICAgICAgICAgbGV0IGxlbjIgPSBsZW4gLyAyO1xcbiAgICAgICAgICAgICAgICBpZiAoZmlsZU5hbWUubGVuZ3RoID49IGxlbikge1xcbiAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWUgPSBmaWxlTmFtZS5zdWJzdHIoMCwgbGVuMikgKyAnLi4uJyArIGZpbGVOYW1lLnN1YnN0cihmaWxlTmFtZS5sZW5ndGggLSBsZW4yKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGZpbGVOYW1lLFxcbiAgICAgICAgICAgICAgICAgICAgZGVzYzogZm9ybWF0RGF0ZShEYXRlLnBhcnNlKGl0ZW0udXBkYXRlZF9hdCkpLFxcbiAgICAgICAgICAgICAgICAgICAgaW1nOiAoaXRlbS50aHVtYm5haWwgPyBpdGVtLnRodW1ibmFpbCA6IChpdGVtLnR5cGUgPT0gXFxcImZvbGRlclxcXCIgPyBcXFwiaHR0cHM6Ly9naXRjb2RlLm5ldC9xcV8zMjM5NDM1MS9kci8tL3Jhdy9tYXN0ZXIvaW1nL+aWh+S7tuexu+WeizIv5paH5Lu25aS5LnN2Z1xcXCIgOiAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9hcGlcXFwiKS5nZXRJY29uKGl0ZW0ubmFtZSkpKSxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogKGl0ZW0udHlwZSA9PSBcXFwiZm9sZGVyXFxcIiA/IFxcXCJoaWtlcjovL3BhZ2Uvc2hhcmU/cGFnZT1meXBhZ2Umc2hhcmVfdXJsPVxcXCIgKyBnZXRQYXJhbShcXFwic2hhcmVfdXJsXFxcIikgOiAkKCkubGF6eVJ1bGUoKHNoYXJlX2lkLCBpZCwgbmFtZSwgcykgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9hcGlcXFwiKS5zaGFyZWNodWxpKHNoYXJlX2lkLCBpZCwgbmFtZSwgcylcXG4gICAgICAgICAgICAgICAgICAgIH0sIHNoYXJlX2lkLCBpdGVtLmZpbGVfaWQsIGl0ZW0ubmFtZSwgcykpLFxcbiAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6IGdldEl0ZW0oXFxcInN0eWxlXFxcIiwgXFxcIm1vdmllXzNcXFwiKSxcXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogaXRlbS5maWxlX2lkXFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgIH1cXG4gICAgfSBlbHNlIGlmIChzYS5jb2RlID09IFxcXCJTaGFyZUxpbmsuQ2FuY2VsbGVkXFxcIikge1xcbiAgICAgICAgc2V0UmVzdWx0KFt7XFxuICAgICAgICAgICAgdGl0bGU6IFxcXCLmnaXmmZrkuobvvIzliIbkuqvooqvlj5bmtojkuobgsqBf4LKgXFxcIixcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfY2VudGVyXzFcXFwiXFxuICAgICAgICB9XSlcXG4gICAgfSBlbHNlIGlmIChzYS5jb2RlID09IFxcXCJTaGFyZUxpbmsuRm9yYmlkZGVuXFxcIikge1xcbiAgICAgICAgc2V0UmVzdWx0KFt7XFxuICAgICAgICAgICAgdGl0bGU6IFxcXCLmnaXmmZrkuobvvIzliIbkuqvooqvlsIHnpoHkuobgsqBf4LKgXFxcIixcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfY2VudGVyXzFcXFwiXFxuICAgICAgICB9XSlcXG4gICAgfSBlbHNlIGlmIChzYS5jb2RlID09IFxcXCJTaGFyZUxpbmsuRXhwaXJlZFxcXCIpIHtcXG4gICAgICAgIHNldFJlc3VsdChbe1xcbiAgICAgICAgICAgIHRpdGxlOiBcXFwi5p2l5pma5LqG77yM5YiG5Lqr6L+H5pyf5LqG4LKgX+CyoFxcXCIsXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0X2NlbnRlcl8xXFxcIlxcbiAgICAgICAgfV0pXFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBzZXRSZXN1bHQoW3tcXG4gICAgICAgICAgICB0aXRsZTogXFxcIuivt+i+k+WFpeaPkOWPlueggVxcXCIsXFxuICAgICAgICAgICAgdXJsOiAkKFxcXCJcXFwiKS5pbnB1dCgoc2hhcmVfaWQpID0+IHtcXG4gICAgICAgICAgICAgICAgc2V0SXRlbShzaGFyZV9pZCwgaW5wdXQpXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKClcXG4gICAgICAgICAgICB9LCBzaGFyZV9pZCksXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0X2NlbnRlcl8xXFxcIlxcbiAgICAgICAgfV0pXFxuICAgIH1cXG59XFxuc2V0UmVzdWx0KGQpO1wifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwi5pCc57SiXCIsXCJwYXRoXCI6XCJzZWFyY2hcIixcInJ1bGVcIjpcImpzOlxcbnZhciBkID0gW107XFxuYWRkTGlzdGVuZXIoJ29uQ2xvc2UnLCAkLnRvU3RyaW5nKCgpID0+IHtcXG4gICAgY2xlYXJNeVZhcignc2VhcmNobWFya2VyJylcXG4gICAgY2xlYXJNeVZhcignc2VyYWNoZW5kJylcXG59KSlcXG5cXG5hZGRMaXN0ZW5lcignb25SZWZyZXNoJywgJC50b1N0cmluZygoKSA9PiB7XFxuICAgIGNsZWFyTXlWYXIoJ3NlYXJjaG1hcmtlcicpXFxuICAgIGNsZWFyTXlWYXIoJ3NlcmFjaGVuZCcpXFxufSkpXFxuXFxuXFxuZnVuY3Rpb24gZm9ybWF0RGF0ZSh0aW1lKSB7XFxuICAgIHZhciBkYXRlID0gbmV3IERhdGUodGltZSk7XFxuICAgIHZhciBZWSA9IGRhdGUuZ2V0RnVsbFllYXIoKSArICctJztcXG4gICAgdmFyIE1NID0gKGRhdGUuZ2V0TW9udGgoKSArIDEgPCAxMCA/ICcwJyArIChkYXRlLmdldE1vbnRoKCkgKyAxKSA6IGRhdGUuZ2V0TW9udGgoKSArIDEpICsgJy0nO1xcbiAgICB2YXIgREQgPSAoZGF0ZS5nZXREYXRlKCkgPCAxMCA/ICcwJyArIChkYXRlLmdldERhdGUoKSkgOiBkYXRlLmdldERhdGUoKSk7XFxuICAgIHZhciBoaCA9IChkYXRlLmdldEhvdXJzKCkgPCAxMCA/ICcwJyArIGRhdGUuZ2V0SG91cnMoKSA6IGRhdGUuZ2V0SG91cnMoKSkgKyAnOic7XFxuICAgIHZhciBtbSA9IChkYXRlLmdldE1pbnV0ZXMoKSA8IDEwID8gJzAnICsgZGF0ZS5nZXRNaW51dGVzKCkgOiBkYXRlLmdldE1pbnV0ZXMoKSkgKyAnOic7XFxuICAgIHZhciBzcyA9IChkYXRlLmdldFNlY29uZHMoKSA8IDEwID8gJzAnICsgZGF0ZS5nZXRTZWNvbmRzKCkgOiBkYXRlLmdldFNlY29uZHMoKSk7XFxuICAgIHJldHVybiBZWSArIE1NICsgREQgKyBcXFwiIFxcXCIgKyBoaCArIG1tICsgc3M7XFxufVxcblxcbmxldCBrdyA9IGdldFBhcmFtKFxcXCJrd1xcXCIpO1xcbmxldCBwYWdlID0gTVlfUEFHRTtcXG5cXG5mdW5jdGlvbiBnZXRfU2VhcmNoKGFyciwga3csIHBhZ2UpIHtcXG4gICAgdmFyIGxpbmtzID0ga3cubWF0Y2goL2h0dHBzOlxcXFwvXFxcXC8od3d3XFxcXC5hbGl5dW5kcml2ZVxcXFwuY29tXFxcXC9zfGFseXdwXFxcXC5uZXQpXFxcXC9cXFxcdyovZylcXG4gICAgaWYgKGxpbmtzKSB7XFxuICAgICAgICBhcnIucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6IFxcXCLor4bliKvliLDpk77mjqVcXFwiLFxcbiAgICAgICAgICAgIHVybDogXFxcInRvYXN0Oi8v44O9KCrijJLiiIfijJIqKe++iVxcXCIsXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0X2NlbnRlcl8xXFxcIlxcbiAgICAgICAgfSlcXG4gICAgICAgIGxpbmtzLmZvckVhY2goaXRlbSA9PiB7XFxuICAgICAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IGl0ZW0sXFxuICAgICAgICAgICAgICAgIHVybDogXFxcImhpa2VyOi8vcGFnZS9zaGFyZT9wYWdlPWZ5cGFnZSZzaGFyZV91cmw9XFxcIiArIGl0ZW0sXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF8xXFxcIlxcbiAgICAgICAgICAgIH0pXFxuICAgICAgICB9KVxcbiAgICAgICAgcmV0dXJuIGFyclxcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgdmFyIHBhdGhzID0gTVlfUEFSQU1TLnBhdGggfHwgXFxcInJvb3RcXFwiXFxuICAgICAgICBsZXQgdSA9IFxcXCJodHRwczovL2FwaS5hbGl5dW5kcml2ZS5jb20vYWRyaXZlL3YzL2ZpbGUvc2VhcmNoXFxcIlxcbiAgICAgICAgdmFyIGNvbmZpZyA9IEpTT04ucGFyc2UocmVxdWVzdChcXFwiaGlrZXI6Ly9maWxlcy9ydWxlcy9Kb2UvYWxpLmpzb25cXFwiKSlcXG4gICAgICAgIHZhciBtYXJrID0gZ2V0TXlWYXIoJ3NlYXJjaG1hcmtlcicpIHx8ICcnO1xcbiAgICAgICAgdmFyIGJvZHkgPSB7XFxuICAgICAgICAgICAgXFxcImRyaXZlX2lkXFxcIjogY29uZmlnLmRlZmF1bHRfZHJpdmVfaWQsXFxuICAgICAgICAgICAgXFxcImxpbWl0XFxcIjogMTAwLFxcbiAgICAgICAgICAgICdtYXJrZXInOiBtYXJrLFxcbiAgICAgICAgICAgIFxcXCJpbWFnZV90aHVtYm5haWxfcHJvY2Vzc1xcXCI6IFxcXCJpbWFnZS9yZXNpemUsd180MDAvZm9ybWF0LGpwZWdcXFwiLFxcbiAgICAgICAgICAgIFxcXCJpbWFnZV91cmxfcHJvY2Vzc1xcXCI6IFxcXCJpbWFnZS9yZXNpemUsd18xOTIwL2Zvcm1hdCxqcGVnXFxcIixcXG4gICAgICAgICAgICBcXFwidmlkZW9fdGh1bWJuYWlsX3Byb2Nlc3NcXFwiOiBcXFwidmlkZW8vc25hcHNob3QsdF8xMDAwLGZfanBnLGFyX2F1dG8sd18zMDBcXFwiLFxcbiAgICAgICAgICAgIFxcXCJxdWVyeVxcXCI6IGBuYW1lIG1hdGNoIFxcXFxcXFwiJHtrd31cXFxcXFxcImAsXFxuICAgICAgICAgICAgXFxcIm9yZGVyX2J5XFxcIjogXFxcIm5hbWUgQVNDXFxcIlxcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIGpzb24gPSBKU09OLnBhcnNlKHBvc3QodSwge1xcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAgICAgXFxcImF1dGhvcml6YXRpb25cXFwiOiBjb25maWcuYWNjZXNzX3Rva2VuXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSkpXFxuICAgICAgICB2YXIgbGlzdCA9IGpzb24uaXRlbXM7XFxuICAgICAgICBpZihsaXN0Lmxlbmd0aD09MCl7XFxuICAgICAgICAgICAgYXJyLnB1c2goe1xcbiAgICAgICAgICAgICAgICB0aXRsZTogJ+KAnOKAnOKAneKAnTxzbWFsbD48Zm9udCBjb2xvcj1cXFwiZ3JleVxcXCI+5peg56ym5ZCI57uT5p6cPC9mb250Pjwvc21hbGw+JyxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJyxcXG4gICAgICAgICAgICAgICAgdXJsOiAnaGlrZXI6Ly9lbXB0eScsXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICByZXR1cm4gYXJyO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGpzb24ubmV4dF9tYXJrZXIgIT0gJycpIHtcXG4gICAgICAgICAgICBwdXRNeVZhcignc2VhcmNobWFya2VyJywganNvbi5uZXh0X21hcmtlcik7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHB1dE15VmFyKCdzZXJhY2hlbmQnLCAnMScpXFxuICAgICAgICB9XFxuICAgICAgICBpZiAoZ2V0TXlWYXIoJ3NlcmFjaGVuZCcsICcwJykgPT0gJzEnICYmIHBhZ2UgPiAxKSB7XFxuICAgICAgICAgICAgYXJyLnB1c2goe1xcbiAgICAgICAgICAgICAgICB0aXRsZTogJ+KAnOKAnOKAneKAnTxzbWFsbD48Zm9udCBjb2xvcj1cXFwiZ3JleVxcXCI+5Yir5YiS5LqG5Yiw5bqV5LqGPC9mb250Pjwvc21hbGw+JyxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJyxcXG4gICAgICAgICAgICAgICAgdXJsOiAnaGlrZXI6Ly9lbXB0eScsXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICByZXR1cm4gYXJyO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBsaXN0LmZvckVhY2goaXRlbSA9PiB7XFxuICAgICAgICAgICAgICAgIGxldCBmaWxlTmFtZSA9IGl0ZW0ubmFtZVxcbiAgICAgICAgICAgICAgICBsZXQgbGVuID0gNDA7XFxuICAgICAgICAgICAgICAgIGxldCBsZW4yID0gbGVuIC8gMjtcXG4gICAgICAgICAgICAgICAgaWYgKGZpbGVOYW1lLmxlbmd0aCA+PSBsZW4pIHtcXG4gICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lID0gZmlsZU5hbWUuc3Vic3RyKDAsIGxlbjIpICsgJy4uLicgKyBmaWxlTmFtZS5zdWJzdHIoZmlsZU5hbWUubGVuZ3RoIC0gbGVuMik7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgYXJyLnB1c2goe1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGZpbGVOYW1lLFxcbiAgICAgICAgICAgICAgICAgICAgaW1nOiAoaXRlbS50aHVtYm5haWwgPyBpdGVtLnRodW1ibmFpbCA6IChpdGVtLnR5cGUgPT0gXFxcImZvbGRlclxcXCIgPyBcXFwiaHR0cHM6Ly9naXRjb2RlLm5ldC9xcV8zMjM5NDM1MS9kci8tL3Jhdy9tYXN0ZXIvaW1nL+aWh+S7tuexu+WeizIv5paH5Lu25aS5LnN2Z1xcXCIgOiAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9hcGlcXFwiKS5nZXRJY29uKGl0ZW0ubmFtZSkpKSxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogKGl0ZW0udHlwZSA9PSBcXFwiZm9sZGVyXFxcIiA/IFxcXCJoaWtlcjovL3BhZ2UvaG9tZVxcXCIgOiAkKCkubGF6eVJ1bGUoKGlkLCBuYW1lLCB1cmwpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvYXBpXFxcIikuY2h1bGkoaWQsIG5hbWUsIHVybClcXG4gICAgICAgICAgICAgICAgICAgIH0sIGl0ZW0uZmlsZV9pZCwgaXRlbS5uYW1lLCBpdGVtLnVybCkpLFxcbiAgICAgICAgICAgICAgICAgICAgZGVzYzogZm9ybWF0RGF0ZShEYXRlLnBhcnNlKGl0ZW0udXBkYXRlZF9hdCkpLFxcbiAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJhdmF0YXJcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBpdGVtLmZpbGVfaWRcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgICAgIHJldHVybiBhcnJcXG4gICAgICAgIH1cXG4gICAgfVxcbn1cXG5cXG5nZXRfU2VhcmNoKGQsa3cscGFnZSlcXG5cXG5zZXRSZXN1bHQoZCk7XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLpmL/ph4xsYXp5XCIsXCJwYXRoXCI6XCJhbGlsYXp5XCIsXCJydWxlXCI6XCJldmFsUHJpdmF0ZUpTKFxcXCJyTyszN3VHK2IySmJsOTFKWGUxQUxmWnpEbElRZ1BGSEM2Y1EzK1dPUHhsV2VtMy9jKzkzOUVBOGgxN1VvZXVCTHpsbUQvS2FlWFJ2SUpXUHh2UnZzbm93L1kwMmU1Y21QMmowcW9JOXBmeFhzTDE2QlVVS05NS3lacHB4Z1dDcnBmakRXeXZIakhsL1ZhSEJTVC8xTUR1blVhMlcyUHlTWlViVXEyNk95dUJZVmovWXpJajJ6bHFMZXBQWmVqandrTjcxU0pQK0tuM0w2RFpibWVwZFZVMlVncCtTWkNmbEJIdXlQSDJ5MldXeDMrMmpNYm5RNERJSVptQktwdzc2cCs4WXBNVTFsVm5vdGU4bW1FbzE2MmJMOUMrQjFRU1lkT2hvdDRDSXMxMmhRTENCV3lYdGhlUTFwbW9ZeGJub2xYdktSYnY1WVl0cEZNVDVPWkNnOXByRWphZ1laLy91ZEt6eSt4QlNoQTB1SzBMOFNka2tjaDJOVGlrU1dkQTNjS2tMRHJRbm5UTHUzNFhxVkdmK01xVEZndUFrRFlRRjZ0Nm1zRVlQMXFycmtCc21EeW5Bd2FFTjUyL3RNb3lYSC9GWGJ2YkdEOXVzZnE3azNjU1N5My9XaFNET2g5TVMydytrUCtsNEtTSm9qd3ZwMnhmQ3dESEtsSkFOendWaGlhRDN6WE95VVpzQnFCdEVvTC83ek9LR2hNa0ZHVWJ2bFN4MnJ6a0ZwYVpQdXBsL3pWalUwZVA3VC9hQ2VjV3pXMVYyNm9pbEZZeVhGWit2N0VIRThIUXlDaWVabXlMb211VnRnbmR5SGNkQzF2cVd4RmVYcm55amVsWFRYVE5xTFlUdzI4clp6RENSVWt3UDZkRG41ekR0TXZ4QzNQTWVRMFdkS0d5bXN3RWVucFlRQXFHelBvbHpMNE1MaDhtZ0ZhazIxalN5V0FrS0VkdGpPTVA2MDZVaGh5TlBZaEMxcmQxeFc5bmo5M0FmQ2ZxQm1RdEZEaVQzRnFOUEZIWGtaNFdNYzhWS2MvdjhhamdSWnZib2x4ckVWcW1GU3Ywb1FSWGs5ZGMvRVNMeXBQaUM2RzR2MGFDdk5BR2VpTFcrb2Z6bVJDeDEzWkM4MFNwbCtUajlnYWxneFBMUjZ5N3h6UHpodytjWDFuYmc5MU9Ud09xVXlhN2J2VG05UEk0TnlxR0FWbDNtZ0ZJUlhKcmJuQVk4RndWK3hlRGE1Z1dZekpQSGlFNG1uQjFDZlo2QnZXZWorbUpJbnhxa0IzL016RTN1SDJVenlYVXgrNFloMUZBQ2NPODdZc1IwNS9wNlhtbm1PK1NOYlQ3alAvM25hVzZheDBUL1I1Y0FBbTYyVnczQS9hYVduelBpTExyd2cyZUZIVWt2QUFuR0FVek1MWUlZbE00dG81RktGT1VsZDAzLzRIdHp6RytaVEtYNzRyRC9kK3A2VkRsTzlNTkVacEFQdk5GaHBlSERkNkFxcUVjYUtOK2R6UmFvS2c2NnU1VkhCTWFEVDczK0drMHVoSnNTWWJ3TVhzUExLdE4wUzVYUDcxbUZpM2hTQmdFSTJjVHdqd1QramNMNmdPRzIyWHhoU0NEWEhsYXM5ajEyU2hUbEpYZE4vK0I3Yzh4dm1VeWwrM2JPR0ZTUzBZRktsbmMrOGFUcUhRb3doWmo3NS9NNTNzS1lYMnpSZ09TVGFEMzFSb1FLU0VjUERpTkVzWjJUb21Oa0FtdmYwMzErZlczY2htMVJ3S3crWDlHeGZtSFE3cmlEb1NSaW9VYVp3SGVsRDFsb0Vlc0N5RDUwMUg3Ulk5WnlRVTZxTVplZmtlR1VCT1FaQ2Fac0F3RW5TRCtpN0NxRWhnMi9XY2Z0b3ppUkl4aFhZMkY3bFU1cEVsSUd5V3BuRFZnWnlOY0VheGhuR1FMbE1DUTBPRklKSGpZRG0yalhCdFV2RmtwSi9kK0NnZURENG82ZU5IeE1sQUpSdXNuQWhLcGtNTStVZWc2OVdQbHZESGc4clphNVFuY3pwTjEyM0YvQUs0SnlXMVYyNm9pbEZZeVhGWit2N0VIRThCcE1raCs5WTAvRHpIRG9PT1BnUHpYZ3hxWkFZYkFDV2Ewa0kvQVpMa0QvZWw2QjVCSWppWUhnMUFJbUtsWFhRbWNMUzBzd0doWjJDb1V6Y0JTa0V2UE9sREw3RHZ6enNPUW5LKy9iQ2M0bjlzN2tmRWg1R0grbVY0RTM3NzFwNmlrOUIranZIcjdqYTBTZ3ZRbkNRTTlIZHNsWlNROVd5c3RXSzNkYTg3SW1GKzB5SExsN3JpeEtVNDdXZ3dTVFcwNmxBbWRoalNJVWg2RkswMXpGRk93TlNaZE11MHBxdUU3a3l4ZkZvMXpGSEhWL3k4ZzRPdU12bUozcVBFZXVhRUJGeFE3RVBpUDMvbnhhMGxpOXFhMnR4Y2h5b2dVZDFIL1o5QTRCeGplVnpFc0ZBMkt1QVdHVGYrUGZyajR1OXRYUi9MNXd3VTVGS2tnelRKNVh0NXVkV1hSSDZ0VkpPK05HQmpHSGMxblB0TmtDalR4emExRm5KWUc5RmdHTWsweGpIWXprVE0wb0IwSWdlZjc3T2U4blBRRmEyNkVZcVFHaXM4YUVxVUJXUVA3THZLNTRpejhwOThjdGg2SklNRllwS2lHZ0ZpWmliRlEzclAzdERGd3NzRDJ1NTF2NktQM1M3TlRnVXBidGljbG5rQ21Rc3M5Zy9IMGVMbDF1RTg2VU12c08vUE93NUNjcjc5c0p6aWNQT3lUMkFYNG9GcTh0anY0TXBwSnRqb2pOdUIyeDNwRjRNS1AzWDJrbWZZR2hGdExsU2M1aFphRFNOd0hTdmZ6bEVHYXNLNnVFQ05nU2JoM3dNZGFFZnJTNkxJMjhiQkdHdndKVVF4bXVmeWh5VkRPUk1zcTlTMDEvbHpyK04yb1dLelBEK2NTOGNmTFpJV3RlYmV0VzhBTW93cGlSZ1FZdGpRNEZMTklBKzhHWGo0QmVwTXMrdTdWZFdaY25nZjlFVkxaQVBSMmlkL2tUVUwwdFdXNDBUd0cyWmNpRzNydmRkRzFzTi91SU9peVRNUE81U244RkNQSWpJZGhFZ3FmYkxxR2xvQUdGZU5TRW9GQjBSWXUwaFZtYlhjd1JES1VZaTBYVEw3YkRRdUI2TVJOU3ZkcWJ1ZjdscmVrMTJZQ1J5cGhxZldQRmtmS2ZPYjRWY3ZwYXY1VTByWVczSUhocVJyM25rUFg4YjAweHNTeEJEMVpHSlBLcEVmbHFod3dvTmxJRlhVOHhwWHdGSzJrU2hBTHZhZnZqTDdHNitpd3NlR0tIcW94VkxoNUNGNWRzU0I0RWFCc3kxVU5tNWRwUm1GS1BMdFBvZGJoamhMdGxid3IxNGt0eXI4Qzk2YnhXck1wTnNVazNIekM5Tk5ZUG1rQkk3OWpqQitBZ3JUUFJWMXIvSHNHcHp5TTN0K3dFdmQrSWppU05zZXNoTit6c2liWUF0N1FPenA0Tzhrd2NwK0dRSkVOd3dRdVU5bnhwRE9FMW9mWmlNbUY4a3Z1WExZbkNFbUNlTHI4SHlSdDZGT3JRVDhQYzV0UWI5akQ1MGVrRUlObHcvVnNmRmJSZXk1NWJmT0V2S1BYT1lYVlhxZkh0MFBoMDlWRldGYW9KT0ZTL0pTOTltK0ZTdklEbjBncHpvWGhJUnF3N0I3bkplNHJoVXdSLzIzNnBDbFVqa1dLZEtzMVpGdy8xVXZkTjN3ZHBRN3A5S2YrT1VzalhDMzgwMk9lZnBRb25VNzZ5c3lLVG1WNDE0YmNYek9IZ21HSFRKMVFrNkQ3ZGE4dGRHUlp5bGxxV0RzNlVNdnNPL1BPdzVDY3I3OXNKemljYWl4QWQzQ2V0VUF0c2tRVnhZSmh2Wk9UZXVKYUxhNDVaQlpnK2xYbStZYWNoQU8reUI2YkRmMG9aNXk0L0dmNDFpSGY4REJvUG0yMk5vMUdRalBBQ0k2Q2h5N05BK3QwbFdTRG1ZNlJiZGp6dmN1WElFcmdyMUQvUHVnRm1oT1ZrVTFBTXphd0YyZmh4OWlDUm5GSmpRZXFQeGdaUzkvWi90NEIzV1hQSUIwd0FxVHJ6bjZvUjNEWktORGEyajNuZFhCUjhZSlNVaU96NWNwNGRoQkd2OWEzT0o5YVcybi9yd0FnYzVtcUpueXJDekMzS09nMWRWSWwzekFhbW5ic0wxcE1lQ3JnVkhmbUY3STkvY2Z2TU9WY0tXVWtoTkVqbWtINzl6ek96NURtdktwYVNHZFFocXhjeWdqQnpuVjRueHNUTnNCWmwxSzBVVGsvd0FTOFh5eXZMU05aV2Mvc0luL3ZXU0FIVTl2Yk81SHhJZVJoL3BsZUJOKys5YWVyT2FkUWgydFRVc1lpcXIxYWNidGZabHM4WGhscDlrem5RR0dHTCtPUmdkcHc5dHB2MlRwK2UxMTIySG1nOGIxNVlZN0s3c3p4aGlJeUl1bTR5a0R2Vk03b1A3ZjJkQWJabitmTS9pSVRic09rMlA0dGJpdHhzdW9BZXJwNDF0ZmxZWUtDL2tXODd1L1k0aXZBUUZuNFJoN2FuTjdPL1RSeVRPNHY0SlZKVHMzOUJuZklNd1JGZGplWUFRZTlHUGJtZ1VaTGREUS9Gb2FrZXhYRkxKQ3NwMkRxN1ZhbXFhOFRUMER6RmR0ME5OZVd5N3NNTVhtbTVDUDROOUZ4NTIxYlAwbDdzTXp3WVJTZWhIVU1aLzBOSDlQbTN4Y2ZJZTJBWU5OQURMT25JaW03Wm1tS2hrdFJkdExTdmpHWUUxVVVlQksvbkRsMFF1cWRDaWovWUJaT1hzTWhPQ25zRVVjUjg4R3lsbTViUDRkOGI0aWI2eC9pREFQY3lUSDV4NzhoTnlhUmJhaC9ZdVM0ajA1Wm5KWXBJTzlnUHpUeWJiSS93SE5yNW9ES0NscDZGb0pWemZ6VWpVN1lCcGRabU04OWhOMUc4OW9hTEFFdml4dm9Oci85bjAwZk1RS0twTmgvbXRGQXF1ajhxZ3kxNTJtUnpnTnBHeTc2TFZqZXF3cTZqWFhUWGxYUlBKbEJTSTJCeEVTNUIwVmRhL3g3QnFjOGpON2ZzQkwzZmlIVmRUemc2QksrdEZkSXBPNzk0SFJyaWhvVEpCUmxHNzVVc2RxODVCYVdtUjRNV0l2a1hMd1ZqRDkxZTJHcEhEbjZ6eUNqb2o5eXk2ZEtZSHhnWnFCZXBWNUFZdi9tbzlpcWVraXRXUHRLU3Y1VTByWVczSUhocVJyM25rUFg4YjltTXRxMmxwQmtaRjUyWEViZHk5eFNBaWl5V0R1aEVhOEdITkQ4cTdvUERqUGEvMXpWK0VpTnpBamd4a0N3Rmo0aTFsSmNIbXJlWUxZREZNNkdSWFJCNFJoeWRwbS9RVDJWYkVzV2I5aCtsNzZMMjJndFk3ZDJDbElMM0NobDV3c3NyeTBqV1ZuUDdDSi83MWtnQjFQWVA3bU9NZHdWbHdQL0Eyem9aWUt5d0cybUhZNlNMZXByMVA1VitEME1GdUZMVm1kTmJ3SjZ3Yjd0WmhrTEVZNy9MSzh0STFsWnord2lmKzlaSUFkVDJaNThGRFJ4Vjd1WlpWVzY5VFY4QUFJdjdKSTZJWWZjUU1uSjZpL3Bqa1lpR2RvV2MvYVdnQVBldWNrUWtVK2hVazhRT0xYeE1nODNkNU5qQTJ0Vmh1OUpxYjhhKzNsMWN5ZzZ1VzA0bVpvRUJiSXBiY053eU1IamozMG1GdDdKd1dOWGpVcnhVbkE1NXFsb0k4Z2RPUWNzcnkwaldWblA3Q0ovNzFrZ0IxUFp2bHF4SmVUVlpKNUJ2QlB3OEtSUXB3Rml0SFNoK0VLSkdDTW9VdUZJMjFCcEJaWnJ1TW5jRW1LbldtVytPTkIzMVY3aFlpVWFXNUpuVXFZOWh6OENRb3ozeFRvVlhHeDJ5QzMwcWFlRlhLb2RXMTRLSFJSRjlJcHUrZ0dDb0xBa3BwUGNFWVlCS0FDc0FQN0EzWWdrVVJxdFVnRmhrMDJUUXNsZE8yVG9uSU1OZjlQS1Q3REdvby9KVHJybGp4b2VtSnhLTEhSZEs2SmlsZlA4b1NRV2tvTEp2N3RyQVpmeVpldmdkKzg1RS9tdUd6OGJjMEt4MTlNaHU2UFBuOVNxa0R2MXRndElsMFprYW00ZGIzMUhzTGZtNHZjS0p3cW5rZkhIL2xDdjU3ZlovZTdEVFdzNVRHeU5KaVBLZmw5RWFmT2dFc0RHMnIxQTcyUlVnWWpVbDlrWVZpVUgvd09mQ1VJSlFqNW5SRmpOWkp2bkkxRE5aVnpJa2R6bXJ3SE9takVtVHY3Q1NnVkVpM1NNbUhZRjZzK1VNaWgzdW82Z1BiUmhPZnMwVWp6eDJJamk0Q1dkVlBBcU9NYVpjdHhsUzNUdmp2bGFXMFRJM3lJR2JFOVJySUhJaDFqcmEzQXBZejk3TWcvREhYRGMyT2FuRDFWakVkc3lhSlpPc0tRUHRzaWo1cGp0WVlRV01WMlRzN0FvWUQ5d0tRQkRqUXcvSnJ4blFOUStMTmM4WkhMMVd2clpEWXNtQ2p3VEdIWndMckNDRUU4SnNGYjEvajhFc1pUMWZJT1hjcTdzYjZVMzNwUGcwNDk2OS9wTzlKTUZwNmRNcU1UTVFIbzkzWDJPbHdwOVRvcmlXcUJicXVGZC84M1lUa2YraDRXRW04SldDbk9GTnlzWWtqNEtKbUNhZEE3T1JNbWlTeUt6ZE9rVlNkbVRRbU0xV2cwN205akdMcHE0ZGFlWE5ObGRSUW9saThudG1wWDN5NW9Zd3FwanBQV2ExRE9IUGx3WXlUNHg3QSs1Q3VYV2d5aDIwcFg2RVJUakxuY0ZXZ0FjS05Camc3NysxYndkVkQxTTlCdVpEMlladjhxZFdibXNodkdzbFErTnVNcjZEbUNUTkM4NWZpMHVMRFhsdzZMT0FRUGhNeFQ2NWkwcmhsVEpGRUptSEdDeU5WSi9kUFVJbjArbjVpYzEwQ2RFeWl2anlNTWxoTkY0VlRqOUpCZ0Z1MVVKUVgrM3Y0UjhITVZ0VmR1cUlwUldNbHhXZnIreEJ4UEJiRlZZRGltbHVDTzBBSkdranJYVlRQTzl5NWNnU3VDdlVQOCs2QVdhRTVRaXVIbllaekNUSzN3bGd1WmgyTlJacHFMUkVlWlZnV2hLMXZBNHVsREFBOGNFbzE5RzY3WUxtVFFKb3pwWTNYY3NyeTBqV1ZuUDdDSi83MWtnQjFQWXhjZFNTT2ZBTjJBOEE0cExMd1ZjMFlUdWZldXYreDZrLzVRNTRVOGdIVU1zcnkwaldWblA3Q0ovNzFrZ0IxUGJSSmtEajJTVUo0aTNObHZ4Rm5FWi9HS1ZRWDNvcXJwWm0xZU5WeVB0b0lKYVVwT3BZU3pncjEyTGJIRlI1azkvTEs4dEkxbFp6K3dpZis5WklBZFQyZzJCa09rYVFJQWV4ZFNBU0c5UE5Sa3hUUUpDc0pPN2VpcWRGSHh1cmFNdWtIKzNWQ3JhMjIzWWhmZ04vTTQrSUVnTUg2QnlJL2x6eUNvSHM4OGVzK0ZQVk5TOU5IM3BwYWdCdGEwUW1hUktkdXBJeUx4MlZ3dzc5bG9FUUI2UUp5eXZMU05aV2Mvc0luL3ZXU0FIVTlwS24zc2NJTHNZb3R5bXpKUVVsV1JqOE91YUdvb1lHOVNRQWhFRkNvdVFEeXl2TFNOWldjL3NJbi92V1NBSFU5Z1d0dVArR2lDTFZhRnR3MTVoMFBLTE5Nc2NBVTQrUlR3R1VSYnlzVlBhUkNUNGFSZXZ0azdxZnJJRzBQcHZTM2NzcnkwaldWblA3Q0ovNzFrZ0IxUFpjQWhjUzR5eWhEYjFCL3JTcTJWTDMxR0ovY1h1YXlEN0xmRjlpcWhteG9Yd2N0dlVyb3laZ20vSFIrZ0p6MDB1ZkgwNGsydGtEVjFEZXhBWHIvNjlKV0xobGZwa3pIOXo5UCs4MUlwQkVIcERuclhyeDlDd0hBZnM2elVnTFNscVJueEdxZ1prSjVVSUYzRVBqVFVKQ2FBR2ZyNlpXbGpINmdlSFpkSTlOSkV6QzZMZzQ3RDh0L3J2SC9jLzlLN0xMSzh0STFsWnord2lmKzlaSUFkVDJiNWFzU1hrMVdTZVFid1Q4UENrVUtTZ3FJZVU4RFpFUWttZTNGWGVGVEw3MURnUTZKQklMTWhFSVY3cHlrQzdLMmhOMEFVQVhVNWNJQklqOXZadEdwODZVTXZzTy9QT3c1Q2NyNzlzSnppZTdmOTdrS3BETnpDazZjQlgxR2tCMGkzcEFOc2o4c2NzSm9IaFQ2MFNpNGM2VU12c08vUE93NUNjcjc5c0p6aWRtaTBVL3FJa3pSb0lXUlEwZ09UeEUxeVJXMWU5Z1VKWThGQ3ZlaGxkMmtETkREbHMvVE1pVTY2UDlCZXNQMWtQNkVBdGZBbFB4cHk3TG9VcXJCeTU5MmNZajdJa1pMbG1FdjlsaWdGWUJ6NTl3WHdJWGdQZG81NGdJTDZSU242YTE4TVdUQytEUUo4ZWtrcllKR1g2bjlqS041bklPRjN6ekcxT0ZBbW5lV1BVcENiT0lmUkxGWW5wbEdZaHFteUNqQ25Lc3luc1I3elhEbTdpeFVrWHdsdVdoVlNISURTRW00S20yampXZWNwazVHWGFIbzhEaDZGSzFCMS9uUHN4anRYUlZHMmNaOXY5QXliMG40aTJMeG9MbU5sUUo0eDRYdDNsNkl2MWNOL1F4cXhrNXdxSFZvKzV2blFJNHFGVlA2VFVob3BrV1VUY0JxbHhIOXpudFVkczE1dUxvYnlmSjFmcXMva0V2RnRJKzZpS1RTY1pyQWNvT1hVT2Q4MmY2N3cvZ3M2aWw4N3c2VENPOWgxMkdNVTRvMXBFR082SXFhd2MwYU9HWTF3S2xHSXh6ZjZFOHlmNk45RWFIUEFrRktVR3F2YitSMUNIMExhdlZuNWxoUXJpdFpwTEFYZytZcGYyaldzcGsxbHNYemVFMGl4ZVk4UmtidUtGdUdhelJObzlDRHQ2VVpVejUxK2JmQlVhaUVyTEhaMWoxcnFXaUExVmt3bWIyTGJLN2cxK3V6OFJTK2Y1L21vTDNEdVJrZHBaYkFyYXBOTnl3ZDlZQms2Qnk2aEJwWUJBQU9pa0l4bkVIM3JVQy8xM1NVeUlKelhSbnBXWnJzL3MzL2x3OFNNeUxvV0RVQkdpNHk0bVl2T21sUWE5RGxsNlEwQi95eUhXbTVaTm82V29nYkRJLzhkOWR2aG5FcjJUSmVSdzFXbm9GSm1hSy8zbmQ2WUhta2lqOUgzbm5OVldEdUJZbUZaam93b0FwRVk4VjU4S2wycWRNVFhiMlozWU1XVlhSVEVmRFgwZDRLNVdnNFV0M1o2NFEySmVaWmV3aTNNeThTRmZxSGxGVHRteVM5VU01N3lESWh5Z05lTC84aHBmWklzM2tWS2x6NVZzVFhwRGFaNmN5TS9CMFU1cVRleVBKaXNQaGs2cDlPd2ppTnhpaDdLUVVqTnVKUEJMMHBoSTFDbVV0WWpXek1pbE1RVGRrQWFYUlBuWUxVUkRiWWJjMlV2RDBJSzI2Ull4YUhJTDBlRlRGMk5FcE9rbG5sOEZDTklabkY1WC90RHI4akNPaTJ5RkpBMnVLa2hXMW5taEl2OEx3S1pWbnA1OEFZSXNEQTh4Z3Z4TWEwQ0VHL25GZ2xxRGxOV2dzWWhsRmpGZDdwUEhvS1k5akg2WnhNNzRjZFlxYlRSK3RWdDdnNTNIVnJ3ZkxpTUw4cnVocWRGTUVOOGlkYTFRZWU4WGY2cGdsbzFkS2NZYnc2Qm1uOGVRUHN1RHQvay90OS83b1R1WXYzRmdwdXowbHRhRUZNWldwR3Bzd29hVXN2dDIrekh5Um5tM2kvODI4Lzc0S0UzQlBWcXhpUWY3NFhJMG5tbVlkU0xCNGJKL1hOWUc3WGg3MCtiZkZ4OGg3WUJnMDBBTXM2Y2lLWG1BMENxZUtFeGhmVnY1cEpLMUEyVzZlR0ZhTGtVQ2h4RnJaemo0RktMU3Q1S3Jpa0c1RGh6ZnNtbWdkSmhYR0pubENwR1N0b0JIOCt5aERVMVpjSjNUSDkvMEE1T0hZMlQxb3BvTlBsc2VzaWdlbTZ2bzBuM1Fzc2RacExscWsyRTlGQ1dDVG9Oa1NvY0tuQW9nMTAzWmVkUTNOOStINUpqMSs4S1htZDJGazhMVkczZjNtNitzQVVJenAxVk9LOXN0TDJVcHZ4cHNIYnFNQ3haVmR1ZXdqUCtML285YXVEYWdhNHZsZWFLLzhwL01EL1R6SmltWFEvbHdUbG53bWlWU24yWDZPSzkwUmZFcWprQy9ySVZLcW5hemRSSTFuV1labmlYSmU2TXZMSzh0STFsWnord2lmKzlaSUFkVDJ1SHF2NnVIT1pCODlwb0ROeW5KeHlzc3J5MGpXVm5QN0NKLzcxa2dCMVBZMjhMQ1lUUVM0eVJYdjB6VkdKVTFWeXl2TFNOWldjL3NJbi92V1NBSFU5clBSUHhJa1VBT09GZFBqYUEzUitwTGl0QWNUYVcwOWdCT1RCSEFkeGwzanNEMWN4UCtrYThFRnEwVy9ObEtYejRsVXA5bCtqaXZkRVh4S281QXY2eUcrTnZEdktmdTNhZHhHdERDelBNcmV3RXFabDZOQllUUi9nN1NSUzVEVDNJeE1jSlBkTCtlYlJaQ3p4UWlLMnNzUFRZOTRsTGZ0bzJxcFp6RWh4Z1IxNFhrZmRFekZ1bitPdmhONEVwdkpWaDZyRnE1eC9zdXJ5b2xjL0tnVElVRlp3K29oVE9FWDFDZGwyNDRaS1h2YXl5dkxTTlpXYy9zSW4vdldTQUhVOWwvSC9heUhuVWpDcEFTWG5lUjhhNlRhRjJRTmRrdFl6bE16bnl4NjkyZlVPODdjajhyNml5Z2JwbEpIdThScEg4c3J5MGpXVm5QN0NKLzcxa2dCMVBhV0s3b1ZPYURJMEFkc3A4cjlCRUEzU3h6eUx3cG8zcEVTeDRLTmwwbzgzZk9GdzUyeTcvdk8vczlaSTA3VnBBbEd1eUk2STBrOUpxbUpJVExobi9FVXFDVzFvYU10SzdFbnRTdmlNMjMySlMydmdiOXI0T2Fod1IwNFdwZTM1RlZVZXZlc0kxemxKREdNbCtVRVFtSmRmQ0RhUFhvbWxkTVIydTJMYVRoOEZSS0tNMUk5RkJmNW5JaVZOZkZkOHZud1VDeWthK1l3SDhTTmNKQ3dOQWt2eXl2TFNOWldjL3NJbi92V1NBSFU5aUhxZmpVbU1tR2s1bzhrQlhudjZkV25MNElDMWRGY1RseE92VjhHYlN5L3l5dkxTTlpXYy9zSW4vdldTQUhVOWdSQ3dhU1dPU3RJTUlEazFsT2hwejNXQ2xuZ2UvQmY0MytyZWN0cmNrWWFCTGwxV1Q3UVVsWDVxNkVHRjNpMnRpSGYxWisvanc4Y0c3YXZTTFpCMUxneGtaNG1rbjQrMndEbms3Y2dWYzh1R0t4ZlZjQmxHdmsrMHd2UWNSVzJsOG1PRTNraE44TTFDNGMwUDl2cGpPQnNDb2E5RVhnN3NaanZZQ21vSUx3bTJrRmFDSEk1c3ZKbE9VS29PdExmZGNzcnkwaldWblA3Q0ovNzFrZ0IxUFpEbUtJSUxwZU9NeUdldFM2NkJZRnlobmFGblAybG9BRDNybkpFSkZQb1ZJL0p4bGtvM3hxcHovSnQwTzdISmZKWi91MzVvMTVPWmpkQ0o5dXh4TUI1M3RCTHlWWHEyQWZWcFh6ai9GQWZZcC93eSt3bUk5alFEaldMSllyWXlJbkxLOHRJMWxaeit3aWYrOVpJQWRUMmVJS0FFWEFZdXo3bTlpdlUxNDVnTUtISG53MDYxaklRN3FXc0Q2a0YwaFM4TFVNNjNrcmR3dkpGdWRaQXhGZld5eXZMU05aV2Mvc0luL3ZXU0FIVTlsNVhETG5wTDVJdHBpNkRkMWw1bkJVSGhVK054am5Hb29OTURidklJSFNuRjkwdDRrOVBGSkJHNUp4eEhDRzkwSHBMZkUxQTVjdUwvVkhqejE0RFJObW9rNnFWQ1dYdURxeENGMnovTlV2TjJaTUFZZWs5eFY0eU1MejF1NnBTVnB6UURoQzlrTlNDZXZQelJaajNoT3lhbTVxZCtLZWdra0VTT0c4a1FRZXByMmhBbGswOGVYOS9oc3pnUGdvRzhaVjdOYStnK0xDUjJJZXZ1OGQ1RDBLZzJoalVCeXd5Z1VFRnEzWmV4VzdSNHNqMzFpc0VFSFdtaWhRUEJ1NXBEQ3ZTcVJLVkZZOWlBOTQ5V09jRTF5RzlhNjFLN01zTEtBcUtvRkR6R3JBNEtEZFFvcU9XOVptWE9XM0R6ZlF6Yi9IVEpCZ0RsTk5JeG9GMHhuSEFtd01ZQXNOTlhUV1cxWjZzLzcvaUpkZmFsWHMxcjZENHNKSFloNis3eDNrUFFyUXBqQlNqdWtrTTRXcC9XaEZ5M3dkaUkzeko3eTF0THo3eVo2ZmVTc2JKS0YxSHRpK1p3WVBtdWUzN3ZzZlBxNEF6Ry9oNWMrU2RhM0VQU1hBNjBYVGNQTzJXNGZ2RUJNcjJrVkpEY0xONHVhM0NnZ0tNMmZiSTM4b0hSZ21EL2Rzam5SSWZ3c0hMaFdOalJGR2c3aUJUZWdvQk00YklPcVZqQ0dUbUVuZEdmK1hJbncrczdwMDVKSEtRamxna1VHTWtwUENOZlFiUHc4QmhRZFR4MGsrMjMzNXhEK3FHOUVJRSthUWNFbm1qTjB1ZTRhejNOY1pCeWVCVzY1MlJSTXpDZ2FzZTNQU0pMUjZZTjFQVmNmL2tRdUY4eW1tLzRWSEVVVmdaS2Flb1k1MExYUjBzOExldTQxTk9MaTIzT1hKbmE1Nk1oSHRqSGhUM1hydTQwd3Z1OVNjRTdLdXV6cnBUT0FkUGVlYVpROG9ENnVqclVZYjlreE5ScUNBYW1nOGl1a1dEUVlSS2lRQ2Z6cjE0SGlKZnhSU01KcFNkUkJHYzlrMUcxY2p5WnlCL01rUGd5bVRmQWJmQmV3Z2V3SlorejQ0dHVudWdwWTZ3bHRWTmZiWS9iRUhuNzhNd0hLeFVNQjZVamlsaDhwWk96NnFrcUoxOG9EQVRmR2JPS0V5NThtZWtQZVRlR2JZYlR6WHFZU1JHVzNFSktSS0xEelpjV2FBMFlQdHNwckozMzJCbWFLcGJEY1BiYTIrd2FoWGJieTMvb0ZHMFFwWnhybG9paDcvUGVyYkpLQklVWVhic0NXLzJScE03b3pVTmw5RXJ4Vk1NZEtGbUM1S0s0WmNMUHpQWmxIRWRIdDUvZGVkSm5Uenh2MGpsdWlnL084dlRVaUw2UUJxR3l5dkxTTlpXYy9zSW4vdldTQUhVOXFERGVTRXhzMjN0WXBXYzU0YnZqTHYxNDhJSkR4cG1iREpPa2RKTkk3NUg2dGo5RHk3V0svUWYydEVkNHZDTWpXamtkU2pjTmRXckwxV0RrVGZsNGxjNzZHeTVheHI2byttUEdsZ0lvNWdId3prVHJpbzRqQVJINlp3VFhwUmxIM2dtL1JPTTI3TVBxVHZDOEFiZmd6YmE1Z3pWd3I0VjYxTk96YVFLMU03cHZPdDNQSVRZb0Z2bUNmZGhiN1NRaWpmZGw5T3hOY29Odk1aWVdnKzF6TG5MSzh0STFsWnord2lmKzlaSUFkVDJ3RXJVSmtrQUxOSDVQWXRpSFBHQThtYzE2YUc4cW00bldWUlJFZjQrYUpleERBdkgzUHlVeFdEMUVGc0I3OTV2eXl2TFNOWldjL3NJbi92V1NBSFU5dkg3L3ZTWDFNVnRwNWpNMG1xSWRLd08xaGZ6VEZDWFp4ZG5aUW5lKzFiR3l5dkxTTlpXYy9zSW4vdldTQUhVOWo4blJtZHlQOS9hQ3ZsbWpXTnEvR3F4Z0xQRnpBaHBROUE1M1JEVWtBbXJHK1V3aHNBTklZWWVNMlZNRE5wa01Nc3J5MGpXVm5QN0NKLzcxa2dCMVBZSTRqY1lvZXlrRkl6YmlUd1M5S1lTWE5XR1M2M1FFc2laM20xazNGQXpOc3NyeTBqV1ZuUDdDSi83MWtnQjFQYVdMTVZhT1ZHNC9lMVZQVFNBelk5SDg3T0NKWGV4K2lBT29XK0tBbnJpQjNKbmE1Nk1oSHRqSGhUM1hydTQwd3RtK0NFV1h1b1k4WEVKRmR2Y0ZjSDd5eXZMU05aV2Mvc0luL3ZXU0FIVTlsTE9MZnJPUU1wQ3hRbERnMDJZSkFUTEs4dEkxbFp6K3dpZis5WklBZFQyazZndnRjMXo1YUltQnFGZ25iUTBOVEU5R0xmYk9DU0VoZCtycFk2a3l3L0xLOHRJMWxaeit3aWYrOVpJQWRUMkNWdjNvWXRNMHpNQVMxeDRYdHkrenNlYkdWNHVGbW9jUzBuTzM0ZXc4TFBMSzh0STFsWnord2lmKzlaSUFkVDJ1TEo5NktYUjM2eHl5cG1HaXBGekZPU1A1SUdDRTJsS3FzSXo2V0F2dHVUTEs4dEkxbFp6K3dpZis5WklBZFQyMXgvd0hwellicW5UQjZNQk9uT29Xa0U4ZzlXK3BaWGt5N0ZaSTNKakh5bkxLOHRJMWxaeit3aWYrOVpJQWRUMjAvM2F3b0QxSXI3ODBleXAvWGNJNjlsRVNGeDE3SFVvd3R6NkRnajZOekhMSzh0STFsWnord2lmKzlaSUFkVDJmb2tQRjZ1NmEwZWdYU0N0bExEd2N4T09jY1llcjlkZzM0V21pOWlINVY0N28yS1E2Yk5pQ08wMnBONTFHZm9PeXl2TFNOWldjL3NJbi92V1NBSFU5dmhDWWdhWCt6SjVZUGlGdS9nbjEwdzIrN2M5cG16a1ZZbW9FazBuR3FpYnl5dkxTTlpXYy9zSW4vdldTQUhVOWhQMVNrbUk1YllCbDdSR25KK1c3U2JMSzh0STFsWnord2lmKzlaSUFkVDJsaXpGV2psUnVQM3RWVDAwZ00yUFIvT3pnaVYzc2ZvZ0RxRnZpZ0o2NGdkeVoydWVqSVI3WXg0VTkxNjd1Tk1MWnZnaEZsN3FHUEZ4Q1JYYjNCWEIrd2srR2tYcjdaTzZuNnlCdEQ2YjB0M0xLOHRJMWxaeit3aWYrOVpJQWRUMmVJS0FFWEFZdXo3bTlpdlUxNDVnTUtISG53MDYxaklRN3FXc0Q2a0YwaFFlQUUvZUNyR1ViRjJiVmhOL2U4ZFRXUjh0bzd5UjR1NWhReXZVQ2NnYjhWTTlCdVpEMlladjhxZFdibXNodkdzVzIxT245WGcycDRzRHRtZEZ6SXViVzFWMjZvaWxGWXlYRlordjdFSEU4T0JFYlRhb0V3Y3ZVU0xyOFAyVXlVNGh4cGN3ZkdTM3Ftc2N1YlBNbkh1cXUrS3gxZkVpVEVrVlR6NnN6clZGZE1zcnkwaldWblA3Q0ovNzFrZ0IxUFkzR0hrM3ZUcWY3dk56OGdFc1BkY0M1clNWKzVMaWJETWtBcnRxcmVudnBPbC9Tcld3QnpkZ1ZzK3lnTStUNlRjMStnS2owRC82NG9mNWhxZkVPRHdFb2hNamswL0krUktkaTA4OURnb01iOHNyeTBqV1ZuUDdDSi83MWtnQjFQWWtZMnVSM2NHR2VORXF4Z0hmaWVpV0NmdDhZaG5rclZBRlJjN3dab2phRnUydFpJSnBPVFBqdTA2UWdVT0VFVFZSVjlTK3EwSDZsZmpuQlRuWlZ0UTl2UDNzY0ZIYmpXUmY4RlJKREtJVlEzaTJpa1FwUmRPN0l4dGs5L2ptaFNFZnFlRU9sSlN1VWpGK1Q2MERmSy9YTVdwYjZBVjIzZXBvK2haSlVkM21jMW5LMGVEeDJFZHZJczRuWXR0WlJmN0xLOHRJMWxaeit3aWYrOVpJQWRUMlcwTmlFanVCZEFoNDVJT2cvZ2lPUXBxYm1wMzRwNkNTUVJJNGJ5UkJCNm5PbERMN0R2enpzT1FuSysvYkNjNG5kMXZubG50VU52ZFVDVnRaTGVjanBCUkpkaTdLZmtyS1oyTlhTQzdieG1CY2JkQ0tTMS9TWFphRXoydzhxUDdyWU9EMTZFUFBVUVphWnA1VmVoK0dWTS96Ry9qZFRBUktvOHdkZHJtcW5IQmJWWGJxaUtVVmpKY1ZuNi9zUWNUd1FQUGI0MHErZ3c5aEFlSG5FZS82djJlU0lwQXN5dVc0WlJMVi9IM0h0N3o1R2lEa0FKb1EzUFlZMzdkSzJTSkRVZHMxNXVMb2J5ZkoxZnFzL2tFdkZvUTVtUU1UWUlwajhkVHNYUndrWmRMQmZOcGlGazhNOVE2TU5yeHBJVmVxVW9VUmFKWDJmdHBJMndoa09ETGhFeU03aDloYit6eU1lZWpZNVlIc3psR1J0QllZZ3JWM2JCWFN3L1pMZXJWeEk1U3hkZndVRENvc3hKaGcvKytFU3pCMEhOcHlnS0FaY3BvUW0veWl1VDl1WEoycnNqM3hFeTFiZ3pGelFuYnl5eXZMU05aV2Mvc0luL3ZXU0FIVTlwNmlrRVkrU3BIOURDMmUreUNtSjF6YTZXa3VndXM1N1h5bXVuOWxPUlcrUFBUQi9nc3lvdS9wbHp3aFExNlZMTXNyeTBqV1ZuUDdDSi83MWtnQjFQYVB6bVJER1hMamxtL1RVYnMyS2F2MUI2ck01WmljdXN4S1hXS3JWRDlPL1FHNEtPT3crdW1FYXRIVGhxZnY5eFBMMDk4N3BCV0U4YmlKNnN3QklvOXU5ZU9QZDRMUG5CeHVCaFoyZXUxSVhBMHErTG91RUxJeUVCTGlubGxzRFBNMGtINW4wVTU3OThWMTJCSVRGcWhXRFFtczVjOUhETnBXb0t1WVM2SkNtTGxJRWhGdHZ4WnZ2cTE0Tno2dG5xRm9ZZHNLZ3owYWpGaWcrN0ZpbWFVOXJjU1VFR2E1RjBxSWhwNGtNTXFnZnQzcVhHMCtXZWV6ZlFaOHJ1b0dQV0lSajhiOGVuR2RnUFFGMWhNd05PbGhrblpjUFBwWmo0MVZVNlQrR3psTnljc3J5MGpXVm5QN0NKLzcxa2dCMVBiK1BlMmFSZmxmM3dPdDZhNW4rNE1oWW9obk1YN09qSVJPVjVFenM0QVVDOHNyeTBqV1ZuUDdDSi83MWtnQjFQYWJCNDk3alVkTWpveUVtVUJWMzRYVjF5UlcxZTlnVUpZOEZDdmVobGQya01zcnkwaldWblA3Q0ovNzFrZ0IxUFo5NnZlRmY1bzA2SGxGaEZrRWJqVk5ydEd2a1Z2VnZObGJVbElEaStFaitPS0ZXUVYyS0h3N3hINzRFdkxKZ2lSOTNpbGNFWExBNDVOWDFmR016Zmc1S1ZMQXFUZnFpaVNqRTUzblNGUU5aaE1VaGE4dlFFUjVJV1dBQXdUZVd1dnh3MEo5Z1ovelNROVB5VzJMbVhLK3QzSFR4SkNuSzNjenVNYUFMVlY5K0l2cTI5K284MmNxRkgrODlib29YcmVLK2dwMmVPVnA2cFJlNklMMldJbll6cFF5K3c3ODg3RGtKeXZ2MnduT0oxRkkvNlp2TXdxK2RVRXREZWJXaEVuVysrRjIzYTFQemZ3L21DS1h3bDVQeXl2TFNOWldjL3NJbi92V1NBSFU5bm9HZHpWdGRhWTBFUGJiRndIbGx0VVV4VTFJeksvNWJVWVFqTjc0QlRQdFd2WkJYK1Z3OVlFTkZLdGwxMUJrenJMSEViNGJGSVlCQ3FIVGlIQUUyYWlnSEo4bW11NW5TR1R2Q1RkTzJhUTJQM1NYRFh2NkJRY1F6cTQ2aFlPdTFRQTEvTkpRTkRwb0hEMHdOU2dKclRwQ0hrbjgwYUxqRGkvL0pMaWlXVjFqckdQRXdycUlsaEsxNmNXYnZYSktiTXNyeTBqV1ZuUDdDSi83MWtnQjFQYnBUZjhCU0JIT3NFQmRBZWdibU5QRU4xR0pGcU5qL0I4VkNMUVdUR1VRRkVPQjJsb0FreElrMTUzYjhNaU5CZ1hMSzh0STFsWnord2lmKzlaSUFkVDJBOGZrWWdTeDZaMnlPbnFycVl4WngrWmpFcFNsMnFWRk1hTkV3SDMwV0ZqTEs4dEkxbFp6K3dpZis5WklBZFQyaVY3eklOMGVOemp3OXQxb3JIWmlVQXAvVC9PdzNGWEFkRkpBSzBMTG5ZaS9VZzhNc0lwZE1qWDl3OVdxazZxVnl5dkxTTlpXYy9zSW4vdldTQUhVOXBqakFmVi83L3BlMU1PSzFKQnVxWkc0VDh1RlpqaVF5NnI1MGVDVytTWS9GZmI5UjJvQmJqdFNpRzFEaUJnSFQzQVd5QVBkQXc1Yy92eUpKN0hFNmFuaFJXVFNCTXBvRXZ1a1l0Y2ZpVWgveXl2TFNOWldjL3NJbi92V1NBSFU5b0RXdWVsQXFmak03ZkNKZk9hc3dRZ2tscFdVVXlqQXN3b0R3Nk5YSDdpMFBsek5xb1pHU0R3VEtQQXVtelloSDBXU2NnZWpHRnRhYVgyV3NWTU1oRmVHajlQSG9qUXpoUFMvaHdGMSsraWxvZ2FZNWt4ZHJMRFVkVHU0K01FemxZejdQS3lROEtqeSt6d21jeVYzUzhkRSttY2FqREJRRC9GZmI4dC9oc3ZuenBReSt3Nzg4N0RrSnl2djJ3bk9KOHNyeTBqV1ZuUDdDSi83MWtnQjFQWWlES2ExazNDRm03VXNGalowV21wenpwUXkrdzc4ODdEa0p5dnYyd25PSjhzcnkwaldWblA3Q0ovNzFrZ0IxUFliMm51QkF6NUI3SHFGelRPK2NUWnltcHVhbmZpbm9KSkJFamh2SkVFSHFjNlVNdnNPL1BPdzVDY3I3OXNKemllN3Z6bE5pS2RrbU1BenZiWlA5OVVKeXl2TFNOWldjL3NJbi92V1NBSFU5bytuZmJrTzFZOXRQRDE5aFc3Y0F4dmxHaWp1dzNCYVAxSzN2b2hvN0E1Z0dxUHdkckJQZTdvODJ2NlVidmpzU3d5T0JUcGp6SzRlN3piOU1aY1NQaUd6VmNBby9LdUY2ZTZDcWczZmpUZjFmWXpYcXplTS9YN0FqQ0VjVVdLdGljc3J5MGpXVm5QN0NKLzcxa2dCMVBaYkZWWURpbWx1Q08wQUpHa2pyWFZUUE85eTVjZ1N1Q3ZVUDgrNkFXYUU1ZC9nMmFhZXBRNHFvK1dRdUJvb0FwT3g4N3dJYzZhM09BTmVwbXhKSGJ3b3l5dkxTTlpXYy9zSW4vdldTQUhVOXN0ckVYam9iWHo4ZjJHWlVVQXJxOTRUVU5FSUtMUXZ1REFsRVJEUFBVWHVjb1VmRFdYdnFBU0RHSjc0QXgwRUcrRVhNd0RxNGp4cnZXTUlUWjY2bVVWQmVIQlVMYW5nNnJ5Ky9kUlY1TjNFeXl2TFNOWldjL3NJbi92V1NBSFU5dGhHRVJ2ZlBGTHdOUkRWWmF6UTNZNHhWWENwdjl1eG01eXdOcVgrandtd3l5dkxTTlpXYy9zSW4vdldTQUhVOW56TW9CNXpSc3RmcU1US3U4UjJvbEhNSWNFR2VWTi9qTGtJY3A1ZGF0ZWxkdkdoS3JMSWp5YTExeUJwMkxNdHpQOWFJN1FodGpwUFhJUUwzWFBXNys2elJFb2toUHZkUmNKSTJUWGxIQkVab2huWm1HbWlXQzdVNG8wdWtreVBBeEVhT05uSVZ3bEQ5RHBvbHUvUXVrU01OMjNrbW1sYmdTbStJeW9mNmwxRjk0cDQ2VXMvZytpdVdIQTJzZEh1RUE3bkoydnVsaUZ4WTFPMmpmWGxLdzZXeWtTZnlhRWF1TzMvWEluWmJoOWc4OUhjaWU4eUZpQ2tqcE5KUWpMUTc1NEE1TVZIUXJBOExKbzRjZEZ5VVRwenRScVpWZnhodEM2Y3llSTRXQVlmL0VoY01INlZ0K2VLeUt2b3cyYUljN2FFcDhuYWNscHEzQ21lSmVwRWk3ajF6UitWRkU2OVF5YlVzZGI1T2dsQ3p6clZQWnJKaHY4dDQ1SmFJTHFJbHpYWHZoUmp4THFkRnFZRzYwcWszcEVQeS8rTC9VRElydlFLaTVENGdvWEZQTzl5NWNnU3VDdlVQOCs2QVdhRTVZUkdqemxFOGV1OUV6bkdKUW9NSGQ3NFMzbFZ4VStXUVMwZGdJRjBvZHJKUE85eTVjZ1N1Q3ZVUDgrNkFXYUU1VDQrUGRTQWdCTzJjSGZ1ZGw2S3lLSlI2d1B3UEZwOHBndmIydmFnVWMwVmxhM0F0NEtqQjlISmlhbkJSb216Y1RDSUJ4U1VEREVwVjF0aHBJTW1vVEZjSmk5R2t1RGZZVDJQbkx0Q3dpcERDOUE1d1MxY2hCV29FMGYyZ3hrcmRxZksydkcvL2JabzNVSkVhNnhBSW02RWUrZ1VUTmp1VkJBV0VyUFNRQnNIbk81MjlmRVR6YUdvcmNoYmJkRHpWbUdXeEJtU0JtODdqVnVoeG9jWUdER2M3bmIxOFJQTm9haXR5RnR0MFBOV2tSSVgrQlRKWU5GKzVkVjFVeEtMbTRXUWJkbVhZWWg4MlVQN05ON3BTUURPbERMN0R2enpzT1FuSysvYkNjNG51ckhVMHhEZGV1Vm1xNS9XRFQxdWhEenZjdVhJRXJncjFEL1B1Z0ZtaE9XRzk1U1dXRk9LdktueXJwSlVLVVBtN0djRzVRby9wMFB5SkFOaEovaGNLU2xabTlLUVdtKzBMVWhER1Z6V1Fac3k5UkM5SGZna3ZSVDZtbHZITHVLWVZGYXE5SGVtUnR2V2VsVmFDOXpoQVpvZVVLbmE1cDJJQXdjdHloNElSblVuMTlRUnhJZGErVHgrbktmRDRHUmdCWnhLUGFtQjZpcE02L05ub05MbGJ5cklFQkgvSHFYTUtCL0FLUlZ6bHhXbnlyQkZNM2tWQzdSemdZN3RTVkJxY0VSTUdzZ1JURUpnOHJUTk44U0ZXSCtRdTFYc0xjMDVUYTNXQ2JucFZaMXh6cWc1RktNc0IzNzdmK0xNOW9tQm9sRDBKMnBRQVRORjZQWWIvSG9DSU9PNmY0V2FwT2pZQ3d5UnF2Z1dkcjV2elcyMVNuVGREM2hZMitvU2pUb1dqL0RNYVNGeFZjWjdNb1dsMm9uOEd0R1F6R3REQUo1K1QzaGdNY2NvYzc4eFZTazRkc1lpZ3dla0cwU1hKWkk2TTN2TnJESVo4ci9aVStlV1BwdmFnZXV3aDVsSkFHejdlMmFTMlFrblZvM2ZyNzNqd2c4TlAxSXNPQjE5LytpYTA1b0pRL0FQdDdFMmFObHYwenpXNjNsQzFtQ0lia2xSYW1KcVpxYXljWUZvcUErNks2eTJheXhCdWhmdzYyMG9wY0UyeDE2OFFORE5OTGUrcVhqTWFEYW16Ym9tUE9nK2tuUEVKRW9adHVGam1Qem1yZ2pOR0NOdDNYK0ErTUdCS1Q3REZWRXU2bXpHYVFpQ2F1aDNRM0VKK1pnUG40TjJJNzZtSkZORXliWVJHampaeUZjSlEvUTZhSmJ2MExwRTR1SDlLckVxLzhjOVBsSzE4VHRUODVncDNNQ1ZkT1l6SndRSDR2ZDkrTUYrMGt5Zmd3djJZa1NGaE5mS1hxTzRmVTVzUlE2Rk5MMEE1VmdYamlUa2p5NE1DdGFDa2krZUlDRFgrVkNCTTY1VjlxZHFHei9MU0puRnhJdlE4a0J4XFxcIilcIn1dLFwicGFyYW1zXCI6XCJ7XFxcInBhdGhcXFwiOlxcXCI2NDhmOTJlNTU5ZjZjOTA4MzY2NDQxYzNhNGRmZmZhYzg5ZmZkYTExXFxcIn1cIixcInNhdmVkXCI6ZmFsc2UsXCJ0aXRsZVwiOlwi6Zi/6YeM5LqR55uYXCIsXCJ2ZXJzaW9uXCI6MCxcInVybFwiOlwiaGlrZXI6Ly9wYWdlL3NoYXJlP3BhZ2U9ZnlwYWdlJnNoYXJlX3VybD1odHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vcy9wTnRzR2pUaW5zZi9mb2xkZXIvNjQ4ZjkyZTU1OWY2YzkwODM2NjQ0MWMzYTRkZmZmYWM4OWZmZGExMVwiLFwiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcImZpbmRfcnVsZVwiOlwianM6XFxudmFyIGQgPSBbXTtcXG5cXG4kLmV4dGVuZCh7XFxuICAgIHRleHQ6IFtcXFwiaHRtXFxcIiwgXFxcImh0bWxcXFwiLCBcXFwieG1sXFxcIiwgXFxcImphdmFcXFwiLCBcXFwicHJvcGVydGllc1xcXCIsIFxcXCJzcWxcXFwiLCBcXFwianNcXFwiLCBcXFwibWRcXFwiLCBcXFwianNvblxcXCIsIFxcXCJjb25mXFxcIiwgXFxcImluaVxcXCIsIFxcXCJ2dWVcXFwiLCBcXFwicGhwXFxcIiwgXFxcInB5XFxcIiwgXFxcImJhdFxcXCIsIFxcXCJnaXRpZ25vcmVcXFwiLCBcXFwieW1sXFxcIiwgXFxcImdvXFxcIiwgXFxcInNoXFxcIiwgXFxcImNcXFwiLCBcXFwiY3BwXFxcIiwgXFxcImhcXFwiLCBcXFwiaHBwXFxcIiwgXFxcInRzeFxcXCJdLFxcbiAgICBhdWRpbzogW1xcXCJtcDNcXFwiLCBcXFwiZmxhY1xcXCIsIFxcXCJvZ2dcXFwiLCBcXFwibTRhXFxcIiwgXFxcIndhdlxcXCIsIFxcXCJvcHVzXFxcIl0sXFxuICAgIG1vdmllOiBbXFxcIm1wNFxcXCIsIFxcXCJta3ZcXFwiLCBcXFwiYXZpXFxcIiwgXFxcIm1vdlxcXCIsIFxcXCJybXZiXFxcIiwgXFxcIndlYm1cXFwiLCBcXFwiZmx2XFxcIiwgXFxcIm00dlxcXCIsIFxcXCJtM3U4XFxcIiwgXFxcInRzXFxcIl0sXFxuICAgIGltZzogW1xcXCJqcGdcXFwiLCBcXFwicG5nXFxcIiwgXFxcImpwZWdcXFwiLCBcXFwiZ2lmXFxcIiwgXFxcInN2Z1xcXCIsIFxcXCJyYXdcXFwiXSxcXG4gICAgc3VidGl0bGU6IFtcXFwidnR0XFxcIiwgXFxcInNydFxcXCIsIFxcXCJhc3NcXFwiXVxcbn0pXFxuXFxuZnVuY3Rpb24gZm9ybWF0RGF0ZSh0aW1lKSB7XFxuICAgIHZhciBkYXRlID0gbmV3IERhdGUodGltZSk7XFxuICAgIHZhciBZWSA9IGRhdGUuZ2V0RnVsbFllYXIoKSArICctJztcXG4gICAgdmFyIE1NID0gKGRhdGUuZ2V0TW9udGgoKSArIDEgPCAxMCA/ICcwJyArIChkYXRlLmdldE1vbnRoKCkgKyAxKSA6IGRhdGUuZ2V0TW9udGgoKSArIDEpICsgJy0nO1xcbiAgICB2YXIgREQgPSAoZGF0ZS5nZXREYXRlKCkgPCAxMCA/ICcwJyArIChkYXRlLmdldERhdGUoKSkgOiBkYXRlLmdldERhdGUoKSk7XFxuICAgIHZhciBoaCA9IChkYXRlLmdldEhvdXJzKCkgPCAxMCA/ICcwJyArIGRhdGUuZ2V0SG91cnMoKSA6IGRhdGUuZ2V0SG91cnMoKSkgKyAnOic7XFxuICAgIHZhciBtbSA9IChkYXRlLmdldE1pbnV0ZXMoKSA8IDEwID8gJzAnICsgZGF0ZS5nZXRNaW51dGVzKCkgOiBkYXRlLmdldE1pbnV0ZXMoKSkgKyAnOic7XFxuICAgIHZhciBzcyA9IChkYXRlLmdldFNlY29uZHMoKSA8IDEwID8gJzAnICsgZGF0ZS5nZXRTZWNvbmRzKCkgOiBkYXRlLmdldFNlY29uZHMoKSk7XFxuICAgIHJldHVybiBZWSArIE1NICsgREQgKyBcXFwiIFxcXCIgKyBoaCArIG1tICsgc3M7XFxufVxcbmlmIChnZXRQYXJhbShcXFwic2hhcmVfdXJsXFxcIikuc3RhcnRzV2l0aChcXFwiaHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tL3MvXFxcIikpIHtcXG4gICAgdmFyIHNoYXJlVXJsID0gZ2V0UGFyYW0oXFxcInNoYXJlX3VybFxcXCIpXFxuICAgIHZhciBzaGFyZV9pZCA9IHNoYXJlVXJsLnNwbGl0KCdjb20vcy8nKVsxXS5zcGxpdChcXFwiL1xcXCIpWzBdXFxuICAgIGlmIChnZXRJdGVtKHNoYXJlX2lkLCBcXFwiXFxcIikgIT0gXFxcIlxcXCIpIHtcXG4gICAgICAgIHZhciBwYXNzd29yZCA9IGdldEl0ZW0oc2hhcmVfaWQpXFxuICAgIH0gZWxzZSBpZiAoZ2V0UGFyYW0oXFxcInBhc3N3b3JkXFxcIikpIHtcXG4gICAgICAgIHZhciBwYXNzd29yZCA9IGdldFBhcmFtKFxcXCJwYXNzd29yZFxcXCIpXFxuICAgIH0gZWxzZSB7XFxuICAgICAgICB2YXIgcGFzc3dvcmQgPSBcXFwiXFxcIlxcbiAgICB9XFxuICAgIHZhciByZXMgPSBKU09OLnBhcnNlKHBvc3QoXFxcImh0dHBzOi8vYXBpLmFsaXl1bmRyaXZlLmNvbS9hZHJpdmUvdjMvc2hhcmVfbGluay9nZXRfc2hhcmVfYnlfYW5vbnltb3VzP3NoYXJlX2lkPVxcXCIgKyBzaGFyZV9pZCwge1xcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xcbiAgICAgICAgICAgIFxcXCJzaGFyZV9pZFxcXCI6IHNoYXJlX2lkXFxuICAgICAgICB9KVxcbiAgICB9KSlcXG4gICAgdmFyIHNhID0gSlNPTi5wYXJzZShwb3N0KFxcXCJodHRwczovL2FwaS5hbGl5dW5kcml2ZS5jb20vdjIvc2hhcmVfbGluay9nZXRfc2hhcmVfdG9rZW5cXFwiLCB7XFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XFxuICAgICAgICAgICAgXFxcInNoYXJlX3B3ZFxcXCI6IHBhc3N3b3JkLFxcbiAgICAgICAgICAgIFxcXCJzaGFyZV9pZFxcXCI6IHNoYXJlX2lkXFxuICAgICAgICB9KVxcbiAgICB9KSlcXG4gICAgaWYgKHNhLnNoYXJlX3Rva2VuKSB7XFxuICAgICAgICB2YXIgcyA9IHNhLnNoYXJlX3Rva2VuXFxuICAgICAgICBzZXRQYWdlVGl0bGUocmVzLnNoYXJlX25hbWUpXFxuICAgICAgICB2YXIgcGF0aCA9IE1ZX1BBUkFNUy5wYXRoIHx8IFxcXCJyb290XFxcIlxcbiAgICAgICAgaWYgKE1ZX1BBR0UgPT0gMSkge1xcbiAgICAgICAgICAgIGQudW5zaGlmdCh7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiByZXMuY3JlYXRvcl9uYW1lLFxcbiAgICAgICAgICAgICAgICBpbWc6IHJlcy5hdmF0YXIsXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwiYXZhdGFyXFxcIlxcbiAgICAgICAgICAgIH0sIHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLigJzigJzigJ3igJ08c21hbGw+XFxcIiArIGZvcm1hdERhdGUoRGF0ZS5wYXJzZShyZXMudXBkYXRlZF9hdCkpICsgXFxcIjwvc21hbGw+XFxcIixcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiXFxuICAgICAgICAgICAgfSwge1xcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcIuS/neWtmOWIsOaIkeeahOe9keebmFxcXCIsXFxuICAgICAgICAgICAgICAgIHVybDogYHNtYXJ0ZHJpdmU6Ly9zaGFyZS9icm93c2U/c2hhcmVJZD0ke3NoYXJlX2lkfSZzaGFyZVB3ZD0ke3Bhc3N3b3JkfWAsXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF9jZW50ZXJfMVxcXCJcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwi5YiH5o2i5qC35byPXFxcIixcXG4gICAgICAgICAgICAgICAgdXJsOiAkKFtcXFwibW92aWVfMV9sZWZ0X3BpY1xcXCIsIFxcXCJjYXJkX3BpY18zXFxcIiwgXFxcImF2YXRhclxcXCJdKS5zZWxlY3QoKCkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgc2V0SXRlbShcXFwic3R5bGVcXFwiLCBpbnB1dClcXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKClcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/lt7LliIfmjaJcXFwiXFxuICAgICAgICAgICAgICAgIH0pLFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfMlxcXCJcXG4gICAgICAgICAgICB9LCB7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwi5o6S5bqP77yaXFxcIiArIChnZXRNeVZhcihcXFwib3JkZXJcXFwiLCBcXFwibmFtZVxcXCIpID09IFxcXCJuYW1lXFxcIiA/IFxcXCLlkI3np7BcXFwiIDogXFxcIuaXtumXtFxcXCIpLFxcbiAgICAgICAgICAgICAgICB1cmw6ICQoXFxcIiNub1JlY29yZEhpc3RvcnkjI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZSgoKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IGdldE15VmFyKFxcXCJvcmRlclxcXCIsIFxcXCJuYW1lXFxcIilcXG4gICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXCJvcmRlclxcXCIsIChvID09IFxcXCJuYW1lXFxcIiA/IFxcXCJ1cGRhdGVkX2F0XFxcIiA6IFxcXCJuYW1lXFxcIikpXFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5YiH5o2i5oiQ5YqfXFxcIlxcbiAgICAgICAgICAgICAgICB9KSxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzJcXFwiXFxuICAgICAgICAgICAgfSwge1xcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcImJsYW5rX2Jsb2NrXFxcIlxcbiAgICAgICAgICAgIH0pXFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIgZmlsZXMgPSAkLnJlcXVpcmUoXFxcImFwaVxcXCIpLnNoYXJlZ2V0ZmlsZXMoc2hhcmVfaWQsIHBhdGgsIHMpXFxuICAgICAgICBpZiAoZmlsZXMpIHtcXG4gICAgICAgICAgICBwdXRNeVZhcihwYXRoICsgXFxcIm1hcmtlclxcXCIsIGZpbGVzLm5leHRfbWFya2VyKVxcbiAgICAgICAgICAgIGxpc3QgPSBmaWxlcy5pdGVtc1xcbiAgICAgICAgICAgIGxpc3QuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xcbiAgICAgICAgICAgICAgICBsZXQgZmlsZU5hbWUgPSBpdGVtLm5hbWVcXG4gICAgICAgICAgICAgICAgbGV0IGxlbiA9IDQwO1xcbiAgICAgICAgICAgICAgICBsZXQgbGVuMiA9IGxlbiAvIDI7XFxuICAgICAgICAgICAgICAgIGlmIChmaWxlTmFtZS5sZW5ndGggPj0gbGVuKSB7XFxuICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZSA9IGZpbGVOYW1lLnN1YnN0cigwLCBsZW4yKSArICcuLi4nICsgZmlsZU5hbWUuc3Vic3RyKGZpbGVOYW1lLmxlbmd0aCAtIGxlbjIpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogZmlsZU5hbWUsXFxuICAgICAgICAgICAgICAgICAgICBkZXNjOiBmb3JtYXREYXRlKERhdGUucGFyc2UoaXRlbS51cGRhdGVkX2F0KSksXFxuICAgICAgICAgICAgICAgICAgICBpbWc6IChpdGVtLnRodW1ibmFpbCA/IGl0ZW0udGh1bWJuYWlsIDogKGl0ZW0udHlwZSA9PSBcXFwiZm9sZGVyXFxcIiA/IFxcXCJodHRwczovL2dpdGNvZGUubmV0L3FxXzMyMzk0MzUxL2RyLy0vcmF3L21hc3Rlci9pbWcv5paH5Lu257G75Z6LMi/mlofku7blpLkuc3ZnXFxcIiA6ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL2FwaVxcXCIpLmdldEljb24oaXRlbS5uYW1lKSkpLFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiAoaXRlbS50eXBlID09IFxcXCJmb2xkZXJcXFwiID8gXFxcImhpa2VyOi8vcGFnZS9zaGFyZT9wYWdlPWZ5cGFnZSZzaGFyZV91cmw9XFxcIiArIGdldFBhcmFtKFxcXCJzaGFyZV91cmxcXFwiKSA6ICQoKS5sYXp5UnVsZSgoc2hhcmVfaWQsIGlkLCBuYW1lLCBzKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL2FwaVxcXCIpLnNoYXJlY2h1bGkoc2hhcmVfaWQsIGlkLCBuYW1lLCBzKVxcbiAgICAgICAgICAgICAgICAgICAgfSwgc2hhcmVfaWQsIGl0ZW0uZmlsZV9pZCwgaXRlbS5uYW1lLCBzKSksXFxuICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogZ2V0SXRlbShcXFwic3R5bGVcXFwiLCBcXFwibW92aWVfM1xcXCIpLFxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBpdGVtLmZpbGVfaWRcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgfVxcbiAgICB9IGVsc2UgaWYgKHNhLmNvZGUgPT0gXFxcIlNoYXJlTGluay5DYW5jZWxsZWRcXFwiKSB7XFxuICAgICAgICBzZXRSZXN1bHQoW3tcXG4gICAgICAgICAgICB0aXRsZTogXFxcIuadpeaZmuS6hu+8jOWIhuS6q+iiq+WPlua2iOS6huCyoF/gsqBcXFwiLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF9jZW50ZXJfMVxcXCJcXG4gICAgICAgIH1dKVxcbiAgICB9IGVsc2UgaWYgKHNhLmNvZGUgPT0gXFxcIlNoYXJlTGluay5Gb3JiaWRkZW5cXFwiKSB7XFxuICAgICAgICBzZXRSZXN1bHQoW3tcXG4gICAgICAgICAgICB0aXRsZTogXFxcIuadpeaZmuS6hu+8jOWIhuS6q+iiq+WwgeemgeS6huCyoF/gsqBcXFwiLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF9jZW50ZXJfMVxcXCJcXG4gICAgICAgIH1dKVxcbiAgICB9IGVsc2UgaWYgKHNhLmNvZGUgPT0gXFxcIlNoYXJlTGluay5FeHBpcmVkXFxcIikge1xcbiAgICAgICAgc2V0UmVzdWx0KFt7XFxuICAgICAgICAgICAgdGl0bGU6IFxcXCLmnaXmmZrkuobvvIzliIbkuqvov4fmnJ/kuobgsqBf4LKgXFxcIixcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfY2VudGVyXzFcXFwiXFxuICAgICAgICB9XSlcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHNldFJlc3VsdChbe1xcbiAgICAgICAgICAgIHRpdGxlOiBcXFwi6K+36L6T5YWl5o+Q5Y+W56CBXFxcIixcXG4gICAgICAgICAgICB1cmw6ICQoXFxcIlxcXCIpLmlucHV0KChzaGFyZV9pZCkgPT4ge1xcbiAgICAgICAgICAgICAgICBzZXRJdGVtKHNoYXJlX2lkLCBpbnB1dClcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKVxcbiAgICAgICAgICAgIH0sIHNoYXJlX2lkKSxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfY2VudGVyXzFcXFwiXFxuICAgICAgICB9XSlcXG4gICAgfVxcbn1cXG5zZXRSZXN1bHQoZCk7XCIsXCJncm91cFwiOlwi6KeG6aKRXCIsXCJ1YVwiOlwibW9iaWxlXCIsXCJwcmVSdWxlXCI6XCIkLmV4dGVuZCh7XFxuICAgIHRleHQ6IFtcXFwiaHRtXFxcIiwgXFxcImh0bWxcXFwiLCBcXFwieG1sXFxcIiwgXFxcImphdmFcXFwiLCBcXFwicHJvcGVydGllc1xcXCIsIFxcXCJzcWxcXFwiLCBcXFwianNcXFwiLCBcXFwibWRcXFwiLCBcXFwianNvblxcXCIsIFxcXCJjb25mXFxcIiwgXFxcImluaVxcXCIsIFxcXCJ2dWVcXFwiLCBcXFwicGhwXFxcIiwgXFxcInB5XFxcIiwgXFxcImJhdFxcXCIsIFxcXCJnaXRpZ25vcmVcXFwiLCBcXFwieW1sXFxcIiwgXFxcImdvXFxcIiwgXFxcInNoXFxcIiwgXFxcImNcXFwiLCBcXFwiY3BwXFxcIiwgXFxcImhcXFwiLCBcXFwiaHBwXFxcIiwgXFxcInRzeFxcXCJdLFxcbiAgICBhdWRpbzogW1xcXCJtcDNcXFwiLCBcXFwiZmxhY1xcXCIsIFxcXCJvZ2dcXFwiLCBcXFwibTRhXFxcIiwgXFxcIndhdlxcXCIsIFxcXCJvcHVzXFxcIl0sXFxuICAgIG1vdmllOiBbXFxcIm1wNFxcXCIsIFxcXCJta3ZcXFwiLCBcXFwiYXZpXFxcIiwgXFxcIm1vdlxcXCIsIFxcXCJybXZiXFxcIiwgXFxcIndlYm1cXFwiLCBcXFwiZmx2XFxcIiwgXFxcIm00dlxcXCIsIFxcXCJtM3U4XFxcIiwgXFxcInRzXFxcIl0sXFxuICAgIGltZzogW1xcXCJqcGdcXFwiLCBcXFwicG5nXFxcIiwgXFxcImpwZWdcXFwiLCBcXFwiZ2lmXFxcIiwgXFxcInN2Z1xcXCIsIFxcXCJyYXdcXFwiXSxcXG4gICAgc3VidGl0bGU6IFtcXFwidnR0XFxcIiwgXFxcInNydFxcXCIsIFxcXCJhc3NcXFwiXVxcbn0pXCIsXCJwYWdlc1wiOlwiW3tcXFwiY29sX3R5cGVcXFwiOlxcXCJ0ZXh0XzFcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5Li76aG1XFxcIixcXFwicGF0aFxcXCI6XFxcImhvbWVcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG52YXIgZCA9IFtdO1xcXFxuaWYgKCFmaWxlRXhpc3QoXFxcXFxcXCJoaWtlcjovL2ZpbGVzL3J1bGVzL0pvZS9hbGkuanNvblxcXFxcXFwiKSkge1xcXFxuICAgIGQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiBcXFxcXFxcIueZu+mZhuS7peW8gOWQr1xcXFxcXFwiLFxcXFxuICAgICAgICB1cmw6IFxcXFxcXFwiaGlrZXI6Ly9wYWdlL2xvZ2luXFxcXFxcXCIsXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfY2VudGVyXzFcXFxcXFxcIlxcXFxuICAgIH0pXFxcXG59IGVsc2Uge1xcXFxuICAgIGZ1bmN0aW9uIGZvcm1hdERhdGUodGltZSkge1xcXFxuICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHRpbWUpO1xcXFxuICAgICAgICB2YXIgWVkgPSBkYXRlLmdldEZ1bGxZZWFyKCkgKyAnLSc7XFxcXG4gICAgICAgIHZhciBNTSA9IChkYXRlLmdldE1vbnRoKCkgKyAxIDwgMTAgPyAnMCcgKyAoZGF0ZS5nZXRNb250aCgpICsgMSkgOiBkYXRlLmdldE1vbnRoKCkgKyAxKSArICctJztcXFxcbiAgICAgICAgdmFyIEREID0gKGRhdGUuZ2V0RGF0ZSgpIDwgMTAgPyAnMCcgKyAoZGF0ZS5nZXREYXRlKCkpIDogZGF0ZS5nZXREYXRlKCkpO1xcXFxuICAgICAgICB2YXIgaGggPSAoZGF0ZS5nZXRIb3VycygpIDwgMTAgPyAnMCcgKyBkYXRlLmdldEhvdXJzKCkgOiBkYXRlLmdldEhvdXJzKCkpICsgJzonO1xcXFxuICAgICAgICB2YXIgbW0gPSAoZGF0ZS5nZXRNaW51dGVzKCkgPCAxMCA/ICcwJyArIGRhdGUuZ2V0TWludXRlcygpIDogZGF0ZS5nZXRNaW51dGVzKCkpICsgJzonO1xcXFxuICAgICAgICB2YXIgc3MgPSAoZGF0ZS5nZXRTZWNvbmRzKCkgPCAxMCA/ICcwJyArIGRhdGUuZ2V0U2Vjb25kcygpIDogZGF0ZS5nZXRTZWNvbmRzKCkpO1xcXFxuICAgICAgICByZXR1cm4gWVkgKyBNTSArIEREICsgXFxcXFxcXCIgXFxcXFxcXCIgKyBoaCArIG1tICsgc3M7XFxcXG4gICAgfVxcXFxuXFxcXG4gICAgaWYgKE1ZX1BBR0UgPT0gMSkge1xcXFxuICAgICAgICBsZXQgY29uZmlnID0gSlNPTi5wYXJzZShmZXRjaChcXFxcXFxcImhpa2VyOi8vZmlsZXMvcnVsZXMvSm9lL2FsaS5qc29uXFxcXFxcXCIpKVxcXFxuICAgICAgICBpZihuZXcgRGF0ZSgpLmdldFRpbWUoKT49Y29uZmlnLnRpbWVfZXhwaXJlKXtcXFxcbiAgICAgICAgICAgICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9hcGlcXFxcXFxcIikucmVmcmVzaFRva2VuKCk7XFxcXG4gICAgICAgICAgICBsb2coJ+WIt+aWsHRva2VuJyk7XFxcXG4gICAgICAgICAgICBjb25maWcgPSBKU09OLnBhcnNlKGZldGNoKFxcXFxcXFwiaGlrZXI6Ly9maWxlcy9ydWxlcy9Kb2UvYWxpLmpzb25cXFxcXFxcIikpXFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgZC51bnNoaWZ0KHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiBjb25maWcubmlja19uYW1lLFxcXFxuICAgICAgICAgICAgaW1nOiBjb25maWcuYXZhdGFyLFxcXFxuICAgICAgICAgICAgdXJsOiAkKFxcXFxcXFwi56Gu6K6k6YCA5Ye655m76ZmG77yfXFxcXFxcXCIpLmNvbmZpcm0oKCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIGRlbGV0ZUZpbGUoXFxcXFxcXCJoaWtlcjovL2ZpbGVzL3J1bGVzL0pvZS9hbGkuanNvblxcXFxcXFwiKVxcXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKClcXFxcbiAgICAgICAgICAgIH0pLFxcXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiYXZhdGFyXFxcXFxcXCJcXFxcbiAgICAgICAgfSwge1xcXFxuICAgICAgICAgICAgZGVzYzogXFxcXFxcXCLmkJzntKLmiJHnmoTmlofku7bmiJbovpPlhaXliIbkuqvpk77mjqVcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImlucHV0XFxcXFxcXCIsXFxcXG4gICAgICAgICAgICB1cmw6IFxcXFxcXFwiJ2hpa2VyOi8vcGFnZS9zZWFyY2g/a3c9JytpbnB1dCsnJnA9ZnlwYWdlI25vUmVmcmVzaCMnXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgIHRpdGxlVmlzaWJsZTogZmFsc2UsXFxcXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6IFxcXFxcXFwicHV0TXlWYXIoJ2t3JyxpbnB1dClcXFxcXFxcIlxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9KVxcXFxuICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi5YiH5o2i5qC35byPXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICB1cmw6ICQoW1xcXFxcXFwibW92aWVfMV9sZWZ0X3BpY1xcXFxcXFwiLCBcXFxcXFxcImNhcmRfcGljXzNcXFxcXFxcIiwgXFxcXFxcXCJhdmF0YXJcXFxcXFxcIl0pLnNlbGVjdCgoKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgc2V0SXRlbShcXFxcXFxcInN0eWxlXFxcXFxcXCIsIGlucHV0KVxcXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKClcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+W3suWIh+aNolxcXFxcXFwiXFxcXG4gICAgICAgICAgICB9KSxcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMlxcXFxcXFwiXFxcXG4gICAgICAgIH0sIHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuaOkuW6jzpcXFxcXFxcIiArIChnZXRNeVZhcihcXFxcXFxcIm9yZGVyXFxcXFxcXCIsIFxcXFxcXFwibmFtZVxcXFxcXFwiKSA9PSBcXFxcXFxcIm5hbWVcXFxcXFxcIiA/IFxcXFxcXFwi5ZCN56ewXFxcXFxcXCIgOiBcXFxcXFxcIuaXtumXtFxcXFxcXFwiKSxcXFxcbiAgICAgICAgICAgIHVybDogJChcXFxcXFxcIiNub1JlY29yZEhpc3RvcnkjI25vTG9hZGluZyNcXFxcXFxcIikubGF6eVJ1bGUoKCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIHZhciBvID0gZ2V0TXlWYXIoXFxcXFxcXCJvcmRlclxcXFxcXFwiLCBcXFxcXFxcIm5hbWVcXFxcXFxcIilcXFxcbiAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFxcXFxcIm9yZGVyXFxcXFxcXCIsIChvID09IFxcXFxcXFwibmFtZVxcXFxcXFwiID8gXFxcXFxcXCJ1cGRhdGVkX2F0XFxcXFxcXCIgOiBcXFxcXFxcIm5hbWVcXFxcXFxcIikpXFxcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKVxcXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5YiH5o2i5oiQ5YqfXFxcXFxcXCJcXFxcbiAgICAgICAgICAgIH0pLFxcXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF8yXFxcXFxcXCJcXFxcbiAgICAgICAgfSwge1xcXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiYmxhbmtfYmxvY2tcXFxcXFxcIlxcXFxuICAgICAgICB9KVxcXFxuICAgIH1cXFxcblxcXFxuICAgIHZhciBwYXRoID0gTVlfUEFSQU1TLnBhdGggfHwgXFxcXFxcXCJyb290XFxcXFxcXCJcXFxcbiAgICBcXFxcbiAgICBcXFxcbiAgICB2YXIgZmlsZXM9JC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL2FwaVxcXFxcXFwiKS5nZXRGaWxlcyhwYXRoKVxcXFxuICAgIFxcXFxuICAgIGlmIChmaWxlcy5pdGVtcyE9dW5kZWZpbmVkKSB7XFxcXG4gICAgICAgIHB1dE15VmFyKHBhdGggKyBcXFxcXFxcIm1hcmtlclxcXFxcXFwiLCBmaWxlcy5uZXh0X21hcmtlcilcXFxcbiAgICAgICAgdmFyIGxpc3QgPSBmaWxlcy5pdGVtc1xcXFxuICAgICAgICBsaXN0LmZvckVhY2goKGl0ZW0sIGkpID0+IHtcXFxcbiAgICAgICAgICAgIGxldCBmaWxlTmFtZSA9IGl0ZW0ubmFtZVxcXFxuICAgICAgICAgICAgbGV0IGxlbiA9IDQwO1xcXFxuICAgICAgICAgICAgbGV0IGxlbjIgPSBsZW4gLyAyO1xcXFxuICAgICAgICAgICAgaWYgKGZpbGVOYW1lLmxlbmd0aCA+PSBsZW4pIHtcXFxcbiAgICAgICAgICAgICAgICBmaWxlTmFtZSA9IGZpbGVOYW1lLnN1YnN0cigwLCBsZW4yKSArICcuLi4nICsgZmlsZU5hbWUuc3Vic3RyKGZpbGVOYW1lLmxlbmd0aCAtIGxlbjIpO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogZmlsZU5hbWUsXFxcXG4gICAgICAgICAgICAgICAgaW1nOiAoaXRlbS50aHVtYm5haWwgPyBpdGVtLnRodW1ibmFpbCA6IChpdGVtLnR5cGUgPT0gXFxcXFxcXCJmb2xkZXJcXFxcXFxcIiA/IFxcXFxcXFwiaHR0cHM6Ly9naXRjb2RlLm5ldC9xcV8zMjM5NDM1MS9kci8tL3Jhdy9tYXN0ZXIvaW1nL+aWh+S7tuexu+WeizIv5paH5Lu25aS5LnN2Z1xcXFxcXFwiIDogJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL2FwaVxcXFxcXFwiKS5nZXRJY29uKGl0ZW0ubmFtZSkpKSxcXFxcbiAgICAgICAgICAgICAgICB1cmw6IChpdGVtLnR5cGUgPT0gXFxcXFxcXCJmb2xkZXJcXFxcXFxcIiA/IFxcXFxcXFwiaGlrZXI6Ly9wYWdlL2hvbWU/cGFnZT1meXBhZ2VcXFxcXFxcIiA6ICQoKS5sYXp5UnVsZSgoaWQsIG5hbWUsIHVybCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL2FwaVxcXFxcXFwiKS5jaHVsaShpZCwgbmFtZSwgdXJsKVxcXFxuICAgICAgICAgICAgICAgIH0sIGl0ZW0uZmlsZV9pZCwgaXRlbS5uYW1lLCBpdGVtLnVybCkpLFxcXFxuICAgICAgICAgICAgICAgIGRlc2M6IGZvcm1hdERhdGUoRGF0ZS5wYXJzZShpdGVtLnVwZGF0ZWRfYXQpKSxcXFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogZ2V0SXRlbShcXFxcXFxcInN0eWxlXFxcXFxcXCIsIFxcXFxcXFwibW92aWVfM1xcXFxcXFwiKSxcXFxcbiAgICAgICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBpdGVtLmZpbGVfaWRcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9KVxcXFxuICAgICAgICB9KVxcXFxuICAgIH1lbHNle1xcXFxuICAgICAgICBpZihmaWxlcz09ZmFsc2Upe1xcXFxuICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgdGl0bGU6J+KAnOKAnOKAneKAnTxzbWFsbD48Zm9udCBjb2xvcj1cXFxcXFxcImdyZXlcXFxcXFxcIj7liKvliJLkuobliLDlupXkuoY8L2ZvbnQ+PC9zbWFsbD4nLFxcXFxuICAgICAgICAgICAgY29sX3R5cGU6J3RleHRfY2VudGVyXzEnLFxcXFxuICAgICAgICAgICAgdXJsOidoaWtlcjovL2VtcHR5JywgICAgICAgICAgICBcXFxcbiAgICAgICAgICB9KVxcXFxuICAgICAgICB9ZWxzZXtcXFxcbiAgICAgICAgICAgICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9hcGlcXFxcXFxcIikucmVmcmVzaFRva2VuKCk7XFxcXG4gICAgICAgICAgICBsb2coJ+WIt+aWsHRva2VuJyk7XFxcXG4gICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZTon4oCc4oCc4oCd4oCdPHNtYWxsPjxmb250IGNvbG9yPVxcXFxcXFwiZ3JleVxcXFxcXFwiPuiOt+WPluWksei0peivt+mHjeivlTwvZm9udD48L3NtYWxsPicsXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTondGV4dF9jZW50ZXJfMScsXFxcXG4gICAgICAgICAgICB1cmw6J2hpa2VyOi8vZW1wdHknLCAgICAgICAgICAgIFxcXFxuICAgICAgICAgIH0pXFxcXG4gICAgICAgIH1cXFxcbiAgICB9XFxcXG59XFxcXG5zZXRSZXN1bHQoZCk7XFxcXG5cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLnmbvpmYZcXFwiLFxcXCJwYXRoXFxcIjpcXFwibG9naW5cXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG52YXIgZCA9IFtdO1xcXFxubGV0IHVybCA9ICdodHRwczovL2F1dGguYWxpeXVuZHJpdmUuY29tL3YyL29hdXRoL2F1dGhvcml6ZT9sb2dpbl90eXBlPWN1c3RvbSZyZXNwb25zZV90eXBlPWNvZGUmcmVkaXJlY3RfdXJpPWh0dHBzJTNBJTJGJTJGd3d3LmFsaXl1bmRyaXZlLmNvbSUyRnNpZ24lMkZjYWxsYmFjayZjbGllbnRfaWQ9MjVkelgzdmJZcWt0Vnh5WCZzdGF0ZT0lN0IlMjJvcmlnaW4lMjIlM0ElMjIqJTIyJTdEIy9sb2dpbidcXFxcbnZhciBqcyA9ICQudG9TdHJpbmcoKCkgPT4ge1xcXFxuICAgIGNvbnN0IHRva2VuRnVuY3Rpb24gPSBmdW5jdGlvbigpIHtcXFxcbiAgICAgICAgdmFyIHRva2VuID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndG9rZW4nKSlcXFxcbiAgICAgICAgaWYgKHRva2VuICYmIHRva2VuLnVzZXJfaWQpIHtcXFxcbiAgICAgICAgICAgIGxldCB0b2tlbl91cmwgPSAnaGlrZXI6Ly9maWxlcy9ydWxlcy9Kb2UvYWxpLmpzb24nO1xcXFxuICAgICAgICAgICAgZnlfYnJpZGdlX2FwcC53cml0ZUZpbGUodG9rZW5fdXJsLCBKU09OLnN0cmluZ2lmeSh0b2tlbikpXFxcXG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2UuY2xlYXIoKTtcXFxcbiAgICAgICAgICAgIGFsZXJ0KCdUT0tFTuiOt+WPluaIkOWKn++8jOivt+WLv+azhOa8j+S4quS6uumakOengSHpgIDlh7ror6XpobXpnaLlkI7liLfmlrDph43or5XvvIEnKTtcXFxcbiAgICAgICAgICAgIGZ5X2JyaWRnZV9hcHAuYmFjaygpO1xcXFxuICAgICAgICAgICAgcmV0dXJuO1xcXFxuICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgdG9rZW5fdGltZXIoKTtcXFxcbiAgICAgICAgfVxcXFxuICAgIH1cXFxcbiAgICB2YXIgdG9rZW5fdGltZXIgPSBmdW5jdGlvbigpIHtcXFxcbiAgICAgICAgc2V0VGltZW91dCh0b2tlbkZ1bmN0aW9uLCAzMDApXFxcXG4gICAgfTtcXFxcbiAgICB0b2tlbl90aW1lcigpO1xcXFxuICAgIHRva2VuRnVuY3Rpb24oKTtcXFxcbn0pXFxcXG5kLnB1c2goe1xcXFxuICAgIHVybDogdXJsLFxcXFxuICAgIGNvbF90eXBlOiAneDVfd2Vidmlld19zaW5nbGUnLFxcXFxuICAgIGRlc2M6ICcxMDAlJiZmbG9hdCcsXFxcXG4gICAgZXh0cmE6IHtcXFxcbiAgICAgICAgY2FuQmFjazogdHJ1ZSxcXFxcbiAgICAgICAganM6IGpzXFxcXG4gICAgfVxcXFxufSlcXFxcbnNldFJlc3VsdChkKTtcXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCJhcGlcXFwiLFxcXCJwYXRoXFxcIjpcXFwiYXBpXFxcIixcXFwicnVsZVxcXCI6XFxcInZhciByZWZyZXNoVG9rZW4gPSBmdW5jdGlvbigpIHtcXFxcbiAgICB2YXIgdXJsID0gXFxcXFxcXCJodHRwczovL2F1dGguYWxpeXVuZHJpdmUuY29tL3YyL2FjY291bnQvdG9rZW5cXFxcXFxcIlxcXFxuICAgIHZhciBjb25maWcgPSBKU09OLnBhcnNlKGZldGNoKFxcXFxcXFwiaGlrZXI6Ly9maWxlcy9ydWxlcy9Kb2UvYWxpLmpzb25cXFxcXFxcIikpXFxcXG4gICAgdmFyIHJlcyA9IEpTT04ucGFyc2UocG9zdCh1cmwsIHtcXFxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xcXFxuICAgICAgICAgICAgXFxcXFxcXCJyZWZyZXNoX3Rva2VuXFxcXFxcXCI6IGNvbmZpZy5yZWZyZXNoX3Rva2VuLFxcXFxuICAgICAgICAgICAgXFxcXFxcXCJncmFudF90eXBlXFxcXFxcXCI6IFxcXFxcXFwicmVmcmVzaF90b2tlblxcXFxcXFwiXFxcXG4gICAgICAgIH0pXFxcXG4gICAgfSkpXFxcXG4gICAgY29uZmlnW1xcXFxcXFwicmVmcmVzaF90b2tlblxcXFxcXFwiXSA9IHJlcy5yZWZyZXNoX3Rva2VuXFxcXG4gICAgY29uZmlnW1xcXFxcXFwiYWNjZXNzX3Rva2VuXFxcXFxcXCJdID0gcmVzLmFjY2Vzc190b2tlblxcXFxuICAgIGNvbmZpZ1tcXFxcXFxcImV4cGlyZV90aW1lXFxcXFxcXCJdID0gcmVzLmV4cGlyZV90aW1lXFxcXG4gICAgY29uZmlnW1xcXFxcXFwidGltZV9leHBpcmVcXFxcXFxcIl0gPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIDcyMDAgKiAxMDAwXFxcXG4gICAgd3JpdGVGaWxlKFxcXFxcXFwiaGlrZXI6Ly9maWxlcy9ydWxlcy9Kb2UvYWxpLmpzb25cXFxcXFxcIiwgSlNPTi5zdHJpbmdpZnkoY29uZmlnKSlcXFxcbn1cXFxcbnZhciBnZXRGaWxlcyA9IGZ1bmN0aW9uKGlkLCBkaWQpIHtcXFxcbiAgICB2YXIgdXJsID0gXFxcXFxcXCJodHRwczovL2FwaS5hbGl5dW5kcml2ZS5jb20vYWRyaXZlL3YzL2ZpbGUvbGlzdFxcXFxcXFwiXFxcXG4gICAgdmFyIGNvbmZpZyA9IEpTT04ucGFyc2UoZmV0Y2goXFxcXFxcXCJoaWtlcjovL2ZpbGVzL3J1bGVzL0pvZS9hbGkuanNvblxcXFxcXFwiKSlcXFxcbiAgICB2YXIgZGVmID0gZGlkID8gZGlkIDogY29uZmlnLmRlZmF1bHRfZHJpdmVfaWRcXFxcbiAgICAvL2xvZyhpZClcXFxcbiAgICB2YXIgZGF0YSA9IHtcXFxcbiAgICAgICAgXFxcXFxcXCJkcml2ZV9pZFxcXFxcXFwiOiBkZWYsXFxcXG4gICAgICAgIFxcXFxcXFwicGFyZW50X2ZpbGVfaWRcXFxcXFxcIjogaWQsXFxcXG4gICAgICAgIFxcXFxcXFwidG9rZW5fdHlwZVxcXFxcXFwiOiAnQmVhcmVyJyxcXFxcbiAgICAgICAgXFxcXFxcXCJsaW1pdFxcXFxcXFwiOiAxMDAsXFxcXG4gICAgICAgIFxcXFxcXFwiYWxsXFxcXFxcXCI6IHRydWUsXFxcXG4gICAgICAgIFxcXFxcXFwidXJsX2V4cGlyZV9zZWNcXFxcXFxcIjogMTYwMCxcXFxcbiAgICAgICAgXFxcXFxcXCJpbWFnZV90aHVtYm5haWxfcHJvY2Vzc1xcXFxcXFwiOiBcXFxcXFxcImltYWdlL3Jlc2l6ZSx3XzQwMC9mb3JtYXQsanBlZ1xcXFxcXFwiLFxcXFxuICAgICAgICBcXFxcXFxcImltYWdlX3VybF9wcm9jZXNzXFxcXFxcXCI6IFxcXFxcXFwiaW1hZ2UvcmVzaXplLHdfMTkyMC9mb3JtYXQsanBlZ1xcXFxcXFwiLFxcXFxuICAgICAgICBcXFxcXFxcInZpZGVvX3RodW1ibmFpbF9wcm9jZXNzXFxcXFxcXCI6IFxcXFxcXFwidmlkZW8vc25hcHNob3QsdF8xMDAwLGZfanBnLGFyX2F1dG8sd18zMDBcXFxcXFxcIixcXFxcbiAgICAgICAgXFxcXFxcXCJmaWVsZHNcXFxcXFxcIjogXFxcXFxcXCIqXFxcXFxcXCIsXFxcXG4gICAgICAgIFxcXFxcXFwib3JkZXJfYnlcXFxcXFxcIjogZ2V0TXlWYXIoXFxcXFxcXCJvcmRlclxcXFxcXFwiLCBcXFxcXFxcIm5hbWVcXFxcXFxcIiksXFxcXG4gICAgICAgIFxcXFxcXFwib3JkZXJfZGlyZWN0aW9uXFxcXFxcXCI6IFxcXFxcXFwiQVNDXFxcXFxcXCJcXFxcbiAgICB9XFxcXG4gICAgLy9sb2coZ2V0TXlWYXIoaWQgKyBcXFxcXFxcIm1hcmtlclxcXFxcXFwiKSlcXFxcbiAgICBpZiAoTVlfUEFHRSAhPSAxICYmIGdldE15VmFyKGlkICsgXFxcXFxcXCJtYXJrZXJcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIikgPT0gXFxcXFxcXCJcXFxcXFxcIikge1xcXFxuXFxcXG4gICAgICAgIHJldHVybiBmYWxzZVxcXFxuICAgIH0gZWxzZSB7XFxcXG4gICAgICAgIGRhdGEubWFya2VyID0gZ2V0TXlWYXIoaWQgKyBcXFxcXFxcIm1hcmtlclxcXFxcXFwiKSAhPSAndW5kZWZpbmVkJyA/IGdldE15VmFyKGlkICsgXFxcXFxcXCJtYXJrZXJcXFxcXFxcIikgOiAnJ1xcXFxuICAgICAgICBjbGVhck15VmFyKGlkICsgXFxcXFxcXCJtYXJrZXJcXFxcXFxcIilcXFxcbiAgICAgICAgbGV0IHJlcyA9IHBvc3QodXJsLCB7XFxcXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcXFxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICAgICBcXFxcXFxcImF1dGhvcml6YXRpb25cXFxcXFxcIjogY29uZmlnLmFjY2Vzc190b2tlblxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9KVxcXFxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShyZXMpXFxcXG4gICAgfVxcXFxufVxcXFxudmFyIGNodWxpID0gZnVuY3Rpb24oaWQsIG5hbWUsIHVybCwgZGlkKSB7XFxcXG4gICAgdmFyIGNvbmZpZyA9IEpTT04ucGFyc2UoZmV0Y2goXFxcXFxcXCJoaWtlcjovL2ZpbGVzL3J1bGVzL0pvZS9hbGkuanNvblxcXFxcXFwiKSlcXFxcbiAgICB2YXIgZGlkID0gZGlkID8gZGlkIDogY29uZmlnLmRlZmF1bHRfZHJpdmVfaWRcXFxcbiAgICBsZXQge1xcXFxuICAgICAgICBnZXRIem0sXFxcXG4gICAgICAgIHB1c2hcXFxcbiAgICB9ID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL2FwaVxcXFxcXFwiKVxcXFxuICAgIHZhciBIem0gPSBnZXRIem0obmFtZSlcXFxcbiAgICBpZiAoJC5tb3ZpZS5pbmNsdWRlcyhIem0pKSB7XFxcXG4gICAgICAgIGxldCBwdXJsID0gXFxcXFxcXCJodHRwczovL2FwaS5hbGl5dW5kcml2ZS5jb20vYWRyaXZlL3YyL2ZpbGUvZ2V0X3ZpZGVvX3ByZXZpZXdfcGxheV9pbmZvXFxcXFxcXCJcXFxcbiAgICAgICAgdmFyIHVybHMgPSBbXVxcXFxuICAgICAgICB2YXIgbmFtZXMgPSBbXFxcXFxcXCLljp/nlLtcXFxcXFxcIl1cXFxcbiAgICAgICAgdXJscy5wdXNoKHVybCArIFxcXFxcXFwiI2lzVmlkZW89dHJ1ZSNcXFxcXFxcIilcXFxcbiAgICAgICAgbGV0IHB1ID0gcG9zdChwdXJsLCB7XFxcXG4gICAgICAgICAgICBoZWFkZXJzOiB7XFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJhdXRob3JpemF0aW9uXFxcXFxcXCI6IGNvbmZpZy5hY2Nlc3NfdG9rZW5cXFxcbiAgICAgICAgICAgIH0sXFxcXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJkcml2ZV9pZFxcXFxcXFwiOiBkaWQsXFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJjYXRlZ29yeVxcXFxcXFwiOiBcXFxcXFxcImxpdmVfdHJhbnNjb2RpbmdcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICBcXFxcXFxcImZpbGVfaWRcXFxcXFxcIjogaWQsXFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJ0ZW1wbGF0ZV9pZFxcXFxcXFwiOiBcXFxcXFxcIlxcXFxcXFwiXFxcXG4gICAgICAgICAgICB9KVxcXFxuICAgICAgICB9KVxcXFxuICAgICAgICBjb25zdCB0cmFuc2NvZGluZyA9IHtcXFxcbiAgICAgICAgICAgIFVIRDogXFxcXFxcXCI0SyDotoXmuIVcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIFFIRDogXFxcXFxcXCIySyDotoXmuIVcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIEZIRDogXFxcXFxcXCIxMDgwIOWFqOmrmOa4hVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgSEQ6IFxcXFxcXFwiNzIwIOmrmOa4hVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgU0Q6IFxcXFxcXFwiNTQwIOagh+a4hVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgTEQ6IFxcXFxcXFwiMzYwIOa1geeVhVxcXFxcXFwiXFxcXG4gICAgICAgIH07XFxcXG4gICAgICAgIGxldCBhcnIxID0gSlNPTi5wYXJzZShwdSkudmlkZW9fcHJldmlld19wbGF5X2luZm8ubGl2ZV90cmFuc2NvZGluZ190YXNrX2xpc3QuZmlsdGVyKGl0ID0+IGl0LnVybCAhPSBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbiAgICAgICAgZm9yIChsZXQgayBvZiBPYmplY3Qua2V5cyh0cmFuc2NvZGluZykpIHtcXFxcbiAgICAgICAgICAgIGZvciAobGV0IGl0IG9mIGFycjEpIHtcXFxcbiAgICAgICAgICAgICAgICBpZiAoaXQudGVtcGxhdGVfaWQgPT0gaykge1xcXFxuICAgICAgICAgICAgICAgICAgICB1cmxzLnB1c2goaXQudXJsICsgXFxcXFxcXCIjaXNWaWRlbz10cnVlI1xcXFxcXFwiKVxcXFxuICAgICAgICAgICAgICAgICAgICBuYW1lcy5wdXNoKHRyYW5zY29kaW5nW2tdKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfVxcXFxuXFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcXFxcbiAgICAgICAgICAgIHVybHM6IHVybHMsXFxcXG4gICAgICAgICAgICBuYW1lczogbmFtZXMsXFxcXG4gICAgICAgICAgICBoZWFkZXJzOiBbe1xcXFxuICAgICAgICAgICAgICAgIFxcXFxcXFwiUmVmZXJlclxcXFxcXFwiOiBcXFxcXFxcImh0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS9cXFxcXFxcIlxcXFxuICAgICAgICAgICAgfV1cXFxcbiAgICAgICAgfSlcXFxcbiAgICB9IGVsc2Uge1xcXFxuICAgICAgICBsZXQgcmVzID0gcmVxdWVzdChidWlsZFVybChcXFxcXFxcImh0dHBzOi8vYXBpLmFsaXl1bmRyaXZlLmNvbS92Mi9maWxlL2Rvd25sb2FkXFxcXFxcXCIsIHtcXFxcbiAgICAgICAgICAgIFxcXFxcXFwiZHJpdmVfaWRcXFxcXFxcIjogZGlkLFxcXFxuICAgICAgICAgICAgXFxcXFxcXCJmaWxlX2lkXFxcXFxcXCI6IGlkLFxcXFxuICAgICAgICAgICAgXFxcXFxcXCJpbWFnZV90aHVtYm5haWxfcHJvY2Vzc1xcXFxcXFwiOiBcXFxcXFxcImltYWdlL3Jlc2l6ZSxtX2xmaXQsd18yNTYsbGltaXRfMC9mb3JtYXQsanBnfGltYWdlL2Zvcm1hdCx3ZWJwXFxcXFxcXCJcXFxcbiAgICAgICAgfSksIHtcXFxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICAgICBcXFxcXFxcImF1dGhvcml6YXRpb25cXFxcXFxcIjogY29uZmlnLmFjY2Vzc190b2tlblxcXFxuICAgICAgICAgICAgfSxcXFxcbiAgICAgICAgICAgIHJlZGlyZWN0OiBmYWxzZVxcXFxuICAgICAgICB9KVxcXFxuICAgICAgICB2YXIgdXJsID0gcGRmaChyZXMsIFxcXFxcXFwiYSYmaHJlZlxcXFxcXFwiKVxcXFxuICAgICAgICBpZiAoJC5pbWcuaW5jbHVkZXMoSHptKSkge1xcXFxuICAgICAgICAgICAgcmV0dXJuIHVybCArIFxcXFxcXFwiIy5qcGdcXFxcXFxcIlxcXFxuICAgICAgICB9IGVsc2UgaWYgKCQuYXVkaW8uaW5jbHVkZXMoSHptKSkge1xcXFxuICAgICAgICAgICAgcmV0dXJuIHVybCArIFxcXFxcXFwiI2lzTXVzaWM9dHJ1ZSNcXFxcXFxcIlxcXFxuICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiZG93bmxvYWQ6Ly9cXFxcXFxcIiArIHVybFxcXFxuICAgICAgICB9XFxcXG4gICAgfVxcXFxufVxcXFxuJC5leHBvcnRzLnNoYXJlZ2V0ZmlsZXMgPSBmdW5jdGlvbihpZCwgcGF0aCwgcykge1xcXFxuICAgIHZhciBkYXRhID0ge1xcXFxuICAgICAgICBcXFxcXFxcImFsbFxcXFxcXFwiOiB0cnVlLFxcXFxuICAgICAgICBcXFxcXFxcInNoYXJlX2lkXFxcXFxcXCI6IGlkLFxcXFxuICAgICAgICBcXFxcXFxcInBhcmVudF9maWxlX2lkXFxcXFxcXCI6IHBhdGgsXFxcXG4gICAgICAgIFxcXFxcXFwibGltaXRcXFxcXFxcIjogMjAwLFxcXFxuICAgICAgICBcXFxcXFxcImltYWdlX3RodW1ibmFpbF9wcm9jZXNzXFxcXFxcXCI6IFxcXFxcXFwiaW1hZ2UvcmVzaXplLHdfMTYwL2Zvcm1hdCxqcGVnXFxcXFxcXCIsXFxcXG4gICAgICAgIFxcXFxcXFwiaW1hZ2VfdXJsX3Byb2Nlc3NcXFxcXFxcIjogXFxcXFxcXCJpbWFnZS9yZXNpemUsd18xOTIwL2Zvcm1hdCxqcGVnXFxcXFxcXCIsXFxcXG4gICAgICAgIFxcXFxcXFwidmlkZW9fdGh1bWJuYWlsX3Byb2Nlc3NcXFxcXFxcIjogXFxcXFxcXCJ2aWRlby9zbmFwc2hvdCx0XzEwMDAsZl9qcGcsYXJfYXV0byx3XzMwMFxcXFxcXFwiLFxcXFxuICAgICAgICBcXFxcXFxcIm9yZGVyX2J5XFxcXFxcXCI6IGdldEl0ZW0oXFxcXFxcXCJvcmRlclxcXFxcXFwiLCBcXFxcXFxcIm5hbWVcXFxcXFxcIiksXFxcXG4gICAgICAgIFxcXFxcXFwib3JkZXJfZGlyZWN0aW9uXFxcXFxcXCI6IFxcXFxcXFwiQVNDXFxcXFxcXCJcXFxcbiAgICB9XFxcXG4gICAgaWYgKE1ZX1BBR0UgPT0gMSB8fCBnZXRNeVZhcihpZCArIFxcXFxcXFwibWFya2VyXFxcXFxcXCIsIFxcXFxcXFwiXFxcXFxcXCIpICE9IFxcXFxcXFwiXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgZGF0YS5tYXJrZXIgPSBnZXRNeVZhcihpZCArIFxcXFxcXFwibWFya2VyXFxcXFxcXCIpICE9ICd1bmRlZmluZWQnID8gZ2V0TXlWYXIoaWQgKyBcXFxcXFxcIm1hcmtlclxcXFxcXFwiKSA6ICcnXFxcXG4gICAgICAgIGNsZWFyTXlWYXIoaWQgKyBcXFxcXFxcIm1hcmtlclxcXFxcXFwiKVxcXFxuICAgICAgICB2YXIgZmlsZXMgPSBKU09OLnBhcnNlKHBvc3QoXFxcXFxcXCJodHRwczovL2FwaS5hbGl5dW5kcml2ZS5jb20vYWRyaXZlL3YzL2ZpbGUvbGlzdFxcXFxcXFwiLCB7XFxcXG4gICAgICAgICAgICBoZWFkZXJzOiB7XFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJ4LXNoYXJlLXRva2VuXFxcXFxcXCI6IHNcXFxcbiAgICAgICAgICAgIH0sXFxcXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKVxcXFxuICAgICAgICB9KSlcXFxcbiAgICAgICAgcmV0dXJuIGZpbGVzXFxcXG4gICAgfSBlbHNlIHtcXFxcbiAgICAgICAgcmV0dXJuIGZhbHNlXFxcXG4gICAgfVxcXFxufVxcXFxuJC5leHBvcnRzLnNoYXJlY2h1bGkgPSBmdW5jdGlvbihzaGFyZV9pZCwgaWQsIG5hbWUsIHMpIHtcXFxcbiAgICB2YXIgY29uZmlnID0gSlNPTi5wYXJzZShmZXRjaChcXFxcXFxcImhpa2VyOi8vZmlsZXMvcnVsZXMvSm9lL2FsaS5qc29uXFxcXFxcXCIpKVxcXFxuICAgIGxldCB7XFxcXG4gICAgICAgIGdldEh6bSxcXFxcbiAgICAgICAgcHVzaFxcXFxuICAgIH0gPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvYXBpXFxcXFxcXCIpXFxcXG4gICAgdmFyIEh6bSA9IGdldEh6bShuYW1lKVxcXFxuICAgIGlmICgkLm1vdmllLmluY2x1ZGVzKEh6bSkpIHtcXFxcbiAgICAgICAgbGV0IHVybCA9IEpTT04ucGFyc2UocG9zdChcXFxcXFxcImh0dHBzOi8vYXBpLmFsaXl1bmRyaXZlLmNvbS92Mi9maWxlL2dldF9zaGFyZV9saW5rX2Rvd25sb2FkX3VybFxcXFxcXFwiLCB7XFxcXG4gICAgICAgICAgICBoZWFkZXJzOiB7XFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJ4LXNoYXJlLXRva2VuXFxcXFxcXCI6IHMsXFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJhdXRob3JpemF0aW9uXFxcXFxcXCI6IGNvbmZpZy5hY2Nlc3NfdG9rZW5cXFxcbiAgICAgICAgICAgIH0sXFxcXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJleHBpcmVfc2VjXFxcXFxcXCI6IDYwMCxcXFxcbiAgICAgICAgICAgICAgICBcXFxcXFxcImZpbGVfaWRcXFxcXFxcIjogaWQsXFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJzaGFyZV9pZFxcXFxcXFwiOiBzaGFyZV9pZFxcXFxuICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgfSkpLmRvd25sb2FkX3VybFxcXFxuICAgICAgICBsZXQgcHUgPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvYWxpbGF6eVxcXFxcXFwiKShzaGFyZV9pZCwgaWQsIHVybClcXFxcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHB1KVxcXFxuICAgIH0gZWxzZSB7XFxcXG4gICAgICAgIGxldCB1cmwgPSBKU09OLnBhcnNlKHBvc3QoXFxcXFxcXCJodHRwczovL2FwaS5hbGl5dW5kcml2ZS5jb20vdjIvZmlsZS9nZXRfc2hhcmVfbGlua19kb3dubG9hZF91cmxcXFxcXFxcIiwge1xcXFxuICAgICAgICAgICAgaGVhZGVyczoge1xcXFxuICAgICAgICAgICAgICAgIFxcXFxcXFwieC1zaGFyZS10b2tlblxcXFxcXFwiOiBzLFxcXFxuICAgICAgICAgICAgICAgIFxcXFxcXFwiYXV0aG9yaXphdGlvblxcXFxcXFwiOiBjb25maWcuYWNjZXNzX3Rva2VuXFxcXG4gICAgICAgICAgICB9LFxcXFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xcXFxuICAgICAgICAgICAgICAgIFxcXFxcXFwiZXhwaXJlX3NlY1xcXFxcXFwiOiA2MDAsXFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJmaWxlX2lkXFxcXFxcXCI6IGlkLFxcXFxuICAgICAgICAgICAgICAgIFxcXFxcXFwic2hhcmVfaWRcXFxcXFxcIjogc2hhcmVfaWRcXFxcbiAgICAgICAgICAgIH0pXFxcXG4gICAgICAgIH0pKS51cmxcXFxcbiAgICAgICAgaWYgKCQuaW1nLmluY2x1ZGVzKEh6bSkpIHtcXFxcbiAgICAgICAgICAgIHJldHVybiB1cmwgKyBcXFxcXFxcIiMuanBnXFxcXFxcXCJcXFxcbiAgICAgICAgfSBlbHNlIGlmICgkLmF1ZGlvLmluY2x1ZGVzKEh6bSkpIHtcXFxcbiAgICAgICAgICAgIHJldHVybiB1cmwgKyBcXFxcXFxcIiNpc011c2ljPXRydWUjXFxcXFxcXCJcXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImRvd25sb2FkOi8vXFxcXFxcXCIgKyB1cmxcXFxcbiAgICAgICAgfVxcXFxuICAgIH1cXFxcbn1cXFxcbiQuZXhwb3J0cy5nZXRJY29uID0gZnVuY3Rpb24oZmlsZU5hbWUpIHtcXFxcbiAgICBsZXQge1xcXFxuICAgICAgICBnZXRIem1cXFxcbiAgICB9ID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL2FwaVxcXFxcXFwiKVxcXFxuICAgIGxldCByb290ID0gXFxcXFxcXCJodHRwczovL2dpdGNvZGUubmV0L3FxXzMyMzk0MzUxL2RyLy0vcmF3L21hc3Rlci9pbWcv5paH5Lu257G75Z6LMi9cXFxcXFxcIjtcXFxcbiAgICBsZXQgZmlsZXMgPSAnYWl8YXBrfGF2aXxjc3N8ZG1nfGV4ZXxmbHZ8Z2lmfGhpa2VyfGh0bWx8aXNvfGpwZ3xqc3xqc29ufGxvZ3xtb3Z8bXAzfG1wNHxvdGZ8cGhwfHBuZ3xwcHR8cHNkfHRhYmxlfHR4dHx3YXZ8eGxzfHppcHxjc3N8ZG9jfGVwdWJ8ZXhjfGh0bXx4bHN4Jy5zcGxpdCgnfCcpO1xcXFxuICAgIGxldCBoem0gPSBnZXRIem0oZmlsZU5hbWUpXFxcXG4gICAgaWYgKGZpbGVzLmluY2x1ZGVzKGh6bSkpIHtcXFxcbiAgICAgICAgaW1nID0gcm9vdCArIGh6bSArICcuc3ZnJztcXFxcbiAgICB9IGVsc2Uge1xcXFxuICAgICAgICBpbWcgPSByb290ICsgXFxcXFxcXCLmlofku7Yuc3ZnXFxcXFxcXCJcXFxcbiAgICB9XFxcXG4gICAgcmV0dXJuIGltZ1xcXFxufVxcXFxuJC5leHBvcnRzLmdldEh6bSA9IGZ1bmN0aW9uKGZpbGVOYW1lKSB7XFxcXG4gICAgcmV0dXJuIGZpbGVOYW1lLnN1YnN0cihmaWxlTmFtZS5sYXN0SW5kZXhPZihcXFxcXFxcIi5cXFxcXFxcIikgKyAxKS50b0xvd2VyQ2FzZSgpXFxcXG59XFxcXG4kLmV4cG9ydHMucmVmcmVzaFRva2VuID0gcmVmcmVzaFRva2VuXFxcXG4kLmV4cG9ydHMuZ2V0RmlsZXMgPSBnZXRGaWxlc1xcXFxuJC5leHBvcnRzLmNodWxpID0gY2h1bGlcXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLliIbkuqtcXFwiLFxcXCJwYXRoXFxcIjpcXFwic2hhcmVcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG52YXIgZCA9IFtdO1xcXFxuXFxcXG4kLmV4dGVuZCh7XFxcXG4gICAgdGV4dDogW1xcXFxcXFwiaHRtXFxcXFxcXCIsIFxcXFxcXFwiaHRtbFxcXFxcXFwiLCBcXFxcXFxcInhtbFxcXFxcXFwiLCBcXFxcXFxcImphdmFcXFxcXFxcIiwgXFxcXFxcXCJwcm9wZXJ0aWVzXFxcXFxcXCIsIFxcXFxcXFwic3FsXFxcXFxcXCIsIFxcXFxcXFwianNcXFxcXFxcIiwgXFxcXFxcXCJtZFxcXFxcXFwiLCBcXFxcXFxcImpzb25cXFxcXFxcIiwgXFxcXFxcXCJjb25mXFxcXFxcXCIsIFxcXFxcXFwiaW5pXFxcXFxcXCIsIFxcXFxcXFwidnVlXFxcXFxcXCIsIFxcXFxcXFwicGhwXFxcXFxcXCIsIFxcXFxcXFwicHlcXFxcXFxcIiwgXFxcXFxcXCJiYXRcXFxcXFxcIiwgXFxcXFxcXCJnaXRpZ25vcmVcXFxcXFxcIiwgXFxcXFxcXCJ5bWxcXFxcXFxcIiwgXFxcXFxcXCJnb1xcXFxcXFwiLCBcXFxcXFxcInNoXFxcXFxcXCIsIFxcXFxcXFwiY1xcXFxcXFwiLCBcXFxcXFxcImNwcFxcXFxcXFwiLCBcXFxcXFxcImhcXFxcXFxcIiwgXFxcXFxcXCJocHBcXFxcXFxcIiwgXFxcXFxcXCJ0c3hcXFxcXFxcIl0sXFxcXG4gICAgYXVkaW86IFtcXFxcXFxcIm1wM1xcXFxcXFwiLCBcXFxcXFxcImZsYWNcXFxcXFxcIiwgXFxcXFxcXCJvZ2dcXFxcXFxcIiwgXFxcXFxcXCJtNGFcXFxcXFxcIiwgXFxcXFxcXCJ3YXZcXFxcXFxcIiwgXFxcXFxcXCJvcHVzXFxcXFxcXCJdLFxcXFxuICAgIG1vdmllOiBbXFxcXFxcXCJtcDRcXFxcXFxcIiwgXFxcXFxcXCJta3ZcXFxcXFxcIiwgXFxcXFxcXCJhdmlcXFxcXFxcIiwgXFxcXFxcXCJtb3ZcXFxcXFxcIiwgXFxcXFxcXCJybXZiXFxcXFxcXCIsIFxcXFxcXFwid2VibVxcXFxcXFwiLCBcXFxcXFxcImZsdlxcXFxcXFwiLCBcXFxcXFxcIm00dlxcXFxcXFwiLCBcXFxcXFxcIm0zdThcXFxcXFxcIiwgXFxcXFxcXCJ0c1xcXFxcXFwiXSxcXFxcbiAgICBpbWc6IFtcXFxcXFxcImpwZ1xcXFxcXFwiLCBcXFxcXFxcInBuZ1xcXFxcXFwiLCBcXFxcXFxcImpwZWdcXFxcXFxcIiwgXFxcXFxcXCJnaWZcXFxcXFxcIiwgXFxcXFxcXCJzdmdcXFxcXFxcIiwgXFxcXFxcXCJyYXdcXFxcXFxcIl0sXFxcXG4gICAgc3VidGl0bGU6IFtcXFxcXFxcInZ0dFxcXFxcXFwiLCBcXFxcXFxcInNydFxcXFxcXFwiLCBcXFxcXFxcImFzc1xcXFxcXFwiXVxcXFxufSlcXFxcblxcXFxuZnVuY3Rpb24gZm9ybWF0RGF0ZSh0aW1lKSB7XFxcXG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh0aW1lKTtcXFxcbiAgICB2YXIgWVkgPSBkYXRlLmdldEZ1bGxZZWFyKCkgKyAnLSc7XFxcXG4gICAgdmFyIE1NID0gKGRhdGUuZ2V0TW9udGgoKSArIDEgPCAxMCA/ICcwJyArIChkYXRlLmdldE1vbnRoKCkgKyAxKSA6IGRhdGUuZ2V0TW9udGgoKSArIDEpICsgJy0nO1xcXFxuICAgIHZhciBERCA9IChkYXRlLmdldERhdGUoKSA8IDEwID8gJzAnICsgKGRhdGUuZ2V0RGF0ZSgpKSA6IGRhdGUuZ2V0RGF0ZSgpKTtcXFxcbiAgICB2YXIgaGggPSAoZGF0ZS5nZXRIb3VycygpIDwgMTAgPyAnMCcgKyBkYXRlLmdldEhvdXJzKCkgOiBkYXRlLmdldEhvdXJzKCkpICsgJzonO1xcXFxuICAgIHZhciBtbSA9IChkYXRlLmdldE1pbnV0ZXMoKSA8IDEwID8gJzAnICsgZGF0ZS5nZXRNaW51dGVzKCkgOiBkYXRlLmdldE1pbnV0ZXMoKSkgKyAnOic7XFxcXG4gICAgdmFyIHNzID0gKGRhdGUuZ2V0U2Vjb25kcygpIDwgMTAgPyAnMCcgKyBkYXRlLmdldFNlY29uZHMoKSA6IGRhdGUuZ2V0U2Vjb25kcygpKTtcXFxcbiAgICByZXR1cm4gWVkgKyBNTSArIEREICsgXFxcXFxcXCIgXFxcXFxcXCIgKyBoaCArIG1tICsgc3M7XFxcXG59XFxcXG5pZiAoZ2V0UGFyYW0oXFxcXFxcXCJzaGFyZV91cmxcXFxcXFxcIikuc3RhcnRzV2l0aChcXFxcXFxcImh0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS9zL1xcXFxcXFwiKSkge1xcXFxuICAgIHZhciBzaGFyZVVybCA9IGdldFBhcmFtKFxcXFxcXFwic2hhcmVfdXJsXFxcXFxcXCIpXFxcXG4gICAgdmFyIHNoYXJlX2lkID0gc2hhcmVVcmwuc3BsaXQoJ2NvbS9zLycpWzFdLnNwbGl0KFxcXFxcXFwiL1xcXFxcXFwiKVswXVxcXFxuICAgIGlmIChnZXRJdGVtKHNoYXJlX2lkLCBcXFxcXFxcIlxcXFxcXFwiKSAhPSBcXFxcXFxcIlxcXFxcXFwiKSB7XFxcXG4gICAgICAgIHZhciBwYXNzd29yZCA9IGdldEl0ZW0oc2hhcmVfaWQpXFxcXG4gICAgfSBlbHNlIGlmIChnZXRQYXJhbShcXFxcXFxcInBhc3N3b3JkXFxcXFxcXCIpKSB7XFxcXG4gICAgICAgIHZhciBwYXNzd29yZCA9IGdldFBhcmFtKFxcXFxcXFwicGFzc3dvcmRcXFxcXFxcIilcXFxcbiAgICB9IGVsc2Uge1xcXFxuICAgICAgICB2YXIgcGFzc3dvcmQgPSBcXFxcXFxcIlxcXFxcXFwiXFxcXG4gICAgfVxcXFxuICAgIHZhciByZXMgPSBKU09OLnBhcnNlKHBvc3QoXFxcXFxcXCJodHRwczovL2FwaS5hbGl5dW5kcml2ZS5jb20vYWRyaXZlL3YzL3NoYXJlX2xpbmsvZ2V0X3NoYXJlX2J5X2Fub255bW91cz9zaGFyZV9pZD1cXFxcXFxcIiArIHNoYXJlX2lkLCB7XFxcXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcXFxcbiAgICAgICAgICAgIFxcXFxcXFwic2hhcmVfaWRcXFxcXFxcIjogc2hhcmVfaWRcXFxcbiAgICAgICAgfSlcXFxcbiAgICB9KSlcXFxcbiAgICB2YXIgc2EgPSBKU09OLnBhcnNlKHBvc3QoXFxcXFxcXCJodHRwczovL2FwaS5hbGl5dW5kcml2ZS5jb20vdjIvc2hhcmVfbGluay9nZXRfc2hhcmVfdG9rZW5cXFxcXFxcIiwge1xcXFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XFxcXG4gICAgICAgICAgICBcXFxcXFxcInNoYXJlX3B3ZFxcXFxcXFwiOiBwYXNzd29yZCxcXFxcbiAgICAgICAgICAgIFxcXFxcXFwic2hhcmVfaWRcXFxcXFxcIjogc2hhcmVfaWRcXFxcbiAgICAgICAgfSlcXFxcbiAgICB9KSlcXFxcbiAgICBpZiAoc2Euc2hhcmVfdG9rZW4pIHtcXFxcbiAgICAgICAgdmFyIHMgPSBzYS5zaGFyZV90b2tlblxcXFxuICAgICAgICBzZXRQYWdlVGl0bGUocmVzLnNoYXJlX25hbWUpXFxcXG4gICAgICAgIHZhciBwYXRoID0gTVlfUEFSQU1TLnBhdGggfHwgXFxcXFxcXCJyb290XFxcXFxcXCJcXFxcbiAgICAgICAgaWYgKE1ZX1BBR0UgPT0gMSkge1xcXFxuICAgICAgICAgICAgZC51bnNoaWZ0KHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogcmVzLmNyZWF0b3JfbmFtZSxcXFxcbiAgICAgICAgICAgICAgICBpbWc6IHJlcy5hdmF0YXIsXFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiYXZhdGFyXFxcXFxcXCJcXFxcbiAgICAgICAgICAgIH0sIHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLigJzigJzigJ3igJ08c21hbGw+XFxcXFxcXCIgKyBmb3JtYXREYXRlKERhdGUucGFyc2UocmVzLnVwZGF0ZWRfYXQpKSArIFxcXFxcXFwiPC9zbWFsbD5cXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0XzFcXFxcXFxcIlxcXFxuICAgICAgICAgICAgfSwge1xcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuS/neWtmOWIsOaIkeeahOe9keebmFxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIHVybDogYHNtYXJ0ZHJpdmU6Ly9zaGFyZS9icm93c2U/c2hhcmVJZD0ke3NoYXJlX2lkfSZzaGFyZVB3ZD0ke3Bhc3N3b3JkfWAsXFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF9jZW50ZXJfMVxcXFxcXFwiXFxcXG4gICAgICAgICAgICB9KVxcXFxuICAgICAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLliIfmjaLmoLflvI9cXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICB1cmw6ICQoW1xcXFxcXFwibW92aWVfMV9sZWZ0X3BpY1xcXFxcXFwiLCBcXFxcXFxcImNhcmRfcGljXzNcXFxcXFxcIiwgXFxcXFxcXCJhdmF0YXJcXFxcXFxcIl0pLnNlbGVjdCgoKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHNldEl0ZW0oXFxcXFxcXCJzdHlsZVxcXFxcXFwiLCBpbnB1dClcXFxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKVxcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+W3suWIh+aNolxcXFxcXFwiXFxcXG4gICAgICAgICAgICAgICAgfSksXFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF8yXFxcXFxcXCJcXFxcbiAgICAgICAgICAgIH0sIHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLmjpLluo/vvJpcXFxcXFxcIiArIChnZXRNeVZhcihcXFxcXFxcIm9yZGVyXFxcXFxcXCIsIFxcXFxcXFwibmFtZVxcXFxcXFwiKSA9PSBcXFxcXFxcIm5hbWVcXFxcXFxcIiA/IFxcXFxcXFwi5ZCN56ewXFxcXFxcXCIgOiBcXFxcXFxcIuaXtumXtFxcXFxcXFwiKSxcXFxcbiAgICAgICAgICAgICAgICB1cmw6ICQoXFxcXFxcXCIjbm9SZWNvcmRIaXN0b3J5IyNub0xvYWRpbmcjXFxcXFxcXCIpLmxhenlSdWxlKCgpID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBnZXRNeVZhcihcXFxcXFxcIm9yZGVyXFxcXFxcXCIsIFxcXFxcXFwibmFtZVxcXFxcXFwiKVxcXFxuICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFxcXFxcIm9yZGVyXFxcXFxcXCIsIChvID09IFxcXFxcXFwibmFtZVxcXFxcXFwiID8gXFxcXFxcXCJ1cGRhdGVkX2F0XFxcXFxcXCIgOiBcXFxcXFxcIm5hbWVcXFxcXFxcIikpXFxcXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKClcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/liIfmjaLmiJDlip9cXFxcXFxcIlxcXFxuICAgICAgICAgICAgICAgIH0pLFxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMlxcXFxcXFwiXFxcXG4gICAgICAgICAgICB9LCB7XFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiYmxhbmtfYmxvY2tcXFxcXFxcIlxcXFxuICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgfVxcXFxuXFxcXG4gICAgICAgIHZhciBmaWxlcyA9ICQucmVxdWlyZShcXFxcXFxcImFwaVxcXFxcXFwiKS5zaGFyZWdldGZpbGVzKHNoYXJlX2lkLCBwYXRoLCBzKVxcXFxuICAgICAgICBpZiAoZmlsZXMpIHtcXFxcbiAgICAgICAgICAgIHB1dE15VmFyKHBhdGggKyBcXFxcXFxcIm1hcmtlclxcXFxcXFwiLCBmaWxlcy5uZXh0X21hcmtlcilcXFxcbiAgICAgICAgICAgIGxpc3QgPSBmaWxlcy5pdGVtc1xcXFxuICAgICAgICAgICAgbGlzdC5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IGZpbGVOYW1lID0gaXRlbS5uYW1lXFxcXG4gICAgICAgICAgICAgICAgbGV0IGxlbiA9IDQwO1xcXFxuICAgICAgICAgICAgICAgIGxldCBsZW4yID0gbGVuIC8gMjtcXFxcbiAgICAgICAgICAgICAgICBpZiAoZmlsZU5hbWUubGVuZ3RoID49IGxlbikge1xcXFxuICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZSA9IGZpbGVOYW1lLnN1YnN0cigwLCBsZW4yKSArICcuLi4nICsgZmlsZU5hbWUuc3Vic3RyKGZpbGVOYW1lLmxlbmd0aCAtIGxlbjIpO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogZmlsZU5hbWUsXFxcXG4gICAgICAgICAgICAgICAgICAgIGRlc2M6IGZvcm1hdERhdGUoRGF0ZS5wYXJzZShpdGVtLnVwZGF0ZWRfYXQpKSxcXFxcbiAgICAgICAgICAgICAgICAgICAgaW1nOiAoaXRlbS50aHVtYm5haWwgPyBpdGVtLnRodW1ibmFpbCA6IChpdGVtLnR5cGUgPT0gXFxcXFxcXCJmb2xkZXJcXFxcXFxcIiA/IFxcXFxcXFwiaHR0cHM6Ly9naXRjb2RlLm5ldC9xcV8zMjM5NDM1MS9kci8tL3Jhdy9tYXN0ZXIvaW1nL+aWh+S7tuexu+WeizIv5paH5Lu25aS5LnN2Z1xcXFxcXFwiIDogJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL2FwaVxcXFxcXFwiKS5nZXRJY29uKGl0ZW0ubmFtZSkpKSxcXFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiAoaXRlbS50eXBlID09IFxcXFxcXFwiZm9sZGVyXFxcXFxcXCIgPyBcXFxcXFxcImhpa2VyOi8vcGFnZS9zaGFyZT9wYWdlPWZ5cGFnZSZzaGFyZV91cmw9XFxcXFxcXCIgKyBnZXRQYXJhbShcXFxcXFxcInNoYXJlX3VybFxcXFxcXFwiKSA6ICQoKS5sYXp5UnVsZSgoc2hhcmVfaWQsIGlkLCBuYW1lLCBzKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL2FwaVxcXFxcXFwiKS5zaGFyZWNodWxpKHNoYXJlX2lkLCBpZCwgbmFtZSwgcylcXFxcbiAgICAgICAgICAgICAgICAgICAgfSwgc2hhcmVfaWQsIGl0ZW0uZmlsZV9pZCwgaXRlbS5uYW1lLCBzKSksXFxcXG4gICAgICAgICAgICAgICAgICAgIGNvbF90eXBlOiBnZXRJdGVtKFxcXFxcXFwic3R5bGVcXFxcXFxcIiwgXFxcXFxcXCJtb3ZpZV8zXFxcXFxcXCIpLFxcXFxuICAgICAgICAgICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogaXRlbS5maWxlX2lkXFxcXG4gICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICB9KVxcXFxuICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgfVxcXFxuICAgIH0gZWxzZSBpZiAoc2EuY29kZSA9PSBcXFxcXFxcIlNoYXJlTGluay5DYW5jZWxsZWRcXFxcXFxcIikge1xcXFxuICAgICAgICBzZXRSZXN1bHQoW3tcXFxcbiAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuadpeaZmuS6hu+8jOWIhuS6q+iiq+WPlua2iOS6huCyoF/gsqBcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfY2VudGVyXzFcXFxcXFxcIlxcXFxuICAgICAgICB9XSlcXFxcbiAgICB9IGVsc2UgaWYgKHNhLmNvZGUgPT0gXFxcXFxcXCJTaGFyZUxpbmsuRm9yYmlkZGVuXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgc2V0UmVzdWx0KFt7XFxcXG4gICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLmnaXmmZrkuobvvIzliIbkuqvooqvlsIHnpoHkuobgsqBf4LKgXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0X2NlbnRlcl8xXFxcXFxcXCJcXFxcbiAgICAgICAgfV0pXFxcXG4gICAgfSBlbHNlIGlmIChzYS5jb2RlID09IFxcXFxcXFwiU2hhcmVMaW5rLkV4cGlyZWRcXFxcXFxcIikge1xcXFxuICAgICAgICBzZXRSZXN1bHQoW3tcXFxcbiAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuadpeaZmuS6hu+8jOWIhuS6q+i/h+acn+S6huCyoF/gsqBcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfY2VudGVyXzFcXFxcXFxcIlxcXFxuICAgICAgICB9XSlcXFxcbiAgICB9IGVsc2Uge1xcXFxuICAgICAgICBzZXRSZXN1bHQoW3tcXFxcbiAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuivt+i+k+WFpeaPkOWPlueggVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgdXJsOiAkKFxcXFxcXFwiXFxcXFxcXCIpLmlucHV0KChzaGFyZV9pZCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIHNldEl0ZW0oc2hhcmVfaWQsIGlucHV0KVxcXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKClcXFxcbiAgICAgICAgICAgIH0sIHNoYXJlX2lkKSxcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfY2VudGVyXzFcXFxcXFxcIlxcXFxuICAgICAgICB9XSlcXFxcbiAgICB9XFxcXG59XFxcXG5zZXRSZXN1bHQoZCk7XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5pCc57SiXFxcIixcXFwicGF0aFxcXCI6XFxcInNlYXJjaFxcXCIsXFxcInJ1bGVcXFwiOlxcXCJqczpcXFxcbnZhciBkID0gW107XFxcXG5hZGRMaXN0ZW5lcignb25DbG9zZScsICQudG9TdHJpbmcoKCkgPT4ge1xcXFxuICAgIGNsZWFyTXlWYXIoJ3NlYXJjaG1hcmtlcicpXFxcXG4gICAgY2xlYXJNeVZhcignc2VyYWNoZW5kJylcXFxcbn0pKVxcXFxuXFxcXG5hZGRMaXN0ZW5lcignb25SZWZyZXNoJywgJC50b1N0cmluZygoKSA9PiB7XFxcXG4gICAgY2xlYXJNeVZhcignc2VhcmNobWFya2VyJylcXFxcbiAgICBjbGVhck15VmFyKCdzZXJhY2hlbmQnKVxcXFxufSkpXFxcXG5cXFxcblxcXFxuZnVuY3Rpb24gZm9ybWF0RGF0ZSh0aW1lKSB7XFxcXG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh0aW1lKTtcXFxcbiAgICB2YXIgWVkgPSBkYXRlLmdldEZ1bGxZZWFyKCkgKyAnLSc7XFxcXG4gICAgdmFyIE1NID0gKGRhdGUuZ2V0TW9udGgoKSArIDEgPCAxMCA/ICcwJyArIChkYXRlLmdldE1vbnRoKCkgKyAxKSA6IGRhdGUuZ2V0TW9udGgoKSArIDEpICsgJy0nO1xcXFxuICAgIHZhciBERCA9IChkYXRlLmdldERhdGUoKSA8IDEwID8gJzAnICsgKGRhdGUuZ2V0RGF0ZSgpKSA6IGRhdGUuZ2V0RGF0ZSgpKTtcXFxcbiAgICB2YXIgaGggPSAoZGF0ZS5nZXRIb3VycygpIDwgMTAgPyAnMCcgKyBkYXRlLmdldEhvdXJzKCkgOiBkYXRlLmdldEhvdXJzKCkpICsgJzonO1xcXFxuICAgIHZhciBtbSA9IChkYXRlLmdldE1pbnV0ZXMoKSA8IDEwID8gJzAnICsgZGF0ZS5nZXRNaW51dGVzKCkgOiBkYXRlLmdldE1pbnV0ZXMoKSkgKyAnOic7XFxcXG4gICAgdmFyIHNzID0gKGRhdGUuZ2V0U2Vjb25kcygpIDwgMTAgPyAnMCcgKyBkYXRlLmdldFNlY29uZHMoKSA6IGRhdGUuZ2V0U2Vjb25kcygpKTtcXFxcbiAgICByZXR1cm4gWVkgKyBNTSArIEREICsgXFxcXFxcXCIgXFxcXFxcXCIgKyBoaCArIG1tICsgc3M7XFxcXG59XFxcXG5cXFxcbmxldCBrdyA9IGdldFBhcmFtKFxcXFxcXFwia3dcXFxcXFxcIik7XFxcXG5sZXQgcGFnZSA9IE1ZX1BBR0U7XFxcXG5cXFxcbmZ1bmN0aW9uIGdldF9TZWFyY2goYXJyLCBrdywgcGFnZSkge1xcXFxuICAgIHZhciBsaW5rcyA9IGt3Lm1hdGNoKC9odHRwczpcXFxcXFxcXC9cXFxcXFxcXC8od3d3XFxcXFxcXFwuYWxpeXVuZHJpdmVcXFxcXFxcXC5jb21cXFxcXFxcXC9zfGFseXdwXFxcXFxcXFwubmV0KVxcXFxcXFxcL1xcXFxcXFxcdyovZylcXFxcbiAgICBpZiAobGlua3MpIHtcXFxcbiAgICAgICAgYXJyLnB1c2goe1xcXFxuICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi6K+G5Yir5Yiw6ZO+5o6lXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICB1cmw6IFxcXFxcXFwidG9hc3Q6Ly/jg70oKuKMkuKIh+KMkiop776JXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0X2NlbnRlcl8xXFxcXFxcXCJcXFxcbiAgICAgICAgfSlcXFxcbiAgICAgICAgbGlua3MuZm9yRWFjaChpdGVtID0+IHtcXFxcbiAgICAgICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IGl0ZW0sXFxcXG4gICAgICAgICAgICAgICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vcGFnZS9zaGFyZT9wYWdlPWZ5cGFnZSZzaGFyZV91cmw9XFxcXFxcXCIgKyBpdGVtLFxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMVxcXFxcXFwiXFxcXG4gICAgICAgICAgICB9KVxcXFxuICAgICAgICB9KVxcXFxuICAgICAgICByZXR1cm4gYXJyXFxcXG4gICAgfSBlbHNlIHtcXFxcbiAgICAgICAgdmFyIHBhdGhzID0gTVlfUEFSQU1TLnBhdGggfHwgXFxcXFxcXCJyb290XFxcXFxcXCJcXFxcbiAgICAgICAgbGV0IHUgPSBcXFxcXFxcImh0dHBzOi8vYXBpLmFsaXl1bmRyaXZlLmNvbS9hZHJpdmUvdjMvZmlsZS9zZWFyY2hcXFxcXFxcIlxcXFxuICAgICAgICB2YXIgY29uZmlnID0gSlNPTi5wYXJzZShyZXF1ZXN0KFxcXFxcXFwiaGlrZXI6Ly9maWxlcy9ydWxlcy9Kb2UvYWxpLmpzb25cXFxcXFxcIikpXFxcXG4gICAgICAgIHZhciBtYXJrID0gZ2V0TXlWYXIoJ3NlYXJjaG1hcmtlcicpIHx8ICcnO1xcXFxuICAgICAgICB2YXIgYm9keSA9IHtcXFxcbiAgICAgICAgICAgIFxcXFxcXFwiZHJpdmVfaWRcXFxcXFxcIjogY29uZmlnLmRlZmF1bHRfZHJpdmVfaWQsXFxcXG4gICAgICAgICAgICBcXFxcXFxcImxpbWl0XFxcXFxcXCI6IDEwMCxcXFxcbiAgICAgICAgICAgICdtYXJrZXInOiBtYXJrLFxcXFxuICAgICAgICAgICAgXFxcXFxcXCJpbWFnZV90aHVtYm5haWxfcHJvY2Vzc1xcXFxcXFwiOiBcXFxcXFxcImltYWdlL3Jlc2l6ZSx3XzQwMC9mb3JtYXQsanBlZ1xcXFxcXFwiLFxcXFxuICAgICAgICAgICAgXFxcXFxcXCJpbWFnZV91cmxfcHJvY2Vzc1xcXFxcXFwiOiBcXFxcXFxcImltYWdlL3Jlc2l6ZSx3XzE5MjAvZm9ybWF0LGpwZWdcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIFxcXFxcXFwidmlkZW9fdGh1bWJuYWlsX3Byb2Nlc3NcXFxcXFxcIjogXFxcXFxcXCJ2aWRlby9zbmFwc2hvdCx0XzEwMDAsZl9qcGcsYXJfYXV0byx3XzMwMFxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgXFxcXFxcXCJxdWVyeVxcXFxcXFwiOiBgbmFtZSBtYXRjaCBcXFxcXFxcXFxcXFxcXFwiJHtrd31cXFxcXFxcXFxcXFxcXFwiYCxcXFxcbiAgICAgICAgICAgIFxcXFxcXFwib3JkZXJfYnlcXFxcXFxcIjogXFxcXFxcXCJuYW1lIEFTQ1xcXFxcXFwiXFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgdmFyIGpzb24gPSBKU09OLnBhcnNlKHBvc3QodSwge1xcXFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXFxcXG4gICAgICAgICAgICBoZWFkZXJzOiB7XFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJhdXRob3JpemF0aW9uXFxcXFxcXCI6IGNvbmZpZy5hY2Nlc3NfdG9rZW5cXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSkpXFxcXG4gICAgICAgIHZhciBsaXN0ID0ganNvbi5pdGVtcztcXFxcbiAgICAgICAgaWYobGlzdC5sZW5ndGg9PTApe1xcXFxuICAgICAgICAgICAgYXJyLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiAn4oCc4oCc4oCd4oCdPHNtYWxsPjxmb250IGNvbG9yPVxcXFxcXFwiZ3JleVxcXFxcXFwiPuaXoOespuWQiOe7k+aenDwvZm9udD48L3NtYWxsPicsXFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJyxcXFxcbiAgICAgICAgICAgICAgICB1cmw6ICdoaWtlcjovL2VtcHR5JyxcXFxcbiAgICAgICAgICAgIH0pXFxcXG4gICAgICAgICAgICByZXR1cm4gYXJyO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGlmIChqc29uLm5leHRfbWFya2VyICE9ICcnKSB7XFxcXG4gICAgICAgICAgICBwdXRNeVZhcignc2VhcmNobWFya2VyJywganNvbi5uZXh0X21hcmtlcik7XFxcXG4gICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICBwdXRNeVZhcignc2VyYWNoZW5kJywgJzEnKVxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGlmIChnZXRNeVZhcignc2VyYWNoZW5kJywgJzAnKSA9PSAnMScgJiYgcGFnZSA+IDEpIHtcXFxcbiAgICAgICAgICAgIGFyci5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogJ+KAnOKAnOKAneKAnTxzbWFsbD48Zm9udCBjb2xvcj1cXFxcXFxcImdyZXlcXFxcXFxcIj7liKvliJLkuobliLDlupXkuoY8L2ZvbnQ+PC9zbWFsbD4nLFxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMScsXFxcXG4gICAgICAgICAgICAgICAgdXJsOiAnaGlrZXI6Ly9lbXB0eScsXFxcXG4gICAgICAgICAgICB9KVxcXFxuICAgICAgICAgICAgcmV0dXJuIGFycjtcXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIGxpc3QuZm9yRWFjaChpdGVtID0+IHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgZmlsZU5hbWUgPSBpdGVtLm5hbWVcXFxcbiAgICAgICAgICAgICAgICBsZXQgbGVuID0gNDA7XFxcXG4gICAgICAgICAgICAgICAgbGV0IGxlbjIgPSBsZW4gLyAyO1xcXFxuICAgICAgICAgICAgICAgIGlmIChmaWxlTmFtZS5sZW5ndGggPj0gbGVuKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lID0gZmlsZU5hbWUuc3Vic3RyKDAsIGxlbjIpICsgJy4uLicgKyBmaWxlTmFtZS5zdWJzdHIoZmlsZU5hbWUubGVuZ3RoIC0gbGVuMik7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIGFyci5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGZpbGVOYW1lLFxcXFxuICAgICAgICAgICAgICAgICAgICBpbWc6IChpdGVtLnRodW1ibmFpbCA/IGl0ZW0udGh1bWJuYWlsIDogKGl0ZW0udHlwZSA9PSBcXFxcXFxcImZvbGRlclxcXFxcXFwiID8gXFxcXFxcXCJodHRwczovL2dpdGNvZGUubmV0L3FxXzMyMzk0MzUxL2RyLy0vcmF3L21hc3Rlci9pbWcv5paH5Lu257G75Z6LMi/mlofku7blpLkuc3ZnXFxcXFxcXCIgOiAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvYXBpXFxcXFxcXCIpLmdldEljb24oaXRlbS5uYW1lKSkpLFxcXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IChpdGVtLnR5cGUgPT0gXFxcXFxcXCJmb2xkZXJcXFxcXFxcIiA/IFxcXFxcXFwiaGlrZXI6Ly9wYWdlL2hvbWVcXFxcXFxcIiA6ICQoKS5sYXp5UnVsZSgoaWQsIG5hbWUsIHVybCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9hcGlcXFxcXFxcIikuY2h1bGkoaWQsIG5hbWUsIHVybClcXFxcbiAgICAgICAgICAgICAgICAgICAgfSwgaXRlbS5maWxlX2lkLCBpdGVtLm5hbWUsIGl0ZW0udXJsKSksXFxcXG4gICAgICAgICAgICAgICAgICAgIGRlc2M6IGZvcm1hdERhdGUoRGF0ZS5wYXJzZShpdGVtLnVwZGF0ZWRfYXQpKSxcXFxcbiAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiYXZhdGFyXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBpdGVtLmZpbGVfaWRcXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIH0pXFxcXG4gICAgICAgICAgICB9KVxcXFxuICAgICAgICAgICAgcmV0dXJuIGFyclxcXFxuICAgICAgICB9XFxcXG4gICAgfVxcXFxufVxcXFxuXFxcXG5nZXRfU2VhcmNoKGQsa3cscGFnZSlcXFxcblxcXFxuc2V0UmVzdWx0KGQpO1xcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIumYv+mHjGxhenlcXFwiLFxcXCJwYXRoXFxcIjpcXFwiYWxpbGF6eVxcXCIsXFxcInJ1bGVcXFwiOlxcXCJldmFsUHJpdmF0ZUpTKFxcXFxcXFwick8rMzd1RytiMkpibDkxSlhlMUFMZlp6RGxJUWdQRkhDNmNRMytXT1B4bFdlbTMvYys5MzlFQThoMTdVb2V1Qkx6bG1EL0thZVhSdklKV1B4dlJ2c25vdy9ZMDJlNWNtUDJqMHFvSTlwZnhYc0wxNkJVVUtOTUt5WnBweGdXQ3JwZmpEV3l2SGpIbC9WYUhCU1QvMU1EdW5VYTJXMlB5U1pVYlVxMjZPeXVCWVZqL1l6SWoyemxxTGVwUFplamp3a043MVNKUCtLbjNMNkRaYm1lcGRWVTJVZ3ArU1pDZmxCSHV5UEgyeTJXV3gzKzJqTWJuUTRESUlabUJLcHc3NnArOFlwTVUxbFZub3RlOG1tRW8xNjJiTDlDK0IxUVNZZE9ob3Q0Q0lzMTJoUUxDQld5WHRoZVExcG1vWXhibm9sWHZLUmJ2NVlZdHBGTVQ1T1pDZzlwckVqYWdZWi8vdWRLenkreEJTaEEwdUswTDhTZGtrY2gyTlRpa1NXZEEzY0trTERyUW5uVEx1MzRYcVZHZitNcVRGZ3VBa0RZUUY2dDZtc0VZUDFxcnJrQnNtRHluQXdhRU41Mi90TW95WEgvRlhidmJHRDl1c2ZxN2szY1NTeTMvV2hTRE9oOU1TMncra1ArbDRLU0pvand2cDJ4ZkN3REhLbEpBTnp3VmhpYUQzelhPeVVac0JxQnRFb0wvN3pPS0doTWtGR1VidmxTeDJyemtGcGFaUHVwbC96VmpVMGVQN1QvYUNlY1d6VzFWMjZvaWxGWXlYRlordjdFSEU4SFF5Q2llWm15TG9tdVZ0Z25keUhjZEMxdnFXeEZlWHJueWplbFhUWFROcUxZVHcyOHJaekRDUlVrd1A2ZERuNXpEdE12eEMzUE1lUTBXZEtHeW1zd0VlbnBZUUFxR3pQb2x6TDRNTGg4bWdGYWsyMWpTeVdBa0tFZHRqT01QNjA2VWhoeU5QWWhDMXJkMXhXOW5qOTNBZkNmcUJtUXRGRGlUM0ZxTlBGSFhrWjRXTWM4VktjL3Y4YWpnUlp2Ym9seHJFVnFtRlN2MG9RUlhrOWRjL0VTTHlwUGlDNkc0djBhQ3ZOQUdlaUxXK29mem1SQ3gxM1pDODBTcGwrVGo5Z2FsZ3hQTFI2eTd4elB6aHcrY1gxbmJnOTFPVHdPcVV5YTdidlRtOVBJNE55cUdBVmwzbWdGSVJYSnJibkFZOEZ3Vit4ZURhNWdXWXpKUEhpRTRtbkIxQ2ZaNkJ2V2VqK21KSW54cWtCMy9NekUzdUgyVXp5WFV4KzRZaDFGQUNjTzg3WXNSMDUvcDZYbW5tTytTTmJUN2pQLzNuYVc2YXgwVC9SNWNBQW02MlZ3M0EvYWFXbnpQaUxMcndnMmVGSFVrdkFBbkdBVXpNTFlJWWxNNHRvNUZLRk9VbGQwMy80SHR6ekcrWlRLWDc0ckQvZCtwNlZEbE85TU5FWnBBUHZORmhwZUhEZDZBcXFFY2FLTitkelJhb0tnNjZ1NVZIQk1hRFQ3MytHazB1aEpzU1lid01Yc1BMS3ROMFM1WFA3MW1GaTNoU0JnRUkyY1R3andUK2pjTDZnT0cyMlh4aFNDRFhIbGFzOWoxMlNoVGxKWGROLytCN2M4eHZtVXlsKzNiT0dGU1MwWUZLbG5jKzhhVHFIUW93aFpqNzUvTTUzc0tZWDJ6UmdPU1RhRDMxUm9RS1NFY1BEaU5Fc1oyVG9tTmtBbXZmMDMxK2ZXM2NobTFSd0t3K1g5R3hmbUhRN3JpRG9TUmlvVWFad0hlbEQxbG9FZXNDeUQ1MDFIN1JZOVp5UVU2cU1aZWZrZUdVQk9RWkNhWnNBd0VuU0QraTdDcUVoZzIvV2NmdG96aVJJeGhYWTJGN2xVNXBFbElHeVdwbkRWZ1p5TmNFYXhobkdRTGxNQ1EwT0ZJSkhqWURtMmpYQnRVdkZrcEovZCtDZ2VERDRvNmVOSHhNbEFKUnVzbkFoS3BrTU0rVWVnNjlXUGx2REhnOHJaYTVRbmN6cE4xMjNGL0FLNEp5VzFWMjZvaWxGWXlYRlordjdFSEU4QnBNa2grOVkwL0R6SERvT09QZ1B6WGd4cVpBWWJBQ1dhMGtJL0FaTGtEL2VsNkI1QklqaVlIZzFBSW1LbFhYUW1jTFMwc3dHaFoyQ29VemNCU2tFdlBPbERMN0R2enpzT1FuSysvYkNjNG45czdrZkVoNUdIK21WNEUzNzcxcDZpazlCK2p2SHI3amEwU2d2UW5DUU05SGRzbFpTUTlXeXN0V0szZGE4N0ltRisweUhMbDdyaXhLVTQ3V2d3U1RXMDZsQW1kaGpTSVVoNkZLMDF6RkZPd05TWmRNdTBwcXVFN2t5eGZGbzF6RkhIVi95OGc0T3VNdm1KM3FQRWV1YUVCRnhRN0VQaVAzL254YTBsaTlxYTJ0eGNoeW9nVWQxSC9aOUE0QnhqZVZ6RXNGQTJLdUFXR1RmK1Bmcmo0dTl0WFIvTDV3d1U1RktrZ3pUSjVYdDV1ZFdYUkg2dFZKTytOR0JqR0hjMW5QdE5rQ2pUeHphMUZuSllHOUZnR01rMHhqSFl6a1RNMG9CMElnZWY3N09lOG5QUUZhMjZFWXFRR2lzOGFFcVVCV1FQN0x2SzU0aXo4cDk4Y3RoNkpJTUZZcEtpR2dGaVppYkZRM3JQM3RERndzc0QydTUxdjZLUDNTN05UZ1VwYnRpY2xua0NtUXNzOWcvSDBlTGwxdUU4NlVNdnNPL1BPdzVDY3I3OXNKemljUE95VDJBWDRvRnE4dGp2NE1wcEp0am9qTnVCMngzcEY0TUtQM1gya21mWUdoRnRMbFNjNWhaYURTTndIU3ZmemxFR2FzSzZ1RUNOZ1NiaDN3TWRhRWZyUzZMSTI4YkJHR3Z3SlVReG11ZnloeVZET1JNc3E5UzAxL2x6citOMm9XS3pQRCtjUzhjZkxaSVd0ZWJldFc4QU1vd3BpUmdRWXRqUTRGTE5JQSs4R1hqNEJlcE1zK3U3VmRXWmNuZ2Y5RVZMWkFQUjJpZC9rVFVMMHRXVzQwVHdHMlpjaUczcnZkZEcxc04vdUlPaXlUTVBPNVNuOEZDUElqSWRoRWdxZmJMcUdsb0FHRmVOU0VvRkIwUll1MGhWbWJYY3dSREtVWWkwWFRMN2JEUXVCNk1STlN2ZHFidWY3bHJlazEyWUNSeXBocWZXUEZrZktmT2I0VmN2cGF2NVUwcllXM0lIaHFScjNua1BYOGIwMHhzU3hCRDFaR0pQS3BFZmxxaHd3b05sSUZYVTh4cFh3Rksya1NoQUx2YWZ2akw3RzYraXdzZUdLSHFveFZMaDVDRjVkc1NCNEVhQnN5MVVObTVkcFJtRktQTHRQb2RiaGpoTHRsYndyMTRrdHlyOEM5NmJ4V3JNcE5zVWszSHpDOU5OWVBta0JJNzlqakIrQWdyVFBSVjFyL0hzR3B6eU0zdCt3RXZkK0lqaVNOc2VzaE4renNpYllBdDdRT3pwNE84a3djcCtHUUpFTnd3UXVVOW54cERPRTFvZlppTW1GOGt2dVhMWW5DRW1DZUxyOEh5UnQ2Rk9yUVQ4UGM1dFFiOWpENTBla0VJTmx3L1ZzZkZiUmV5NTViZk9FdktQWE9ZWFZYcWZIdDBQaDA5VkZXRmFvSk9GUy9KUzk5bStGU3ZJRG4wZ3B6b1hoSVJxdzdCN25KZTRyaFV3Ui8yMzZwQ2xVamtXS2RLczFaRncvMVV2ZE4zd2RwUTdwOUtmK09Vc2pYQzM4MDJPZWZwUW9uVTc2eXN5S1RtVjQxNGJjWHpPSGdtR0hUSjFRazZEN2RhOHRkR1JaeWxscVdEczZVTXZzTy9QT3c1Q2NyNzlzSnppY2FpeEFkM0NldFVBdHNrUVZ4WUpodlpPVGV1SmFMYTQ1WkJaZytsWG0rWWFjaEFPK3lCNmJEZjBvWjV5NC9HZjQxaUhmOERCb1BtMjJObzFHUWpQQUNJNkNoeTdOQSt0MGxXU0RtWTZSYmRqenZjdVhJRXJncjFEL1B1Z0ZtaE9Wa1UxQU16YXdGMmZoeDlpQ1JuRkpqUWVxUHhnWlM5L1ovdDRCM1dYUElCMHdBcVRyem42b1IzRFpLTkRhMmozbmRYQlI4WUpTVWlPejVjcDRkaEJHdjlhM09KOWFXMm4vcndBZ2M1bXFKbnlyQ3pDM0tPZzFkVklsM3pBYW1uYnNMMXBNZUNyZ1ZIZm1GN0k5L2Nmdk1PVmNLV1VraE5Fam1rSDc5enpPejVEbXZLcGFTR2RRaHF4Y3lnakJ6blY0bnhzVE5zQlpsMUswVVRrL3dBUzhYeXl2TFNOWldjL3NJbi92V1NBSFU5dmJPNUh4SWVSaC9wbGVCTisrOWFlck9hZFFoMnRUVXNZaXFyMWFjYnRmWmxzOFhobHA5a3puUUdHR0wrT1JnZHB3OXRwdjJUcCtlMTEyMkhtZzhiMTVZWTdLN3N6eGhpSXlJdW00eWtEdlZNN29QN2YyZEFiWm4rZk0vaUlUYnNPazJQNHRiaXR4c3VvQWVycDQxdGZsWVlLQy9rVzg3dS9ZNGl2QVFGbjRSaDdhbk43Ty9UUnlUTzR2NEpWSlRzMzlCbmZJTXdSRmRqZVlBUWU5R1BibWdVWkxkRFEvRm9ha2V4WEZMSkNzcDJEcTdWYW1xYThUVDBEekZkdDBOTmVXeTdzTU1YbW01Q1A0TjlGeDUyMWJQMGw3c016d1lSU2VoSFVNWi8wTkg5UG0zeGNmSWUyQVlOTkFETE9uSWltN1ptbUtoa3RSZHRMU3ZqR1lFMVVVZUJLL25EbDBRdXFkQ2lqL1lCWk9Yc01oT0Nuc0VVY1I4OEd5bG01YlA0ZDhiNGliNngvaURBUGN5VEg1eDc4aE55YVJiYWgvWXVTNGowNVpuSllwSU85Z1B6VHliYkkvd0hOcjVvREtDbHA2Rm9KVnpmelVqVTdZQnBkWm1NODloTjFHODlvYUxBRXZpeHZvTnIvOW4wMGZNUUtLcE5oL210RkFxdWo4cWd5MTUybVJ6Z05wR3k3NkxWamVxd3E2alhYVFhsWFJQSmxCU0kyQnhFUzVCMFZkYS94N0JxYzhqTjdmc0JMM2ZpSFZkVHpnNkJLK3RGZElwTzc5NEhScmlob1RKQlJsRzc1VXNkcTg1QmFXbVI0TVdJdmtYTHdWakQ5MWUyR3BIRG42enlDam9qOXl5NmRLWUh4Z1pxQmVwVjVBWXYvbW85aXFla2l0V1B0S1N2NVUwcllXM0lIaHFScjNua1BYOGI5bU10cTJscEJrWkY1MlhFYmR5OXhTQWlpeVdEdWhFYThHSE5EOHE3b1BEalBhLzF6VitFaU56QWpneGtDd0ZqNGkxbEpjSG1yZVlMWURGTTZHUlhSQjRSaHlkcG0vUVQyVmJFc1diOWgrbDc2TDIyZ3RZN2QyQ2xJTDNDaGw1d3NzcnkwaldWblA3Q0ovNzFrZ0IxUFlQN21PTWR3Vmx3UC9BMnpvWllLeXdHMm1IWTZTTGVwcjFQNVYrRDBNRnVGTFZtZE5id0o2d2I3dFpoa0xFWTcvTEs4dEkxbFp6K3dpZis5WklBZFQyWjU4RkRSeFY3dVpaVlc2OVRWOEFBSXY3Skk2SVlmY1FNbko2aS9wamtZaUdkb1djL2FXZ0FQZXVja1FrVStoVWs4UU9MWHhNZzgzZDVOakEydFZodTlKcWI4YSszbDFjeWc2dVcwNG1ab0VCYklwYmNOd3lNSGpqMzBtRnQ3SndXTlhqVXJ4VW5BNTVxbG9JOGdkT1Fjc3J5MGpXVm5QN0NKLzcxa2dCMVBadmxxeEplVFZaSjVCdkJQdzhLUlFwd0ZpdEhTaCtFS0pHQ01vVXVGSTIxQnBCWlpydU1uY0VtS25XbVcrT05CMzFWN2hZaVVhVzVKblVxWTloejhDUW96M3hUb1ZYR3gyeUMzMHFhZUZYS29kVzE0S0hSUkY5SXB1K2dHQ29MQWtwcFBjRVlZQktBQ3NBUDdBM1lna1VScXRVZ0ZoazAyVFFzbGRPMlRvbklNTmY5UEtUN0RHb28vSlRycmxqeG9lbUp4S0xIUmRLNkppbGZQOG9TUVdrb0xKdjd0ckFaZnlaZXZnZCs4NUUvbXVHejhiYzBLeDE5TWh1NlBQbjlTcWtEdjF0Z3RJbDBaa2FtNGRiMzFIc0xmbTR2Y0tKd3Fua2ZISC9sQ3Y1N2ZaL2U3RFRXczVUR3lOSmlQS2ZsOUVhZk9nRXNERzJyMUE3MlJVZ1lqVWw5a1lWaVVIL3dPZkNVSUpRajVuUkZqTlpKdm5JMUROWlZ6SWtkem1yd0hPbWpFbVR2N0NTZ1ZFaTNTTW1IWUY2cytVTWloM3VvNmdQYlJoT2ZzMFVqengySWppNENXZFZQQXFPTWFaY3R4bFMzVHZqdmxhVzBUSTN5SUdiRTlScklISWgxanJhM0FwWXo5N01nL0RIWERjMk9hbkQxVmpFZHN5YUpaT3NLUVB0c2lqNXBqdFlZUVdNVjJUczdBb1lEOXdLUUJEalF3L0pyeG5RTlErTE5jOFpITDFXdnJaRFlzbUNqd1RHSFp3THJDQ0VFOEpzRmIxL2o4RXNaVDFmSU9YY3E3c2I2VTMzcFBnMDQ5NjkvcE85Sk1GcDZkTXFNVE1RSG85M1gyT2x3cDlUb3JpV3FCYnF1RmQvODNZVGtmK2g0V0VtOEpXQ25PRk55c1lrajRLSm1DYWRBN09STW1pU3lLemRPa1ZTZG1UUW1NMVdnMDdtOWpHTHBxNGRhZVhOTmxkUlFvbGk4bnRtcFgzeTVvWXdxcGpwUFdhMURPSFBsd1l5VDR4N0ErNUN1WFdneWgyMHBYNkVSVGpMbmNGV2dBY0tOQmpnNzcrMWJ3ZFZEMU05QnVaRDJZWnY4cWRXYm1zaHZHc2xRK051TXI2RG1DVE5DODVmaTB1TERYbHc2TE9BUVBoTXhUNjVpMHJobFRKRkVKbUhHQ3lOVkovZFBVSW4wK241aWMxMENkRXlpdmp5TU1saE5GNFZUajlKQmdGdTFVSlFYKzN2NFI4SE1WdFZkdXFJcFJXTWx4V2ZyK3hCeFBCYkZWWURpbWx1Q08wQUpHa2pyWFZUUE85eTVjZ1N1Q3ZVUDgrNkFXYUU1UWl1SG5ZWnpDVEszd2xndVpoMk5SWnBxTFJFZVpWZ1doSzF2QTR1bERBQThjRW8xOUc2N1lMbVRRSm96cFkzWGNzcnkwaldWblA3Q0ovNzFrZ0IxUFl4Y2RTU09mQU4yQThBNHBMTHdWYzBZVHVmZXV2K3g2ay81UTU0VThnSFVNc3J5MGpXVm5QN0NKLzcxa2dCMVBiUkprRGoyU1VKNGkzTmx2eEZuRVovR0tWUVgzb3FycFptMWVOVnlQdG9JSmFVcE9wWVN6Z3IxMkxiSEZSNWs5L0xLOHRJMWxaeit3aWYrOVpJQWRUMmcyQmtPa2FRSUFleGRTQVNHOVBOUmt4VFFKQ3NKTzdlaXFkRkh4dXJhTXVrSCszVkNyYTIyM1loZmdOL000K0lFZ01INkJ5SS9senlDb0hzODhlcytGUFZOUzlOSDNwcGFnQnRhMFFtYVJLZHVwSXlMeDJWd3c3OWxvRVFCNlFKeXl2TFNOWldjL3NJbi92V1NBSFU5cEtuM3NjSUxzWW90eW16SlFVbFdSajhPdWFHb29ZRzlTUUFoRUZDb3VRRHl5dkxTTlpXYy9zSW4vdldTQUhVOWdXdHVQK0dpQ0xWYUZ0dzE1aDBQS0xOTXNjQVU0K1JUd0dVUmJ5c1ZQYVJDVDRhUmV2dGs3cWZySUcwUHB2UzNjc3J5MGpXVm5QN0NKLzcxa2dCMVBaY0FoY1M0eXloRGIxQi9yU3EyVkwzMUdKL2NYdWF5RDdMZkY5aXFobXhvWHdjdHZVcm95WmdtL0hSK2dKejAwdWZIMDRrMnRrRFYxRGV4QVhyLzY5SldMaGxmcGt6SDl6OVArODFJcEJFSHBEbnJYcng5Q3dIQWZzNnpVZ0xTbHFSbnhHcWdaa0o1VUlGM0VQalRVSkNhQUdmcjZaV2xqSDZnZUhaZEk5TkpFekM2TGc0N0Q4dC9ydkgvYy85SzdMTEs4dEkxbFp6K3dpZis5WklBZFQyYjVhc1NYazFXU2VRYndUOFBDa1VLU2dxSWVVOERaRVFrbWUzRlhlRlRMNzFEZ1E2SkJJTE1oRUlWN3B5a0M3SzJoTjBBVUFYVTVjSUJJajl2WnRHcDg2VU12c08vUE93NUNjcjc5c0p6aWU3Zjk3a0twRE56Q2s2Y0JYMUdrQjBpM3BBTnNqOHNjc0pvSGhUNjBTaTRjNlVNdnNPL1BPdzVDY3I3OXNKemlkbWkwVS9xSWt6Um9JV1JRMGdPVHhFMXlSVzFlOWdVSlk4RkN2ZWhsZDJrRE5ERGxzL1RNaVU2NlA5QmVzUDFrUDZFQXRmQWxQeHB5N0xvVXFyQnk1OTJjWWo3SWtaTGxtRXY5bGlnRllCejU5d1h3SVhnUGRvNTRnSUw2UlNuNmExOE1XVEMrRFFKOGVra3JZSkdYNm45aktONW5JT0YzenpHMU9GQW1uZVdQVXBDYk9JZlJMRllucGxHWWhxbXlDakNuS3N5bnNSN3pYRG03aXhVa1h3bHVXaFZTSElEU0VtNEttMmpqV2VjcGs1R1hhSG84RGg2RksxQjEvblBzeGp0WFJWRzJjWjl2OUF5YjBuNGkyTHhvTG1ObFFKNHg0WHQzbDZJdjFjTi9ReHF4azV3cUhWbys1dm5RSTRxRlZQNlRVaG9wa1dVVGNCcWx4SDl6bnRVZHMxNXVMb2J5ZkoxZnFzL2tFdkZ0SSs2aUtUU2NackFjb09YVU9kODJmNjd3L2dzNmlsODd3NlRDTzloMTJHTVU0bzFwRUdPNklxYXdjMGFPR1kxd0tsR0l4emY2RTh5ZjZOOUVhSFBBa0ZLVUdxdmIrUjFDSDBMYXZWbjVsaFFyaXRacExBWGcrWXBmMmpXc3BrMWxzWHplRTBpeGVZOFJrYnVLRnVHYXpSTm85Q0R0NlVaVXo1MStiZkJVYWlFckxIWjFqMXJxV2lBMVZrd21iMkxiSzdnMSt1ejhSUytmNS9tb0wzRHVSa2RwWmJBcmFwTk55d2Q5WUJrNkJ5NmhCcFlCQUFPaWtJeG5FSDNyVUMvMTNTVXlJSnpYUm5wV1pycy9zMy9sdzhTTXlMb1dEVUJHaTR5NG1Zdk9tbFFhOURsbDZRMEIveXlIV201Wk5vNldvZ2JESS84ZDlkdmhuRXIyVEplUncxV25vRkptYUsvM25kNllIbWtpajlIM25uTlZXRHVCWW1GWmpvd29BcEVZOFY1OEtsMnFkTVRYYjJaM1lNV1ZYUlRFZkRYMGQ0SzVXZzRVdDNaNjRRMkplWlpld2kzTXk4U0ZmcUhsRlR0bXlTOVVNNTd5REloeWdOZUwvOGhwZlpJczNrVktsejVWc1RYcERhWjZjeU0vQjBVNXFUZXlQSmlzUGhrNnA5T3dqaU54aWg3S1FVak51SlBCTDBwaEkxQ21VdFlqV3pNaWxNUVRka0FhWFJQbllMVVJEYlliYzJVdkQwSUsyNlJZeGFISUwwZUZURjJORXBPa2xubDhGQ05JWm5GNVgvdERyOGpDT2kyeUZKQTJ1S2toVzFubWhJdjhMd0taVm5wNThBWUlzREE4eGd2eE1hMENFRy9uRmdscURsTldnc1lobEZqRmQ3cFBIb0tZOWpINlp4TTc0Y2RZcWJUUit0VnQ3ZzUzSFZyd2ZMaU1MOHJ1aHFkRk1FTjhpZGExUWVlOFhmNnBnbG8xZEtjWWJ3NkJtbjhlUVBzdUR0L2svdDkvN29UdVl2M0ZncHV6MGx0YUVGTVpXcEdwc3dvYVVzdnQyK3pIeVJubTNpLzgyOC83NEtFM0JQVnF4aVFmNzRYSTBubW1ZZFNMQjRiSi9YTllHN1hoNzArYmZGeDhoN1lCZzAwQU1zNmNpS1htQTBDcWVLRXhoZlZ2NXBKSzFBMlc2ZUdGYUxrVUNoeEZyWnpqNEZLTFN0NUtyaWtHNURoemZzbW1nZEpoWEdKbmxDcEdTdG9CSDgreWhEVTFaY0ozVEg5LzBBNU9IWTJUMW9wb05QbHNlc2lnZW02dm8wbjNRc3NkWnBMbHFrMkU5RkNXQ1RvTmtTb2NLbkFvZzEwM1plZFEzTjkrSDVKajErOEtYbWQyRms4TFZHM2YzbTYrc0FVSXpwMVZPSzlzdEwyVXB2eHBzSGJxTUN4WlZkdWV3alArTC9vOWF1RGFnYTR2bGVhSy84cC9NRC9UekppbVhRL2x3VGxud21pVlNuMlg2T0s5MFJmRXFqa0MvcklWS3FuYXpkUkkxbldZWm5pWEplNk12TEs4dEkxbFp6K3dpZis5WklBZFQydUhxdjZ1SE9aQjg5cG9ETnluSnh5c3NyeTBqV1ZuUDdDSi83MWtnQjFQWTI4TENZVFFTNHlSWHYwelZHSlUxVnl5dkxTTlpXYy9zSW4vdldTQUhVOXJQUlB4SWtVQU9PRmRQamFBM1IrcExpdEFjVGFXMDlnQk9UQkhBZHhsM2pzRDFjeFAra2E4RUZxMFcvTmxLWHo0bFVwOWwraml2ZEVYeEtvNUF2NnlHK052RHZLZnUzYWR4R3REQ3pQTXJld0VxWmw2TkJZVFIvZzdTUlM1RFQzSXhNY0pQZEwrZWJSWkN6eFFpSzJzc1BUWTk0bExmdG8ycXBaekVoeGdSMTRYa2ZkRXpGdW4rT3ZoTjRFcHZKVmg2ckZxNXgvc3VyeW9sYy9LZ1RJVUZadytvaFRPRVgxQ2RsMjQ0WktYdmF5eXZMU05aV2Mvc0luL3ZXU0FIVTlsL0gvYXlIblVqQ3BBU1huZVI4YTZUYUYyUU5ka3RZemxNem55eDY5MmZVTzg3Y2o4cjZpeWdicGxKSHU4UnBIOHNyeTBqV1ZuUDdDSi83MWtnQjFQYVdLN29WT2FESTBBZHNwOHI5QkVBM1N4enlMd3BvM3BFU3g0S05sMG84M2ZPRnc1Mnk3L3ZPL3M5WkkwN1ZwQWxHdXlJNkkwazlKcW1KSVRMaG4vRVVxQ1cxb2FNdEs3RW50U3ZpTTIzMkpTMnZnYjlyNE9haHdSMDRXcGUzNUZWVWV2ZXNJMXpsSkRHTWwrVUVRbUpkZkNEYVBYb21sZE1SMnUyTGFUaDhGUktLTTFJOUZCZjVuSWlWTmZGZDh2bndVQ3lrYStZd0g4U05jSkN3TkFrdnl5dkxTTlpXYy9zSW4vdldTQUhVOWlIcWZqVW1NbUdrNW84a0JYbnY2ZFduTDRJQzFkRmNUbHhPdlY4R2JTeS95eXZMU05aV2Mvc0luL3ZXU0FIVTlnUkN3YVNXT1N0SU1JRGsxbE9ocHozV0NsbmdlL0JmNDMrcmVjdHJja1lhQkxsMVdUN1FVbFg1cTZFR0YzaTJ0aUhmMVorL2p3OGNHN2F2U0xaQjFMZ3hrWjRta240KzJ3RG5rN2NnVmM4dUdLeGZWY0JsR3ZrKzB3dlFjUlcybDhtT0Uza2hOOE0xQzRjMFA5dnBqT0JzQ29hOUVYZzdzWmp2WUNtb0lMd20ya0ZhQ0hJNXN2SmxPVUtvT3RMZmRjc3J5MGpXVm5QN0NKLzcxa2dCMVBaRG1LSUlMcGVPTXlHZXRTNjZCWUZ5aG5hRm5QMmxvQUQzcm5KRUpGUG9WSS9KeGxrbzN4cXB6L0p0ME83SEpmSlovdTM1bzE1T1pqZENKOXV4eE1CNTN0Qkx5VlhxMkFmVnBYemovRkFmWXAvd3krd21JOWpRRGpXTEpZcll5SW5MSzh0STFsWnord2lmKzlaSUFkVDJlSUtBRVhBWXV6N205aXZVMTQ1Z01LSEhudzA2MWpJUTdxV3NENmtGMGhTOExVTTYza3Jkd3ZKRnVkWkF4RmZXeXl2TFNOWldjL3NJbi92V1NBSFU5bDVYRExucEw1SXRwaTZEZDFsNW5CVUhoVStOeGpuR29vTk1EYnZJSUhTbkY5MHQ0azlQRkpCRzVKeHhIQ0c5MEhwTGZFMUE1Y3VML1ZIanoxNERSTm1vazZxVkNXWHVEcXhDRjJ6L05Vdk4yWk1BWWVrOXhWNHlNTHoxdTZwU1ZwelFEaEM5a05TQ2V2UHpSWmozaE95YW01cWQrS2Vna2tFU09HOGtRUWVwcjJoQWxrMDhlWDkvaHN6Z1Bnb0c4WlY3TmErZytMQ1IySWV2dThkNUQwS2cyaGpVQnl3eWdVRUZxM1pleFc3UjRzajMxaXNFRUhXbWloUVBCdTVwREN2U3FSS1ZGWTlpQTk0OVdPY0UxeUc5YTYxSzdNc0xLQXFLb0ZEekdyQTRLRGRRb3FPVzlabVhPVzNEemZRemIvSFRKQmdEbE5OSXhvRjB4bkhBbXdNWUFzTk5YVFdXMVo2cy83L2lKZGZhbFhzMXI2RDRzSkhZaDYrN3gza1BRclFwakJTanVra000V3AvV2hGeTN3ZGlJM3pKN3kxdEx6N3laNmZlU3NiSktGMUh0aStad1lQbXVlMzd2c2ZQcTRBekcvaDVjK1NkYTNFUFNYQTYwWFRjUE8yVzRmdkVCTXIya1ZKRGNMTjR1YTNDZ2dLTTJmYkkzOG9IUmdtRC9kc2puUklmd3NITGhXTmpSRkdnN2lCVGVnb0JNNGJJT3FWakNHVG1FbmRHZitYSW53K3M3cDA1SkhLUWpsZ2tVR01rcFBDTmZRYlB3OEJoUWRUeDBrKzIzMzV4RCtxRzlFSUUrYVFjRW5tak4wdWU0YXozTmNaQnllQlc2NTJSUk16Q2dhc2UzUFNKTFI2WU4xUFZjZi9rUXVGOHltbS80VkhFVVZnWkthZW9ZNTBMWFIwczhMZXU0MU5PTGkyM09YSm5hNTZNaEh0akhoVDNYcnU0MHd2dTlTY0U3S3V1enJwVE9BZFBlZWFaUThvRDZ1anJVWWI5a3hOUnFDQWFtZzhpdWtXRFFZUktpUUNmenIxNEhpSmZ4UlNNSnBTZFJCR2M5azFHMWNqeVp5Qi9Na1BneW1UZkFiZkJld2dld0paK3o0NHR1bnVncFk2d2x0Vk5mYlkvYkVIbjc4TXdIS3hVTUI2VWppbGg4cFpPejZxa3FKMThvREFUZkdiT0tFeTU4bWVrUGVUZUdiWWJUelhxWVNSR1czRUpLUktMRHpaY1dhQTBZUHRzcHJKMzMyQm1hS3BiRGNQYmEyK3dhaFhiYnkzL29GRzBRcFp4cmxvaWg3L1BlcmJKS0JJVVlYYnNDVy8yUnBNN296VU5sOUVyeFZNTWRLRm1DNUtLNFpjTFB6UFpsSEVkSHQ1L2RlZEpuVHp4djBqbHVpZy9POHZUVWlMNlFCcUd5eXZMU05aV2Mvc0luL3ZXU0FIVTlxRERlU0V4czIzdFlwV2M1NGJ2akx2MTQ4SUpEeHBtYkRKT2tkSk5JNzVINnRqOUR5N1dLL1FmMnRFZDR2Q01qV2prZFNqY05kV3JMMVdEa1RmbDRsYzc2R3k1YXhyNm8rbVBHbGdJbzVnSHd6a1RyaW80akFSSDZad1RYcFJsSDNnbS9ST00yN01QcVR2QzhBYmZnemJhNWd6VndyNFY2MU5PemFRSzFNN3B2T3QzUElUWW9Gdm1DZmRoYjdTUWlqZmRsOU94TmNvTnZNWllXZysxekxuTEs4dEkxbFp6K3dpZis5WklBZFQyd0VyVUpra0FMTkg1UFl0aUhQR0E4bWMxNmFHOHFtNG5XVlJSRWY0K2FKZXhEQXZIM1B5VXhXRDFFRnNCNzk1dnl5dkxTTlpXYy9zSW4vdldTQUhVOXZINy92U1gxTVZ0cDVqTTBtcUlkS3dPMWhmelRGQ1haeGRuWlFuZSsxYkd5eXZMU05aV2Mvc0luL3ZXU0FIVTlqOG5SbWR5UDkvYUN2bG1qV05xL0dxeGdMUEZ6QWhwUTlBNTNSRFVrQW1yRytVd2hzQU5JWVllTTJWTUROcGtNTXNyeTBqV1ZuUDdDSi83MWtnQjFQWUk0amNZb2V5a0ZJemJpVHdTOUtZU1hOV0dTNjNRRXNpWjNtMWszRkF6TnNzcnkwaldWblA3Q0ovNzFrZ0IxUGFXTE1WYU9WRzQvZTFWUFRTQXpZOUg4N09DSlhleCtpQU9vVytLQW5yaUIzSm5hNTZNaEh0akhoVDNYcnU0MHd0bStDRVdYdW9ZOFhFSkZkdmNGY0g3eXl2TFNOWldjL3NJbi92V1NBSFU5bExPTGZyT1FNcEN4UWxEZzAyWUpBVExLOHRJMWxaeit3aWYrOVpJQWRUMms2Z3Z0YzF6NWFJbUJxRmduYlEwTlRFOUdMZmJPQ1NFaGQrcnBZNmt5dy9MSzh0STFsWnord2lmKzlaSUFkVDJDVnYzb1l0TTB6TUFTMXg0WHR5K3pzZWJHVjR1Rm1vY1Mwbk8zNGV3OExQTEs4dEkxbFp6K3dpZis5WklBZFQydUxKOTZLWFIzNnh5eXBtR2lwRnpGT1NQNUlHQ0UybEtxc0l6NldBdnR1VExLOHRJMWxaeit3aWYrOVpJQWRUMjF4L3dIcHpZYnFuVEI2TUJPbk9vV2tFOGc5VytwWlhreTdGWkkzSmpIeW5MSzh0STFsWnord2lmKzlaSUFkVDIwLzNhd29EMUlyNzgwZXlwL1hjSTY5bEVTRngxN0hVb3d0ejZEZ2o2TnpITEs4dEkxbFp6K3dpZis5WklBZFQyZm9rUEY2dTZhMGVnWFNDdGxMRHdjeE9PY2NZZXI5ZGczNFdtaTlpSDVWNDdvMktRNmJOaUNPMDJwTjUxR2ZvT3l5dkxTTlpXYy9zSW4vdldTQUhVOXZoQ1lnYVgreko1WVBpRnUvZ24xMHcyKzdjOXBtemtWWW1vRWswbkdxaWJ5eXZMU05aV2Mvc0luL3ZXU0FIVTloUDFTa21JNWJZQmw3UkduSitXN1NiTEs4dEkxbFp6K3dpZis5WklBZFQybGl6RldqbFJ1UDN0VlQwMGdNMlBSL096Z2lWM3Nmb2dEcUZ2aWdKNjRnZHlaMnVlaklSN1l4NFU5MTY3dU5NTFp2Z2hGbDdxR1BGeENSWGIzQlhCK3drK0drWHI3Wk82bjZ5QnRENmIwdDNMSzh0STFsWnord2lmKzlaSUFkVDJlSUtBRVhBWXV6N205aXZVMTQ1Z01LSEhudzA2MWpJUTdxV3NENmtGMGhRZUFFL2VDckdVYkYyYlZoTi9lOGRUV1I4dG83eVI0dTVoUXl2VUNjZ2I4Vk05QnVaRDJZWnY4cWRXYm1zaHZHc1cyMU9uOVhnMnA0c0R0bWRGekl1YlcxVjI2b2lsRll5WEZaK3Y3RUhFOE9CRWJUYW9Fd2N2VVNMcjhQMlV5VTRoeHBjd2ZHUzNxbXNjdWJQTW5IdXF1K0t4MWZFaVRFa1ZUejZzenJWRmRNc3J5MGpXVm5QN0NKLzcxa2dCMVBZM0dIazN2VHFmN3ZOejhnRXNQZGNDNXJTVis1TGliRE1rQXJ0cXJlbnZwT2wvU3JXd0J6ZGdWcyt5Z00rVDZUYzErZ0tqMEQvNjRvZjVocWZFT0R3RW9oTWprMC9JK1JLZGkwODlEZ29NYjhzcnkwaldWblA3Q0ovNzFrZ0IxUFlrWTJ1UjNjR0dlTkVxeGdIZmllaVdDZnQ4WWhua3JWQUZSYzd3Wm9qYUZ1MnRaSUpwT1RQanUwNlFnVU9FRVRWUlY5UytxMEg2bGZqbkJUblpWdFE5dlAzc2NGSGJqV1JmOEZSSkRLSVZRM2kyaWtRcFJkTzdJeHRrOS9qbWhTRWZxZUVPbEpTdVVqRitUNjBEZksvWE1XcGI2QVYyM2VwbytoWkpVZDNtYzFuSzBlRHgyRWR2SXM0bll0dFpSZjdMSzh0STFsWnord2lmKzlaSUFkVDJXME5pRWp1QmRBaDQ1SU9nL2dpT1FwcWJtcDM0cDZDU1FSSTRieVJCQjZuT2xETDdEdnp6c09RbksrL2JDYzRuZDF2bmxudFVOdmRVQ1Z0WkxlY2pwQlJKZGk3S2ZrcktaMk5YU0M3YnhtQmNiZENLUzEvU1haYUV6Mnc4cVA3cllPRDE2RVBQVVFaYVpwNVZlaCtHVk0vekcvamRUQVJLbzh3ZGRybXFuSEJiVlhicWlLVVZqSmNWbjYvc1FjVHdRUFBiNDBxK2d3OWhBZUhuRWUvNnYyZVNJcEFzeXVXNFpSTFYvSDNIdDd6NUdpRGtBSm9RM1BZWTM3ZEsyU0pEVWRzMTV1TG9ieWZKMWZxcy9rRXZGb1E1bVFNVFlJcGo4ZFRzWFJ3a1pkTEJmTnBpRms4TTlRNk1OcnhwSVZlcVVvVVJhSlgyZnRwSTJ3aGtPRExoRXlNN2g5aGIrenlNZWVqWTVZSHN6bEdSdEJZWWdyVjNiQlhTdy9aTGVyVnhJNVN4ZGZ3VURDb3N4SmhnLysrRVN6QjBITnB5Z0tBWmNwb1FtL3lpdVQ5dVhKMnJzajN4RXkxYmd6RnpRbmJ5eXl2TFNOWldjL3NJbi92V1NBSFU5cDZpa0VZK1NwSDlEQzJlK3lDbUoxemE2V2t1Z3VzNTdYeW11bjlsT1JXK1BQVEIvZ3N5b3UvcGx6d2hRMTZWTE1zcnkwaldWblA3Q0ovNzFrZ0IxUGFQem1SREdYTGpsbS9UVWJzMkthdjFCNnJNNVppY3VzeEtYV0tyVkQ5Ty9RRzRLT093K3VtRWF0SFRocWZ2OXhQTDA5ODdwQldFOGJpSjZzd0JJbzl1OWVPUGQ0TFBuQnh1QmhaMmV1MUlYQTBxK0xvdUVMSXlFQkxpbmxsc0RQTTBrSDVuMFU1Nzk4VjEyQklURnFoV0RRbXM1YzlIRE5wV29LdVlTNkpDbUxsSUVoRnR2eFp2dnExNE56NnRucUZvWWRzS2d6MGFqRmlnKzdGaW1hVTlyY1NVRUdhNUYwcUlocDRrTU1xZ2Z0M3FYRzArV2VlemZRWjhydW9HUFdJUmo4YjhlbkdkZ1BRRjFoTXdOT2xoa25aY1BQcFpqNDFWVTZUK0d6bE55Y3NyeTBqV1ZuUDdDSi83MWtnQjFQYitQZTJhUmZsZjN3T3Q2YTVuKzRNaFlvaG5NWDdPaklST1Y1RXpzNEFVQzhzcnkwaldWblA3Q0ovNzFrZ0IxUGFiQjQ5N2pVZE1qb3lFbVVCVjM0WFYxeVJXMWU5Z1VKWThGQ3ZlaGxkMmtNc3J5MGpXVm5QN0NKLzcxa2dCMVBaOTZ2ZUZmNW8wNkhsRmhGa0VialZOcnRHdmtWdlZ2TmxiVWxJRGkrRWorT0tGV1FWMktIdzd4SDc0RXZMSmdpUjkzaWxjRVhMQTQ1TlgxZkdNemZnNUtWTEFxVGZxaWlTakU1M25TRlFOWmhNVWhhOHZRRVI1SVdXQUF3VGVXdXZ4dzBKOWdaL3pTUTlQeVcyTG1YSyt0M0hUeEpDbkszY3p1TWFBTFZWOStJdnEyOStvODJjcUZIKzg5Ym9vWHJlSytncDJlT1ZwNnBSZTZJTDJXSW5ZenBReSt3Nzg4N0RrSnl2djJ3bk9KMUZJLzZadk13cStkVUV0RGViV2hFblcrK0YyM2ExUHpmdy9tQ0tYd2w1UHl5dkxTTlpXYy9zSW4vdldTQUhVOW5vR2R6VnRkYVkwRVBiYkZ3SGxsdFVVeFUxSXpLLzViVVlRak43NEJUUHRXdlpCWCtWdzlZRU5GS3RsMTFCa3pyTEhFYjRiRklZQkNxSFRpSEFFMmFpZ0hKOG1tdTVuU0dUdkNUZE8yYVEyUDNTWERYdjZCUWNRenE0NmhZT3UxUUExL05KUU5EcG9IRDB3TlNnSnJUcENIa244MGFMakRpLy9KTGlpV1YxanJHUEV3cnFJbGhLMTZjV2J2WEpLYk1zcnkwaldWblA3Q0ovNzFrZ0IxUGJwVGY4QlNCSE9zRUJkQWVnYm1OUEVOMUdKRnFOai9COFZDTFFXVEdVUUZFT0IybG9Ba3hJazE1M2I4TWlOQmdYTEs4dEkxbFp6K3dpZis5WklBZFQyQThma1lnU3g2WjJ5T25xcnFZeFp4K1pqRXBTbDJxVkZNYU5Fd0gzMFdGakxLOHRJMWxaeit3aWYrOVpJQWRUMmlWN3pJTjBlTnpqdzl0MW9ySFppVUFwL1QvT3czRlhBZEZKQUswTExuWWkvVWc4TXNJcGRNalg5dzlXcWs2cVZ5eXZMU05aV2Mvc0luL3ZXU0FIVTlwampBZlYvNy9wZTFNT0sxSkJ1cVpHNFQ4dUZaamlReTZyNTBlQ1crU1kvRmZiOVIyb0JianRTaUcxRGlCZ0hUM0FXeUFQZEF3NWMvdnlKSjdIRTZhbmhSV1RTQk1wb0V2dWtZdGNmaVVoL3l5dkxTTlpXYy9zSW4vdldTQUhVOW9EV3VlbEFxZmpNN2ZDSmZPYXN3UWdrbHBXVVV5akFzd29EdzZOWEg3aTBQbHpOcW9aR1NEd1RLUEF1bXpZaEgwV1NjZ2VqR0Z0YWFYMldzVk1NaEZlR2o5UEhvalF6aFBTL2h3RjErK2lsb2dhWTVreGRyTERVZFR1NCtNRXpsWXo3UEt5UThLankrendtY3lWM1M4ZEUrbWNhakRCUUQvRmZiOHQvaHN2bnpwUXkrdzc4ODdEa0p5dnYyd25PSjhzcnkwaldWblA3Q0ovNzFrZ0IxUFlpREthMWszQ0ZtN1VzRmpaMFdtcHp6cFF5K3c3ODg3RGtKeXZ2MnduT0o4c3J5MGpXVm5QN0NKLzcxa2dCMVBZYjJudUJBejVCN0hxRnpUTytjVFp5bXB1YW5maW5vSkpCRWpodkpFRUhxYzZVTXZzTy9QT3c1Q2NyNzlzSnppZTd2emxOaUtka21NQXp2YlpQOTlVSnl5dkxTTlpXYy9zSW4vdldTQUhVOW8rbmZia08xWTl0UEQxOWhXN2NBeHZsR2lqdXczQmFQMUszdm9obzdBNWdHcVB3ZHJCUGU3bzgydjZVYnZqc1N3eU9CVHBqeks0ZTd6YjlNWmNTUGlHelZjQW8vS3VGNmU2Q3FnM2ZqVGYxZll6WHF6ZU0vWDdBakNFY1VXS3RpY3NyeTBqV1ZuUDdDSi83MWtnQjFQWmJGVllEaW1sdUNPMEFKR2tqclhWVFBPOXk1Y2dTdUN2VVA4KzZBV2FFNWQvZzJhYWVwUTRxbytXUXVCb29BcE94ODd3SWM2YTNPQU5lcG14Skhid295eXZMU05aV2Mvc0luL3ZXU0FIVTlzdHJFWGpvYlh6OGYyR1pVVUFycTk0VFVORUlLTFF2dURBbEVSRFBQVVh1Y29VZkRXWHZxQVNER0o3NEF4MEVHK0VYTXdEcTRqeHJ2V01JVFo2Nm1VVkJlSEJVTGFuZzZyeSsvZFJWNU4zRXl5dkxTTlpXYy9zSW4vdldTQUhVOXRoR0VSdmZQRkx3TlJEVlphelEzWTR4VlhDcHY5dXhtNXl3TnFYK2p3bXd5eXZMU05aV2Mvc0luL3ZXU0FIVTluek1vQjV6UnN0ZnFNVEt1OFIyb2xITUljRUdlVk4vakxrSWNwNWRhdGVsZHZHaEtyTElqeWExMXlCcDJMTXR6UDlhSTdRaHRqcFBYSVFMM1hQVzcrNnpSRW9raFB2ZFJjSkkyVFhsSEJFWm9oblptR21pV0M3VTRvMHVra3lQQXhFYU9ObklWd2xEOURwb2x1L1F1a1NNTjIza21tbGJnU20rSXlvZjZsMUY5NHA0NlVzL2craXVXSEEyc2RIdUVBN25KMnZ1bGlGeFkxTzJqZlhsS3c2V3lrU2Z5YUVhdU8zL1hJblpiaDlnODlIY2llOHlGaUNranBOSlFqTFE3NTRBNU1WSFFyQThMSm80Y2RGeVVUcHp0UnFaVmZ4aHRDNmN5ZUk0V0FZZi9FaGNNSDZWdCtlS3lLdm93MmFJYzdhRXA4bmFjbHBxM0NtZUplcEVpN2oxelIrVkZFNjlReWJVc2RiNU9nbEN6enJWUFpySmh2OHQ0NUphSUxxSWx6WFh2aFJqeExxZEZxWUc2MHFrM3BFUHkvK0wvVURJcnZRS2k1RDRnb1hGUE85eTVjZ1N1Q3ZVUDgrNkFXYUU1WVJHanpsRThldTlFem5HSlFvTUhkNzRTM2xWeFUrV1FTMGRnSUYwb2RySlBPOXk1Y2dTdUN2VVA4KzZBV2FFNVQ0K1BkU0FnQk8yY0hmdWRsNkt5S0pSNndQd1BGcDhwZ3ZiMnZhZ1VjMFZsYTNBdDRLakI5SEppYW5CUm9temNUQ0lCeFNVRERFcFYxdGhwSU1tb1RGY0ppOUdrdURmWVQyUG5MdEN3aXBEQzlBNXdTMWNoQldvRTBmMmd4a3JkcWZLMnZHLy9iWm8zVUpFYTZ4QUltNkVlK2dVVE5qdVZCQVdFclBTUUJzSG5PNTI5ZkVUemFHb3JjaGJiZER6Vm1HV3hCbVNCbTg3alZ1aHhvY1lHREdjN25iMThSUE5vYWl0eUZ0dDBQTldrUklYK0JUSllORis1ZFYxVXhLTG00V1FiZG1YWVloODJVUDdOTjdwU1FET2xETDdEdnp6c09RbksrL2JDYzRudXJIVTB4RGRldVZtcTUvV0RUMXVoRHp2Y3VYSUVyZ3IxRC9QdWdGbWhPV0c5NVNXV0ZPS3ZLbnlycEpVS1VQbTdHY0c1UW8vcDBQeUpBTmhKL2hjS1NsWm05S1FXbSswTFVoREdWeldRWnN5OVJDOUhmZ2t2UlQ2bWx2SEx1S1lWRmFxOUhlbVJ0dldlbFZhQzl6aEFab2VVS25hNXAySUF3Y3R5aDRJUm5VbjE5UVJ4SWRhK1R4K25LZkQ0R1JnQlp4S1BhbUI2aXBNNi9Obm9OTGxieXJJRUJIL0hxWE1LQi9BS1JWemx4V255ckJGTTNrVkM3UnpnWTd0U1ZCcWNFUk1Hc2dSVEVKZzhyVE5OOFNGV0grUXUxWHNMYzA1VGEzV0NibnBWWjF4enFnNUZLTXNCMzc3ZitMTTlvbUJvbEQwSjJwUUFUTkY2UFliL0hvQ0lPTzZmNFdhcE9qWUN3eVJxdmdXZHI1dnpXMjFTblRkRDNoWTIrb1NqVG9Xai9ETWFTRnhWY1o3TW9XbDJvbjhHdEdRekd0REFKNStUM2hnTWNjb2M3OHhWU2s0ZHNZaWd3ZWtHMFNYSlpJNk0zdk5yRElaOHIvWlUrZVdQcHZhZ2V1d2g1bEpBR3o3ZTJhUzJRa25WbzNmcjczandnOE5QMUlzT0IxOS8raWEwNW9KUS9BUHQ3RTJhTmx2MHp6VzYzbEMxbUNJYmtsUmFtSnFacWF5Y1lGb3FBKzZLNnkyYXl4QnVoZnc2MjBvcGNFMngxNjhRTkROTkxlK3FYak1hRGFtemJvbVBPZytrblBFSkVvWnR1RmptUHptcmdqTkdDTnQzWCtBK01HQktUN0RGVkV1Nm16R2FRaUNhdWgzUTNFSitaZ1BuNE4ySTc2bUpGTkV5YllSR2pqWnlGY0pRL1E2YUpidjBMcEU0dUg5S3JFcS84YzlQbEsxOFR0VDg1Z3AzTUNWZE9Zekp3UUg0dmQ5K01GKzBreWZnd3YyWWtTRmhOZktYcU80ZlU1c1JRNkZOTDBBNVZnWGppVGtqeTRNQ3RhQ2tpK2VJQ0RYK1ZDQk02NVY5cWRxR3ovTFNKbkZ4SXZROGtCeFxcXFxcXFwiKVxcXCJ9XVwiLFwicHJveHlcIjpcIlwifSIsInBpY1VybCI6Imh0dHBzOi8vZ2l0Y29kZS5uZXQvcXFfMzIzOTQzNTEvZHIvLS9yYXcvbWFzdGVyL2ltZy/mlofku7bnsbvlnosyL+aWh+S7tuWkuS5zdmciLCJ0aXRsZSI6IumVv+mjjua4oSAifQ==
UkPVAEMb,Disk Formatting script for console in python,UNIXnerdV,Python,Thursday 29th of June 2023 08:15:19 AM CDT,"""""""
	Python Disk Formatter - Remade
	Created on: 21 May 2023
	Created by MrUNIMan
	
	Copyright (C) 2023 MrUNIXMan

	This program is specific for Linux not any other due to course time.
	
	This was a remade version for a college project. So I decided to give the 
	code out
	
	
	Requirements for Python3 to be installed via PIP.
	
	Prettytable
	Psutil
	
	
	On line 654 uncomment to make the program actually write over the disk as
	the program was intended to be a mock program.
	
	#os.system(argv);



""""""
# imports

import os, datetime, sys, platform, time;
from subprocess import run, PIPE
from prettytable import PrettyTable;




# Dictionary if required


# Class - OOP (Object Orientated Programming)

""""""
   Methods must be kept with inside the class group now
""""""

# Screen Format for the Menu


# Tuples for Blocksize and Phase

PHASE = (1,2,3);   # Default phases used for the 3 devices
BLK_SIZE = (512,1024,2048, 3097, 4096);  # Default blocksizes
MAX_DISK_LIST = 0;  # To be used to prevent overdoing it.

# Default Index set for the tuples
PHI = 0   # Phase Index
BSI = 0  # Blocksize Index
DI = 0  # Disk Index

# Log file




class formatOOP():
	def __init__(self):
		
		self.inputdev = [];        # Contains /dev/zero, /dev/random and /dev/urandom
		self.outputdev = ""/dev/null"";	   # Default value Hard disk to be erased.
		self.blocksize = 4096;	   # Blocksize
		self.phase = 0		   # Phases for 1 to 3
		self.maxphase = 0	   # Max Phase set by phase select
		self.drivelist = []    # List of drives from lsblk
		
		# Phase related stuff  - These to show on the table
		
		self.phase1_start_time = 0;
		self.phase2_start_time = 0;
		self.phase3_start_time = 0;
		
		self.phase1_fin_time = 0;
		self.phase2_fin_time = 0;
		self.phase3_fin_time = 0;
		
		# Statuses - this will update on the tabled
		
		self.phase1_status = ""Running"";
		self.phase2_status = ""Running"";
		self.phase3_status = ""Running"";
		
		# Phase Status - This will show time after
		self.working = ""Running"";
		
		# Phase Values
		self.phase1_val = 1;
		self.phase2_val = 2;
		self.phase3_val = 3;
		
		# Input device
		self.phase1_ip = 0
		self.phase2_ip = 0
		self.phase3_ip = 0
		
		# Start Date/Time
		self.datetime_start = 0;
		
		
		
		
		
		
		
	# Some functions that can be reused without needing to re-write them
	
	def pause(self):  # Waits for user input.
		print()
		dumbkey = input(""Press Enter to continue......."");
		print()
		
	def update_time(self):   # This is used for different purpose to the date_time
		now = datetime.datetime.now();
		TIME = now.strftime(""%H:%M"");
		return TIME;
		
	def update_date(self):   # This is used for different purpose to the date_time
		now = datetime.datetime.now();
		DATE = now.strftime(""%d/%m/%Y"");
		return DATE;
	
	def update_date_time(self):
		# This works
		# shows like this:     22/05/2023 - 09:18

		now = datetime.datetime.now()
		DATE = now.strftime(""%d/%m/%Y"");
		TIME = now.strftime(""%H:%M"");
		
		DateTimeInfo = DATE + "" - "" + TIME;
		
		return DateTimeInfo;
		
	# Functions to add to the quing system
	
	def que_device(self, item):
		self.inputdev.append(item);
	
	def deque_device(self):
		if len(self.inputdev) < 1:
			return None
		return self.inputdev.pop(0);
		
	def print_que_dev(self, i=1):
		print(""Phase"");
		print(""Queue     Device to use"");
		print(""-------------------------"");
		
		for x in self.inputdev:
			print(""{0}         {1}          "".format(i, x));
			i += 1;
			
	def print_que_dev_phases(self, phase, timeinfo, i=1):
	#def print_que_dev_phases(self, i=1, phase, timeinfo):
		print(""Phase"");
		print(""Queue     Device to use"");
		print(""-------------------------"");
		
		for x in self.inputdev:
			print(""{0}         {1}          "".format(i, x));
			i += 1;
			
	def get_os(self):
		OS = platform.system()
		return OS;
		
	# These 2 is for the blocksize and phase changes at the menu
	def update_phase(self,i):
		self.phase = PHASE[i];
	
	def update_blocksize(self,i):
		self.blocksize = BLK_SIZE[i];
	
	
	def get_disks(self):
		argv = ['lsblk -d -o name -n']
		output = run(argv, shell=True, stdout=PIPE)
		
		output_string = output.stdout.decode('utf-8');
		output_string = output_string.strip();
		
		results = output_string.split('\n');
		return results;
		
	def update_disklist(self,i):
		self.outputdev = self.drivelist[i]
	
	
	# Messsage Boxes
	
	
	def DisplayStartFormat_Confirm(self):
		os.system('clear');
		print();
		print(""Confirm Operation..."");
		print();
		StartFormat = PrettyTable([""Format Options"", ""Selected values""])
		disk_row = ""Disk to erase:"", self.outputdev ;
		phase_row =  ""Phase(s):"", self.phase;
		blocksize_row = ""Blocksize:"", self.blocksize
		
		StartFormat.add_row(disk_row);
		StartFormat.add_row(phase_row);
		StartFormat.add_row(blocksize_row);
		
		print(StartFormat);   # Prints the table.
		print()
		print(""Time can be few minutes to hours or days to complete"");
		print();
		print(""This will be destructive to the chosen disk and will erase it"");
		print(""so do not expect data recovery being possible."");
		print();
		print(""You are about to erase the selected disk"");
		print(""Continue with process?"");
		print();	
		
	
	# Yes/No Question

	def YNquest(self, message, message2):
		print();
		print(""="" * len(message))
		print();
		print(message);
		print(message2);
		print();
		print(""Yes/No:"");
		print();
		print(""="" * len(message))
		print();
		
	
	
	
	
	
	# This will give a layout of the main menu
	# Must look presentable to the user using the program
	
	def Draw_main_menu(self):
		os.system('clear')
		
		DateTime = self.update_date_time();    # Gets the date and time
		Os = self.get_os();
		print();
		print(""Formatter running on {0} - Copyright (C) 2023 MrUNIXMan"".format(Os));
		print();
		print(""Date/Time: "" + DateTime);
		print(""-""*30);
	
		# Other Information
		
		DeviceInfo = PrettyTable([""Target Disk"", ""Blocksize Selected"", ""No of Phases""]);
		output = self.outputdev, self.blocksize, self.phase;
		DeviceInfo.add_row(output)
		print(DeviceInfo);
		
		
		#Options
		print();
		print(""1. Select Disk"");
		print(""2. Set Block Size value (Press number and enter to scroll through)"");
		print(""3. Set phase amount (Press number and enter to scroll through)"");
		print(""4. Commence Format"");
		print(""=""*70);
		print(""5. Help"");
		print(""6. About Format utility"");
		print(""7. Quit"");
		print()
		
	
	
	def Draw_Status_Screen(self,dateinfo, inputdev, phasenumber):   # This will replace the Format Screen
		""""""
		The Table SHould look like this
		
		Formatting Disk:  /dev/sda using 4068 Blocksize value
		Format Date/Stat time
		
		+---------------------------------------------------------+
		|Phase  |  Time Start | State/Time Finish | Input device  |
		+---------------------------------------------------------+
		| 1     |             |   Running         | /dev/zero     |        
		| 2     |             |   *               |               |
		| 3     |             |   *               |               |
		+---------------------------------------------------------+
		""""""
		
		
		
		os.system('clear');
		
		
		print()
		print(""{0} Phase - Format Started on: {1}"".format(self.phase, dateinfo));
		print();
		print(""Erasing Disk {0}"".format(self.outputdev));
		print(""Using Blocksize value {0}"".format(self.blocksize));
		print();
		
		print();
		StatusTable = PrettyTable([""Phase"", ""Time Start"", ""State/Finish Time"", ""Erasing with""]); # Makes a table

		
		
		if(phasenumber == 1):
			StatusOut = self.phase1_val, self.phase1_start_time, self.phase1_status, self.phase1_ip
			StatusTable.add_row(StatusOut)
			
			
		
		elif(phasenumber == 2):
			P1Out = self.phase1_val, self.phase1_start_time, self.phase1_status, self.phase1_ip
			# Add rows
			StatusTable.add_row(P1Out)
			
			P2Out = self.phase2_val, self.phase2_start_time, self.phase2_status, self.phase2_ip
			StatusTable.add_row(P2Out)
			
			
		
		elif(phasenumber == 3):
			P1Out = self.phase1_val, self.phase1_start_time, self.phase1_status, self.phase1_ip
			StatusTable.add_row(P1Out)
			
			P2Out = self.phase2_val, self.phase2_start_time, self.phase2_status, self.phase2_ip
			StatusTable.add_row(P2Out)
			
			P3Out = self.phase3_val, self.phase3_start_time, self.phase3_status, self.phase3_ip
			StatusTable.add_row(P3Out)
			
		print(StatusTable);
		print();
		
		
		
	def Draw_Status_Complete_Screen(self, phasenumber):   # This will show after the format
		
		""""""
		The Table SHould look like this
		
		Formatting Disk:  /dev/sda using 4068 Blocksize value
		Format Date/Stat time
		
		+---------------------------------------------------------+
		|Phase  |  Time Start | State/Time Finish | Input device  |
		+---------------------------------------------------------+
		| 1     |             |   Running         | /dev/zero     |        
		| 2     |             |   *               |               |
		| 3     |             |   *               |               |
		+---------------------------------------------------------+
		""""""
		
		
		
		os.system('clear');
		
		dateinfo = self.update_date_time();
		print()
		print(""{0} Phase - Format Completed"".format(self.phase));
		print()
		print(""Started:   {0}"".format(self.datetime_start));
		print(""Completed: {0}"".format(dateinfo));
		print(""="" * 35);
		
		
		print();
		print(""Erased Disk {0}"".format(self.outputdev));
		print(""Used Blocksize value {0}"".format(self.blocksize));
		print();
		
		print();
		StatusTable = PrettyTable([""Phase"", ""Time Start"", ""State/Finish Time"", ""Erased with""]); # Makes a table

		
		
		if(phasenumber == 1):
			StatusOut = self.phase1_val, self.phase1_start_time, self.phase1_status, self.phase1_ip
			StatusTable.add_row(StatusOut)
			
			
		
		elif(phasenumber == 2):
			P1Out = self.phase1_val, self.phase1_start_time, self.phase1_status, self.phase1_ip
			# Add rows
			StatusTable.add_row(P1Out)
			
			P2Out = self.phase2_val, self.phase2_start_time, self.phase2_status, self.phase2_ip
			StatusTable.add_row(P2Out)
			
			
		
		elif(phasenumber == 3):
			P1Out = self.phase1_val, self.phase1_start_time, self.phase1_status, self.phase1_ip
			StatusTable.add_row(P1Out)
			
			P2Out = self.phase2_val, self.phase2_start_time, self.phase2_status, self.phase2_ip
			StatusTable.add_row(P2Out)
			
			P3Out = self.phase3_val, self.phase3_start_time, self.phase3_status, self.phase3_ip
			StatusTable.add_row(P3Out)
			
		print(StatusTable);
		print();
		
		
	def writelog(self, message):
		""""""
		Log files are written like this
		
		logfile = open(""/tmp/format-utility.log"", 'a');				# Open as Append
		logfile.write(""Format log started: {0} - {1}\n"".format(LogDate, LogTime));
		logfile.flush();
		
		""""""	
		DATETIME = self.update_date_time();
		
		logfile.write(""[ {0} ]: {1}\n"".format(DATETIME, message));
		logfile.flush();
		
	
	
		
	
		
		
		
		
f = formatOOP()	# Instancing  - This only needs to be done once

""""""
Log file writing at Start and Finish displays
differently to rest of the log

This is why is done like this while
rest is called from an OOP function

""""""
logfile = open(""format-utility.log"", 'a');				# Open as Append
LogDateTimeStart = f.update_date_time();
logfile.write(""\n"");
logfile.write(""Format log started: {0}\n"".format(LogDateTimeStart));
logfile.write(""\n"");
logfile.flush();



# Code to test - Start program puts all the procedural and functional stuff
# inside a main function which will deal with OOP objects particularly for using loops.

def select_disk():
	
	global MAX_DISK_LIST, DI
	
	
	
	
	sdiskkey = 0;
	DISKS = f.get_disks()   # Calls the get_disks method in class
	
	for x in DISKS:
		
		""""""
		Filter unwanted Disk entries 
		
		loop are found on Ubuntu Linux snaps as if they are separate
		disks. Although they don't show in df unless you do df -aT
		you will find they use a squashfs filesystem.
		
		
		To be worked on
		
		""""""
		
		if(""zram"" in x ):  # Ram Disk on ASUS PC
			continue;
		if(""loop"" in x ):  # Ubuntu's snap
			continue;
		else:
			disktmp = ""/dev/{0}"".format(x);
			f.drivelist.append(disktmp);   # Forms a newlist in the class
	

	MAX_DISK_LIST = len(f.drivelist)
	count = 1;

	
	while sdiskkey != 3:
		
		os.system('clear');
		
		print(""Select Disks"");
		print()
		print(""List of disks on the system"");
		print()
		
		DisksTable = PrettyTable([""Device No"", ""Device name"", ""Selected""]);
		
		
		
		for disks in f.drivelist:
			
			
			# This shows an arrow next to the disks in form of <===
			if(disks == f.outputdev):
				selected = ""<===""
			else:
				selected = "" "";
			
			
			DiskEntry = count,disks, selected;
			DisksTable.add_row(DiskEntry);
			
			
			
			if(count < MAX_DISK_LIST):
				count += 1;
			else:
				count = 1;
		
		print(DisksTable);
		
		print();
		print(""Selected Disk: {0}"".format(f.outputdev));
		print();
		print(""1. Reset disk back to /dev/null"");
		print(""2. Circulate through the disks"");
		print(""3. Return to previous"");
		print()
		
		try:
			sdiskkey = int(input(""> ""));
			
			if (sdiskkey == 3):
				Message = ""Selected Disk: "" + f.outputdev; 
				f.writelog(Message);
				f.drivelist.clear();   # clears the list
				break;
				
			if(sdiskkey == 1):
				f.outputdev = ""/dev/null""
			
			elif(sdiskkey == 2):
				if(DI < MAX_DISK_LIST):
					f.update_disklist(DI)
				else:
					DI = 0; # Reset
					f.update_disklist(DI)
				DI += 1
				
			
		except ValueError:
			print();
			print(""Use only intergers"");
			f.pause()
		
		
		
	
def start_format():
	
	
	f.DisplayStartFormat_Confirm();  # Display Dialog
	#f.YNquest(""You are about to erase the selected disk"",""Continue with process?"");	
	choice = input(""(Yes/No):> "");
	
	if(choice == 'n' or choice == 'N' or choice == 'No' or choice == 'NO' or choice == 'no'):
		return 1;
	
	
	
	# Actual Start of the process.
	
	elif(choice == 'y' or choice == 'Y' or choice == 'yes' or choice == 'YES'):
		# Queing the input devices
		# List is cleared after the operation is complete
		#
		PHCount = 1;
		
		
		if(f.phase == 0):
			print();
			print(""No Phase Selected, Aborting...."");
			print();
			f.pause();
			return 1;
			
		if(f.phase == 3):
			f.maxphase = f.phase 
			f.que_device(""/dev/zero"");
			f.phase1_ip = ""/dev/zero"";
			f.que_device(""/dev/random"");
			f.phase2_ip = ""/dev/random"";
			f.que_device(""/dev/urandom"");
			f.phase3_ip = ""/dev/urandom"";
		elif(f.phase == 2):
			f.maxphase = f.phase 
			f.que_device(""/dev/random"");
			f.phase1_ip = ""/dev/random"";
			f.que_device(""/dev/urandom"");
			f.phase2_ip = ""/dev/urandom"";
		elif(f.phase == 1):
			f.maxphase = f.phase 
			f.que_device(""/dev/urandom"");
			f.phase1_ip = ""/dev/urandom"";
	
	
		print(""Contents of devices to use for format"")
		print(""=""*40);
		
		DATETIME = f.update_date_time()  # This keeps the whole date and time it started
		f.datetime_start = DATETIME;  # This can be shown on the final screen
		f.writelog(""{0} phase Format Process - Started"".format(f.phase));
		f.writelog("" "");

		print()
		
		for x in f.inputdev:
				
			if(PHCount == 1):
				PH1TIME_START = f.update_time();
				f.phase1_start_time  = PH1TIME_START;
				
				
			elif(PHCount == 2):	
				PH2TIME_START = f.update_time();
				f.phase2_start_time  = PH2TIME_START;
				
			
			elif(PHCount == 3):
				PH3TIME_START = f.update_time();
				f.phase3_start_time  = PH3TIME_START;
				
			
			f.Draw_Status_Screen(DATETIME, x, PHCount); # Draws the table here
			
			
			argv = ""dd if={0} of={1} bs={2} status=progress conv=notrunc,noerror"".format(x, f.outputdev, f.blocksize)
			
			# Writes to a log file
			f.writelog(""Phase {0} Format Started"".format(PHCount));
			f.writelog(""Executing command: {0}"".format(argv));
			
			
			print();
			print(argv) # mimics the action - Where execution should occur.
			print();
			
			#uncomment this if you are going to wipe the disks.
			#os.system(argv);
			
			# Comment this if you going to use os.system
			time.sleep(60);
			
			
			# Update Phase Finish Times
			
			if(PHCount == 1):
				PH1TIME_FINISH = f.update_time();
				f.phase1_fin_time = PH1TIME_FINISH
				f.phase1_status = f.phase1_fin_time
				
			elif(PHCount == 2):
				PH2TIME_FINISH = f.update_time();
				f.phase2_fin_time = PH2TIME_FINISH
				f.phase2_status = f.phase2_fin_time
				
				
			elif(PHCount == 3):
				PH3TIME_FINISH = f.update_time();
				f.phase3_fin_time = PH3TIME_FINISH
				f.phase3_status = f.phase3_fin_time
			
			
			f.writelog(""Phase {0} Format Complete"".format(PHCount));
			
			
			if ( PHCount < f.maxphase):
				PHCount += 1;
			else:
				PHCount = 1;
			
		
		f.Draw_Status_Complete_Screen(f.phase);
		f.writelog("" "");
		f.writelog(""{0} phase format process complete.."".format(f.phase));
		
		
		print();
		print(""Resetting the Program for next use...."");
		print(""=""*50);
		f.inputdev.clear();   # Clears the list for the next use
		print(f.inputdev)
		f.phase1_status = ""Running"";
		f.phase2_status = ""Running"";
		f.phase3_status = ""Running"";
		
		f.pause();
		
		

			
			



def start_program():
	
	key = 0;
	
	while(key != 7):
		f.Draw_main_menu();		
		
		try:	
			key = int(input(""> ""));
		
			if(key == 7):	# Quits the program by breaking the loop
				LogTimeDate = f.update_date_time();
				logfile.write(""\n"");
				logfile.write(""Format log Ended: {0}\n"".format(LogTimeDate));
				logfile.flush();
				logfile.close()				# Closes the log file
				break

			if(key == 1):
				select_disk(); # Passes to another function

			elif(key == 2):
				print(""Set blocksize"");
				global BSI;  # Blocksize index for tuple
				
				if (BSI < 4 + 1):
					f.update_blocksize(BSI)
				else:
					BSI = 0; # Reset
					f.update_blocksize(BSI)
				BSI += 1
				
			elif(key == 3):      # Sets the phase index which is handled by the update phase
				print(""Set Phase"");
				global PHI
				
				if(PHI < 2+1):
					f.update_phase(PHI)
				else:
					PHI = 0; # Reset
					f.update_phase(PHI)
				PHI += 1;
			
			elif(key == 4):
				start_format();
			
			elif(key == 5):
				print(""Show Help"");
				time.sleep(10);
		
			elif(key == 6):
				print();
				print(""Rewritten formatter for College project by MrUNIXMan - 2023"");
				print();
				f.pause();
		except ValueError:
			print(""Please use numbers to select on the menu"");
			f.pause();
	
	
if __name__ == ""__main__"":
	start_program();
	exit();
"
C7Vy0qmk,ahttpserver,misaalanshori,Python,Thursday 29th of June 2023 07:50:18 AM CDT,"try:
    import asyncio
except ImportError:
    import uasyncio as asyncio

import gc


loop = asyncio.get_event_loop()

def simpleHTML(text):
    return f'''<html><head><title>{text}</title></head><body><h1>{text}</h1></body></html>'''

class HttpServer:
    def __init__(self, host=""0.0.0.0"", port=80):
        self.host = host
        self.port = port
        self.routes = {}
        self.server = None

    def start(self):
        loop.create_task(asyncio.start_server(self.__handle_request, self.host, self.port, 4096))
        loop.run_forever()

    def add_route(self, method, path):
        def decorator(callback):
            self.routes[(method, path)] = callback
            return callback
        return decorator

    async def __handle_route(self, request):
        print(""Handling: "", request)
        if (request[""method""], request[""path""]) in self.routes:
            return await self.routes[(request[""method""], request[""path""])](request)
        else:
            return [""404"", ""text/html"", simpleHTML(""Not Found"")]
    
    async def __process_header(self, reader):
        header = (await reader.readline()).decode().split("" "")
        path = header[1].split(""?"")
        query = {}
        if len(path) > 1:
            query = dict(q.split(""="") for q in path[1].split(""&""))
        return {""method"": header[0], ""path"": path[0], ""query"": query}
    
    async def __handle_request(self, reader, writer):
        gc.collect()
        result = await self.__handle_route(await self.__process_header(reader))
        writer.write(f""HTTP/1.0 {result[0]} Works\r\n"")
        writer.write(f""Content-Type: {result[1]}\r\n"")
        writer.write(f""Content-Length: {len(result[2])}\r\n"")
        writer.write(f""\r\n"")
        writer.write(result[2])
        print(""Sending: "", result[2])
        await writer.drain()
        await asyncio.sleep(0.5)
        writer.close()
        await writer.wait_closed()
"
