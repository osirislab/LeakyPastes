id,title,username,language,date,content
1qHcvLeG,Frustum,OrangoMango,Java,Sunday 21st of May 2023 12:40:29 PM CDT,"import java.util.Arrays;

public class FrustumPlanes {
	public static class Plane {
		public final Point3D point;
		public final Vector3D normal;

		public Plane(Point3D point, Vector3D normal) {
			this.point = point;
			this.normal = normal;
		}
	}

	public static class Point3D {
		public final double x, y, z;

		public Point3D(double x, double y, double z) {
			this.x = x;
			this.y = y;
			this.z = z;
		}
	}

	public static class Vector3D {
		public final double x, y, z;

		public Vector3D(double x, double y, double z) {
			this.x = x;
			this.y = y;
			this.z = z;
		}
	}

	public static Plane[] calculateFrustumPlanes(Point3D cameraPosition, double zNear, double zFar, Vector3D cameraDirection, double fovAngle) {
		// Calculate the half-height and half-width of the near plane
		double nearHeight = 2.0 * Math.tan(Math.toRadians(fovAngle / 2.0)) * zNear;
		double nearWidth = nearHeight;

		// Calculate the center and normal of the near plane
		Point3D nearCenter = new Point3D(
				cameraPosition.x + cameraDirection.x * zNear,
				cameraPosition.y + cameraDirection.y * zNear,
				cameraPosition.z + cameraDirection.z * zNear
		);
		Vector3D nearNormal = new Vector3D(
				cameraDirection.x,
				cameraDirection.y,
				cameraDirection.z
		);

		// Calculate the center and normal of the far plane
		Point3D farCenter = new Point3D(
				cameraPosition.x + cameraDirection.x * zFar,
				cameraPosition.y + cameraDirection.y * zFar,
				cameraPosition.z + cameraDirection.z * zFar
		);
		Vector3D farNormal = new Vector3D(
				-cameraDirection.x,
				-cameraDirection.y,
				-cameraDirection.z
		);

		// Calculate the corners of the near plane
		Point3D nearTopLeft = new Point3D(
				nearCenter.x - cameraDirection.y * nearHeight / 2.0 + cameraDirection.z * nearWidth / 2.0,
				nearCenter.y + cameraDirection.x * nearHeight / 2.0 - cameraDirection.z * nearWidth / 2.0,
				nearCenter.z - cameraDirection.x * nearWidth / 2.0 - cameraDirection.y * nearHeight / 2.0
		);
		Point3D nearTopRight = new Point3D(
				nearCenter.x + cameraDirection.y * nearHeight / 2.0 + cameraDirection.z * nearWidth / 2.0,
				nearCenter.y - cameraDirection.x * nearHeight / 2.0 - cameraDirection.z * nearWidth / 2.0,
				nearCenter.z - cameraDirection.x * nearWidth / 2.0 - cameraDirection.y * nearHeight / 2.0
		);
		Point3D nearBottomLeft = new Point3D(
				nearCenter.x - cameraDirection.y * nearHeight / 2.0 - cameraDirection.z * nearWidth / 2.0,
				nearCenter.y + cameraDirection.x * nearHeight / 2.0 + cameraDirection.z * nearWidth/ 2.0,
				nearCenter.z - cameraDirection.x * nearWidth / 2.0 + cameraDirection.y * nearHeight / 2.0
		);
		Point3D nearBottomRight = new Point3D(
				nearCenter.x + cameraDirection.y * nearHeight / 2.0 - cameraDirection.z * nearWidth / 2.0,
				nearCenter.y - cameraDirection.x * nearHeight / 2.0 + cameraDirection.z * nearWidth / 2.0,
				nearCenter.z - cameraDirection.x * nearWidth / 2.0 + cameraDirection.y * nearHeight / 2.0
		);

		// Calculate the corners of the far plane
		Point3D farTopLeft = new Point3D(
				farCenter.x - cameraDirection.y * nearHeight / 2.0 + cameraDirection.z * nearWidth / 2.0,
				farCenter.y + cameraDirection.x * nearHeight / 2.0 - cameraDirection.z * nearWidth / 2.0,
			   	farCenter.z - cameraDirection.x * nearWidth / 2.0 - cameraDirection.y * nearHeight / 2.0
  		);
   		Point3D farTopRight = new Point3D(
				farCenter.x + cameraDirection.y * nearHeight / 2.0 + cameraDirection.z * nearWidth / 2.0,
				farCenter.y - cameraDirection.x * nearHeight / 2.0 - cameraDirection.z * nearWidth / 2.0,
				farCenter.z - cameraDirection.x * nearWidth / 2.0 - cameraDirection.y * nearHeight / 2.0
		);
		Point3D farBottomLeft = new Point3D(
				farCenter.x - cameraDirection.y * nearHeight / 2.0 - cameraDirection.z * nearWidth / 2.0,
				farCenter.y + cameraDirection.x * nearHeight / 2.0 + cameraDirection.z * nearWidth / 2.0,
				farCenter.z - cameraDirection.x * nearWidth / 2.0 + cameraDirection.y * nearHeight / 2.0
		);
		Point3D farBottomRight = new Point3D(
				farCenter.x + cameraDirection.y * nearHeight / 2.0 - cameraDirection.z * nearWidth / 2.0,
				farCenter.y - cameraDirection.x * nearHeight / 2.0 + cameraDirection.z * nearWidth / 2.0,
				farCenter.z - cameraDirection.x * nearWidth / 2.0 + cameraDirection.y * nearHeight / 2.0
		);

		// Create the planes using the corner points and normals
		Plane[] planes = new Plane[6];
		planes[0] = new Plane(nearTopLeft, calculatePlaneNormal(nearTopLeft, nearTopRight, nearBottomRight)); // Near plane
		planes[1] = new Plane(farTopRight, calculatePlaneNormal(farTopRight, farTopLeft, farBottomLeft)); // Far plane
		planes[2] = new Plane(nearTopRight, calculatePlaneNormal(nearTopRight, farTopRight, farBottomRight)); // Right plane
		planes[3] = new Plane(nearTopLeft, calculatePlaneNormal(nearTopLeft, farTopLeft, farBottomLeft)); // Left plane
		planes[4] = new Plane(nearTopLeft, calculatePlaneNormal(nearTopLeft, nearTopRight, farTopRight)); // Top plane
		planes[5] = new Plane(nearBottomRight, calculatePlaneNormal(nearBottomRight, nearBottomLeft, farBottomLeft)); // Bottom plane

		return planes;
	}

	private static Vector3D calculatePlaneNormal(Point3D p1, Point3D p2, Point3D p3) {
		// Calculate the vectors for two sides of the plane
		double v1x = p2.x - p1.x;
		double v1y = p2.y - p1.y;
		double v1z = p2.z - p1.z;
		double v2x = p3.x - p1.x;
		double v2y = p3.y - p1.y;
		double v2z = p3.z - p1.z;

		// Calculate the cross product of the two vectors
		double nx = v1y * v2z - v1z * v2y;
		double ny = v1z * v2x - v1x * v2z;
		double nz = v1x * v2y - v1y * v2x;

		// Normalize the cross product vector
		double magnitude = Math.sqrt(nx * nx + ny * ny + nz * nz);
		nx /= magnitude;
		ny /= magnitude;
		nz /= magnitude;

		return new Vector3D(nx, ny, nz);
	}

	public static void main(String[] args) {
		// Example usage
		Point3D cameraPosition = new Point3D(0, 0, 0);
		double zNear = 1.0;
		double zFar = 10.0;
		Vector3D cameraDirection = new Vector3D(0, 0, -1);
		double fovAngle = 60.0;

		Plane[] frustumPlanes = calculateFrustumPlanes(cameraPosition, zNear, zFar, cameraDirection, fovAngle);

		for (Plane plane : frustumPlanes) {
			System.out.println(""Point: ("" + plane.point.x + "", "" + plane.point.y + "", "" + plane.point.z + "")"");
			System.out.println(""Normal: ("" + plane.normal.x + "", "" + plane.normal.y + "", "" + plane.normal.z + "")"");
			System.out.println();
		}
	}
}


"
m7CqeFiU,Untitled,westor,mIRC,Sunday 21st of May 2023 11:51:06 AM CDT,"alias _unicode {
  var -s %read = $read(Unicode.txt, nw, $+(*,$_chr2uni($1),$chr(59),*))

  if ($gettok(%read,2,59) == <control>) { var %result = $gettok(%read,7,59) }
  else { var %result = $gettok(%read,2,59) }

  $iif($isid,return,echo -at) U+ $+ $_chr2uni($1-) %result ( $+ $1 $+ )
}

alias _chr2uni { 
  var %r = $iif($isid,return,echo -at)

  if ($len($1) == 2) { %r $base($calc(($asc($mid($1,1,1)) - 55296) * 1024 + $asc($mid($1,2,1)) - 56320 + 65536),10,16,4) | return } 

  %r $base($asc($1),10,16,4)
}
"
Ne2MDp7u,flutter_put,yudiwibisono,Dart,Sunday 21st of May 2023 11:30:44 AM CDT,"import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;

void main() => runApp(MaterialApp(home: MyApp()));

class MyApp extends StatefulWidget {
  const MyApp({Key? key}) : super(key: key);
  @override
  MyAppState createState() => MyAppState();
}

class MyAppState extends State<MyApp> {
  late Future<int> respPost; //201 artinya berhasil
  String url = ""http://127.0.0.1:8000/tambah_mhs/"";

  Future<int> fetchData() async {
    //data disimpan di body
    final response = await http.post(Uri.parse(url), headers: <String, String>{
      'Content-Type': 'application/json; charset=UTF-8'
    }, body: """"""
      {""nim"": ""13594022"",
      ""nama"": ""Sandra Permana"",
      ""id_prov"": ""12"",
      ""angkatan"": ""2020"",
      ""tinggi_badan"": 190} """""");
    return response.statusCode; //sukses kalau 201
  }

  @override
  void initState() {
    super.initState();
    respPost = Future.value(0); //init
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'My App',
      home: Scaffold(
        appBar: AppBar(
          title: const Text('My App'),
        ),
        body: Center(
            child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            ElevatedButton(
              onPressed: () {
                setState(() {
                  respPost = fetchData();
                });
              },
              child: const Text('Klik Untuk Insert data (POST)'),
            ),
            Text(""Hasil:""),
            FutureBuilder<int>(
                future: respPost,
                builder: (context, snapshot) {
                  if (snapshot.hasData) {
                    if (snapshot.data! == 201) {
                      return Text(""Proses Insert Berhasil!"");
                    }
                    if (snapshot.data! == 0) {
                      return Text("""");
                    } else {
                      return Text(""Proses insert gagal"");
                    }
                  }
                  // default: loading spinner.
                  return const CircularProgressIndicator();
                })
          ],
        )), //column center
      ), //Scaffold
    ); //Material APP
  }
}
"
KNDdHB2H,asd,rejcsibejcsi,PL/SQL,Sunday 21st of May 2023 11:24:54 AM CDT,"CREATE OR REPLACE TRIGGER constraint_trigger
  BEFORE INSERT ON reviews
  FOR EACH ROW
BEGIN
   IF :NEW.rating > 10 THEN
      RAISE_APPLICATION_ERROR(-20000, 'Rating cannot be higher than 10');
   END IF;
END;

"
QnM8FcNA,Untitled,0andrejj0,C++,Sunday 21st of May 2023 11:07:18 AM CDT,"#include ""api.hpp""
#include <ostream>
#include <string>
#include <vector>
#include <map>
#include <queue>
#include <iostream>

using std::cout;

DFA dfa_minim(DFA &d) {

    std::cout << ""ABOB\n"" << std::endl;

    int n = d.size() + 1;
    int npos = d.size();
    std::vector<std::vector<std::pair<int, char> > > g(n);
    std::vector<int> term(n);
    std::map<std::string, int> numOfState;
    {
        int i = 0;
        for (auto& state : d.get_states()) {
            if (numOfState.find(state) == numOfState.end()) {
                numOfState[state] = i++;
            }
            term[numOfState[state]] = d.is_final(state);
        }
    }
    {
        for (auto& from : d.get_states()) {
            for (char c : d.get_alphabet()) {
                if (d.has_trans(from, c)) {
                    g[numOfState[from]].push_back({numOfState[d.get_trans(from, c)], c});
                } else {
                    g[numOfState[from]].push_back({npos, c});
                }
            }
        }
    }
    {
        for (char c: d.get_alphabet()) {
            g[npos].push_back({npos, c});
        }
    }

    int startPos = numOfState[d.get_initial_state()];

    cout << ""graph:\n"";
    for (int i = 0; i < n; ++i) {
        for (auto [nxt, c]: g[i]) {
            cout << i << ' ' << nxt << ' ' << c << '\n';
        }
    }
    cout << ""term:\n"";
    for (int i = 0; i < n; ++i)
        if (term[i])
            cout << i << ' ';
    cout << '\n';
    cout << ""start:"" << ' ' << startPos << '\n'; 
    std::cout << ""kok\n"";


    std::vector<std::map<char, std::vector<int> > > inv(n);
    for (int i = 0; i < n; ++i) {
        for (auto&& [nxt, c]: g[i]) {
            inv[nxt][c].push_back(i);
        }
    }

    std::vector<std::set<int> > classes(2);
    std::vector<int> invSize(2);
    std::vector<int> twin(2, -1);
    std::vector<int> numOfClass(n);

    for (int i = 0; i < n; ++i) {
        if (term[i]) {
            classes[0].insert(i);
            numOfClass[i] = 0;
        } else { 
            classes[1].insert(i);
            numOfClass[i] = 1;
        }
    }


    std::queue<std::pair<int, char> > q;
    for (char c : d.get_alphabet()) {
        q.push({1, c});
        q.push({0, c});
    }

    cout << ""lol\n"";
    while (!q.empty()) {

        auto [curClassIdx, c] = q.front();
        std::set<int>& curClass = classes[curClassIdx];
        q.pop();

        cout << ""try split: "" << c << ' ' << curClassIdx << '\n';
        for (int cur: curClass)
            cout << cur << ' ';
        cout << '\n';

        cout << ""before split: \n"";
        for (int i = 0; i < n; ++i)
            cout << numOfClass[i] << ' ';
        cout << '\n';

        std::map<int, std::set<int> > involved;

        for (int cur : curClass) {
            for (int from : inv[cur][c]) {
                int i = numOfClass[from];
                involved[i].insert(from);
            }
        }

        for (auto& [i, arr]: involved) {
            if (arr.size() < classes[i].size()) {
                cout << ""need split: "" << i << "" sz: "" << classes[i].size() << '\n';
                for (int k : arr)
                    cout << k << ' ';
                cout << '\n';
                classes.emplace_back();
                int j = classes.size() - 1;

                for (int r : arr) {
                    classes[i].erase(r);
                    classes[j].insert(r);
                }

                if (classes[i].size() < classes[j].size()) {
                    std::swap(classes[i], classes[j]);
                }

                for (int r : classes[j]) {
                    numOfClass[r] = j;
                }

                for (int r : classes[i]) {
                    numOfClass[r] = i;
                }

                for (char c : d.get_alphabet()) {
                    q.push({j, c});
                }
            }
        }
        cout << ""after split: \n"";
        for (int i = 0; i < n; ++i)
            cout << numOfClass[i] << ' ';
        cout << '\n';
    }

    std::vector<int> used(n);
    std::queue<int> qq;
    qq.push(startPos);
    used[startPos] = 1;
    while (!qq.empty()) {
        int cur = qq.front();
        qq.pop();
        for (auto p : g[cur]) {
            if (!used[p.first]) {
                used[p.first] = 1;
                qq.push(p.first);
            }
        }
    }

    std::vector<int> u(n);
    for (int i = 0; i < n; ++i)
        if (term[i]) {
            qq.push(i);
            u[i] = true;
        }

    while (!qq.empty()) {
        int cur = qq.front();
        qq.pop();
        for (char c: d.get_alphabet())
            for (int nxt:inv[cur][c]) {
                if (u[nxt])
                    continue;
                u[nxt] = 1;
                qq.push(nxt);
            }
    }

    for (int i = 0; i < n; ++i) {
        std::cout << i << ' ' << numOfClass[i] <<  "":\n"";
        for (auto [j, c]: g[i]) {
            std::cout << c << ' ' << j << '\n';
        }
    }

    for (int i = 0; i < n; ++i)
        cout << used[i] << ' ';
    cout << '\n';
    for (int i = 0; i < n; ++i)
        cout << u[i] << ' ';
    cout << '\n';


    DFA ans(d.get_alphabet());

    for (int i = 0; i < n; ++i) {
        if (!used[i] || i == npos)
            continue;
        if (!u[i])
            continue;

        cout << ""st in ans: "" << i << ' ' << numOfClass[i] << '\n';
        if (!ans.has_state(std::to_string(numOfClass[i]))) {
            ans.create_state(std::to_string(numOfClass[i]));
            if (term[i])
                ans.make_final(std::to_string(numOfClass[i]));
        }
    }

    ans.set_initial(std::to_string(numOfClass[startPos]));

    for (int i = 0; i < n; ++i) {
        if (!used[i] || i == npos)
            continue;
        if (!u[i])
            continue;
        int from = numOfClass[i];
        for (auto [nxt, c]: g[i]) {
            if (nxt == npos)
                continue;
            if (!u[nxt])
                continue;
            int to = numOfClass[nxt];
            ans.set_trans(std::to_string(from), c, std::to_string(to));
        }
    }

    return ans;
}
"
T1sPGBEP,plsql2,rejcsibejcsi,PL/SQL,Sunday 21st of May 2023 10:19:54 AM CDT,"-- create table about director
CREATE TABLE directors ( id INT NOT NULL PRIMARY KEY, name VARCHAR2(255) NOT NULL, born NUMERIC(4) NOT NULL CHECK (born BETWEEN 1900 AND 2022), gender VARCHAR2(255) NOT NULL, country VARCHAR2(255) NOT NULL );
CREATE SEQUENCE directors_sequence;
CREATE 
OR replace TRIGGER directors_on_insert BEFORE INSERT 
ON directors FOR EACH ROW 
BEGIN
   SELECT
      directors_sequence.NEXTVAL INTO :new.id 
   FROM
      dual;
END
;
-- create table about studios
CREATE TABLE studios ( id INT NOT NULL PRIMARY KEY, name VARCHAR2(255) NOT NULL, founded NUMERIC(4) NOT NULL CHECK (founded BETWEEN 1800 AND 2022), country VARCHAR2(255) NOT NULL );
CREATE SEQUENCE studios_sequence;
CREATE 
OR replace TRIGGER studios_on_insert BEFORE INSERT 
ON studios FOR EACH ROW 
BEGIN
   SELECT
      studios_sequence.NEXTVAL INTO :new.id 
   FROM
      dual;
END
;
-- create table about movies
CREATE TABLE movies ( id INT NOT NULL PRIMARY KEY, title VARCHAR2(255) NOT NULL, year NUMERIC(4) NOT NULL CHECK (year BETWEEN 1900 AND 2022), director NUMERIC(10) NOT NULL, genre VARCHAR2(255) NOT NULL, rating NUMERIC(2) NOT NULL CHECK (rating BETWEEN 0 AND 10), studio NUMERIC(10) NOT NULL, FOREIGN KEY (studio) REFERENCES studios(id), FOREIGN KEY (director) REFERENCES directors(id) );
CREATE SEQUENCE movies_sequence;
CREATE 
OR replace TRIGGER movies_on_insert BEFORE INSERT 
ON movies FOR EACH ROW 
BEGIN
   SELECT
      movies_sequence.NEXTVAL INTO :new.id 
   FROM
      dual;
END
;
-- mysql create table about actors
CREATE TABLE actors ( id INT NOT NULL PRIMARY KEY, name VARCHAR2(255) NOT NULL, born NUMERIC(4) NOT NULL CHECK (born BETWEEN 1900 AND 2022), gender VARCHAR2(255) NOT NULL, country VARCHAR2(255) NOT NULL );
CREATE SEQUENCE actors_sequence;
CREATE 
OR replace TRIGGER actors_on_insert BEFORE INSERT 
ON actors FOR EACH ROW 
BEGIN
   SELECT
      actors_sequence.NEXTVAL INTO :new.id 
   FROM
      dual;
END
;
-- create table about movieActors
CREATE TABLE movieactors ( id INT NOT NULL PRIMARY KEY, movie_id INT, actor_id INT, FOREIGN KEY (actor_id) REFERENCES actors(id), FOREIGN KEY (movie_id) REFERENCES movies(id) );
CREATE SEQUENCE movieactors_sequence;
CREATE 
OR replace TRIGGER movieactors_on_insert BEFORE INSERT 
ON movieactors FOR EACH ROW 
BEGIN
   SELECT
      movieactors_sequence.NEXTVAL INTO :new.id 
   FROM
      dual;
END
;
-- create table about reviews
CREATE TABLE reviews ( id INT NOT NULL PRIMARY KEY, movie_id NUMERIC(10) NOT NULL, review VARCHAR2(255), rating NUMERIC(2) NOT NULL CHECK (rating BETWEEN 0 AND 10), date_r DATE, FOREIGN KEY (movie_id) REFERENCES movies(id) );
CREATE SEQUENCE reviews_sequence;
CREATE 
OR replace TRIGGER reviews_on_insert BEFORE INSERT 
ON reviews FOR EACH ROW 
BEGIN
   SELECT
      reviews_sequence.NEXTVAL INTO :new.id 
   FROM
      dual;
END
;
-- INSERTS
-- inserts for directors
INSERT INTO
   directors ( name, born, gender, country ) 
VALUES
   (
      'Frank Darabont',
      1959,
      'male',
      'France' 
   )
;
INSERT INTO
   directors ( name, born, gender, country ) 
VALUES
   (
      'Francis Ford Coppola',
      1939,
      'male',
      'USA' 
   )
;
INSERT INTO
   directors ( name, born, gender, country ) 
VALUES
   (
      'Christopher Nolan',
      1970,
      'male',
      'UK' 
   )
;
-- inserts for studios
INSERT INTO
   studios ( name, founded, country ) 
VALUES
   (
      'Castle Rock Entertainment',
      1987,
      'USA' 
   )
;
INSERT INTO
   studios ( name, founded, country ) 
VALUES
   (
      'Paramount Pictures',
      1912,
      'USA' 
   )
;
INSERT INTO
   studios ( name, founded, country ) 
VALUES
   (
      'Warner Bros.',
      1923,
      'USA' 
   )
;
-- inserts for movies
INSERT INTO
   movies ( title, year, director, genre, rating, studio ) 
VALUES
   (
      'The Shawshank Redemption',
      1994,
      1,
      'Drama',
      9.2,
      1 
   )
;
INSERT INTO
   movies ( title, year, director, genre, rating, studio ) 
VALUES
   (
      'The Godfather',
      1972,
      2,
      'Crime',
      9.2,
      2 
   )
;
INSERT INTO
   movies ( title, year, director, genre, rating, studio ) 
VALUES
   (
      'The Godfather: Part II',
      1974,
      2,
      'Crime',
      9.0,
      2 
   )
;
INSERT INTO
   movies ( title, year, director, genre, rating, studio ) 
VALUES
   (
      'The Dark Knight',
      2008,
      3,
      'Action',
      9.0,
      3 
   )
;
INSERT INTO
   movies ( title, year, director, genre, rating, studio ) 
VALUES
   (
      'The Green Mile',
      1999,
      1,
      'Drama',
      8.6,
      1 
   )
;
BEGIN
   -- inserts for actors
   -- The Shawshank Redemption
   INSERT INTO
      actors ( name, born, gender, country ) 
   VALUES
      (
         'Tim Robbins',
         1958,
         'male',
         'USA' 
      )
;
INSERT INTO
   actors ( name, born, gender, country ) 
VALUES
   (
      'Morgan Freeman',
      1937,
      'male',
      'USA' 
   )
;
-- The Godfather
INSERT INTO
   actors ( name, born, gender, country ) 
VALUES
   (
      'Marlon Brando',
      1924,
      'male',
      'USA' 
   )
;
INSERT INTO
   actors ( name, born, gender, country ) 
VALUES
   (
      'Al Pacino',
      1940,
      'male',
      'USA' 
   )
;
-- The Godfather: Part II  alpacino
INSERT INTO
   actors ( name, born, gender, country ) 
VALUES
   (
      'Robert De Niro',
      1943,
      'male',
      'USA' 
   )
;
-- The Dark Knight
INSERT INTO
   actors ( name, born, gender, country ) 
VALUES
   (
      'Christian Bale',
      1974,
      'male',
      'UK' 
   )
;
INSERT INTO
   actors ( name, born, gender, country ) 
VALUES
   (
      'Heath Ledger',
      1979,
      'male',
      'Australia' 
   )
;
-- The Green Mile
INSERT INTO
   actors ( name, born, gender, country ) 
VALUES
   (
      'Tom Hanks',
      1956,
      'male',
      'USA' 
   )
;
INSERT INTO
   actors ( name, born, gender, country ) 
VALUES
   (
      'Michael Clarke Duncan',
      1957,
      'male',
      'USA' 
   )
;
END
;
BEGIN
   -- inserts for reviews
   INSERT INTO
      reviews ( movie_id, review, rating, date_r ) 
   VALUES
      (
         1,
         'Great movie!',
         9,
         to_date('2019-01-01', 'YYYY-MM-DD') 
      )
;
INSERT INTO
   reviews ( movie_id, review, rating, date_r ) 
VALUES
   (
      1,
      'Awesome!',
      10,
      to_date('2019-01-02', 'YYYY-MM-DD') 
   )
;
INSERT INTO
   reviews ( movie_id, review, rating, date_r ) 
VALUES
   (
      2,
      'Pretty good!',
      9,
      to_date( '2010-11-22', 'YYYY-MM-DD') 
   )
;
INSERT INTO
   reviews ( movie_id, review, rating, date_r ) 
VALUES
   (
      2,
      'I liked it!',
      8,
      to_date( '2010-11-23', 'YYYY-MM-DD') 
   )
;
INSERT INTO
   reviews ( movie_id, review, rating, date_r ) 
VALUES
   (
      3,
      'Great movie!',
      9,
      to_date('2019-01-01', 'YYYY-MM-DD') 
   )
;
INSERT INTO
   reviews ( movie_id, review, rating, date_r ) 
VALUES
   (
      3,
      'Awesome!',
      10,
      to_date('2019-01-02', 'YYYY-MM-DD') 
   )
;
INSERT INTO
   reviews ( movie_id, review, rating, date_r ) 
VALUES
   (
      4,
      'Pretty good!',
      9,
      to_date( '2010-11-22', 'YYYY-MM-DD') 
   )
;
INSERT INTO
   reviews ( movie_id, review, rating, date_r ) 
VALUES
   (
      4,
      'I liked it!',
      8,
      to_date( '2010-11-23', 'YYYY-MM-DD') 
   )
;
INSERT INTO
   reviews ( movie_id, review, rating, date_r ) 
VALUES
   (
      5,
      'Great movie!',
      9,
      to_date( '2019-01-01', 'YYYY-MM-DD') 
   )
;
INSERT INTO
   reviews ( movie_id, review, rating, date_r ) 
VALUES
   (
      5,
      'Awesome!',
      10,
      to_date('2019-01-02', 'YYYY-MM-DD') 
   )
;
-- inserts for movieActors
INSERT INTO
   movieactors ( movie_id, actor_id ) 
VALUES
   (
      1,
      1 
   )
;
INSERT INTO
   movieactors ( movie_id, actor_id ) 
VALUES
   (
      1,
      2 
   )
;
INSERT INTO
   movieactors ( movie_id, actor_id ) 
VALUES
   (
      2,
      3 
   )
;
INSERT INTO
   movieactors ( movie_id, actor_id ) 
VALUES
   (
      2,
      4 
   )
;
INSERT INTO
   movieactors ( movie_id, actor_id ) 
VALUES
   (
      3,
      4 
   )
;
INSERT INTO
   movieactors ( movie_id, actor_id ) 
VALUES
   (
      3,
      5 
   )
;
INSERT INTO
   movieactors ( movie_id, actor_id ) 
VALUES
   (
      4,
      6 
   )
;
INSERT INTO
   movieactors ( movie_id, actor_id ) 
VALUES
   (
      4,
      7 
   )
;
INSERT INTO
   movieactors ( movie_id, actor_id ) 
VALUES
   (
      5,
      8 
   )
;
INSERT INTO
   movieactors ( movie_id, actor_id ) 
VALUES
   (
      5,
      9 
   )
;
END
;
-- TRIGGERS
-- insert, update, delete triggers
CREATE 
OR replace TRIGGER movies_log AFTER INSERT 
OR 
UPDATE
   OR 
   DELETE
      ON movies FOR EACH ROW 
      BEGIN
         IF inserting 
      THEN
         INSERT INTO
            log ( table_name, action, date_l ) 
         VALUES
            (
               'movies', 'insert', SYSDATE 
            )
;
ELSIF updating 
THEN
   INSERT INTO
      log ( table_name, action, date_l ) 
   VALUES
      (
         'movies', 'update', SYSDATE 
      )
;
ELSIF deleting 
THEN
   INSERT INTO
      log ( table_name, action, date_l ) 
   VALUES
      (
         'movies', 'delete', SYSDATE 
      )
;
      END
      IF;
END
;
CREATE 
OR replace TRIGGER actors_log AFTER INSERT 
OR 
UPDATE
   OR 
   DELETE
      ON actors FOR EACH ROW 
      BEGIN
         IF inserting 
      THEN
         INSERT INTO
            log ( table_name, action, date_l ) 
         VALUES
            (
               'actors', 'insert', SYSDATE 
            )
;
ELSIF updating 
THEN
   INSERT INTO
      log ( table_name, action, date_l ) 
   VALUES
      (
         'actors', 'update', SYSDATE 
      )
;
ELSIF deleting 
THEN
   INSERT INTO
      log ( table_name, action, date_l ) 
   VALUES
      (
         'actors', 'delete', SYSDATE 
      )
;
      END
      IF;
END
;
CREATE 
OR replace TRIGGER studios_log AFTER INSERT 
OR 
UPDATE
   OR 
   DELETE
      ON studios FOR EACH ROW 
      BEGIN
         IF inserting 
      THEN
         INSERT INTO
            log ( table_name, action, date_l ) 
         VALUES
            (
               'studios', 'insert', SYSDATE 
            )
;
ELSIF updating 
THEN
   INSERT INTO
      log ( table_name, action, date_l ) 
   VALUES
      (
         'studios', 'update', SYSDATE 
      )
;
ELSIF deleting 
THEN
   INSERT INTO
      log ( table_name, action, date_l ) 
   VALUES
      (
         'studios', 'delete', SYSDATE 
      )
;
      END
      IF;
END
;
CREATE 
OR replace TRIGGER reviews_log AFTER INSERT 
OR 
UPDATE
   OR 
   DELETE
      ON reviews FOR EACH ROW 
      BEGIN
         IF inserting 
      THEN
         INSERT INTO
            log ( table_name, action, date_l ) 
         VALUES
            (
               'reviews', 'insert', SYSDATE 
            )
;
ELSIF updating 
THEN
   INSERT INTO
      log ( table_name, action, date_l ) 
   VALUES
      (
         'reviews', 'update', SYSDATE 
      )
;
ELSIF deleting 
THEN
   INSERT INTO
      log ( table_name, action, date_l ) 
   VALUES
      (
         'reviews', 'delete', SYSDATE 
      )
;
      END
      IF;
END
;
CREATE 
OR replace TRIGGER movieactors_log AFTER INSERT 
OR 
UPDATE
   OR 
   DELETE
      ON movieactors FOR EACH ROW 
      BEGIN
         IF inserting 
      THEN
         INSERT INTO
            log ( table_name, action, date_l ) 
         VALUES
            (
               'movieActors', 'insert', SYSDATE 
            )
;
ELSIF updating 
THEN
   INSERT INTO
      log ( table_name, action, date_l ) 
   VALUES
      (
         'movieActors', 'update', SYSDATE 
      )
;
ELSIF deleting 
THEN
   INSERT INTO
      log ( table_name, action, date_l ) 
   VALUES
      (
         'movieActors', 'delete', SYSDATE 
      )
;
      END
      IF;
END
;
CREATE 
OR replace TRIGGER directors_log AFTER INSERT 
OR 
UPDATE
   OR 
   DELETE
      ON directors FOR EACH ROW 
      BEGIN
         IF inserting 
      THEN
         INSERT INTO
            log ( table_name, action, date_l ) 
         VALUES
            (
               'directors', 'insert', SYSDATE 
            )
;
ELSIF updating 
THEN
   INSERT INTO
      log ( table_name, action, date_l ) 
   VALUES
      (
         'directors', 'update', SYSDATE 
      )
;
ELSIF deleting 
THEN
   INSERT INTO
      log ( table_name, action, date_l ) 
   VALUES
      (
         'directors', 'delete', SYSDATE 
      )
;
      END
      IF;
END
;
-- create sequence
CREATE SEQUENCE log_sequence;
-- create trigger
CREATE 
OR replace TRIGGER log_trigger BEFORE INSERT 
ON log FOR EACH ROW 
BEGIN
   SELECT
      log_sequence.NEXTVAL INTO :new.id 
   FROM
      dual;
END
;
-- CSOMAGOK
--egy csomag ami a módosítókat tartalmazza, insert, update, delete
CREATE 
OR replace PACKAGE modifiers AS FUNCTION berak(table_name VARCHAR2, micsoda VARCHAR2) RETURN NUMBER;
FUNCTION frissit(table_name VARCHAR2, micsoda VARCHAR2) RETURN NUMBER;
FUNCTION kivesz(table_name VARCHAR2, micsoda VARCHAR2) RETURN NUMBER;
END
;
CREATE 
OR replace PACKAGE BODY modifiers AS FUNCTION berak(table_name VARCHAR2, micsoda VARCHAR2) RETURN NUMBER IS sql0 VARCHAR2(1000);
BEGIN
   sql0 := 'insert into ' || table_name || ' values (' || micsoda || ')';
EXECUTE IMMEDIATE sql0;
RETURN SQL % rowcount;
END
;
FUNCTION frissit(table_name VARCHAR2, micsoda VARCHAR2) RETURN NUMBER IS sql0 VARCHAR2(1000);
BEGIN
   sql0 := 'update ' || table_name || ' set ' || micsoda;
EXECUTE IMMEDIATE sql0;
RETURN SQL % rowcount;
END
;
FUNCTION kivesz(table_name VARCHAR2, micsoda VARCHAR2) RETURN NUMBER IS sql0 VARCHAR2(1000);
BEGIN
   sql0 := 'delete from ' || table_name || ' where ' || micsoda;
EXECUTE IMMEDIATE sql0;
RETURN SQL % rowcount;
END
;
END
;
-- például
BEGIN
   dbms_output.put_line(modifiers.berak('movies', '1, 1, 1, 1, 1, 1, 1, 1, 1, 1'));
dbms_output.put_line(modifiers.frissit('movies', 'id = 1, title = ''asd'''));
dbms_output.put_line(modifiers.kivesz('reviews', 'id = 5'));
END
;
-- egy csomag ami mindenféle selecteket tartalmaz
CREATE 
OR replace PACKAGE queries AS PROCEDURE dynamic_select_5(table_name2 VARCHAR2);
PROCEDURE directormovies(director_name CHAR);
PROCEDURE movie_count_with_higher_rating(rating_be NUMBER);
END
;
CREATE 
OR replace PACKAGE BODY queries AS PROCEDURE dynamic_select_5( table_name2 VARCHAR2) IS TYPE cur_typ IS ref CURSOR;
c CUR_TYP;
query_str CHAR(2000);
str_1 VARCHAR2(200);
str_2 VARCHAR2(200);
str_3 VARCHAR2(200);
str_4 VARCHAR2(200);
str_5 VARCHAR2(200);
sql_all VARCHAR2(1000);
sql_5 VARCHAR2(1000);
BEGIN
   SELECT
      listagg(column_name , ', ') INTO sql_all 
   FROM
      user_tab_columns 
   WHERE
      table_name = table_name2;
SELECT
   regexp_substr(sql_all, '[^,]+,[^,]+,[^,]+,[^,]+,[^,]+') ""REGEXP_SUBSTR"" INTO sql_5 
FROM
   dual;
dbms_output.Put_line(sql_5);
query_str := 'SELECT ' || sql_5 || ' FROM ' || table_name2;
OPEN c FOR query_str;
LOOP FETCH c INTO str_1,
str_2,
str_3,
str_4,
str_5;
EXIT 
WHEN
   c % NOTFOUND;
dbms_output.Put_line(str_1 || ' ' || str_2 || ' ' || str_3 || ' ' || str_4 || ' ' || str_5);
END
LOOP;
CLOSE c;
EXCEPTION 
WHEN
   OTHERS 
THEN
   dbms_output.Put_line('Error, nincs ilyen tabla');
END
;
PROCEDURE directormovies (director_name IN CHAR) AS CURSOR cur IS 
SELECT
   title,
   year 
FROM
   movies 
   inner join
      directors 
      ON movies.director = directors.id 
WHERE
   directors.name LIKE director_name || '%';
cv cur % ROWTYPE;
BEGIN
   OPEN cur;
FETCH cur INTO cv;
IF cur % NOTFOUND 
THEN
   dbms_output.Put_line('Nincs ' || director_name || ' rendezoju film!');
ELSE
   dbms_output.put_line('Cim: ' || cv.title || ' Ev: ' || cv.year);
LOOP FETCH cur INTO cv;
EXIT 
WHEN
   cur % NOTFOUND;
dbms_output.put_line('Cim: ' || cv.title || ' Ev: ' || cv.year);
END
LOOP;
END
IF;
CLOSE cur;
EXCEPTION 
WHEN
   OTHERS 
THEN
   dbms_output.Put_line('Error, nincs ilyen rendezo');
END
;
PROCEDURE movie_count_with_higher_rating (rating_be IN NUMBER) AS CURSOR cur IS 
SELECT
   count(*) AS db 
FROM
   movies 
WHERE
   rating > rating_be;
cv cur % ROWTYPE;
BEGIN
   OPEN cur;
FETCH cur INTO cv;
IF (cv.db = 0) 
THEN
   dbms_output.Put_line('Nincs olyan film ami ' || rating_be || ' pontal tobbet kapott volna!');
ELSE
   dbms_output.Put_line('Ennel magasabb ratingu filmek szama: ' || cv.db);
END
IF;
CLOSE cur;
EXCEPTION 
WHEN
   OTHERS 
THEN
   dbms_output.Put_line('Error');
END
;
END
;
--Például
BEGIN
   queries.directormovies('Frank Darabont');
END
;

"
Y1cMzzeV,Untitled,Derga,C++,Sunday 21st of May 2023 10:12:43 AM CDT,"//Билет 7
//Перегрузка операторов <<, >>, []
/*
Язык C++ имеет широкие возможности для перегрузки большинства операторов. 
Перегрузка оператора означает использование оператора для оперирования определенными объектами классов.  
При перегрузке оператора в классе вызывается соответствующая операторная функция (operator function), 
которая выполняет действия, которые касаются данного класса.
*/

// Класс, который реализует точку на координатной плоскости
// класс содержит две операторные функции

#include <iostream>

using namespace std;

class Point {
private:
    int x, y; // координаты точки

public:
    // конструкторы класса
    Point() {
        x = 0;
        y = 0;
    }

    Point(int nx, int ny) {
        x = nx;
        y = ny;
    }

    // методы доступа к членам класса
    int GetX(void) const { return x; }
    int GetY(void) const { return y; }
    void SetX(int new_x) { x = new_x; }
    void SetY(int new_y) { y = new_y; }

    // перегруженный бинарный оператор '+'
    Point operator+(const Point& pt) {
        // p - временный объект, который создается с помощью конструктора без параметров
        Point p;
        p.x = x + pt.x;
        p.y = y + pt.y;
        return p;
    }

    // перегруженный унарный оператор '-'
    Point operator-(const Point& pt) {
        Point p;
        p.x = x - pt.x;
        p.y = y - pt.y;
        return p;
    }

    friend istream& operator>>(istream&, Point&);

    int& operator[](int index) {
        if (index == 0) {
            return x;
        }
        else {
            return y;
        }
    }
};

istream& operator>>(istream& in, Point& p) {
    int x, y;
    in >> x >> y;
    p.SetX(x);
    p.SetY(y);
    return in;
}

ostream& operator<<(ostream& out, const Point& p) {
    out << p.GetX() << ' ' << p.GetY();
    return out;
}

int main() {
    // объявление переменных - объектов класса CPoint
    Point P1(3, 4);
    Point P2(5, 7);
   
    // 1. Использование перегруженного бинарного оператора '+'
    Point P3 = P1 + P2; // объект P1 вызывает операторную функцию
    //std::cout << P3.GetX() << ' ' << P3.GetY() << '\n';
    cout << P3 << '\n';
    
    // 2. Использование перегруженного унарного оператора '-'
    Point P4 = P1 - P2;
    //std::cout << P3.GetX() << ' ' << P3.GetY() << '\n';
    cout << P4 << '\n';

    Point P5;
    cin >> P5;
    cout << P5 << '\n';

    P5[0] = 21;
    P5[1] = 42;
    int p5_x = P5[0];
    int p5_y = P5[1];
    cout << P5 << '\n' << p5_x << ' ' << p5_y;

    return 0;
}"
M1VdeCAh,Untitled,Derga,C++,Sunday 21st of May 2023 09:56:57 AM CDT,"//Билет 6
//операторная функция, перегрузка операторов

/*
Язык C++ имеет широкие возможности для перегрузки большинства операторов. 
Перегрузка оператора означает использование оператора для оперирования определенными объектами классов.  
При перегрузке оператора в классе вызывается соответствующая операторная функция (operator function), 
которая выполняет действия, которые касаются данного класса.
*/

// Класс, который реализует точку на координатной плоскости
// класс содержит две операторные функции
class Point {
private:
    int x, y; // координаты точки

public:
    // конструкторы класса
    Point() {
        x = 0;
        y = 0;
    }

    Point(int nx, int ny) {
        x = nx;
        y = ny;
    }

    // методы доступа к членам класса
    int GetX(void) const { return x; }
    int GetY(void) const { return y; }
    void SetX(int new_x) { x = new_x; }
    void Set(int new_y) { y = new_y; }

    // перегруженный бинарный оператор '+'
    Point operator+(const Point& pt) {
        // p - временный объект, который создается с помощью конструктора без параметров
        Point p;
        p.x = x + pt.x;
        p.y = y + pt.y;
        return p;
    }

    // перегруженный унарный оператор '-'
    Point operator-(const Point& pt) {
        Point p;
        p.x = x - pt.x;
        p.y = y - pt.y;
        return p;
    }
};

#include <iostream>

int main() {
    // объявление переменных - объектов класса CPoint
    Point P1(3, 4);
    Point P2(5, 7);
    Point P3;
    int x, y; // дополнительные переменные

    // 1. Использование перегруженного бинарного оператора '+'
    P3 = P1 + P2; // объект P1 вызывает операторную функцию
    std::cout << P3.GetX() << ' ' << P3.GetY() << '\n';
    
    // 2. Использование перегруженного унарного оператора '-'
    P3 = P1 - P2;
    std::cout << P3.GetX() << ' ' << P3.GetY() << '\n';

    return 0;
}"
MiEbKkXA,Untitled,Derga,C++,Sunday 21st of May 2023 09:27:59 AM CDT,"//Билет 5
//Целочисленные константы класса

//Инициализация констант в классе. Примеры
class MyClass1 {
    const int val = 50;
    //const int val;
public:
    MyClass1() = default;
    /*
    MyClass(int new_val) {
        val = new_val; // ошибка. Поле val в этот момент уже создано и 
                       //так как оно константное - его нельзя менять
    }
    */

    //тут мы инициализируем val в момент создания, через лист инициализации, ""налету""
    MyClass1(int new_val) : val(new_val) {} 

    /*
     Поэтому либо используйте статическую константу, которая сто процентов не изменится, 
     либо используйте константу + динамический массив.
    */
    int GetVal() const {
        return val;
    }

    //так как val можно изменить - можно создать динамический массив, а статический нельзя
    int* pointer_i = new int[val]; //можно
    //нельзя
    //int a[val];
};

class MyClass2 {
    static const int val = 50;
public:
    //так сделать уже нельзя
    //MyClass2(int new_val) : val(new_val) {}

    int GetVal() const {
        return val;
    }

    //так как val - невозможно изменить - можно создать и динамический и статический массивы размера val
    int* pointer_i = new int[val];
    int a[val];
};

#include <iostream>

int main() {
    //Тут пример, как можно в констаное поле класса записать значение.
    MyClass1 a;
    std::cout << a.GetVal() << '\n';

    MyClass1 b(100);
    std::cout << b.GetVal() << '\n';

    //Тут пример класса, константное поле котороего переписать не получится

}"
BAXX8Eqz,Upskill Password,Paceusa,JavaScript,Sunday 21st of May 2023 09:25:38 AM CDT,21mei2023
MfacZpEq,邀您一起看：「精品美女吧.dy」,xiaomianao666,JavaScript,Sunday 21st of May 2023 09:19:27 AM CDT,海阔视界规则分享，当前分享的是：二级页面详情￥page_detail￥「精品美女吧.dy」@@eyJkYXRhIjoie1wiYXNzb2NpYXRlZE1vZGVsc01hcEZvckpvaW5UYWJsZVwiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhGS1wiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhvdXRGS1wiOnt9LFwiZmllbGRzVG9TZXRUb0RlZmF1bHRcIjpbXSxcImdtdE1vZGlmaWVkXCI6MCxcImlkXCI6MCxcImxhc3RfY2hhcHRlcl9ydWxlXCI6XCJcIixcImxpc3RUb0NsZWFyQXNzb2NpYXRlZEZLXCI6W10sXCJsaXN0VG9DbGVhclNlbGZGS1wiOltdLFwicGFnZUxpc3RcIjpbe1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuW3peWFt1wiLFwicGF0aFwiOlwidXRpbGl5XCIsXCJydWxlXCI6XCJqczpcXG5sZXQgaG9zdCA9IFxcXCJodHRwOi8vaGlrZXIubm9raWEucHJlc3NcXFwiO1xcbi8vbGV0IGhvc3QgPSBcXFwiaHR0cDovLzE5Mi4xNjguMy45NDo4MDc5XFxcIjtcXG5sZXQgaG9tZSA9IGJhc2U2NERlY29kZShcXFwiYUdsclpYSTZMeTlvYjIxbFxcXCIpO1xcbnZhciBhcGkgPSB7XFxuICAgIGhvc3Q6IGhvc3QrXFxcIi9oaWtlcnVsZVxcXCIsXFxuICAgIHVzZXJzVXJsOiBcXFwiL2Rldi91c2Vycz9vcmRlcj1cXFwiLCAvL+eUqOaIt+WIl+ihqFxcbiAgICBydWxlQ291bnRVcmw6IFxcXCIvZGV2L3J1bGVjb3VudFxcXCIsIC8v6I635Y+W6KeE5YiZ5pWw6YePXFxuICAgIHJ1bGVzVXJsOiBcXFwiL2Rldi9nZXRcXFwiLCAvL+eUqOaIt+WvueW6lOeahOinhOWImeWIl+ihqOS7heS7heiOt+WPluWFrOW8gFxcbiAgICBydWxlc0FsbFVybDogXFxcIi9kZXYvZ2V0YWxsXFxcIiwgLy/lvIDlj5HogIXlr7nlupTnmoTop4TliJnliJfooajlj6/ojrflj5bnp4HmnIlcXG4gICAgZGV2U2VsZjonL2Rldi9nZXRzZWxmJywvL+iOt+WPluW8gOWPkeiAheS/oeaBr1xcbiAgICBtYW5DYW5VcGxvYWQ6Jy9zZXRfY2FuX3VwbG9hZC8nLC8v6LaF566h6K6+572u5byA5Y+R6ICF5piv5ZCm5Y+v5LiK5LygXFxuICAgIG1hblJ1bGVTYWZlOicvc2V0X3J1bGVfc2FmZS8nLC8v6LaF566h6K6+572u6KeE5YiZ5a6J5YWo5oCnXFxuICAgIG1hblJ1bGVHb29kOicvc2V0X3J1bGVfZ29vZC8nLC8v6LaF566h6K6+572u6KeE5YiZ5LyY6LSo5oCnXFxuICAgIGltcG9ydFVybDogXFxcIi9ydWxlbGlzdC5qc29uP2lkPVxcXCIsIC8v6KeE5YiZ6K+m5oOF5Y+v5a+85YWlXFxuICAgIGluZm9TZXRVcmw6IFxcXCIvZGV2L3NldF9pbmZvXFxcIixcXG4gICAgbm93Q29uVXJsOiBcXFwiL3NxbF9pbmZvL2dldF9ub3dfY29uXFxcIixcXG4gICAgaW5mb0dldFVybDogXFxcIi9kZXYvZ2V0X2luZm8/bmFtZT1cXFwiLFxcbiAgICBzZXR0aW5nc0dldFVybDogXFxcIi9kZXYvZ2V0X3NldHRpbmdzP25hbWU9XFxcIixcXG4gICAgZ3VwbG9hZDogXFxcIi9kZXYvZ3VwbG9hZFxcXCIsXFxuICAgIGd0aW1lb3ZlcjogXFxcIi9kZXYvZ3RpbWVvdmVyXFxcIixcXG4gICAgZ2V0YnlpZDogXFxcIi9kZXYvZ2V0YnlpZFxcXCIsXFxuICAgIHJ1bGVMaXN0SnNvbjogXFxcIi9ydWxlbGlzdC5qc29uXFxcIixcXG4gICAgYXV0aDogXFxcIi9kZXYvZ2V0X2F1dGhcXFwiLFxcbiAgICB0aW1lb3ZlcjogXFxcIi9kZXYvdGltZW92ZXJcXFwiLFxcbiAgICBzaGFyZTogXFxcIi9kZXYvc2hhcmVcXFwiLFxcbiAgICBnZW5BdXRoOiBcXFwiL2Rldi9nZW5fYXV0aFxcXCIsXFxuICAgIGRlbGV0ZVVybDogXFxcIi9kZXYvZGVsZXRlXFxcIixcXG4gICAganNvbkxpc3Q6IFxcXCIvZGV2L2pzb25fbGlzdFxcXCIsXFxuICAgIHNlYXJjaDogXFxcIi9kZXYvc2VhcmNoXFxcIixcXG4gICAgbmV3X2RldjogXFxcIi9kZXZfcmVnaXN0L25ld1xcXCIsXFxuICAgIG5ld19nZXRJZDogXFxcIi9kZXZfcmVnaXN0L2dldF9pZFxcXCIsXFxuICAgIG5ld19jb25maXJtOiBcXFwiL2Rldl9yZWdpc3QvY29uZmlybVxcXCIsXFxuICAgIG1vZGlmeV9wd2Q6IFxcXCIvbW9kaWZ5L3Bhc3N3b3JkXFxcIixcXG4gICAgbW9kaWZ5X25hbWU6IFxcXCIvbW9kaWZ5L25hbWVcXFwiLFxcbiAgICBtb2RpZnlfYXZhOiBcXFwiL21vZGlmeS9hdmF0YXJcXFwiLFxcbiAgICB1c2VyOiBcXFwiL2Rldi91c2VyL1xcXCIsXFxuICAgIGdldF9ydWxlX25vdGU6IFxcXCIvbW9kaWZ5L2dldF9ydWxlX25vdGUvXFxcIixcXG4gICAgc2V0X3J1bGVfcGljOiBcXFwiL21vZGlmeS9ydWxlX3BpYy9cXFwiLFxcbiAgICBzZXRfcnVsZV9ub3RlOiBcXFwiL21vZGlmeS9ydWxlX25vdGUvXFxcIlxcbn1cXG4kLmV4cG9ydHMucmFuZ2UgPSBmdW5jdGlvbihtLCBuKSB7XFxuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobSAtIG4gKyAxKSArIG4pO1xcbn1cXG4kLmV4cG9ydHMubWFwQ29sVHlwZSA9IGZ1bmN0aW9uKHRhcmdldCwgdHlwZSwgbikge1xcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xcbiAgICAgICAgdGFyZ2V0LnB1c2goe1xcbiAgICAgICAgICAgIGNvbF90eXBlOiB0eXBlXFxuICAgICAgICB9KTtcXG4gICAgfVxcbn1cXG52YXIgZ2V0QXBpID0gZnVuY3Rpb24oaykge1xcbiAgICByZXR1cm4gYXBpLmhvc3QgKyBhcGlba107XFxufTtcXG4kLmV4cG9ydHMuZ2V0QXBpPWdldEFwaTtcXG4kLmV4cG9ydHMubWQ9Z2V0QXBpKCdpbXBvcnRVcmwnKStcXFwiMzE4N1xcXCI7XFxuJC5leHBvcnRzLmxvY2FsUnVsZVZlciA9IGZ1bmN0aW9uKGxvY2FsUnVsZUxpc3QsIHJ1bGUpIHtcXG4gICAgbGV0IGxvY2FsUnVsZTtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhbFJ1bGVMaXN0Lmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICBsZXQgaXRlbSA9IGxvY2FsUnVsZUxpc3RbaV07XFxuICAgICAgICBsZXQgYXUgPSBpdGVtLmF1dGhvciB8fCBcXFwiXFxcIjtcXG4gICAgICAgIGxldCBzYW1lQXU9YXUubGVuZ3RoID4gMCAmJiBydWxlLmF1dGhvci5pbmNsdWRlcyhhdSk7XFxuICAgICAgICBzYW1lQXU9dHJ1ZTsvL+S4jeWIpOaWreS9nOiAhem7mOiupOS4unRydWVcXG4gICAgICAgIGlmIChpdGVtLnRpdGxlID09PSBydWxlLm5hbWUgJiYgc2FtZUF1KSB7XFxuICAgICAgICAgICAgbG9jYWxSdWxlID0gaXRlbTtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBpZiAobG9jYWxSdWxlID09PSB2b2lkIDApIHtcXG4gICAgICAgIHJldHVybiAtMTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiBsb2NhbFJ1bGUudmVyc2lvbjtcXG4gICAgfVxcbn1cXG4kLmV4cG9ydHMuY29sb3IgPSBmdW5jdGlvbih0ZXh0LCBjb2xvcikge1xcbiAgICB0ZXh0ICs9IFxcXCJcXFwiO1xcbiAgICBpZiAodGV4dC5pbmRleE9mKFxcXCLigJzigJzigJ3igJ1cXFwiKSA9PT0gMCkge1xcbiAgICAgICAgdGV4dC5yZXBsYWNlKFxcXCLigJzigJzigJ3igJ1cXFwiLCBcXFwiXFxcIik7XFxuICAgIH1cXG4gICAgcmV0dXJuIFxcXCLigJzigJzigJ3igJ08Zm9udCBjb2xvcj0nXFxcIiArIGNvbG9yICsgXFxcIic+XFxcIiArIHRleHQgKyBcXFwiPC9mb250PlxcXCI7XFxufVxcblxcbiQuZXhwb3J0cy5zbGVlcCA9IGZ1bmN0aW9uKHRpbWVvdXQpe1xcbiAgICBqYXZhLmxhbmcuVGhyZWFkLnNsZWVwKHRpbWVvdXQpO1xcbn1cXG5mdW5jdGlvbiBodG1sVGFnKHRhZywgdGV4dCkge1xcbiAgICB0ZXh0ICs9IFxcXCJcXFwiO1xcbiAgICBpZiAodGV4dC5pbmRleE9mKFxcXCLigJzigJzigJ3igJ1cXFwiKSA9PT0gMCkge1xcbiAgICAgICAgdGV4dC5yZXBsYWNlKFxcXCLigJzigJzigJ3igJ1cXFwiLCBcXFwiXFxcIik7XFxuICAgIH1cXG4gICAgcmV0dXJuIFxcXCLigJzigJzigJ3igJ1cXFwiICsgXFxcIjxcXFwiICsgdGFnICsgXFxcIj5cXFwiICsgdGV4dCArIFxcXCI8L1xcXCIgKyB0YWcgKyBcXFwiPlxcXCI7XFxuXFxufVxcblxcbmZ1bmN0aW9uIGdldE5vd0Zvcm1hdERhdGUoKSB7XFxuICAgICAgICAgICAgbGV0IGRhdGUgPSBuZXcgRGF0ZSgpO1xcbiAgICAgICAgICAgIGxldCBzZXBlcmF0b3IxID0gXFxcIi1cXFwiO1xcbiAgICAgICAgICAgIGxldCBzZXBlcmF0b3IyID0gXFxcIjpcXFwiO1xcbiAgICAgICAgICAgIGxldCBtb250aCA9IGRhdGUuZ2V0TW9udGgoKSArIDE7XFxuICAgICAgICAgICAgbGV0IHN0ckRhdGUgPSBkYXRlLmdldERhdGUoKTtcXG4gICAgICAgICAgICBsZXQgc3RySG91cnMgPSBkYXRlLmdldEhvdXJzKCk7XFxuICAgICAgICAgICAgbGV0IHN0ck1pbnV0ZXMgPSBkYXRlLmdldE1pbnV0ZXMoKTtcXG4gICAgICAgICAgICBsZXQgc3RyU2Vjb25kcyA9IGRhdGUuZ2V0U2Vjb25kcygpKzE7XFxuICAgICAgICAgICAgaWYgKG1vbnRoID49IDEgJiYgbW9udGggPD0gOSkge1xcbiAgICAgICAgICAgICAgICBtb250aCA9IFxcXCIwXFxcIiArIG1vbnRoXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChzdHJEYXRlID49IDAgJiYgc3RyRGF0ZSA8PSA5KSB7XFxuICAgICAgICAgICAgICAgIHN0ckRhdGUgPSBcXFwiMFxcXCIgKyBzdHJEYXRlXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChzdHJIb3VycyA+PSAwICYmIHN0ckhvdXJzIDw9IDkpIHtcXG4gICAgICAgICAgICAgICAgc3RySG91cnMgPSBcXFwiMFxcXCIgKyBzdHJIb3Vyc1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoc3RyTWludXRlcyA+PSAwICYmIHN0ck1pbnV0ZXMgPD0gOSkge1xcbiAgICAgICAgICAgICAgICBzdHJNaW51dGVzID0gXFxcIjBcXFwiICsgc3RyTWludXRlc1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoc3RyU2Vjb25kcyA+PSAwICYmIHN0clNlY29uZHMgPD0gOSkge1xcbiAgICAgICAgICAgICAgICBzdHJTZWNvbmRzID0gXFxcIjBcXFwiICsgc3RyU2Vjb25kc1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAvL2xldCBjdXJyZW50ZGF0ZSA9IGRhdGUuZ2V0RnVsbFllYXIoKSArIHNlcGVyYXRvcjEgKyBtb250aCArIHNlcGVyYXRvcjEgKyBzdHJEYXRlICsgXFxcIiBcXFwiICsgc3RySG91cnMgKyBzZXBlcmF0b3IyICsgc3RyTWludXRlcyArIHNlcGVyYXRvcjIgKyBzdHJTZWNvbmRzO1xcbiAgICAgICAgICAgIGxldCBjdXJyZW50ZGF0ZSA9IChkYXRlLmdldEZ1bGxZZWFyKCktMjAyMCkrJycrIG1vbnRoICsnJysgc3RyRGF0ZSArJycrIHN0ckhvdXJzKycnICsgc3RyTWludXRlcyArJycrIE1hdGguY2VpbChzdHJTZWNvbmRzLzcpO1xcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChjdXJyZW50ZGF0ZSlcXG4gICAgICAgIH1cXG4kLmV4cG9ydHMuZ2V0Tm93Rm9ybWF0RGF0ZSA9IGdldE5vd0Zvcm1hdERhdGU7XFxuJC5leHBvcnRzLmh0bWxUYWcgPSBodG1sVGFnO1xcbiQuZXhwb3J0cy5zbWFsbCA9IGZ1bmN0aW9uKHRleHQpIHtcXG4gICAgcmV0dXJuIGh0bWxUYWcoXFxcInNtYWxsXFxcIiwgdGV4dCk7XFxufVxcbiQuZXhwb3J0cy5nZXRGaWxlID0gZnVuY3Rpb24oKSB7XFxuICAgIHZhciBGaWxlID0gcmVxdWVzdChcXFwiaGlrZXI6Ly9maWxlcy9XYXJlaG91c2VVU0VSLmpzb25cXFwiKSB8fCBcXFwie31cXFwiO1xcbiAgICB0cnkge1xcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoRmlsZSk7XFxuICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgIHdyaXRlRmlsZShcXFwiaGlrZXI6Ly9maWxlcy9XYXJlaG91c2VVU0VSLmpzb25cXFwiLCBcXFwie31cXFwiKTtcXG4gICAgICAgIHJldHVybiB7fTtcXG4gICAgfVxcbn1cXG4kLmV4cG9ydHMuZ2V0VXNlckRhdGUgPWZ1bmN0aW9uKCl7XFxuICAgIHZhciBGaWxlID0gcmVxdWVzdChcXFwiaGlrZXI6Ly9maWxlcy9XYXJlaG91c2VVU0VSQS5qc29uXFxcIikgfHwgXFxcIltdXFxcIjtcXG4gICAgdHJ5IHtcXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKEZpbGUpO1xcbiAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICB3cml0ZUZpbGUoXFxcImhpa2VyOi8vZmlsZXMvV2FyZWhvdXNlVVNFUkEuanNvblxcXCIsIFxcXCJbXVxcXCIpO1xcbiAgICAgICAgcmV0dXJuIFtdO1xcbiAgICB9XFxufVxcbiQuZXhwb3J0cy5leGlzdEZpbGUgPSBmdW5jdGlvbihzcGF0aCwgaXBhdGgsIGhlYWRlcnMpIHtcXG4gICAgbGV0IHNjb2RlID0gcmVxdWVzdChzcGF0aCk7XFxuICAgIGlmICghc2NvZGUpIHtcXG4gICAgICAgIHdyaXRlRmlsZShzcGF0aCwgcmVxdWVzdChpcGF0aCwgaGVhZGVycykpO1xcbiAgICB9XFxufVxcblxcbmxldCBuZXdBcGkgPSB7XFxuICAgIFxcXCJkaXNfbmV3XFxcIjogXFxcIi9oaWtlcnVsZS9uZXdfcnVsZV9kaXNjdXNzL1xcXCIsXFxuICAgIFxcXCJkaXNfdmVyaWZ5XFxcIjogXFxcIi9oaWtlcnVsZS9ydWxlX2Rpc2N1c3MvZ2V0X3l6bVxcXCIsXFxuICAgIFxcXCJkaXNfZ2V0XFxcIjogXFxcIi9oaWtlcnVsZS9ydWxlX2Rpc2N1c3MvXFxcIixcXG4gICAgXFxcImRpc19zZXRcXFwiOiBcXFwiL2hpa2VydWxlL21vZGlmeS9jYW5fZGlzY3Vzcy9cXFwiLFxcbiAgICBcXFwiZGlzX25ld191c2VyXFxcIjogXFxcIi9oaWtlcnVsZS9ydWxlX2Rpc2N1c3MvbmV3X3VzZXJcXFwiLFxcbiAgICBcXFwiZGlzX2xvZ2luXFxcIjpcXFwiL2hpa2VydWxlL3J1bGVfZGlzY3Vzcy91c2VyX2xvZ2luXFxcIixcXG4gICAgXFxcImRpc19kZXZfZGlzY3Vzc1xcXCI6XFxcIi9oaWtlcnVsZS9tb2RpZnkvZGV2X2Nhbl9kaXNjdXNzXFxcIixcXG4gICAgXFxcImRpc19kZXZfY29udHJvbFxcXCI6XFxcIi9oaWtlcnVsZS9ydWxlX2Rpc2N1c3MvcmVtb3ZlL1xcXCIsXFxuICAgIFxcXCJhbGxfcnVsZVxcXCI6XFxcIi9oaWtlcnVsZS9nZXRfcnVsZXNcXFwiLFxcbiAgICBcXFwiZGlzX2dldF9yZXBseVxcXCI6XFxcIi9oaWtlcnVsZS9nZXRfcmVwbHlfcnVsZV9kaXNjdXNzXFxcIixcXG4gICAgXFxcImRpc19yZXBseVxcXCI6XFxcIi9oaWtlcnVsZS9kZXZfbmV3X3J1bGVfZGlzY3Vzcy9cXFwiLFxcbn1cXG5cXG5mdW5jdGlvbiBzZXRBcGkob2JqZWN0KSB7XFxuICAgIGxldCB0YXJnZXQgPSB7fTtcXG4gICAgZm9yIChsZXQga2V5IGluIG9iamVjdCkge1xcbiAgICAgICAgdGFyZ2V0W2tleV09aG9zdCtvYmplY3Rba2V5XVxcbiAgICB9XFxuICAgIHJldHVybiB0YXJnZXQ7XFxufVxcblxcbiQuZXhwb3J0cy5hcGkgPSBzZXRBcGkobmV3QXBpKTtcXG4kLmV4cG9ydHMuYXBpLmhvc3Q9aG9zdDtcXG4kLmV4cG9ydHMuYXBpLmhvbWU9aG9tZTtcIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuW8gOWPkeiAheeZu+W9lVwiLFwicGF0aFwiOlwiZGV2TG9naW5cIixcInJ1bGVcIjpcImpzOlxcbnNldFBhZ2VUaXRsZShcXFwi5byA5Y+R6ICF55m75b2VXFxcIik7XFxuY29uc3Qge1xcbiAgICBnZXRBcGksXFxuICAgIGh0bWxUYWcsXFxuICAgIG1hcENvbFR5cGUsXFxuICAgIHNtYWxsLFxcbmdldEZpbGVcXG59ID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvdXRpbGl5XFxcIik7XFxudmFyIGRhdGEgPSBbXTtcXG5hZGRMaXN0ZW5lcignb25DbG9zZScsICQudG9TdHJpbmcoKCk9PntcXG4gICAgY2xlYXJWYXIoXFxcIldhcmVob3VzZVVzZXJuYW1lXFxcIik7XFxuICAgIGNsZWFyVmFyKFxcXCJXYXJlaG91c2VQYXNzd29yZFxcXCIpO1xcbn0pKVxcbmRhdGEucHVzaCh7XFxuICAgIHRpdGxlOiAn6LSm5Y+3JyxcXG4gICAgY29sX3R5cGU6ICdpbnB1dCcsXFxuICAgIGV4dHJhOiB7XFxuICAgICAgICBkZWZhdWx0VmFsdWU6IGdldFZhcignV2FyZWhvdXNlVXNlcm5hbWUnLCcnKSxcXG4gICAgICAgIHR5cGU6XFxcIm51bWJlclxcXCIsXFxuICAgICAgICBvbkNoYW5nZTogJ3B1dFZhcihcXFwiV2FyZWhvdXNlVXNlcm5hbWVcXFwiLGlucHV0KSdcXG4gICAgfVxcbn0sIHtcXG4gICAgdGl0bGU6ICflr4bnoIEnLFxcbiAgICBjb2xfdHlwZTogJ2lucHV0JyxcXG4gICAgZXh0cmE6IHtcXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogZ2V0VmFyKCdXYXJlaG91c2VQYXNzd29yZCcsICcnKSxcXG4gICAgICAgIHR5cGU6IFxcXCJwYXNzd29yZFxcXCIsXFxuICAgICAgICBvbkNoYW5nZTogJ3B1dFZhcihcXFwiV2FyZWhvdXNlUGFzc3dvcmRcXFwiLGlucHV0KSdcXG4gICAgfVxcbn0pO1xcblxcbmRhdGEucHVzaCh7XFxuICAgIHRpdGxlOlxcXCImbmJzcDsmbmJzcDs8YSBocmVmPSdoaWtlcjovL3BhZ2UvUmVnaXN0ZXInPuazqOWGjDwvYT5cXFwiLFxcbiAgICBjb2xfdHlwZTpcXFwicmljaF90ZXh0XFxcIlxcbn0pO1xcbm1hcENvbFR5cGUoZGF0YSwgXFxcImxpbmVfYmxhbmtcXFwiLCAxKTtcXG5sZXQgdXNlciA9IGdldEZpbGUoKTtcXG5kYXRhLnB1c2goe1xcbiAgICB0aXRsZTogaHRtbFRhZyhcXFwiYlxcXCIsIFxcXCLnmbvlvZVcXFwiKSxcXG4gICAgdXJsOiAkKCkubGF6eVJ1bGUoKHVybCwgZik9PiB7XFxuICAgICAgICBsZXQgdXNlcm5hbWUgPSBnZXRWYXIoJ1dhcmVob3VzZVVzZXJuYW1lJywgJycpLFxcbiAgICAgICAgICAgIHBhc3N3b3JkID0gZ2V0VmFyKCdXYXJlaG91c2VQYXNzd29yZCcsICcnKTtcXG4gICAgICAgIGlmKHVzZXJuYW1lID09PSBcXFwiXFxcIiAmJiBwYXNzd29yZCA9PT1cXFwiXFxcIil7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+i0puWPt+WSjOWvhueggeS4jeiDveS4uuepulxcXCJcXG4gICAgICAgIH1cXG4gICAgICAgIGxldCBteVVybCA9IHVybCArICc/cXE9JyArIHVzZXJuYW1lICsgJyZwYXNzd29yZD0nICsgcGFzc3dvcmQ7XFxuICAgICAgICBsZXQgY29kZV9zdHIgPSByZXF1ZXN0KG15VXJsKTtcXG4gICAgICAgIGxldCBjb2RlID0gSlNPTi5wYXJzZShjb2RlX3N0cik7XFxuICAgICAgICBpZiAoY29kZS5zdGF0dXMgPT0gMCkge1xcbiAgICAgICAgICAgIGYudXNlcm5hbWU9dXNlcm5hbWU7XFxuICAgICAgICAgICAgZi5wYXNzd29yZD1wYXNzd29yZFxcbiAgICAgICAgICAgIHdyaXRlRmlsZSgnaGlrZXI6Ly9maWxlcy9XYXJlaG91c2VVU0VSLmpzb24nLCBKU09OLnN0cmluZ2lmeShmKSk7XFxuICAgICAgICAgICAgYmFjaygpO1xcbiAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/nmbvlvZXmiJDlip9cXFwiO1xcbiAgICAgICAgfWVsc2V7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+i0puWPt+aIluWvhueggemUmeivr1xcXCI7XFxuICAgICAgICB9XFxuICAgIH0sIGdldEFwaShcXFwicnVsZXNBbGxVcmxcXFwiKSx1c2VyKSxcXG4gICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJ1xcbn0pO1xcbnNldFJlc3VsdChkYXRhKTtcIn0se1wiY29sX3R5cGVcIjpcImljb25fMl9yb3VuZFwiLFwibmFtZVwiOlwi5byA5Y+R6ICF566h55CGXCIsXCJwYXRoXCI6XCJkZXZNYW5hZ2VcIixcInJ1bGVcIjpcImpzOlxcbnNldFBhZ2VUaXRsZShcXFwi6KeE5YiZ566h55CGXFxcIik7XFxuYWRkTGlzdGVuZXIoJ29uQ2xvc2UnLCAnY2xlYXJWYXIoXFxcIldhcmVob3VzZS5iYWNrXFxcIixcXFwiXFxcIik7Jyk7XFxuaWYgKGdldFZhcihcXFwiV2FyZWhvdXNlLmJhY2tcXFwiKSA9PT0gXFxcIjFcXFwiKSB7XFxuICAgIGJhY2soKTtcXG59XFxuY29uc3Qge1xcbiAgICBnZXRBcGksXFxuICAgIGNvbG9yLFxcbiAgICBzbWFsbCxcXG4gICAgZ2V0RmlsZSxcXG4gICAgZXhpc3RGaWxlLFxcbiAgICBtYXBDb2xUeXBlLFxcbiAgICBhcGlcXG59ID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvdXRpbGl5XFxcIik7XFxubGV0IHtcXG4gICAgZGV2XFxufSA9IE1ZX1BBUkFNUztcXG5sZXQge1xcbiAgICB1c2VybmFtZSxcXG4gICAgcGFzc3dvcmQsXFxufSA9IGdldEZpbGUoKTtcXG4vL2V4aXN0RmlsZShcXFwiaGlrZXI6Ly9maWxlcy9ydWxlcy9kekhvdXNlL2h0bWwv5byA5Y+R6ICF5YiG5LqrLmh0bWxcXFwiLCBcXFwiaHR0cHM6Ly9lcnAuc2N3aW5iYW8uY29tL2hpa2VydWxlL3J1bGVsaXN0Lmpzb24/aWQ9NTM5XFxcIik7XFxubGV0IHJ1bGVMaXN0ID0gSlNPTi5wYXJzZShyZXF1ZXN0KGdldEFwaShcXFwicnVsZXNBbGxVcmxcXFwiKSArICc/cXE9JyArIHVzZXJuYW1lICsgJyZwYXNzd29yZD0nICsgcGFzc3dvcmQpKS5yZXN1bHQ7XFxubGV0IE1PQklMRV9VQSA9ICdNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNS4wOyBTTS1HOTAwUCBCdWlsZC9MUlgyMVQpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS84OC4wLjQzMjQuMTQ2IE1vYmlsZSBTYWZhcmkvNTM3LjM2JztcXG5sZXQgaW5mb1NldFVybCA9IGdldEFwaShcXFwiaW5mb1NldFVybFxcXCIpO1xcbmxldCBpbmZvR2V0VXJsID0gZ2V0QXBpKFxcXCJpbmZvR2V0VXJsXFxcIikgKyB1c2VybmFtZTtcXG5sZXQgc2V0dGluZ3NHZXRVcmwgPSBnZXRBcGkoXFxcInNldHRpbmdzR2V0VXJsXFxcIikgKyB1c2VybmFtZTtcXG5wdXRNeVZhcihcXFwiZGV2X3NldF9pbmZvXFxcIiwgW3VzZXJuYW1lLCBwYXNzd29yZCwgaW5mb1NldFVybCwgTU9CSUxFX1VBLCBpbmZvR2V0VXJsXS5qb2luKFxcXCIkJFxcXCIpKTtcXG5sZXQgZGF0YSA9IFtdO1xcbmRhdGEucHVzaCh7XFxuICAgIHRpdGxlOiAn4oCc4oCc4oCd4oCdPGJpZz7ku5PlupPorr7nva48L2JpZz4mbmJzcDsmbmJzcDsmbmJzcDs8c21hbGw+PHU+77yIIOS4quS6uui1hOaWmSA+77yJPC91Pjwvc21hbGw+JyxcXG4gICAgZGVzYzogJ+KAnOKAnOKAneKAneaCqOWFseaciSA8c3BhbiBzdHlsZT1cXFwiY29sb3I6ICNmZjcwMDBcXFwiPicgKyBydWxlTGlzdC5sZW5ndGggKyAnPC9zcGFuPicgKyBcXFwiIOadoeinhOWImeOAglxcXFxu54K55Ye76KeE5YiZ5Y+v6L+b6KGM5YiG5Lqr44CB5Yig6Zmk44CB5a+85YWl5pON5L2c5Y+K5p+l55yL6K+m5oOFXFxcIixcXG4gICAgdXJsOiBcXFwiaGlrZXI6Ly9wYWdlL1BlcnNvbmFsRGF0YSNub0hpc3RvcnkjI25vUmVjb3JkSGlzdG9yeSNcXFwiLFxcbiAgICBleHRyYTp7aWQ6ZGV2LmlkfSxcXG4gICAgY29sX3R5cGU6ICd0ZXh0XzEnXFxufSk7XFxubWFwQ29sVHlwZShkYXRhLCBcXFwibGluZVxcXCIsIDIpO1xcbmRhdGEucHVzaCh7XFxuICAgIHRpdGxlOiBzbWFsbChjb2xvcihcXFwi5pu05pS55YWs5ZGK4pyNXFxcIiwgXFxcIiMzNGIxZmZcXFwiKSksXFxuICAgIC8vIHVybDogXFxcIng1Oi8vZmlsZTovLy9zdG9yYWdlL2VtdWxhdGVkLzAvQW5kcm9pZC9kYXRhL2NvbS5leGFtcGxlLmhpa2Vydmlldy9maWxlcy9Eb2N1bWVudHMvcnVsZXMvZHpIb3VzZS9odG1sL2Rldl9pbmZvX2VkaXQuaHRtbFxcXCIsXFxuICAgIHVybDogXFxcImhpa2VyOi8vcGFnZS9kZXZJbmZvRWRpdFxcXCIsXFxuICAgIGNvbF90eXBlOiAndGV4dF8zJ1xcbn0pO1xcbmRhdGEucHVzaCh7XFxuICAgIHRpdGxlOiBzbWFsbChjb2xvcihcXFwi5pu05aSa5YiG5Lqr8J+TslxcXCIsIFxcXCIjMzRiMWZmXFxcIikpLFxcbiAgICAvL3VybDogXFxcIng1Oi8vZmlsZTovLy9zdG9yYWdlL2VtdWxhdGVkLzAvQW5kcm9pZC9kYXRhL2NvbS5leGFtcGxlLmhpa2Vydmlldy9maWxlcy9Eb2N1bWVudHMvcnVsZXMvZHpIb3VzZS9odG1sL+W8gOWPkeiAheWIhuS6qy5odG1sXFxcIixcXG4gICAgdXJsOiBcXFwiaGlrZXI6Ly9wYWdlL21vcmVTaGFyZVxcXCIsXFxuICAgIGNvbF90eXBlOiAndGV4dF8zJ1xcbn0pO1xcbmRhdGEucHVzaCh7XFxuICAgIHRpdGxlOiBzbWFsbChjb2xvcihcXFwi5Y2H57qn5L6d6LWW8J+TpVxcXCIsIFxcXCIjMzRiMWZmXFxcIikpLFxcbiAgICB1cmw6ICQoXFxcIuWNh+e6p+S8mumHjeaWsOS7juS7k+W6k+aLieWPluebuOWFs+eahOmdmeaAgemhtemdouWIsOacrOWcsFxcXFxu56Gu6K6k5Y2H57qn5ZCXP1xcXCIpLmNvbmZpcm0oKGhvc3QpID0+IHtcXG4gICAgICAgIHdyaXRlRmlsZShcXFwiaGlrZXI6Ly9maWxlcy9ydWxlcy9kekhvdXNlL2h0bWwv5byA5Y+R6ICF5YiG5LqrLmh0bWxcXFwiLCByZXF1ZXN0KGhvc3QrJy9oaWtlcnVsZS9ydWxlbGlzdC5qc29uP2lkPTUzOScpKTtcXG4gICAgICAgIHdyaXRlRmlsZShcXFwiaGlrZXI6Ly9maWxlcy9ydWxlcy9kekhvdXNlL2h0bWwvZGV2X2luZm9fZWRpdC5odG1sXFxcIiwgcmVxdWVzdChob3N0KycvaGlrZXJ1bGUvcnVsZWxpc3QuanNvbj9pZD00MDInKSk7XFxuICAgICAgICB3cml0ZUZpbGUoXFxcImhpa2VyOi8vZmlsZXMvcnVsZXMvZHpIb3VzZS9odG1sL2Rldl9pbmZvX2dldC5odG1sXFxcIiwgcmVxdWVzdChob3N0KycvaGlrZXJ1bGUvcnVsZWxpc3QuanNvbj9pZD00MDQnKSk7XFxuICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxuICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5bey6YeN572u5byA5Y+R6ICF5YiG5LqrLOeugOS7i+afpeeciyznroDku4vnvJbovpHnrYnpnZnmgIHmlofku7ZcXFwiO1xcbiAgICB9LGFwaS5ob3N0KSxcXG4gICAgY29sX3R5cGU6ICd0ZXh0XzMnXFxufSk7XFxubGV0IGRldlNldEJhY2s7XFxudHJ5IHtcXG4gICAgZGV2U2V0QmFjayA9IEpTT04ucGFyc2UocmVxdWVzdChzZXR0aW5nc0dldFVybCkpO1xcbn0gY2F0Y2ggKGUpIHtcXG4gICAgZGV2U2V0QmFjayA9IHt9O1xcbn1cXG5cXG5mdW5jdGlvbiBzZXRTZXR0aW5nSXRlbShiYXNpYykge1xcbiAgICBsZXQgdGVtcCA9IHtcXG4gICAgICAgIHRpdGxlOiBiYXNpYy50aXRsZSxcXG4gICAgICAgIGNvbF90eXBlOiBiYXNpYy5jb2xfdHlwZSxcXG4gICAgICAgIHVybDogJChiYXNpYy5jb25maXJtKS5jb25maXJtKCh1cmwsIG1zZykgPT4ge1xcbiAgICAgICAgICAgIGxldCBiYWNrID0gcmVxdWVzdCh1cmwpO1xcbiAgICAgICAgICAgIGxldCByZXQgPSBKU09OLnBhcnNlKGJhY2spO1xcbiAgICAgICAgICAgIGlmIChyZXQuc3RhdHVzID09IDApIHtcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UodHJ1ZSk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly9cXFwiICsgbXNnWzBdO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL1xcXCIgKyBtc2dbMV0gKyBcXFwiXFxcXG5cXFwiICsgcmV0LmRldGFpbDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LCBiYXNpYy51cmwsIGJhc2ljLm1zZylcXG4gICAgfTtcXG4gICAgcmV0dXJuIHRlbXA7XFxufVxcbmlmIChkZXZTZXRCYWNrLnN0YXR1cyA9PSAwKSB7XFxuICAgIGxldCBkZXZTZXR0aW5ncyA9IGRldlNldEJhY2sucmVzdWx0O1xcbiAgICBsZXQgc2hhcmUgPSB7XFxuICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfM1xcXCJcXG4gICAgfTtcXG4gICAgaWYgKGRldlNldHRpbmdzLnNoYXJlX3B1YmxpYykge1xcbiAgICAgICAgc2hhcmUudGl0bGUgPSBzbWFsbChjb2xvcihcXFwi5YWs5byA5LiK5LygXFxcIiwgXFxcImdyZWVuXFxcIikgKyBjb2xvcihcXFwiKOengeiXjylcXFwiLCBcXFwiIzAwYmZmZlxcXCIpKTtcXG4gICAgICAgIHNoYXJlLnVybCA9IGdldEFwaShcXFwiZ3VwbG9hZFxcXCIpICsgXFxcIj9xcT1cXFwiICsgdXNlcm5hbWUgKyBcXFwiJnBhc3N3b3JkPVxcXCIgKyBwYXNzd29yZCArIFxcXCImZmxhZz0xXFxcIjtcXG4gICAgICAgIHNoYXJlLmNvbmZpcm0gPSBcXFwi5piv5ZCm56Gu6K6k56eB6JeP5Lul5ZCO5o+Q5Lqk55qE6KeE5YiZP1xcXCI7XFxuICAgICAgICBzaGFyZS5tc2cgPSBbXFxcIuW3suengeiXj1xcXCIsIFxcXCLnp4Hol4/lpLHotKVcXFwiXTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHNoYXJlLnRpdGxlID0gc21hbGwoY29sb3IoXFxcIuengeWvhuS4iuS8oFxcXCIsIFxcXCJyZWRcXFwiKSArIGNvbG9yKFxcXCIo5YWs5byAKVxcXCIsIFxcXCIjYWRmZjJmXFxcIikpO1xcbiAgICAgICAgc2hhcmUudXJsID0gZ2V0QXBpKFxcXCJndXBsb2FkXFxcIikgKyBcXFwiP3FxPVxcXCIgKyB1c2VybmFtZSArIFxcXCImcGFzc3dvcmQ9XFxcIiArIHBhc3N3b3JkO1xcbiAgICAgICAgc2hhcmUuY29uZmlybSA9IFxcXCLmmK/lkKbnoa7orqTlhazlvIDku6XlkI7mj5DkuqTnmoTop4TliJk/XFxcIjtcXG4gICAgICAgIHNoYXJlLm1zZyA9IFtcXFwi5bey5YWs5byAXFxcIiwgXFxcIuWFrOW8gOWksei0pVxcXCJdO1xcbiAgICB9XFxuICAgIGRhdGEucHVzaChzZXRTZXR0aW5nSXRlbShzaGFyZSkpO1xcbiAgICBsZXQgdGltZU92ZXIgPSB7XFxuICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfM1xcXCJcXG4gICAgfTtcXG4gICAgaWYgKGRldlNldHRpbmdzLnRpbWVfb3Zlcikge1xcbiAgICAgICAgdGltZU92ZXIudGl0bGUgPSBzbWFsbChjb2xvcihcXFwi55+t5pe256eY6ZKlXFxcIiwgXFxcImdyZWVuXFxcIikgKyBjb2xvcihcXFwiKOawuOS5hSlcXFwiLCBcXFwiIzAwYmZmZlxcXCIpKTtcXG4gICAgICAgIHRpbWVPdmVyLnVybCA9IGdldEFwaShcXFwiZ3RpbWVvdmVyXFxcIikgKyBcXFwiP3FxPVxcXCIgKyB1c2VybmFtZSArIFxcXCImcGFzc3dvcmQ9XFxcIiArIHBhc3N3b3JkICsgXFxcIiZmbGFnPTFcXFwiO1xcbiAgICAgICAgdGltZU92ZXIuY29uZmlybSA9IFxcXCLmmK/lkKbnoa7orqTku6XlkI7nmoTnp4Hol4/op4TliJnliIbkuqvkuI3ov4fmnJ8/XFxcIjtcXG4gICAgICAgIHRpbWVPdmVyLm1zZyA9IFtcXFwi5bey6K6+5Li65rC45LmFXFxcIiwgXFxcIuiuvuS4uuawuOS5heWksei0pVxcXCJdO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgdGltZU92ZXIudGl0bGUgPSBzbWFsbChjb2xvcihcXFwi5rC45LmF56eY6ZKlXFxcIiwgXFxcInJlZFxcXCIpICsgY29sb3IoXFxcIijov4fmnJ8pXFxcIiwgXFxcIiNhZGZmMmZcXFwiKSk7XFxuICAgICAgICB0aW1lT3Zlci51cmwgPSBnZXRBcGkoXFxcImd0aW1lb3ZlclxcXCIpICsgXFxcIj9xcT1cXFwiICsgdXNlcm5hbWUgKyBcXFwiJnBhc3N3b3JkPVxcXCIgKyBwYXNzd29yZDtcXG4gICAgICAgIHRpbWVPdmVyLmNvbmZpcm0gPSBcXFwi56Gu6K6k6KaB5Lul5ZCO5YiG5Lqr55qE56eB6JeP6KeE5YiZ6Ieq5Yqo5Yiw5pyfP1xcXCI7XFxuICAgICAgICB0aW1lT3Zlci5tc2cgPSBbXFxcIuW3suiuvuS4uui/h+acn1xcXCIsIFxcXCLorr7kuLrov4fmnJ/lpLHotKVcXFwiXTtcXG4gICAgfVxcbiAgICBkYXRhLnB1c2goc2V0U2V0dGluZ0l0ZW0odGltZU92ZXIpKTtcXG4gICAgbGV0IGRpc2N1c3MgPSB7XFxuICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfM1xcXCJcXG4gICAgfTtcXG4gICAgaWYgKGRldlNldHRpbmdzLmNhbl9kaXNjdXNzKSB7XFxuICAgICAgICBkaXNjdXNzLnRpdGxlID0gc21hbGwoY29sb3IoXFxcIuWFgeiuuOivhOiuulxcXCIsIFxcXCJyZWRcXFwiKSArIGNvbG9yKFxcXCIo5LiN6K64KVxcXCIsIFxcXCIjYWRmZjJmXFxcIikpO1xcbiAgICAgICAgZGlzY3Vzcy51cmwgPSBhcGkuZGlzX2Rldl9kaXNjdXNzICsgXFxcIj9xcT1cXFwiICsgdXNlcm5hbWUgKyBcXFwiJnBhc3N3b3JkPVxcXCIgKyBwYXNzd29yZCsgXFxcIiZmbGFnPTFcXFwiO1xcbiAgICAgICAgZGlzY3Vzcy5jb25maXJtID0gXFxcIuaYr+WQpuehruiupOS7peWQjuS4iuS8oOeahOinhOWImeWFgeiuuOivhOiuuj9cXFwiO1xcbiAgICAgICAgZGlzY3Vzcy5tc2cgPSBbXFxcIuW3suiuvuS4uuS4jeiuuFxcXCIsIFxcXCLorr7nva7lpLHotKVcXFwiXTtcXG5cXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGRpc2N1c3MudGl0bGUgPSBzbWFsbChjb2xvcihcXFwi5LiN6K646K+E6K66XFxcIiwgXFxcImdyZWVuXFxcIikgKyBjb2xvcihcXFwiKOWFgeiuuClcXFwiLCBcXFwiIzAwYmZmZlxcXCIpKTtcXG4gICAgICAgIGRpc2N1c3MudXJsID0gYXBpLmRpc19kZXZfZGlzY3VzcyArIFxcXCI/cXE9XFxcIiArIHVzZXJuYW1lICsgXFxcIiZwYXNzd29yZD1cXFwiICsgcGFzc3dvcmQ7XFxuICAgICAgICBkaXNjdXNzLmNvbmZpcm0gPSBcXFwi5piv5ZCm56Gu6K6k5Lul5ZCO5LiK5Lyg55qE6KeE5YiZ5YWB6K646K+E6K66P1xcXCI7XFxuICAgICAgICBkaXNjdXNzLm1zZyA9IFtcXFwi5bey6K6+5Li65YWB6K64XFxcIiwgXFxcIuiuvue9ruWksei0pVxcXCJdO1xcbiAgICB9XFxuICAgIGRhdGEucHVzaChzZXRTZXR0aW5nSXRlbShkaXNjdXNzKSk7XFxufVxcbm1hcENvbFR5cGUoZGF0YSwgXFxcImxpbmVcXFwiLCAyKTtcXG5mb3IgKGxldCBpdGVtIG9mIHJ1bGVMaXN0KSB7XFxuICAgIGxldCBteV90X2V4Y29kZTEgPSAnJztcXG4gICAgbGV0IG15X3RfZXhjb2RlMiA9ICcnO1xcbiAgICBpZiAoaXRlbS5zdGF0ZSAhPSAncHVibGljJykge1xcbiAgICAgICAgbXlfdF9leGNvZGUxICs9ICfjipnvuI8nO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgbXlfdF9leGNvZGUxICs9ICcnO1xcbiAgICB9XFxuICAgIGRhdGEucHVzaCh7XFxuICAgICAgICB0aXRsZTogbXlfdF9leGNvZGUxICsgaXRlbS5uYW1lICsgbXlfdF9leGNvZGUyLFxcbiAgICAgICAgdXJsOiBcXFwiaGlrZXI6Ly9wYWdlL21hbmFnZVJ1bGUjbm9IaXN0b3J5IyNub1JlY29yZEhpc3RvcnkjXFxcIixcXG4gICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgaWQ6IGl0ZW0uaWQsXFxuICAgICAgICAgICAgLy91c2VybmFtZTogdXNlcm5hbWUsXFxuICAgICAgICAgICAgLy9wYXNzd29yZDogcGFzc3dvcmRcXG4gICAgICAgIH0sXFxuICAgICAgICBwaWNfdXJsOiBpdGVtLnBpYyxcXG4gICAgfSlcXG59XFxuaWYgKHJ1bGVMaXN0Lmxlbmd0aCA9PT0gMCkge1xcbiAgICBkYXRhLnB1c2goe1xcbiAgICAgICAgdGl0bGU6IFxcXCI8aDUgc3R5bGU9J3RleHQtYWxpZ246Y2VudGVyJz7lv6vmnaXkuIrkvKDkvaDnmoTnrKzkuIDmnaHop4TliJnlkKfvvIE8L2g1PlxcXCIsXFxuICAgICAgICBjb2xfdHlwZTogXFxcInJpY2hfdGV4dFxcXCJcXG4gICAgfSk7XFxufVxcbnNldFJlc3VsdChkYXRhKTtcIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuinhOWImeivpue7hi1kZXZcIixcInBhdGhcIjpcIm1hbmFnZVJ1bGVcIixcInJ1bGVcIjpcImpzOlxcbiAgICBjb25zdCB7XFxuICAgICAgICBnZXRBcGksXFxuICAgICAgICBjb2xvcixcXG4gICAgICAgIHNtYWxsLFxcbiAgICAgICAgZ2V0RmlsZSxcXG4gICAgICAgIGV4aXN0RmlsZSxcXG4gICAgICAgIG1hcENvbFR5cGUsXFxuICAgICAgICBodG1sVGFnLFxcbiAgICAgICAgYXBpLFxcbiAgICAgICAgbWQsXFxuICAgIH0gPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS91dGlsaXlcXFwiKTtcXG5sZXQge1xcbiAgICBpZFxcbn0gPSBNWV9QQVJBTVM7XFxubGV0IHtcXG4gICAgdXNlcm5hbWUsXFxuICAgIHBhc3N3b3JkLFxcbn0gPSBnZXRGaWxlKCk7XFxuYWRkTGlzdGVuZXIoJ29uQ2xvc2UnLCAkLnRvU3RyaW5nKCgpID0+IHtcXG4gICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcbn0pKTtcXG5sZXQgZGF0YUl0ZW0gPSBKU09OLnBhcnNlKHJlcXVlc3QoZ2V0QXBpKFxcXCJnZXRieWlkXFxcIikgKyBcXFwiP2lkPVxcXCIgKyBpZCkpLnJlc3VsdDtcXG5zZXRQYWdlVGl0bGUoXFxcIue8lui+keOAjFxcXCIgKyBkYXRhSXRlbS5uYW1lICsgXFxcIuOAjVxcXCIpO1xcbmxldCByZXFCeUdldCA9IFxcXCI/aWQ9XFxcIiArIGRhdGFJdGVtLmlkICsgXFxcIiZxcT1cXFwiICsgdXNlcm5hbWUgKyBcXFwiJnBhc3N3b3JkPVxcXCIgKyBwYXNzd29yZDtcXG5sZXQgcnVsZUxpc3RKc29uID0gZ2V0QXBpKFxcXCJydWxlTGlzdEpzb25cXFwiKSArIFxcXCI/aWQ9XFxcIjtcXG5sZXQgZGF0YSA9IFtdO1xcbmRhdGEucHVzaCh7XFxuICAgIHRpdGxlOiBodG1sVGFnKFxcXCJiaWdcXFwiLCBcXFwi54mI5pysXFxcIiksXFxuICAgIGRlc2M6IFxcXCLigJzigJzigJ3igJ3kupHnq6/niYjmnKw6XFxcIiArIGNvbG9yKGRhdGFJdGVtLnZlciwgXFxcIiM1Y2ZmMmNcXFwiKSArIFxcXCJcXFxcbuS4iuasoeaPkOS6pOS6jjogW1xcXCIgKyBjb2xvcihkYXRhSXRlbS5sYXN0X3VwZGF0ZSwgXFxcIiNmZjcwMDBcXFwiKSArIFxcXCJdXFxcIixcXG4gICAgdXJsOiAkKFxcXCI85byA5Y+R6ICFPlxcXFxuXFxcIiArIGRhdGFJdGVtLmF1dGhvciArIFxcXCJcXFxcbjzlkI3np7A+XFxcXG5cXFwiICsgZGF0YUl0ZW0ubmFtZSArIFxcXCJcXFxcbjzkupHnq6/niYjmnKw+XFxcXG5cXFwiICsgZGF0YUl0ZW0udmVyICsgXFxcIlxcXFxuPOabtOaWsOaXtumXtD5cXFxcbltcXFwiICsgZGF0YUl0ZW0ubGFzdF91cGRhdGUgKyBcXFwiXVxcXCIpLmNvbmZpcm0oKCkgPT4ge30pLFxcbiAgICBjb2xfdHlwZTogJ3RleHRfMSdcXG59KTtcXG5sZXQgZGF0YVR5cGUgPSB7XFxuICAgIGhvbWVfcnVsZV91cmw6ICfpppbpobXkupHop4TliJknLFxcbiAgICBwdWJsaXNoOiAn5o+Q5Lqk5LqR5LuT5bqT6KeE5YiZJyxcXG4gICAganNfdXJsOiAn572R6aG15o+S5Lu26KeE5YiZJyxcXG4gICAgaHRtbDogJ+mdmeaAgemhtemdoicsXFxuICAgIGNvbmZpZzogJ+S4u+mhtemFjee9ridcXG59O1xcblxcbmxldCBiYXNpYyA9IHtcXG4gICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiLFxcbiAgICB1cmw6IFxcXCJoaWtlcjovL2VtcHR5XFxcIlxcbn07XFxubGV0IGRhdGFUeXBlVGlwcyA9IGRhdGFUeXBlW2RhdGFJdGVtLmRhdGFfdHlwZV0gfHwgJ+acquefpeinhOWImTonICsgZGF0YUl0ZW0uZGF0YV90eXBlO1xcblxcbmJhc2ljLnRpdGxlID0gaHRtbFRhZyhcXFwiYmlnXFxcIiwgXFxcIuexu+Wei1xcXCIpICsgXFxcIlxcXFx0XFxcXHRcXFxcdFxcXCIgKyBzbWFsbChcXFwiKGlkOlxcXCIgKyBkYXRhSXRlbS5pZCArIFxcXCIpXFxcIik7XFxuYmFzaWMuZGVzYyA9IFxcXCLmlbDmja7nsbvlnovvvJpcXFwiICsgY29sb3IoZGF0YVR5cGVUaXBzLCBcXFwiI2NiNTRmZlxcXCIpICsgXFxcIlxcXFxu5YiG5Lqr54q25oCB5Li677yaXFxcIiArIGRhdGFJdGVtLnN0YXRlO1xcbmlmIChbXFxcImh0bWxcXFwiLCBcXFwiY29uZmlnXFxcIiwgXFxcImpzX3VybFxcXCJdLmluY2x1ZGVzKGRhdGFJdGVtLmRhdGFfdHlwZSkpIHtcXG4gICAgYmFzaWMuZGVzYyArPSBcXFwiXFxcXG7igJzigJzigJ3igJ0gPT5cXFwiICsgc21hbGwoXFxcIueCueatpOmihOiniFxcXCIpO1xcbiAgICBiYXNpYy51cmwgPSBydWxlTGlzdEpzb24gKyBkYXRhSXRlbS5pZDtcXG59XFxubGV0IGF1dGggPSBcXFwiXFxcIjtcXG5pZiAoZGF0YUl0ZW0uc3RhdGUgPT0gXFxcInByaXZhdGVcXFwiKSB7XFxuICAgIGxldCBhdXRoX2JhY2sgPSBKU09OLnBhcnNlKHJlcXVlc3QoZ2V0QXBpKFxcXCJhdXRoXFxcIikgKyByZXFCeUdldCkpO1xcbiAgICBiYXNpYy50aXRsZSA9IGJhc2ljLnRpdGxlICsgXFxcIlxcXFxuXFxcIiArIHNtYWxsKGNvbG9yKGF1dGhfYmFjay5yZXN1bHQsIFxcXCJncmV5XFxcIikpO1xcbiAgICBhdXRoID0gJyZhdXRoPScgKyBhdXRoX2JhY2sucmVzdWx0O1xcbiAgICBiYXNpYy51cmwgPSBiYXNpYy51cmwgPT09IFxcXCJoaWtlcjovL2VtcHR5XFxcIiA/IGJhc2ljLnVybCA6IGJhc2ljLnVybCArIGF1dGg7XFxufVxcbmRhdGEucHVzaChiYXNpYyk7XFxubGV0IG5vdGVzID0gcmVxdWVzdChnZXRBcGkoXFxcImdldF9ydWxlX25vdGVcXFwiKSArIGlkKTtcXG5ub3RlcyA9IEpTT04ucGFyc2Uobm90ZXMpLnJlc3VsdDtcXG5yZXF1aXJlKG1kKTtcXG5sZXQgbm90ZXNIdG1sPVxcXCJcXFwiXFxudHJ5e1xcbiAgICBub3Rlc0h0bWw9bWFya2VkLnBhcnNlKG5vdGVzKTtcXG59Y2F0Y2goZSl7fVxcbmlmIChub3RlcyAhPT0gZmFsc2UpIHtcXG4gICAgZGF0YS5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBodG1sVGFnKFxcXCJiaWdcXFwiLCBcXFwi5aSH5rOoXFxcIikgKyBcXFwiXFxcXHRcXFxcdFxcXFx0XFxcIiArIHNtYWxsKGh0bWxUYWcoXFxcInVcXFwiLCBcXFwi5p+l55yL5a6M5pW05YWs5ZGKID5cXFwiKSksXFxuICAgICAgICBkZXNjOiBub3RlcyxcXG4gICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF8xXFxcIixcXG4gICAgICAgIHVybDogXFxcImhpa2VyOi8vcGFnZS9pbmZvXFxcIixcXG4gICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgdGV4dDogbm90ZXNIdG1sLFxcbiAgICAgICAgICAgIG5hbWU6IGRhdGFJdGVtLm5hbWUsXFxuICAgICAgICAgICAgLy8gdHlwZTogXFxcImxvbmdfdGV4dFxcXCJcXG4gICAgICAgICAgICB0eXBlOiBcXFwicmljaF90ZXh0XFxcIlxcbiAgICAgICAgfVxcbiAgICB9KTtcXG59XFxuZGF0YS5wdXNoKHtcXG4gICAgdGl0bGU6IGh0bWxUYWcoXFxcImJpZ1xcXCIsIFxcXCLmk43kvZxcXFwiKSxcXG4gICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiLFxcbiAgICB1cmw6IFxcXCJ0b2FzdDovL+S9oOaJjeaYr+acgOW4heeahOmCo+S4quS6uu+8gVxcXCJcXG59KTtcXG5sZXQgaW1wb3J0VXJsLCBydWxlQ29kZSwgc2hhcmVVcmwsIGJhY2tDb2RlID0gXFxcIlxcXCI7XFxubGV0IHN1YlVybCA9IHJ1bGVMaXN0SnNvbiArIGRhdGFJdGVtLmlkICsgYXV0aDtcXG5pZiAoIWRhdGFJdGVtLmlzX2pzb24pIHtcXG4gICAgYmFja0NvZGUgPSByZXF1ZXN0KHN1YlVybCk7XFxufVxcbnN3aXRjaCAoZGF0YUl0ZW0uZGF0YV90eXBlKSB7XFxuICAgIGNhc2UgXFxcImhvbWVfcnVsZV91cmxcXFwiOlxcbiAgICAgICAgcnVsZUNvZGUgPSBcXFwi5rW36ZiU6KeG55WM6aaW6aG16aKR6YGT6KeE5YiZ44CQXFxcIiArIGRhdGFJdGVtLm5hbWUgKyBcXFwi44CR77+laG9tZV9ydWxlX3VybO+/pVxcXCIgKyBydWxlTGlzdEpzb24gKyBkYXRhSXRlbS5pZCArIGF1dGg7XFxuICAgICAgICBpbXBvcnRVcmwgPSBcXFwicnVsZTovL1xcXCIgKyBiYXNlNjRFbmNvZGUocnVsZUNvZGUpXFxuICAgICAgICBicmVhaztcXG4gICAgY2FzZSAncHVibGlzaCc6XFxuICAgICAgICBydWxlQ29kZSA9ICfmtbfpmJTop4bnlYzop4TliJnliIbkuqvvvIzlvZPliY3liIbkuqvnmoTmmK/vvJonICsgZGF0YUl0ZW0ubmFtZSArICfvv6VwdWJsaXNo77+lJyArIGJhc2U2NEVuY29kZShiYWNrQ29kZSk7XFxuICAgICAgICBpbXBvcnRVcmwgPSAncnVsZTovLycgKyBiYXNlNjRFbmNvZGUocnVsZUNvZGUpO1xcbiAgICAgICAgYnJlYWs7XFxuICAgIGNhc2UgJ2pzX3VybCc6XFxuICAgICAgICBydWxlQ29kZSA9ICfmtbfpmJTop4bnlYzop4TliJnliIbkuqvvvIzlvZPliY3liIbkuqvnmoTmmK/vvJrnvZHpobXmj5Lku7bvv6Vqc191cmzvv6UnICsgZGF0YUl0ZW0ubmFtZSArICdAYmFzZTY0Oi8vJyArIGJhc2U2NEVuY29kZShiYWNrQ29kZSk7XFxuICAgICAgICBpbXBvcnRVcmwgPSAncnVsZTovLycgKyBiYXNlNjRFbmNvZGUocnVsZUNvZGUpO1xcbiAgICAgICAgYnJlYWs7XFxuICAgIGNhc2UgJ2h0bWwnOlxcbiAgICAgICAgbGV0IGZpbGVfdG1wID0gZGF0YUl0ZW0ubmFtZS5zcGxpdCgnLicpO1xcbiAgICAgICAgbGV0IGZpbGVfcGF0aCA9IGZpbGVfdG1wLmxlbmd0aCA+IDEgPyBmaWxlX3RtcFtmaWxlX3RtcC5sZW5ndGggLSAxXSArIFxcXCIvXFxcIiArIGRhdGFJdGVtLm5hbWUgOiBkYXRhSXRlbS5uYW1lO1xcbiAgICAgICAgcnVsZUNvZGUgPSBcXFwi5rW36ZiU6KeG55WM5pys5Zyw5paH5Lu25YiG5Lqr77+lZmlsZV91cmzvv6VoaWtlcjovL2ZpbGVzL3J1bGVzL2R6SG91c2UvXFxcIiArIGZpbGVfcGF0aCArIFxcXCJAXFxcIiArIHJ1bGVMaXN0SnNvbiArIGRhdGFJdGVtLmlkICsgYXV0aDtcXG4gICAgICAgIGltcG9ydFVybCA9ICdydWxlOi8vJyArIGJhc2U2NEVuY29kZShydWxlQ29kZSk7XFxuICAgICAgICBicmVha1xcbiAgICBjYXNlIFxcXCJjb25maWdcXFwiOlxcbiAgICAgICAgaW1wb3J0VXJsID0gJCgpLnJ1bGUocGFzc3dvcmQgPT4ge1xcbiAgICAgICAgICAgIGV2YWwoZmV0Y2goXFxcImhpa2VyOi8vYXNzZXRzL2hvbWUuanNcXFwiKSk7XFxuICAgICAgICAgICAgSGlrZXJIb21lLmxvYWQoXFxcImltcG9ydFxcXCIsIHBhc3N3b3JkKTtcXG4gICAgICAgIH0sIGJhY2tDb2RlKTtcXG4gICAgICAgIGJyZWFrO1xcbn1cXG5sZXQgbXlfY29sX3R5cGUgPSBcXFwidGV4dF8yXFxcIjtcXG5pZiAoaW1wb3J0VXJsKSB7XFxuICAgIGRhdGEucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIuWvvOWFpeinhOWImVxcXCIsXFxuICAgICAgICB1cmw6IGltcG9ydFVybCxcXG4gICAgICAgIGNvbF90eXBlOiBteV9jb2xfdHlwZVxcbiAgICB9KTtcXG4gICAgaWYoZGF0YUl0ZW0uaXNfanNvbl9saXN0JiYvaG9tZV9ydWxlX3VybHxodG1sLy50ZXN0KGRhdGFJdGVtLmRhdGFfdHlwZSkpe1xcbiAgICAgICAgZGF0YS5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogJ+KAnOKAnOKAneKAnTxzcGFuIHN0eWxlPVxcXCJjb2xvcjogI2ZmNzAwMFxcXCI+5a+85YWl6YGT5b6357uPPC9zcGFuPicsXFxuICAgICAgICAgICAgdXJsOiAkKCkubGF6eVJ1bGUoKGRhdGFJdGVtLHN1YlVybCk9PntcXG4gICAgICAgICAgICAgICAgLy8gbGV0IHRpdGxlID0gXFxcIkgtXFxcIitkYXRhSXRlbS5uYW1lK1xcXCIuXFxcIitkYXRhSXRlbS5hdXRob3I7XFxuICAgICAgICAgICAgICAgIGxldCB0aXRsZSA9IFxcXCJKLVxcXCIrZGF0YUl0ZW0ubmFtZS5zcGxpdCgnLicpWzBdO1xcbiAgICAgICAgICAgICAgICBsZXQgc3ViT2JqID0ge1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBzdWJVcmwsXFxuICAgICAgICAgICAgICAgICAgICBkZXNjOiBcXFwiaGlrZXI6Ly9maWxlcy9ydWxlcy9kekhvdXNlL3J1bGVDYWNoZS9cXFwiK3RpdGxlK1xcXCIuanNvblxcXCIsXFxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBcXFwiXFxcIixcXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZTogZmFsc2UsLy/npoHnlKjlubblj5Hmm7TmlrBcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBsZXQgc2hhcmVUZXh0ID0gYmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KHN1Yk9iaikpO1xcbiAgICAgICAgICAgICAgICB2YXIgcGFzdGVzID0gZ2V0UGFzdGVzKCk7XFxuICAgICAgICAgICAgICAgIHZhciB1cmwgPSBzaGFyZVBhc3RlKHNoYXJlVGV4dCxwYXN0ZXMuc2xpY2UoLTEpWzBdKTtcXG4gICAgICAgICAgICAgICAgbGV0IGltcG9ydF9ydWxlPSBcXFwi6L275ZCI6ZuG6K6i6ZiF77yaXFxcIit0aXRsZSsnXFxcXG4nK3VybDtcXG4gICAgICAgICAgICAgICAgY29weShpbXBvcnRfcnVsZSk7XFxuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSAnaGlrZXI6Ly9maWxlcy9ydWxlcy9kekhvdXNlL3J1bGVDYWNoZS9zdWIuanNvbic7XFxuICAgICAgICAgICAgICAgICQucmMoY29uZmlnLmxpYi5zdWIpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4g6K6i6ZiF5a+85YWlKHBhdGgpXFxuICAgICAgICAgICAgfSxkYXRhSXRlbSxzdWJVcmwpLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBteV9jb2xfdHlwZVxcbiAgICAgICAgfSk7XFxuICAgIH1cXG59XFxuaWYgKHJ1bGVDb2RlKSB7XFxuICAgIGRhdGEucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIuWIhuS6q+inhOWImVxcXCIsXFxuICAgICAgICB1cmw6IFxcXCJjb3B5Oi8vXFxcIiArIHJ1bGVDb2RlLFxcbiAgICAgICAgY29sX3R5cGU6IG15X2NvbF90eXBlXFxuICAgIH0pO1xcbn1cXG5cXG5mdW5jdGlvbiBzZXRTZXR0aW5nSXRlbShiYXNpYywgcGF0dGVybikge1xcbiAgICBsZXQgdGVtcCA9IHtcXG4gICAgICAgIHRpdGxlOiBiYXNpYy50aXRsZSxcXG4gICAgICAgIGNvbF90eXBlOiBiYXNpYy5jb2xfdHlwZSxcXG4gICAgICAgIHVybDogJChiYXNpYy5jb25maXJtKS5jb25maXJtKCh1cmwsIG1zZywgcGF0dGVybikgPT4ge1xcbiAgICAgICAgICAgIGxldCBiYWNrQSA9IHJlcXVlc3QodXJsKTtcXG4gICAgICAgICAgICBsZXQgcmV0ID0gSlNPTi5wYXJzZShiYWNrQSk7XFxuICAgICAgICAgICAgaWYgKHJldC5zdGF0dXMgPT0gMCkge1xcbiAgICAgICAgICAgICAgICBwYXR0ZXJuID8gYmFjaygpIDogcmVmcmVzaFBhZ2UoZmFsc2UpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8vXFxcIiArIG1zZ1swXTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBwYXR0ZXJuID8gYmFjaygpIDogcmVmcmVzaFBhZ2UoZmFsc2UpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8vXFxcIiArIG1zZ1sxXSArIFxcXCJcXFxcblxcXCIgKyByZXQuZGV0YWlsO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sIGJhc2ljLnVybCwgYmFzaWMubXNnLCBwYXR0ZXJuKVxcbiAgICB9O1xcbiAgICByZXR1cm4gdGVtcDtcXG59XFxuaWYgKGRhdGFJdGVtLnN0YXRlID09ICdwcml2YXRlJykge1xcbiAgICBkYXRhLnB1c2goe1xcbiAgICAgICAgdGl0bGU6IFxcXCLorr7kuLrlhazlvIBcXFwiLFxcbiAgICAgICAgdXJsOiAkKGdldEFwaShcXFwic2hhcmVcXFwiKSArIHJlcUJ5R2V0ICsgXFxcIiZmbGFnXFxcIiArIFxcXCIjbm9Mb2FkaW5nI1xcXCIpLmxhenlSdWxlKCgpID0+IHtcXG4gICAgICAgICAgICByZXF1ZXN0KGlucHV0KTtcXG4gICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+W3suiuvuS4uuWFrOW8gFxcXCI7XFxuICAgICAgICB9KSxcXG4gICAgICAgIGNvbF90eXBlOiBteV9jb2xfdHlwZVxcbiAgICB9LCB7XFxuICAgICAgICB0aXRsZTogXFxcIumaj+acuuWvhumSpVxcXCIsXFxuICAgICAgICBjb2xfdHlwZTogbXlfY29sX3R5cGUsXFxuICAgICAgICB1cmw6ICQoZ2V0QXBpKFxcXCJnZW5BdXRoXFxcIikgKyByZXFCeUdldCArIFxcXCIjbm9Mb2FkaW5nI1xcXCIpLmxhenlSdWxlKCgpID0+IHtcXG4gICAgICAgICAgICBsZXQgYmFjayA9IHJlcXVlc3QoaW5wdXQpO1xcbiAgICAgICAgICAgIGxldCByZXQgPSBKU09OLnBhcnNlKGJhY2spO1xcbiAgICAgICAgICAgIGlmIChyZXQuc3RhdHVzID09IDApIHtcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5bey55Sf5oiQ6ZqP5py65a+G56CBXFxcXG5cXFwiICsgcmV0LnJlc3VsdFxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKHRydWUpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v6ZqP5py65a+G56CB55Sf5oiQ5aSx6LSlXFxcIlxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pXFxuICAgIH0pO1xcbiAgICBsZXQgdGltZU92ZXIgPSB7XFxuICAgICAgICBjb2xfdHlwZTogbXlfY29sX3R5cGVcXG4gICAgfTtcXG4gICAgaWYgKGRhdGFJdGVtLnRpbWVfb3Zlcikge1xcbiAgICAgICAgdGltZU92ZXIudGl0bGUgPSBzbWFsbChjb2xvcihcXFwi55+t5pe25a+G6ZKlXFxcIiwgXFxcImdyZWVuXFxcIikgKyBjb2xvcihcXFwiKOKGkuawuOS5hSlcXFwiLCBcXFwicmVkXFxcIikpO1xcbiAgICAgICAgdGltZU92ZXIudXJsID0gZ2V0QXBpKFxcXCJ0aW1lb3ZlclxcXCIpICsgcmVxQnlHZXQgKyBcXFwiJmZsYWc9MVxcXCI7XFxuICAgICAgICB0aW1lT3Zlci5jb25maXJtID0gXFxcIuaYr+WQpuehruiupOS7peWQjueahOengeiXj+inhOWImeWIhuS6q+S4jei/h+acnz9cXFwiO1xcbiAgICAgICAgdGltZU92ZXIubXNnID0gW1xcXCLlt7Lorr7kuLrmsLjkuYVcXFwiLCBcXFwi6K6+5Li65rC45LmF5aSx6LSlXFxcIl07XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICB0aW1lT3Zlci50aXRsZSA9IHNtYWxsKGNvbG9yKFxcXCLmsLjkuYXlr4bpkqVcXFwiLCBcXFwicmVkXFxcIikgKyBjb2xvcihcXFwiKOKGkuefreaXtilcXFwiLCBcXFwiZ3JlZW5cXFwiKSk7XFxuICAgICAgICB0aW1lT3Zlci51cmwgPSBnZXRBcGkoXFxcInRpbWVvdmVyXFxcIikgKyByZXFCeUdldDtcXG4gICAgICAgIHRpbWVPdmVyLmNvbmZpcm0gPSBcXFwi56Gu6K6k6KaB5Lul5ZCO5YiG5Lqr55qE56eB6JeP6KeE5YiZ6Ieq5Yqo5Yiw5pyfP1xcXCI7XFxuICAgICAgICB0aW1lT3Zlci5tc2cgPSBbXFxcIuW3suiuvuS4uui/h+acn1xcXCIsIFxcXCLorr7kuLrov4fmnJ/lpLHotKVcXFwiXTtcXG4gICAgfVxcbiAgICBkYXRhLnB1c2goc2V0U2V0dGluZ0l0ZW0odGltZU92ZXIpKTtcXG59IGVsc2UgaWYgKGRhdGFJdGVtLnN0YXRlID09ICdwdWJsaWMnKSB7XFxuICAgIGRhdGEucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIuiuvuS4uuengeaciVxcXCIsXFxuICAgICAgICB1cmw6ICQoZ2V0QXBpKFxcXCJzaGFyZVxcXCIpICsgcmVxQnlHZXQgKyBcXFwiJmZsYWc9MSNub0xvYWRpbmcjXFxcIikubGF6eVJ1bGUoKCkgPT4ge1xcbiAgICAgICAgICAgIHJlcXVlc3QoaW5wdXQpO1xcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXG4gICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5bey6K6+5Li656eB5pyJXFxcIjtcXG4gICAgICAgIH0pLFxcbiAgICAgICAgY29sX3R5cGU6IG15X2NvbF90eXBlXFxuICAgIH0pO1xcbn1cXG5kYXRhLnB1c2goc2V0U2V0dGluZ0l0ZW0oe1xcbiAgICB0aXRsZTogXFxcIuWIoOmZpOaVsOaNrlxcXCIsXFxuICAgIGNvbmZpcm06IFxcXCLmmK/lkKbnoa7orqTliKDpmaRcXFwiLFxcbiAgICBtc2c6IFtcXFwi5bey5Yig6ZmkXFxcIiwgXFxcIuWIoOmZpOWksei0pVxcXCJdLFxcbiAgICB1cmw6IGdldEFwaShcXFwiZGVsZXRlVXJsXFxcIikgKyByZXFCeUdldCxcXG4gICAgY29sX3R5cGU6IG15X2NvbF90eXBlXFxufSwgdHJ1ZSkpO1xcbmRhdGEucHVzaCh7XFxuICAgIHRpdGxlOiBcXFwi6K6+572u5Zu+5qCHXFxcIixcXG4gICAgdXJsOiAkKGRhdGFJdGVtLnBpY191cmwsIFxcXCLovpPlhaXlm77moIflnLDlnYBcXFwiKS5pbnB1dChhcGkgPT4ge1xcbiAgICAgICAgaWYgKGlucHV0ID09PSBcXFwiXFxcIikge1xcbiAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/kvaDlnKjpgJfmiJHpk77mjqXlk6o/XFxcIlxcbiAgICAgICAgfVxcbiAgICAgICAgbGV0IHJlc3VsdCA9IHJlcXVlc3QoYXBpICsgXFxcIiZydWxlX3BpYz1cXFwiICsgaW5wdXQpO1xcbiAgICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZShyZXN1bHQpO1xcbiAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgIT09IDApIHtcXG4gICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8vXFxcIiArIHJlc3VsdC5kZXRhaWw7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5L+u5pS55oiQ5YqfXFxcIjtcXG4gICAgfSwgZ2V0QXBpKFxcXCJzZXRfcnVsZV9waWNcXFwiKSArIGRhdGFJdGVtLmlkICsgcmVxQnlHZXQpLFxcbiAgICBjb2xfdHlwZTogbXlfY29sX3R5cGVcXG59KTtcXG5cXG5kYXRhLnB1c2goe1xcbiAgICB0aXRsZTogZGF0YUl0ZW0uY2FuX2Rpc2N1c3MgPyBcXFwi56aB5q2i6K+E6K66XFxcIiA6IFxcXCLlvIDlkK/or4TorrpcXFwiLFxcbiAgICB1cmw6ICQoYXBpLmRpc19zZXQgKyBkYXRhSXRlbS5pZCArIHJlcUJ5R2V0ICsgXFxcIiZzdGF0ZT1cXFwiICsgKGRhdGFJdGVtLmNhbl9kaXNjdXNzID8gXFxcIlxcXCIgOiAxKSkubGF6eVJ1bGUoKGNhbl9kaXNjdXNzKSA9PiB7XFxuICAgICAgICByZXF1ZXN0KGlucHV0KTtcXG4gICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXG4gICAgICAgIHJldHVybiBjYW5fZGlzY3VzcyA/IFxcXCJ0b2FzdDovL+W3suemgeatouivhOiuulxcXCIgOiBcXFwidG9hc3Q6Ly/lt7LlvIDlkK/or4TorrpcXFwiO1xcbiAgICB9LCBkYXRhSXRlbS5jYW5fZGlzY3VzcyksXFxuICAgIGNvbF90eXBlOiBteV9jb2xfdHlwZVxcbn0pO1xcbk1ZX1BBUkFNUy5uYW1lID0gZGF0YUl0ZW0ubmFtZTtcXG5NWV9QQVJBTVMudXNlcm5hbWU9dXNlcm5hbWU7XFxuTVlfUEFSQU1TLnBhc3N3b3JkPXBhc3N3b3JkO1xcbmRhdGEucHVzaCh7XFxuICAgIHRpdGxlOiBcXFwi6K6+572u5aSH5rOoXFxcIixcXG4gICAgdXJsOiBcXFwiaGlrZXI6Ly9wYWdlL3NldF9ydWxlX25vdGVzXFxcIixcXG4gICAgZXh0cmE6IE1ZX1BBUkFNUyxcXG4gICAgY29sX3R5cGU6IG15X2NvbF90eXBlXFxufSk7XFxuaWYgKGRhdGFJdGVtLmlzX2pzb24gJiYgZGF0YUl0ZW0uZGF0YV90eXBlID09PSBcXFwiaG9tZV9ydWxlX3VybFxcXCIgJiYgIWRhdGFJdGVtLmlzX2pzb25fbGlzdCkge1xcbiAgICBkYXRhLnB1c2goe1xcbiAgICAgICAgdGl0bGU6ICfov5vlhaXpopHpgZMnLFxcbiAgICAgICAgdXJsOiAkKCAvKlxcXCIjbm9Mb2FkaW5nI1xcXCIqLyApLmxhenlSdWxlKChuYW1lLGhvbWUpID0+IHtcXG4gICAgICAgICAgICBsZXQgcnVsZUxpc3QgPSBKU09OLnBhcnNlKHJlcXVlc3QoaG9tZSkpO1xcbiAgICAgICAgICAgIGxldCBoYXNSdWxlID0gcnVsZUxpc3Quc29tZShpdGVtID0+IGl0ZW0udGl0bGUgPT09IG5hbWUpO1xcbiAgICAgICAgICAgIGlmIChoYXNSdWxlKSB7XFxuICAgICAgICAgICAgICAgIHB1dFZhcihcXFwiV2FyZWhvdXNlLmJhY2tcXFwiLCBcXFwiMVxcXCIpO1xcbiAgICAgICAgICAgICAgICBiYWNrKCk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBob21lK1xcXCJzQFxcXCIgKyBuYW1lO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/mnKrlronoo4VcXFwiO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sIGRhdGFJdGVtLm5hbWUsYXBpLmhvbWUpLFxcbiAgICAgICAgY29sX3R5cGU6IG15X2NvbF90eXBlXFxuICAgIH0pO1xcbn1cXG5kYXRhLnB1c2goe1xcbiAgICBjb2xfdHlwZTogXFxcImxpbmVfYmxhbmtcXFwiXFxufSk7XFxuZGF0YS5wdXNoKHtcXG4gICAgdGl0bGU6IGRhdGFJdGVtLmdvb2RfbnVtLFxcbiAgICBwaWNfdXJsOiBcXFwiaGlrZXI6Ly9maWxlcy9pY29uL+i1ni5zdmdcXFwiLFxcbiAgICBjb2xfdHlwZTogXFxcImljb25fc21hbGxfM1xcXCIsXFxuICAgIHVybDogXFxcImhpa2VyOi8vZW1wdHlcXFwiXFxufSk7XFxuZGF0YS5wdXNoKHtcXG4gICAgdGl0bGU6IGRhdGFJdGVtLmJhZF9udW0sXFxuICAgIHBpY191cmw6IFxcXCJoaWtlcjovL2ZpbGVzL2ljb24v6LipLnN2Z1xcXCIsXFxuICAgIGNvbF90eXBlOiBcXFwiaWNvbl9zbWFsbF8zXFxcIixcXG4gICAgdXJsOiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCJcXG59KTtcXG5kYXRhLnB1c2goe1xcbiAgICB0aXRsZTogXFxcIuivhOiuulxcXCIsXFxuICAgIHBpY191cmw6IFxcXCJoaWtlcjovL2ZpbGVzL2ljb24v6K+E6K66LnN2Z1xcXCIsXFxuICAgIGNvbF90eXBlOiBcXFwiaWNvbl9zbWFsbF8zXFxcIixcXG4gICAgdXJsOiBcXFwiaGlrZXI6Ly9wYWdlL1JlcGx5I25vSGlzdG9yeSMjbm9SZWNvcmRIaXN0b3J5I1xcXCIsXFxuICAgIGV4dHJhOiB7XFxuICAgICAgICBydWxlSWQ6IGRhdGFJdGVtLmlkLFxcbiAgICAgICAgbmFtZTogZGF0YUl0ZW0uYXV0aG9yLFxcbiAgICAgICAgcGFzc3dvcmQ6IHBhc3N3b3JkLFxcbiAgICAgICAgdXNlcm5hbWU6IHVzZXJuYW1lXFxuICAgIH1cXG59KTtcXG5sZXQgdG90YWxTdW0gPSBkYXRhSXRlbS5nb29kX251bSArIGRhdGFJdGVtLmJhZF9udW07XFxuXFxuZGF0YS5wdXNoKHtcXG4gICAgdGl0bGU6IGh0bWxUYWcoXFxcImJpZ1xcXCIsIFxcXCLor4TorrooXFxcIiArIHRvdGFsU3VtICsgXFxcIilcXFwiKSArIFxcXCJcXFxcdFxcXFx0XFxcXHRcXFwiICsgc21hbGwoaHRtbFRhZyhcXFwidVxcXCIsIFxcXCLmn6XnnIvlhajpg6jor4Torroo5o6n6K+EKSA+XFxcIikpLFxcbiAgICBjb2xfdHlwZTogXFxcInRleHRfMVxcXCIsXFxuICAgIHVybDogXFxcImhpa2VyOi8vcGFnZS9Db21tZW50XFxcIixcXG4gICAgZXh0cmE6IHtcXG4gICAgICAgIHVybDogXFxcImhpa2VyOi8vZW1wdHkjZnlwYWdlI25vSGlzdG9yeSMjbm9SZWNvcmRIaXN0b3J5I1xcXCIsXFxuICAgICAgICBpZDogZGF0YUl0ZW0uaWQsXFxuICAgICAgICB0b3RhbFN1bTogdG90YWxTdW0sXFxuICAgICAgICBub19hY3RpdmU6IHRydWUsXFxuICAgICAgICB1c2VybmFtZTogdXNlcm5hbWUsXFxuICAgICAgICBwYXNzd29yZDogcGFzc3dvcmRcXG4gICAgfVxcbn0pO1xcbi8vY29uc3QgbG9uZ2VzdFN1bT0xMjA7XFxubGV0IGljb24gPSB7XFxuICAgIFxcXCJnb29kXFxcIjogXFxcIvCfkY1cXFwiLFxcbiAgICBcXFwiYmFkXFxcIjogXFxcIvCfkY5cXFwiLFxcbiAgICBcXFwicmVwbHlcXFwiOiBcXFwi5byA5Y+R6ICF8J+Xo1xcXCJcXG59XFxuaWYgKHRvdGFsU3VtID09PSAwKSB7XFxuICAgIGRhdGEucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIjxoNSBzdHlsZT0ndGV4dC1hbGlnbjpjZW50ZXInPuS4gOadoeivhOiuuuS5n+ayoeacie+8jOW/q+adpeaKouaymeWPkeWQp++8gTwvaDU+XFxcIixcXG4gICAgICAgIGNvbF90eXBlOiBcXFwicmljaF90ZXh0XFxcIlxcbiAgICB9KTtcXG59IGVsc2Uge1xcbiAgICBsZXQgY29tbWVudExpc3QgPSBKU09OLnBhcnNlKHJlcXVlc3QoYXBpLmRpc19nZXQgKyBkYXRhSXRlbS5pZCArIFxcXCI/bGltaXQ9NVxcXCIpKS5yZXN1bHQ7XFxuICAgIGZvciAobGV0IGl0ZW0gb2YgY29tbWVudExpc3QpIHtcXG4gICAgICAgIGxldCBSZXBseSA9IGl0ZW0uZGlzY3Vzc190eXBlPT09XFxcInJlcGx5XFxcIiYmaXRlbS5yZXBseV90b19uYW1lIT09ZmFsc2UmJml0ZW0ucmVwbHlfdG9faWQhPT1mYWxzZT9cXFwi4oCY4oCY5Zue5aSNQFxcXCIraXRlbS5yZXBseV90b19uYW1lK1xcXCIgI1xcXCIraXRlbS5kaXNjdXNzX2lkK1xcXCLigJnigJlcXFxcblxcXCI6XFxcIlxcXCI7XFxuICAgICAgICBkYXRhLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiBpdGVtLm5hbWUgKyBcXFwiJm5ic3A7Jm5ic3A7PGZvbnQgY29sb3I9J2dyYXknPjxzbWFsbD4jXFxcIiArIGl0ZW0uaWQgKyBcXFwiPC9zbWFsbD48Zm9udD5cXFwiLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwiYXZhdGFyXFxcIixcXG4gICAgICAgICAgICB1cmw6IFxcXCJoaWtlcjovL3BhZ2UvUmVwbHlcXFwiLFxcbiAgICAgICAgICAgIGV4dHJhOntcXG4gICAgICAgICAgICAgICAgcnVsZUlkOiBkYXRhSXRlbS5pZCxcXG4gICAgICAgICAgICAgICAgbmFtZTogaXRlbS5uYW1lLFxcbiAgICAgICAgICAgICAgICBwYXNzd29yZDogcGFzc3dvcmQsXFxuICAgICAgICAgICAgICAgIHVzZXJuYW1lOiB1c2VybmFtZSxcXG4gICAgICAgICAgICAgICAgcmVwbHlJZDppdGVtLmlkXFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBwaWNfdXJsOiBpdGVtLmF2YXRhcl91cmxcXG4gICAgICAgIH0pO1xcbiAgICAgICAgZGF0YS5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogaXRlbS5kaXNjdXNzX3RleHQsXFxuICAgICAgICAgICAgZGVzYzogUmVwbHkraXRlbS5jcmVhdGVfZGF0ZSArIFxcXCLCt1xcXCIgKyBpY29uW2l0ZW0uZGlzY3Vzc190eXBlXSxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfMVxcXCIsXFxuICAgICAgICAgICAgdXJsOiBcXFwiaGlrZXI6Ly9wYWdlL2luZm9cXFwiLFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgIG5hbWU6IGl0ZW0ubmFtZSxcXG4gICAgICAgICAgICAgICAgdHlwZTogXFxcImxvbmdfdGV4dFxcXCIsXFxuICAgICAgICAgICAgICAgIHRleHQ6IGl0ZW0uZGlzY3Vzc190ZXh0XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBwaWNfdXJsOiBpdGVtLmF2YXRhcl91cmxcXG4gICAgICAgIH0pO1xcbiAgICB9XFxufVxcbmRhdGEucHVzaCh7XFxuICAgIGNvbF90eXBlOiBcXFwibGluZV9ibGFua1xcXCJcXG59KTtcXG5zZXRSZXN1bHQoZGF0YSk7XCJ9LHtcImNvbF90eXBlXCI6XCJpY29uXzJfcm91bmRcIixcIm5hbWVcIjpcIuinhOWImeWIl+ihqFwiLFwicGF0aFwiOlwicnVsZXNcIixcInJ1bGVcIjpcImpzOlxcbiAgICBhZGRMaXN0ZW5lcignb25DbG9zZScsJC50b1N0cmluZygoKT0+e1xcbiAgICAgICAgY2xlYXJWYXIoXFxcIldhcmVob3VzZS5iYWNrXFxcIik7XFxuICAgICAgICBjbGVhclZhcihcXFwiV2FyZWhvdXNlLmZpbHRlclxcXCIpO1xcbiAgICAgICAgY2xlYXJWYXIoXFxcIldhcmVob3VzZS50eXBlXFxcIik7XFxuICAgICAgICBpZihnZXRWYXIoJ1dhcmVob3VzZS5jYW5fdXBsb2FkJywnJykpe1xcbiAgICAgICAgICAgIGxvZygn5pON5L2c6L+H56aB5q2i5LiK5LygOicrZ2V0VmFyKCdXYXJlaG91c2UuY2FuX3VwbG9hZCcpKTtcXG4gICAgICAgICAgICBjbGVhclZhcihcXFwiV2FyZWhvdXNlLmNhbl91cGxvYWRcXFwiKTtcXG4gICAgICAgICAgICByZWZyZXNoUGFnZSh0cnVlKTtcXG4gICAgICAgIH1cXG4gICAgfSkpO1xcblxcbmlmIChnZXRWYXIoXFxcIldhcmVob3VzZS5iYWNrXFxcIikgPT09IFxcXCIxXFxcIikge1xcbiAgICBiYWNrKGZhbHNlKTtcXG59XFxuXFxuY29uc3Qge1xcbiAgICBnZXRBcGksXFxuICAgIGFwaSxcXG4gICAgY29sb3IsXFxuICAgIHNtYWxsLFxcbiAgICBsb2NhbFJ1bGVWZXIsXFxuICAgIGh0bWxUYWcsXFxuICAgIG1kXFxufSA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL3V0aWxpeVxcXCIpO1xcbmNvbnN0IHsgbm9ybWFsU29ydCB9ID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2Uvc29ydFxcXCIpO1xcbmxldCB7XFxuICAgIGF2YXRhclVybCxcXG4gICAgcXEsXFxuICAgIGlkLFxcbiAgICBjYW5fdXBsb2FkXFxufSA9IE1ZX1BBUkFNUztcXG5sZXQgZGF0YVR5cGUgPSBnZXRWYXIoXFxcIldhcmVob3VzZS50eXBlXFxcIixcXFwiXFxcIik7XFxubGV0IGJhY2tDb2RlID0gSlNPTi5wYXJzZShyZXF1ZXN0KGdldEFwaShcXFwicnVsZXNVcmxcXFwiKSArIFxcXCI/bmFtZT1cXFwiICsgcXErXFxcIiZkYXRhX3R5cGU9XFxcIitkYXRhVHlwZSkpO1xcbmxldCBkZXZOYW1lID0gYmFja0NvZGUuZGV2X25hbWU7XFxucHV0VmFyKFxcXCJXYXJlaG91c2UuZmlsdGVyXFxcIiwgZGV2TmFtZSk7XFxubGV0IHJ1bGVMaXN0ID0gYmFja0NvZGUucmVzdWx0O1xcbmxldCBzdWJVcmwgPSBnZXRBcGkoXFxcImpzb25MaXN0XFxcIikgKyBcXFwiP25hbWU9XFxcIiArIHFxO1xcbmxldCBoYXNTdWIgPSBoYXNIb21lU3ViKHN1YlVybCk7XFxubGV0IGRldkluZm8gPSBcXFwi6L+Z5Liq5Lq65b6I5oeSLOS7gOS5iOmDveayoeWGmeWTpn5cXFwiO1xcbmxldCB0bXBKc29uID0gSlNPTi5wYXJzZShyZXF1ZXN0KGdldEFwaShcXFwiaW5mb0dldFVybFxcXCIpICsgcXEpKTtcXG5pZiAodG1wSnNvbi5zdGF0dXMgPT0gMCkge1xcbiAgICBkZXZJbmZvID0gdG1wSnNvbi5yZXN1bHQgfHwgZGV2SW5mbztcXG59XFxubGV0IHN1YkZsYWcgPSBoYXNTdWIgPyAn8J+GlycgOiAn8J+ToSc7XFxubGV0IGRhdGEgPSBbXTtcXG5yZXF1aXJlKG1kKTtcXG5kZXZJbmZvPW1hcmtlZC5wYXJzZShkZXZJbmZvKTtcXG5kYXRhLnB1c2goe1xcbiAgICB0aXRsZTogXFxcIuKAnOKAnOKAneKAnVxcXCIgKyBkZXZOYW1lICsgXFxcIlxcXFxuXFxcXG5cXFwiICsgc21hbGwoaHRtbFRhZyhcXFwidVxcXCIsIFxcXCLngrnlh7vmn6XnnIvlrozmlbTlhazlkYpcXFwiKSksXFxuICAgIGRlc2M6IHNtYWxsKGRldkluZm8pLFxcbiAgICB1cmw6ICdoaWtlcjovL3BhZ2UvaW5mbycsXFxuICAgIGV4dHJhOiB7XFxuICAgICAgICB0ZXh0OiBkZXZJbmZvLFxcbiAgICAgICAgbmFtZTogZGV2TmFtZSxcXG4gICAgICAgIHR5cGU6XFxcInJpY2hfdGV4dFxcXCJcXG4gICAgfSxcXG4gICAgcGljX3VybDogYXZhdGFyVXJsLFxcbiAgICBjb2xfdHlwZTogJ21vdmllXzFfdmVydGljYWxfcGljJ1xcbn0pO1xcbmRhdGEucHVzaCh7XFxuICAgIHRpdGxlOiBcXFwiPGJpZz7orqLpmIXnrqHnkIY8L2JpZz4mbmJzcDsmbmJzcDs8c21hbGw+KOW9k+WJjVxcXCIgKyAoaGFzU3ViID8gXFxcIuW3suiuoumYhVxcXCIgOiBcXFwi5pyq6K6i6ZiFXFxcIikgKyBcXFwiKTwvc21hbGw+XFxcIixcXG4gICAgY29sX3R5cGU6IFxcXCJyaWNoX3RleHRcXFwiXFxufSk7XFxuXFxubGV0IHN1Yl9jb2RlID0gJ+a1t+mYlOinhueVjOWQiOmbhuinhOWImeiuoumYhe+/pWhvbWVfc3Vi77+lJyArIGRldk5hbWUgKyBcXFwi5ZCI6ZuGQEBcXFwiICsgc3ViVXJsO1xcbmxldCBydWxlc0NvZGUgPSAn5rW36ZiU6KeG55WM5ZCI6ZuG6KeE5YiZ77+laG9tZV9ydWxlX3VybO+/pScgKyBzdWJVcmw7XFxuZGF0YS5wdXNoKHtcXG4gICAgdGl0bGU6ICfigJzigJzigJ3igJ08c3BhbiBzdHlsZT1cXFwiY29sb3I6ICNmZjcwMDBcXFwiPuS4gOmUruiuoumYhTwvc3Bhbj4nLFxcbiAgICBkZXNjOiAn6K6i6ZiF4oCc4oCc4oCd4oCdPHNwYW4gc3R5bGU9XFxcImNvbG9yOiAjNWNmZjJjXFxcIj4nICsgZGV2TmFtZSArICc8L3NwYW4+55qE5omA5pyJ5Y2V6KeE5YiZ77yM5ZCI6ZuG6ZyA5Y2V54us6K6i6ZiFJyxcXG4gICAgdXJsOiBzdWJfY29kZSxcXG4gICAgY29sX3R5cGU6ICd0ZXh0XzInXFxufSk7XFxuZGF0YS5wdXNoKHtcXG4gICAgdGl0bGU6ICfigJzigJzigJ3igJ08c3BhbiBzdHlsZT1cXFwiY29sb3I6ICNmZjcwMDBcXFwiPuWvvOWFpeWFqOmDqDwvc3Bhbj4nLFxcbiAgICB1cmw6IHJ1bGVzQ29kZSxcXG4gICAgY29sX3R5cGU6ICd0ZXh0XzInXFxufSk7XFxuZGF0YS5wdXNoKHtcXG4gICAgdGl0bGU6ICfigJzigJzigJ3igJ08c3BhbiBzdHlsZT1cXFwiY29sb3I6ICNmZjcwMDBcXFwiPuWvvOWFpei9u+WQiOmbhjwvc3Bhbj4nLFxcbiAgICB1cmw6ICQoKS5sYXp5UnVsZSgoZGV2TmFtZSxzdWJVcmwsYXZhdGFyVXJsKT0+e1xcbiAgICAgICAgY29uc3Qge2dlblJ1bGV9PSQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL2dlbkFwaVxcXCIpO1xcbiAgICAgICAgbG9nKFxcXCLovbvlkIjpm4blm77moIfpk77mjqU6XFxcIithdmF0YXJVcmwpO1xcbiAgICAgICAgbGV0IGltcG9ydF9ydWxlPWdlblJ1bGUoXFxcIui9u+WQiOmbhi5cXFwiK2Rldk5hbWUsc3ViVXJsLGF2YXRhclVybCk7XFxuICAgICAgICAvL2NvcHkoaW1wb3J0X3J1bGUpO1xcbiAgICAgICAgbGV0IHJ1bGVDb2RlPXBhcnNlUGFzdGUoaW1wb3J0X3J1bGUuc3BsaXQoXFxcIlxcXFxuXFxcIilbMF0pO1xcbiAgICAgICAgLy9yZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiXFxuICAgICAgICBpbXBvcnRVcmwgPSAncnVsZTovLycgKyBiYXNlNjRFbmNvZGUocnVsZUNvZGUpO1xcbiAgICAgICAgcmV0dXJuIGltcG9ydFVybFxcbiAgICB9LGRldk5hbWUsc3ViVXJsLGF2YXRhclVybCksXFxuICAgIGNvbF90eXBlOiAndGV4dF8yJ1xcbn0pO1xcbmRhdGEucHVzaCh7XFxuICAgIHRpdGxlOiAn4oCc4oCc4oCd4oCdPHNwYW4gc3R5bGU9XFxcImNvbG9yOiAjZmY3MDAwXFxcIj7lr7zlhaXpgZPlvrfnu488L3NwYW4+JyxcXG4gICAgdXJsOiAkKCkubGF6eVJ1bGUoKGRldk5hbWUsc3ViVXJsLGF2YXRhclVybCk9PntcXG4gICAgICAgIGxldCB0aXRsZSA9IFxcXCJILVxcXCIrZGV2TmFtZTtcXG4gICAgICAgIGxldCBzdWJPYmogPSB7XFxuICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxcbiAgICAgICAgICAgIHVybDogc3ViVXJsLFxcbiAgICAgICAgICAgIGRlc2M6IFxcXCJoaWtlcjovL2ZpbGVzL3J1bGVzL2R6SG91c2UvcnVsZUNhY2hlL1xcXCIrdGl0bGUrXFxcIi5qc29uXFxcIixcXG4gICAgICAgICAgICBjb2RlOiBcXFwiXFxcIixcXG4gICAgICAgICAgICBhY3RpdmU6IGZhbHNlLC8v56aB55So5bm25Y+R5pu05pawXFxuICAgICAgICB9XFxuICAgICAgICBsZXQgc2hhcmVUZXh0ID0gYmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KHN1Yk9iaikpO1xcbiAgICAgICAgdmFyIHBhc3RlcyA9IGdldFBhc3RlcygpO1xcbiAgICAgICAgdmFyIHVybCA9IHNoYXJlUGFzdGUoc2hhcmVUZXh0LHBhc3Rlcy5zbGljZSgtMSlbMF0pO1xcbiAgICAgICAgbGV0IGltcG9ydF9ydWxlPSBcXFwi6L275ZCI6ZuG6K6i6ZiF77yaXFxcIit0aXRsZSsnXFxcXG4nK3VybDtcXG4gICAgICAgIGNvcHkoaW1wb3J0X3J1bGUpO1xcbiAgICAgICAgY29uc3QgcGF0aCA9ICdoaWtlcjovL2ZpbGVzL3J1bGVzL2R6SG91c2UvcnVsZUNhY2hlL3N1Yi5qc29uJztcXG4gICAgICAgICQucmMoY29uZmlnLmxpYi5zdWIpO1xcbiAgICAgICAgcmV0dXJuIOiuoumYheWvvOWFpShwYXRoKVxcbiAgICB9LGRldk5hbWUsc3ViVXJsLGF2YXRhclVybCksXFxuICAgIGNvbF90eXBlOiAndGV4dF8yJ1xcbn0pO1xcbmxldCBjYW5fdXBsb2FkX2FwaSA9IGdldEFwaShcXFwibWFuQ2FuVXBsb2FkXFxcIikraWQ7XFxuaWYoZ2V0VmFyKCdob3VzZS5pc19tYW5hZ2VyJykpe1xcbiAgICBsZXQgdGlwcyA9IGNhbl91cGxvYWQ/J+iDvSc6J+WQpic7XFxuICAgIC8vIGxvZygndGlwczonK3RpcHMpO1xcbiAgICAvLyBsb2coJ2Nhbl91cGxvYWQ6JytjYW5fdXBsb2FkKTtcXG4gICAgZGF0YS5wdXNoKHtcXG4gICAgICAgIHRpdGxlOifimqDog73lkKbkuIrkvKA6JysoZ2V0VmFyKCdXYXJlaG91c2UuY2FuX3VwbG9hZCcpfHx0aXBzKSxcXG4gICAgICAgIGNvbF90eXBlOidzY3JvbGxfYnV0dG9uJyxcXG4gICAgICAgIHVybDonaGlrZXI6Ly9lbXB0eSdcXG4gICAgfSk7XFxuICAgIGZ1bmN0aW9uIHNldFVwbG9hZChmbGFnLGNhbl91cGxvYWRfYXBpKSB7XFxuICAgICAgICBmbGFnID0gZmxhZyB8fCAnJztcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgbGV0IGNvZGUgPSBmZXRjaChjYW5fdXBsb2FkX2FwaSwge1xcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxcIlVzZXItQWdlbnRcXFwiOiBNT0JJTEVfVUF9LFxcbiAgICAgICAgICAgICAgICBib2R5OiB7XFxuICAgICAgICAgICAgICAgICAgICBcXFwicGFyYW1zXFxcIjpcXG4gICAgICAgICAgICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJ1c2VybmFtZVxcXCI6IGdldFZhcignaG91c2UudXNlcm5hbWUnKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcInBhc3N3b3JkXFxcIjogZ2V0VmFyKCdob3VzZS5wYXNzd29yZCcpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFwiY2FuX3VwbG9hZFxcXCI6ICEhZmxhZ1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIGNvZGUgPSBKU09OLnBhcnNlKGNvZGUpLnJlc3VsdDtcXG4gICAgICAgICAgICBpZiAoY29kZS5zdGF0dXMgPT09IDApIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvZGUuZGV0YWlsXFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuICfmk43kvZzlpLHotKU6JyArIGNvZGUuZGV0YWlsXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgIHJldHVybiAn5pON5L2c5aSx6LSlOicgKyBlLm1lc3NhZ2VcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBkYXRhLnB1c2goe1xcbiAgICAgICAgdGl0bGU6J/CfmqvnpoHmraLkuIrkvKAnLFxcbiAgICAgICAgY29sX3R5cGU6J3Njcm9sbF9idXR0b24nLFxcbiAgICAgICAgdXJsOiQoJ+emgeatouivpeW8gOWPkeiAheS4iuS8oOinhOWImT/kvaDnmoTmk43kvZzlsIbooqvns7vnu5/orrDlvZUnKS5jb25maXJtKChpZCxjYW5fdXBsb2FkX2FwaSxzZXRVcGxvYWQpPT57XFxuICAgICAgICAgICAgbGV0IHJldCA9IHNldFVwbG9hZChmYWxzZSxjYW5fdXBsb2FkX2FwaSk7XFxuICAgICAgICAgICAgaWYoIS/mk43kvZzlpLHotKUvLnRlc3QocmV0KSl7XFxuICAgICAgICAgICAgICAgIHB1dFZhcignV2FyZWhvdXNlLmNhbl91cGxvYWQnLCflkKYnKTtcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8vJytyZXRcXG4gICAgICAgIH0saWQsY2FuX3VwbG9hZF9hcGksc2V0VXBsb2FkKVxcbiAgICB9KTtcXG4gICAgZGF0YS5wdXNoKHtcXG4gICAgICAgIHRpdGxlOifinIXlhYHorrjkuIrkvKAnLFxcbiAgICAgICAgY29sX3R5cGU6J3Njcm9sbF9idXR0b24nLFxcbiAgICAgICAgdXJsOiQoJ+WFgeiuuOivpeW8gOWPkeiAheS4iuS8oOinhOWImT/kvaDnmoTmk43kvZzlsIbooqvns7vnu5/orrDlvZUnKS5jb25maXJtKChpZCxjYW5fdXBsb2FkX2FwaSxzZXRVcGxvYWQpPT57XFxuICAgICAgICAgICAgbGV0IHJldCA9IHNldFVwbG9hZCh0cnVlLGNhbl91cGxvYWRfYXBpKTtcXG4gICAgICAgICAgICBpZighL+aTjeS9nOWksei0pS8udGVzdChyZXQpKXtcXG4gICAgICAgICAgICAgICAgcHV0VmFyKCdXYXJlaG91c2UuY2FuX3VwbG9hZCcsJ+aYrycpO1xcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly8nK3JldFxcbiAgICAgICAgfSxpZCxjYW5fdXBsb2FkX2FwaSxzZXRVcGxvYWQpXFxuICAgIH0pO1xcbn1cXG5kYXRhLnB1c2goe1xcbiAgICB0aXRsZTogXFxcIjxzbWFsbD7mj5DnpLrvvJrlvIDlj5HogIXljZXni6zliIbkuqvnmoTlkIjpm4bmlofku7blj6rog73ljZXni6zlr7zlhaXjgII8L3NtYWxsPlxcXCIsXFxuICAgIGNvbF90eXBlOiBcXFwicmljaF90ZXh0XFxcIlxcbn0pO1xcbmRhdGEucHVzaCh7XFxuICAgIHRpdGxlOiBcXFwiPGJpZz7op4TliJnliJfooag8L2JpZz4mbmJzcDsmbmJzcDs8c21hbGw+KOWFsVxcXCIgKyBydWxlTGlzdC5sZW5ndGggKyBcXFwi5p2hKTwvc21hbGw+XFxcIixcXG4gICAgY29sX3R5cGU6IFxcXCJyaWNoX3RleHRcXFwiXFxufSk7XFxubGV0IGRhdGFUeXBlTGlzdCA9IHtcXG4gICAgXFxcIlxcXCI6XFxcIuWFqOmDqFxcXCIsXFxuICAgIFxcXCJob21lX3J1bGVfdXJsXFxcIjogJ+Wwj+eoi+W6jycsXFxuICAgIC8vXFxcInB1Ymxpc2hcXFwiOiAn5o+Q5Lqk5LqR5LuT5bqT6KeE5YiZJyxcXG4gICAgXFxcImpzX3VybFxcXCI6ICfnvZHpobXmj5Lku7YnLFxcbiAgICBcXFwiaHRtbFxcXCI6ICfpnZnmgIHpobXpnaInLFxcbiAgICBcXFwiY29uZmlnXFxcIjogJ+S4u+mimCdcXG59O1xcbmZvcihsZXQga2V5IGluIGRhdGFUeXBlTGlzdCl7XFxuICAgIGRhdGEucHVzaCh7XFxuICAgICAgICB0aXRsZTpkYXRhVHlwZT09PWtleT9cXFwi4oCc4oCcXFxcIitkYXRhVHlwZUxpc3Rba2V5XStcXFwi4oCd4oCdXFxcIjpkYXRhVHlwZUxpc3Rba2V5XSxcXG4gICAgICAgIHVybDokKFxcXCIjbm9Mb2FkaW5nI1xcXCIpLmxhenlSdWxlKChrZXkpPT57XFxuICAgICAgICAgICAgcHV0VmFyKFxcXCJXYXJlaG91c2UudHlwZVxcXCIsa2V5KTtcXG4gICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL2VtcHR5XFxcIjtcXG4gICAgICAgIH0sa2V5KSxcXG4gICAgICAgIGNvbF90eXBlOlxcXCJzY3JvbGxfYnV0dG9uXFxcIlxcbiAgICB9KTtcXG59XFxuaWYgKHJ1bGVMaXN0Lmxlbmd0aCA+IDIwKSB7XFxuICAgIGRhdGEucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIuaQnOe0olxcXCIsXFxuICAgICAgICB1cmw6ICQudG9TdHJpbmcobmFtZSA9PiBcXFwiaGlrZXI6Ly9zZWFyY2g/cz1cXFwiICsgaW5wdXQgKyBcXFwiJnJ1bGU9XFxcIiArIG5hbWUsIE1ZX1JVTEUudGl0bGUpLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJpbnB1dFxcXCIsXFxuICAgICAgICBkZXNjOiBcXFwi5pCc57Si5b2T5YmN5byA5Y+R6ICF55qE6KeE5YiZXFxcIlxcbiAgICB9KTtcXG59XFxubGV0IGhvbWVMaXN0ID0gSlNPTi5wYXJzZShyZXF1ZXN0KGFwaS5ob21lKSk7XFxubGV0IG1SdWxlTGlzdCA9IFtdO1xcbmZvciAodmFyIGl0ZW0gb2YgcnVsZUxpc3QpIHtcXG4gICAgdmFyIG5hbWUgPSBpdGVtLm5hbWU7XFxuICAgIGlmIChpdGVtLmlzX3RhcCkge1xcbiAgICAgICAgbGV0IGxvY2F0aW9uID0gSlNPTi5wYXJzZShyZXF1ZXN0KGdldEFwaShcXFwicnVsZUxpc3RKc29uXFxcIikgKyBcXFwiP2lkPVxcXCIgKyBpdGVtLmlkKSk7XFxuICAgICAgICBpdGVtLmlkID0gbG9jYXRpb24uaWQ7XFxuICAgICAgICBpdGVtLm5hbWUgPSBsb2NhdGlvbi5uYW1lO1xcbiAgICAgICAgaXRlbS5hdXRob3IgPSBsb2NhdGlvbi5hdXRob3I7XFxuICAgICAgICBpdGVtLmRhdGFfdHlwZSA9IGxvY2F0aW9uLmRhdGFfdHlwZTtcXG4gICAgICAgIGl0ZW0udmVyID0gbG9jYXRpb24udmVyXFxuICAgIH1cXG4gICAgaXRlbS52ZXJzaW9uID0gaXRlbS52ZXI7XFxuICAgIGxldCBsYWJlbCA9IFxcXCJcXFwiLFxcbiAgICAgICAgbHZlciA9IC0yO1xcbiAgICBpZiAoaXRlbS5pc19qc29uICYmIGl0ZW0uZGF0YV90eXBlID09PSBcXFwiaG9tZV9ydWxlX3VybFxcXCIpIHtcXG4gICAgICAgIGx2ZXIgPSBsb2NhbFJ1bGVWZXIoaG9tZUxpc3QsIGl0ZW0pO1xcbiAgICAgICAgaWYgKGx2ZXIgPT09IC0xKSB7XFxuICAgICAgICAgICAgbGFiZWwgPSBcXFwi8J+GlVxcXCI7XFxuICAgICAgICB9IGVsc2UgaWYgKGx2ZXIgPCBpdGVtLnZlcikge1xcbiAgICAgICAgICAgIGxhYmVsID0gXFxcIvCfhplcXFwiO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIG1SdWxlTGlzdC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBsYWJlbCArIG5hbWUsXFxuICAgICAgICB1cmw6IFxcXCJoaWtlcjovL3BhZ2UvcnVsZURldGFpbCNub0hpc3RvcnkjI25vUmVjb3JkSGlzdG9yeSNcXFwiLFxcbiAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICBsdmVyOiBsdmVyLFxcbiAgICAgICAgICAgIGlkOiBpdGVtLmlkXFxuICAgICAgICB9LFxcbiAgICAgICAgcGljX3VybDogaXRlbS5waWMsXFxuICAgIH0pO1xcbn1cXG4vKiDlvZLlubbmjpLluo8gU3RhcnQgKi9cXG5pZihnZXRJdGVtKFxcXCLmjpLluo9cXFwiLFxcXCLml7bpl7TkvJjlhYhcXFwiKT09PSfmlrDniYjkvJjlhYgnKXtcXG4gICAgbVJ1bGVMaXN0ID0gbm9ybWFsU29ydChtUnVsZUxpc3QpO1xcbn1cXG4vKiDlvZLlubbmjpLluo8gRW5kICovXFxuZGF0YS5wdXNoLmFwcGx5KGRhdGEsIG1SdWxlTGlzdClcXG5zZXRSZXN1bHQoZGF0YSk7XFxuXCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLop4TliJnor6bnu4YtdXNlclwiLFwicGF0aFwiOlwicnVsZURldGFpbFwiLFwicnVsZVwiOlwianM6XFxuICAgIGNvbnN0IHtcXG4gICAgICAgIGdldEFwaSxcXG4gICAgICAgIGNvbG9yLFxcbiAgICAgICAgc21hbGwsXFxuICAgICAgICBodG1sVGFnLFxcbiAgICAgICAgYXBpLFxcbiAgICAgICAgbWRcXG4gICAgfSA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL3V0aWxpeVxcXCIpO1xcbmxldCB7XFxuICAgIGlkLFxcbiAgICBsdmVyLFxcbiAgICBpc0FsbFxcbn0gPSBNWV9QQVJBTVM7XFxuaWYoZ2V0UGFyYW0oXFxcImlkXFxcIikpe1xcbiAgICBpc0FsbCA9IHRydWU7XFxuICAgIGlkID0gZ2V0UGFyYW0oXFxcImlkXFxcIik7XFxuICAgIGx2ZXIgPSBsdmVyIHx8IFxcXCLmnKrojrflj5bniYjmnKzlj7dcXFwiO1xcbn1cXG5hZGRMaXN0ZW5lcignb25DbG9zZScsICQudG9TdHJpbmcoKGlzQWxsKSA9PiB7XFxuICAgIGlmKCFpc0FsbCl7XFxuICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxuICAgIH1cXG59LGlzQWxsKSk7XFxubGV0IGRhdGFJdGVtID0gSlNPTi5wYXJzZShyZXF1ZXN0KGdldEFwaShcXFwiZ2V0YnlpZFxcXCIpICsgXFxcIj9pZD1cXFwiICsgaWQpKS5yZXN1bHQ7XFxuc2V0UGFnZVRpdGxlKFxcXCLjgIxcXFwiICsgZGF0YUl0ZW0ubmFtZSArIFxcXCLjgI1cXFwiKVxcbmxldCBydWxlTGlzdEpzb24gPSBnZXRBcGkoXFxcInJ1bGVMaXN0SnNvblxcXCIpICsgXFxcIj9pZD1cXFwiO1xcbmxldCBkYXRhID0gW107XFxudmFyIGhhc1N1YiA9IGZhbHNlO1xcblxcbmlmIChkYXRhSXRlbS5pc19qc29uX2xpc3QpIHtcXG4gICAgaGFzU3ViID0gaGFzSG9tZVN1YihydWxlTGlzdEpzb24gKyBkYXRhSXRlbS5pZCk7XFxufSBlbHNlIGlmICghZGF0YUl0ZW0uaXNfanNvbl9saXN0ICYmIGRhdGFJdGVtLmRhdGFfdHlwZSA9PSAnaG9tZV9ydWxlX3VybCcpIHtcXG4gICAgaGFzU3ViID0gaGFzSG9tZVN1YihydWxlTGlzdEpzb24gKyBkYXRhSXRlbS5pZCArICcmZGVidWc9dHJ1ZScpO1xcbn1cXG5cXG5kYXRhLnB1c2goe1xcbiAgICB0aXRsZTogaHRtbFRhZyhcXFwiYmlnXFxcIiwgXFxcIueJiOacrFxcXCIpLFxcbiAgICBkZXNjOiBcXFwi4oCc4oCc4oCd4oCd5byA5Y+R6ICF77yaXFxcIiArIGNvbG9yKGRhdGFJdGVtLmF1dGhvciwgXFxcIiMyMjhCRTZcXFwiKSArIFxcXCJcXFxcbuS6keerr+eJiOacrO+8mlxcXCIgKyBjb2xvcihkYXRhSXRlbS52ZXIsIFxcXCIjNWNmZjJjXFxcIikgKyBcXFwiXFxcXHRcXFxcdOacrOWcsOeJiOacrO+8mlxcXCIgKyBjb2xvcihsdmVyLCBcXFwiIzVjZmYyY1xcXCIpICsgXFxcIlxcXFxu5pu05paw5LqOOiBbXFxcIiArIGNvbG9yKGRhdGFJdGVtLmxhc3RfdXBkYXRlLCBcXFwiI2ZmNzAwMFxcXCIpICsgXFxcIl1cXFwiLFxcbiAgICB1cmw6ICQoXFxcIjzlvIDlj5HogIU+XFxcXG5cXFwiICsgZGF0YUl0ZW0uYXV0aG9yICsgXFxcIlxcXFxuPOWQjeensD5cXFxcblxcXCIgKyBkYXRhSXRlbS5uYW1lICsgXFxcIlxcXFxuPOS6keerr+eJiOacrD5cXFxcblxcXCIgKyBkYXRhSXRlbS52ZXIgKyBcXFwiXFxcXG485pys5Zyw54mI5pysPlxcXFxuXFxcIiArIGx2ZXIgKyBcXFwiXFxcXG485pu05paw5pe26Ze0PlxcXFxuW1xcXCIgKyBkYXRhSXRlbS5sYXN0X3VwZGF0ZSArIFxcXCJdXFxcIikuY29uZmlybSgoKSA9PiB7fSksXFxuICAgIGNvbF90eXBlOiAndGV4dF8xJ1xcbn0pO1xcbmxldCBkYXRhVHlwZSA9IHtcXG4gICAgaG9tZV9ydWxlX3VybDogJ+mmlumhteS6keinhOWImScsXFxuICAgIHB1Ymxpc2g6ICfmj5DkuqTkupHku5PlupPop4TliJknLFxcbiAgICBqc191cmw6ICfnvZHpobXmj5Lku7bop4TliJknLFxcbiAgICBodG1sOiAn6Z2Z5oCB6aG16Z2iJyxcXG4gICAgY29uZmlnOiAn5Li76aG16YWN572uJ1xcbn07XFxuXFxubGV0IGJhc2ljID0ge1xcbiAgICBjb2xfdHlwZTogXFxcInRleHRfMVxcXCIsXFxuICAgIHVybDogXFxcImhpa2VyOi8vZW1wdHlcXFwiXFxufTtcXG5sZXQgZGF0YVR5cGVUaXBzID0gZGF0YVR5cGVbZGF0YUl0ZW0uZGF0YV90eXBlXSB8fCAn5pyq55+l6KeE5YiZ77yaJyArIGRhdGFJdGVtLmRhdGFfdHlwZTtcXG5cXG5sZXQgc2FmZV90aXA9ZGF0YUl0ZW0uaXNfc2FmZT9cXFwi5a6J5YWoXFxcIjpcXFwi5Y2x6ZmpXFxcIjtcXG5sZXQgZ29vZF90aXAgPSBkYXRhSXRlbS5pc19nb29kP3NtYWxsKGNvbG9yKFxcXCLjgJDkvJjotKjop4TliJnjgJFcXFwiLCcjZmY3MDAwJykpOlxcXCJcXFwiO1xcbmxldCBub3Rfc2FmZV9ub3RlPWRhdGFJdGVtLm5vdF9zYWZlX25vdGU7XFxuYmFzaWMudGl0bGUgPSBodG1sVGFnKFxcXCJiaWdcXFwiLCBcXFwi57G75Z6LXFxcIikgKyBcXFwiXFxcXHRcXFxcdFxcXFx0XFxcIiArIHNtYWxsKFxcXCIoaWQ6XFxcIiArIGRhdGFJdGVtLmlkICsgXFxcIilcXFwiKStcXFwiXFxcXHRcXFxcdFxcXFx0XFxcIiArIHNtYWxsKFxcXCIo6aOO6Zmp5qOA5rWLOlxcXCIgK3NhZmVfdGlwK1xcXCIpXFxcIikrZ29vZF90aXA7XFxuYmFzaWMuZGVzYyA9IFxcXCLmlbDmja7nsbvlnovvvJpcXFwiICsgY29sb3IoZGF0YVR5cGVUaXBzLCBcXFwiI2NiNTRmZlxcXCIpICsgXFxcIlxcXFxu5YiG5Lqr54q25oCB5Li677yaXFxcIiArIGRhdGFJdGVtLnN0YXRlO1xcbmlmIChbXFxcImh0bWxcXFwiLCBcXFwiY29uZmlnXFxcIiwgXFxcImpzX3VybFxcXCJdLmluY2x1ZGVzKGRhdGFJdGVtLmRhdGFfdHlwZSkpIHtcXG4gICAgYmFzaWMuZGVzYyArPSBcXFwiXFxcXG7igJzigJzigJ3igJ0gPT5cXFwiICsgc21hbGwoXFxcIueCueatpOmihOiniFxcXCIpO1xcbiAgICBiYXNpYy51cmwgPSBydWxlTGlzdEpzb24gKyBkYXRhSXRlbS5pZDtcXG59XFxuXFxuZGF0YS5wdXNoKGJhc2ljKTtcXG5sZXQgaGFzU3VicyA9IFxcXCJcXFwiO1xcbmlmIChoYXNTdWIpIHtcXG4gICAgaGFzU3VicyA9IFxcXCJcXFxcdFxcXFx0XFxcXHRcXFwiICsgc21hbGwoXFxcIuW3suiuoumYhVxcXCIpXFxufVxcblxcbmxldCBub3RlcyA9IHJlcXVlc3QoZ2V0QXBpKFxcXCJnZXRfcnVsZV9ub3RlXFxcIikgKyBpZCk7XFxubm90ZXMgPSBKU09OLnBhcnNlKG5vdGVzKS5yZXN1bHQ7XFxucmVxdWlyZShtZCk7XFxubGV0IG5vdGVzSHRtbD1cXFwiXFxcIlxcbnRyeXtcXG4gICAgbm90ZXNIdG1sPW1hcmtlZC5wYXJzZShub3Rlcyk7XFxufWNhdGNoKGUpe31cXG5cXG5pZiAobm90ZXMgIT09IGZhbHNlKSB7XFxuICAgIGRhdGEucHVzaCh7XFxuICAgICAgICB0aXRsZTogaHRtbFRhZyhcXFwiYmlnXFxcIiwgXFxcIuWkh+azqFxcXCIpICsgXFxcIlxcXFx0XFxcXHRcXFxcdFxcXCIgKyBzbWFsbChodG1sVGFnKFxcXCJ1XFxcIiwgXFxcIuafpeeci+WujOaVtOWFrOWRiiA+XFxcIikpLFxcbiAgICAgICAgZGVzYzogbm90ZXMsXFxuICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfMVxcXCIsXFxuICAgICAgICB1cmw6IFxcXCJoaWtlcjovL3BhZ2UvaW5mb1xcXCIsXFxuICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgIHRleHQ6IG5vdGVzSHRtbCxcXG4gICAgICAgICAgICBuYW1lOiBkYXRhSXRlbS5uYW1lLFxcbiAgICAgICAgICAgIC8vIHR5cGU6IFxcXCJsb25nX3RleHRcXFwiXFxuICAgICAgICAgICAgdHlwZTogXFxcInJpY2hfdGV4dFxcXCJcXG4gICAgICAgIH1cXG4gICAgfSk7XFxufVxcbmRhdGEucHVzaCh7XFxuICAgIHRpdGxlOiBodG1sVGFnKFxcXCJiaWdcXFwiLCBcXFwi5pON5L2cKOWIhuS6q+ivpue7humhtSlcXFwiKSArIGhhc1N1YnMsXFxuICAgIGNvbF90eXBlOiBcXFwidGV4dF8xXFxcIixcXG4gICAgdXJsOiBcXFwiY29weTovL+mBk+mVv+S7k+W6k+OAjFxcXCIrZGF0YUl0ZW0ubmFtZStcXFwi44CNXFxcXG5cXFwiK2lkKydAaW1wb3J0PWpzOiQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL3J1bGVEZXRhaWxJbXBvcnQ/cnVsZT3pgZPplb/ku5PlupNQcm9cXFwiLCBpbnB1dCknXFxufSk7XFxubGV0IGltcG9ydFVybCwgcnVsZUNvZGUsIHNoYXJlVXJsLCBiYWNrQ29kZSA9IFxcXCJcXFwiO1xcbmlmICghZGF0YUl0ZW0uaXNfanNvbikge1xcbiAgICBiYWNrQ29kZSA9IHJlcXVlc3QocnVsZUxpc3RKc29uICsgZGF0YUl0ZW0uaWQpO1xcbn1cXG5zd2l0Y2ggKGRhdGFJdGVtLmRhdGFfdHlwZSkge1xcbiAgICBjYXNlIFxcXCJob21lX3J1bGVfdXJsXFxcIjpcXG4gICAgICAgIHJ1bGVDb2RlID0gXFxcIua1t+mYlOinhueVjOmmlumhtemikemBk+inhOWImeOAkFxcXCIgKyBkYXRhSXRlbS5uYW1lICsgXFxcIuOAke+/pWhvbWVfcnVsZV91cmzvv6VcXFwiICsgcnVsZUxpc3RKc29uICsgZGF0YUl0ZW0uaWQ7XFxuICAgICAgICBpbXBvcnRVcmwgPSBcXFwicnVsZTovL1xcXCIgKyBiYXNlNjRFbmNvZGUocnVsZUNvZGUpXFxuICAgICAgICBicmVhaztcXG4gICAgY2FzZSAncHVibGlzaCc6XFxuICAgICAgICBydWxlQ29kZSA9ICfmtbfpmJTop4bnlYzop4TliJnliIbkuqvvvIzlvZPliY3liIbkuqvnmoTmmK/vvJonICsgZGF0YUl0ZW0ubmFtZSArICfvv6VwdWJsaXNo77+lJyArIGJhc2U2NEVuY29kZShiYWNrQ29kZSk7XFxuICAgICAgICBpbXBvcnRVcmwgPSAncnVsZTovLycgKyBiYXNlNjRFbmNvZGUocnVsZUNvZGUpO1xcbiAgICAgICAgYnJlYWs7XFxuICAgIGNhc2UgJ2pzX3VybCc6XFxuICAgICAgICBydWxlQ29kZSA9ICfmtbfpmJTop4bnlYzop4TliJnliIbkuqvvvIzlvZPliY3liIbkuqvnmoTmmK/vvJrnvZHpobXmj5Lku7bvv6Vqc191cmzvv6UnICsgZGF0YUl0ZW0ubmFtZSArICdAYmFzZTY0Oi8vJyArIGJhc2U2NEVuY29kZShiYWNrQ29kZSk7XFxuICAgICAgICBpbXBvcnRVcmwgPSAncnVsZTovLycgKyBiYXNlNjRFbmNvZGUocnVsZUNvZGUpO1xcbiAgICAgICAgYnJlYWs7XFxuICAgIGNhc2UgJ2h0bWwnOlxcbiAgICAgICAgbGV0IGZpbGVfdG1wID0gZGF0YUl0ZW0ubmFtZS5zcGxpdCgnLicpO1xcbiAgICAgICAgbGV0IGZpbGVfcGF0aCA9IGZpbGVfdG1wLmxlbmd0aCA+IDEgPyBmaWxlX3RtcFtmaWxlX3RtcC5sZW5ndGggLSAxXSArIFxcXCIvXFxcIiArIGRhdGFJdGVtLm5hbWUgOiBkYXRhSXRlbS5uYW1lO1xcbiAgICAgICAgcnVsZUNvZGUgPSBcXFwi5rW36ZiU6KeG55WM5pys5Zyw5paH5Lu25YiG5Lqr77+lZmlsZV91cmzvv6VoaWtlcjovL2ZpbGVzL3J1bGVzL2R6SG91c2UvXFxcIiArIGZpbGVfcGF0aCArIFxcXCJAXFxcIiArIHJ1bGVMaXN0SnNvbiArIGRhdGFJdGVtLmlkO1xcbiAgICAgICAgaW1wb3J0VXJsID0gJ3J1bGU6Ly8nICsgYmFzZTY0RW5jb2RlKHJ1bGVDb2RlKTtcXG4gICAgICAgIGJyZWFrXFxuICAgIGNhc2UgXFxcImNvbmZpZ1xcXCI6XFxuICAgICAgICBpbXBvcnRVcmwgPSAkKCkucnVsZShwYXNzd29yZCA9PiB7XFxuICAgICAgICAgICAgZXZhbChmZXRjaChcXFwiaGlrZXI6Ly9hc3NldHMvaG9tZS5qc1xcXCIpKTtcXG4gICAgICAgICAgICBIaWtlckhvbWUubG9hZChcXFwiaW1wb3J0XFxcIiwgcGFzc3dvcmQpO1xcbiAgICAgICAgfSwgYmFja0NvZGUpO1xcbiAgICAgICAgYnJlYWs7XFxufVxcbmxldCBteV9jb2xfdHlwZSA9IFxcXCJ0ZXh0XzJcXFwiO1xcbmxldCBteV9jb2xfdHlwZTIgPSBcXFwidGV4dF8zXFxcIjtcXG5pZiAoaW1wb3J0VXJsKSB7XFxuICAgIGRhdGEucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIuWvvOWFpeinhOWImVxcXCIsXFxuICAgICAgICB1cmw6IGRhdGFJdGVtLmlzX3NhZmU/aW1wb3J0VXJsOid0b2FzdDovL+mjjumZqeinhOWImeemgeatouWvvOWFpSEhIScsXFxuICAgICAgICBjb2xfdHlwZTogbXlfY29sX3R5cGVcXG4gICAgfSk7XFxufVxcbmlmIChydWxlQ29kZSkge1xcbiAgICBkYXRhLnB1c2goe1xcbiAgICAgICAgdGl0bGU6IFxcXCLliIbkuqvlj6Pku6RcXFwiLFxcbiAgICAgICAgdXJsOiBcXFwiY29weTovL1xcXCIgKyBydWxlQ29kZSxcXG4gICAgICAgIGNvbF90eXBlOiBteV9jb2xfdHlwZVxcbiAgICB9KTtcXG59XFxuXFxuaWYgKGltcG9ydFVybCkge1xcbiAgICBpZiAoZGF0YUl0ZW0uaXNfanNvbl9saXN0ICYmICFoYXNTdWIpIHtcXG4gICAgICAgIGxldCBzdWJfcnVsZV9jb2RlID0gJ+a1t+mYlOinhueVjOWQiOmbhuinhOWImeiuoumYhe+/pWhvbWVfc3Vi77+lJyArIGRhdGFJdGVtLm5hbWUgKyBcXFwiQEBcXFwiICsgcnVsZUxpc3RKc29uICsgZGF0YUl0ZW0uaWQ7XFxuICAgICAgICBsZXQgc3ViX3VybCA9ICdydWxlOi8vJyArIGJhc2U2NEVuY29kZShzdWJfcnVsZV9jb2RlKTtcXG4gICAgICAgIGRhdGEucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6ICforqLpmIXlkIjpm4YnLFxcbiAgICAgICAgICAgIHVybDogc3ViX3VybCxcXG4gICAgICAgICAgICBjb2xfdHlwZTogbXlfY29sX3R5cGUyXFxuICAgICAgICB9KTtcXG4gICAgICAgIGRhdGEucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6ICfigJzigJzigJ3igJ08c3BhbiBzdHlsZT1cXFwiY29sb3I6ICNmZjcwMDBcXFwiPuWvvOWFpei9u+WQiOmbhjwvc3Bhbj4nLFxcbiAgICAgICAgICAgIHVybDogJCgpLmxhenlSdWxlKChkYXRhSXRlbSxzdWJVcmwpPT57XFxuICAgICAgICAgICAgICAgIGNvbnN0IHtnZW5SdWxlfT0kLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9nZW5BcGlcXFwiKTtcXG4gICAgICAgICAgICAgICAgbGV0IGltcG9ydF9ydWxlPWdlblJ1bGUoZGF0YUl0ZW0ubmFtZStcXFwiLlxcXCIrZGF0YUl0ZW0uYXV0aG9yLHN1YlVybCk7XFxuICAgICAgICAgICAgICAgIC8vY29weShpbXBvcnRfcnVsZSk7XFxuICAgICAgICAgICAgICAgIGxldCBydWxlQ29kZT1wYXJzZVBhc3RlKGltcG9ydF9ydWxlLnNwbGl0KFxcXCJcXFxcblxcXCIpWzBdKTtcXG4gICAgICAgICAgICAgICAgLy9yZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiXFxuICAgICAgICAgICAgICAgIGltcG9ydFVybCA9ICdydWxlOi8vJyArIGJhc2U2NEVuY29kZShydWxlQ29kZSk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBpbXBvcnRVcmxcXG4gICAgICAgICAgICB9LGRhdGFJdGVtLHJ1bGVMaXN0SnNvbiArIGRhdGFJdGVtLmlkKSxcXG4gICAgICAgICAgICBjb2xfdHlwZTogbXlfY29sX3R5cGUyXFxuICAgICAgICB9KTtcXG4gICAgICAgIGRhdGEucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6ICfigJzigJzigJ3igJ08c3BhbiBzdHlsZT1cXFwiY29sb3I6ICNmZjcwMDBcXFwiPuWvvOWFpemBk+W+t+e7jzwvc3Bhbj4nLFxcbiAgICAgICAgICAgIHVybDogJCgpLmxhenlSdWxlKChkYXRhSXRlbSxzdWJVcmwpPT57XFxuICAgICAgICAgICAgICAgIC8vIGxldCB0aXRsZSA9IFxcXCJILVxcXCIrZGF0YUl0ZW0ubmFtZStcXFwiLlxcXCIrZGF0YUl0ZW0uYXV0aG9yO1xcbiAgICAgICAgICAgICAgICBsZXQgdGl0bGUgPSBcXFwiSi1cXFwiK2RhdGFJdGVtLm5hbWUuc3BsaXQoJy4nKVswXTtcXG4gICAgICAgICAgICAgICAgbGV0IHN1Yk9iaiA9IHtcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogc3ViVXJsLFxcbiAgICAgICAgICAgICAgICAgICAgZGVzYzogXFxcImhpa2VyOi8vZmlsZXMvcnVsZXMvZHpIb3VzZS9ydWxlQ2FjaGUvXFxcIit0aXRsZStcXFwiLmpzb25cXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogXFxcIlxcXCIsXFxuICAgICAgICAgICAgICAgICAgICBhY3RpdmU6IGZhbHNlLC8v56aB55So5bm25Y+R5pu05pawXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgbGV0IHNoYXJlVGV4dCA9IGJhc2U2NEVuY29kZShKU09OLnN0cmluZ2lmeShzdWJPYmopKTtcXG4gICAgICAgICAgICAgICAgdmFyIHBhc3RlcyA9IGdldFBhc3RlcygpO1xcbiAgICAgICAgICAgICAgICB2YXIgdXJsID0gc2hhcmVQYXN0ZShzaGFyZVRleHQscGFzdGVzLnNsaWNlKC0xKVswXSk7XFxuICAgICAgICAgICAgICAgIGxldCBpbXBvcnRfcnVsZT0gXFxcIui9u+WQiOmbhuiuoumYhe+8mlxcXCIrdGl0bGUrJ1xcXFxuJyt1cmw7XFxuICAgICAgICAgICAgICAgIGNvcHkoaW1wb3J0X3J1bGUpO1xcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gJ2hpa2VyOi8vZmlsZXMvcnVsZXMvZHpIb3VzZS9ydWxlQ2FjaGUvc3ViLmpzb24nO1xcbiAgICAgICAgICAgICAgICAkLnJjKGNvbmZpZy5saWIuc3ViKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIOiuoumYheWvvOWFpShwYXRoKVxcbiAgICAgICAgICAgIH0sZGF0YUl0ZW0scnVsZUxpc3RKc29uICsgZGF0YUl0ZW0uaWQpLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBteV9jb2xfdHlwZTJcXG4gICAgICAgIH0pO1xcbiAgICAgICAgZGF0YS5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogXFxcIjxzbWFsbD7mj5DnpLrvvJrlvIDlj5HogIXljZXni6zliIbkuqvnmoTlkIjpm4bmlofku7blj6rog73ljZXni6zlr7zlhaXjgII8L3NtYWxsPlxcXCIsXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJyaWNoX3RleHRcXFwiXFxuICAgICAgICB9KTtcXG4gICAgfSBlbHNlIGlmICghZGF0YUl0ZW0uaXNfanNvbl9saXN0ICYmICFoYXNTdWIgJiYgZGF0YUl0ZW0uZGF0YV90eXBlID09ICdob21lX3J1bGVfdXJsJykge1xcbiAgICAgICAgbGV0IHN1Yl9ydWxlX2NvZGUgPSAn5rW36ZiU6KeG55WM5Y2V6KeE5YiZ6K6i6ZiF77+laG9tZV9zdWLvv6UnICsgZGF0YUl0ZW0ubmFtZSArIFxcXCJAQFxcXCIgKyBydWxlTGlzdEpzb24gKyBkYXRhSXRlbS5pZCArICcmZGVidWc9dHJ1ZSc7XFxuICAgICAgICBsZXQgc3ViX3VybCA9ICdydWxlOi8vJyArIGJhc2U2NEVuY29kZShzdWJfcnVsZV9jb2RlKTtcXG4gICAgICAgIGRhdGEucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6ICforqLpmIXop4TliJknLFxcbiAgICAgICAgICAgIHVybDogc3ViX3VybCxcXG4gICAgICAgICAgICBjb2xfdHlwZTogbXlfY29sX3R5cGVcXG4gICAgICAgIH0pXFxuICAgIH1cXG59XFxuaWYgKGRhdGFJdGVtLmlzX2pzb24gJiYgZGF0YUl0ZW0uZGF0YV90eXBlID09PSBcXFwiaG9tZV9ydWxlX3VybFxcXCIgJiYgIWRhdGFJdGVtLmlzX2pzb25fbGlzdCkge1xcbiAgICBkYXRhLnB1c2goe1xcbiAgICAgICAgdGl0bGU6ICfov5vlhaXpopHpgZMnLFxcbiAgICAgICAgdXJsOiAkKCAvKlxcXCIjbm9Mb2FkaW5nI1xcXCIqLyApLmxhenlSdWxlKChuYW1lLGhvbWUpID0+IHtcXG4gICAgICAgICAgICBsZXQgcnVsZUxpc3QgPSBKU09OLnBhcnNlKHJlcXVlc3QoaG9tZSkpO1xcbiAgICAgICAgICAgIGxldCBoYXNSdWxlID0gcnVsZUxpc3Quc29tZShpdGVtID0+IGl0ZW0udGl0bGUgPT09IG5hbWUpO1xcbiAgICAgICAgICAgIGlmIChoYXNSdWxlKSB7XFxuICAgICAgICAgICAgICAgIHB1dFZhcihcXFwiV2FyZWhvdXNlLmJhY2tcXFwiLCBcXFwiMVxcXCIpO1xcbiAgICAgICAgICAgICAgICBiYWNrKCk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBob21lK1xcXCJzQFxcXCIgKyBuYW1lO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/mnKrlronoo4VcXFwiO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sIGRhdGFJdGVtLm5hbWUsYXBpLmhvbWUpLFxcbiAgICAgICAgY29sX3R5cGU6IG15X2NvbF90eXBlXFxuICAgIH0pXFxufVxcbmxldCBtYW5fcnVsZV9zYWZlID0gZ2V0QXBpKFxcXCJtYW5SdWxlU2FmZVxcXCIpK2RhdGFJdGVtLmlkO1xcbmxldCBtYW5fcnVsZV9nb29kID0gZ2V0QXBpKFxcXCJtYW5SdWxlR29vZFxcXCIpK2RhdGFJdGVtLmlkO1xcbi8vIGRhdGFJdGVtLmlzX3NhZmU7XFxuaWYoZ2V0VmFyKCdob3VzZS5pc19tYW5hZ2VyJykpe1xcbiAgICBmdW5jdGlvbiBzZXRJc1NhZmUoZmxhZyxtYW5fcnVsZV9zYWZlKSB7XFxuICAgICAgICBmbGFnID0gZmxhZyB8fCAnJztcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgbGV0IGNvZGUgPSBmZXRjaChtYW5fcnVsZV9zYWZlLCB7XFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXFwiVXNlci1BZ2VudFxcXCI6IE1PQklMRV9VQX0sXFxuICAgICAgICAgICAgICAgIGJvZHk6IHtcXG4gICAgICAgICAgICAgICAgICAgIFxcXCJwYXJhbXNcXFwiOlxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcInVzZXJuYW1lXFxcIjogZ2V0VmFyKCdob3VzZS51c2VybmFtZScpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFwicGFzc3dvcmRcXFwiOiBnZXRWYXIoJ2hvdXNlLnBhc3N3b3JkJyksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJpc19zYWZlXFxcIjogISFmbGFnXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgY29kZSA9IEpTT04ucGFyc2UoY29kZSkucmVzdWx0O1xcbiAgICAgICAgICAgIGlmIChjb2RlLnN0YXR1cyA9PT0gMCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gY29kZS5kZXRhaWxcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+aTjeS9nOWksei0pTonICsgY29kZS5kZXRhaWxcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICAgICAgcmV0dXJuICfmk43kvZzlpLHotKU6JyArIGUubWVzc2FnZVxcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIGZ1bmN0aW9uIHNldElzR29vZChmbGFnLG1hbl9ydWxlX2dvb2QpIHtcXG4gICAgICAgIGZsYWcgPSBmbGFnIHx8ICcnO1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICBsZXQgY29kZSA9IGZldGNoKG1hbl9ydWxlX2dvb2QsIHtcXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xcXCJVc2VyLUFnZW50XFxcIjogTU9CSUxFX1VBfSxcXG4gICAgICAgICAgICAgICAgYm9keToge1xcbiAgICAgICAgICAgICAgICAgICAgXFxcInBhcmFtc1xcXCI6XFxuICAgICAgICAgICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFwidXNlcm5hbWVcXFwiOiBnZXRWYXIoJ2hvdXNlLnVzZXJuYW1lJyksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJwYXNzd29yZFxcXCI6IGdldFZhcignaG91c2UucGFzc3dvcmQnKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcImlzX2dvb2RcXFwiOiAhIWZsYWdcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBjb2RlID0gSlNPTi5wYXJzZShjb2RlKS5yZXN1bHQ7XFxuICAgICAgICAgICAgaWYgKGNvZGUuc3RhdHVzID09PSAwKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBjb2RlLmRldGFpbFxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiAn5pON5L2c5aSx6LSlOicgKyBjb2RlLmRldGFpbFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgICByZXR1cm4gJ+aTjeS9nOWksei0pTonICsgZS5tZXNzYWdlXFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgZGF0YS5wdXNoKHtcXG4gICAgICAgIHRpdGxlOifwn5qr6aOO6ZmpJyxcXG4gICAgICAgIGNvbF90eXBlOidzY3JvbGxfYnV0dG9uJyxcXG4gICAgICAgIHVybDokKCfmoIforrDor6Xop4TliJnkuLrpo47pmak/6aOO6Zmp6KeE5YiZ5peg5rOV6KKr5a+85YWlJykuY29uZmlybSgoaWQsbWFuX3J1bGVfc2FmZSxzZXRJc1NhZmUpPT57XFxuICAgICAgICAgICAgbGV0IHJldCA9IHNldElzU2FmZShmYWxzZSxtYW5fcnVsZV9zYWZlKTtcXG4gICAgICAgICAgICBpZighL+aTjeS9nOWksei0pS8udGVzdChyZXQpKXtcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8vJytyZXRcXG4gICAgICAgIH0sZGF0YUl0ZW0uaWQsbWFuX3J1bGVfc2FmZSxzZXRJc1NhZmUpXFxuICAgIH0pO1xcbiAgICBkYXRhLnB1c2goe1xcbiAgICAgICAgdGl0bGU6J+Kcheato+W4uCcsXFxuICAgICAgICBjb2xfdHlwZTonc2Nyb2xsX2J1dHRvbicsXFxuICAgICAgICB1cmw6JCgn5qCH6K6w6K+l6KeE5YiZ5Li65q2j5bi4PycpLmNvbmZpcm0oKGlkLG1hbl9ydWxlX3NhZmUsc2V0SXNTYWZlKT0+e1xcbiAgICAgICAgICAgIGxldCByZXQgPSBzZXRJc1NhZmUodHJ1ZSxtYW5fcnVsZV9zYWZlKTtcXG4gICAgICAgICAgICBpZighL+aTjeS9nOWksei0pS8udGVzdChyZXQpKXtcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8vJytyZXRcXG4gICAgICAgIH0sZGF0YUl0ZW0uaWQsbWFuX3J1bGVfc2FmZSxzZXRJc1NhZmUpXFxuICAgIH0pO1xcbiAgICBkYXRhLnB1c2goe1xcbiAgICAgICAgdGl0bGU6J+KZpemdnuS8mOi0qCcsXFxuICAgICAgICBjb2xfdHlwZTonc2Nyb2xsX2J1dHRvbicsXFxuICAgICAgICB1cmw6JCgn5qCH6K6w6K+l6KeE5YiZ5Li66Z2e5LyY6LSoPycpLmNvbmZpcm0oKGlkLG1hbl9ydWxlX2dvb2Qsc2V0SXNHb29kKT0+e1xcbiAgICAgICAgICAgIGxldCByZXQgPSBzZXRJc0dvb2QoZmFsc2UsbWFuX3J1bGVfZ29vZCk7XFxuICAgICAgICAgICAgaWYoIS/mk43kvZzlpLHotKUvLnRlc3QocmV0KSl7XFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovLycrcmV0XFxuICAgICAgICB9LGRhdGFJdGVtLmlkLG1hbl9ydWxlX2dvb2Qsc2V0SXNHb29kKVxcbiAgICB9KTtcXG4gICAgZGF0YS5wdXNoKHtcXG4gICAgICAgIHRpdGxlOifwn5KW5LyY6LSoJyxcXG4gICAgICAgIGNvbF90eXBlOidzY3JvbGxfYnV0dG9uJyxcXG4gICAgICAgIHVybDokKCfmoIforrDor6Xop4TliJnkuLrkvJjotKg/JykuY29uZmlybSgoaWQsbWFuX3J1bGVfZ29vZCxzZXRJc0dvb2QpPT57XFxuICAgICAgICAgICAgbGV0IHJldCA9IHNldElzR29vZCh0cnVlLG1hbl9ydWxlX2dvb2QpO1xcbiAgICAgICAgICAgIGlmKCEv5pON5L2c5aSx6LSlLy50ZXN0KHJldCkpe1xcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly8nK3JldFxcbiAgICAgICAgfSxkYXRhSXRlbS5pZCxtYW5fcnVsZV9nb29kLHNldElzR29vZClcXG4gICAgfSk7XFxufVxcblxcbmRhdGEucHVzaCh7XFxuICAgIGNvbF90eXBlOiBcXFwibGluZV9ibGFua1xcXCJcXG59KTtcXG5kYXRhLnB1c2goe1xcbiAgICB0aXRsZTogZGF0YUl0ZW0uZ29vZF9udW0sXFxuICAgIHBpY191cmw6IFxcXCJoaWtlcjovL2ZpbGVzL2ljb24v6LWeLnN2Z1xcXCIsXFxuICAgIGNvbF90eXBlOiBcXFwiaWNvbl9zbWFsbF8zXFxcIixcXG4gICAgdXJsOiBcXFwiaGlrZXI6Ly9wYWdlL01ha2VBY29tbWVudCNub0hpc3RvcnkjI25vUmVjb3JkSGlzdG9yeSNcXFwiLFxcbiAgICBleHRyYToge1xcbiAgICAgICAgaWQ6IGRhdGFJdGVtLmlkLFxcbiAgICAgICAgbmFtZTogZGF0YUl0ZW0ubmFtZVxcbiAgICB9XFxufSk7XFxuZGF0YS5wdXNoKHtcXG4gICAgdGl0bGU6IGRhdGFJdGVtLmJhZF9udW0sXFxuICAgIHBpY191cmw6IFxcXCJoaWtlcjovL2ZpbGVzL2ljb24v6LipLnN2Z1xcXCIsXFxuICAgIGNvbF90eXBlOiBcXFwiaWNvbl9zbWFsbF8zXFxcIixcXG4gICAgdXJsOiBcXFwiaGlrZXI6Ly9wYWdlL01ha2VBY29tbWVudCNub0hpc3RvcnkjI25vUmVjb3JkSGlzdG9yeSNcXFwiLFxcbiAgICBleHRyYToge1xcbiAgICAgICAgaWQ6IGRhdGFJdGVtLmlkLFxcbiAgICAgICAgbmFtZTogZGF0YUl0ZW0ubmFtZSxcXG4gICAgICAgIGRlZmF1bHRUeXBlOlxcXCJiYWRcXFwiXFxuICAgIH1cXG59KTtcXG5kYXRhLnB1c2goe1xcbiAgICB0aXRsZTogXFxcIuivhOiuulxcXCIsXFxuICAgIHBpY191cmw6IFxcXCJoaWtlcjovL2ZpbGVzL2ljb24v6K+E6K66LnN2Z1xcXCIsXFxuICAgIGNvbF90eXBlOiBcXFwiaWNvbl9zbWFsbF8zXFxcIixcXG4gICAgdXJsOiBcXFwiaGlrZXI6Ly9wYWdlL01ha2VBY29tbWVudCNub0hpc3RvcnkjI25vUmVjb3JkSGlzdG9yeSNcXFwiLFxcbiAgICBleHRyYToge1xcbiAgICAgICAgaWQ6IGRhdGFJdGVtLmlkLFxcbiAgICAgICAgbmFtZTogZGF0YUl0ZW0ubmFtZVxcbiAgICB9XFxufSk7XFxubGV0IHRvdGFsU3VtID0gZGF0YUl0ZW0uZ29vZF9udW0gKyBkYXRhSXRlbS5iYWRfbnVtO1xcblxcbmRhdGEucHVzaCh7XFxuICAgIHRpdGxlOiBodG1sVGFnKFxcXCJiaWdcXFwiLCBcXFwi6K+E6K66KFxcXCIgKyB0b3RhbFN1bSArIFxcXCIpXFxcIikgKyBcXFwiXFxcXHRcXFxcdFxcXFx0XFxcIiArIHNtYWxsKGh0bWxUYWcoXFxcInVcXFwiLCBcXFwi5p+l55yL5YWo6YOo6K+E6K66ID5cXFwiKSksXFxuICAgIGNvbF90eXBlOiBcXFwidGV4dF8xXFxcIixcXG4gICAgdXJsOiBcXFwiaGlrZXI6Ly9wYWdlL0NvbW1lbnRcXFwiLFxcbiAgICBleHRyYToge1xcbiAgICAgICAgdXJsOiBcXFwiaGlrZXI6Ly9lbXB0eSNmeXBhZ2Ujbm9IaXN0b3J5IyNub1JlY29yZEhpc3RvcnkjXFxcIixcXG4gICAgICAgIGlkOiBkYXRhSXRlbS5pZCxcXG4gICAgICAgIHRvdGFsU3VtOiB0b3RhbFN1bSxcXG4gICAgICAgIG5vX2FjdGl2ZTogZmFsc2VcXG4gICAgfVxcbn0pO1xcbi8vY29uc3QgbG9uZ2VzdFN1bT0xMjA7XFxubGV0IGljb24gPSB7XFxuICAgIFxcXCJnb29kXFxcIjogXFxcIvCfkY1cXFwiLFxcbiAgICBcXFwiYmFkXFxcIjogXFxcIvCfkY5cXFwiLFxcbiAgICBcXFwicmVwbHlcXFwiOlxcXCLlvIDlj5HogIXwn5ejXFxcIlxcbn1cXG5pZiAodG90YWxTdW0gPT09IDApIHtcXG4gICAgZGF0YS5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBcXFwiPGg1IHN0eWxlPSd0ZXh0LWFsaWduOmNlbnRlcic+5LiA5p2h6K+E6K665Lmf5rKh5pyJ77yM5b+r5p2l5oqi5rKZ5Y+R5ZCn77yBPC9oNT5cXFwiLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJyaWNoX3RleHRcXFwiXFxuICAgIH0pO1xcbn0gZWxzZSB7XFxuICAgIGxldCBjb21tZW50TGlzdCA9IEpTT04ucGFyc2UocmVxdWVzdChhcGkuZGlzX2dldCArIGRhdGFJdGVtLmlkICsgXFxcIj9saW1pdD01XFxcIikpLnJlc3VsdDtcXG4gICAgZm9yIChsZXQgaXRlbSBvZiBjb21tZW50TGlzdCkge1xcbiAgICAgICAgbGV0IFJlcGx5ID0gaXRlbS5kaXNjdXNzX3R5cGU9PT1cXFwicmVwbHlcXFwiJiZpdGVtLnJlcGx5X3RvX25hbWUhPT1mYWxzZSYmaXRlbS5yZXBseV90b19pZCE9PWZhbHNlP1xcXCLigJjigJjlm57lpI1AXFxcIitpdGVtLnJlcGx5X3RvX25hbWUrXFxcIiAjXFxcIitpdGVtLmRpc2N1c3NfaWQrXFxcIuKAmeKAmVxcXFxuXFxcIjpcXFwiXFxcIjtcXG4gICAgICAgIGRhdGEucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6IGl0ZW0ubmFtZSArIFxcXCImbmJzcDsmbmJzcDs8Zm9udCBjb2xvcj0nZ3JheSc+PHNtYWxsPiNcXFwiICsgaXRlbS5pZCArIFxcXCI8L3NtYWxsPjxmb250PlxcXCIsXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJhdmF0YXJcXFwiLFxcbiAgICAgICAgICAgIC8vdXJsOiBcXFwidG9hc3Q6Ly9cXFwiICsgaXRlbS5xcSxcXG4gICAgICAgICAgICB1cmw6XFxcIm1xcXdwYTovL2ltL2NoYXQ/Y2hhdF90eXBlPXdwYSZ1aW49XFxcIitpdGVtLnFxLFxcbiAgICAgICAgICAgIHBpY191cmw6IGl0ZW0uYXZhdGFyX3VybFxcbiAgICAgICAgfSk7XFxuICAgICAgICBkYXRhLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiBpdGVtLmRpc2N1c3NfdGV4dCxcXG4gICAgICAgICAgICBkZXNjOiBSZXBseStpdGVtLmNyZWF0ZV9kYXRlICsgXFxcIsK3XFxcIiArIGljb25baXRlbS5kaXNjdXNzX3R5cGVdLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF8xXFxcIixcXG4gICAgICAgICAgICB1cmw6IFxcXCJoaWtlcjovL3BhZ2UvaW5mb1xcXCIsXFxuICAgICAgICAgICAgZXh0cmE6e1xcbiAgICAgICAgICAgICAgICBuYW1lOml0ZW0ubmFtZSxcXG4gICAgICAgICAgICAgICAgdHlwZTpcXFwibG9uZ190ZXh0XFxcIixcXG4gICAgICAgICAgICAgICAgdGV4dDppdGVtLmRpc2N1c3NfdGV4dFxcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgcGljX3VybDogaXRlbS5hdmF0YXJfdXJsXFxuICAgICAgICB9KTtcXG4gICAgfVxcbiAgICBkYXRhLnB1c2goe1xcbiAgICAgICAgY29sX3R5cGU6IFxcXCJsaW5lX2JsYW5rXFxcIlxcbiAgICB9KTtcXG59XFxuXFxuc2V0UmVzdWx0KGRhdGEpO1wifSx7XCJjb2xfdHlwZVwiOlwicmljaF90ZXh0XCIsXCJuYW1lXCI6XCLmn6XnnItcIixcInBhdGhcIjpcImluZm9cIixcInJ1bGVcIjpcImpzOlxcbnNldFBhZ2VUaXRsZShcXFwi5p+l55yL44CMXFxcIitNWV9QQVJBTVMubmFtZStcXFwi44CNXFxcIilcXG5zZXRSZXN1bHQoW3tcXG4gICAgdGl0bGU6IE1ZX1BBUkFNUy50ZXh0LFxcbiAgICBjb2xfdHlwZTpNWV9QQVJBTVMudHlwZVxcbn1dKTtcIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuW8gOWPkeiAheazqOWGjFwiLFwicGF0aFwiOlwiUmVnaXN0ZXJcIixcInJ1bGVcIjpcImpzOlxcbnNldFBhZ2VUaXRsZShcXFwi5byA5Y+R6ICF5rOo5YaMXFxcIik7XFxuY29uc3Qge1xcbiAgICBnZXRBcGksXFxuICAgIGh0bWxUYWcsXFxuICAgIG1hcENvbFR5cGUsXFxuICAgIHNtYWxsXFxufSA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL3V0aWxpeVxcXCIpO1xcbnZhciBkYXRhID0gW107XFxuYWRkTGlzdGVuZXIoJ29uQ2xvc2UnLCAkLnRvU3RyaW5nKCgpID0+IHtcXG4gICAgY2xlYXJWYXIoXFxcIldhcmVob3VzZS5QYXNzd29yZFxcXCIpO1xcbiAgICBjbGVhclZhcihcXFwiV2FyZWhvdXNlLlVzZXJuYW1lXFxcIik7XFxuICAgIGNsZWFyVmFyKFxcXCJXYXJlaG91c2UuRGVzY3JpcHRpb25cXFwiKTtcXG4gICAgY2xlYXJWYXIoXFxcIldhcmVob3VzZS5Vc2VyQWRkcmVzc1xcXCIpO1xcbn0pKTtcXG5hZGRMaXN0ZW5lcignb25SZWZyZXNoJywgJC50b1N0cmluZygoKT0+e1xcbiAgICBwdXRWYXIoXFxcIldhcmVob3VzZS5XYWl0XFxcIiwgXFxcIlxcXCIpO1xcbn0pKTtcXG5kYXRhLnB1c2goe1xcbiAgICB0aXRsZTogJ+i0puWPtycsXFxuICAgIGRlc2M6IFxcXCLor7fovpPlhaXotKblj7co5b+F5aGrKVxcXCIsXFxuICAgIGNvbF90eXBlOiAnaW5wdXQnLFxcbiAgICBleHRyYToge1xcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBnZXRWYXIoJ1dhcmVob3VzZS5Vc2VybmFtZScsICcnKSxcXG4gICAgICAgIHR5cGU6IFxcXCJudW1iZXJcXFwiLFxcbiAgICAgICAgb25DaGFuZ2U6ICdwdXRWYXIoXFxcIldhcmVob3VzZS5Vc2VybmFtZVxcXCIsaW5wdXQpJ1xcbiAgICB9XFxufSwge1xcbiAgICB0aXRsZTogJ+WvhueggScsXFxuICAgIGRlc2M6IFxcXCLor7fovpPlhaXlr4bnoIEo5b+F5aGrKVxcXCIsXFxuICAgIGNvbF90eXBlOiAnaW5wdXQnLFxcbiAgICBleHRyYToge1xcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBnZXRWYXIoJ1dhcmVob3VzZS5QYXNzd29yZCcsICcnKSxcXG4gICAgICAgIHR5cGU6IFxcXCJwYXNzd29yZFxcXCIsXFxuICAgICAgICBvbkNoYW5nZTogJ3B1dFZhcihcXFwiV2FyZWhvdXNlLlBhc3N3b3JkXFxcIixpbnB1dCknXFxuICAgIH1cXG59KTtcXG5tYXBDb2xUeXBlKGRhdGEsIFxcXCJsaW5lX2JsYW5rXFxcIiwgMSk7XFxuZGF0YS5wdXNoKHtcXG4gICAgdGl0bGU6ICfmmLXnp7AnLFxcbiAgICBkZXNjOiBcXFwi6K+36L6T5YWl5pi156ewKOW/heWhqylcXFwiLFxcbiAgICBjb2xfdHlwZTogJ2lucHV0JyxcXG4gICAgZXh0cmE6IHtcXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogZ2V0VmFyKCdXYXJlaG91c2UuVXNlckFkZHJlc3MnLCAnJyksXFxuICAgICAgICBvbkNoYW5nZTogJ3B1dFZhcihcXFwiV2FyZWhvdXNlLlVzZXJBZGRyZXNzXFxcIixpbnB1dCknXFxuICAgIH1cXG59LCB7XFxuICAgIHRpdGxlOiAn5o+P6L+wJyxcXG4gICAgZGVzYzogXFxcIuivtOivtOS4uuS7gOS5iOimgeazqOWGjOWQp1xcXFxuKOWPr+S7peWinuWKoOmAmui/h+amgueOhyzpgInloaspXFxcIixcXG4gICAgY29sX3R5cGU6ICdpbnB1dCcsXFxuICAgIGV4dHJhOiB7XFxuICAgICAgICBkZWZhdWx0VmFsdWU6IGdldFZhcignV2FyZWhvdXNlLkRlc2NyaXB0aW9uJywgJycpLFxcbiAgICAgICAgdHlwZTogXFxcInRleHRhcmVhXFxcIixcXG4gICAgICAgIG9uQ2hhbmdlOiAncHV0VmFyKFxcXCJXYXJlaG91c2UuRGVzY3JpcHRpb25cXFwiLGlucHV0KSdcXG4gICAgfVxcbn0pXFxuXFxubWFwQ29sVHlwZShkYXRhLCBcXFwibGluZV9ibGFua1xcXCIsIDEpO1xcblxcbmRhdGEucHVzaCh7XFxuICAgIHRpdGxlOiBodG1sVGFnKFxcXCJiXFxcIiwgXFxcIuazqOWGjFxcXCIpLFxcbiAgICB1cmw6ICQoZ2V0QXBpKFxcXCJuZXdfZGV2XFxcIikrXFxcIiNub0xvYWRpbmcjXFxcIikubGF6eVJ1bGUoKGdldElkLCBjb25maXJtKSA9PiB7XFxuICAgICAgICBsZXQgdXNlcm5hbWUgPSBnZXRWYXIoJ1dhcmVob3VzZS5Vc2VybmFtZScsIFxcXCJcXFwiKSxcXG4gICAgICAgICAgICBwYXNzd29yZCA9IGdldFZhcignV2FyZWhvdXNlLlBhc3N3b3JkJywgXFxcIlxcXCIpLFxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gZ2V0VmFyKCdXYXJlaG91c2UuRGVzY3JpcHRpb24nLCBcXFwiXFxcIiksXFxuICAgICAgICAgICAgbmFtZSA9IGdldFZhcihcXFwiV2FyZWhvdXNlLlVzZXJBZGRyZXNzXFxcIiwgXFxcIlxcXCIpO1xcbiAgICAgICAgaWYgKFt1c2VybmFtZSwgcGFzc3dvcmQsIG5hbWVdLmluY2x1ZGVzKFxcXCJcXFwiKSkge1xcbiAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/otKblj7cs5a+G56CB5ZKM5pi156ew5LiN6IO95Li656m6XFxcIjtcXG4gICAgICAgIH1cXG4gICAgICAgIHNob3dMb2FkaW5nKFxcXCLmraPlnKjmj5DkuqTnlLPor7fooahcXFwiKTtcXG4gICAgICAgIGxldCByZXN1bHQgPSByZXF1ZXN0KGlucHV0LCB7XFxuICAgICAgICAgICAgaGVhZGVyczoge1xcbiAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XFxuICAgICAgICAgICAgICAgIFxcXCJwYXJhbXNcXFwiOiB7XFxuICAgICAgICAgICAgICAgICAgICBcXFwicmVhc29uXFxcIjogZGVzY3JpcHRpb24sXFxuICAgICAgICAgICAgICAgICAgICBcXFwibmFtZVxcXCI6IG5hbWUsXFxuICAgICAgICAgICAgICAgICAgICBcXFwicGFzc3dvcmRcXFwiOiBwYXNzd29yZCxcXG4gICAgICAgICAgICAgICAgICAgIFxcXCJxcVxcXCI6IHVzZXJuYW1lXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KSxcXG4gICAgICAgICAgICBtZXRob2Q6ICdwb3N0J1xcbiAgICAgICAgfSk7XFxuICAgICAgICByZXN1bHQgPSBKU09OLnBhcnNlKHJlc3VsdCkucmVzdWx0O1xcbiAgICAgICAgaGlkZUxvYWRpbmcoKTtcXG4gICAgICAgIGlmIChyZXN1bHQuc3RhdHVzICE9PSAwKSB7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL1xcXCIgKyByZXN1bHQuZGV0YWlsO1xcbiAgICAgICAgfVxcbiAgICAgICAgbGV0IGlkcmVzdWx0ID0gSlNPTi5wYXJzZShyZXF1ZXN0KGdldElkICsgXFxcIj9xcT1cXFwiICsgdXNlcm5hbWUpKTtcXG4gICAgICAgIGlmIChpZHJlc3VsdC5zdGF0dXMgIT09IDApIHtcXG4gICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8vXFxcIiArIGlkcmVzdWx0LmRldGFpbDtcXG4gICAgICAgIH1cXG4gICAgICAgIFxcbiAgICAgICAgcmV0dXJuICQoXFxcIlxcXCIsIFxcXCLovpPlhaXpgq7nrrHpqozor4HnoIFcXFxcblxcXCIgKyByZXN1bHQuZGV0YWlsKS5pbnB1dCgoY29uZmlybSwgaWQsIGFjY291bnQpID0+IHtcXG4gICAgICAgICAgICBzaG93TG9hZGluZyhcXFwi6K+36ICQ5b+D562J5b6FXFxcIik7XFxuICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHJlcXVlc3QoY29uZmlybSwge1xcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcXG4gICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxcInBhcmFtc1xcXCI6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcInJlZ2lzdF9pZFxcXCI6IGlkLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFwieXptXFxcIjogaW5wdXRcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9KSxcXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnXFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBKU09OLnBhcnNlKHJlc3VsdCkucmVzdWx0O1xcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyAhPT0gMCkge1xcbiAgICAgICAgICAgICAgICAgICAgaGlkZUxvYWRpbmcoKTtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly9cXFwiICsgcmVzdWx0LmRldGFpbDtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIHB1dFZhcihcXFwiV2FyZWhvdXNlVXNlcm5hbWVcXFwiLCBhY2NvdW50WzBdKTtcXG4gICAgICAgICAgICAgICAgICAgIHB1dFZhcihcXFwiV2FyZWhvdXNlUGFzc3dvcmRcXFwiLCBhY2NvdW50WzFdKTtcXG4gICAgICAgICAgICAgICAgICAgIGhpZGVMb2FkaW5nKCk7XFxuICAgICAgICAgICAgICAgICAgICBiYWNrKCk7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5oiQ5Yqf5o+Q5Lqk5rOo5YaM5rOo5YaMXFxcXG5cXFwiK3Jlc3VsdC5kZXRhaWw7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICAgICAgICAgIGhpZGVMb2FkaW5nKCk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/lh7rplJnkuoblkZBcXFwiO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sIGNvbmZpcm0sIGlkcmVzdWx0LnJlc3VsdCwgW3VzZXJuYW1lLCBwYXNzd29yZF0pO1xcbiAgICB9LCBnZXRBcGkoXFxcIm5ld19nZXRJZFxcXCIpLCBnZXRBcGkoXFxcIm5ld19jb25maXJtXFxcIikpLFxcbiAgICBjb2xfdHlwZTogJ3RleHRfY2VudGVyXzEnXFxufSk7XFxuc2V0UmVzdWx0KGRhdGEpO1wifSx7XCJjb2xfdHlwZVwiOlwidGV4dF8xXCIsXCJuYW1lXCI6XCLkuKrkurrotYTmlplcIixcInBhdGhcIjpcIlBlcnNvbmFsRGF0YVwiLFwicnVsZVwiOlwianM6XFxuc2V0UGFnZVRpdGxlKFxcXCLkuKrkurrotYTmlplcXFwiKTtcXG52YXIgZGF0YT1bXTtcXG5jb25zdCB7XFxuICAgIGdldEFwaSxcXG4gICAgZ2V0RmlsZSxcXG4gICAgYXBpXFxufSA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL3V0aWxpeVxcXCIpO1xcblxcbmRhdGEucHVzaCh7XFxuICAgIGNvbF90eXBlOlxcXCJsaW5lX2JsYW5rXFxcIlxcbn0pO1xcblxcbmxldCB7dXNlcm5hbWUscGFzc3dvcmR9ID0gZ2V0RmlsZSgpO1xcbmxldCBkZXYgPSBKU09OLnBhcnNlKHJlcXVlc3QoZ2V0QXBpKFxcXCJ1c2VyXFxcIikrTVlfUEFSQU1TLmlkKSkucmVzdWx0O1xcbmRhdGEucHVzaCh7XFxuICAgIHRpdGxlOlxcXCLlpLTlg49cXFwiLFxcbiAgICBkZXNjOmRldi5hdmF0YXIsXFxuICAgIHVybDpcXFwiaGlrZXI6Ly9wYWdlL21vZGlmeV9QZXJzb25hbERhdGEjbm9IaXN0b3J5IyNub1JlY29yZEhpc3RvcnkjXFxcIixcXG4gICAgZXh0cmE6e1xcbiAgICAgICAgZGV2OmRldixcXG4gICAgICAgIHVzZXJuYW1lOnVzZXJuYW1lLFxcbiAgICAgICAgcGFzc3dvcmQ6cGFzc3dvcmQsXFxuICAgICAgICBQYXR0ZXJuOjBcXG4gICAgfSxcXG4gICAgY29sX3R5cGU6XFxcInRleHRfMVxcXCJcXG59KTtcXG5cXG5cXG5kYXRhLnB1c2goe1xcbiAgICB0aXRsZTpcXFwi5pi156ewXFxcIixcXG4gICAgZGVzYzpkZXYubmFtZSxcXG4gICAgdXJsOlxcXCJoaWtlcjovL3BhZ2UvbW9kaWZ5X1BlcnNvbmFsRGF0YSNub0hpc3RvcnkjI25vUmVjb3JkSGlzdG9yeSNcXFwiLFxcbiAgICBleHRyYTp7XFxuICAgICAgICBkZXY6ZGV2LFxcbiAgICAgICAgdXNlcm5hbWU6dXNlcm5hbWUsXFxuICAgICAgICBwYXNzd29yZDpwYXNzd29yZCxcXG4gICAgICAgIFBhdHRlcm46MVxcbiAgICB9LFxcbiAgICBjb2xfdHlwZTpcXFwidGV4dF8xXFxcIlxcbn0pO1xcblxcbmRhdGEucHVzaCh7XFxuICAgIHRpdGxlOlxcXCLlr4bnoIFcXFwiLFxcbiAgICB1cmw6XFxcImhpa2VyOi8vcGFnZS9tb2RpZnlfUGVyc29uYWxEYXRhI25vSGlzdG9yeSMjbm9SZWNvcmRIaXN0b3J5I1xcXCIsXFxuICAgIGV4dHJhOntcXG4gICAgICAgIGRldjpkZXYsXFxuICAgICAgICB1c2VybmFtZTp1c2VybmFtZSxcXG4gICAgICAgIHBhc3N3b3JkOnBhc3N3b3JkLFxcbiAgICAgICAgUGF0dGVybjoyXFxuICAgIH0sXFxuICAgIGNvbF90eXBlOlxcXCJ0ZXh0XzFcXFwiXFxufSk7XFxuZGF0YS5wdXNoKHtcXG4gICAgY29sX3R5cGU6XFxcImxpbmVfYmxhbmtcXFwiXFxufSk7XFxuZGF0YS5wdXNoKHtcXG4gICAgdGl0bGU6XFxcIui0puWPt++8mlxcXCIrdXNlcm5hbWUsXFxuICAgIHVybDpcXFwiY29weTovL1xcXCIrdXNlcm5hbWUsXFxuICAgIGNvbF90eXBlOlxcXCJ0ZXh0XzFcXFwiXFxufSk7XFxuZGF0YS5wdXNoKHtcXG4gICAgdGl0bGU6XFxcIlVJRO+8mlxcXCIrZGV2LmlkLFxcbiAgICB1cmw6XFxcImNvcHk6Ly9cXFwiK2Rldi5pZCxcXG4gICAgY29sX3R5cGU6XFxcInRleHRfMVxcXCJcXG59KTtcXG5kYXRhLnB1c2goe1xcbiAgICBjb2xfdHlwZTpcXFwibGluZV9ibGFua1xcXCJcXG59KTtcXG5kYXRhLnB1c2goe1xcbiAgICB0aXRsZTpcXFwi5o+Q5Lqk5LqR5LuT5bqT6KeE5YiZXFxcIixcXG4gICAgdXJsOiQoXFxcIiNub0xvYWRpbmcjXFxcIikubGF6eVJ1bGUoKGhvc3QpPT57XFxuICAgICAgICBsZXQgY29kZT1yZXF1ZXN0KGhvc3QrXFxcIi9oaWtlcnVsZS9ydWxlbGlzdC5qc29uP2lkPTE0NVxcXCIpO1xcbiAgICAgICAgbGV0IHdvcmQ9XFxcIu+/pXB1Ymxpc2jvv6VcXFwiK2Jhc2U2NEVuY29kZShjb2RlKTtcXG4gICAgICAgIHJldHVybiBcXFwicnVsZTovL1xcXCIrYmFzZTY0RW5jb2RlKHdvcmQpO1xcbiAgICB9LGFwaS5ob3N0KSxcXG4gICAgY29sX3R5cGU6XFxcInRleHRfMVxcXCJcXG59KTtcXG5kYXRhLnB1c2goe1xcbiAgICB0aXRsZTpcXFwi5ZCM5q2l5o+Q5Lqk5LqR5LuT5bqT6LSm5Y+35a+G56CBXFxcIixcXG4gICAgdXJsOlxcXCJydWxlOi8vXFxcIitiYXNlNjRFbmNvZGUoXFxcIu+/pXB1Ymxpc2hfYWNjb3VudO+/pVxcXCIrdXNlcm5hbWUrXFxcIkBcXFwiK3Bhc3N3b3JkKSxcXG4gICAgY29sX3R5cGU6XFxcInRleHRfMVxcXCJcXG59KTtcXG5kYXRhLnB1c2goe1xcbiAgICBjb2xfdHlwZTpcXFwibGluZV9ibGFua1xcXCJcXG59KTtcXG5kYXRhLnB1c2goe1xcbiAgICB0aXRsZTpcXFwi5L2g5LiA5YWx5Y+R5biD5LqG44CMXFxcIitkZXYucnVsZV9udW0rXFxcIuOAjeadoeinhOWImVxcXCIsXFxuICAgIHVybDpcXFwiaGlrZXI6Ly9lbXB0eVxcXCIsXFxuICAgIGNvbF90eXBlOlxcXCJ0ZXh0XzFcXFwiXFxufSk7XFxuZGF0YS5wdXNoKHtcXG4gICAgY29sX3R5cGU6XFxcImxpbmVfYmxhbmtcXFwiXFxufSk7XFxubGV0IHVzZXIgPSBnZXRGaWxlKCk7XFxuZGF0YS5wdXNoKHtcXG4gICAgdGl0bGU6XFxcIuazqOmUgOeZu+W9lVxcXCIsXFxuICAgIHVybDokKFxcXCLnoa7orqTms6jplIDnmbvlvZU/XFxcIikuY29uZmlybShmID0+IHtcXG4gICAgICAgIGYudXNlcm5hbWU9XFxcIlxcXCI7XFxuICAgICAgICBmLnBhc3N3b3JkPVxcXCJcXFwiO1xcbiAgICAgICAgd3JpdGVGaWxlKCdoaWtlcjovL2ZpbGVzL1dhcmVob3VzZVVTRVIuanNvbicsIEpTT04uc3RyaW5naWZ5KGYpKTtcXG4gICAgICAgIHB1dFZhcihcXFwiV2FyZWhvdXNlLmJhY2tcXFwiLFxcXCIxXFxcIik7XFxuICAgICAgICBiYWNrKCk7XFxuICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5bey5rOo6ZSAXFxcIjtcXG4gICAgfSx1c2VyKSxcXG4gICAgY29sX3R5cGU6XFxcInRleHRfY2VudGVyXzFcXFwiXFxufSk7XFxuc2V0UmVzdWx0KGRhdGEpO1wifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwi5pu05pS55Liq5Lq66LWE5paZXCIsXCJwYXRoXCI6XCJtb2RpZnlfUGVyc29uYWxEYXRhXCIsXCJydWxlXCI6XCJqczpcXG5jb25zdCB7XFxuICAgIGdldEFwaSxcXG4gICAgY29sb3IsXFxuICAgIHNtYWxsLFxcbiAgICBnZXRGaWxlLFxcbiAgICBodG1sVGFnXFxufSA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL3V0aWxpeVxcXCIpO1xcbmxldCB7XFxuICAgIGRldixcXG4gICAgdXNlcm5hbWUsXFxuICAgIHBhc3N3b3JkLFxcbiAgICBQYXR0ZXJuXFxufSA9IE1ZX1BBUkFNUztcXG52YXIgZGF0YSA9IFtdO1xcbmxldCBwYXRoID0gXFxcIj9xcT1cXFwiICsgdXNlcm5hbWUgKyBcXFwiJnBhc3N3b3JkPVxcXCIgKyBwYXNzd29yZDtcXG5hZGRMaXN0ZW5lcignb25DbG9zZScsICQudG9TdHJpbmcoKCkgPT4ge1xcbiAgICBjbGVhclZhcihcXFwiV2FyZWhvdXNlLm0ucGV0TmFtZVxcXCIpO1xcbiAgICBjbGVhclZhcihcXFwiV2FyZWhvdXNlLm0uYXZhdGFyXFxcIik7XFxuICAgIGNsZWFyVmFyKFxcXCJXYXJlaG91c2UubS5QYXNzd29yZC5jXFxcIik7XFxuICAgIGNsZWFyVmFyKFxcXCJXYXJlaG91c2UubS5QYXNzd29yZC54XFxcIik7XFxuICAgIGNsZWFyVmFyKFxcXCJXYXJlaG91c2UubS5QYXNzd29yZC55XFxcIik7XFxufSkpO1xcbmZ1bmN0aW9uIG1fcGV0TmFtZSgpIHtcXG4gICAgZGF0YS5wdXNoKHtcXG4gICAgICAgIGNvbF90eXBlOiBcXFwibGluZV9ibGFua1xcXCJcXG4gICAgfSk7XFxuICAgIGRhdGEucHVzaCh7XFxuICAgICAgICBjb2xfdHlwZTogJ2lucHV0JyxcXG4gICAgICAgIGRlc2M6IFxcXCLor7fovpPlhaXmlrDmmLXnp7BcXFwiLFxcbiAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICB0aXRsZVZpc2libGU6IGZhbHNlLFxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZ2V0VmFyKCdXYXJlaG91c2UubS5wZXROYW1lJywgJycpfHxkZXYubmFtZSxcXG4gICAgICAgICAgICBvbkNoYW5nZTogJ3B1dFZhcihcXFwiV2FyZWhvdXNlLm0ucGV0TmFtZVxcXCIsaW5wdXQpJ1xcbiAgICAgICAgfVxcbiAgICB9KTtcXG4gICAgZGF0YS5wdXNoKHtcXG4gICAgICAgIGNvbF90eXBlOiBcXFwibGluZV9ibGFua1xcXCJcXG4gICAgfSk7XFxuICAgIGRhdGEucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIuS/neWtmFxcXCIsXFxuICAgICAgICB1cmw6ICQoZ2V0QXBpKFxcXCJtb2RpZnlfbmFtZVxcXCIpICsgcGF0aCkubGF6eVJ1bGUoKCkgPT4ge1xcbiAgICAgICAgICAgIGxldCBuZXdQZXROYW1lID0gZ2V0VmFyKCdXYXJlaG91c2UubS5wZXROYW1lJywgJycpO1xcbiAgICAgICAgICAgIGlmIChuZXdQZXROYW1lID09IFxcXCJcXFwiKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/kvaDov5jku4DkuYjpg73msqHloavllYohXFxcIjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHJlcXVlc3QoaW5wdXQgKyBcXFwiJm5hbWU9XFxcIiArIGVuY29kZVVSSUNvbXBvbmVudChuZXdQZXROYW1lKSk7XFxuICAgICAgICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZShyZXN1bHQpO1xcbiAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSAwKSB7XFxuICAgICAgICAgICAgICAgIGJhY2soKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+S/ruaUueaIkOWKn1xcXCI7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL1xcXCIgKyByZXN1bHQuZGV0YWlsO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pLFxcbiAgICAgICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJ1xcbiAgICB9KTtcXG59XFxuXFxuZnVuY3Rpb24gbV9hdmF0YXIoKSB7XFxuICAgIGRhdGEucHVzaCh7XFxuICAgICAgICBjb2xfdHlwZTogXFxcImxpbmVfYmxhbmtcXFwiXFxuICAgIH0pO1xcbiAgICBkYXRhLnB1c2goe1xcbiAgICAgICAgY29sX3R5cGU6ICdpbnB1dCcsXFxuICAgICAgICBkZXNjOiBcXFwi6K+36L6T5YWl5paw55qE5aS05YOP6ZO+5o6lXFxcIixcXG4gICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgdGl0bGVWaXNpYmxlOiBmYWxzZSxcXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IGdldFZhcignV2FyZWhvdXNlLm0uYXZhdGFyJywgJycpIHx8IGRldi5hdmF0YXIsXFxuICAgICAgICAgICAgb25DaGFuZ2U6ICdwdXRWYXIoXFxcIldhcmVob3VzZS5tLmF2YXRhclxcXCIsaW5wdXQpJ1xcbiAgICAgICAgfVxcbiAgICB9KTtcXG4gICAgZGF0YS5wdXNoKHtcXG4gICAgICAgIGNvbF90eXBlOiBcXFwibGluZV9ibGFua1xcXCJcXG4gICAgfSk7XFxuICAgIGRhdGEucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIuS/neWtmFxcXCIsXFxuICAgICAgICB1cmw6ICQoZ2V0QXBpKFxcXCJtb2RpZnlfYXZhXFxcIikgKyBwYXRoKS5sYXp5UnVsZSgoKSA9PiB7XFxuICAgICAgICAgICAgbGV0IG5ld0F2YXRhciA9IGdldFZhcignV2FyZWhvdXNlLm0uYXZhdGFyJywgJycpO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSByZXF1ZXN0KGlucHV0ICsgXFxcIiZhdmF0YXJfdXJsPVxcXCIgKyBlbmNvZGVVUklDb21wb25lbnQobmV3QXZhdGFyKSk7XFxuICAgICAgICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZShyZXN1bHQpO1xcbiAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSAwKSB7XFxuICAgICAgICAgICAgICAgIGJhY2soKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+S/ruaUueaIkOWKn1xcXCI7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL1xcXCIgKyByZXN1bHQuZGV0YWlsO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pLFxcbiAgICAgICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJ1xcbiAgICB9KTtcXG59XFxuXFxuZnVuY3Rpb24gbV9wd2QoKSB7XFxuICAgIGRhdGEucHVzaCh7XFxuICAgICAgICBjb2xfdHlwZTogXFxcImxpbmVfYmxhbmtcXFwiXFxuICAgIH0pO1xcbiAgICBkYXRhLnB1c2goe1xcbiAgICAgICAgdGl0bGU6XFxcIuWOn+WvhueggVxcXCIsXFxuICAgICAgICBjb2xfdHlwZTogJ2lucHV0JyxcXG4gICAgICAgIGRlc2M6IFxcXCLor7fovpPlhaXljp/lr4bnoIFcXFwiLFxcbiAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICB0eXBlOlxcXCJwYXNzd29yZFxcXCIsXFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBnZXRWYXIoJ1dhcmVob3VzZS5tLlBhc3N3b3JkLnknLCAnJyksXFxuICAgICAgICAgICAgb25DaGFuZ2U6ICdwdXRWYXIoXFxcIldhcmVob3VzZS5tLlBhc3N3b3JkLnlcXFwiLGlucHV0KSdcXG4gICAgICAgIH1cXG4gICAgfSk7XFxuICAgIGRhdGEucHVzaCh7XFxuICAgICAgICBjb2xfdHlwZTogXFxcImxpbmVfYmxhbmtcXFwiXFxuICAgIH0pO1xcbiAgICBkYXRhLnB1c2goe1xcbiAgICAgICAgdGl0bGU6XFxcIuaWsOWvhueggVxcXCIsXFxuICAgICAgICBjb2xfdHlwZTogJ2lucHV0JyxcXG4gICAgICAgIGRlc2M6IFxcXCLor7fovpPlhaXmlrDlr4bnoIFcXFwiLFxcbiAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICB0eXBlOlxcXCJwYXNzd29yZFxcXCIsXFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBnZXRWYXIoJ1dhcmVob3VzZS5tLlBhc3N3b3JkLngnLCAnJyksXFxuICAgICAgICAgICAgb25DaGFuZ2U6ICdwdXRWYXIoXFxcIldhcmVob3VzZS5tLlBhc3N3b3JkLnhcXFwiLGlucHV0KSdcXG4gICAgICAgIH1cXG4gICAgfSk7XFxuICAgIGRhdGEucHVzaCh7XFxuICAgICAgICB0aXRsZTpcXFwi6YeN5aSN5paw5a+G56CBXFxcIixcXG4gICAgICAgIGNvbF90eXBlOiAnaW5wdXQnLFxcbiAgICAgICAgZGVzYzogXFxcIuivt+mHjeWkjeaWsOWvhueggVxcXCIsXFxuICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgIHR5cGU6XFxcInBhc3N3b3JkXFxcIixcXG4gICAgICAgICAgICB0aXRsZVZpc2libGU6IGZhbHNlLFxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZ2V0VmFyKCdXYXJlaG91c2UubS5QYXNzd29yZC5jJywgJycpLFxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiAncHV0VmFyKFxcXCJXYXJlaG91c2UubS5QYXNzd29yZC5jXFxcIixpbnB1dCknXFxuICAgICAgICB9XFxuICAgIH0pO1xcbiAgICBkYXRhLnB1c2goe1xcbiAgICAgICAgY29sX3R5cGU6IFxcXCJsaW5lX2JsYW5rXFxcIlxcbiAgICB9KTtcXG4gICAgZGF0YS5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBcXFwi5L+d5a2YXFxcIixcXG4gICAgICAgIHVybDogJChnZXRBcGkoXFxcIm1vZGlmeV9wd2RcXFwiKStwYXRoKS5sYXp5UnVsZSgocGFzc3dvcmQsdXNlcm5hbWUpID0+IHtcXG4gICAgICAgICAgICBsZXQgb2xkX3Bhc3N3b3JkID0gZ2V0VmFyKCdXYXJlaG91c2UubS5QYXNzd29yZC55JywgJycpO1xcbiAgICAgICAgICAgIGxldCBuZXdfcGFzc3dvcmQgPSBnZXRWYXIoJ1dhcmVob3VzZS5tLlBhc3N3b3JkLngnLCAnJyk7XFxuICAgICAgICAgICAgbGV0IG5ld19wYXNzd29yZF9hZ2FpbiA9IGdldFZhcignV2FyZWhvdXNlLm0uUGFzc3dvcmQuYycsICcnKTtcXG4gICAgICAgICAgICBpZiAob2xkX3Bhc3N3b3JkIT09cGFzc3dvcmQpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+WOn+WvhueggemUmeivr1xcXCI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmKG5ld19wYXNzd29yZD09PVxcXCJcXFwiKXtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+ivt+i+k+WFpeaWsOWvhueggVxcXCI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmKG5ld19wYXNzd29yZCE9PW5ld19wYXNzd29yZF9hZ2Fpbil7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/kuKTmrKHlr4bnoIHkuI3lkIxcXFwiXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSByZXF1ZXN0KGlucHV0ICsgXFxcIiZuZXdfcGFzc3dvcmQ9XFxcIiArIG5ld19wYXNzd29yZCtcXFwiJm5ld19wYXNzd29yZF9yZT1cXFwiK25ld19wYXNzd29yZF9hZ2Fpbik7XFxuICAgICAgICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZShyZXN1bHQpO1xcbiAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSAwKSB7XFxuICAgICAgICAgICAgICAgIHdyaXRlRmlsZShcXFwiaGlrZXI6Ly9maWxlcy9XYXJlaG91c2VVU0VSLmpzb25cXFwiLEpTT04uc3RyaW5naWZ5KHtcXG4gICAgICAgICAgICAgICAgICAgIHVzZXJuYW1lOnVzZXJuYW1lLFxcbiAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQ6bmV3X3Bhc3N3b3JkXFxuICAgICAgICAgICAgICAgIH0pKTtcXG4gICAgICAgICAgICAgICAgYmFjaygpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5L+u5pS55oiQ5YqfXFxcIjtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8vXFxcIiArIHJlc3VsdC5kZXRhaWw7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxwYXNzd29yZCx1c2VybmFtZSksXFxuICAgICAgICBjb2xfdHlwZTogJ3RleHRfY2VudGVyXzEnXFxuICAgIH0pO1xcbn1cXG5cXG5zd2l0Y2ggKFBhdHRlcm4pIHtcXG4gICAgY2FzZSAwOlxcbiAgICAgICAgc2V0UGFnZVRpdGxlKFxcXCLkv67mlLnlpLTlg49cXFwiKTtcXG4gICAgICAgIG1fYXZhdGFyKCk7XFxuICAgICAgICBicmVhaztcXG4gICAgY2FzZSAxOlxcbiAgICAgICAgc2V0UGFnZVRpdGxlKFxcXCLkv67mlLnmmLXnp7BcXFwiKTtcXG4gICAgICAgIG1fcGV0TmFtZSgpO1xcbiAgICAgICAgYnJlYWs7XFxuICAgIGNhc2UgMjpcXG4gICAgICAgIHNldFBhZ2VUaXRsZShcXFwi5L+u5pS55a+G56CBXFxcIik7XFxuICAgICAgICBtX3B3ZCgpO1xcbiAgICAgICAgYnJlYWs7XFxufVxcbnNldFJlc3VsdChkYXRhKTtcIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIue8lui+keinhOWImeWkh+azqFwiLFwicGF0aFwiOlwic2V0X3J1bGVfbm90ZXNcIixcInJ1bGVcIjpcImpzOlxcbmxldCBkYXRhID0gW107XFxuY29uc3Qge1xcbiAgICBnZXRBcGlcXG59ID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvdXRpbGl5XFxcIik7XFxubGV0IHtcXG4gICAgaWQsXFxuICAgIHVzZXJuYW1lLFxcbiAgICBwYXNzd29yZCxcXG4gICAgbmFtZVxcbn0gPSBNWV9QQVJBTVM7XFxuc2V0UGFnZVRpdGxlKFxcXCLlpIfms6jjgIxcXFwiK25hbWUrXFxcIuOAjVxcXCIpO1xcbmFkZExpc3RlbmVyKCdvbkNsb3NlJyxcXFwiY2xlYXJWYXIoJ1dhcmVob3VzZS5ydWxlLm5vdGVzJywgJycpXFxcIik7XFxubGV0IG5vdGVzPXJlcXVlc3QoZ2V0QXBpKFxcXCJnZXRfcnVsZV9ub3RlXFxcIikraWQpO1xcbm5vdGVzPUpTT04ucGFyc2Uobm90ZXMpLnJlc3VsdDtcXG5kYXRhLnB1c2goe1xcbiAgICBkZXNjOiBcXFwi6KeE5YiZ5aSH5rOoLi4uLi4uXFxcIixcXG4gICAgY29sX3R5cGU6ICdpbnB1dCcsXFxuICAgIGV4dHJhOiB7XFxuICAgICAgICB0aXRsZVZpc2libGU6IGZhbHNlLFxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBnZXRWYXIoJ1dhcmVob3VzZS5ydWxlLm5vdGVzJywgJycpfHxub3Rlc3x8XFxcIlxcXCIsXFxuICAgICAgICB0eXBlOiBcXFwidGV4dGFyZWFcXFwiLFxcbiAgICAgICAgaGVpZ2h0Oi0xLFxcbiAgICAgICAgb25DaGFuZ2U6ICdwdXRWYXIoXFxcIldhcmVob3VzZS5ydWxlLm5vdGVzXFxcIixpbnB1dCknXFxuICAgIH1cXG59KTtcXG5cXG5kYXRhLnB1c2goe1xcbiAgICB0aXRsZTogXFxcIuS/neWtmFxcXCIsXFxuICAgIGNvbF90eXBlOiBcXFwidGV4dF9jZW50ZXJfMVxcXCIsXFxuICAgIHVybDogJChnZXRBcGkoXFxcInNldF9ydWxlX25vdGVcXFwiKSArIGlkKS5sYXp5UnVsZSgodXNlcm5hbWUsIHBhc3N3b3JkKSA9PiB7XFxuICAgICAgICBsZXQgbm90ZXMgPSBnZXRWYXIoJ1dhcmVob3VzZS5ydWxlLm5vdGVzJywgJycpO1xcbiAgICAgICAgbGV0IHJlc3VsdCA9IHJlcXVlc3QoaW5wdXQsIHtcXG4gICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcXG4gICAgICAgICAgICAgICAgXFxcInBhcmFtc1xcXCI6IHtcXG4gICAgICAgICAgICAgICAgICAgIFxcXCJxcVxcXCI6IHVzZXJuYW1lLFxcbiAgICAgICAgICAgICAgICAgICAgXFxcInBhc3N3b3JkXFxcIjogcGFzc3dvcmQsXFxuICAgICAgICAgICAgICAgICAgICBcXFwibm90ZVxcXCI6bm90ZXNcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pLFxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnXFxuICAgICAgICB9KTtcXG4gICAgICAgIHJlc3VsdCA9IEpTT04ucGFyc2UocmVzdWx0KS5yZXN1bHQ7XFxuICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyAhPT0gMCkge1xcbiAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly9cXFwiICsgcmVzdWx0LmRldGFpbDtcXG4gICAgICAgIH1cXG4gICAgICAgIGJhY2soZmFsc2UpO1xcbiAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+S/ruaUueaIkOWKn1xcXCI7XFxuICAgIH0sIHVzZXJuYW1lLCBwYXNzd29yZClcXG59KTtcXG5zZXRSZXN1bHQoZGF0YSk7XCJ9LHtcImNvbF90eXBlXCI6XCJsaW5lXCIsXCJuYW1lXCI6XCLor4TorrrliJfooahcIixcInBhdGhcIjpcIkNvbW1lbnRcIixcInJ1bGVcIjpcImpzOlxcbnNldFBhZ2VUaXRsZShcXFwi6K+E6K665YiX6KGoXFxcIik7XFxuY29uc3Qge1xcbiAgICBhcGlcXG59ID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvdXRpbGl5XFxcIik7XFxubGV0IGRhdGEgPSBbXTtcXG5sZXQge1xcbiAgICB0b3RhbFN1bSxcXG4gICAgaWQsXFxuICAgIG5vX2FjdGl2ZSxcXG4gICAgdXNlcm5hbWUsXFxuICAgIHBhc3N3b3JkXFxufSA9IE1ZX1BBUkFNUztcXG5sZXQgcGFnZSA9IHBhcnNlSW50KE1ZX1VSTC5zcGxpdChcXFwiI1xcXCIpWzFdKTtcXG5sZXQgZGlzY3Vzc190eXBlID0gZ2V0VmFyKFxcXCJXYXJlaG91c2UuY29tbWVudC5kaXNjdXNzX3R5cGVcXFwiLCBcXFwiXFxcIik7XFxuaWYgKHBhZ2UgPT09IDEpIHtcXG4gICAgZGF0YS5wdXNoKHtcXG4gICAgICAgIGNvbF90eXBlOiBcXFwibGluZV9ibGFua1xcXCJcXG4gICAgfSk7XFxuICAgIGFkZExpc3RlbmVyKCdvbkNsb3NlJywgJC50b1N0cmluZygoKSA9PiB7XFxuICAgICAgICBwdXRWYXIoXFxcIldhcmVob3VzZS5jb21tZW50LmRpc2N1c3NfdHlwZVxcXCIsIFxcXCJcXFwiKTtcXG4gICAgfSkpO1xcbiAgICBkYXRhLnB1c2goe1xcbiAgICAgICAgdGl0bGU6IFxcXCLlhajpg6hcXFwiICsgKGRpc2N1c3NfdHlwZSA9PT0gXFxcIlxcXCIgPyBcXFwi4peJXFxcIiA6IFxcXCLil4tcXFwiKSxcXG4gICAgICAgIHVybDogJChcXFwiI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZSgoKSA9PiB7XFxuICAgICAgICAgICAgcHV0VmFyKFxcXCJXYXJlaG91c2UuY29tbWVudC5kaXNjdXNzX3R5cGVcXFwiLCBcXFwiXFxcIik7XFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXG4gICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiO1xcbiAgICAgICAgfSksXFxuICAgICAgICBjb2xfdHlwZTogJ3RleHRfNCdcXG5cXG4gICAgfSk7XFxuICAgIGRhdGEucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIvCfkY3otZ5cXFwiICsgKGRpc2N1c3NfdHlwZSA9PT0gXFxcImdvb2RcXFwiID8gXFxcIuKXiVxcXCIgOiBcXFwi4peLXFxcIiksXFxuICAgICAgICB1cmw6ICQoXFxcIiNub0xvYWRpbmcjXFxcIikubGF6eVJ1bGUoKCkgPT4ge1xcbiAgICAgICAgICAgIHB1dFZhcihcXFwiV2FyZWhvdXNlLmNvbW1lbnQuZGlzY3Vzc190eXBlXFxcIiwgXFxcImdvb2RcXFwiKTtcXG4gICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcbiAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCI7XFxuICAgICAgICB9KSxcXG4gICAgICAgIGNvbF90eXBlOiAndGV4dF80J1xcblxcbiAgICB9KTtcXG4gICAgZGF0YS5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBcXFwi8J+Rjui4qVxcXCIgKyAoZGlzY3Vzc190eXBlID09PSBcXFwiYmFkXFxcIiA/IFxcXCLil4lcXFwiIDogXFxcIuKXi1xcXCIpLFxcbiAgICAgICAgdXJsOiAkKFxcXCIjbm9Mb2FkaW5nI1xcXCIpLmxhenlSdWxlKCgpID0+IHtcXG4gICAgICAgICAgICBwdXRWYXIoXFxcIldhcmVob3VzZS5jb21tZW50LmRpc2N1c3NfdHlwZVxcXCIsIFxcXCJiYWRcXFwiKTtcXG4gICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcbiAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCI7XFxuICAgICAgICB9KSxcXG4gICAgICAgIGNvbF90eXBlOiAndGV4dF80J1xcbiAgICB9KTtcXG4gICAgZGF0YS5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBcXFwi5Zue5aSNXFxcIiArIChkaXNjdXNzX3R5cGUgPT09IFxcXCJyZXBseVxcXCIgPyBcXFwi4peJXFxcIiA6IFxcXCLil4tcXFwiKSxcXG4gICAgICAgIHVybDogJChcXFwiI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZSgoKSA9PiB7XFxuICAgICAgICAgICAgcHV0VmFyKFxcXCJXYXJlaG91c2UuY29tbWVudC5kaXNjdXNzX3R5cGVcXFwiLCBcXFwicmVwbHlcXFwiKTtcXG4gICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcbiAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCI7XFxuICAgICAgICB9KSxcXG4gICAgICAgIGNvbF90eXBlOiAndGV4dF80J1xcbiAgICB9KTtcXG59XFxuXFxuXFxubGV0IGljb24gPSB7XFxuICAgIFxcXCJnb29kXFxcIjogXFxcIvCfkY1cXFwiLFxcbiAgICBcXFwiYmFkXFxcIjogXFxcIvCfkY5cXFwiLFxcbiAgICBcXFwicmVwbHlcXFwiOlxcXCLlvIDlj5HogIXwn5ejXFxcIlxcbn1cXG5sZXQgY29udHJvbD0ocGlkLGFjdGl2ZSk9PnZvaWQgMDtcXG5pZihub19hY3RpdmUpe1xcbiAgICBjb250cm9sPWZ1bmN0aW9uKHBpZCxhY3RpdmUpe1xcbiAgICAgICAgZGF0YS5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTphY3RpdmU/XFxcIumakOiXj+ivhOiuulxcXCI6XFxcIuWxleekuuivhOiuulxcXCIsXFxuICAgICAgICAgICAgdXJsOiQoYXBpLmRpc19kZXZfY29udHJvbCtwaWQrXFxcIj9xcT1cXFwiICsgdXNlcm5hbWUgKyBcXFwiJnBhc3N3b3JkPVxcXCIgKyBwYXNzd29yZCtcXFwiI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZSgoKT0+e1xcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0PUpTT04ucGFyc2UocmVxdWVzdChpbnB1dCkpO1xcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL1xcXCIrcmVzdWx0LmRldGFpbDtcXG4gICAgICAgICAgICB9KSxcXG4gICAgICAgICAgICBjb2xfdHlwZTpcXFwidGV4dF8yXFxcIlxcbiAgICAgICAgfSk7XFxuICAgICAgICBkYXRhLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOlxcXCLliKDpmaTor4TorrpcXFwiLFxcbiAgICAgICAgICAgIHVybDokKFxcXCLnoa7orqTliKDpmaTor6Xor4Torro/XFxcIikuY29uZmlybSgoaW5wdXQpPT57XFxuICAgICAgICAgICAgICAgIGxldCByZXN1bHQ9SlNPTi5wYXJzZShyZXF1ZXN0KGlucHV0KSk7XFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKVxcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8vXFxcIityZXN1bHQuZGV0YWlsO1xcbiAgICAgICAgICAgIH0sYXBpLmRpc19kZXZfY29udHJvbCtwaWQrXFxcIj9xcT1cXFwiICsgdXNlcm5hbWUgKyBcXFwiJnBhc3N3b3JkPVxcXCIgKyBwYXNzd29yZCtcXFwiJmRlbGV0ZT0xXFxcIiksXFxuICAgICAgICAgICAgY29sX3R5cGU6XFxcInRleHRfMlxcXCJcXG4gICAgICAgIH0pO1xcbiAgICAgICAgZGF0YS5wdXNoKHtcXG4gICAgICAgICAgICBjb2xfdHlwZTpcXFwibGluZVxcXCJcXG4gICAgICAgIH0pO1xcbiAgICAgICAgZGF0YS5wdXNoKHtcXG4gICAgICAgICAgICBjb2xfdHlwZTpcXFwibGluZVxcXCJcXG4gICAgICAgIH0pO1xcbiAgICB9XFxufVxcbmlmICh0b3RhbFN1bSA9PT0gMCkge1xcbiAgICBkYXRhLnB1c2goe1xcbiAgICAgICAgdGl0bGU6IFxcXCI8aDUgc3R5bGU9J3RleHQtYWxpZ246Y2VudGVyJz7kuIDmnaHor4TorrrkuZ/msqHmnInvvIzlv6vmnaXmiqLmspnlj5HlkKfvvIE8L2g1PlxcXCIsXFxuICAgICAgICBjb2xfdHlwZTogXFxcInJpY2hfdGV4dFxcXCJcXG4gICAgfSk7XFxufSBlbHNlIHtcXG4gICAgbGV0IGNvbW1lbnRMaXN0ID0gSlNPTi5wYXJzZShyZXF1ZXN0KGFwaS5kaXNfZ2V0ICsgaWQgKyBcXFwiP2xpbWl0PTUmcGFnZT1cXFwiICsgcGFnZSArIFxcXCImbm9fYWN0aXZlPVxcXCIgKyBub19hY3RpdmUgKyBcXFwiJmRpc2N1c3NfdHlwZT1cXFwiICsgZGlzY3Vzc190eXBlKSkucmVzdWx0O1xcbiAgICBmb3IgKGxldCBpdGVtIG9mIGNvbW1lbnRMaXN0KSB7XFxuICAgICAgICBsZXQgUmVwbHkgPSBpdGVtLmRpc2N1c3NfdHlwZT09PVxcXCJyZXBseVxcXCImJml0ZW0ucmVwbHlfdG9fbmFtZSE9PWZhbHNlJiZpdGVtLnJlcGx5X3RvX2lkIT09ZmFsc2U/XFxcIuKAmOKAmOWbnuWkjUBcXFwiK2l0ZW0ucmVwbHlfdG9fbmFtZStcXFwiICNcXFwiK2l0ZW0uZGlzY3Vzc19pZCtcXFwi4oCZ4oCZXFxcXG5cXFwiOlxcXCJcXFwiO1xcbiAgICAgICAgZGF0YS5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogaXRlbS5uYW1lICsgXFxcIiZuYnNwOyZuYnNwOzxmb250IGNvbG9yPSdncmF5Jz48c21hbGw+I1xcXCIgKyBpdGVtLmlkICsgXFxcIjwvc21hbGw+PGZvbnQ+XFxcIixcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcImF2YXRhclxcXCIsXFxuICAgICAgICAgICAgLy91cmw6IG5vX2FjdGl2ZT9cXFwiaGlrZXI6Ly9wYWdlL1JlcGx5XFxcIjpcXFwidG9hc3Q6Ly9cXFwiICsgaXRlbS5xcSxcXG5cXHRcXHQgICAgICAgdXJsOm5vX2FjdGl2ZT9cXFwiaGlrZXI6Ly9wYWdlL1JlcGx5XFxcIjpcXFwibXFxd3BhOi8vaW0vY2hhdD9jaGF0X3R5cGU9d3BhJnVpbj1cXFwiK2l0ZW0ucXEsXFxuICAgICAgICAgICAgZXh0cmE6e1xcbiAgICAgICAgICAgICAgICBydWxlSWQ6IGlkLFxcbiAgICAgICAgICAgICAgICBuYW1lOiBpdGVtLm5hbWUsXFxuICAgICAgICAgICAgICAgIHBhc3N3b3JkOiBwYXNzd29yZCxcXG4gICAgICAgICAgICAgICAgdXNlcm5hbWU6IHVzZXJuYW1lLFxcbiAgICAgICAgICAgICAgICByZXBseUlkOml0ZW0uaWRcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIHBpY191cmw6IGl0ZW0uYXZhdGFyX3VybFxcbiAgICAgICAgfSk7XFxuICAgICAgICBkYXRhLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiBpdGVtLmRpc2N1c3NfdGV4dCxcXG4gICAgICAgICAgICBkZXNjOiBSZXBseStpdGVtLmNyZWF0ZV9kYXRlICsgXFxcIsK3XFxcIiArIGljb25baXRlbS5kaXNjdXNzX3R5cGVdLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF8xXFxcIixcXG4gICAgICAgICAgICB1cmw6IFxcXCJoaWtlcjovL3BhZ2UvaW5mb1xcXCIsXFxuICAgICAgICAgICAgZXh0cmE6e1xcbiAgICAgICAgICAgICAgICBuYW1lOml0ZW0ubmFtZSxcXG4gICAgICAgICAgICAgICAgdHlwZTpcXFwibG9uZ190ZXh0XFxcIixcXG4gICAgICAgICAgICAgICAgdGV4dDppdGVtLmRpc2N1c3NfdGV4dFxcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgcGljX3VybDogaXRlbS5hdmF0YXJfdXJsXFxuICAgICAgICB9KTtcXG4gICAgICAgIGNvbnRyb2woaXRlbS5pZCxpdGVtLmFjdGl2ZSk7XFxuICAgIH1cXG4gICAgaWYgKGNvbW1lbnRMaXN0Lmxlbmd0aCA9PT0gMCkge1xcbiAgICAgICAgZGF0YS5wdXNoKHtcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcImxpbmVfYmxhbmtcXFwiXFxuICAgICAgICB9KTtcXG4gICAgfVxcbn1cXG5cXG5zZXRSZXN1bHQoZGF0YSlcIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuWPkeihqOivhOiuulwiLFwicGF0aFwiOlwiTWFrZUFjb21tZW50XCIsXCJydWxlXCI6XCJqczpcXG5sZXQgZGF0YSA9IFtdO1xcbmNvbnN0IHtcXG4gICAgYXBpLFxcbiAgICBnZXRGaWxlXFxufSA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL3V0aWxpeVxcXCIpO1xcbmxldCB7XFxuICAgIGlkLFxcbiAgICBuYW1lLFxcbiAgICBkZWZhdWx0VHlwZVxcbn0gPSBNWV9QQVJBTVM7XFxubGV0IHVzZXI9Z2V0RmlsZSgpLnVzZXJ8fFtcXFwiXFxcIixcXFwiXFxcIl07XFxuXFxuc2V0UGFnZVRpdGxlKFxcXCLor4TorrooXFxcIiArIG5hbWUgKyBcXFwiKVxcXCIpO1xcbmFkZExpc3RlbmVyKCdvbkNsb3NlJywgJC50b1N0cmluZygoKSA9PiB7XFxuICAgIGNsZWFyVmFyKFxcXCJXYXJlaG91c2UuY29tbWVudC50eXBlXFxcIik7XFxuICAgIGNsZWFyVmFyKFxcXCJXYXJlaG91c2UuY29tbWVudC50ZXh0XFxcIik7XFxuICAgIGNsZWFyVmFyKFxcXCJXYXJlaG91c2UuY29tbWVudC5xcVxcXCIpO1xcbiAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxufSkpO1xcbmxldCB0eXBlID0gZ2V0VmFyKFxcXCJXYXJlaG91c2UuY29tbWVudC50eXBlXFxcIikgfHwgZGVmYXVsdFR5cGV8fFxcXCJnb29kXFxcIjtcXG5kYXRhLnB1c2goe1xcbiAgICBkZXNjOiBcXFwi6K+E6K66Li4uLi4uXFxcIixcXG4gICAgY29sX3R5cGU6ICdpbnB1dCcsXFxuICAgIGV4dHJhOiB7XFxuICAgICAgICB0aXRsZVZpc2libGU6IGZhbHNlLFxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBnZXRWYXIoJ1dhcmVob3VzZS5jb21tZW50LnRleHQnLCAnJyksXFxuICAgICAgICB0eXBlOiBcXFwidGV4dGFyZWFcXFwiLFxcbiAgICAgICAgaGVpZ2h0OjcsXFxuICAgICAgICBvbkNoYW5nZTogJ3B1dFZhcihcXFwiV2FyZWhvdXNlLmNvbW1lbnQudGV4dFxcXCIsaW5wdXQpJ1xcbiAgICB9XFxufSk7XFxuZGF0YS5wdXNoKHtcXG4gICAgdGl0bGU6XFxcIui0puWPt++8mlxcXCIrKHVzZXJbMF18fFxcXCJcXFwiKSxcXG4gICAgZGVzYzpcXFwi6aqM6K+B56CB77yaXFxcIisodXNlclsxXXx8XFxcIlxcXCIpLFxcbiAgICB1cmw6XFxcImhpa2VyOi8vcGFnZS9Vc2VycmVnaXN0cmF0aW9uXFxcIixcXG4gICAgY29sX3R5cGU6ICd0ZXh0XzEnLFxcbiAgICBcXG59KTtcXG5cXG5kYXRhLnB1c2goe1xcbiAgICB0aXRsZTogICh0eXBlID09PSBcXFwiZ29vZFxcXCIgPyBcXFwi4peJXFxcIiA6IFxcXCLil4tcXFwiKStcXFwiIPCfkY1cXFwiLFxcbiAgICB1cmw6ICQoXFxcIiNub0xvYWRpbmcjXFxcIikubGF6eVJ1bGUoKCkgPT4ge1xcbiAgICAgICAgcHV0VmFyKFxcXCJXYXJlaG91c2UuY29tbWVudC50eXBlXFxcIiwgXFxcImdvb2RcXFwiKTtcXG4gICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiO1xcbiAgICB9KSxcXG4gICAgY29sX3R5cGU6ICd0ZXh0XzInXFxuXFxufSk7XFxuZGF0YS5wdXNoKHtcXG4gICAgdGl0bGU6ICAodHlwZSA9PT0gXFxcImJhZFxcXCIgPyBcXFwi4peJXFxcIiA6IFxcXCLil4tcXFwiKStcXFwiIPCfkY5cXFwiLFxcbiAgICB1cmw6ICQoXFxcIiNub0xvYWRpbmcjXFxcIikubGF6eVJ1bGUoKCkgPT4ge1xcbiAgICAgICAgcHV0VmFyKFxcXCJXYXJlaG91c2UuY29tbWVudC50eXBlXFxcIiwgXFxcImJhZFxcXCIpO1xcbiAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXG4gICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCI7XFxuICAgIH0pLFxcbiAgICBjb2xfdHlwZTogJ3RleHRfMidcXG59KTtcXG5cXG5kYXRhLnB1c2goe1xcbiAgICB0aXRsZTogXFxcIuaPkOS6pFxcXCIsXFxuICAgIGNvbF90eXBlOiBcXFwidGV4dF9jZW50ZXJfMVxcXCIsXFxuICAgIHVybDogJChhcGkuZGlzX25ldyArIGlkKS5sYXp5UnVsZSgoQWNjb3VudCkgPT4ge1xcbiAgICAgICAgbGV0IHRleHQgPSBnZXRWYXIoJ1dhcmVob3VzZS5jb21tZW50LnRleHQnLCAnJyk7XFxuICAgICAgICBsZXQgW3FxLGF1dGhfY29kZV0gPSBBY2NvdW50O1xcbiAgICAgICAgbGV0IHR5cGUgPSBnZXRWYXIoJ1dhcmVob3VzZS5jb21tZW50LnR5cGUnKSB8fCAnZ29vZCc7XFxuICAgICAgICBxcT1xcXx8XFxcIlxcXCI7XFxuICAgICAgICBhdXRoX2NvZGU9YXV0aF9jb2RlfHxcXFwiXFxcIjtcXG4gICAgICAgIGlmKHFxPT1cXFwiXFxcInx8YXV0aF9jb2RlPT1cXFwiXFxcIil7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+acqueZu+W9lei0puWPt1xcXCI7XFxuICAgICAgICB9XFxuICAgICAgICBpZih0ZXh0PT1cXFwiXFxcIil7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+S9oOi/mOS7gOS5iOmDveayoeWGmeWVilxcXCI7XFxuICAgICAgICB9XFxuICAgICAgICBmdW5jdGlvbiByKHApIHtcXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gcmVxdWVzdChpbnB1dCwge1xcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXFxuICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHApLFxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJ1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHJlc3VsdCkucmVzdWx0O1xcbiAgICAgICAgfVxcbiAgICAgICAgbGV0IHAgPSB7XFxuICAgICAgICAgICAgXFxcInBhcmFtc1xcXCI6IHtcXG4gICAgICAgICAgICAgICAgXFxcImRpc2N1c3NfdGV4dFxcXCI6IHRleHQsXFxuICAgICAgICAgICAgICAgIFxcXCJxcVxcXCI6IHFxLFxcbiAgICAgICAgICAgICAgICBcXFwiZGlzY3Vzc190eXBlXFxcIjogdHlwZSxcXG4gICAgICAgICAgICAgICAgXFxcImF1dGhfY29kZVxcXCI6IGF1dGhfY29kZVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGxldCByZXN1bHQgPSByKHApO1xcbiAgICAgICAgaWYocmVzdWx0LnN0YXR1cz09PTApe1xcbiAgICAgICAgICAgIGJhY2soZmFsc2UpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL1xcXCIrcmVzdWx0LmRldGFpbDtcXG5cXG4gICAgfSx1c2VyKVxcbn0pO1xcblxcbnNldFJlc3VsdChkYXRhKTtcIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuS8queUqOaIt+azqOWGjFwiLFwicGF0aFwiOlwiVXNlcnJlZ2lzdHJhdGlvblwiLFwicnVsZVwiOlwianM6XFxuY29uc3Qge1xcbiAgICBhcGksXFxuICAgIGdldEZpbGUsXFxuICAgIGdldFVzZXJEYXRlXFxufSA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL3V0aWxpeVxcXCIpO1xcbmxldCBkYXRhID0gW107XFxuZGF0YS5wdXNoKHtcXG4gICAgY29sX3R5cGU6IFxcXCJsaW5lX2JsYW5rXFxcIlxcbn0pO1xcbnNldFBhZ2VUaXRsZShcXFwi55So5oi35YiX6KGo566h55CGXFxcIik7XFxuYWRkTGlzdGVuZXIoJ29uQ2xvc2UnLCAkLnRvU3RyaW5nKCgpID0+IHtcXG4gICAgY2xlYXJWYXIoXFxcIldhcmVob3VzZS5tLnFxXFxcIik7XFxuICAgIGNsZWFyVmFyKFxcXCJXYXJlaG91c2UubS55em1cXFwiKTtcXG59KSk7XFxubGV0IHVzZXIgPSBnZXRGaWxlKCk7XFxubGV0IHVzZXJOYW1lID0gdXNlci51c2VyIHx8IFtcXFwiXFxcIl07XFxudXNlck5hbWUgPSB1c2VyTmFtZVswXTtcXG5kYXRhLnB1c2goe1xcbiAgICB0aXRsZTogXFxcIuKAnOKAnOKAneKAnTxiaWc+KOa3u+WKoC/pqozor4Ep6LSm5Y+3PC9iaWc+XFxcIixcXG4gICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiLFxcbiAgICB1cmw6IFxcXCJoaWtlcjovL2VtcHR5XFxcIlxcbn0pO1xcblxcbmRhdGEucHVzaCh7XFxuICAgIHRpdGxlOiBcXFwi6I635Y+WXFxcIixcXG4gICAgY29sX3R5cGU6ICdpbnB1dCcsXFxuICAgIGRlc2M6IFxcXCLor7fovpPlhaVxcVxcXCIsXFxuICAgIHVybDogJC50b1N0cmluZygoYSwgYikgPT4ge1xcbiAgICAgICAgbGV0IHFxID0gaW5wdXQ7XFxuICAgICAgICBpZiAocXEgPT0gXFxcIlxcXCIpIHtcXG4gICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5L2g6L+Y5LuA5LmI6YO95rKh5aGr5ZWKIVxcXCI7XFxuICAgICAgICB9XFxuICAgICAgICBzaG93TG9hZGluZyhcXFwi6I635Y+W5LitLi4uXFxcIilcXG4gICAgICAgIHJldHVybiAkKFxcXCIjbm9Mb2FkaW5nI1xcXCIpLmxhenlSdWxlKChxcSwgYSwgYikgPT4ge1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gcmVxdWVzdChhLCB7XFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcXG4gICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xcbiAgICAgICAgICAgICAgICAgICAgXFxcInBhcmFtc1xcXCI6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXFwicXFcXFwiOiBxcVxcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9KSxcXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCdcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICByZXN1bHQgPSBKU09OLnBhcnNlKHJlc3VsdCkucmVzdWx0O1xcbiAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSAwKSB7XFxuICAgICAgICAgICAgICAgIGhpZGVMb2FkaW5nKCk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly9cXFwiICsgcmVzdWx0LmRldGFpbDtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0MiA9IEpTT04ucGFyc2UocmVxdWVzdChiICsgXFxcIj9xcT1cXFwiICsgcXEpKTtcXG4gICAgICAgICAgICAgICAgaGlkZUxvYWRpbmcoKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL1xcXCIgKyByZXN1bHQyLmRldGFpbDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICAgICAgaGlkZUxvYWRpbmcoKTtcXG4gICAgICAgICAgICB0aHJvdyBlO1xcbiAgICAgICAgfVxcbiAgICAgICAgfSwgcXEsIGEsIGIpO1xcblxcbiAgICB9LCBhcGkuZGlzX25ld191c2VyLCBhcGkuZGlzX3ZlcmlmeSksXFxuICAgIGV4dHJhOiB7XFxuICAgICAgICB0eXBlOiBcXFwibnVtYmVyXFxcIixcXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogZ2V0VmFyKCdXYXJlaG91c2UubS5xcScsICcnKSB8fCB1c2VyTmFtZSxcXG4gICAgICAgIG9uQ2hhbmdlOiAncHV0VmFyKFxcXCJXYXJlaG91c2UubS5xcVxcXCIsaW5wdXQpJ1xcbiAgICB9XFxufSk7XFxuXFxuZGF0YS5wdXNoKHtcXG4gICAgY29sX3R5cGU6ICdpbnB1dCcsXFxuICAgIGRlc2M6IFxcXCLor7fovpPlhaXpqozor4HnoIFcXFwiLFxcbiAgICBleHRyYToge1xcbiAgICAgICAgdGl0bGVWaXNpYmxlOiBmYWxzZSxcXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogZ2V0VmFyKCdXYXJlaG91c2UubS55em0nLCAnJyksXFxuICAgICAgICBvbkNoYW5nZTogJ3B1dFZhcihcXFwiV2FyZWhvdXNlLm0ueXptXFxcIixpbnB1dCknXFxuICAgIH1cXG59KTtcXG5kYXRhLnB1c2goe1xcbiAgICBjb2xfdHlwZTogJ3JpY2hfdGV4dCcsXFxuICAgIHRpdGxlOiBcXFwiPHNtYWxsPuaPkOekuu+8mjEu5q+P5aSp5Y+q6IO96I635Y+WNeasoemqjOivgeeggS48YnI+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Mi48cz7pqozor4HnoIHmnInmlYjmnJ/mjIHnu63kuIDlkajlt6blj7M8L3M+KOaaguaXtuS4jeS8mu+8jOW/mOiusOmqjOivgeeggeWPr+mAmui/h1FR5Y+36I635Y+WKTwvc21hbGw+XFxcIlxcbn0pO1xcblxcbmxldCB1c2VyTGlzdCA9IGdldFVzZXJEYXRlKCk7XFxuZGF0YS5wdXNoKHtcXG4gICAgdGl0bGU6IFxcXCLpqozor4Ev55m75b2VXFxcIixcXG4gICAgdXJsOiAkKFxcXCLnoa7lrprkv53lrZjvvIzpqozor4HnoIHloavplJnvvIzml6Dms5Xor4Torrrlk6ZcXFwiKS5jb25maXJtKChmLCBsLCBsb2dpbikgPT4ge1xcbiAgICAgICAgbGV0IHFxID0gZ2V0VmFyKCdXYXJlaG91c2UubS5xcScsICcnKTtcXG4gICAgICAgIGxldCB5em0gPSBnZXRWYXIoJ1dhcmVob3VzZS5tLnl6bScsICcnKTtcXG4gICAgICAgIGlmIChxcSA9PSBcXFwiXFxcIiB8fCB5em0gPT0gXFxcIlxcXCIpIHtcXG4gICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8vcXHmiJbpqozor4HnoIHkuLrnqbpcXFwiO1xcbiAgICAgICAgfVxcbiAgICAgICAgbGV0IHJlc3VsdCA9IHJlcXVlc3QobG9naW4sIHtcXG4gICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcXG4gICAgICAgICAgICAgICAgXFxcInBhcmFtc1xcXCI6IHtcXG4gICAgICAgICAgICAgICAgICAgIFxcXCJxcVxcXCI6IHFxLFxcbiAgICAgICAgICAgICAgICAgICAgXFxcImF1dGhfY29kZVxcXCI6IHl6bVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSksXFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCdcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZShyZXN1bHQpLnJlc3VsdDtcXG4gICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSAwKSB7XFxuICAgICAgICAgICAgZi51c2VyID0gW3FxLCB5em1dO1xcbiAgICAgICAgICAgIHdyaXRlRmlsZShcXFwiaGlrZXI6Ly9maWxlcy9XYXJlaG91c2VVU0VSLmpzb25cXFwiLCBKU09OLnN0cmluZ2lmeShmKSk7XFxuICAgICAgICAgICAgbGV0IGluZGV4ID0gbC5maW5kSW5kZXgoaXRlbSA9PiBpdGVtWzBdID09PSBxcSk7XFxuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcXG4gICAgICAgICAgICAgICAgbC5zcGxpY2UoaW5kZXgsIDEsIFtxcSwgeXptXSk7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChsLmxlbmd0aCA8IDYpIHtcXG4gICAgICAgICAgICAgICAgbC5wdXNoKFtxcSwgeXptXSk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgbC5zcGxpY2UoMCwgMSk7XFxuICAgICAgICAgICAgICAgIGwucHVzaChbcXEsIHl6bV0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB3cml0ZUZpbGUoXFxcImhpa2VyOi8vZmlsZXMvV2FyZWhvdXNlVVNFUkEuanNvblxcXCIsIEpTT04uc3RyaW5naWZ5KGwpKTtcXG4gICAgICAgICAgICBiYWNrKCk7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+mqjOivgeaIkOWKn1xcXCI7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8vXFxcIiArIHJlc3VsdC5kZXRhaWw7XFxuICAgIH0sIHVzZXIsIHVzZXJMaXN0LCBhcGkuZGlzX2xvZ2luKSxcXG4gICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJ1xcbn0pO1xcbmRhdGEucHVzaCh7XFxuICAgIGNvbF90eXBlOiBcXFwibGluZV9ibGFua1xcXCJcXG59KTtcXG5kYXRhLnB1c2goe1xcbiAgICB0aXRsZTogXFxcIuKAnOKAnOKAneKAnTxiaWc+6LSm5Y+35YiX6KGoPC9iaWc+XFxcXHRcXFxcdFxcXFx0PHNtYWxsPijkv53nlZk15p2h6K6w5b2VKTwvc21hbGw+XFxcIixcXG4gICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiLFxcbiAgICB1cmw6IFxcXCJoaWtlcjovL2VtcHR5XFxcIlxcbn0pO1xcbnVzZXJMaXN0LnJldmVyc2UoKTtcXG5cXG5mb3IgKGxldCBpdGVtIG9mIHVzZXJMaXN0KSB7XFxuICAgIGRhdGEucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIui0puWPt++8mlxcXCIgKyBpdGVtWzBdICsgKHVzZXJOYW1lID09PSBpdGVtWzBdID8gXFxcIlxcXFx0XFxcXHRcXFxcdOKAnOKAnFvlvZPliY3otKblj7dd4oCd4oCdXFxcIiA6IFxcXCJcXFwiKSxcXG4gICAgICAgIGRlc2M6IFxcXCLpqozor4HnoIHvvJpcXFwiICsgaXRlbVsxXSxcXG4gICAgICAgIHVybDogJChcXFwi5piv5ZCm5YiH5o2i5Li66K+lW1xcXCIgKyBpdGVtWzBdICsgXFxcIl3otKblj7dcXFwiKS5jb25maXJtKChmLCBpdGVtKSA9PiB7XFxuICAgICAgICAgICAgZi51c2VyID0gaXRlbTtcXG4gICAgICAgICAgICB3cml0ZUZpbGUoXFxcImhpa2VyOi8vZmlsZXMvV2FyZWhvdXNlVVNFUi5qc29uXFxcIiwgSlNPTi5zdHJpbmdpZnkoZikpO1xcbiAgICAgICAgICAgIGJhY2soKTtcXG4gICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5YiH5o2i5oiQ5YqfXFxcIjtcXG4gICAgICAgIH0sIHVzZXIsIGl0ZW0pLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiXFxuICAgIH0pO1xcbn1cXG5kYXRhLnB1c2goe1xcbiAgICBjb2xfdHlwZTogXFxcImxpbmVfYmxhbmtcXFwiXFxufSk7XFxuZGF0YS5wdXNoKHtcXG4gICAgdGl0bGU6IFxcXCLpgIDlh7rotKblj7dcXFwiLFxcbiAgICB1cmw6ICQoXFxcIuehruiupOmAgOWHuueZu+W9leeKtuaAgVxcXCIpLmNvbmZpcm0oKGYpID0+IHtcXG4gICAgICAgIGYudXNlciA9IFtdO1xcbiAgICAgICAgd3JpdGVGaWxlKFxcXCJoaWtlcjovL2ZpbGVzL1dhcmVob3VzZVVTRVIuanNvblxcXCIsIEpTT04uc3RyaW5naWZ5KGYpKTtcXG4gICAgICAgIGJhY2soKTtcXG4gICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/pgIDlh7rmiJDlip9cXFwiO1xcbiAgICB9LCB1c2VyKSxcXG4gICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJ1xcbn0pO1xcbnNldFJlc3VsdChkYXRhKTtcIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuWIl+ihqOaOkuW6j+eul+azlVwiLFwicGF0aFwiOlwic29ydFwiLFwicnVsZVwiOlwianM6XFxuLyog6KeE5YiZ5YiX6KGo5o6S5bqPIFsgVVDjgIFORVfjgIHml6Dmm7TmlrAgXSDpobrluo8gKi9cXG4vKiDlvZLlubbmjpLluo8gU3RhcnQgKi9cXG4vKlxcbmZ1bmN0aW9uIG1lcmdlU29ydChhcnIpIHtcXG4gICAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XFxuICAgIGlmIChsZW4gPCAyKSB7XFxuICAgICAgICByZXR1cm4gYXJyO1xcbiAgICB9XFxuICAgIHZhciBtaWRkbGUgPSBNYXRoLmZsb29yKGxlbiAvIDIpLFxcbiAgICAgICAgbGVmdCA9IGFyci5zbGljZSgwLCBtaWRkbGUpLFxcbiAgICAgICAgcmlnaHQgPSBhcnIuc2xpY2UobWlkZGxlKTtcXG4gICAgcmV0dXJuIG1lcmdlKG1lcmdlU29ydChsZWZ0KSwgbWVyZ2VTb3J0KHJpZ2h0KSk7XFxufVxcbmZ1bmN0aW9uIG1lcmdlKGxlZnQsIHJpZ2h0KSB7XFxuICAgIHZhciByZXN1bHQgPSBbXTtcXG4gICAgdmFyIGlzVGhpc1ZlcnNpb25MaXN0ID0gW107XFxuXFxuICAgIHdoaWxlIChsZWZ0Lmxlbmd0aCA+IDAgJiYgcmlnaHQubGVuZ3RoID4gMCkge1xcbiAgICAgICAgaWYgKGxlZnRbMF0udGl0bGUuaW5jbHVkZXMoXFxcIvCfhplcXFwiKSkge1xcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGxlZnQuc2hpZnQoKSk7XFxuICAgICAgICB9IGVsc2UgaWYgKHJpZ2h0WzBdLnRpdGxlLmluY2x1ZGVzKFxcXCLwn4aZXFxcIikpIHtcXG4gICAgICAgICAgICByZXN1bHQucHVzaChyaWdodC5zaGlmdCgpKTtcXG4gICAgICAgIH0gZWxzZSBpZiAobGVmdFswXS50aXRsZS5pbmNsdWRlcyhcXFwi8J+GlVxcXCIpKSB7XFxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobGVmdC5zaGlmdCgpKTtcXG4gICAgICAgIH0gZWxzZSBpZiAocmlnaHRbMF0udGl0bGUuaW5jbHVkZXMoXFxcIvCfhpVcXFwiKSkge1xcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHJpZ2h0LnNoaWZ0KCkpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBpc1RoaXNWZXJzaW9uTGlzdC5wdXNoKGxlZnQuc2hpZnQoKSk7XFxuICAgICAgICAgICAgaXNUaGlzVmVyc2lvbkxpc3QucHVzaChyaWdodC5zaGlmdCgpKTtcXG4gICAgICAgIH1cXG4gICAgfVxcblxcbiAgICB3aGlsZSAoaXNUaGlzVmVyc2lvbkxpc3QubGVuZ3RoKSByZXN1bHQucHVzaChpc1RoaXNWZXJzaW9uTGlzdC5zaGlmdCgpKTtcXG5cXG4gICAgd2hpbGUgKGxlZnQubGVuZ3RoKVxcbiAgICAgICAgcmVzdWx0LnB1c2gobGVmdC5zaGlmdCgpKTtcXG5cXG4gICAgd2hpbGUgKHJpZ2h0Lmxlbmd0aClcXG4gICAgICAgIHJlc3VsdC5wdXNoKHJpZ2h0LnNoaWZ0KCkpO1xcblxcbiAgICByZXR1cm4gcmVzdWx0O1xcbn1cXG4kLmV4cG9ydHMubWVyZ2VTb3J0ID0gbWVyZ2VTb3J0O1xcbiovXFxuLyog5b2S5bm25o6S5bqPIEVuZCAqL1xcbi8qIOaZrumAmuWIhuexu+aOkuW6jyBTdGFydCAqL1xcbmZ1bmN0aW9uIG5vcm1hbFNvcnQoYXJyKSB7XFxuICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xcbiAgICBpZiAobGVuIDwgMikge1xcbiAgICAgICAgcmV0dXJuIGFycjtcXG4gICAgfVxcbiAgICBsZXQgdXBSZXN1bHQgPSBbXTtcXG4gICAgbGV0IG90aGVyUmVzdWx0ID0gW107XFxuICAgIHdoaWxlKGFyci5sZW5ndGgpIHtcXG4gICAgICAgIGxldCBpdGVtID0gYXJyLnNoaWZ0KCk7XFxuICAgICAgICBpZihpdGVtLnRpdGxlLmluY2x1ZGVzKFxcXCLwn4aZXFxcIikpIHtcXG4gICAgICAgICAgICB1cFJlc3VsdC5wdXNoKGl0ZW0pXFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIG90aGVyUmVzdWx0LnB1c2goaXRlbSlcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gdXBSZXN1bHQuY29uY2F0KG90aGVyUmVzdWx0KTtcXG59XFxuJC5leHBvcnRzLm5vcm1hbFNvcnQgPSBub3JtYWxTb3J0O1xcbi8qIOaZrumAmuWIhuexu+aOkuW6jyBFbmQgKi9cIn0se1wiY29sX3R5cGVcIjpcImljb25fMl9yb3VuZFwiLFwibmFtZVwiOlwi5YWo6YOo5YWs5byA6KeE5YiZXCIsXCJwYXRoXCI6XCJBbGxQdWJsaWNSdWxlXCIsXCJydWxlXCI6XCJqczpcXG4gICAgY29uc3Qge1xcbiAgICAgICAgYXBpLFxcbiAgICAgICAgbG9jYWxSdWxlVmVyLFxcbiAgICAgICAgZ2V0QXBpXFxuICAgIH0gPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS91dGlsaXlcXFwiKTtcXG5jb25zdCB7XFxuICAgIG1lcmdlU29ydFxcbn0gPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9zb3J0XFxcIik7XFxubGV0IGRhdGFUeXBlID0gZ2V0VmFyKFxcXCJXYXJlaG91c2UudHlwZVxcXCIsIFxcXCJcXFwiKTtcXG5sZXQgb3JkZXIgPSBnZXRWYXIoXFxcIldhcmVob3VzZS5vcmRlclxcXCIsIFxcXCIwXFxcIik7XFxubGV0IHNvcnQgPSBnZXRWYXIoXFxcIldhcmVob3VzZS5zb3J0XFxcIiwgXFxcIjBcXFwiKTtcXG5sZXQgZ29vZCA9IGdldFZhcihcXFwiV2FyZWhvdXNlLmdvb2RcXFwiLCBcXFwiXFxcIik7XFxubGV0IHBhZ2UgPSBNWV9VUkwuc3BsaXQoXFxcIiNcXFwiKVsxXSB8fCAxO1xcbmxldCBydWxlTGlzdCA9IEpTT04ucGFyc2UocmVxdWVzdChhcGkuYWxsX3J1bGUgKyBcXFwiP2RhdGFfdHlwZT1cXFwiICsgZGF0YVR5cGUgKyBcXFwiJnBhZ2U9XFxcIiArIHBhZ2UgKyBcXFwiJmxpbWl0PTIwJm9yZGVyPVxcXCIgKyBvcmRlciArIFxcXCImc29ydD1cXFwiICsgc29ydCsgXFxcIiZpc19nb29kPVxcXCIgKyBnb29kKSkucmVzdWx0O1xcbmFkZExpc3RlbmVyKCdvbkNsb3NlJywgJC50b1N0cmluZygoKSA9PiB7XFxuICAgIGNsZWFyVmFyKFxcXCJXYXJlaG91c2UudHlwZVxcXCIpO1xcbiAgICBjbGVhclZhcihcXFwiV2FyZWhvdXNlLm9yZGVyXFxcIik7XFxuICAgIGNsZWFyVmFyKFxcXCJXYXJlaG91c2Uuc29ydFxcXCIpO1xcbiAgICBjbGVhclZhcihcXFwiV2FyZWhvdXNlLmdvb2RcXFwiKTtcXG4gICAgY2xlYXJWYXIoXFxcIldhcmVob3VzZS5iYWNrXFxcIik7XFxufSkpO1xcbmxldCBkYXRhID0gW107XFxuaWYgKGdldFZhcihcXFwiV2FyZWhvdXNlLmJhY2tcXFwiKSA9PT0gXFxcIjFcXFwiKSB7XFxuICAgIGJhY2soKTtcXG59XFxuZnVuY3Rpb24gdGFiKGFyciwgdHlwZSwgY29udHJhc3QpIHtcXG4gICAgZm9yIChsZXQgaXRlbSBvZiBhcnIpIHtcXG4gICAgICAgIGRhdGEucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6IGl0ZW1bMV0gPT09IGNvbnRyYXN0ID8gXFxcIuKAnOKAnFxcXCIgKyBpdGVtWzBdICsgXFxcIuKAneKAnVxcXCIgOiBpdGVtWzBdLFxcbiAgICAgICAgICAgIHVybDogJChcXFwiI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZSgoa2V5LCB0eXBlKSA9PiB7XFxuICAgICAgICAgICAgICAgIHB1dFZhcih0eXBlLCBrZXkpO1xcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCI7XFxuICAgICAgICAgICAgfSwgaXRlbVsxXSwgdHlwZSksXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJzY3JvbGxfYnV0dG9uXFxcIlxcbiAgICAgICAgfSk7XFxuICAgIH1cXG4gICAgZGF0YS5wdXNoKHtcXG4gICAgICAgIGNvbF90eXBlOiBcXFwiYmxhbmtfYmxvY2tcXFwiXFxuICAgIH0pO1xcbn1cXG5pZiAocGFnZSA9PT0gXFxcIjFcXFwiKSB7XFxuICAgIHRhYihbXFxuICAgICAgICBbXFxcIuWFqOmDqFxcXCIsIFxcXCJcXFwiXSxcXG4gICAgICAgIFtcXFwi5bCP56iL5bqPXFxcIiwgXFxcImhvbWVfcnVsZV91cmxcXFwiXSxcXG4gICAgICAgIFtcXFwi5o+Q5Lqk5LqR5LuT5bqT6KeE5YiZXFxcIiwgXFxcInB1Ymxpc2hcXFwiXSxcXG4gICAgICAgIFtcXFwi572R6aG15o+S5Lu2XFxcIiwgXFxcImpzX3VybFxcXCJdLFxcbiAgICAgICAgW1xcXCLpnZnmgIHpobXpnaJcXFwiLCBcXFwiaHRtbFxcXCJdLFxcbiAgICAgICAgW1xcXCLkuLvpophcXFwiLCBcXFwiY29uZmlnXFxcIl1cXG4gICAgXSwgXFxcIldhcmVob3VzZS50eXBlXFxcIiwgZGF0YVR5cGUpO1xcbiAgICB0YWIoW1xcbiAgICAgICAgW1xcXCLml7bpl7RcXFwiLCBcXFwiMFxcXCJdLFxcbiAgICAgICAgW1xcXCJJRFxcXCIsIFxcXCIxXFxcIl0sXFxuICAgICAgICBbXFxcIuWlveivhOW6plxcXCIsIFxcXCIyXFxcIl0sXFxuICAgICAgICBbXFxcIuW3ruivhOW6plxcXCIsIFxcXCIzXFxcIl0sXFxuICAgICAgICBbXFxcIuWbnuWkjeaVsFxcXCIsIFxcXCI0XFxcIl1cXG4gICAgXSwgXFxcIldhcmVob3VzZS5vcmRlclxcXCIsIG9yZGVyKTtcXG4gICAgdGFiKFtcXG4gICAgICAgIFtcXFwi5YCS5bqPXFxcIiwgXFxcIjBcXFwiXSxcXG4gICAgICAgIFtcXFwi5q2j5bqPXFxcIiwgXFxcIjFcXFwiXVxcbiAgICBdLCBcXFwiV2FyZWhvdXNlLnNvcnRcXFwiLCBzb3J0KTtcXG4gICAgdGFiKFtcXG4gICAgICAgIFtcXFwi5LiN6K66XFxcIiwgXFxcIlxcXCJdLFxcbiAgICAgICAgW1xcXCLkvJjotKhcXFwiLCBcXFwiMVxcXCJdXFxuICAgIF0sIFxcXCJXYXJlaG91c2UuZ29vZFxcXCIsIGdvb2QpO1xcbiAgICBkYXRhLnB1c2goe1xcbiAgICAgICAgdGl0bGU6IFxcXCLmkJzntKJcXFwiLFxcbiAgICAgICAgdXJsOiAkLnRvU3RyaW5nKG5hbWUgPT4gXFxcImhpa2VyOi8vc2VhcmNoP3M9XFxcIiArIGlucHV0ICsgXFxcIiZydWxlPVxcXCIgKyBuYW1lLCBNWV9SVUxFLnRpdGxlKSxcXG4gICAgICAgIGNvbF90eXBlOiBcXFwiaW5wdXRcXFwiLFxcbiAgICAgICAgZGVzYzogXFxcIuaQnOe0ouWFqOmDqOinhOWImVxcXCJcXG4gICAgfSk7XFxufVxcblxcbmxldCBob21lTGlzdCA9IEpTT04ucGFyc2UocmVxdWVzdChhcGkuaG9tZSkpO1xcbmxldCBtUnVsZUxpc3QgPSBbXTtcXG5mb3IgKHZhciBpdGVtIG9mIHJ1bGVMaXN0KSB7XFxuICAgIHZhciBuYW1lID0gaXRlbS5uYW1lO1xcbiAgICBpZiAoaXRlbS5pc190YXApIHtcXG4gICAgICAgIGxldCBsb2NhdGlvbiA9IEpTT04ucGFyc2UocmVxdWVzdChnZXRBcGkoXFxcInJ1bGVMaXN0SnNvblxcXCIpICsgXFxcIj9pZD1cXFwiICsgaXRlbS5pZCkpO1xcbiAgICAgICAgaXRlbS5pZCA9IGxvY2F0aW9uLmlkO1xcbiAgICAgICAgaXRlbS5uYW1lID0gbG9jYXRpb24ubmFtZTtcXG4gICAgICAgIGl0ZW0uYXV0aG9yID0gbG9jYXRpb24uYXV0aG9yO1xcbiAgICAgICAgaXRlbS5kYXRhX3R5cGUgPSBsb2NhdGlvbi5kYXRhX3R5cGU7XFxuICAgICAgICBpdGVtLnZlciA9IGxvY2F0aW9uLnZlclxcbiAgICB9XFxuICAgIGl0ZW0udmVyc2lvbiA9IGl0ZW0udmVyO1xcbiAgICBsZXQgbGFiZWwgPSBcXFwiXFxcIixcXG4gICAgICAgIGx2ZXIgPSAtMjtcXG4gICAgaWYgKGl0ZW0uaXNfanNvbiAmJiBpdGVtLmRhdGFfdHlwZSA9PT0gXFxcImhvbWVfcnVsZV91cmxcXFwiKSB7XFxuICAgICAgICBsdmVyID0gbG9jYWxSdWxlVmVyKGhvbWVMaXN0LCBpdGVtKTtcXG4gICAgICAgIGlmIChsdmVyID09PSAtMSkge1xcbiAgICAgICAgICAgIGxhYmVsID0gXFxcIvCfhpVcXFwiO1xcbiAgICAgICAgfSBlbHNlIGlmIChsdmVyIDwgaXRlbS52ZXIpIHtcXG4gICAgICAgICAgICBsYWJlbCA9IFxcXCLwn4aZXFxcIjtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBtUnVsZUxpc3QucHVzaCh7XFxuICAgICAgICB0aXRsZTogbGFiZWwgKyBuYW1lLFxcbiAgICAgICAgdXJsOiBcXFwiaGlrZXI6Ly9wYWdlL3J1bGVEZXRhaWwjbm9IaXN0b3J5IyNub1JlY29yZEhpc3RvcnkjXFxcIixcXG4gICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgbHZlcjogbHZlcixcXG4gICAgICAgICAgICBpZDogaXRlbS5pZCxcXG4gICAgICAgICAgICBpc0FsbDp0cnVlXFxuICAgICAgICB9LFxcbiAgICAgICAgcGljX3VybDogaXRlbS5waWMsXFxuICAgIH0pXFxufVxcbi8qIOW9kuW5tuaOkuW6jyBTdGFydCAqL1xcbi8vbVJ1bGVMaXN0ID0gbWVyZ2VTb3J0KG1SdWxlTGlzdCk7XFxuLyog5b2S5bm25o6S5bqPIEVuZCAqL1xcbmRhdGEucHVzaC5hcHBseShkYXRhLCBtUnVsZUxpc3QpXFxuc2V0UmVzdWx0KGRhdGEpO1wifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwi5Zue5aSNXCIsXCJwYXRoXCI6XCJSZXBseVwiLFwicnVsZVwiOlwianM6XFxubGV0IGRhdGEgPSBbXTtcXG5jb25zdCB7XFxuICAgIGFwaVxcbn0gPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS91dGlsaXlcXFwiKTtcXG5sZXQge1xcbiAgICByZXBseUlkLFxcbiAgICBydWxlSWQsXFxuICAgIG5hbWUsXFxuICAgIHBhc3N3b3JkLFxcbiAgICB1c2VybmFtZVxcbn0gPSBNWV9QQVJBTVM7XFxuXFxuXFxuc2V0UGFnZVRpdGxlKFxcXCLlm57lpI0oXFxcIiArIG5hbWUgKyBcXFwiKVxcXCIpO1xcbmFkZExpc3RlbmVyKCdvbkNsb3NlJywgJC50b1N0cmluZygoKSA9PiB7XFxuICAgIGNsZWFyVmFyKFxcXCJXYXJlaG91c2UuY29tbWVudC50ZXh0XFxcIik7XFxuICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXG59KSk7XFxuXFxuZGF0YS5wdXNoKHtcXG4gICAgZGVzYzogXFxcIuWbnuWkjS4uLi4uLlxcXCIsXFxuICAgIGNvbF90eXBlOiAnaW5wdXQnLFxcbiAgICBleHRyYToge1xcbiAgICAgICAgdGl0bGVWaXNpYmxlOiBmYWxzZSxcXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogZ2V0VmFyKCdXYXJlaG91c2UuY29tbWVudC50ZXh0JywgJycpLFxcbiAgICAgICAgdHlwZTogXFxcInRleHRhcmVhXFxcIixcXG4gICAgICAgIGhlaWdodDo3LFxcbiAgICAgICAgb25DaGFuZ2U6ICdwdXRWYXIoXFxcIldhcmVob3VzZS5jb21tZW50LnRleHRcXFwiLGlucHV0KSdcXG4gICAgfVxcbn0pO1xcblxcblxcbmRhdGEucHVzaCh7XFxuICAgIHRpdGxlOiBcXFwi5o+Q5LqkXFxcIixcXG4gICAgY29sX3R5cGU6IFxcXCJ0ZXh0X2NlbnRlcl8xXFxcIixcXG4gICAgdXJsOiAkKGFwaS5kaXNfcmVwbHkgKyBydWxlSWQpLmxhenlSdWxlKChwYXNzd29yZCwgdXNlcm5hbWUsIHJ1bGVJZCkgPT4ge1xcbiAgICAgICAgbGV0IHRleHQgPSBnZXRWYXIoJ1dhcmVob3VzZS5jb21tZW50LnRleHQnLCAnJyk7XFxuICAgICAgICBpZiAocGFzc3dvcmQgPT0gXFxcIlxcXCIgfHwgdXNlcm5hbWUgPT0gXFxcIlxcXCIpIHtcXG4gICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5pyq55m75b2V6LSm5Y+3XFxcIjtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0ZXh0ID09IFxcXCJcXFwiKSB7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+S9oOi/mOS7gOS5iOmDveayoeWGmeWVilxcXCI7XFxuICAgICAgICB9XFxuICAgICAgICBsZXQgcmVzdWx0ID0gcmVxdWVzdChpbnB1dCwge1xcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xcbiAgICAgICAgICAgICAgICBcXFwicGFyYW1zXFxcIjoge1xcbiAgICAgICAgICAgICAgICAgICAgXFxcImRpc2N1c3NfdGV4dFxcXCI6IHRleHQsXFxuICAgICAgICAgICAgICAgICAgICBcXFwicXFcXFwiOiB1c2VybmFtZSxcXG4gICAgICAgICAgICAgICAgICAgIFxcXCJwYXNzd29yZFxcXCI6IHBhc3N3b3JkLFxcbiAgICAgICAgICAgICAgICAgICAgXFxcImRpc2N1c3NfaWRcXFwiOiBydWxlSWRcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pLFxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnXFxuICAgICAgICB9KTtcXG4gICAgICAgIHJlc3VsdCA9IEpTT04ucGFyc2UocmVzdWx0KS5yZXN1bHQ7XFxuICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gMCkge1xcbiAgICAgICAgICAgIGJhY2soZmFsc2UpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL1xcXCIgKyByZXN1bHQuZGV0YWlsO1xcblxcbiAgICB9LCBwYXNzd29yZCwgdXNlcm5hbWUsIHJlcGx5SWQpXFxufSk7XFxuXFxuc2V0UmVzdWx0KGRhdGEpO1wifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwi5oiR55qE5Zue5aSNXCIsXCJwYXRoXCI6XCJNeVJlcGx5XCIsXCJydWxlXCI6XCJqczpcXG5jb25zdCB7XFxuICAgIGFwaVxcbn0gPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS91dGlsaXlcXFwiKTtcXG5sZXQge1xcbiAgICBhdXRoX2NvZGUsXFxuICAgIHFxXFxufSA9IE1ZX1BBUkFNUztcXG5sZXQgcGFnZSA9IHBhcnNlSW50KE1ZX1VSTC5zcGxpdChcXFwiI1xcXCIpWzFdKTtcXG5sZXQgZGF0YT1bXTtcXG5sZXQgY29tbWVudExpc3QgPSBKU09OLnBhcnNlKHJlcXVlc3QoYXBpLmRpc19nZXRfcmVwbHkgKyBcXFwiP2xpbWl0PTUmcGFnZT1cXFwiICsgcGFnZSArIFxcXCImcXE9XFxcIiArIHFxICsgXFxcIiZhdXRoX2NvZGU9XFxcIiArIGF1dGhfY29kZSkpLnJlc3VsdDtcXG5pZiAoY29tbWVudExpc3QubGVuZ3RoID09PSAwKSB7XFxuICAgIGRhdGEucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIjxoNSBzdHlsZT0ndGV4dC1hbGlnbjpjZW50ZXInPuWIq+aLieS6huS4gOadoeS5n+S4jeWJqeS6hjwvaDU+XFxcIixcXG4gICAgICAgIGNvbF90eXBlOiBcXFwicmljaF90ZXh0XFxcIlxcbiAgICB9KTtcXG59IGVsc2Uge1xcbiAgICBmb3IgKGxldCBpdGVtIG9mIGNvbW1lbnRMaXN0KSB7XFxuICAgICAgICBkYXRhLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiBpdGVtLm5hbWUgKyBcXFwiJm5ic3A7Jm5ic3A7PGZvbnQgY29sb3I9J2dyYXknPjxzbWFsbD4jXFxcIiArIGl0ZW0uaWQgKyBcXFwiPC9zbWFsbD48Zm9udD5cXFwiLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwiYXZhdGFyXFxcIixcXG4gICAgICAgICAgICB1cmw6IFxcXCJoaWtlcjovL3BhZ2UvcnVsZURldGFpbCNub0hpc3RvcnkjI25vUmVjb3JkSGlzdG9yeSNcXFwiLFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgIGx2ZXI6IFxcXCLlm57lpI3ov5vlhaXkuI3mlK/mjIHmn6XnnItcXFwiLFxcbiAgICAgICAgICAgICAgICBpZDogaXRlbS5ydWxlX2lkWzBdXFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBwaWNfdXJsOiBpdGVtLmF2YXRhcl91cmxcXG4gICAgICAgIH0pO1xcbiAgICAgICAgZGF0YS5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogaXRlbS5kaXNjdXNzX3RleHQsXFxuICAgICAgICAgICAgZGVzYzogaXRlbS5jcmVhdGVfZGF0ZSArIFxcXCLCt1xcXCIraXRlbS5ydWxlX2lkWzFdK1xcXCLCt1xcXCIrXFxcIuW8gOWPkeiAhfCfl6NcXFwiLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF8xXFxcIixcXG4gICAgICAgICAgICB1cmw6IFxcXCJoaWtlcjovL3BhZ2UvaW5mb1xcXCIsXFxuICAgICAgICAgICAgZXh0cmE6e1xcbiAgICAgICAgICAgICAgICBuYW1lOml0ZW0ubmFtZSxcXG4gICAgICAgICAgICAgICAgdHlwZTpcXFwibG9uZ190ZXh0XFxcIixcXG4gICAgICAgICAgICAgICAgdGV4dDppdGVtLmRpc2N1c3NfdGV4dFxcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgcGljX3VybDogaXRlbS5hdmF0YXJfdXJsXFxuICAgICAgICB9KTtcXG4gICAgfVxcbiAgICBcXG59XFxuc2V0UmVzdWx0KGRhdGEpO1xcblwifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwi5pu05aSa5YiG5LqrXCIsXCJwYXRoXCI6XCJtb3JlU2hhcmVcIixcInJ1bGVcIjpcImpzOlxcbiAgICBhZGRMaXN0ZW5lcignb25DbG9zZScsICQudG9TdHJpbmcoKCk9PntcXG4gICAgICAgIGNsZWFyVmFyKFxcXCJob3VzZS51cGxvYWRfY29kZVxcXCIpO1xcbiAgICB9KSk7XFxuY29uc3Qge2NvbG9yLHNtYWxsLGFwaSwgZ2V0RmlsZX0gPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS91dGlsaXlcXFwiKTtcXG5sZXQgaG91c2VGaWxlID0gZ2V0RmlsZXx8ZmFsc2U7XFxubGV0IHB1dF91cmwgPSBhcGkuaG9zdCsnL2hpa2VydWxlL2Rldi9wdXQnO1xcbmlmKCFob3VzZUZpbGUpe1xcbiAgICBzZXRJdGVtKCdpc19ob3VzZV92aXAnLCAnZmFsc2UnKTtcXG59XFxubGV0IGhvdXNlX2RhdGEgPSBob3VzZUZpbGUoKTtcXG4vLyBsb2coaG91c2VfZGF0YS51c2VybmFtZSsnLScraG91c2VfZGF0YS5wYXNzd29yZCk7XFxudmFyIGNhbnVwID0gaG91c2VfZGF0YS51c2VybmFtZS5sZW5ndGggPj0gNiAmJiBob3VzZV9kYXRhLnBhc3N3b3JkLmxlbmd0aCA+IDI7XFxubG9nKCflj6/ku6XkuIrkvKA/JytjYW51cCk7XFxubGV0IGQgPSBbXTtcXG5sZXQgZmlsZV90eXBlID0gW3tuYW1lOifpnZnmgIHmlofku7YnLHZhbHVlOidodG1sJ30se25hbWU6J+e9kemhteaPkuS7ticsdmFsdWU6J2pzX3VybCd9LHtuYW1lOifkuLvpobXphY3nva4nLHZhbHVlOidjb25maWcnfV07IC8v5LiK5Lyg57G75Z6LXFxubGV0IGZpbGVfcmVkaXJlY3QgPSBbe25hbWU6J+acrOWcsCcsdmFsdWU6J2ZhbHNlJ30se25hbWU6J+ebtOmTvjMwMicsdmFsdWU6J3RydWUnfV07IC8v5piv5ZCm6YeN5a6a5ZCRXFxubGV0IGZpbGVfdWEgPSBbe25hbWU6J+eUteiEkScsdmFsdWU6J3BjJ30se25hbWU6J+aJi+acuicsdmFsdWU6J21vYmlsZSd9XTtcXG5sZXQgZmlsZV90eXBlX3RpdGxlID0gZmlsZV90eXBlLm1hcCgoaXRlbSkgPT4ge1xcbiAgICBsZXQgbmFtZSA9IGdldEl0ZW0oJ2hvdXNlLmZpbGVfdHlwZScsJ+mdmeaAgeaWh+S7ticpO1xcbiAgICBpZihpdGVtLm5hbWU9PT1uYW1lKXtcXG4gICAgICAgIHJldHVybiAn8J+RiScraXRlbS5uYW1lO1xcbiAgICB9ZWxzZXtcXG4gICAgICAgIHJldHVybiBpdGVtLm5hbWU7XFxuICAgIH1cXG59KTtcXG5sZXQgZmlsZV9yZWRpcmVjdF90aXRsZSA9IGZpbGVfcmVkaXJlY3QubWFwKChpdGVtKSA9PiB7XFxuICAgIGxldCBuYW1lID0gZ2V0SXRlbSgnaG91c2UuZmlsZV9yZWRpcmVjdCcsJ+acrOWcsCcpO1xcbiAgICBpZihpdGVtLm5hbWU9PT1uYW1lKXtcXG4gICAgICAgIHJldHVybiAn8J+RiScraXRlbS5uYW1lO1xcbiAgICB9ZWxzZXtcXG4gICAgICAgIHJldHVybiBpdGVtLm5hbWU7XFxuICAgIH1cXG59KTtcXG5sZXQgZmlsZV91YV90aXRsZSA9IGZpbGVfdWEubWFwKChpdGVtKSA9PiB7XFxuICAgIGxldCBuYW1lID0gZ2V0SXRlbSgnaG91c2UuZmlsZV91YScsJ+eUteiEkScpO1xcbiAgICBpZihpdGVtLm5hbWU9PT1uYW1lKXtcXG4gICAgICAgIHJldHVybiAn8J+RiScraXRlbS5uYW1lO1xcbiAgICB9ZWxzZXtcXG4gICAgICAgIHJldHVybiBpdGVtLm5hbWU7XFxuICAgIH1cXG59KTtcXG5kLnB1c2goe2NvbF90eXBlOiAneDVfd2Vidmlld19zaW5nbGUnLCBleHRyYToge2pzOiAnY29uc29sZS5sb2coXFxcIuaIkeWKoOi9veS6hlxcXCIpJ319KTtcXG5kLnB1c2goe1xcbiAgICB0aXRsZTogJ+iOt+WPlicsXFxuICAgIGRlc2M6IFxcXCLmlofku7bot6/lvoQs5pSv5oyBaGlrZXIsZmlsZSxodHRwLOS4u+mimFxcXCIsXFxuICAgIGV4dHJhOiB7XFxuICAgICAgICBvbkNoYW5nZTogXFxcInB1dFZhcignaG91c2Uud2ViX3VybCcsaW5wdXQpXFxcIixcXG4gICAgICAgIHRpdGxlVmlzaWJsZTogdHJ1ZSxcXG4gICAgICAgIGlkOidmaWxlUGF0aCcsXFxuICAgICAgICBkZWZhdWx0VmFsdWU6Z2V0VmFyKCdob3VzZS53ZWJfdXJsJylcXG4gICAgfSxcXG4gICAgdXJsOiQudG9TdHJpbmcoKCkgPT4ge1xcbiAgICAgICAgbGV0IGlucHV0ID0gZ2V0VmFyKCdob3VzZS53ZWJfdXJsJywnJyk7XFxuICAgICAgICBpZihpbnB1dC5sZW5ndGg8Mil7XFxuICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+mTvuaOpeS4jeWPr+S7peS4uuepuidcXG4gICAgICAgIH0gZWxzZSBpZigvXmhpa2VyOnxeZmlsZTp8Xmh0dHA6fF5odHRwczp8XlxcXFwvc3RvcmFnZVxcXFwvfF5cXFxcL3NkY2FyZFxcXFwvLy50ZXN0KGlucHV0KSl7XFxuICAgICAgICAgICAgaWYoL15cXFxcL3N0b3JhZ2VcXFxcL3xeXFxcXC9zZGNhcmRcXFxcLy8udGVzdChpbnB1dCkpe1xcbiAgICAgICAgICAgICAgICBpbnB1dCA9ICdmaWxlOi8vJytpbnB1dDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgbG9nKCfmraPluLjpk77mjqU6JytpbnB1dCk7XFxuICAgICAgICAgICAgbGV0IHVhID0gZ2V0SXRlbSgnaG91c2UuZmlsZV91YScpPT09J+eUteiEkSc/J01vemlsbGEvNS4wIChXaW5kb3dzIE5UIDEwLjA7IFdpbjY0OyB4NjQpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS84OC4wLjQzMjQuMTQ2IFNhZmFyaS81MzcuMzYnOidNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgOTsgTUkgNikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzg5LjAuNDM4OS45MCBNb2JpbGUgU2FmYXJpLzUzNy4zNic7XFxuICAgICAgICAgICAgbGV0IHdlYl91cmxfYXJyID0gaW5wdXQuc3BsaXQoJzsnKTtcXG4gICAgICAgICAgICBsZXQgd2ViX3VybCA9IHdlYl91cmxfYXJyWzBdO1xcbiAgICAgICAgICAgIGxldCBoZWFkZXJzID0ge1xcbiAgICAgICAgICAgICAgICAnUmVmZXJlcic6J2h0dHBzOi8vYmxvZy5jc2RuLm5ldCcsXFxuICAgICAgICAgICAgICAgICdVc2VyLUFnZW50Jzp1YSxcXG4gICAgICAgICAgICAgICAgJ0FjY2VwdCc6J2FwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdCwgKi8qOyBxPTAuMDEnLFxcbiAgICAgICAgICAgICAgICAnQWNjZXB0LUxhbmd1YWdlJzonemgtQ04nLFxcbiAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgaWYod2ViX3VybF9hcnIubGVuZ3RoPj0zJiZ3ZWJfdXJsX2FyclsyXS5sZW5ndGg+Mil7IC8v6K6+572u57yW56CBXFxuICAgICAgICAgICAgICAgIGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gJ2NoYXJzZXQ9Jyt3ZWJfdXJsX2FyclsyXS50b1VwcGVyQ2FzZSgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBsZXQgcGFyYW1zID0ge2hlYWRlcnM6aGVhZGVycyx3aXRoSGVhZGVyczpmYWxzZSxyZWRpcmVjdDpmYWxzZX07XFxuICAgICAgICAgICAgaWYod2ViX3VybF9hcnIubGVuZ3RoPj0yJiZ3ZWJfdXJsX2FyclsxXS5sZW5ndGg+Mil7IC8vIOiuvue9ruivt+axguaWueazlVxcbiAgICAgICAgICAgICAgICBwYXJhbXNbJ21ldGhvZCddID0gd2ViX3VybF9hcnJbMV0udG9VcHBlckNhc2UoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgbG9nKCflvIDlp4vojrflj5bmupDnoIEnKTtcXG4gICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAvKlxcbiAgICAgICAgICAgICAgICByZXF1ZXN0QXN5bmMod2ViX3VybCxwYXJhbXMsZnVuY3Rpb24gKGtleSxjb2RlKSB7XFxuICAgICAgICAgICAgICAgICAgICBsZXQgYmFja19jb2RlID0gY29kZTtcXG4gICAgICAgICAgICAgICAgICAgIGlmKGJhY2tfY29kZS5sZW5ndGg+MjApe1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1dFZhcignaG91c2UudXBsb2FkX2NvZGUnLGJhY2tfY29kZSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UodHJ1ZSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+a6kOeggeW3suiOt+WPlizlubbpg6jliIbmj5LlhaXliLDmlofmnKzljLrln58nXFxuICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v6ZSZ6K+v77yM5pys5qyh6I635Y+W5Yiw56m65paH5pys77yM55aR5Ly85L2g5rKh5pyJ5q2k5paH5Lu2ISc7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICAqL1xcbiAgICAgICAgICAgICAgICBsZXQgYmFja19jb2RlID0gZ2V0SXRlbSgnaG91c2UuZmlsZV91YScpPT09J+eUteiEkSc/ZmV0Y2god2ViX3VybCxwYXJhbXMpOnJlcXVlc3Qod2ViX3VybCxwYXJhbXMpO1xcbiAgICAgICAgICAgICAgICBpZihiYWNrX2NvZGUubGVuZ3RoPjIwKXtcXG4gICAgICAgICAgICAgICAgICAgIHB1dFZhcignaG91c2UudXBsb2FkX2NvZGUnLGJhY2tfY29kZSk7XFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSh0cnVlKTtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/mupDnoIHlt7Lojrflj5Ys5bm26YOo5YiG5o+S5YWl5Yiw5paH5pys5Yy65Z+fJ1xcbiAgICAgICAgICAgICAgICB9ZWxzZXtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/plJnor6/vvIzmnKzmrKHojrflj5bliLDnqbrmlofmnKzvvIznlpHkvLzkvaDmsqHmnInmraTmlofku7YhJztcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1jYXRjaCAoZSkge1xcbiAgICAgICAgICAgICAgICBsb2coZS5tZXNzYWdlKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+WPkeeUn+S6humUmeivrzpcXFxcbicrZS5tZXNzYWdlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1lbHNlIGlmKC/kuLvpopjvv6V85YWD57Sg77+lLy50ZXN0KGlucHV0KSl7XFxuICAgICAgICAgICAgbG9nKCfkuLvpopjpk77mjqUnKTtcXG4gICAgICAgICAgICBsZXQgd2ViX3VybF9hcnIgPSBpbnB1dC5zcGxpdCgn77+lJyk7XFxuICAgICAgICAgICAgbGV0IHdlYl91cmwgPSB3ZWJfdXJsX2Fyclt3ZWJfdXJsX2Fyci5sZW5ndGgtMV07XFxuICAgICAgICAgICAgbGV0IGJhY2tfY29kZSA9IHBhcnNlUGFzdGUod2ViX3VybCk7XFxuICAgICAgICAgICAgaWYoYmFja19jb2RlLmxlbmd0aD4yMCkge1xcbiAgICAgICAgICAgICAgICBwdXRWYXIoJ2hvdXNlLnVwbG9hZF9jb2RlJyxiYWNrX2NvZGUpO1xcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSh0cnVlKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+a6kOeggeW3suiOt+WPlizlubbpg6jliIbmj5LlhaXliLDmlofmnKzljLrln58nXFxuICAgICAgICAgICAgfWVsc2V7XFxuICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/plJnor6/vvIzmnKzmrKHojrflj5bov5Tlm57kuLo6XFxcXG4nK2JhY2tfY29kZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9ZWxzZXtcXG4gICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v6Z2e5rOV6ZO+5o6lOlxcXFxuJytnZXRWYXIoJ2hvdXNlLndlYl91cmwnKTtcXG4gICAgICAgIH1cXG4gICAgfSksXFxuICAgIGNvbF90eXBlOiBcXFwiaW5wdXRcXFwiXFxufSk7XFxuZC5wdXNoKHtcXG4gICAgdGl0bGU6IFxcXCLpgInmi6nmlofku7bot6/lvoRcXFwiLFxcbiAgICB1cmw6JCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoKT0+e1xcbiAgICAgICAgLypcXG4gICAgICAgIGxldCBmcCA9ICdodHRwczovL2dpdGNvZGUubmV0L3FxXzMyMzk0MzUxL2RyLy0vcmF3L21hc3Rlci9qcy9maWxlU2VsZWN0LmpzJztcXG4gICAgICAgIGxldCBmID0gcmVxdWlyZShmcCk7XFxuICAgICAgICAqL1xcbiAgICAgICAgbGV0IGZwPWNvbmZpZy5saWIuZmlsZVNlbGVjdDtcXG4gICAgICAgIGxldCBmPSQucmMoZnApO1xcbiAgICAgICAgcmV0dXJuIGYuZmlsZVNlbGVjdGlvblVyaSh7XFxuICAgICAgICAgICAgY2FsbGJhY2s6ICQudG9TdHJpbmcoKCkgPT4ge1xcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0ID0gZmluZEl0ZW0oXFxcImZpbGVQYXRoXFxcIikuZXh0cmE7XFxuICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0oXFxcImZpbGVQYXRoXFxcIiwge1xcbiAgICAgICAgICAgICAgICAgICAgZXh0cmE6IE9iamVjdC5hc3NpZ24odGFyZ2V0LCB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBQQVRIXFxuICAgICAgICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgcHV0VmFyKCdob3VzZS53ZWJfdXJsJyxQQVRIKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICAgICAgfSksXFxuICAgICAgICAgICAgb25DbGlja1R5cGU6J2NvbmZpcm0nLFxcbiAgICAgICAgICAgIGZpbGVUeXBlOiBcXFwiLmpzfC50eHR8Lmhpa2VyfC5qc29ufC5odG1sXFxcIixcXG4gICAgICAgICAgICBwYXR0ZXJuOiAwLFxcbiAgICAgICAgICAgIHJlcXVpcmVVcmw6ZnAsXFxuICAgICAgICAgICAgaW5pdGlhbFBhdGg6Z2V0UGF0aCgnaGlrZXI6Ly9maWxlcy9ydWxlcy9kekhvdXNlLycpLnNsaWNlKDcpLFxcbiAgICAgICAgICAgIG1lbW9yeTondHJ1ZScsXFxuICAgICAgICB9KTtcXG4gICAgfSksXFxuICAgIGNvbF90eXBlOiBcXFwidGV4dF9jZW50ZXJfMVxcXCIsXFxufSk7XFxuZC5wdXNoKHtcXG4gICAgdGl0bGU6J+S4iuS8oOexu+WeiycsXFxuICAgIGRlc2M6J+S4iuS8oOaWh+S7tueahOexu+WeiyzlvZPliY3kuLo6Jytjb2xvcihnZXRJdGVtKCdob3VzZS5maWxlX3R5cGUnLCfpnZnmgIHmlofku7YnKSwnI2ZmNzAwMCcpLFxcbiAgICBjb2xfdHlwZTondGV4dF8xJyxcXG4gICAgdXJsOiQoZmlsZV90eXBlX3RpdGxlLDIpLnNlbGVjdCgoKSA9PiB7XFxuICAgICAgICBzZXRJdGVtKCdob3VzZS5maWxlX3R5cGUnLGlucHV0LnJlcGxhY2UoJ/CfkYknLCcnKSk7XFxuICAgICAgICByZWZyZXNoUGFnZSh0cnVlKTtcXG4gICAgICAgIHJldHVybiAndG9hc3Q6Ly/kvaDpgInmi6nkuoY6JytpbnB1dDtcXG4gICAgfSlcXG59KTtcXG5cXG5kLnB1c2goe1xcbiAgICB0aXRsZTon5paH5Lu25a6a5L2NJyxcXG4gICAgZGVzYzon5paH5Lu25piv5ZCm5bGe5LqO6YeN5a6a5ZCRLOW9k+WJjeS4ujonK2NvbG9yKGdldEl0ZW0oJ2hvdXNlLmZpbGVfcmVkaXJlY3QnLCfmnKzlnLAnKSwnI2ZmNzAwMCcpLFxcbiAgICBjb2xfdHlwZTondGV4dF8xJyxcXG4gICAgdXJsOiQoZmlsZV9yZWRpcmVjdF90aXRsZSwyKS5zZWxlY3QoKCkgPT4ge1xcbiAgICAgICAgc2V0SXRlbSgnaG91c2UuZmlsZV9yZWRpcmVjdCcsaW5wdXQucmVwbGFjZSgn8J+RiScsJycpKTtcXG4gICAgICAgIHJlZnJlc2hQYWdlKHRydWUpO1xcbiAgICAgICAgcmV0dXJuICd0b2FzdDovL+S9oOmAieaLqeS6hjonK2lucHV0O1xcbiAgICB9KVxcbn0pO1xcblxcbmQucHVzaCh7XFxuICAgIHRpdGxlOiforr7lpIdVQScsXFxuICAgIGRlc2M6J+WPkei1t+e9kemhteivt+axguWktOagh+ivhizlvZPliY3kuLo6Jytjb2xvcihnZXRJdGVtKCdob3VzZS5maWxlX3VhJywn55S16ISRJyksJyNmZjcwMDAnKSxcXG4gICAgY29sX3R5cGU6J3RleHRfMScsXFxuICAgIHVybDokKGZpbGVfdWFfdGl0bGUsMikuc2VsZWN0KCgpID0+IHtcXG4gICAgICAgIHNldEl0ZW0oJ2hvdXNlLmZpbGVfdWEnLGlucHV0LnJlcGxhY2UoJ/CfkYknLCcnKSk7XFxuICAgICAgICByZWZyZXNoUGFnZSh0cnVlKTtcXG4gICAgICAgIHJldHVybiAndG9hc3Q6Ly/kvaDpgInmi6nkuoY6JytpbnB1dDtcXG4gICAgfSlcXG59KTtcXG5mdW5jdGlvbiBjb21wYXJlKG5hbWUpIHtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGl0ZW0pIHtcXG4gICAgICAgIHJldHVybiBpdGVtLm5hbWUgPT09IG5hbWU7XFxuICAgIH1cXG59XFxuZC5wdXNoKHtcXG4gICAgdGl0bGU6J/Cfl4TvuI/njq/looMnLFxcbiAgICBjb2xfdHlwZTonZmxleF9idXR0b24nLFxcbiAgICB1cmw6JCgpLmxhenlSdWxlKChmaWxlX3R5cGUsY29tcGFyZSk9PntcXG4gICAgICAgIGxvZygn5p+l55yL546v5aKD5Y+Y6YePJyk7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIGxldCB1cF9jb2RlID0gZ2V0VmFyKCdob3VzZS51cGxvYWRfY29kZScsJycpO1xcbiAgICAgICAgICAgIGxldCBmdHlwZSA9ICBmaWxlX3R5cGUuZmlsdGVyKGNvbXBhcmUoZ2V0SXRlbSgnaG91c2UuZmlsZV90eXBlJywn6Z2Z5oCB5paH5Lu2JykpKVswXS52YWx1ZTtcXG4gICAgICAgICAgICBsZXQgcmVkaXJlY3QgPSBnZXRJdGVtKCdob3VzZS5maWxlX3JlZGlyZWN0Jywn5pys5ZywJykhPT0n5pys5ZywJztcXG4gICAgICAgICAgICBsZXQgY29kZSA9ICFyZWRpcmVjdD91cF9jb2RlOmlucHV0O1xcbiAgICAgICAgICAgIGxldCBlbnYgPSB7XFxuICAgICAgICAgICAgICAgIHdlYl91cmw6Z2V0VmFyKCdob3VzZS53ZWJfdXJsJywnJyksXFxuICAgICAgICAgICAgICAgIGRldmljZTpnZXRJdGVtKCdob3VzZS5maWxlX3VhJywn55S16ISRJyksXFxuICAgICAgICAgICAgICAgIGZ0eXBlOmZ0eXBlfHxcXFwiXFxcIixcXG4gICAgICAgICAgICAgICAgcmVkaXJlY3Q6cmVkaXJlY3QsXFxuICAgICAgICAgICAgICAgIGNvZGU6Y29kZS5zdWJzdHJpbmcoMCw0MCl8fFxcXCJcXFwiLFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBsb2coZW52KTtcXG4gICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8vJytKU09OLnN0cmluZ2lmeShlbnYpO1xcbiAgICAgICAgICAgIC8vIGFsZXJ0KEpTT04uc3RyaW5naWZ5KGVudikpO1xcbiAgICAgICAgfWNhdGNoIChlKSB7XFxuICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovLycrZS5tZXNzYWdlO1xcbiAgICAgICAgICAgIC8vIGFsZXJ0KGUubWVzc2FnZSk7XFxuICAgICAgICB9XFxuICAgIH0sZmlsZV90eXBlLGNvbXBhcmUpXFxufSk7XFxuXFxuZC5wdXNoKHtcXG4gICAgdGl0bGU6J/Cfk4PmlZnnqIsnLFxcbiAgICBjb2xfdHlwZTonZmxleF9idXR0b24nLFxcbiAgICB1cmw6JCgpLng1UnVsZSgoKT0+e1xcbiAgICAgICAgbGV0IG1zZyA9ICfmrKLov47kvb/nlKjlvIDlj5HogIXmm7TlpJrliIbkuqvlt6XlhbdcXFxcbjEu6L6T5YWl572R5Z2A5Li65pys5Zyw5paH5Lu26Lev5b6ELGhpa2VyOi8v5oiW6ICFZmlsZTovL+W8gOWktFxcXFxuMi7ngrnlh7vnvZHlnYDovpPlhaXmoI/lkI7pnaLnmoTmjInpkq5cXFxcbjMu55yL5paH5pys6aKE6KeI5Yy65piv5ZCm5q2j56GuXFxcXG40LueCueWHu+S4iuS8oOaMiemSruaPkOS6pOWIsOS7k+W6kyc7XFxuICAgICAgICBhbGVydChtc2cpO1xcbiAgICB9KVxcbn0pO1xcblxcbmQucHVzaCh7XFxuICAgIHRpdGxlOifwn5eR77iP5riF56m6JyxcXG4gICAgY29sX3R5cGU6J2ZsZXhfYnV0dG9uJyxcXG4gICAgdXJsOiQoKS5sYXp5UnVsZSgoKT0+e1xcbiAgICAgICAgY2xlYXJWYXIoJ2hvdXNlLnVwbG9hZF9jb2RlJyk7XFxuICAgICAgICByZWZyZXNoUGFnZSh0cnVlKTtcXG4gICAgICAgIHJldHVybiAndG9hc3Q6Ly/lt7LmuIXpmaTpooTop4jljLrln5/lhoXlrrknXFxuICAgIH0pXFxufSk7XFxuXFxuZC5wdXNoKHtcXG4gICAgdGl0bGU6J/Cfk7LnpLrkvosnLFxcbiAgICBjb2xfdHlwZTonZmxleF9idXR0b24nLFxcbiAgICB1cmw6JCgpLmxhenlSdWxlKCgpPT57XFxuICAgICAgICBsZXQgZGVtb19jb2RlID0gZ2V0SXRlbSgnaG91c2UuZGVtbycsJzAnKTtcXG4gICAgICAgIGlmKGRlbW9fY29kZT09JzAnKXtcXG4gICAgICAgICAgICBwdXRWYXIoJ2hvdXNlLndlYl91cmwnLCdoaWtlcjovL2ZpbGVzL3J1bGVzL2R6SG91c2UvaHRtbC/otYTmupDnvZHkuabnrb4uaHRtbCcpO1xcbiAgICAgICAgICAgIGRlbW9fY29kZSA9IHBhcnNlSW50KGRlbW9fY29kZSkrMTtcXG4gICAgICAgICAgICBzZXRJdGVtKCdob3VzZS5kZW1vJyxkZW1vX2NvZGUrJycpO1xcbiAgICAgICAgfWVsc2V7XFxuICAgICAgICAgICAgcHV0VmFyKCdob3VzZS53ZWJfdXJsJywnZmlsZTovLy9zdG9yYWdlL2VtdWxhdGVkLzAvQW5kcm9pZC9kYXRhL2NvbS5leGFtcGxlLmhpa2Vydmlldy9maWxlcy9Eb2N1bWVudHMvcnVsZXMvZHpIb3VzZS9odG1sL+i1hOa6kOe9keS5puetvi5odG1sJyk7XFxuICAgICAgICAgICAgc2V0SXRlbSgnaG91c2UuZGVtbycsJzAnKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJlZnJlc2hQYWdlKHRydWUpO1xcbiAgICAgICAgcmV0dXJuICd0b2FzdDovL+W3suiuvue9ruekuuS+i+WcsOWdgCdcXG4gICAgfSlcXG59KTtcXG5cXG5kLnB1c2goe1xcbiAgICB0aXRsZTon8J+TpOS4iuS8oCcsXFxuICAgIGNvbF90eXBlOidmbGV4X2J1dHRvbicsXFxuICAgIHVybDokKCkubGF6eVJ1bGUoKGNhbnVwLGhvdXNlX2RhdGEscHV0X3VybCxmaWxlX3R5cGUpID0+e1xcbiAgICAgICAgZnVuY3Rpb24gY29tcGFyZShuYW1lKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGl0ZW0pIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0ubmFtZSA9PT0gbmFtZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBjb25zdCB7Z2V0Tm93Rm9ybWF0RGF0ZX09JC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvdXRpbGl5XFxcIik7XFxuICAgICAgICBsZXQgdXBfY29kZSA9IGdldFZhcignaG91c2UudXBsb2FkX2NvZGUnLCcnKTtcXG4gICAgICAgIGlmKHVwX2NvZGUubGVuZ3RoIDwgMil7XFxuICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+a6kOeggeWMuuaXoOWGheWuue+8jOivt+WFiOiuv+mXruS4gOS4qumdmeaAgemhtemdoidcXG4gICAgICAgIH1cXG4gICAgICAgIGlmKCFjYW51cCl7XFxuICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+S9oOS4jeaYr+W8gOWPkeiAhe+8jOayoeacieaPkOS6pOWIsOS7k+W6k+eahOadg+WIqSEnXFxuICAgICAgICB9XFxuICAgICAgICBsZXQgaW5wdXQgPSBnZXRWYXIoJ2hvdXNlLndlYl91cmwnLCcnKTtcXG4gICAgICAgIGxldCB3ZWJfdXJsID0gaW5wdXQuc3BsaXQoJzsnKVswXTtcXG4gICAgICAgIGxldCBmaWxlTmFtZSA9ICcnO1xcbiAgICAgICAgaWYoL15oaWtlcjp8XmZpbGU6fF5odHRwOnxeaHR0cHM6fF5cXFxcL3N0b3JhZ2VcXFxcL3xeXFxcXC9zZGNhcmRcXFxcLy8udGVzdCh3ZWJfdXJsKSl7XFxuICAgICAgICAgICAgZmlsZU5hbWUgPSB3ZWJfdXJsLnNwbGl0KCcvJylbd2ViX3VybC5zcGxpdCgnLycpLmxlbmd0aC0xXTtcXG4gICAgICAgIH1lbHNlIGlmKC/kuLvpopjvv6V85YWD57Sg77+lLy50ZXN0KGlucHV0KSl7XFxuICAgICAgICAgICAgbGV0IGJrYXJyID0gdXBfY29kZS5zcGxpdCgn77+lJyk7XFxuICAgICAgICAgICAgaWYoYmthcnIubGVuZ3RoPDMpe1xcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5LqR5Ymq6LS05p2/5YaF5a655pyJ6K+vJ1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBzd2l0Y2ggKGJrYXJyWzFdKSB7XFxuICAgICAgICAgICAgICAgIGNhc2UgJ215X2hvbWVfdGhlbWUnOlxcbiAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWUgPSB1cF9jb2RlLnNwbGl0KCfjgIwnKVsxXS5zcGxpdCgn44CNJylbMF07XFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgY2FzZSAnbXlfaG9tZV9zaW5nbGUnOlxcbiAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWUgPSB1cF9jb2RlLnNwbGl0KCfjgIwnKVsxXS5zcGxpdCgn44CNJylbMF07XFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgY2FzZSAnanNfdXJsJzpcXG4gICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lID0gdXBfY29kZS5zcGxpdCgn77+lJylbMl0uc3BsaXQoJ0AnKVswXTtcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1lbHNle1xcbiAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/plJnor6/vvIznvZHpobXpk77mjqXml6DlhoXlrrkhJztcXG4gICAgICAgIH1cXG4gICAgICAgIGxldCB1YSA9IGdldEl0ZW0oJ2hvdXNlLmZpbGVfdWEnKT09PSfnlLXohJEnPydNb3ppbGxhLzUuMCAoV2luZG93cyBOVCAxMC4wOyBXaW42NDsgeDY0KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvODguMC40MzI0LjE0NiBTYWZhcmkvNTM3LjM2JzonTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDk7IE1JIDYpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS84OS4wLjQzODkuOTAgTW9iaWxlIFNhZmFyaS81MzcuMzYnO1xcbiAgICAgICAgbGV0IGhlYWRlcnMgPSB7XFxuICAgICAgICAgICAgJ1JlZmVyZXInOidodHRwczovL2Jsb2cuY3Nkbi5uZXQnLFxcbiAgICAgICAgICAgIFxcXCJjb250ZW50LXR5cGVcXFwiOiBcXFwiYXBwbGljYXRpb24vanNvblxcXCIsXFxuICAgICAgICAgICAgJ1VzZXItQWdlbnQnOnVhLFxcbiAgICAgICAgICAgICdBY2NlcHQnOidhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHQsICovKjsgcT0wLjAxJyxcXG4gICAgICAgICAgICAnQWNjZXB0LUxhbmd1YWdlJzonemgtQ04nLFxcbiAgICAgICAgfTtcXG4gICAgICAgIGxldCB0b0NvbXBhcmUgPSAnJztcXG4gICAgICAgIGlmKGZpbGVOYW1lLmVuZHNXaXRoKCcuaHRtbCcpKXtcXG4gICAgICAgICAgICB0b0NvbXBhcmUgPSAn6Z2Z5oCB5paH5Lu2JztcXG4gICAgICAgIH1lbHNlIGlmKC/kuLvpopgvLnRlc3QoZmlsZU5hbWUpKXtcXG4gICAgICAgICAgICB0b0NvbXBhcmUgPSAn5Li76aG16YWN572uJ1xcbiAgICAgICAgfVxcbiAgICAgICAgbGV0IGZ0eXBlID0gIGZpbGVfdHlwZS5maWx0ZXIoY29tcGFyZSh0b0NvbXBhcmV8fGdldEl0ZW0oJ2hvdXNlLmZpbGVfdHlwZScsJ+mdmeaAgeaWh+S7ticpKSlbMF0udmFsdWU7XFxuICAgICAgICBsZXQgcmVkaXJlY3QgPSBnZXRJdGVtKCdob3VzZS5maWxlX3JlZGlyZWN0Jywn5pys5ZywJykhPT0n5pys5ZywJztcXG4gICAgICAgIGlmKHJlZGlyZWN0JiYhd2ViX3VybC5zdGFydHNXaXRoKCdodHRwJykpe1xcbiAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/nm7Tpk74zMDLph43lrprlkJHnvZHlnYDpk77mjqXlv4XpobtodHRw5byA5aS0JztcXG4gICAgICAgIH1cXG4gICAgICAgIGxldCBjb2RlID0gIXJlZGlyZWN0P3VwX2NvZGU6d2ViX3VybDtcXG4gICAgICAgIGxldCBkYXRhID0ge1xcXCJwYXJhbXNcXFwiOlxcbiAgICAgICAgICAgICAgICB7XFxcImRhdGFcXFwiOiB7cnVsZV9uYW1lOiBmaWxlTmFtZSwgXFxcInJ1bGVfdHlwZVxcXCI6ICfmm7TlpJrliIbkuqsnLCBcXFwidmVyc2lvblxcXCI6Z2V0Tm93Rm9ybWF0RGF0ZSgpLFxcXCJydWxlX3ZhbHVlXFxcIjogY29kZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhX3R5cGU6ZnR5cGUsIGlzX3JlZGlyZWN0OnJlZGlyZWN0LGRldmljZVVhOmdldEl0ZW0oJ2hvdXNlLmZpbGVfdWEnKSxcXG4gICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICBcXFwibmFtZVxcXCI6IGhvdXNlX2RhdGEudXNlcm5hbWUsXFxuICAgICAgICAgICAgICAgICAgICBcXFwicGFzc3dvcmRcXFwiOiBob3VzZV9kYXRhLnBhc3N3b3JkfVxcbiAgICAgICAgfTtcXG4gICAgICAgIGxldCB1cHBhcmFtcyA9IHtoZWFkZXJzOmhlYWRlcnMsYm9keTpKU09OLnN0cmluZ2lmeShkYXRhKSx3aXRoSGVhZGVyczpmYWxzZSxyZWRpcmVjdDpmYWxzZSxtZXRob2Q6J1BPU1QnfTtcXG4gICAgICAgIGxldCBiYWNrbXNnID0gZ2V0SXRlbSgnaG91c2UuZmlsZV91YScpPT09J+eUteiEkSc/ZmV0Y2gocHV0X3VybCx1cHBhcmFtcyk6cmVxdWVzdChwdXRfdXJsLHVwcGFyYW1zKTtcXG4gICAgICAgIHRyeXtcXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gSlNPTi5wYXJzZShiYWNrbXNnKS5yZXN1bHQ7XFxuICAgICAgICAgICAgbGV0IGRldGFpbCA9IHJlc3VsdC5kZXRhaWw7XFxuICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovLycrZGV0YWlsO1xcbiAgICAgICAgfWNhdGNoIChlKSB7XFxuICAgICAgICAgICAgbG9nKGUubWVzc2FnZSk7XFxuICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+WPkeeUn+S6humUmeivr1xcXFxuJytlLm1lc3NhZ2U7XFxuICAgICAgICB9XFxuICAgIH0sY2FudXAsaG91c2VfZGF0YSxwdXRfdXJsLGZpbGVfdHlwZSlcXG59KTtcXG5cXG5kLnB1c2goe1xcbiAgICB0aXRsZTon6ZW/5paH5pys6aKE6KeI5Yy65Z+fJyxcXG4gICAgY29sX3R5cGU6J3RleHRfMScsXFxuICAgIHVybDonaGlrZXI6Ly9lbXB0eScsXFxuICAgIGV4dHJhOiB7dGV4dFNpemU6IDExLGxpbmVWaXNpYmxlOmZhbHNlfVxcbn0pO1xcblxcbmQucHVzaCh7XFxuICAgIHRpdGxlOmdldFZhcignaG91c2UudXBsb2FkX2NvZGUnLCcnKS5zdWJzdHJpbmcoMCwxMDI0MCksXFxuICAgIGNvbF90eXBlOidsb25nX3RleHQnLFxcbiAgICBleHRyYToge3RleHRTaXplOiAxMX1cXG59KTtcXG5zZXRQYWdlVGl0bGUoXFxcIuabtOWkmuWIhuS6q1xcXCIpO1xcbnNldFJlc3VsdChkKTtcIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIui9u+WQiOmbhueUn+aIkOaOpeWPo1wiLFwicGF0aFwiOlwiZ2VuQXBpXCIsXCJydWxlXCI6XCJqczpcXG5mdW5jdGlvbiBnZW5SdWxlKG5hbWUsdXJsLGljb24pe1xcbiAgICBpY29uPWljb258fCdodHRwczovL3ozLmF4MXguY29tLzIwMjEvMTEvMTYvSVdKaHhmLnBuZyc7XFxuICAgIGNvbnN0IHtnZXROb3dGb3JtYXREYXRlLGFwaSxnZXRBcGl9PSQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL3V0aWxpeT9ydWxlPemBk+mVv+S7k+W6k1Byb1xcXCIpO1xcbiAgICBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2VBbGwgPSBmdW5jdGlvbihvbGQsbmV3X3N0cil7XFxuICAgICAgICByZXR1cm4gdGhpcy5zcGxpdChvbGQpLmpvaW4obmV3X3N0cik7XFxuICAgIH07XFxuICAgIGxldCBtdWJhbiA9IGdldEFwaSgnaW1wb3J0VXJsJykrXFxcIjE2OTBcXFwiO1xcbiAgICBsZXQgbXViYW5fd29yZD17bmFtZTpcXFwiQOi9u+WQiOmbhlxcXCIsdXJsOlxcXCJA5Zyw5Z2AXFxcIix2ZXI6XFxcIkDniYjmnKxcXFwiLGljb246XFxcIkDlm77moIdcXFwifTtcXG4gICAgbGV0IG11YmFuX2NvZGUgPSBmZXRjaChtdWJhbik7XFxuICAgIG11YmFuX2NvZGU9bXViYW5fY29kZS5yZXBsYWNlQWxsKG11YmFuX3dvcmQubmFtZSxuYW1lKS5yZXBsYWNlQWxsKG11YmFuX3dvcmQudmVyLGdldE5vd0Zvcm1hdERhdGUoKSkucmVwbGFjZUFsbChtdWJhbl93b3JkLnVybCx1cmwpLnJlcGxhY2VBbGwobXViYW5fd29yZC5pY29uLGljb24pO1xcbiAgICBsZXQgaW1wb3J0X2NvZGU9XFxcIua1t+mYlOinhueVjOinhOWImeWIhuS6q++8jOW9k+WJjeWIhuS6q+eahOaYr++8muWwj+eoi+W6j++8jOaXoOagueagke+8jOiKseato+a4he+8jOS4jeaWreiNpOiFpeS4jeaIkua3q++/pWhvbWVfcnVsZV92Mu+/pWJhc2U2NDovL0BcXFwiK25hbWUrXFxcIkBcXFwiK2Jhc2U2NEVuY29kZShtdWJhbl9jb2RlKTtcXG4gICAgdmFyIHBhc3RlcyA9IGdldFBhc3RlcygpO1xcbiAgICB2YXIgdXJsID0gc2hhcmVQYXN0ZShpbXBvcnRfY29kZSxwYXN0ZXMuc2xpY2UoLTEpWzBdKTtcXG4gICAgbGV0IGltcG9ydF9ydWxlPSB1cmwrXFxcIlxcXFxuXFxcXG7lsI/nqIvluo/vvJpcXFwiK25hbWU7XFxuICAgIHJldHVybiBpbXBvcnRfcnVsZTtcXG59XFxuJC5leHBvcnRzLmdlblJ1bGU9Z2VuUnVsZTtcIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuWFqOWxgOino+aekOWFjeWXhVwiLFwicGF0aFwiOlwiZ2xvYmFsUGFyc2VcIixcInJ1bGVcIjpcImpzOlxcbiAgICBmdW5jdGlvbiBnZXRIZWFkZXJzKHBsYXlVcmwpe1xcbiAgICAgICAgbGV0IGhlYWRlcnMgPSB7fTtcXG4gICAgICAgIGxldCByZWZlcj1wbGF5VXJsLnNwbGl0KFxcXCIvL1xcXCIpWzBdK1xcXCIvL1xcXCIrcGxheVVybC5zcGxpdChcXFwiLy9cXFwiKVsxXS5zcGxpdChcXFwiL1xcXCIpWzBdO1xcbiAgICAgICAgaWYoL2xlY2xvdWRcXFxcLmNvbXxiaWxpdmlkZW9cXFxcLmNvbS8udGVzdChwbGF5VXJsKSl7XFxuICAgICAgICAgICAgaGVhZGVycyA9IHtcXFwiUmVmZXJlclxcXCI6ICdodHRwczovL3d3dy5iaWxpYmlsaS5jb20vJyxcXFwiVXNlci1BZ2VudFxcXCI6XFxcIk1vemlsbGEvNS4wXFxcIn1cXG4gICAgICAgIH1lbHNlIGlmKC9tZ3R2XFxcXC5jb20vLnRlc3QocGxheVVybCkpe1xcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XFxcIlJlZmVyZXJcXFwiOiByZWZlcixcXFwiVXNlci1BZ2VudFxcXCI6XFxcIk1vemlsbGEvNS4wXFxcIn1cXG4gICAgICAgIH1lbHNlIGlmKC9peGlndWFcXFxcLmNvbS8udGVzdChwbGF5VXJsKSl7XFxuICAgICAgICAgICAgaGVhZGVycyA9IHtcXFwiUmVmZXJlclxcXCI6ICdodHRwczovL3d3dy5peGlndWEuY29tLycsXFxcIlVzZXItQWdlbnRcXFwiOlxcXCJNb3ppbGxhLzUuMFxcXCJ9XFxuICAgICAgICB9ZWxzZXtcXG4gICAgICAgICAgICAvLyBoZWFkZXJzID0ge1xcXCJSZWZlcmVyXFxcIjogcmVmZXIsJ1VzZXItQWdlbnQnOidEYXJ0LzIuMTMgKGRhcnQ6aW8pJ31cXG4gICAgICAgICAgICAvLyBoZWFkZXJzID0ge1xcXCJSZWZlcmVyXFxcIjogcmVmZXIsJ1VzZXItQWdlbnQnOk1PQklMRV9VQX07XFxuICAgICAgICAgICAgaGVhZGVycyA9IHsnVXNlci1BZ2VudCc6TU9CSUxFX1VBfTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBoZWFkZXJzXFxuICAgIH1cXG5mdW5jdGlvbiBpc1BpYyhzdHIpe1xcbiAgICByZXR1cm4gL1xcXFwuKGdpZnxqcGd8anBlZ3xwbmd8R0lGfEpQR3xQTkcpJC8udGVzdChzdHIpO1xcbn1cXG5mdW5jdGlvbiBpc1ZpZGVvKHBsYXlVcmwscmVjaGFuZ2Upe1xcbiAgICAvL+azqOaEjy5waHDkuI3lj6/ku6XooqvmjpLpmaTlkKbliJnono3lhbTop6PmnpDkuI3kuoYgfC5waHAkXFxuICAgIC8v5aaC5p6c5piv5pKt5pS+5Zyw5Z2A5bCx55u05o6l6L+U5Zue5Zyw5Z2A5Yqg5LiKVUHvvIzkuI3mmK/nmoTor53lsLHov5Tlm55mYWxzZVxcbiAgICAvLyBsZXQgdDEgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcXG4gICAgbGV0IGNhY2hlUmVneCA9IG5ldyBSZWdFeHAoJ2ZpbGU6Ly8vc3RvcmFnZS9lbXVsYXRlZC8oLio/KVxcXFxcXFxcLm0zdTh8aGlrZXI6Ly9maWxlcy8oLio/KVxcXFxcXFxcLm0zdTgnKTtcXG4gICAgaWYoY2FjaGVSZWd4LnRlc3QocGxheVVybCkpe1xcbiAgICAgICAgcmV0dXJuIHBsYXlVcmxcXG4gICAgfVxcbiAgICBmdW5jdGlvbiBnZXRIb3N0KHVybCl7XFxuICAgICAgICAvLyBmYmHnmoRwYXJzZUxhennlpKrmhaLkuobljYPkuIfliKvnlKhcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgcmV0dXJuIHVybC5tYXRjaCgvXmh0dHAocyk/OlxcXFwvXFxcXC8oLio/KVxcXFwvLylbMF0uc2xpY2UoMCwtMSk7XFxuICAgICAgICB9Y2F0Y2ggKGUpIHtcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcXG4gICAgICAgIH1cXG4gICAgICAgIC8qXFxuICAgICAgICBpZih0eXBlb2YobG9nKT09PSd1bmRlZmluZWQnKXtcXG4gICAgICAgICAgICByZXR1cm4gIGZiYS5wYXJzZUxhenlSdWxlKCQkJCgpLmxhenlSdWxlKCh1cmwpPT57XFxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRIb21lKHVybClcXG4gICAgICAgICAgICB9LHVybCkpXFxuICAgICAgICB9ZWxzZSB7XFxuICAgICAgICAgICAgcmV0dXJuIGdldEhvbWUodXJsKVxcbiAgICAgICAgfVxcbiAgICAgICAgKi9cXG4gICAgfVxcbiAgICBsZXQgcFVybD1wbGF5VXJsLnNwbGl0KFxcXCI7XFxcIilbMF07Ly/ojrflj5bmiqDmjonmtbfpmJR1YeetieWPguaVsOeahOe9kemhteaSreaUvumTvuaOpVxcbiAgICBsZXQgaG9zdCA9IGdldEhvc3QocFVybCk7IC8vIOiOt+WPluWfn+WQjVxcbiAgICBpZighaG9zdCl7Ly/liKTmlq3ml6Dln5/lkI3nm7TmjqXkuI3mmK/op4bpopFcXG4gICAgICAgIHJldHVybiBmYWxzZVxcbiAgICB9XFxuICAgIGZ1bmN0aW9uIHByaW50KGRhdGEpe1xcbiAgICAgICAgaWYodHlwZW9mKGxvZyk9PT0ndW5kZWZpbmVkJyl7XFxuICAgICAgICAgICAgcmV0dXJuICBmYmEubG9nKGRhdGEpXFxuICAgICAgICB9ZWxzZSB7XFxuICAgICAgICAgICAgcmV0dXJuIGxvZyhkYXRhKVxcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIHJlY2hhbmdlPXR5cGVvZihyZWNoYW5nZSk9PT1cXFwiZnVuY3Rpb25cXFwiP3JlY2hhbmdlOmZ1bmN0aW9uKHBsYXlVcmwpe3JldHVybiBwbGF5VXJsfTtcXG4gICAgbGV0IGV4Y2VwdFdvcmRzID0gJy5qcyR8LmNzcyR8LnRzJHwuaHRtbCR8Lmh0bSR8LmdpZiR8LmpwZyR8LmpwZWckfC5wbmckfC5pY28kfC5zdmckfC50eHQkJy5zcGxpdCgnfCcpLm1hcChpdD0+J1xcXFxcXFxcJytpdCkuam9pbignfCcpO1xcbiAgICB2YXIgZXhjZXB0S2V5cyA9IG5ldyBSZWdFeHAoZXhjZXB0V29yZHMpO1xcbiAgICBsZXQgZXhjZXB0V29yZHMxID0gJ3JlZmVyZXI9fHVybD0nLnNwbGl0KCd8JykubWFwKGl0PT5pdCkuam9pbignfCcpO1xcbiAgICB2YXIgZXhjZXB0S2V5czEgPSBuZXcgUmVnRXhwKGV4Y2VwdFdvcmRzMSk7XFxuICAgIGxldCByZXBsYWNlV29yZHMgPSAncGxheW0zdTh8bTN1OFxcXFwudHYnLnNwbGl0KCd8JykubWFwKGl0PT5pdCkuam9pbignfCcpO1xcbiAgICBsZXQgcmVwbGFjZUtleXMgPSBuZXcgUmVnRXhwKHJlcGxhY2VXb3JkcywnZycpO1xcbiAgICBsZXQgdmlkZW9Xb3JkcyA9IFxcXCIvdmlkZW8vdG9zfC5tcDQkfC5tM3U4JHwuZmx2JHwuYXZpJHwuM2dwJHwubXBlZyR8LndtdiR8Lm1vdiR8cm12YnwuZGF0JHwubXAzJHwubTRhJHxxcUJGZG93bmxvYWR8bWltZT12aWRlbyUyRnxtaW1lX3R5cGU9dmlkZW9ffHR5cGU9bTN1OHxwdD1tM3U4XFxcIi5zcGxpdCgnfCcpLm1hcCgoaXQpPT57XFxuICAgICAgICAvL3R5cGU9bXA0XFxuICAgICAgICBpZihpdC5zdGFydHNXaXRoKFxcXCIuXFxcIikpe1xcbiAgICAgICAgICAgIHJldHVybiAnXFxcXFxcXFwnK2l0XFxuICAgICAgICB9ZWxzZXtcXG4gICAgICAgICAgICByZXR1cm4gaXRcXG4gICAgICAgIH1cXG4gICAgfSkuam9pbihcXFwifFxcXCIpO1xcbiAgICBsZXQgdmlkZW9LZXlzID0gbmV3IFJlZ0V4cCh2aWRlb1dvcmRzKTtcXG4gICAgbGV0IHJVcmwgPSBwVXJsLnJlcGxhY2UoaG9zdCwnJyk7Ly/ojrflj5bpmaTlvIDln5/lkI3nmoTliankvZnpk77mjqVcXG4gICAgbGV0IHBVcmwyPXBVcmwuc3BsaXQoXFxcIiZcXFwiKVswXS5zcGxpdChcXFwiP1xcXCIpWzBdOy8v6I635Y+W5LiN5bim5Y+C5pWw55qE572R6aG16ZO+5o6lXFxuICAgIGxldCBydXJsMiA9IHBVcmwyLnJlcGxhY2UoaG9zdCwnJyk7Ly/ojrflj5bpmaTlvIDln5/lkI3nmoTliankvZnkuI3luKblj4LmlbDpk77mjqVcXG4gICAgbGV0IGhhc0tleSA9IHZpZGVvS2V5cy50ZXN0KHJVcmwpfHx2aWRlb0tleXMudGVzdChydXJsMik7XFxuICAgIGxldCBwYXJVcmwgPSBwVXJsLnJlcGxhY2UocFVybC5zcGxpdChcXFwiP1xcXCIpWzBdLCcnKTsgLy8g5YiG5Ymy6Zeu5Y+35ZCO5Ymp5L2Z5Y+C5pWw55qE5a6M5pW06ZO+5o6lXFxuICAgIGxldCBleGNLZXkgPSBleGNlcHRLZXlzMS50ZXN0KHBhclVybCk7XFxuICAgIGlmKHJVcmwuc3BsaXQoJz8nKS5sZW5ndGg+Mil7XFxuICAgICAgICBsZXQgclVybDM9clVybC5zcGxpdChcXFwiP1xcXCIpWzFdOy8v6I635Y+WP+WIhuWJsuWQjueahOesrOS4gOautVxcbiAgICAgICAgaGFzS2V5ID0gaGFzS2V5fHx2aWRlb0tleXMudGVzdChyVXJsMyk7XFxuICAgIH1cXG4gICAgaWYoaGFzS2V5JiYhZXhjS2V5KXtcXG4gICAgICAgIGxldCB0aXBzID0gJ+ajgOa1i+WIsOeWkeS8vOWkmuWqkuS9k+eahOWcsOWdgDonO1xcbiAgICAgICAgcHJpbnQoXFxcImpz5LitXFxcIit0aXBzK3BVcmwpO1xcbiAgICAgICAgcHJpbnQoXFxcIuWIhuWJsumXruWPt+WQjjpcXFwiK3BhclVybCk7XFxuICAgIH1cXG4gICAgLy8gbG9nKCcxOicrKHZpZGVvS2V5cy50ZXN0KHBVcmwpfHx2aWRlb0tleXMudGVzdChwVXJsMil8fHZpZGVvS2V5cy50ZXN0KHBVcmwucmVwbGFjZShyZXBsYWNlS2V5cyxcXFwiXFxcIikuc3BsaXQoXFxcIiZcXFwiKVswXS5zcGxpdChcXFwiP1xcXCIpWzBdKSkpO1xcbiAgICAvLyBsb2coJzI6JyshZXhjZXB0S2V5cy50ZXN0KHBVcmwuc3BsaXQoXFxcIj9cXFwiKVswXS5zcGxpdCgnJicpWzBdKSk7XFxuICAgIC8vIGxvZygnMzonKyFleGNlcHRLZXlzMS50ZXN0KHBVcmwucmVwbGFjZShwVXJsLnNwbGl0KFxcXCI/XFxcIilbMF0sJycpKSk7XFxuICAgIGlmICgoaGFzS2V5fHx2aWRlb0tleXMudGVzdChyVXJsLnJlcGxhY2UocmVwbGFjZUtleXMsXFxcIlxcXCIpLnNwbGl0KFxcXCImXFxcIilbMF0uc3BsaXQoXFxcIj9cXFwiKVswXSkgKSYmICFleGNlcHRLZXlzLnRlc3QocFVybDIpJiYhZXhjZXB0S2V5czEudGVzdChwVXJsMikpIHtcXG4gICAgICAgIGlmKCEoL1VzZXItQWdlbnR8UmVmZXJlckAvLnRlc3QocGxheVVybCkpKXtcXG4gICAgICAgICAgICBpZigvbGVjbG91ZFxcXFwuY29tfGJpbGl2aWRlby8udGVzdChwbGF5VXJsKSl7XFxuICAgICAgICAgICAgICAgIHBsYXlVcmwrPVxcXCI7e1JlZmVyZXJAaHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tLyYmVXNlci1BZ2VudEBNb3ppbGxhLzUuMH1cXFwiO1xcbiAgICAgICAgICAgIH1lbHNlIGlmKC9peGlndWFcXFxcLmNvbS8udGVzdChwbGF5VXJsKSl7XFxuICAgICAgICAgICAgICAgIHBsYXlVcmwrPVxcXCIjaXN2aWRlbz10cnVlIzt7UmVmZXJlckBodHRwczovL3d3dy5peGlndWEuY29tLyYmVXNlci1BZ2VudEBNb3ppbGxhLzUuMH1cXFwiO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIGlmKC9tZ3R2XFxcXC5jb218Ynl0ZWFtb25lLy50ZXN0KHBsYXlVcmwpKXtcXG4gICAgICAgICAgICAgICAgcGxheVVybCs9XFxcIjt7VXNlci1BZ2VudEBNb3ppbGxhLzUuMH1cXFwiO1xcbiAgICAgICAgICAgIH1lbHNlIGlmKC9wdHdvXFxcXC53a2ZpbGVcXFxcLmNvbS8udGVzdChwbGF5VXJsKSYmL3VybD0vLnRlc3QocGxheVVybCkpe1xcbiAgICAgICAgICAgICAgICBwbGF5VXJsPXBsYXlVcmwuc3BsaXQoXFxcInVybD1cXFwiKVsxXStcXFwiO3tSZWZlcmVyQGh0dHBzOi8vZmFudHVhbi50dn1cXFwiXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIC8vIOWkhOeQhuWkp+W4iOWFhOS5i+exu+eahGFwcFxcbiAgICAgICAgICAgIC8vIGVsc2V7XFxuICAgICAgICAgICAgLy8gICAgIHBsYXlVcmwrPVxcXCI7e1VzZXItQWdlbnRATW96aWxsYS81LjB9XFxcIjtcXG4gICAgICAgICAgICAvLyB9XFxuICAgICAgICB9XFxuICAgICAgICBwbGF5VXJsPXJlY2hhbmdlKHBsYXlVcmwpO1xcbiAgICAgICAgaWYoIS8jaXNWaWRlbz10cnVlIy8udGVzdChwbGF5VXJsKSl7XFxuICAgICAgICAgICAgcGxheVVybCs9XFxcIiNpc1ZpZGVvPXRydWUjXFxcIjtcXG4gICAgICAgIH1cXG4gICAgICAgIC8vIGxldCB0MiA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xcbiAgICAgICAgLy8gcHJpbnQoJ+WIpOaWrWlzVmlkZW/ogJfml7Y6JysodDItdDEpKTtcXG4gICAgICAgIHJldHVybiBwbGF5VXJsO1xcbiAgICB9ZWxzZXtcXG4gICAgICAgIC8vIGxldCB0MiA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xcbiAgICAgICAgLy8gcHJpbnQoJ+WIpOaWrWlzVmlkZW/ogJfml7Y6JysodDItdDEpKTtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbn1cXG5mdW5jdGlvbiBjb21QYXJzZShwYXJTdHIsZWosb25seWJhY2ssaHRtbCl7XFxuICAgIC8v5YiX6KGo77yM5qCH6aKY77yM5Zu+54mH77yM5o+P6L+w77yM6ZO+5o6l77yM5YaF5a65XFxuICAgIGVqID0gZWp8fGZhbHNlOy8v5pyJ5LqM57qnXFxuICAgIG9ubHliYWNrPW9ubHliYWNrfHxmYWxzZTsvL+WPqui/lOWbnuaVsOaNrlxcbiAgICBodG1sID0gaHRtbHx8Z2V0UmVzQ29kZSgpO1xcbiAgICBodG1sID0gdHlwZW9mKGh0bWwpPT09J3N0cmluZyc/aHRtbDpodG1sLmh0bWw7XFxuICAgIHJldHVybiAkLnRvU3RyaW5nKChwYXJTdHIsZWosb25seWJhY2ssaHRtbCxpc1BpYyk9PntcXG4gICAgICAgIGxldCB0PXBhclN0ci5zcGxpdChcXFwiO1xcXCIpO1xcbiAgICAgICAgbGV0IGQ9W107XFxuICAgICAgICAvLyBsZXQgbGlzdD1wZGZhKGdldFJlc0NvZGUoKSx0WzBdKTtcXG4gICAgICAgIGxldCBsaXN0PXBkZmEoaHRtbCx0WzBdKTtcXG4gICAgICAgIGxldCBsYXp5ID0gJCgnJykubGF6eVJ1bGUoKCk9PntcXG4gICAgICAgICAgICBjb25zdCB7bGF6eVBhcnNlfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2dsb2JhbFBhcnNlP3J1bGU96YGT6ZW/5LuT5bqTUHJvJyk7XFxuICAgICAgICAgICAgcmV0dXJuIGxhenlQYXJzZShpbnB1dClcXG4gICAgICAgIH0pO1xcbiAgICAgICAgZm9yKGxldCBpIGluIGxpc3Qpe1xcbiAgICAgICAgICAgIGxldCBfcGljID0gdFsyXT9wZChsaXN0W2ldLHRbMl0pOicnO1xcbiAgICAgICAgICAgIGlmKGlzUGljKF9waWMpJiYhL0BSZWZlcmVyPS8udGVzdChfcGljKSl7XFxuICAgICAgICAgICAgICAgIF9waWMrPSdAUmVmZXJlcj0nXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGxldCBpdD17XFxuICAgICAgICAgICAgICAgIHRpdGxlOnBkZmgobGlzdFtpXSx0WzFdKSxcXG4gICAgICAgICAgICAgICAgcGljX3VybDpfcGljLFxcbiAgICAgICAgICAgICAgICBkZXNjOnBkZmgobGlzdFtpXSx0WzNdKSxcXG4gICAgICAgICAgICAgICAgdXJsOmVqP3BkKGxpc3RbaV0sdFs0XSk6cGQobGlzdFtpXSx0WzRdKStsYXp5XFxuICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICBpZih0Lmxlbmd0aD41KXsvL+WGheWuue+8jOeUqOS6juaQnOe0olxcbiAgICAgICAgICAgICAgICBpdC5jb250ZW50PXBkZmgobGlzdFtpXSx0WzVdKVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBkLnB1c2goaXQpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYob25seWJhY2spe1xcbiAgICAgICAgICAgIHJldHVybiBkXFxuICAgICAgICB9ZWxzZXtcXG4gICAgICAgICAgICBzZXRSZXN1bHQoZClcXG4gICAgICAgIH1cXG4gICAgfSxwYXJTdHIsZWosb25seWJhY2ssaHRtbCxpc1BpYylcXG59XFxuXFxuZnVuY3Rpb24gaXNCYWRWaWRlbyh2aWRlb1VybCkgey8v5piv5Z2P55qE6KeG6aKRXFxuICAgIGxldCBkbVBhdGggPSAnaGlrZXI6Ly9maWxlcy9jYWNoZS9kaWFvbWFvLnR4dCc7Ly/lkIrmr5vmqKHlvI/ov4fmu6Tmlofku7bot6/lvoRcXG4gICAgbGV0IGRtVXJscztcXG4gICAgdHJ5IHtcXG4gICAgICAgIGRtVXJscyA9IHJlcXVlc3QoZG1QYXRoKS50cmltKCkuc3BsaXQoJ1xcXFxuJykuZmlsdGVyKGl0ID0+IGl0ICYmICFpdC5zdGFydHNXaXRoKCcvLycpKTtcXG4gICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgZG1VcmxzID0gW107XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gaGFzRG0odmlkZW9VcmwsIGRtVXJscykgey8v5pKt5pS+5Zyw5Z2A5piv5ZCm5Li65ZCK5q+b6KeG6aKRXFxuICAgICAgICBpZiAoZG1VcmxzLmxlbmd0aCA8IDEpIHtcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcXG4gICAgICAgIH1cXG4gICAgICAgIGZ1bmN0aW9uIHByaW50KHN0cil7XFxuICAgICAgICAgICAgaWYodHlwZW9mKGxvZykhPT0ndW5kZWZpbmVkJyl7XFxuICAgICAgICAgICAgICAgIGxvZyhzdHIpO1xcbiAgICAgICAgICAgIH1lbHNle1xcbiAgICAgICAgICAgICAgICBmYmEubG9nKHN0cik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgZm9yIChsZXQgZG1Vcmwgb2YgZG1VcmxzKSB7XFxuICAgICAgICAgICAgaWYgKChuZXcgUmVnRXhwKGRtVXJsKSkudGVzdCh2aWRlb1VybCkpIHsvL+aSreaUvuWcsOWdgOWMheWQq+WQiuavm+agh+W/l+eahOWcsOWdgFxcbiAgICAgICAgICAgICAgICBwcmludCgn5ZCK5q+b6KeG6aKRLOiHquWKqOi/h+a7pDonK3ZpZGVvVXJsKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBwcmludCgn6Z2e5ZCK5q+b6KeG6aKRLOWPr+aSreaUvjonK3ZpZGVvVXJsKTtcXG4gICAgICAgIHJldHVybiBmYWxzZVxcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIGlzRG0ocmV0KSB7XFxuICAgICAgICBpZiAoIXJldCkge1xcbiAgICAgICAgICAgIHJldHVybiB0cnVlXFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gaGFzRG0ocmV0LnNwbGl0KCcjJylbMF0uc3BsaXQoJzsnKVswXSwgZG1VcmxzKVxcbiAgICB9XFxuICAgIHJldHVybiBpc0RtKHZpZGVvVXJsKVxcbn1cXG5cXG5mdW5jdGlvbiBsYXp5UGFyc2UocGxheVVybCxtcyx0bSxyZWNoYW5nZSl7XFxuICAgIC8vIGxvZygn6LCD55So5LuT5bqT5YWN5ZeF5o6i5Lyg5Y+C6LaF5pe25Li6OicrbXMpO1xcbiAgICB0bSA9IHBhcnNlSW50KHRtKXx8NTAwMDtcXG4gICAgY29uc3Qge2lzVmlkZW8sZ2V0SGVhZGVycyxpc0JhZFZpZGVvfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2dsb2JhbFBhcnNlP3J1bGU96YGT6ZW/5LuT5bqTUHJvJyk7XFxuICAgIGxldCByZWFsVXJsID0gaXNWaWRlbyhwbGF5VXJsLHJlY2hhbmdlKTtcXG4gICAgLy9sb2cocmVhbFVybCk7XFxuICAgIGlmKHR5cGVvZihyZWFsVXJsKT09J3N0cmluZycpey8vYm9vbOWAvOWwseaYr+Wksei0pVxcbiAgICAgICAgdHJ5e1xcbiAgICAgICAgICAgIGxldCBydXJsPXJlYWxVcmwuc3BsaXQoXFxcIjtcXFwiKVswXS5zcGxpdChcXFwiI1xcXCIpWzBdO1xcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHJlcXVlc3QocnVybCx7dGltZW91dDp0bX0pKS51cmxcXG4gICAgICAgIH1jYXRjaChlKXtcXG4gICAgICAgICAgICByZXR1cm4gcmVhbFVybFxcbiAgICAgICAgfVxcbiAgICAgICAgLy9yZXR1cm4gcmVhbFVybFxcbiAgICB9XFxuXFxuICAgIC8vbG9nKFxcXCLorr/pl67otoXml7Y6XFxcIit0bSk7XFxuICAgIGxvZyhcXFwi5bCd6K+V6YGT6ZW/5LuT5bqTeDXlhY3ll4U6XFxcIitwbGF5VXJsKTtcXG4gICAgY2xlYXJWYXIoXFxcIl94NWp4VXJsXFxcIik7XFxuICAgIGxldCBiYWQ9JChcXFwi572R57uc5LiN5L2z5oiW6ICF55aR5Ly85a+55pa5572R56uZ5oyC5LqG77yM5L2g6KaB5p+l55yL5YW2572R6aG15ZCX77yfXFxcIikuY29uZmlybSgocGxheVVybCk9PntcXG4gICAgICAgIGxvZyhcXFwi572R56uZ55yL6LW35p2l5oyC5LqGOlxcXCIrcGxheVVybCk7XFxuICAgICAgICByZXR1cm4gcGxheVVybFxcbiAgICB9LHBsYXlVcmwpO1xcbiAgICB0cnl7XFxuICAgICAgICB2YXIgYmFjaz1yZXF1ZXN0KHBsYXlVcmwse2hlYWRlcnM6IGdldEhlYWRlcnMocGxheVVybCksdGltZW91dDp0bX0pO1xcbiAgICAgICAgLy92YXIgYmFjaz1mZXRjaChwbGF5VXJsLHtoZWFkZXJzOiB7J1VzZXItQWdlbnQnOiBQQ19VQX19KTtcXG4gICAgICAgIGlmKCFiYWNrKXtcXG4gICAgICAgICAgICBsb2coXFxcIue9keermVxcXCIrcGxheVVybCtcXFwi56Gu5a6e5ZWl5Lmf5rKh6L+U5ZueXFxcIik7XFxuICAgICAgICAgICAgcmV0dXJuIGJhZFxcbiAgICAgICAgfWVsc2UgaWYoLyNFWFRJTkYvLnRlc3QoYmFjaykpe1xcbiAgICAgICAgICAgIC8vbGV0IGxjYWNoZT1cXFwiL3N0b3JhZ2UvZW11bGF0ZWQvMC9BbmRyb2lkL2RhdGEvY29tLmV4YW1wbGUuaGlrZXJ2aWV3L2ZpbGVzL0RvY3VtZW50cy9jYWNoZS92aWRlby5tM3U4XFxcIjtcXG4gICAgICAgICAgICAvL3dyaXRlRmlsZShsY2FjaGUsYmFjayk7XFxuICAgICAgICAgICAgLy9yZXR1cm4gbGNhY2hlK1xcXCIjI1xcXCIrcGxheVVybCtcXFwiI2lzVmlkZW89dHJ1ZSNcXFwiXFxuICAgICAgICAgICAgcGxheVVybD1jYWNoZU0zdTgocGxheVVybCk7XFxuICAgICAgICAgICAgcmV0dXJuIHBsYXlVcmxcXG4gICAgICAgIH1lbHNlIGlmKCghL+inpuWPkeS6humYsuebl+mTvnzmnKrmjojmnYN85o6l5Y+j6Ziy55uXLy50ZXN0KGJhY2spKSYmKCEvaHR0cHx1cmwvLnRlc3QoYmFjaykpJiYoIS9tc2d8Y29kZXxodG1sLy50ZXN0KGJhY2spKSl7XFxuICAgICAgICAgICAgbG9nKGJhY2spO1xcbiAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/nlpHkvLzlr7nmlrnmlbDmja7liqDlr4bkuobvvIzlhbfkvZPmlbDmja7nnIvml6Xlv5cnXFxuICAgICAgICB9XFxuICAgIH1jYXRjaChlKXtcXG4gICAgICAgIGxvZyhlLm1lc3NhZ2UpO1xcbiAgICAgICAgcmV0dXJuIGJhZFxcbiAgICB9XFxuICAgIHRyeSB7XFxuICAgICAgICBiYWNrPUpTT04ucGFyc2UoYmFjayk7XFxuICAgICAgICBsZXQgcmVhbFVybD1iYWNrLnVybDtcXG4gICAgICAgIGlmKHR5cGVvZihyZWFsVXJsKT09XFxcInVuZGVmaW5lZFxcXCJ8fCFyZWFsVXJsKXtcXG4gICAgICAgICAgICBsb2coYmFjayk7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+mBk+mVv+S7k+W6k+ino+aekOWksei0pe+8gei/lOWbnuaSreaUvuWcsOWdgOS4uuepulxcXCJcXG4gICAgICAgIH0gZWxzZSBpZih0eXBlb2YoaXNWaWRlbyhyZWFsVXJsLHJlY2hhbmdlKSk9PSdzdHJpbmcnKXtcXG4gICAgICAgICAgICByZXR1cm4gaXNWaWRlbyhyZWFsVXJsLHJlY2hhbmdlKTtcXG4gICAgICAgIH1lbHNle1xcbiAgICAgICAgICAgIHJldHVybiByZWFsVXJsK1xcXCIjaXNWaWRlbz10cnVlI1xcXCI7XFxuICAgICAgICB9XFxuICAgICAgICAvL2Vsc2V7XFxuICAgICAgICAvL3JlYWxVcmwrPVxcXCI7e1VzZXItQWdlbnRATW96aWxsYS81LjB9XFxcIjtcXG4gICAgICAgIC8vIH1cXG4gICAgfWNhdGNoIChlKSB7XFxuICAgICAgICBsb2coXFxcIuajgOa1i+WIsOino+aekOWPo+mdnmpzb27plJnor686XFxcIitlLm1lc3NhZ2UrJyzlvIDlp4t4NeWFjeWXheaOoicpO1xcbiAgICAgICAgLy8gcmVxdWlyZSgnaHR0cHM6Ly9oamRobnguY29kaW5nLm5ldC9wL2hpa2VyL2QvZHIvZ2l0L3Jhdy9tYXN0ZXIvanMvbHNnLmpzJyk7Ly/lvJXnlKjmnKzlnLDlgqjlrZjmj5Lku7ZcXG4gICAgICAgIGNvbnN0IGxzZz0kLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9sb2NhbFN0b3JhZ2U/cnVsZT3pgZPplb/ku5PlupNQcm9cXFwiKTsvL+W8leeUqOWtkOmhtemdouacrOWcsOWCqOWtmOaPkuS7tlxcbiAgICAgICAgbGV0IGxvY2FsX21zID0gbHNnLmdldEl0ZW0oJ3RpbWVvdXQnKTtcXG4gICAgICAgIGxldCBtcyA9IHBhcnNlSW50KG1zKXx8cGFyc2VJbnQobG9jYWxfbXMpfHw1MDAwO1xcbiAgICAgICAgbGV0IG1heF9jb3VudD1NYXRoLmNlaWwobXMvMjUwKTtcXG4gICAgICAgIGxvZyhcXFwi5pys5qyh5ZeF5o6i6LaF5pe2OlxcXCIrbXMrXFxcIuWFseiuoeW+heaKk+WMhTpcXFwiK21heF9jb3VudCtcXFwi5qyhXFxcIik7XFxuICAgICAgICBzaG93TG9hZGluZygn5ZeF5o6i5Lit77yM6Iul5aSx6LSl5bCx5YiH5o2id2Vi5ZeF5o6iLi4uJyk7XFxuICAgICAgICBsZXQgX3g1ID0gJC50b1N0cmluZygoaXNWaWRlbyxyZWNoYW5nZSxwbGF5VXJsLG1heF9jb3VudCxQQ19VQSxpc0JhZFZpZGVvKT0+e1xcbiAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgIGlmKHR5cGVvZihmYmEpPT0ndW5kZWZpbmVkJ3x8IWZiYSl7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgZmJhID0gZnlfYnJpZGdlX2FwcDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mKHJlcXVlc3QpPT0ndW5kZWZpbmVkJ3x8IXJlcXVlc3Qpe1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2YWwoZmJhLmdldEludGVybmFsSnMoKSk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1jYXRjaCAoZSkge1xcbiAgICAgICAgICAgICAgICAgICAgZmJhLmxvZyhlLm1lc3NhZ2UpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGZiYS5wdXRWYXIoXFxcIl94NWp4VXJsXFxcIixwbGF5VXJsKTtcXG4gICAgICAgICAgICAgICAgaWYod2luZG93LmNvdW50ID09IG51bGwpe1xcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmNvdW50PTE7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgbGV0IHRleHQ9Jyc7XFxuICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICB0ZXh0PWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXFxcImJvZHlcXFwiKS5pbm5lclRleHQ7XFxuICAgICAgICAgICAgICAgIH1jYXRjaCAoZSkge2ZiYS5sb2coZS5tZXNzYWdlKX1cXG4gICAgICAgICAgICAgICAgaWYoL+inpuWPkeS6humYsuebl+mTvnzmnKrmjojmnYN85o6l5Y+j6Ziy55uXLy50ZXN0KHRleHQpJiZ3aW5kb3cuY291bnQ9PT0xKXtcXG4gICAgICAgICAgICAgICAgICAgIGZiYS5sb2coXFxcIuajgOa1i+WIsOacieaOiOadg++8jOW8gOWni+i/h+aOiOadg1xcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgLy9sb2NhdGlvbi5yZWxvYWQoKTtcXG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uLmhyZWY9ZmJhLmdldFZhcihcXFwiX3g1anhVcmxcXFwiKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB3aW5kb3cuY291bnQrKztcXG4gICAgICAgICAgICAgICAgLy8gZmJhLmxvZygnY291bnQ6Jyt3aW5kb3cuY291bnQrJyxtYXhfY291bnQ6JyttYXhfY291bnQpO1xcbiAgICAgICAgICAgICAgICBpZiggd2luZG93LmNvdW50ID49IG1heF9jb3VudCl7XFxuICAgICAgICAgICAgICAgICAgICBmYmEubG9nKFxcXCLotoXov4dcXFwiK21heF9jb3VudCoyNTArXFxcIuavq+enkuacquiOt+WPluWIsOi1hOa6kOWcsOWdgO+8jOi3s+WIsOa6kOe9kemhtSzku6XkuIvmmK/liqDovb3ov4fnmoTlnLDlnYBcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRleHQ9ZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcXFwiYm9keVxcXCIpLmlubmVyVGV4dDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmYmEubG9nKHRleHQpO1xcbiAgICAgICAgICAgICAgICAgICAgfWNhdGNoIChlKSB7ZmJhLmxvZyhlLm1lc3NhZ2UpfVxcbiAgICAgICAgICAgICAgICAgICAgZmJhLmxvZyhKU09OLnN0cmluZ2lmeShfZ2V0VXJscygpKSk7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmJhLmdldFZhcihcXFwiX3g1anhVcmxcXFwiKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBtdXRlTWUoZWxlbSkge1xcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnBhdXNlKCk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHZhciB2aWRlb3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFxcXCJ2aWRlb1xcXCIpLCBhdWRpb3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFxcXCJhdWRpb1xcXCIpLCB2MiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXFxcImVtYmVkXFxcIiksIHYzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcXFwiI3BsYXllclxcXCIpO1xcbiAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgW10uZm9yRWFjaC5jYWxsKHZpZGVvcywgZnVuY3Rpb24gKHZpZGVvKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbXV0ZU1lKHZpZGVvKTtcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxcbiAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgW10uZm9yRWFjaC5jYWxsKGF1ZGlvcywgZnVuY3Rpb24gKGF1ZGlvKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbXV0ZU1lKGF1ZGlvKTtcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxcbiAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgW10uZm9yRWFjaC5jYWxsKHYyLCBmdW5jdGlvbiAodikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGVNZSh2KTtcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxcbiAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgW10uZm9yRWFjaC5jYWxsKHYzLCBmdW5jdGlvbiAodikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGVNZSh2KTtcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxcbiAgICAgICAgICAgICAgICB2YXIgdXJscyA9IF9nZXRVcmxzKCk7XFxuICAgICAgICAgICAgICAgIC8vIGZiYS5sb2coSlNPTi5zdHJpbmdpZnkodXJscykpO1xcbiAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpIGluIHVybHMpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdT11cmxzW2ldO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeXt1PWRlY29kZVVSSUNvbXBvbmVudCh1KTt9Y2F0Y2goZSl7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHU9dW5lc2NhcGUodSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoL3VybD1odHRwLy50ZXN0KHUpKXtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdSA9IHUuc3BsaXQoXFxcInVybD1cXFwiKS5zbGljZSgtMSlbMF07XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZiYS5sb2coXFxcInVybOWIhuWJsjpcXFwiK3UpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1lbHNlIGlmKC91cmw9XFxcXC8vLnRlc3QodSkmJi9cXFxcLm0zdTgvLnRlc3QodSkpe1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaG9zdCA9IHUubWF0Y2goLyguKilcXFxcL1xcXFwvKC4qPylcXFxcLy8pWzBdO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ID0gaG9zdCt1LnNwbGl0KFxcXCJ1cmw9XFxcIikuc2xpY2UoLTEpWzBdO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmYmEubG9nKFxcXCJ1cmzliIblibI6XFxcIit1KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZigvdmlkPWh0dHAvLnRlc3QodSkpe1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ID0gdS5zcGxpdChcXFwidmlkPVxcXCIpLnNsaWNlKC0xKVswXTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmJhLmxvZyhcXFwidmlk5YiG5YmyOlxcXCIrdSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2UgaWYoL3ZpZD1cXFxcLy8udGVzdCh1KSYmL1xcXFwubTN1OC8udGVzdCh1KSl7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBob3N0ID0gdS5tYXRjaCgvKC4qKVxcXFwvXFxcXC8oLio/KVxcXFwvLylbMF07XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUgPSBob3N0K3Uuc3BsaXQoXFxcInZpZD1cXFwiKS5zbGljZSgtMSlbMF07XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZiYS5sb2coXFxcInZpZOWIhuWJsjpcXFwiK3UpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKC9cXFxcPyguKik9aHR0cC8udGVzdCh1KSYmL1xcXFwubTN1OC8udGVzdCh1KSl7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUgPSBcXFwiaHR0cFxcXCIrdS5zcGxpdCgvXFxcXD8oLiopPWh0dHAvKS5zbGljZSgtMSlbMF07XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZiYS5sb2coXFxcIuWFtuS7luWIhuWJsjpcXFwiK3UpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3xpbmRleFxcXFwubTN1OCRcXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKC9cXFxcLzFcXFxcLm0zdTgvLnRlc3QodSkpe1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgdT11LnJlcGxhY2UoLyZmcm9tPS4qfCZuZXh0PS4qfCZqdW1wPS4qLywnJyk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlYWxVcmwgPSBpc1ZpZGVvKHUscmVjaGFuZ2UpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZihyZWFsVXJsKT09J3N0cmluZycmJiFpc0JhZFZpZGVvKHUpKXsvL+i/h+a7pOWQiuavm+inhumikVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2Z5X2JyaWRnZV9hcHAuc2V0V2ViVWEoUENfVUEpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2YoZmJhLmdldEhlYWRlclVybCkhPT0ndW5kZWZpbmVkJyYmdHlwZW9mKHJlY2hhbmdlKSE9PSdmdW5jdGlvbicpe1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGV0IGJhY2tVcmwgPSBmYmEuZ2V0SGVhZGVyVXJsKHUucmVwbGFjZShcXFwiO3tcXFwiLFxcXCIjaXNWaWRlbz10cnVlIzt7XFxcIikpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJhY2tVcmwgPSBmYmEuZ2V0SGVhZGVyVXJsKHVybHNbaV0pLnJlcGxhY2UoJzt7JywnI2lnbm9yZUltZz10cnVlIyNpc1ZpZGVvPXRydWUjO3snKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB1MSA9IGJhY2tVcmwuc3BsaXQoJyNpZ25vcmVJbWcnKVswXTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB1MiA9ICcjaWdub3JlSW1nJytiYWNrVXJsLnNwbGl0KCcjaWdub3JlSW1nJylbMV07XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1MSA9IHUxLnJlcGxhY2UoLyZmcm9tPS4qfCZuZXh0PS4qfCZqdW1wPS4qLywnJyk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZigvdXJsPWh0dHAvLnRlc3QodTEpKXtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1MSA9IHUxLnNwbGl0KFxcXCJ1cmw9XFxcIikuc2xpY2UoLTEpWzBdO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2UgaWYoL3VybD1cXFxcLy8udGVzdCh1MSkmJi9cXFxcLm0zdTgvLnRlc3QodTEpKXtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaG9zdDEgPSB1MS5tYXRjaCgvKC4qKVxcXFwvXFxcXC8oLio/KVxcXFwvLylbMF07XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdTEgPSBob3N0MSt1MS5zcGxpdChcXFwidXJsPVxcXCIpLnNsaWNlKC0xKVswXTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmYmEubG9nKFxcXCJ1cmzliIblibI6XFxcIit1KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoL3ZpZD1odHRwLy50ZXN0KHUxKSl7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdTEgPSB1MS5zcGxpdChcXFwidmlkPVxcXCIpLnNsaWNlKC0xKVswXTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1lbHNlIGlmKC92aWQ9XFxcXC8vLnRlc3QodTEpJiYvXFxcXC5tM3U4Ly50ZXN0KHUxKSl7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGhvc3QxID0gdTEubWF0Y2goLyguKilcXFxcL1xcXFwvKC4qPylcXFxcLy8pWzBdO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUxID0gaG9zdDErdTEuc3BsaXQoXFxcInZpZD1cXFwiKS5zbGljZSgtMSlbMF07XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKC9cXFxcPyguKik9aHR0cC8udGVzdCh1MSkmJi9cXFxcLm0zdTgvLnRlc3QodTEpKXtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1MSA9IFxcXCJodHRwXFxcIit1MS5zcGxpdCgvXFxcXD8oLiopPWh0dHAvKS5zbGljZSgtMSlbMF07XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrVXJsID0gdTEgKyB1MjtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZiYS5sb2coJ+i/lOWbnuiHquWKqOWKoGNvb2tpZemTvuaOpTonK2JhY2tVcmwpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmJhLmxvZygn6L+U5Zue6ZO+5o6lOicrdSsn5bm26Ieq5Yqo5Yqg5LqGY29va2llLOWFt+S9k2Nvb2tpZeWcqOinhumikeaSreaUvuWkhOafpeeciycpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhY2tVcmw7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZXtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZiYS5sb2coXFxcIui/lOWbnuS7k+W6k3g15YWN5ZeF57uT5p6cOlxcXCIrcmVhbFVybCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhbFVybFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9Y2F0Y2ggKGUpIHtcXG4gICAgICAgICAgICAgICAgICAgIGZiYS5sb2coZS5tZXNzYWdlKVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfWNhdGNoIChlKSB7XFxuICAgICAgICAgICAgICAgIC8vIGZ5X2JyaWRnZV9hcHAubG9nKCd4NeWkp+iMg+WbtOmUmeivrzonK2UubWVzc2FnZSk7XFxuICAgICAgICAgICAgICAgIGFsZXJ0KCd4NeWkp+iMg+WbtOmUmeivrzonK2UubWVzc2FnZSk7XFxuICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/miqXplJnnu5PmnZ94NSdcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LGlzVmlkZW8scmVjaGFuZ2UscGxheVVybCxtYXhfY291bnQsUENfVUEsaXNCYWRWaWRlbyk7XFxuICAgICAgICBsZXQgdXNlV2ViPWxzZy5nZXRJdGVtKFxcXCLpgJrlhY1cXFwiLFxcXCJYNVxcXCIpPT09XFxcIldFQlxcXCI7XFxuICAgICAgICAvL2xvZyhcXFwi5LuT5bqT5L2/55Sod2Vi6YCa5YWN5pu/5LujeDU6XFxcIit1c2VXZWIpO1xcbiAgICAgICAgbGV0IHJ1bGVIZWFkPXVzZVdlYiYmcGFyc2VJbnQoZ2V0QXBwVmVyc2lvbigpKT49MjMzOT9cXFwid2ViUnVsZTovL1xcXCI6XFxcIng1UnVsZTovL1xcXCI7XFxuICAgICAgICBsZXQgeDVVcmwgPSBydWxlSGVhZCtwbGF5VXJsKyAnQCcgK194NTtcXG4gICAgICAgIHJldHVybiB4NVVybFxcbiAgICB9XFxufVxcblxcbmZ1bmN0aW9uIHg1UGFyc2VQcm8oeDVsaXN0LHg1VGltZW91dCxpc1ZpZGVvKXtcXG4gICAgbGV0IGJwYXRoID0gJ2ZpbGU6Ly8vc3RvcmFnZS9lbXVsYXRlZC8wL0FuZHJvaWQvZGF0YS9jb20uZXhhbXBsZS5oaWtlcnZpZXcvZmlsZXMvRG9jdW1lbnRzL3J1bGVzL2R6SG91c2UvaHRtbC/mtbfpmJTll4XmjqLlmaguaHRtbCc7XFxuICAgIGxldCBiY29kZSA9IGZldGNoKGJwYXRoKTtcXG4gICAgaWYoIWJjb2RlfHwhL2Z5X2JyaWRnZV9hcHAvLnRlc3QoYmNvZGUpKXtcXG4gICAgICAgIGxvZygn5pys5Zyw5pyq5a6J6KOF5ZeF5o6i5Zmo77yM5byA5aeL5a6J6KOFJyk7XFxuICAgICAgICBjb25zdCB7YXBpfSA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL3V0aWxpeT9ydWxlPemBk+mVv+S7k+W6k1Byb1xcXCIpO1xcbiAgICAgICAgbGV0IGh0bWwgPSBmZXRjaChhcGkuaG9zdCsnL3J1bGVsaXN0Lmpzb24/aWQ9MjA1NScpO1xcbiAgICAgICAgaWYoL+a1t+mYlOinhueVjC8udGVzdChodG1sKSl7XFxuICAgICAgICAgICAgd3JpdGVGaWxlKGJwYXRoLGh0bWwpO1xcbiAgICAgICAgfWVsc2V7XFxuICAgICAgICAgICAgd3JpdGVGaWxlKGJwYXRoLGZldGNoKCdodHRwczovL2hqZGhueC5jb2RpbmcubmV0L3AvaGlrZXIvZC9kci9naXQvcmF3L21hc3Rlci9odG1sL2dldFZpZGVvLmh0bWwnKSlcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICB4NVRpbWVvdXQgPSBwYXJzZUludCh4NVRpbWVvdXQpfHw1MDAwO1xcbiAgICBsZXQgbWF4X2NvdW50PSh4NVRpbWVvdXQvMjUwKTsgLy/moLnmja7otoXml7boh6rliqjorqHnrpfkuoblj6/miafooYznmoTmrKHmlbBcXG4gICAgcHV0VmFyKCd4NUxpc3QnLEpTT04uc3RyaW5naWZ5KHg1bGlzdCkpO1xcbiAgICBsZXQgX3g1ID0gJC50b1N0cmluZygoaXNWaWRlbywgbWF4X2NvdW50LHg1VGltZW91dCxpc0JhZFZpZGVvKSA9PiB7XFxuICAgICAgICAvL+WIneWni+WMlmZiYeWSjHJlcXVzdFxcbiAgICAgICAgaWYgKHR5cGVvZiAoZmJhKSA9PSAndW5kZWZpbmVkJyB8fCAhZmJhKSB7XFxuICAgICAgICAgICAgdmFyIGZiYSA9IGZ5X2JyaWRnZV9hcHA7XFxuICAgICAgICB9XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHJlcXVlc3QpID09ICd1bmRlZmluZWQnIHx8ICFyZXF1ZXN0KSB7XFxuICAgICAgICAgICAgICAgIGV2YWwoZmJhLmdldEludGVybmFsSnMoKSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgIGZiYS5sb2coZS5tZXNzYWdlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIGlmICh3aW5kb3cuY291bnQgPT0gbnVsbCkge1xcbiAgICAgICAgICAgICAgICB3aW5kb3cuY291bnQgPSAxO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBsZXQgdGV4dD0nJztcXG4gICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICB0ZXh0PWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXFxcImJvZHlcXFwiKS5pbm5lclRleHQ7XFxuICAgICAgICAgICAgfWNhdGNoIChlKSB7ZmJhLmxvZyhlLm1lc3NhZ2UpfVxcbiAgICAgICAgICAgIGlmKC/op6blj5HkuobpmLLnm5fpk7585pyq5o6I5p2DfOaOpeWPo+mYsuebly8udGVzdCh0ZXh0KSYmd2luZG93LmNvdW50PT0xKXtcXG4gICAgICAgICAgICAgICAgbG9jYXRpb24ucmVsb2FkKCk7XFxuICAgICAgICAgICAgICAgIGZiYS5sb2coXFxcIuajgOa1i+WIsOacieaOiOadg++8jOW8gOWni+i/h+aOiOadg1xcXCIpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB3aW5kb3cuY291bnQrKztcXG4gICAgICAgICAgICAvLyBmYmEubG9nKCdjb3VudDonICsgd2luZG93LmNvdW50ICsgJyxtYXhfY291bnQ6JyArIG1heF9jb3VudCk7XFxuICAgICAgICAgICAgaWYgKHdpbmRvdy5jb3VudCA+PSBtYXhfY291bnQpIHtcXG4gICAgICAgICAgICAgICAgZmJhLmNsZWFyVmFyKCd4NUxpc3QnKTtcXG4gICAgICAgICAgICAgICAgZmJhLmhpZGVMb2FkaW5nKCk7XFxuICAgICAgICAgICAgICAgIGxldCBmbXNnID0gJ+mBk+mVv+S7k+W6k+mAmuWFjeino+aekOWksei0pSzljp/lm6A66LaF5pe2Jyt4NVRpbWVvdXQrJ+avq+enkic7XFxuICAgICAgICAgICAgICAgIGZiYS5sb2coZm1zZyk7XFxuICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly8nK2Ztc2c7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfWNhdGNoIChlKSB7XFxuICAgICAgICAgICAgZmJhLmxvZyhlLm1lc3NhZ2UpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZnVuY3Rpb24gbXV0ZU1lKGVsZW0pIHtcXG4gICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICBlbGVtLnBhdXNlKCk7XFxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciB2aWRlb3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFxcXCJ2aWRlb1xcXCIpLCBhdWRpb3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFxcXCJhdWRpb1xcXCIpLFxcbiAgICAgICAgICAgIHYyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcXFwiZW1iZWRcXFwiKSwgdjMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFxcXCIjcGxheWVyXFxcIik7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIFtdLmZvckVhY2guY2FsbCh2aWRlb3MsIGZ1bmN0aW9uICh2aWRlbykge1xcbiAgICAgICAgICAgICAgICBtdXRlTWUodmlkZW8pO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgfVxcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICBbXS5mb3JFYWNoLmNhbGwoYXVkaW9zLCBmdW5jdGlvbiAoYXVkaW8pIHtcXG4gICAgICAgICAgICAgICAgbXV0ZU1lKGF1ZGlvKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgIH1cXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgW10uZm9yRWFjaC5jYWxsKHYyLCBmdW5jdGlvbiAodikge1xcbiAgICAgICAgICAgICAgICBtdXRlTWUodik7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICB9XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIFtdLmZvckVhY2guY2FsbCh2MywgZnVuY3Rpb24gKHYpIHtcXG4gICAgICAgICAgICAgICAgbXV0ZU1lKHYpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIHVybHMgPSBfZ2V0VXJscygpO1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICBmb3IgKGxldCBpIGluIHVybHMpIHtcXG4gICAgICAgICAgICAgICAgbGV0IHU9dXJsc1tpXTtcXG4gICAgICAgICAgICAgICAgLy91PWRlY29kZVVSSUNvbXBvbmVudCh1KTtcXG4gICAgICAgICAgICAgICAgdHJ5e3U9ZGVjb2RlVVJJQ29tcG9uZW50KHUpO31jYXRjaChlKXtcXG4gICAgICAgICAgICAgICAgICAgIHU9dW5lc2NhcGUodSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYoL3VybD1odHRwLy50ZXN0KHUpKXtcXG4gICAgICAgICAgICAgICAgICAgIHUgPSB1LnNwbGl0KFxcXCJ1cmw9XFxcIikuc2xpY2UoLTEpWzBdO1xcbiAgICAgICAgICAgICAgICB9ZWxzZSBpZigvdmlkPWh0dHAvLnRlc3QodSkpe1xcbiAgICAgICAgICAgICAgICAgICAgdSA9IHUuc3BsaXQoXFxcInZpZD1cXFwiKS5zbGljZSgtMSlbMF07XFxuICAgICAgICAgICAgICAgIH1lbHNlIGlmKC9cXFxcPyguKik9aHR0cC8udGVzdCh1KSl7XFxuICAgICAgICAgICAgICAgICAgICB1ID0gXFxcImh0dHBcXFwiK3Uuc3BsaXQoL1xcXFw/KC4qKT1odHRwLykuc2xpY2UoLTEpWzBdO1xcbiAgICAgICAgICAgICAgICAgICAgLy9mYmEubG9nKFxcXCLlhbbku5bliIblibI6XFxcIit1KTtcXG4gICAgICAgICAgICAgICAgfWVsc2UgaWYoL1xcXFwvMVxcXFwubTN1OCQvLnRlc3QodSkpe1xcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgdT11LnJlcGxhY2UoLyZmcm9tPS4qfCZuZXh0PS4qfCZqdW1wPS4qLywnJyk7XFxuICAgICAgICAgICAgICAgIGxldCByZWFsVXJsID0gaXNWaWRlbyh1KTtcXG4gICAgICAgICAgICAgICAgaWYgKHJlYWxVcmwmJiFpc0JhZFZpZGVvKHUpKSB7Ly/ov4fmu6TlkIrmr5tcXG4gICAgICAgICAgICAgICAgICAgIGZiYS5sb2coXFxcIuS7k+W6k3g15YWN5ZeF57uT5p6cOlxcXCIgKyByZWFsVXJsKTtcXG4gICAgICAgICAgICAgICAgICAgIGZiYS5jbGVhclZhcigneDVMaXN0Jyk7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhbFVybFxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgIGZiYS5sb2coZS5tZXNzYWdlKVxcbiAgICAgICAgfVxcbiAgICB9LCBpc1ZpZGVvLCBtYXhfY291bnQseDVUaW1lb3V0LGlzQmFkVmlkZW8pO1xcbiAgICBjb25zdCBsc2c9JC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvbG9jYWxTdG9yYWdlP3J1bGU96YGT6ZW/5LuT5bqTUHJvXFxcIik7XFxuICAgIGxldCB1c2VXZWI9bHNnLmdldEl0ZW0oXFxcIumAmuWFjVxcXCIsXFxcIlg1XFxcIik9PT1cXFwiV0VCXFxcIjtcXG4gICAgLy9sb2coXFxcIuS7k+W6k+S9v+eUqHdlYumAmuWFjeabv+S7o3g1OlxcXCIrdXNlV2ViKTtcXG4gICAgbGV0IHJ1bGVIZWFkPXVzZVdlYiYmcGFyc2VJbnQoZ2V0QXBwVmVyc2lvbigpKT49MjMzOT9cXFwid2ViUnVsZTovL1xcXCI6XFxcIng1UnVsZTovL1xcXCI7XFxuICAgIHJldHVybiBydWxlSGVhZCticGF0aCsnQCcgKyBfeDU7XFxufVxcblxcbmZ1bmN0aW9uIExhenlQYXJzZUZhc3QocGxheVVybExpc3QsZ2V0VGltZW91dCx4NVRpbWVvdXQpe1xcbiAgICBjb25zdCB7aXNWaWRlbyxnZXRIZWFkZXJzLHg1UGFyc2VQcm99ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZ2xvYmFsUGFyc2U/cnVsZT3pgZPplb/ku5PlupNQcm8nKTtcXG4gICAgLy8gbG9nKCflvIDlp4vmiafooYwnK3BsYXlVcmxMaXN0Lmxlbmd0aCsn5Liq5Zyw5Z2A55qE5om56YeP5ZeF5o6iOicrcGxheVVybExpc3QpO1xcbiAgICBsb2coJ+W8gOWni+aJp+ihjCcrcGxheVVybExpc3QubGVuZ3RoKyfkuKrlnLDlnYDnmoTmibnph4/ll4XmjqInKTtcXG4gICAgbGV0IHBsYXlVcmxzID0gcGxheVVybExpc3QubWFwKChpdCk9PntcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgdXJsOml0LnNwbGl0KFxcXCI7XFxcIilbMF0sXFxuICAgICAgICAgICAgb3B0aW9uczoge1xcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgICAgICAvL1xcXCJVc2VyLUFnZW50XFxcIjogXFxcIkRhcnQvMi4xMyAoZGFydDppbylcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgXFxcIlVzZXItQWdlbnRcXFwiOlxcXCJNb3ppbGxhLzUuMFxcXCJcXG4gICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgdGltZW91dDogZ2V0VGltZW91dFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfSk7XFxuICAgIGxldCBiaHRtbCA9IGJhdGNoRmV0Y2gocGxheVVybHMpO1xcbiAgICBsZXQgdmlkZW9zID0gW107XFxuICAgIGxldCB4NWxpc3QgPSBbXTtcXG4gICAgZm9yKGxldCBpIGluIGJodG1sKXtcXG4gICAgICAgIGxldCBvcmRlciA9IHBhcnNlSW50KGkpKzE7XFxuICAgICAgICBsZXQgdG5hbWU9b3JkZXIrJ+WPt+ino+aekOe9keWdgDonO1xcbiAgICAgICAgLy9sb2codG5hbWUpO1xcbiAgICAgICAgbGV0IHR1cmw9cGxheVVybExpc3RbaV0uc3BsaXQoXFxcIjtcXFwiKVswXTtcXG4gICAgICAgIGxldCBqbmFtZT1wbGF5VXJsTGlzdFtpXS5zcGxpdChcXFwiO1xcXCIpLmxlbmd0aD4xP3BsYXlVcmxMaXN0W2ldLnNwbGl0KFxcXCI7XFxcIilbMV06XFxcIlxcXCI7XFxuICAgICAgICB0bmFtZSs9am5hbWU7XFxuICAgICAgICBsZXQgYmFja2NvZGUgPSBiaHRtbFtpXTtcXG4gICAgICAgIGlmKCghL3VybHxodHRwLy50ZXN0KGJhY2tjb2RlKSkmJighLyNFWFRJTkYvLnRlc3QoYmFja2NvZGUpKSl7XFxuICAgICAgICAgICAgbG9nKHRuYW1lK3R1cmwrJ+aciemXrumimCzlj6/og73liqDlr4bmiJbogIXmjILkuoYnKTtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgIH1lbHNlIGlmKC8jRVhUSU5GLy50ZXN0KGJhY2tjb2RlKSl7XFxuICAgICAgICAgICAgLy9sZXQgbGNhY2hlPVxcXCIvc3RvcmFnZS9lbXVsYXRlZC8wL0FuZHJvaWQvZGF0YS9jb20uZXhhbXBsZS5oaWtlcnZpZXcvZmlsZXMvRG9jdW1lbnRzL2NhY2hlL3ZpZGVvX1xcXCIrdG5hbWUrXFxcIi5tM3U4XFxcIjtcXG4gICAgICAgICAgICAvL3dyaXRlRmlsZShsY2FjaGUsYmFja2NvZGUpO1xcbiAgICAgICAgICAgIC8vdmlkZW9zLnB1c2gobGNhY2hlKTtcXG4gICAgICAgICAgICBsZXQgcFVybD1jYWNoZU0zdTgodHVybCk7XFxuICAgICAgICAgICAgdmlkZW9zLnB1c2gocFVybCk7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIGxldCB1cmwgPSBKU09OLnBhcnNlKGJhY2tjb2RlKS51cmw7XFxuICAgICAgICAgICAgaWYoL15odHRwLy50ZXN0KHVybCkpe1xcbiAgICAgICAgICAgICAgICBsZXQgcmVhbFZpZGVvID0gaXNWaWRlbyh1cmwpO1xcbiAgICAgICAgICAgICAgICBpZih0eXBlb2YocmVhbFZpZGVvKT09J3N0cmluZycpe1xcbiAgICAgICAgICAgICAgICAgICAgbG9nKHRuYW1lKyflt7Lop6PmnpDlh7rop4bpopE6JytyZWFsVmlkZW8pO1xcbiAgICAgICAgICAgICAgICAgICAgaWYoam5hbWUpe1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWxWaWRlbys9XFxcIuKYhVxcXCIram5hbWVcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIHZpZGVvcy5wdXNoKHJlYWxWaWRlbyk7XFxuICAgICAgICAgICAgICAgIH1lbHNle1xcbiAgICAgICAgICAgICAgICAgICAgbG9nKHRuYW1lKyfop6PmnpDlh7rkuI3nn6XpgZPku4DkuYjkuJzopb86Jyt1cmwpO1xcbiAgICAgICAgICAgICAgICAgICAgdXJsKz1cXFwiI2lzVmlkZW89dHJ1ZSNcXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgaWYoam5hbWUpe1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCs9XFxcIuKYhVxcXCIram5hbWVcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIHZpZGVvcy5wdXNoKHVybCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9ZWxzZXtcXG4gICAgICAgICAgICAgICAgbG9nKHRuYW1lKyfkuLpqc29u5o6l5Y+j5LiU5peg6L+U5Zue6KeG6aKR5Zyw5Z2A5pWw5o2uOicrcGxheVVybExpc3RbaV0rJ1xcXFxuJytiYWNrY29kZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfWNhdGNoIChlKSB7XFxuICAgICAgICAgICAgbG9nKHRuYW1lKyfkuLp4NeaOpeWPoyzliqDlhaV4NeWXheaOouWIl+ihqCcpO1xcbiAgICAgICAgICAgIHg1bGlzdC5wdXNoKHBsYXlVcmxMaXN0W2ldKTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICAvLyBsb2codmlkZW9zKTtcXG4gICAgaWYodmlkZW9zLmxlbmd0aD4wKXtcXG4gICAgICAgIGlmKGdldFZhcignZHAuY2FjaGVWaWRlbycsJ3RydWUnKT09PSd0cnVlJyYmcGFyc2VJbnQoZ2V0QXBwVmVyc2lvbigpKT49MjI1NSlcXG4gICAgICAgIHtcXG4gICAgICAgICAgICBsb2coXFxcIuWwiuaVrOeahOmtlOaWreeUqOaIt++8jOinhumikee8k+WtmOW3suWQr+eUqO+8jOivt+WwveaDheS6q+WPl+eci+WJp+aXtuWFiVxcXCIpO1xcbiAgICAgICAgICAgIGxldCB2aWRlb3NDYWNoZT12aWRlb3MubWFwKChpdCk9PntcXG4gICAgICAgICAgICAgICAgbGV0IGhlYWRlcnM9e307XFxuICAgICAgICAgICAgICAgIGlmKGl0LnNwbGl0KFxcXCI7XFxcIikubGVuZ3RoPjEpe1xcbiAgICAgICAgICAgICAgICAgICAgbGV0IGhlYWQgPSBpdC5zcGxpdCgnOycpWzFdO1xcbiAgICAgICAgICAgICAgICAgICAgaWYoL0AvLnRlc3QoaGVhZCkmJi97fH0vLnRlc3QoaGVhZCkpe1xcbi8vaGVhZCA9IGhlYWQucmVwbGFjZSgve3x9L2csJycpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWQgPSBoZWFkLnNwbGl0KFxcXCJ7XFxcIilbMV0uc3BsaXQoXFxcIn1cXFwiKVswXTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkID0gaGVhZC5zcGxpdCgnJiYnKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgaW4gaGVhZCl7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBrZXkgPSBoZWFkW2ldLnNwbGl0KCdAJylbMF07XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9aGVhZFtpXS5zcGxpdCgnQCcpWzFdLnJlcGxhY2UoLzsvLCfvvJvvvJsnKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1trZXldID0gdmFsdWU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgICAgICB1cmw6aXQuc3BsaXQoXFxcIjtcXFwiKVswXS5zcGxpdChcXFwi4piFXFxcIilbMF0sXFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOntcXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOmhlYWRlcnNcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIHZhciBkYXRhPWJhdGNoQ2FjaGVNM3U4KHZpZGVvc0NhY2hlKTtcXG4gICAgICAgICAgICBkYXRhPWRhdGEubWFwKChpdCxpZCk9PntcXG4gICAgICAgICAgICAgICAgbGV0IGV4dHJhPVxcXCJcXFwiO1xcbiAgICAgICAgICAgICAgICBpZih2aWRlb3NbaWRdLnNwbGl0KFxcXCI7XFxcIikubGVuZ3RoPjEpe1xcbiAgICAgICAgICAgICAgICAgICAgZXh0cmE9XFxcIjtcXFwiK3ZpZGVvc1tpZF0uc3BsaXQoXFxcIjtcXFwiKVsxXTtcXG4gICAgICAgICAgICAgICAgfWVsc2UgaWYodmlkZW9zW2lkXS5zcGxpdChcXFwi4piFXFxcIikubGVuZ3RoPjEpe1xcbiAgICAgICAgICAgICAgICAgICAgZXh0cmE9XFxcIuKYhVxcXCIrdmlkZW9zW2lkXS5zcGxpdChcXFwi4piFXFxcIilbMV07XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgaWYoaXQrXFxcIlxcXCIhPVxcXCJudWxsXFxcIil7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXQrZXh0cmFcXG4gICAgICAgICAgICAgICAgfWVsc2V7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlkZW9zW2lkXVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgLy9sb2coZGF0YSk7XFxuICAgICAgICAgICAgcmV0dXJuIGRhdGFcXG4gICAgICAgICAgICAvL3JldHVybiB2aWRlb3NcXG4gICAgICAgIH1lbHNle1xcbiAgICAgICAgICAgIHJldHVybiB2aWRlb3NcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBsb2coJ+WFseaciScreDVsaXN0Lmxlbmd0aCsn5LiqeDXlnLDlnYDov5vooYzova7mtYHll4XmjqInKTtcXG4gICAgLy/msqHmnInnmoTor53lsLHlvIDlp4vkvp3mrKF4NeWXheaOolxcbiAgICBzaG93TG9hZGluZygn5ZeF5o6i5Lit77yM6Iul5aSx6LSl5bCx5YiH5o2id2Vi5ZeF5o6iLi4uJyk7XFxuICAgIHJldHVybiB4NVBhcnNlUHJvKHg1bGlzdCx4NVRpbWVvdXQsaXNWaWRlbyk7XFxufVxcbnZhciBsYXp5PSQoJycpLmxhenlSdWxlKCgpPT57XFxuICAgIHRyeXtcXG4gICAgICAgIHJlYWxVcmw9aW5wdXQ7XFxuICAgICAgICBldmFsKFxcXCJ2YXIgY29uZmlnX2RwID1cXFwiICsgZmV0Y2goXFxcImhpa2VyOi8vZmlsZXMvY2FjaGUvTXlQYXJzZVNldC5qc29uXFxcIikpO1xcbiAgICAgICAgZXZhbChmZXRjaChjb25maWdfZHAuY2opKTtcXG4gICAgICAgIGxvZyhpbnB1dCsnLT7mraPlnKjmlq3mj5LprZTmlLnniYjop6PmnpAuLi4nKTtcXG4gICAgICAgIC8vIOWKoOWFpei2heaXtuiuvue9ru+8jOW7uuiuruWcqOmmlumhteiuvue9rlxcbiAgICAgICAgcmV0dXJuIGF5dG1QYXJzZShyZWFsVXJsKVxcbiAgICB9Y2F0Y2goZSl7XFxuICAgICAgICByZXR1cm4gaW5wdXRcXG4gICAgfVxcbn0pO1xcbiQuZXhwb3J0cy5pc1BpYz1pc1BpYztcXG4kLmV4cG9ydHMuaXNWaWRlbz1pc1ZpZGVvO1xcbiQuZXhwb3J0cy5pc0JhZFZpZGVvPWlzQmFkVmlkZW87XFxuJC5leHBvcnRzLmNvbVBhcnNlPWNvbVBhcnNlO1xcbiQuZXhwb3J0cy5nZXRIZWFkZXJzPWdldEhlYWRlcnM7XFxuJC5leHBvcnRzLmxhenlQYXJzZT1sYXp5UGFyc2U7XFxuJC5leHBvcnRzLng1UGFyc2VQcm89eDVQYXJzZVBybztcXG4kLmV4cG9ydHMuTGF6eVBhcnNlRmFzdD1MYXp5UGFyc2VGYXN0O1xcbiQuZXhwb3J0cy5sYXp5PWxhenk7XCJ9LHtcIm5hbWVcIjpcIuS7u+WKoeS7k+W6k+aOpeWPo1wiLFwicGF0aFwiOlwidGFza0NhbGxcIixcInJ1bGVcIjpcImpzOlxcblN0cmluZy5wcm90b3R5cGUuc3RyaXAgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnJlcGxhY2UoLyheXFxcXHMqKXwoXFxcXHMqJCkvZywgXFxcIlxcXCIpOyB9O1xcbmZ1bmN0aW9uIHRhc2tfcmVxKHRhc2tfYXBpLHRhc2spIHsgLy8g6YCa55So5Y+R6YCB5LuT5bqTcG9zdOiwg+eUqOS7u+WKoeivt+axglxcbiAgICBjb25zdCB7Z2V0RmlsZX0gPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS91dGlsaXk/cnVsZT3pgZPplb/ku5PlupNQcm9cXFwiKTtcXG4gICAgbGV0IGhvdXNlRmlsZSA9IGdldEZpbGV8fGZhbHNlO1xcbiAgICBpZighaG91c2VGaWxlKXtcXG4gICAgICAgIHNldEl0ZW0oJ2lzX2hvdXNlX3ZpcCcsICdmYWxzZScpO1xcbiAgICB9XFxuICAgIGxldCBob3VzZV9kYXRhID0gaG91c2VGaWxlKCk7XFxuICAgIGxldCByZXN1bHQgPSByZXF1ZXN0KHRhc2tfYXBpLCB7XFxuICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcXG4gICAgICAgICAgICBcXFwicGFyYW1zXFxcIjoge1xcbiAgICAgICAgICAgICAgICBcXFwiZGF0YVxcXCI6IHtcXG4gICAgICAgICAgICAgICAgICAgIFxcXCJ0eXBlXFxcIjogdGFzay5tb2RlfHwncnVuJyxcXG4gICAgICAgICAgICAgICAgICAgIFxcXCJmdW5jXFxcIjogdGFzay5mdW5jfHwnJyxcXG4gICAgICAgICAgICAgICAgICAgIFxcXCJwYXJhbXNcXFwiOiB0YXNrLnBhcmFtc3x8W11cXG4gICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgXFxcImF1dGhcXFwiOiB7XFxuICAgICAgICAgICAgICAgICAgICBcXFwibmFtZVxcXCI6IGhvdXNlX2RhdGEudXNlcm5hbWV8fFxcXCJcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgXFxcInBhc3N3b3JkXFxcIjogaG91c2VfZGF0YS5wYXNzd29yZHx8XFxcIlxcXCJcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pLFxcbiAgICAgICAgbWV0aG9kOiAnUE9TVCdcXG4gICAgfSk7XFxuICAgIHJldHVybiBKU09OLnBhcnNlKHJlc3VsdCkucmVzdWx0O1xcbn1cXG5cXG5mdW5jdGlvbiB0YXNrX3VwbG9hZCh0YXNrKXsgLy8g6YCa55So5Lu75Yqh5Y+R5biD5paw5aKe5Y+K5L+u5pS55Yqf6IO9XFxuICAgIGNvbnN0IHthcGksZ2V0RmlsZX0gPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS91dGlsaXk/cnVsZT3pgZPplb/ku5PlupNQcm9cXFwiKTtcXG4gICAgbGV0IGhvdXNlRmlsZSA9IGdldEZpbGV8fGZhbHNlO1xcbiAgICBpZighaG91c2VGaWxlKXtcXG4gICAgICAgIHNldEl0ZW0oJ2lzX2hvdXNlX3ZpcCcsICdmYWxzZScpO1xcbiAgICB9XFxuICAgIGxldCBhcGlfdXJsID0gYXBpLmhvc3QrJy9oaWtlcnVsZS90YXNrL2FkZCc7XFxuICAgIGxldCBob3VzZV9kYXRhID0gaG91c2VGaWxlKCk7XFxuICAgIGxldCByZXN1bHQgPSByZXF1ZXN0KGFwaV91cmwsIHtcXG4gICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXFxuICAgICAgICB9LFxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xcbiAgICAgICAgICAgIFxcXCJwYXJhbXNcXFwiOiB7XFxuICAgICAgICAgICAgICAgIFxcXCJkYXRhXFxcIjoge1xcbiAgICAgICAgICAgICAgICAgICAgXFxcIm5hbWVcXFwiOiB0YXNrLm5hbWUsXFxuICAgICAgICAgICAgICAgICAgICBcXFwicHljb2RlXFxcIjogdGFzay5weWNvZGUsXFxuICAgICAgICAgICAgICAgICAgICBcXFwibm90ZVxcXCI6IHRhc2subm90ZSxcXG4gICAgICAgICAgICAgICAgICAgIFxcXCJ0ZXN0X2NvZGVcXFwiOiB0YXNrLnRlc3RfY29kZSxcXG4gICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgXFxcImF1dGhcXFwiOiB7XFxuICAgICAgICAgICAgICAgICAgICBcXFwibmFtZVxcXCI6IGhvdXNlX2RhdGEudXNlcm5hbWV8fFxcXCJcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgXFxcInBhc3N3b3JkXFxcIjogaG91c2VfZGF0YS5wYXNzd29yZHx8XFxcIlxcXCJcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pLFxcbiAgICAgICAgbWV0aG9kOiAnUE9TVCdcXG4gICAgfSk7XFxuICAgIHJldHVybiBKU09OLnBhcnNlKHJlc3VsdCkucmVzdWx0O1xcbn1cXG5cXG5mdW5jdGlvbiB0YXNrX2NhbGwoaWQsZnVuYyxwYXJhbXMpe1xcbiAgICBjb25zdCB7YXBpfSA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL3V0aWxpeT9ydWxlPemBk+mVv+S7k+W6k1Byb1xcXCIpO1xcbiAgICBsZXQgdGFza19hcGkgPSBhcGkuaG9zdCsnL2hpa2VydWxlL3Rhc2svcnVuLycraWQ7XFxuICAgIGxldCB0YXNrID0ge1xcbiAgICAgICAgbW9kZTonY2FsbCcsXFxuICAgICAgICBmdW5jOmZ1bmMsXFxuICAgICAgICBwYXJhbXM6cGFyYW1zfHxbXVxcbiAgICB9O1xcbiAgICByZXR1cm4gdGFza19yZXEodGFza19hcGksdGFzayk7XFxufVxcblxcbmZ1bmN0aW9uIHRhc2tfcmVuYW1lKGlkLG5ld190YXNrX25hbWUpe1xcbiAgICBjb25zdCB7YXBpLGdldEZpbGV9ID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvdXRpbGl5P3J1bGU96YGT6ZW/5LuT5bqTUHJvXFxcIik7XFxuICAgIGxldCBob3VzZUZpbGUgPSBnZXRGaWxlfHxmYWxzZTtcXG4gICAgaWYoIWhvdXNlRmlsZSl7XFxuICAgICAgICBzZXRJdGVtKCdpc19ob3VzZV92aXAnLCAnZmFsc2UnKTtcXG4gICAgfVxcbiAgICBsZXQgaG91c2VfZGF0YSA9IGhvdXNlRmlsZSgpO1xcbiAgICBsZXQgdGFza19hcGkgPSBhcGkuaG9zdCsnL2hpa2VydWxlL3Rhc2svcmVuYW1lLycraWQ7XFxuICAgIHRhc2tfYXBpID0gdGFza19hcGkrJz9uYW1lPScraG91c2VfZGF0YS51c2VybmFtZSsnJnBhc3N3b3JkPScraG91c2VfZGF0YS5wYXNzd29yZCsnJnRhc2tfbmFtZT0nK25ld190YXNrX25hbWU7XFxuICAgIHRyeSB7XFxuICAgICAgICBsZXQgcmVzdWx0ID0gSlNPTi5wYXJzZShmZXRjaCh0YXNrX2FwaSx7fSkpO1xcbiAgICAgICAgaWYocmVzdWx0LnN0YXR1cz09MCl7XFxuICAgICAgICAgICAgcmV0dXJuICByZXN1bHQuZGV0YWlsXFxuICAgICAgICB9ZWxzZXtcXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdCsnJytyZXN1bHQuZGV0YWlsXFxuICAgICAgICB9XFxuICAgIH1jYXRjaCAoZSkge1xcbiAgICAgICAgbG9nKGUubWVzc2FnZSk7XFxuICAgICAgICByZXR1cm4gJycrZS5tZXNzYWdlXFxuICAgIH1cXG59XFxuXFxuZnVuY3Rpb24gdGFza19jaGFuZ2Vfc3RhdGUoaWQpe1xcbiAgICBjb25zdCB7YXBpLGdldEZpbGV9ID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvdXRpbGl5P3J1bGU96YGT6ZW/5LuT5bqTUHJvXFxcIik7XFxuICAgIGxldCBob3VzZUZpbGUgPSBnZXRGaWxlfHxmYWxzZTtcXG4gICAgaWYoIWhvdXNlRmlsZSl7XFxuICAgICAgICBzZXRJdGVtKCdpc19ob3VzZV92aXAnLCAnZmFsc2UnKTtcXG4gICAgfVxcbiAgICBsZXQgaG91c2VfZGF0YSA9IGhvdXNlRmlsZSgpO1xcbiAgICBsZXQgdGFza19hcGkgPSBhcGkuaG9zdCsnL2hpa2VydWxlL3Rhc2svY2hhbmdlX3N0YXRlLycraWQ7XFxuICAgIHRhc2tfYXBpID0gdGFza19hcGkrJz9uYW1lPScraG91c2VfZGF0YS51c2VybmFtZSsnJnBhc3N3b3JkPScraG91c2VfZGF0YS5wYXNzd29yZDtcXG4gICAgdHJ5IHtcXG4gICAgICAgIGxldCByZXN1bHQgPSBKU09OLnBhcnNlKGZldGNoKHRhc2tfYXBpLHt9KSk7XFxuICAgICAgICBpZihyZXN1bHQuc3RhdHVzPT0wKXtcXG4gICAgICAgICAgICByZXR1cm4gIHJlc3VsdC5kZXRhaWxcXG4gICAgICAgIH1lbHNle1xcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQucmVzdWx0KycnK3Jlc3VsdC5kZXRhaWxcXG4gICAgICAgIH1cXG4gICAgfWNhdGNoIChlKSB7XFxuICAgICAgICBsb2coZS5tZXNzYWdlKTtcXG4gICAgICAgIHJldHVybiAnJytlLm1lc3NhZ2VcXG4gICAgfVxcbn1cXG5cXG5mdW5jdGlvbiB0YXNrX3J1bihpZCl7XFxuICAgIGNvbnN0IHthcGl9ID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvdXRpbGl5P3J1bGU96YGT6ZW/5LuT5bqTUHJvXFxcIik7XFxuICAgIGxldCB0YXNrX2FwaSA9IGFwaS5ob3N0KycvaGlrZXJ1bGUvdGFzay9ydW4vJytpZDtcXG4gICAgbGV0IHRhc2sgPSB7fTtcXG4gICAgcmV0dXJuIHRhc2tfcmVxKHRhc2tfYXBpLHRhc2spO1xcbn1cXG5cXG4kLmV4cG9ydHMudGFza0NhbGwgPSB0YXNrX2NhbGw7XFxuJC5leHBvcnRzLnRhc2tSdW4gPSB0YXNrX3J1bjtcXG4kLmV4cG9ydHMudGFza1JlcSA9IHRhc2tfcmVxO1xcbiQuZXhwb3J0cy50YXNrVXBsb2FkID0gdGFza191cGxvYWQ7XFxuJC5leHBvcnRzLnRhc2tSZW5hbWUgPSB0YXNrX3JlbmFtZTtcXG4kLmV4cG9ydHMudGFza0NoYW5nZVN0YXRlID0gdGFza19jaGFuZ2Vfc3RhdGU7XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLlhajlsYDlgqjlrZhcIixcInBhdGhcIjpcImxvY2FsU3RvcmFnZVwiLFwicnVsZVwiOlwibGV0IGxvY2FsU3RvcmFnZSA9IChmdW5jdGlvbigpIHtcXG4gICAgZXZhbFByaXZhdGVKUyhcXFwiandVS3dOVGlQR2NXU0xDWEI1WHRBWHdiNkxRYlZ5SEQrMFhKN2wwN2NlMD1cXFwiKTtcXG4gICAgLy9wYXRodG89dW5kZWZpbmVkO1xcbiAgICBldmFsUHJpdmF0ZUpTKFxcXCI0QzBZeFJZbkdDWWtnRlJYdHBsL0N6NXpMNWhoNGpDQ3p0YituZytXb2t5bVE4b1VyelM5bEE4eXhDNWFGYWRuU0VteUhLTWJyYWZsUnFYQ25OUkhEbGs2dWU4eUhUTzE2bEJQcnB3Z3M1amYwUGhyQXRvVEpJRTBaSG45bUthUTRKZDJlcnFiNEk1NWJlV0lldWdLc0RzMjExU3pJTlE1eUpnU2gxZFZ1Tnp6eFJHSmc0MEZtVHVWbVhWZk4xeGcyV0lHSEJFbWtWbkd4bU9SaFBPTkErUTVWd1BtZHA0MS9oemUzZUlzVXZobzdWQ0JnSzRyYUptUGFsSVJCQlZsQ1ZnbjhGa1dtZktxWm8rVlcrb0JjSDdocmNyc1NsQ1NqQmFuZ1QvN3N5V0h4S1loZWhVMGthTVlqbldGZzFFbTBjbU5SdG9tQ3NIejFCOHEzMk9lUUhvYXdkV3h6S09hTUhPWERCalJvakE4RS9haDBXUk95emlxUlN4bC9tOGRoQmQwZjlwaFl6LzVTVS96SkQ1MlgvOUVDMTZXVlZkcFNXMzNha1JIUnNsUHBSbFRXRjkrQXlSbVJ3MGVaT0VzMW85UU1QQVFVZkF4Yll5RkhnenR3L08yZEpScEh5VG1pQmlhYXFUY2l2eDZ2OXp5dkJ6MDR3STFBYVNDdWkrZFR1VTNsdTV4ZEV0M0FqdDZaM2lEWE9WY0VQMEVERjc0NzRQUVU2SkVadXdlOTdTY2g0Ymkxd0IxWEhaU2ZJdGRsWVlvR2VkM0xMcGJtREFJUmNpdjByQW9wOFZtUWNUdDJLM0xmaDFSRFlZMFl0dlJjSDQ5T3ZwRFJIL3hhNUZjOE1ZM0RyRm9BN3Fjb0Y0ZUNnaVZCZkJnSlI2OCtMcFFLN3RPa2c4azllYyszTlN4SlRoY2w4ZDZ5Tnd4VDlUazE3emVKZ2Q2TW95WVpJcFdRTGxGNll2Yk9kRVdoam1uQTc4d0MwaFd6K1htNmhRTVNxdEZ3K2JoRmY3Y0JHVTNhYXRQRm1kQ1kyRWRYZmgwSVlXODV3ZE95TWZpd1c3L3ZWVHA5aUUwMEkzRjA5d0dIa0dLaFZiTHVlQWtZZTd6ekpYUjd0aGFGb3I2SDdxTG1KamJSUWs5ZXZOdEJRWE5SN0RpZmlYdVFmMmx0N25PSDgwU1dtMWZESEh6am1Qc05JcHMyVFhHVCtpd1ZWNjlnL3RXaXBWUTZEOEJUeCtjQ1FwNDdubVRJclkrcU40a2gyRlloNUxsd1hkZ0l5eTFWSXVDM3gwNTNld0FJSVVtbFk5bmlFcHFZdCsxZkZQWE9DdENHdFliU2QzN3ZWUjFFT2oyazVHdS8rOUpXZzJxdndsMXR3ZWxnMUowdHhhcklpNGtUYlRydnJuRkxOOTJwb2ZwWlFVZm9XbzRjZTdIV05kYnU0SktFcmFMUVVmZGZHRVBkMVRJdWZ1dVJWYTM5ZXE5R1p5U0R1Qkw2ME1QZGxkeEt3MXpvK2ZCNVpZK1lNajNMTDJnR3REYnM5OCtBc1JWOUxKV21VbXN4OTFobUp0RlVNV0QzeG5qOEhNWldzME5QbENGVXI5NDg1S3FUcG81a1J6R2ZGK2svTmwySnpydjVjdmtxdFVuTGdLcFhFT2ovc2Uvb0R6T0FyUUtJNVROVWJ2WXdjd2NkampNU2ZqSzY4S3J3aHMrbjZTbVdaNFpkZ1JIZ0FLNU1vRmkzWG1MVjQ3UDN2U1JXdTV6eUVzTWs0eTN1dUNGaXVSUFJsdTRRNXBKdnVPZW03SDdVTGlJaENlbXY1RGdrR3RETDFjR0w0RVFoWVJCNklTelZ2c2IyRWFQOXdRRTZEVlJuTTdPK3BuU3pldDZsenAzcEZkR25ib3gxTFJmQzYwdXRYWitDakltNGlFTW10YkIyTjV6RFNoR2JlTTNYVWJKUWRDQmlzOFhJcmhoMmJpQjVoQkNWd24zWTNldHQ3R0RQVnRvaTFHUmp6K0piZ00rWVI5MjhLYmRXUzV0RmFNTTNLajNYdjZvdEl4ek1CbkRDOXVXM2QrSVh4NnZMUEowSlJ1aDN5UDdwVGxhNmMzaVI0cDluV1lEcUorWlNtcHJIRm5ET3pzTFdtRmphcGplL01xd01KZDZUazNuQVd3aWNNT1B1WXBNeXFJRjA0Zmw0bXFndHNITFNNV1JSTkhQWmpFVFE5Z1JtZURZZTZhUnRsVzAycUwyb2xERU5xTFFNdEFkb2lyTldSY1A5VkwzVGQ4SGFVTzZmU2xHTmFiTWFrSkQvMDBYQ2hPU1VPSVArN2ZNN1YwL2wxYkxXUHRFejFpN0x5Z1RWN3BkR29EbnRxU0NFbkpyQnloQkF6TFJnNVFJYzk0MzhJaEtteWZuMC8zYXdvRDFJcjc4MGV5cC9YY0k2eE5jdzZUdi9FVGZIZzBlN2lZQzBVWWNKSUU1UVVYdjBzK1lvR0lFcTVHSXpLdWI4SE5qU1RVcHN2bmtWeCtkYmUyalJuM1liOVc3SkNaNVlTNkY1TXlVVnNwak1EN05ZYytEV2pVTDJiMnNWeUFmZVlwQzhVaGFoOXR1bWF2YkJ2N2EzYTlrZ0ZicTU4bHJIeHpZN2lKUVZpZ3pxM2UxYTJCU2IwUGNXMWFKOEJEN05rTnBoS1lheVR4eWtnd2lsRVJMOGpxcUJFbmlIVmRCeERKWUxiK1h3M2FsTG1sdHVURVY2S0d0Qm50QlgreXozNlJQRE15R0lLZSszZnpjeGZuQ0RuMjBNb2RWVmtWTm96UHFNWFowRzVMNGFMVEFRYWtZS1Vqc1ZNUWpBaFFrVGxIQmVPL2FMUHg5c3hsKytqMVo1ckxnRzEyVE40WEoxZWljdnc0QVZFNThMb3JhcTBRaUUwY1M3UEgxcGJyWldyZnQ3TFlHaXlCU2hvcjcrMGppb1VoMXBkV3EycU1ZTHFlTUVldUNST1F0NTdtRnJPanlQSDQ5cXA5N2NXT3JnZWcyV3lmV1NER1FQamU1K1AweVFvQ3BEL0QzUkFNdVdtYjl3bEJ0Y3EyajhXSlB0OTFFM2tLYXd1UUl5dmQycjJVang0K0hUTnRWS2I5a01MT084NUk2NWJOR0JIKzRpclN5NWdRWWxFMjZBMmNTR0ljTEtRUmx2Sm9NbmE3TC85d3lyeTRIek9yemtyQXZMZGdzU05sWWpwSFFFUmlPSTgwc0o1ak5DQ25mdzAxM0YrQStzQWZMbXlTL0JETE5RMXFhUTNwNmg4L0pxQWZoWDVPR0hnU2lSVk9DRWp1YURCL013Wk5DdTNRTDllaGhvQWo3dU9mOFBrcjNtSWpiaGg5SGlqc2p4MTkxKzBlMkpRckZhMDFBVkpLRVZ0dVB0SWMyaC8xcFBLTXZ5ZW54alRPMk94UG5qanQrODRuSUtLaHhESi9naFB0N2l2OFBtVEowbEtLeVBSc3NsOGYvUWRIZHh1cGI2alRzSTZVS216OVk0NlBNQnVENlAzd2g4cXAzNk82b2liTkRpUWQxc0UxMHZKaDl6MUZ5c0tJZThFcU1wbk5kRW1HMlRmRUJ4UnBtUXJoS0VxZWUwcDYrYTZzUW84Y1ZsUkprS1FBWUthd2NhTkVTNVhjNmRRWTVucWVpcThzVWl6ZjFzcGZIZUhlbER1MU02QlJYdUNqRmFmWGh6OGkzbFBXZ1lxVnBmeDEzaWdWQ1JmNDdVSDY1MnlMbnNtZXBDQldneUJUV0FjT3lGMVF4OFlHdFpub2IxVE4rNnhFd3pwY1dWeTdRTzlQOTJzS0E5U0srL05Ic3FmMTNDT3QwSkhDdFRWMU9sVFFXK0pBS3l4ZTFIbDcrczk1ejNLQ2dGS1FTKzNBczFKVjdOYStnK0xDUjJJZXZ1OGQ1RDBMN0d3b0RyZVV2NDM3NExSYUZrTnNIT3FXYlU5bmhRamRNVnI3YS9pOE8vNGhicHRhU3pxcWtnWUZpTkZVL29tVzVxd0l6N3NwNG5zY0lUUkUzZ3VhNmJ6a2xNWjhFQ24xaXFBV3QwYTZnZWtpNURhTDhxWWFwVENDaGpsV3NFeHFGdXhpV1AzNVRVQ2RkRWQ4QUNiTUdzK2dRRnlET296ZkJERzE3ZFpPMG1Dd1crUHpDTDJqYklDRE5haTUvam0xUXI2TUw1Nmp6VWFJRHowR0xQVFNhZXgxVUREd2tROW83bVhXQzBSN2pXbnpia0hSV2NvbVZiV21HcUwxcmpkb2Fjcy9SOXVqcVV1QkE2QTVWTC9xa1ExeEhMNDJFWG9vcHJDOHdycmZSNjh6TU1GeE93VTdDWUhKN2JoRy9RNHJOc1hEQmNNbzFBZGlxOUxYYlhtL1FKajB1L2pnWkdzc3owbm5LS1VGSmN4enVBTks5NnpXd2YxRFhhc1VjT29FdUVhdG0xcm1QNXdyQkptVy9ad1Q2YUJCaVIyT1NKMHhyOHRRNk9ibWRLanliKzFlRVhiMTQzN1IySWRoRFVkazVQUnp0SDJZRnQycG11TDQvTG1JTEZBdlBkaXlNdERITmorS2g0c1Y0TWxYYldQcnJJOTdZQk9GcEZsWCtnbmV3S0tmRlprSEU3ZGl0eTM0ZFVRMkduZTZzQUd4MXp4eWpadjVLQk0yNmxSSEY0NVhxRk5KMVJRM2hNeW1KSHN5WU5zTU80MUJXckd2MTlQQTQ2OGVjdzlIY1JOMHdoalVUZ25zOFpWYUM0aGlKc2dZMDdhQUVCSG05MC91aGhqTy9XbWI3d3VWYWRobDlSbkhlUWpweDRnd0NyTHo1aTVzNUl0MXNCd2ZEYjBGZStQQ3BMa2Mrd0lJTksyWTg2a1B0aFI2Z0p3Vzc1enVvTjVDMENBaUR3ZlU3M3ZhQVphaHpmNFZMTmxNMFUwNE90SFlCaTEzWWdQb05tR0hSZWxaVkV5Mkt1S1ZaZ2hEMTR2U2xZK0pyTUJEZG0yeTJ0aEZWK0JyaWhMNytmUTV3Y1lueEdlbGF3RHVvU1I1K2JERGtyNlJMNDBMNHh5ZkFoeGxyT24wdUEyOGdoR2VXZ3VhV0tFdjVuQnJydmV1MXVlVnkxTXZHVVlCWStJbEVyOE5kRE5SZG1Felh0MzlrR2xkODZ4T2ZBSC94TDFWbXVnYVhPR2FQQjJxYzdXRFJrVzZrNUY2bjNQa0l6ZFBYeU9OS3AxRGtPZzNvY1NNWk1UczZHS2o5QzN2T0RaNlpRcHdORFlMTVQrQ21FTDE4R1JqWE5jWmxQL0xuaGlBSXNjWVRMMStpSFdEWXZSbXZQTXd0T0hoQ25FWElVM0ZUYlArNlFSR0E2cXlkYm5uZXFWaFhvd2NMbWJNSXoxNklDMWt3aFpqNzUvTTUzc0tZWDJ6UmdPU1RBZk5TRC81bFpZU05VeEpmS1REZ2lhRkVnZ3JDcmQrM0NjK2NoenNsSTN6RFhFS1RydmxjWDJJbkM5dUgrZnN5cHlIdytBdlkyT21CR1FNSUljOGZFM3ROTzBnQlRWcVhzZHNFNzZZd0hyMjlkelFja3VzdXlKc0JmU1ZjbHJ2c05DWjFQUURMOEgzY1JzM0hFOW5Va3g1YmJKWVdzUHhiODI1Z25FcFdVOVo5S3R6dnNsaTcvaGVPbERLcEh4SmIxdUNyV3FmOGdSbldtcTN6ZlNTclVYQkhTTHU2Mk1ya1hUaldnYXBVVnhNR2tybnpSMEU0UE15MWJGY3lEcEVRZTE1VGF5V0JNMUI2anJJRyswRFJSOU9hQ1VQd0Q3ZXhObWpaYjlNODF1cytBSVJmeXpKUFpHbWZIdVQ5U056RmZOdVFkRlp5aVpWdGFZYW92V3VOMmlySTN6UWF0S0NEblFJWHByMFZoRzBHb3A4Yy96cm9XQm9OL2FWS21uOHNrU0Z2QURPam9aQWl4ZzZLMXk5d0ZpOHBlQ21pbUZaM1p6Q1ZzRzZFVTlTdmxicTUrd243RDZ5K2RBWWRhUG1zNGd3Q3JMejVpNXM1SXQxc0J3ZkRiejRYNFZ4cUlwY1RDOU5hWUtxQTdHS0srYVRyWldVd3dOMjFRT3RyOGVxeFNnSjFVOWVDT2NXWFFkK3AzNkd5NGZZK3Q5YzJDc1ZOYk5sMWdoeGE5Ykk4VTZlNkZUZC92dkJhcTlqcktkaXRxNG1OQ2Fpb2dtZlBLNk00OFVZSThqWk1DZGQvOUM4QnF2VWo0YllVNWJ5V0FTRUc2QkJHZEs4S2xmaS9hNExXdDNpdkM0dTlRQlRmYi92Q21OSmkvUUFmYWJjUEcrVXNXbXNZTlJLK2c4aE1jc3VCbWhoNDhOcGhSdmViVlFxcTZuY0t4YzFuRkhXTVc1TTZvZit6OGMxSGRkbmllRFA5R2FCc3EreXNsaktzbFlydDk4OVBZOXhzYm1rcjNYL29DZmlGVTROZmNPaGVlKytuZ1cwWHBaQVZ0MUkyUW5jMWFsd2Jub05xTU1oWElCOTVpa0x4U0ZxSDIyNlpxOXNHL3RyZHIyU0FWdXJueVdzZkhOanVJbEJXS0RPcmQ3VnJZRkp2UTl4YlZvbUtxUWp1aDlkemYybnZWckJ6YkVGMENaWTZpemtZL1JRWTVyOWs5My95Mk5HN28wN25NWWpPdFpZWWVOVW9pazdHYksvSHpRbDFTN3MvRkNobnQ5TTZmRTBVeXVQbXR0Tzk4aHF6eFFidGVNYWxNdFNjZTJXTGNqeVhWR2ZwcWRCa1l5bTRnWkJ5Y2NTNmFudHQ0b0xkbHVXU1NKc0hYMUljWGhReTZvSitBaGp3OWhGWXdYTEhQTG9DbzNqRWxpVUFLNDE3OXd0WXRIc08wYWJMeDQraG10TTVGejd3VVZhaEJBOXN1cE9UZi9GRDRzaVpNTW9mNVczdm01RGVkaHFHQU5saHQzbUk2Um1JaHY0OFFWdG5lTXNVellDNE5EaFpENE01UjZwN0dYQnFjcHUzRmFFRi8wSTBlM0xjZVgxSE4raURxS1JQdUd6dnBhYy8xdHNHUEl0ZUFEeHU5T1lvYXAyejNGMUN6U2cvVXVhOGwvS0V6dEFLRGN2YmhOVS9ZVWMybGhneGdmZGI0ZStQOVRaN1JhWDgyczYyN3UwQ2JGc2ZHRS8xaExwYjVNYzJ2azF1REdyZEljYldBNnhocFlBSFloRVlVbDljNzVZL1IvMGdsNnI5K202Y0kwQnZCWTVBYTVOQlJjNlVNdnNPL1BPdzVDY3I3OXNKemljZWFWM1l3cllFa2pwNktpK09Zckd1OTU0QUErZEo5V3N2TkdCRkdNcktBZlE5VlVDL0FUa0pmVGxvTWx0RGVWNUFvOXprYWF5M2RLQWE1L1B4QUdSREFVY1FMREY3dVZYYkQxdkZnRS8rUlhpd3pTNU43Y3IzYUZCZFJZN1hBbUZ6L2ZiMC9LU3BSOENRL2xva3BtTTJtbHRKOXZHUGdpcWI1blpsOUt1N2QyR2xnQWRpRVJoU1gxenZsajlIL1NCdWpCUG9PMWZwb091NUYzNWNkSGE1a1NGdkFET2pvWkFpeGc2SzF5OXdGbGowRXo1a3NVVzNXVTYzRTdlNHF0RFVDS1d3ampVNWYwRmQ1N1Z5VnpwQzZDZENTY0JqWVN6VDlyWkxWc2txNjFhT1dyRERVTktxQVEzK25YL0JCVzNjUVRFY09WZGMxNW5nVlhjU1MvYUsyUUZNZGlLUWxxbTE1ZkVySmR3cXllemE3aGZsS1RpQ3pVZHU1VkdsRlc5cUN0OHN5SG9vc0EyTnpmb3NKZFRkTjhiV0hub0RyNU4yNWV0K3AvbnZqak96WlJhTFlvWS9mci9rNWhxcHRPaz1cXFwiKTtcXG4gICAgcmV0dXJuICQuZXhwb3J0cztcXG59KSgpO1wifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwi57yW6L6R5YWs5ZGKXCIsXCJwYXRoXCI6XCJkZXZJbmZvRWRpdFwiLFwicnVsZVwiOlwianM6XFxuYWRkTGlzdGVuZXIoJ29uQ2xvc2UnLCAkLnRvU3RyaW5nKCgpPT57XFxuICAgIHB1dE15VmFyKFxcXCJkZXZJbmZvXFxcIiwnJyk7IC8v5riF6Zmk5Y6G5Y+y5YWs5ZGKXFxufSkpO1xcbnNldFBhZ2VUaXRsZSgn57yW6L6R5YWs5ZGKJyk7XFxuLy8gbGV0IHtub3dKeCxNeUppZXhpLGp4c1JvdXRlfSA9IE1ZX1BBUkFNUztcXG5jb25zdCB7Y29sb3Isc21hbGwsYXBpLCBnZXRGaWxlLGdldEFwaX0gPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS91dGlsaXlcXFwiKTtcXG4vLyBsZXQgaG91c2VGaWxlID0gZ2V0RmlsZXx8ZmFsc2U7XFxudmFyIGRldl9pbmZvX3VybCA9IGdldEFwaSgnaW5mb0dldFVybCcpO1xcbi8vIGxvZyhkZXZfaW5mb191cmwpO1xcbnZhciBnZXRfaW5mbyA9IGZ1bmN0aW9uKHFxKXtcXG4gICAgcXEgPSBxcXx8JzQzNDg1NzAwNSc7XFxuICAgIGxldCBkZXZfaW5mb191cmwgPSBkZXZfaW5mb191cmwrcXE7XFxuICAgIGxldCBiYWNrX2NvZGUgPSBKU09OLnBhcnNlKHJlcXVlc3QoZGV2X2luZm9fdXJsKSk7XFxuICAgIGxldCBkZXZfaW5mbz1iYWNrX2NvZGUucmVzdWx0fHxiYWNrX2NvZGUuZGV0YWlsO1xcbiAgICByZXR1cm4gZGV2X2luZm87XFxufTtcXG52YXIgYmVmb3JlX3JlZnJlc2ggPSBmdW5jdGlvbigpe1xcbiAgICBsZXQgZGV2X3NldF9pbmZvID0gZ2V0TXlWYXIoXFxcImRldl9zZXRfaW5mb1xcXCIpLnNwbGl0KCckJCcpO1xcbiAgICBsZXQgZGV2X2luZm9fdXJsID0gZGV2X3NldF9pbmZvLnNsaWNlKC0xKVswXTtcXG4gICAgbGV0IGJhY2tfY29kZSA9IEpTT04ucGFyc2UocmVxdWVzdChkZXZfaW5mb191cmwpKTtcXG4gICAgbGV0IGRldl9pbmZvPWJhY2tfY29kZS5yZXN1bHR8fGJhY2tfY29kZS5kZXRhaWw7XFxuICAgIHB1dE15VmFyKFxcXCJkZXZJbmZvXFxcIixkZXZfaW5mbyk7XFxuICAgIHJldHVybiBkZXZfaW5mb1xcbn07XFxubGV0IGQgPSBbXTtcXG5kLnB1c2goe1xcbiAgICB0aXRsZTon57yW6L6R5YWs5ZGKJyxcXG4gICAgZGVzYzon5pSv5oyBbWTor63ms5Us54K55Ye76L+b5YWl5a2m5LmgTWTor63ms5VcXFxcbuS/neWtmOWFrOWRiuaMiemSruWcqOaWh+acrOahhuacgOS4i+mdoicsXFxuICAgIGNvbF90eXBlOid0ZXh0XzEnLFxcbiAgICB1cmw6J2h0dHBzOi8vd3d3LnJ1bm9vYi5jb20vbWFya2Rvd24vbWQtdHV0b3JpYWwuaHRtbCdcXG59KTtcXG5kLnB1c2goe1xcbiAgICB0aXRsZTon6L+U5ZueJyxcXG4gICAgY29sX3R5cGU6J3RleHRfMicsXFxuICAgIHVybDokKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKCgpPT57XFxuICAgICAgICBiYWNrKGZhbHNlKTtcXG4gICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXG4gICAgfSlcXG59KTtcXG5pZighZ2V0TXlWYXIoJ2RldkluZm8nKSl7XFxuICAgIGJlZm9yZV9yZWZyZXNoKCk7XFxufVxcbmxldCBlbXB0eSA9ICdoaWtlcjovL2VtcHR5JztcXG5kLnB1c2goe1xcbiAgICB0aXRsZTon6ZiF6KeI5p+l6ZiFJyxcXG4gICAgY29sX3R5cGU6J3RleHRfMicsXFxuICAgIC8vIHVybDokKGdldE15VmFyKCdkZXZJbmZvJykpLmNvbmZpcm0oKVxcbiAgICB1cmw6JChlbXB0eSkucnVsZSgoKT0+e1xcbiAgICAgICAgcmVxdWlyZShcXFwiaHR0cHM6Ly9naXRsYWIuY29tL2hqZGhueC9oaWtlci8tL3Jhdy9tYWluL2pzL21hcmtlZC5taW4uanNcXFwiKTtcXG4gICAgICAgbGV0IGRldkluZm89XFxcIlxcXCI7XFxuICAgICAgIHRyeXtcXG4gICAgICAgICAgZGV2SW5mbz1tYXJrZWQucGFyc2UoZ2V0TXlWYXIoJ2RldkluZm8nKSk7XFxuICAgICAgIH1jYXRjaChlKXt9XFxuICAgICAgICBzZXRSZXN1bHQoW1xcbiAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6ZGV2SW5mbyxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6J3JpY2hfdGV4dCcsXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgXSk7XFxuICAgIH0pXFxufSk7XFxuZC5wdXNoKHtcXG4gICAgZGVzYzogXFxcIuW/q+adpee8lui+keS9oOeahOWFrOWRiuWQp35cXFwiLFxcbiAgICBjb2xfdHlwZTogJ2lucHV0JyxcXG4gICAgZXh0cmE6IHtcXG4gICAgICAgIHRpdGxlVmlzaWJsZTogZmFsc2UsXFxuICAgICAgICBkZWZhdWx0VmFsdWU6IGdldE15VmFyKCdkZXZJbmZvJywgJycpfHxcXFwiXFxcIixcXG4gICAgICAgIHR5cGU6IFxcXCJ0ZXh0YXJlYVxcXCIsXFxuICAgICAgICBoZWlnaHQ6LTEsXFxuICAgICAgICBvbkNoYW5nZTogJ3B1dE15VmFyKFxcXCJkZXZJbmZvXFxcIixpbnB1dCknXFxuICAgIH1cXG59KTtcXG5kLnB1c2goe1xcbiAgICB0aXRsZTpcXFwi5L+d5a2Y5YWs5ZGKXFxcIixcXG4gICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJyxcXG4gICAgdXJsOiQoJ+ehruiupOS/neWtmOWFrOWRiuWQl++8n+WwhuS8muS4jumBk+mVv+S7k+W6k+acjeWKoeWZqOmAmuiurycpLmNvbmZpcm0oKCk9PntcXG4gICAgICAgIGxldCBkZXZfc2V0X2luZm8gPSBnZXRNeVZhcihcXFwiZGV2X3NldF9pbmZvXFxcIikuc3BsaXQoJyQkJyk7XFxuICAgICAgICBsZXQgaW5wdXRfdGV4dCA9IGdldE15VmFyKCdkZXZJbmZvJywgJycpO1xcbiAgICAgICAgaWYoaW5wdXRfdGV4dC5sZW5ndGggPj0gNCl7XFxuICAgICAgICAgICAgbGV0IGluZm9fc2V0X3VybD0gZGV2X3NldF9pbmZvWzJdO1xcbiAgICAgICAgICAgIGxldCBzZW5kX2RhdGEgPSB7XFxcInBhcmFtc1xcXCI6XFxuICAgICAgICAgICAgICAgICAgICB7XFxcImRhdGFcXFwiOiB7XFxcImluZm9cXFwiOiBpbnB1dF90ZXh0fSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXFwibmFtZVxcXCI6IGRldl9zZXRfaW5mb1swXSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXFwicGFzc3dvcmRcXFwiOiBkZXZfc2V0X2luZm9bMV19XFxuICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICAvLyBsb2coc2VuZF9kYXRhKTtcXG4gICAgICAgICAgICBsZXQgcGFyMiA9IHtoZWFkZXJzOnsnY29udGVudC10eXBlJzonYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PVVURi04JywnVXNlci1BZ2VudCc6ZGV2X3NldF9pbmZvWzNdfSxib2R5OkpTT04uc3RyaW5naWZ5KHNlbmRfZGF0YSksbWV0aG9kOidQT1NUJ307XFxuICAgICAgICAgICAgLy8gcGFyMiA9IEpTT04uc3RyaW5naWZ5KHBhcjIpOyAvL3g16YeM6Z2i6K+35rGC5omN6ZyA6KaB57yW56CBXFxuICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgbGV0IGJhY2tfcmV0ID0gcmVxdWVzdChpbmZvX3NldF91cmwsIHBhcjIpO1xcbiAgICAgICAgICAgICAgICBiYWNrX3JldCA9IEpTT04ucGFyc2UoYmFja19yZXQpLnJlc3VsdDtcXG4gICAgICAgICAgICAgICAgaWYoYmFja19yZXQuc3RhdHVzPT09MCl7XFxuICAgICAgICAgICAgICAgICAgICAvLyByZWZyZXNoUGFnZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+S/neWtmOaIkOWKn1xcXFxuJytiYWNrX3JldC5kZXRhaWw7XFxuICAgICAgICAgICAgICAgIH1lbHNle1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+S/neWtmOWksei0pVxcXFxuJytiYWNrX3JldC5kZXRhaWw7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9Y2F0Y2ggKGUpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+mUmeivr1xcXFxuJytlLm1lc3NhZ2U7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfWVsc2V7XFxuICAgICAgICAgICAgY29uZmlybSh7dGl0bGU6J+mBk+mVv+aPkOekuicsY29udGVudDon6Jm954S25L2g5b6I5oeS77yM5L2G5piv5YWs5ZGK6Iez5bCR5YaZNOS4quWtl+WQp++8gSd9KTtcXG4gICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgICAgICB9XFxuICAgIH0pXFxufSk7XFxuXFxuc2V0UmVzdWx0KGQpO1wifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwi6aKE5aSE55CG5L6d6LWW5paH5Lu2XCIsXCJwYXRoXCI6XCJsaWJzXCIsXCJydWxlXCI6XCJpZihnZXRBcHBWZXJzaW9uKCk+PTMyMDApe1xcbiAgICB0cnl7XFxuICAgICAgICByYyhcXFwiaGlrZXI6Ly9maWxlcy9ydWxlcy9qcy8kaGlrZXIuanNcXFwiLCAtMSk7XFxuICAgICAgICAvLyQuc2V0Um9vdCgnaHR0cHM6Ly9oamRobnguY29kaW5nLm5ldC9wdWJsaWMvaGlrZXIvaGlrZXIvZ2l0L2ZpbGVzL21hc3Rlci9qcy8nKTtcXG4gICAgICAgICQuc2V0Um9vdCgpO1xcbiAgICAgICAgJC5zZXRMaWIoe1xcbiAgICAgICAgICAgIGxzZzogXFxcImxzZy5qc1xcXCIsIC8v5pys5Zyw5YKo5a2YXFxuICAgICAgICAgICAgZmlsZTogXFxcImZpbGUuanNcXFwiLCAvL+aWh+S7tm9zXFxuICAgICAgICAgICAgZmlsZVNlbGVjdDogXFxcImZpbGVTZWxlY3QuanNcXFwiLCAvL+aWh+S7tumAieaLqeWZqFxcbiAgICAgICAgICAgIGR0OiBcXFwiZHQuanNcXFwiLCAvL+WKqOaAgeWIhuexu1xcbiAgICAgICAgICAgIGRyOiBcXFwiZHIuanNcXFwiLCAvL2Ry5qih5p2/5L6d6LWWXFxuICAgICAgICAgICAgZHJwcmU6IFxcXCJkcnByZS5qc1xcXCIsIC8vZHLmqKHmnb/pooTlpITnkIZcXG4gICAgICAgICAgICBkcnVwOiBcXFwiZHJ1cC5qc1xcXCIsIC8vZHLmqKHmnb/oh6rliqjmm7TmlrBcXG4gICAgICAgICAgICBkcm1hdGNoOiBcXFwiZHJtYXRjaC5qc1xcXCIsIC8vZHLmqKHmnb/oh6rliqjmqKHmnb/ljLnphY1cXG4gICAgICAgICAgICBkcm06IFxcXCJkcm0uanNcXFwiLCAvL2Ry5qih5p2/5bCP56iL5bqPXFxuICAgICAgICAgICAgY21zOiBcXFwiY21zLmpzXFxcIiwgLy9jbXPmqKHmnb/kvp3otZZcXG4gICAgICAgICAgICBjbXNwcmU6IFxcXCJjbXNwcmUuanNcXFwiLCAvL2Ntc+mihOWkhOeQhlxcbiAgICAgICAgICAgIGNtc206IFxcXCJjbXNtLmpzXFxcIiwgLy9jbXPmqKHmnb/lsI/nqIvluo9cXG4gICAgICAgICAgICBsaWJjaGVjazogXFxcImxpYmNoZWNrLmpzXFxcIiwgLy9kcuajgOa1i+S+nei1llxcbiAgICAgICAgICAgIHJ1bGVFZGl0b3I6IFxcXCJydWxlRWRpdG9yLmpzXFxcIiwgLy/lhpnpobXmupDnpZ7lmajlsI/nqIvluo9cXG4gICAgICAgICAgICBob3VzZUxhenk6IFxcXCJob3VzZUxhenkuanNcXFwiLCAvL+S7k+W6k+mAmuWFjVxcbiAgICAgICAgICAgIGxhenk6IFxcXCJsYXp5LmpzXFxcIiwgLy/pppnlhY1cXG4gICAgICAgICAgICBzdWI6IFxcXCJzdWIuanNcXFwiLCAvL+mBk+W+t+e7j+iuoumYhVxcbiAgICAgICAgICAgIGhpa2VyVWk6IFxcXCJoaWtlclVpLmpzXFxcIiwgLy/mtbfpmJTnu4Tku7bkvp3otZZcXG4gICAgICAgICAgICBoaWtlckxpYnM6IFxcXCJoaWtlckxpYnMuanNcXFwiLCAvL+a1t+mYlOWFqOiDveS+nei1llxcbiAgICAgICAgfSk7XFxuICAgIH1jYXRjaChlKXtcXG4gICAgICAgIC8vdG9hc3QoJ+ivt+WwneivleeCueWHu+S7k+W6k+S4u+mhteeahOWNh+e6p+S7k+W6k+aXgei+ueeahOaMiemSruWNh+e6pyTmianlsZXvvIzlkKbliJnmn5Dkupvlip/og73kuI3og73mraPluLjkvb/nlKgnKTtcXG4gICAgICAgIGNvbmZpcm0oe1xcbiAgICAgICAgICAgIHRpdGxlOiAn5o+Q56S6LeeCueWHu+ehruWumuWPr+S7peWvvOWFpScsXFxuICAgICAgICAgICAgY29udGVudDogJ+ivt+WwneivleeCueWHu+S7k+W6k+S4u+mhteeahOWNh+e6p+S7k+W6k+aXgei+ueeahOaMiemSruWNh+e6pyTmianlsZXvvIzlkKbliJnmn5Dkupvlip/og73kuI3og73mraPluLjkvb/nlKgnLFxcbiAgICAgICAgICAgIGNvbmZpcm06ICQudG9TdHJpbmcoKCk9PntcXG4gICAgICAgICAgICAgICAgY29uc3Qge2dldEFwaX0gPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS91dGlsaXk/cnVsZT3pgZPplb/ku5PlupNQcm9cXFwiKTtcXG4gICAgICAgICAgICAgICAgbGV0IHJ1bGVIZWFkID0gJ+a1t+mYlOinhueVjO+8jOe9kemhteaPkuS7tu+/pWpzX3VybO+/pSRoaWtlckAnO1xcbiAgICAgICAgICAgICAgICBsZXQgdXJsID0gZ2V0QXBpKCdpbXBvcnRVcmwnKStcXFwiNTExMVxcXCI7XFxuICAgICAgICAgICAgICAgIGxldCBpbXBvcnRVcmwgPSAncnVsZTovLycrYmFzZTY0RW5jb2RlKHJ1bGVIZWFkK3VybCk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBpbXBvcnRVcmxcXG4gICAgICAgICAgICB9KSxcXG4gICAgICAgICAgICBjYW5jZWw6ICQudG9TdHJpbmcoKCk9PntcXG5cXG4gICAgICAgICAgICB9KSxcXG4gICAgICAgIH0pXFxuICAgIH1cXG59XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCJJbXBvcnTor6bnu4ZcIixcInBhdGhcIjpcInJ1bGVEZXRhaWxJbXBvcnRcIixcInJ1bGVcIjpcImpzOlxcbiQuZXhwb3J0cyA9IFxcXCJoaWtlcjovL3BhZ2UvcnVsZURldGFpbD9ydWxlPemBk+mVv+S7k+W6k1BybyZpZD1cXFwiICsgJC5pbXBvcnRQYXJhbTtcXG5cIn1dLFwicGFyYW1zXCI6XCJ7XFxcImlkXFxcIjo2MTk5LFxcXCJsdmVyXFxcIjotMX1cIixcInNhdmVkXCI6ZmFsc2UsXCJ0aXRsZVwiOlwi6YGT6ZW/5LuT5bqTUHJvXCIsXCJ2ZXJzaW9uXCI6MCxcInVybFwiOlwiaGlrZXI6Ly9wYWdlL3J1bGVEZXRhaWwjbm9IaXN0b3J5IyNub1JlY29yZEhpc3RvcnkjXCIsXCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwiZmluZF9ydWxlXCI6XCJqczpcXG4gICAgY29uc3Qge1xcbiAgICAgICAgZ2V0QXBpLFxcbiAgICAgICAgY29sb3IsXFxuICAgICAgICBzbWFsbCxcXG4gICAgICAgIGh0bWxUYWcsXFxuICAgICAgICBhcGksXFxuICAgICAgICBtZFxcbiAgICB9ID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvdXRpbGl5XFxcIik7XFxubGV0IHtcXG4gICAgaWQsXFxuICAgIGx2ZXIsXFxuICAgIGlzQWxsXFxufSA9IE1ZX1BBUkFNUztcXG5pZihnZXRQYXJhbShcXFwiaWRcXFwiKSl7XFxuICAgIGlzQWxsID0gdHJ1ZTtcXG4gICAgaWQgPSBnZXRQYXJhbShcXFwiaWRcXFwiKTtcXG4gICAgbHZlciA9IGx2ZXIgfHwgXFxcIuacquiOt+WPlueJiOacrOWPt1xcXCI7XFxufVxcbmFkZExpc3RlbmVyKCdvbkNsb3NlJywgJC50b1N0cmluZygoaXNBbGwpID0+IHtcXG4gICAgaWYoIWlzQWxsKXtcXG4gICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXG4gICAgfVxcbn0saXNBbGwpKTtcXG5sZXQgZGF0YUl0ZW0gPSBKU09OLnBhcnNlKHJlcXVlc3QoZ2V0QXBpKFxcXCJnZXRieWlkXFxcIikgKyBcXFwiP2lkPVxcXCIgKyBpZCkpLnJlc3VsdDtcXG5zZXRQYWdlVGl0bGUoXFxcIuOAjFxcXCIgKyBkYXRhSXRlbS5uYW1lICsgXFxcIuOAjVxcXCIpXFxubGV0IHJ1bGVMaXN0SnNvbiA9IGdldEFwaShcXFwicnVsZUxpc3RKc29uXFxcIikgKyBcXFwiP2lkPVxcXCI7XFxubGV0IGRhdGEgPSBbXTtcXG52YXIgaGFzU3ViID0gZmFsc2U7XFxuXFxuaWYgKGRhdGFJdGVtLmlzX2pzb25fbGlzdCkge1xcbiAgICBoYXNTdWIgPSBoYXNIb21lU3ViKHJ1bGVMaXN0SnNvbiArIGRhdGFJdGVtLmlkKTtcXG59IGVsc2UgaWYgKCFkYXRhSXRlbS5pc19qc29uX2xpc3QgJiYgZGF0YUl0ZW0uZGF0YV90eXBlID09ICdob21lX3J1bGVfdXJsJykge1xcbiAgICBoYXNTdWIgPSBoYXNIb21lU3ViKHJ1bGVMaXN0SnNvbiArIGRhdGFJdGVtLmlkICsgJyZkZWJ1Zz10cnVlJyk7XFxufVxcblxcbmRhdGEucHVzaCh7XFxuICAgIHRpdGxlOiBodG1sVGFnKFxcXCJiaWdcXFwiLCBcXFwi54mI5pysXFxcIiksXFxuICAgIGRlc2M6IFxcXCLigJzigJzigJ3igJ3lvIDlj5HogIXvvJpcXFwiICsgY29sb3IoZGF0YUl0ZW0uYXV0aG9yLCBcXFwiIzIyOEJFNlxcXCIpICsgXFxcIlxcXFxu5LqR56uv54mI5pys77yaXFxcIiArIGNvbG9yKGRhdGFJdGVtLnZlciwgXFxcIiM1Y2ZmMmNcXFwiKSArIFxcXCJcXFxcdFxcXFx05pys5Zyw54mI5pys77yaXFxcIiArIGNvbG9yKGx2ZXIsIFxcXCIjNWNmZjJjXFxcIikgKyBcXFwiXFxcXG7mm7TmlrDkuo46IFtcXFwiICsgY29sb3IoZGF0YUl0ZW0ubGFzdF91cGRhdGUsIFxcXCIjZmY3MDAwXFxcIikgKyBcXFwiXVxcXCIsXFxuICAgIHVybDogJChcXFwiPOW8gOWPkeiAhT5cXFxcblxcXCIgKyBkYXRhSXRlbS5hdXRob3IgKyBcXFwiXFxcXG485ZCN56ewPlxcXFxuXFxcIiArIGRhdGFJdGVtLm5hbWUgKyBcXFwiXFxcXG485LqR56uv54mI5pysPlxcXFxuXFxcIiArIGRhdGFJdGVtLnZlciArIFxcXCJcXFxcbjzmnKzlnLDniYjmnKw+XFxcXG5cXFwiICsgbHZlciArIFxcXCJcXFxcbjzmm7TmlrDml7bpl7Q+XFxcXG5bXFxcIiArIGRhdGFJdGVtLmxhc3RfdXBkYXRlICsgXFxcIl1cXFwiKS5jb25maXJtKCgpID0+IHt9KSxcXG4gICAgY29sX3R5cGU6ICd0ZXh0XzEnXFxufSk7XFxubGV0IGRhdGFUeXBlID0ge1xcbiAgICBob21lX3J1bGVfdXJsOiAn6aaW6aG15LqR6KeE5YiZJyxcXG4gICAgcHVibGlzaDogJ+aPkOS6pOS6keS7k+W6k+inhOWImScsXFxuICAgIGpzX3VybDogJ+e9kemhteaPkuS7tuinhOWImScsXFxuICAgIGh0bWw6ICfpnZnmgIHpobXpnaInLFxcbiAgICBjb25maWc6ICfkuLvpobXphY3nva4nXFxufTtcXG5cXG5sZXQgYmFzaWMgPSB7XFxuICAgIGNvbF90eXBlOiBcXFwidGV4dF8xXFxcIixcXG4gICAgdXJsOiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCJcXG59O1xcbmxldCBkYXRhVHlwZVRpcHMgPSBkYXRhVHlwZVtkYXRhSXRlbS5kYXRhX3R5cGVdIHx8ICfmnKrnn6Xop4TliJnvvJonICsgZGF0YUl0ZW0uZGF0YV90eXBlO1xcblxcbmxldCBzYWZlX3RpcD1kYXRhSXRlbS5pc19zYWZlP1xcXCLlronlhahcXFwiOlxcXCLljbHpmalcXFwiO1xcbmxldCBnb29kX3RpcCA9IGRhdGFJdGVtLmlzX2dvb2Q/c21hbGwoY29sb3IoXFxcIuOAkOS8mOi0qOinhOWImeOAkVxcXCIsJyNmZjcwMDAnKSk6XFxcIlxcXCI7XFxubGV0IG5vdF9zYWZlX25vdGU9ZGF0YUl0ZW0ubm90X3NhZmVfbm90ZTtcXG5iYXNpYy50aXRsZSA9IGh0bWxUYWcoXFxcImJpZ1xcXCIsIFxcXCLnsbvlnotcXFwiKSArIFxcXCJcXFxcdFxcXFx0XFxcXHRcXFwiICsgc21hbGwoXFxcIihpZDpcXFwiICsgZGF0YUl0ZW0uaWQgKyBcXFwiKVxcXCIpK1xcXCJcXFxcdFxcXFx0XFxcXHRcXFwiICsgc21hbGwoXFxcIijpo47pmanmo4DmtYs6XFxcIiArc2FmZV90aXArXFxcIilcXFwiKStnb29kX3RpcDtcXG5iYXNpYy5kZXNjID0gXFxcIuaVsOaNruexu+Wei++8mlxcXCIgKyBjb2xvcihkYXRhVHlwZVRpcHMsIFxcXCIjY2I1NGZmXFxcIikgKyBcXFwiXFxcXG7liIbkuqvnirbmgIHkuLrvvJpcXFwiICsgZGF0YUl0ZW0uc3RhdGU7XFxuaWYgKFtcXFwiaHRtbFxcXCIsIFxcXCJjb25maWdcXFwiLCBcXFwianNfdXJsXFxcIl0uaW5jbHVkZXMoZGF0YUl0ZW0uZGF0YV90eXBlKSkge1xcbiAgICBiYXNpYy5kZXNjICs9IFxcXCJcXFxcbuKAnOKAnOKAneKAnSA9PlxcXCIgKyBzbWFsbChcXFwi54K55q2k6aKE6KeIXFxcIik7XFxuICAgIGJhc2ljLnVybCA9IHJ1bGVMaXN0SnNvbiArIGRhdGFJdGVtLmlkO1xcbn1cXG5cXG5kYXRhLnB1c2goYmFzaWMpO1xcbmxldCBoYXNTdWJzID0gXFxcIlxcXCI7XFxuaWYgKGhhc1N1Yikge1xcbiAgICBoYXNTdWJzID0gXFxcIlxcXFx0XFxcXHRcXFxcdFxcXCIgKyBzbWFsbChcXFwi5bey6K6i6ZiFXFxcIilcXG59XFxuXFxubGV0IG5vdGVzID0gcmVxdWVzdChnZXRBcGkoXFxcImdldF9ydWxlX25vdGVcXFwiKSArIGlkKTtcXG5ub3RlcyA9IEpTT04ucGFyc2Uobm90ZXMpLnJlc3VsdDtcXG5yZXF1aXJlKG1kKTtcXG5sZXQgbm90ZXNIdG1sPVxcXCJcXFwiXFxudHJ5e1xcbiAgICBub3Rlc0h0bWw9bWFya2VkLnBhcnNlKG5vdGVzKTtcXG59Y2F0Y2goZSl7fVxcblxcbmlmIChub3RlcyAhPT0gZmFsc2UpIHtcXG4gICAgZGF0YS5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBodG1sVGFnKFxcXCJiaWdcXFwiLCBcXFwi5aSH5rOoXFxcIikgKyBcXFwiXFxcXHRcXFxcdFxcXFx0XFxcIiArIHNtYWxsKGh0bWxUYWcoXFxcInVcXFwiLCBcXFwi5p+l55yL5a6M5pW05YWs5ZGKID5cXFwiKSksXFxuICAgICAgICBkZXNjOiBub3RlcyxcXG4gICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF8xXFxcIixcXG4gICAgICAgIHVybDogXFxcImhpa2VyOi8vcGFnZS9pbmZvXFxcIixcXG4gICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgdGV4dDogbm90ZXNIdG1sLFxcbiAgICAgICAgICAgIG5hbWU6IGRhdGFJdGVtLm5hbWUsXFxuICAgICAgICAgICAgLy8gdHlwZTogXFxcImxvbmdfdGV4dFxcXCJcXG4gICAgICAgICAgICB0eXBlOiBcXFwicmljaF90ZXh0XFxcIlxcbiAgICAgICAgfVxcbiAgICB9KTtcXG59XFxuZGF0YS5wdXNoKHtcXG4gICAgdGl0bGU6IGh0bWxUYWcoXFxcImJpZ1xcXCIsIFxcXCLmk43kvZwo5YiG5Lqr6K+m57uG6aG1KVxcXCIpICsgaGFzU3VicyxcXG4gICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiLFxcbiAgICB1cmw6IFxcXCJjb3B5Oi8v6YGT6ZW/5LuT5bqT44CMXFxcIitkYXRhSXRlbS5uYW1lK1xcXCLjgI1cXFxcblxcXCIraWQrJ0BpbXBvcnQ9anM6JC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvcnVsZURldGFpbEltcG9ydD9ydWxlPemBk+mVv+S7k+W6k1Byb1xcXCIsIGlucHV0KSdcXG59KTtcXG5sZXQgaW1wb3J0VXJsLCBydWxlQ29kZSwgc2hhcmVVcmwsIGJhY2tDb2RlID0gXFxcIlxcXCI7XFxuaWYgKCFkYXRhSXRlbS5pc19qc29uKSB7XFxuICAgIGJhY2tDb2RlID0gcmVxdWVzdChydWxlTGlzdEpzb24gKyBkYXRhSXRlbS5pZCk7XFxufVxcbnN3aXRjaCAoZGF0YUl0ZW0uZGF0YV90eXBlKSB7XFxuICAgIGNhc2UgXFxcImhvbWVfcnVsZV91cmxcXFwiOlxcbiAgICAgICAgcnVsZUNvZGUgPSBcXFwi5rW36ZiU6KeG55WM6aaW6aG16aKR6YGT6KeE5YiZ44CQXFxcIiArIGRhdGFJdGVtLm5hbWUgKyBcXFwi44CR77+laG9tZV9ydWxlX3VybO+/pVxcXCIgKyBydWxlTGlzdEpzb24gKyBkYXRhSXRlbS5pZDtcXG4gICAgICAgIGltcG9ydFVybCA9IFxcXCJydWxlOi8vXFxcIiArIGJhc2U2NEVuY29kZShydWxlQ29kZSlcXG4gICAgICAgIGJyZWFrO1xcbiAgICBjYXNlICdwdWJsaXNoJzpcXG4gICAgICAgIHJ1bGVDb2RlID0gJ+a1t+mYlOinhueVjOinhOWImeWIhuS6q++8jOW9k+WJjeWIhuS6q+eahOaYr++8micgKyBkYXRhSXRlbS5uYW1lICsgJ++/pXB1Ymxpc2jvv6UnICsgYmFzZTY0RW5jb2RlKGJhY2tDb2RlKTtcXG4gICAgICAgIGltcG9ydFVybCA9ICdydWxlOi8vJyArIGJhc2U2NEVuY29kZShydWxlQ29kZSk7XFxuICAgICAgICBicmVhaztcXG4gICAgY2FzZSAnanNfdXJsJzpcXG4gICAgICAgIHJ1bGVDb2RlID0gJ+a1t+mYlOinhueVjOinhOWImeWIhuS6q++8jOW9k+WJjeWIhuS6q+eahOaYr++8mue9kemhteaPkuS7tu+/pWpzX3VybO+/pScgKyBkYXRhSXRlbS5uYW1lICsgJ0BiYXNlNjQ6Ly8nICsgYmFzZTY0RW5jb2RlKGJhY2tDb2RlKTtcXG4gICAgICAgIGltcG9ydFVybCA9ICdydWxlOi8vJyArIGJhc2U2NEVuY29kZShydWxlQ29kZSk7XFxuICAgICAgICBicmVhaztcXG4gICAgY2FzZSAnaHRtbCc6XFxuICAgICAgICBsZXQgZmlsZV90bXAgPSBkYXRhSXRlbS5uYW1lLnNwbGl0KCcuJyk7XFxuICAgICAgICBsZXQgZmlsZV9wYXRoID0gZmlsZV90bXAubGVuZ3RoID4gMSA/IGZpbGVfdG1wW2ZpbGVfdG1wLmxlbmd0aCAtIDFdICsgXFxcIi9cXFwiICsgZGF0YUl0ZW0ubmFtZSA6IGRhdGFJdGVtLm5hbWU7XFxuICAgICAgICBydWxlQ29kZSA9IFxcXCLmtbfpmJTop4bnlYzmnKzlnLDmlofku7bliIbkuqvvv6VmaWxlX3VybO+/pWhpa2VyOi8vZmlsZXMvcnVsZXMvZHpIb3VzZS9cXFwiICsgZmlsZV9wYXRoICsgXFxcIkBcXFwiICsgcnVsZUxpc3RKc29uICsgZGF0YUl0ZW0uaWQ7XFxuICAgICAgICBpbXBvcnRVcmwgPSAncnVsZTovLycgKyBiYXNlNjRFbmNvZGUocnVsZUNvZGUpO1xcbiAgICAgICAgYnJlYWtcXG4gICAgY2FzZSBcXFwiY29uZmlnXFxcIjpcXG4gICAgICAgIGltcG9ydFVybCA9ICQoKS5ydWxlKHBhc3N3b3JkID0+IHtcXG4gICAgICAgICAgICBldmFsKGZldGNoKFxcXCJoaWtlcjovL2Fzc2V0cy9ob21lLmpzXFxcIikpO1xcbiAgICAgICAgICAgIEhpa2VySG9tZS5sb2FkKFxcXCJpbXBvcnRcXFwiLCBwYXNzd29yZCk7XFxuICAgICAgICB9LCBiYWNrQ29kZSk7XFxuICAgICAgICBicmVhaztcXG59XFxubGV0IG15X2NvbF90eXBlID0gXFxcInRleHRfMlxcXCI7XFxubGV0IG15X2NvbF90eXBlMiA9IFxcXCJ0ZXh0XzNcXFwiO1xcbmlmIChpbXBvcnRVcmwpIHtcXG4gICAgZGF0YS5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBcXFwi5a+85YWl6KeE5YiZXFxcIixcXG4gICAgICAgIHVybDogZGF0YUl0ZW0uaXNfc2FmZT9pbXBvcnRVcmw6J3RvYXN0Oi8v6aOO6Zmp6KeE5YiZ56aB5q2i5a+85YWlISEhJyxcXG4gICAgICAgIGNvbF90eXBlOiBteV9jb2xfdHlwZVxcbiAgICB9KTtcXG59XFxuaWYgKHJ1bGVDb2RlKSB7XFxuICAgIGRhdGEucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIuWIhuS6q+WPo+S7pFxcXCIsXFxuICAgICAgICB1cmw6IFxcXCJjb3B5Oi8vXFxcIiArIHJ1bGVDb2RlLFxcbiAgICAgICAgY29sX3R5cGU6IG15X2NvbF90eXBlXFxuICAgIH0pO1xcbn1cXG5cXG5pZiAoaW1wb3J0VXJsKSB7XFxuICAgIGlmIChkYXRhSXRlbS5pc19qc29uX2xpc3QgJiYgIWhhc1N1Yikge1xcbiAgICAgICAgbGV0IHN1Yl9ydWxlX2NvZGUgPSAn5rW36ZiU6KeG55WM5ZCI6ZuG6KeE5YiZ6K6i6ZiF77+laG9tZV9zdWLvv6UnICsgZGF0YUl0ZW0ubmFtZSArIFxcXCJAQFxcXCIgKyBydWxlTGlzdEpzb24gKyBkYXRhSXRlbS5pZDtcXG4gICAgICAgIGxldCBzdWJfdXJsID0gJ3J1bGU6Ly8nICsgYmFzZTY0RW5jb2RlKHN1Yl9ydWxlX2NvZGUpO1xcbiAgICAgICAgZGF0YS5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogJ+iuoumYheWQiOmbhicsXFxuICAgICAgICAgICAgdXJsOiBzdWJfdXJsLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBteV9jb2xfdHlwZTJcXG4gICAgICAgIH0pO1xcbiAgICAgICAgZGF0YS5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogJ+KAnOKAnOKAneKAnTxzcGFuIHN0eWxlPVxcXCJjb2xvcjogI2ZmNzAwMFxcXCI+5a+85YWl6L275ZCI6ZuGPC9zcGFuPicsXFxuICAgICAgICAgICAgdXJsOiAkKCkubGF6eVJ1bGUoKGRhdGFJdGVtLHN1YlVybCk9PntcXG4gICAgICAgICAgICAgICAgY29uc3Qge2dlblJ1bGV9PSQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL2dlbkFwaVxcXCIpO1xcbiAgICAgICAgICAgICAgICBsZXQgaW1wb3J0X3J1bGU9Z2VuUnVsZShkYXRhSXRlbS5uYW1lK1xcXCIuXFxcIitkYXRhSXRlbS5hdXRob3Isc3ViVXJsKTtcXG4gICAgICAgICAgICAgICAgLy9jb3B5KGltcG9ydF9ydWxlKTtcXG4gICAgICAgICAgICAgICAgbGV0IHJ1bGVDb2RlPXBhcnNlUGFzdGUoaW1wb3J0X3J1bGUuc3BsaXQoXFxcIlxcXFxuXFxcIilbMF0pO1xcbiAgICAgICAgICAgICAgICAvL3JldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCJcXG4gICAgICAgICAgICAgICAgaW1wb3J0VXJsID0gJ3J1bGU6Ly8nICsgYmFzZTY0RW5jb2RlKHJ1bGVDb2RlKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGltcG9ydFVybFxcbiAgICAgICAgICAgIH0sZGF0YUl0ZW0scnVsZUxpc3RKc29uICsgZGF0YUl0ZW0uaWQpLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBteV9jb2xfdHlwZTJcXG4gICAgICAgIH0pO1xcbiAgICAgICAgZGF0YS5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogJ+KAnOKAnOKAneKAnTxzcGFuIHN0eWxlPVxcXCJjb2xvcjogI2ZmNzAwMFxcXCI+5a+85YWl6YGT5b6357uPPC9zcGFuPicsXFxuICAgICAgICAgICAgdXJsOiAkKCkubGF6eVJ1bGUoKGRhdGFJdGVtLHN1YlVybCk9PntcXG4gICAgICAgICAgICAgICAgLy8gbGV0IHRpdGxlID0gXFxcIkgtXFxcIitkYXRhSXRlbS5uYW1lK1xcXCIuXFxcIitkYXRhSXRlbS5hdXRob3I7XFxuICAgICAgICAgICAgICAgIGxldCB0aXRsZSA9IFxcXCJKLVxcXCIrZGF0YUl0ZW0ubmFtZS5zcGxpdCgnLicpWzBdO1xcbiAgICAgICAgICAgICAgICBsZXQgc3ViT2JqID0ge1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBzdWJVcmwsXFxuICAgICAgICAgICAgICAgICAgICBkZXNjOiBcXFwiaGlrZXI6Ly9maWxlcy9ydWxlcy9kekhvdXNlL3J1bGVDYWNoZS9cXFwiK3RpdGxlK1xcXCIuanNvblxcXCIsXFxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBcXFwiXFxcIixcXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZTogZmFsc2UsLy/npoHnlKjlubblj5Hmm7TmlrBcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBsZXQgc2hhcmVUZXh0ID0gYmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KHN1Yk9iaikpO1xcbiAgICAgICAgICAgICAgICB2YXIgcGFzdGVzID0gZ2V0UGFzdGVzKCk7XFxuICAgICAgICAgICAgICAgIHZhciB1cmwgPSBzaGFyZVBhc3RlKHNoYXJlVGV4dCxwYXN0ZXMuc2xpY2UoLTEpWzBdKTtcXG4gICAgICAgICAgICAgICAgbGV0IGltcG9ydF9ydWxlPSBcXFwi6L275ZCI6ZuG6K6i6ZiF77yaXFxcIit0aXRsZSsnXFxcXG4nK3VybDtcXG4gICAgICAgICAgICAgICAgY29weShpbXBvcnRfcnVsZSk7XFxuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSAnaGlrZXI6Ly9maWxlcy9ydWxlcy9kekhvdXNlL3J1bGVDYWNoZS9zdWIuanNvbic7XFxuICAgICAgICAgICAgICAgICQucmMoY29uZmlnLmxpYi5zdWIpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4g6K6i6ZiF5a+85YWlKHBhdGgpXFxuICAgICAgICAgICAgfSxkYXRhSXRlbSxydWxlTGlzdEpzb24gKyBkYXRhSXRlbS5pZCksXFxuICAgICAgICAgICAgY29sX3R5cGU6IG15X2NvbF90eXBlMlxcbiAgICAgICAgfSk7XFxuICAgICAgICBkYXRhLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiBcXFwiPHNtYWxsPuaPkOekuu+8muW8gOWPkeiAheWNleeLrOWIhuS6q+eahOWQiOmbhuaWh+S7tuWPquiDveWNleeLrOWvvOWFpeOAgjwvc21hbGw+XFxcIixcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcInJpY2hfdGV4dFxcXCJcXG4gICAgICAgIH0pO1xcbiAgICB9IGVsc2UgaWYgKCFkYXRhSXRlbS5pc19qc29uX2xpc3QgJiYgIWhhc1N1YiAmJiBkYXRhSXRlbS5kYXRhX3R5cGUgPT0gJ2hvbWVfcnVsZV91cmwnKSB7XFxuICAgICAgICBsZXQgc3ViX3J1bGVfY29kZSA9ICfmtbfpmJTop4bnlYzljZXop4TliJnorqLpmIXvv6Vob21lX3N1Yu+/pScgKyBkYXRhSXRlbS5uYW1lICsgXFxcIkBAXFxcIiArIHJ1bGVMaXN0SnNvbiArIGRhdGFJdGVtLmlkICsgJyZkZWJ1Zz10cnVlJztcXG4gICAgICAgIGxldCBzdWJfdXJsID0gJ3J1bGU6Ly8nICsgYmFzZTY0RW5jb2RlKHN1Yl9ydWxlX2NvZGUpO1xcbiAgICAgICAgZGF0YS5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogJ+iuoumYheinhOWImScsXFxuICAgICAgICAgICAgdXJsOiBzdWJfdXJsLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBteV9jb2xfdHlwZVxcbiAgICAgICAgfSlcXG4gICAgfVxcbn1cXG5pZiAoZGF0YUl0ZW0uaXNfanNvbiAmJiBkYXRhSXRlbS5kYXRhX3R5cGUgPT09IFxcXCJob21lX3J1bGVfdXJsXFxcIiAmJiAhZGF0YUl0ZW0uaXNfanNvbl9saXN0KSB7XFxuICAgIGRhdGEucHVzaCh7XFxuICAgICAgICB0aXRsZTogJ+i/m+WFpemikemBkycsXFxuICAgICAgICB1cmw6ICQoIC8qXFxcIiNub0xvYWRpbmcjXFxcIiovICkubGF6eVJ1bGUoKG5hbWUsaG9tZSkgPT4ge1xcbiAgICAgICAgICAgIGxldCBydWxlTGlzdCA9IEpTT04ucGFyc2UocmVxdWVzdChob21lKSk7XFxuICAgICAgICAgICAgbGV0IGhhc1J1bGUgPSBydWxlTGlzdC5zb21lKGl0ZW0gPT4gaXRlbS50aXRsZSA9PT0gbmFtZSk7XFxuICAgICAgICAgICAgaWYgKGhhc1J1bGUpIHtcXG4gICAgICAgICAgICAgICAgcHV0VmFyKFxcXCJXYXJlaG91c2UuYmFja1xcXCIsIFxcXCIxXFxcIik7XFxuICAgICAgICAgICAgICAgIGJhY2soKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvbWUrXFxcInNAXFxcIiArIG5hbWU7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+acquWuieijhVxcXCI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSwgZGF0YUl0ZW0ubmFtZSxhcGkuaG9tZSksXFxuICAgICAgICBjb2xfdHlwZTogbXlfY29sX3R5cGVcXG4gICAgfSlcXG59XFxubGV0IG1hbl9ydWxlX3NhZmUgPSBnZXRBcGkoXFxcIm1hblJ1bGVTYWZlXFxcIikrZGF0YUl0ZW0uaWQ7XFxubGV0IG1hbl9ydWxlX2dvb2QgPSBnZXRBcGkoXFxcIm1hblJ1bGVHb29kXFxcIikrZGF0YUl0ZW0uaWQ7XFxuLy8gZGF0YUl0ZW0uaXNfc2FmZTtcXG5pZihnZXRWYXIoJ2hvdXNlLmlzX21hbmFnZXInKSl7XFxuICAgIGZ1bmN0aW9uIHNldElzU2FmZShmbGFnLG1hbl9ydWxlX3NhZmUpIHtcXG4gICAgICAgIGZsYWcgPSBmbGFnIHx8ICcnO1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICBsZXQgY29kZSA9IGZldGNoKG1hbl9ydWxlX3NhZmUsIHtcXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xcXCJVc2VyLUFnZW50XFxcIjogTU9CSUxFX1VBfSxcXG4gICAgICAgICAgICAgICAgYm9keToge1xcbiAgICAgICAgICAgICAgICAgICAgXFxcInBhcmFtc1xcXCI6XFxuICAgICAgICAgICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFwidXNlcm5hbWVcXFwiOiBnZXRWYXIoJ2hvdXNlLnVzZXJuYW1lJyksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJwYXNzd29yZFxcXCI6IGdldFZhcignaG91c2UucGFzc3dvcmQnKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcImlzX3NhZmVcXFwiOiAhIWZsYWdcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBjb2RlID0gSlNPTi5wYXJzZShjb2RlKS5yZXN1bHQ7XFxuICAgICAgICAgICAgaWYgKGNvZGUuc3RhdHVzID09PSAwKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBjb2RlLmRldGFpbFxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiAn5pON5L2c5aSx6LSlOicgKyBjb2RlLmRldGFpbFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgICByZXR1cm4gJ+aTjeS9nOWksei0pTonICsgZS5tZXNzYWdlXFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgZnVuY3Rpb24gc2V0SXNHb29kKGZsYWcsbWFuX3J1bGVfZ29vZCkge1xcbiAgICAgICAgZmxhZyA9IGZsYWcgfHwgJyc7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIGxldCBjb2RlID0gZmV0Y2gobWFuX3J1bGVfZ29vZCwge1xcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxcIlVzZXItQWdlbnRcXFwiOiBNT0JJTEVfVUF9LFxcbiAgICAgICAgICAgICAgICBib2R5OiB7XFxuICAgICAgICAgICAgICAgICAgICBcXFwicGFyYW1zXFxcIjpcXG4gICAgICAgICAgICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJ1c2VybmFtZVxcXCI6IGdldFZhcignaG91c2UudXNlcm5hbWUnKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcInBhc3N3b3JkXFxcIjogZ2V0VmFyKCdob3VzZS5wYXNzd29yZCcpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFwiaXNfZ29vZFxcXCI6ICEhZmxhZ1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIGNvZGUgPSBKU09OLnBhcnNlKGNvZGUpLnJlc3VsdDtcXG4gICAgICAgICAgICBpZiAoY29kZS5zdGF0dXMgPT09IDApIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvZGUuZGV0YWlsXFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuICfmk43kvZzlpLHotKU6JyArIGNvZGUuZGV0YWlsXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgIHJldHVybiAn5pON5L2c5aSx6LSlOicgKyBlLm1lc3NhZ2VcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBkYXRhLnB1c2goe1xcbiAgICAgICAgdGl0bGU6J/Cfmqvpo47pmaknLFxcbiAgICAgICAgY29sX3R5cGU6J3Njcm9sbF9idXR0b24nLFxcbiAgICAgICAgdXJsOiQoJ+agh+iusOivpeinhOWImeS4uumjjumZqT/po47pmanop4TliJnml6Dms5Xooqvlr7zlhaUnKS5jb25maXJtKChpZCxtYW5fcnVsZV9zYWZlLHNldElzU2FmZSk9PntcXG4gICAgICAgICAgICBsZXQgcmV0ID0gc2V0SXNTYWZlKGZhbHNlLG1hbl9ydWxlX3NhZmUpO1xcbiAgICAgICAgICAgIGlmKCEv5pON5L2c5aSx6LSlLy50ZXN0KHJldCkpe1xcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly8nK3JldFxcbiAgICAgICAgfSxkYXRhSXRlbS5pZCxtYW5fcnVsZV9zYWZlLHNldElzU2FmZSlcXG4gICAgfSk7XFxuICAgIGRhdGEucHVzaCh7XFxuICAgICAgICB0aXRsZTon4pyF5q2j5bi4JyxcXG4gICAgICAgIGNvbF90eXBlOidzY3JvbGxfYnV0dG9uJyxcXG4gICAgICAgIHVybDokKCfmoIforrDor6Xop4TliJnkuLrmraPluLg/JykuY29uZmlybSgoaWQsbWFuX3J1bGVfc2FmZSxzZXRJc1NhZmUpPT57XFxuICAgICAgICAgICAgbGV0IHJldCA9IHNldElzU2FmZSh0cnVlLG1hbl9ydWxlX3NhZmUpO1xcbiAgICAgICAgICAgIGlmKCEv5pON5L2c5aSx6LSlLy50ZXN0KHJldCkpe1xcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly8nK3JldFxcbiAgICAgICAgfSxkYXRhSXRlbS5pZCxtYW5fcnVsZV9zYWZlLHNldElzU2FmZSlcXG4gICAgfSk7XFxuICAgIGRhdGEucHVzaCh7XFxuICAgICAgICB0aXRsZTon4pml6Z2e5LyY6LSoJyxcXG4gICAgICAgIGNvbF90eXBlOidzY3JvbGxfYnV0dG9uJyxcXG4gICAgICAgIHVybDokKCfmoIforrDor6Xop4TliJnkuLrpnZ7kvJjotKg/JykuY29uZmlybSgoaWQsbWFuX3J1bGVfZ29vZCxzZXRJc0dvb2QpPT57XFxuICAgICAgICAgICAgbGV0IHJldCA9IHNldElzR29vZChmYWxzZSxtYW5fcnVsZV9nb29kKTtcXG4gICAgICAgICAgICBpZighL+aTjeS9nOWksei0pS8udGVzdChyZXQpKXtcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8vJytyZXRcXG4gICAgICAgIH0sZGF0YUl0ZW0uaWQsbWFuX3J1bGVfZ29vZCxzZXRJc0dvb2QpXFxuICAgIH0pO1xcbiAgICBkYXRhLnB1c2goe1xcbiAgICAgICAgdGl0bGU6J/CfkpbkvJjotKgnLFxcbiAgICAgICAgY29sX3R5cGU6J3Njcm9sbF9idXR0b24nLFxcbiAgICAgICAgdXJsOiQoJ+agh+iusOivpeinhOWImeS4uuS8mOi0qD8nKS5jb25maXJtKChpZCxtYW5fcnVsZV9nb29kLHNldElzR29vZCk9PntcXG4gICAgICAgICAgICBsZXQgcmV0ID0gc2V0SXNHb29kKHRydWUsbWFuX3J1bGVfZ29vZCk7XFxuICAgICAgICAgICAgaWYoIS/mk43kvZzlpLHotKUvLnRlc3QocmV0KSl7XFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovLycrcmV0XFxuICAgICAgICB9LGRhdGFJdGVtLmlkLG1hbl9ydWxlX2dvb2Qsc2V0SXNHb29kKVxcbiAgICB9KTtcXG59XFxuXFxuZGF0YS5wdXNoKHtcXG4gICAgY29sX3R5cGU6IFxcXCJsaW5lX2JsYW5rXFxcIlxcbn0pO1xcbmRhdGEucHVzaCh7XFxuICAgIHRpdGxlOiBkYXRhSXRlbS5nb29kX251bSxcXG4gICAgcGljX3VybDogXFxcImhpa2VyOi8vZmlsZXMvaWNvbi/otZ4uc3ZnXFxcIixcXG4gICAgY29sX3R5cGU6IFxcXCJpY29uX3NtYWxsXzNcXFwiLFxcbiAgICB1cmw6IFxcXCJoaWtlcjovL3BhZ2UvTWFrZUFjb21tZW50I25vSGlzdG9yeSMjbm9SZWNvcmRIaXN0b3J5I1xcXCIsXFxuICAgIGV4dHJhOiB7XFxuICAgICAgICBpZDogZGF0YUl0ZW0uaWQsXFxuICAgICAgICBuYW1lOiBkYXRhSXRlbS5uYW1lXFxuICAgIH1cXG59KTtcXG5kYXRhLnB1c2goe1xcbiAgICB0aXRsZTogZGF0YUl0ZW0uYmFkX251bSxcXG4gICAgcGljX3VybDogXFxcImhpa2VyOi8vZmlsZXMvaWNvbi/ouKkuc3ZnXFxcIixcXG4gICAgY29sX3R5cGU6IFxcXCJpY29uX3NtYWxsXzNcXFwiLFxcbiAgICB1cmw6IFxcXCJoaWtlcjovL3BhZ2UvTWFrZUFjb21tZW50I25vSGlzdG9yeSMjbm9SZWNvcmRIaXN0b3J5I1xcXCIsXFxuICAgIGV4dHJhOiB7XFxuICAgICAgICBpZDogZGF0YUl0ZW0uaWQsXFxuICAgICAgICBuYW1lOiBkYXRhSXRlbS5uYW1lLFxcbiAgICAgICAgZGVmYXVsdFR5cGU6XFxcImJhZFxcXCJcXG4gICAgfVxcbn0pO1xcbmRhdGEucHVzaCh7XFxuICAgIHRpdGxlOiBcXFwi6K+E6K66XFxcIixcXG4gICAgcGljX3VybDogXFxcImhpa2VyOi8vZmlsZXMvaWNvbi/or4Torrouc3ZnXFxcIixcXG4gICAgY29sX3R5cGU6IFxcXCJpY29uX3NtYWxsXzNcXFwiLFxcbiAgICB1cmw6IFxcXCJoaWtlcjovL3BhZ2UvTWFrZUFjb21tZW50I25vSGlzdG9yeSMjbm9SZWNvcmRIaXN0b3J5I1xcXCIsXFxuICAgIGV4dHJhOiB7XFxuICAgICAgICBpZDogZGF0YUl0ZW0uaWQsXFxuICAgICAgICBuYW1lOiBkYXRhSXRlbS5uYW1lXFxuICAgIH1cXG59KTtcXG5sZXQgdG90YWxTdW0gPSBkYXRhSXRlbS5nb29kX251bSArIGRhdGFJdGVtLmJhZF9udW07XFxuXFxuZGF0YS5wdXNoKHtcXG4gICAgdGl0bGU6IGh0bWxUYWcoXFxcImJpZ1xcXCIsIFxcXCLor4TorrooXFxcIiArIHRvdGFsU3VtICsgXFxcIilcXFwiKSArIFxcXCJcXFxcdFxcXFx0XFxcXHRcXFwiICsgc21hbGwoaHRtbFRhZyhcXFwidVxcXCIsIFxcXCLmn6XnnIvlhajpg6jor4TorrogPlxcXCIpKSxcXG4gICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiLFxcbiAgICB1cmw6IFxcXCJoaWtlcjovL3BhZ2UvQ29tbWVudFxcXCIsXFxuICAgIGV4dHJhOiB7XFxuICAgICAgICB1cmw6IFxcXCJoaWtlcjovL2VtcHR5I2Z5cGFnZSNub0hpc3RvcnkjI25vUmVjb3JkSGlzdG9yeSNcXFwiLFxcbiAgICAgICAgaWQ6IGRhdGFJdGVtLmlkLFxcbiAgICAgICAgdG90YWxTdW06IHRvdGFsU3VtLFxcbiAgICAgICAgbm9fYWN0aXZlOiBmYWxzZVxcbiAgICB9XFxufSk7XFxuLy9jb25zdCBsb25nZXN0U3VtPTEyMDtcXG5sZXQgaWNvbiA9IHtcXG4gICAgXFxcImdvb2RcXFwiOiBcXFwi8J+RjVxcXCIsXFxuICAgIFxcXCJiYWRcXFwiOiBcXFwi8J+RjlxcXCIsXFxuICAgIFxcXCJyZXBseVxcXCI6XFxcIuW8gOWPkeiAhfCfl6NcXFwiXFxufVxcbmlmICh0b3RhbFN1bSA9PT0gMCkge1xcbiAgICBkYXRhLnB1c2goe1xcbiAgICAgICAgdGl0bGU6IFxcXCI8aDUgc3R5bGU9J3RleHQtYWxpZ246Y2VudGVyJz7kuIDmnaHor4TorrrkuZ/msqHmnInvvIzlv6vmnaXmiqLmspnlj5HlkKfvvIE8L2g1PlxcXCIsXFxuICAgICAgICBjb2xfdHlwZTogXFxcInJpY2hfdGV4dFxcXCJcXG4gICAgfSk7XFxufSBlbHNlIHtcXG4gICAgbGV0IGNvbW1lbnRMaXN0ID0gSlNPTi5wYXJzZShyZXF1ZXN0KGFwaS5kaXNfZ2V0ICsgZGF0YUl0ZW0uaWQgKyBcXFwiP2xpbWl0PTVcXFwiKSkucmVzdWx0O1xcbiAgICBmb3IgKGxldCBpdGVtIG9mIGNvbW1lbnRMaXN0KSB7XFxuICAgICAgICBsZXQgUmVwbHkgPSBpdGVtLmRpc2N1c3NfdHlwZT09PVxcXCJyZXBseVxcXCImJml0ZW0ucmVwbHlfdG9fbmFtZSE9PWZhbHNlJiZpdGVtLnJlcGx5X3RvX2lkIT09ZmFsc2U/XFxcIuKAmOKAmOWbnuWkjUBcXFwiK2l0ZW0ucmVwbHlfdG9fbmFtZStcXFwiICNcXFwiK2l0ZW0uZGlzY3Vzc19pZCtcXFwi4oCZ4oCZXFxcXG5cXFwiOlxcXCJcXFwiO1xcbiAgICAgICAgZGF0YS5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogaXRlbS5uYW1lICsgXFxcIiZuYnNwOyZuYnNwOzxmb250IGNvbG9yPSdncmF5Jz48c21hbGw+I1xcXCIgKyBpdGVtLmlkICsgXFxcIjwvc21hbGw+PGZvbnQ+XFxcIixcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcImF2YXRhclxcXCIsXFxuICAgICAgICAgICAgLy91cmw6IFxcXCJ0b2FzdDovL1xcXCIgKyBpdGVtLnFxLFxcbiAgICAgICAgICAgIHVybDpcXFwibXFxd3BhOi8vaW0vY2hhdD9jaGF0X3R5cGU9d3BhJnVpbj1cXFwiK2l0ZW0ucXEsXFxuICAgICAgICAgICAgcGljX3VybDogaXRlbS5hdmF0YXJfdXJsXFxuICAgICAgICB9KTtcXG4gICAgICAgIGRhdGEucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6IGl0ZW0uZGlzY3Vzc190ZXh0LFxcbiAgICAgICAgICAgIGRlc2M6IFJlcGx5K2l0ZW0uY3JlYXRlX2RhdGUgKyBcXFwiwrdcXFwiICsgaWNvbltpdGVtLmRpc2N1c3NfdHlwZV0sXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiLFxcbiAgICAgICAgICAgIHVybDogXFxcImhpa2VyOi8vcGFnZS9pbmZvXFxcIixcXG4gICAgICAgICAgICBleHRyYTp7XFxuICAgICAgICAgICAgICAgIG5hbWU6aXRlbS5uYW1lLFxcbiAgICAgICAgICAgICAgICB0eXBlOlxcXCJsb25nX3RleHRcXFwiLFxcbiAgICAgICAgICAgICAgICB0ZXh0Oml0ZW0uZGlzY3Vzc190ZXh0XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBwaWNfdXJsOiBpdGVtLmF2YXRhcl91cmxcXG4gICAgICAgIH0pO1xcbiAgICB9XFxuICAgIGRhdGEucHVzaCh7XFxuICAgICAgICBjb2xfdHlwZTogXFxcImxpbmVfYmxhbmtcXFwiXFxuICAgIH0pO1xcbn1cXG5cXG5zZXRSZXN1bHQoZGF0YSk7XCIsXCJncm91cFwiOlwi4pGg5o6o6I2QXCIsXCJ1YVwiOlwibW9iaWxlXCIsXCJwcmVSdWxlXCI6XCIkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9saWJzP3J1bGU96YGT6ZW/5LuT5bqTUHJvJyk7XCIsXCJwYWdlc1wiOlwiW3tcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIuW3peWFt1xcXCIsXFxcInBhdGhcXFwiOlxcXCJ1dGlsaXlcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5sZXQgaG9zdCA9IFxcXFxcXFwiaHR0cDovL2hpa2VyLm5va2lhLnByZXNzXFxcXFxcXCI7XFxcXG4vL2xldCBob3N0ID0gXFxcXFxcXCJodHRwOi8vMTkyLjE2OC4zLjk0OjgwNzlcXFxcXFxcIjtcXFxcbmxldCBob21lID0gYmFzZTY0RGVjb2RlKFxcXFxcXFwiYUdsclpYSTZMeTlvYjIxbFxcXFxcXFwiKTtcXFxcbnZhciBhcGkgPSB7XFxcXG4gICAgaG9zdDogaG9zdCtcXFxcXFxcIi9oaWtlcnVsZVxcXFxcXFwiLFxcXFxuICAgIHVzZXJzVXJsOiBcXFxcXFxcIi9kZXYvdXNlcnM/b3JkZXI9XFxcXFxcXCIsIC8v55So5oi35YiX6KGoXFxcXG4gICAgcnVsZUNvdW50VXJsOiBcXFxcXFxcIi9kZXYvcnVsZWNvdW50XFxcXFxcXCIsIC8v6I635Y+W6KeE5YiZ5pWw6YePXFxcXG4gICAgcnVsZXNVcmw6IFxcXFxcXFwiL2Rldi9nZXRcXFxcXFxcIiwgLy/nlKjmiLflr7nlupTnmoTop4TliJnliJfooajku4Xku4Xojrflj5blhazlvIBcXFxcbiAgICBydWxlc0FsbFVybDogXFxcXFxcXCIvZGV2L2dldGFsbFxcXFxcXFwiLCAvL+W8gOWPkeiAheWvueW6lOeahOinhOWImeWIl+ihqOWPr+iOt+WPluengeaciVxcXFxuICAgIGRldlNlbGY6Jy9kZXYvZ2V0c2VsZicsLy/ojrflj5blvIDlj5HogIXkv6Hmga9cXFxcbiAgICBtYW5DYW5VcGxvYWQ6Jy9zZXRfY2FuX3VwbG9hZC8nLC8v6LaF566h6K6+572u5byA5Y+R6ICF5piv5ZCm5Y+v5LiK5LygXFxcXG4gICAgbWFuUnVsZVNhZmU6Jy9zZXRfcnVsZV9zYWZlLycsLy/otoXnrqHorr7nva7op4TliJnlronlhajmgKdcXFxcbiAgICBtYW5SdWxlR29vZDonL3NldF9ydWxlX2dvb2QvJywvL+i2heeuoeiuvue9ruinhOWImeS8mOi0qOaAp1xcXFxuICAgIGltcG9ydFVybDogXFxcXFxcXCIvcnVsZWxpc3QuanNvbj9pZD1cXFxcXFxcIiwgLy/op4TliJnor6bmg4Xlj6/lr7zlhaVcXFxcbiAgICBpbmZvU2V0VXJsOiBcXFxcXFxcIi9kZXYvc2V0X2luZm9cXFxcXFxcIixcXFxcbiAgICBub3dDb25Vcmw6IFxcXFxcXFwiL3NxbF9pbmZvL2dldF9ub3dfY29uXFxcXFxcXCIsXFxcXG4gICAgaW5mb0dldFVybDogXFxcXFxcXCIvZGV2L2dldF9pbmZvP25hbWU9XFxcXFxcXCIsXFxcXG4gICAgc2V0dGluZ3NHZXRVcmw6IFxcXFxcXFwiL2Rldi9nZXRfc2V0dGluZ3M/bmFtZT1cXFxcXFxcIixcXFxcbiAgICBndXBsb2FkOiBcXFxcXFxcIi9kZXYvZ3VwbG9hZFxcXFxcXFwiLFxcXFxuICAgIGd0aW1lb3ZlcjogXFxcXFxcXCIvZGV2L2d0aW1lb3ZlclxcXFxcXFwiLFxcXFxuICAgIGdldGJ5aWQ6IFxcXFxcXFwiL2Rldi9nZXRieWlkXFxcXFxcXCIsXFxcXG4gICAgcnVsZUxpc3RKc29uOiBcXFxcXFxcIi9ydWxlbGlzdC5qc29uXFxcXFxcXCIsXFxcXG4gICAgYXV0aDogXFxcXFxcXCIvZGV2L2dldF9hdXRoXFxcXFxcXCIsXFxcXG4gICAgdGltZW92ZXI6IFxcXFxcXFwiL2Rldi90aW1lb3ZlclxcXFxcXFwiLFxcXFxuICAgIHNoYXJlOiBcXFxcXFxcIi9kZXYvc2hhcmVcXFxcXFxcIixcXFxcbiAgICBnZW5BdXRoOiBcXFxcXFxcIi9kZXYvZ2VuX2F1dGhcXFxcXFxcIixcXFxcbiAgICBkZWxldGVVcmw6IFxcXFxcXFwiL2Rldi9kZWxldGVcXFxcXFxcIixcXFxcbiAgICBqc29uTGlzdDogXFxcXFxcXCIvZGV2L2pzb25fbGlzdFxcXFxcXFwiLFxcXFxuICAgIHNlYXJjaDogXFxcXFxcXCIvZGV2L3NlYXJjaFxcXFxcXFwiLFxcXFxuICAgIG5ld19kZXY6IFxcXFxcXFwiL2Rldl9yZWdpc3QvbmV3XFxcXFxcXCIsXFxcXG4gICAgbmV3X2dldElkOiBcXFxcXFxcIi9kZXZfcmVnaXN0L2dldF9pZFxcXFxcXFwiLFxcXFxuICAgIG5ld19jb25maXJtOiBcXFxcXFxcIi9kZXZfcmVnaXN0L2NvbmZpcm1cXFxcXFxcIixcXFxcbiAgICBtb2RpZnlfcHdkOiBcXFxcXFxcIi9tb2RpZnkvcGFzc3dvcmRcXFxcXFxcIixcXFxcbiAgICBtb2RpZnlfbmFtZTogXFxcXFxcXCIvbW9kaWZ5L25hbWVcXFxcXFxcIixcXFxcbiAgICBtb2RpZnlfYXZhOiBcXFxcXFxcIi9tb2RpZnkvYXZhdGFyXFxcXFxcXCIsXFxcXG4gICAgdXNlcjogXFxcXFxcXCIvZGV2L3VzZXIvXFxcXFxcXCIsXFxcXG4gICAgZ2V0X3J1bGVfbm90ZTogXFxcXFxcXCIvbW9kaWZ5L2dldF9ydWxlX25vdGUvXFxcXFxcXCIsXFxcXG4gICAgc2V0X3J1bGVfcGljOiBcXFxcXFxcIi9tb2RpZnkvcnVsZV9waWMvXFxcXFxcXCIsXFxcXG4gICAgc2V0X3J1bGVfbm90ZTogXFxcXFxcXCIvbW9kaWZ5L3J1bGVfbm90ZS9cXFxcXFxcIlxcXFxufVxcXFxuJC5leHBvcnRzLnJhbmdlID0gZnVuY3Rpb24obSwgbikge1xcXFxuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobSAtIG4gKyAxKSArIG4pO1xcXFxufVxcXFxuJC5leHBvcnRzLm1hcENvbFR5cGUgPSBmdW5jdGlvbih0YXJnZXQsIHR5cGUsIG4pIHtcXFxcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xcXFxuICAgICAgICB0YXJnZXQucHVzaCh7XFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogdHlwZVxcXFxuICAgICAgICB9KTtcXFxcbiAgICB9XFxcXG59XFxcXG52YXIgZ2V0QXBpID0gZnVuY3Rpb24oaykge1xcXFxuICAgIHJldHVybiBhcGkuaG9zdCArIGFwaVtrXTtcXFxcbn07XFxcXG4kLmV4cG9ydHMuZ2V0QXBpPWdldEFwaTtcXFxcbiQuZXhwb3J0cy5tZD1nZXRBcGkoJ2ltcG9ydFVybCcpK1xcXFxcXFwiMzE4N1xcXFxcXFwiO1xcXFxuJC5leHBvcnRzLmxvY2FsUnVsZVZlciA9IGZ1bmN0aW9uKGxvY2FsUnVsZUxpc3QsIHJ1bGUpIHtcXFxcbiAgICBsZXQgbG9jYWxSdWxlO1xcXFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWxSdWxlTGlzdC5sZW5ndGg7IGkrKykge1xcXFxuICAgICAgICBsZXQgaXRlbSA9IGxvY2FsUnVsZUxpc3RbaV07XFxcXG4gICAgICAgIGxldCBhdSA9IGl0ZW0uYXV0aG9yIHx8IFxcXFxcXFwiXFxcXFxcXCI7XFxcXG4gICAgICAgIGxldCBzYW1lQXU9YXUubGVuZ3RoID4gMCAmJiBydWxlLmF1dGhvci5pbmNsdWRlcyhhdSk7XFxcXG4gICAgICAgIHNhbWVBdT10cnVlOy8v5LiN5Yik5pat5L2c6ICF6buY6K6k5Li6dHJ1ZVxcXFxuICAgICAgICBpZiAoaXRlbS50aXRsZSA9PT0gcnVsZS5uYW1lICYmIHNhbWVBdSkge1xcXFxuICAgICAgICAgICAgbG9jYWxSdWxlID0gaXRlbTtcXFxcbiAgICAgICAgICAgIGJyZWFrO1xcXFxuICAgICAgICB9XFxcXG4gICAgfVxcXFxuICAgIGlmIChsb2NhbFJ1bGUgPT09IHZvaWQgMCkge1xcXFxuICAgICAgICByZXR1cm4gLTE7XFxcXG4gICAgfSBlbHNlIHtcXFxcbiAgICAgICAgcmV0dXJuIGxvY2FsUnVsZS52ZXJzaW9uO1xcXFxuICAgIH1cXFxcbn1cXFxcbiQuZXhwb3J0cy5jb2xvciA9IGZ1bmN0aW9uKHRleHQsIGNvbG9yKSB7XFxcXG4gICAgdGV4dCArPSBcXFxcXFxcIlxcXFxcXFwiO1xcXFxuICAgIGlmICh0ZXh0LmluZGV4T2YoXFxcXFxcXCLigJzigJzigJ3igJ1cXFxcXFxcIikgPT09IDApIHtcXFxcbiAgICAgICAgdGV4dC5yZXBsYWNlKFxcXFxcXFwi4oCc4oCc4oCd4oCdXFxcXFxcXCIsIFxcXFxcXFwiXFxcXFxcXCIpO1xcXFxuICAgIH1cXFxcbiAgICByZXR1cm4gXFxcXFxcXCLigJzigJzigJ3igJ08Zm9udCBjb2xvcj0nXFxcXFxcXCIgKyBjb2xvciArIFxcXFxcXFwiJz5cXFxcXFxcIiArIHRleHQgKyBcXFxcXFxcIjwvZm9udD5cXFxcXFxcIjtcXFxcbn1cXFxcblxcXFxuJC5leHBvcnRzLnNsZWVwID0gZnVuY3Rpb24odGltZW91dCl7XFxcXG4gICAgamF2YS5sYW5nLlRocmVhZC5zbGVlcCh0aW1lb3V0KTtcXFxcbn1cXFxcbmZ1bmN0aW9uIGh0bWxUYWcodGFnLCB0ZXh0KSB7XFxcXG4gICAgdGV4dCArPSBcXFxcXFxcIlxcXFxcXFwiO1xcXFxuICAgIGlmICh0ZXh0LmluZGV4T2YoXFxcXFxcXCLigJzigJzigJ3igJ1cXFxcXFxcIikgPT09IDApIHtcXFxcbiAgICAgICAgdGV4dC5yZXBsYWNlKFxcXFxcXFwi4oCc4oCc4oCd4oCdXFxcXFxcXCIsIFxcXFxcXFwiXFxcXFxcXCIpO1xcXFxuICAgIH1cXFxcbiAgICByZXR1cm4gXFxcXFxcXCLigJzigJzigJ3igJ1cXFxcXFxcIiArIFxcXFxcXFwiPFxcXFxcXFwiICsgdGFnICsgXFxcXFxcXCI+XFxcXFxcXCIgKyB0ZXh0ICsgXFxcXFxcXCI8L1xcXFxcXFwiICsgdGFnICsgXFxcXFxcXCI+XFxcXFxcXCI7XFxcXG5cXFxcbn1cXFxcblxcXFxuZnVuY3Rpb24gZ2V0Tm93Rm9ybWF0RGF0ZSgpIHtcXFxcbiAgICAgICAgICAgIGxldCBkYXRlID0gbmV3IERhdGUoKTtcXFxcbiAgICAgICAgICAgIGxldCBzZXBlcmF0b3IxID0gXFxcXFxcXCItXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICBsZXQgc2VwZXJhdG9yMiA9IFxcXFxcXFwiOlxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgbGV0IG1vbnRoID0gZGF0ZS5nZXRNb250aCgpICsgMTtcXFxcbiAgICAgICAgICAgIGxldCBzdHJEYXRlID0gZGF0ZS5nZXREYXRlKCk7XFxcXG4gICAgICAgICAgICBsZXQgc3RySG91cnMgPSBkYXRlLmdldEhvdXJzKCk7XFxcXG4gICAgICAgICAgICBsZXQgc3RyTWludXRlcyA9IGRhdGUuZ2V0TWludXRlcygpO1xcXFxuICAgICAgICAgICAgbGV0IHN0clNlY29uZHMgPSBkYXRlLmdldFNlY29uZHMoKSsxO1xcXFxuICAgICAgICAgICAgaWYgKG1vbnRoID49IDEgJiYgbW9udGggPD0gOSkge1xcXFxuICAgICAgICAgICAgICAgIG1vbnRoID0gXFxcXFxcXCIwXFxcXFxcXCIgKyBtb250aFxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgaWYgKHN0ckRhdGUgPj0gMCAmJiBzdHJEYXRlIDw9IDkpIHtcXFxcbiAgICAgICAgICAgICAgICBzdHJEYXRlID0gXFxcXFxcXCIwXFxcXFxcXCIgKyBzdHJEYXRlXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICBpZiAoc3RySG91cnMgPj0gMCAmJiBzdHJIb3VycyA8PSA5KSB7XFxcXG4gICAgICAgICAgICAgICAgc3RySG91cnMgPSBcXFxcXFxcIjBcXFxcXFxcIiArIHN0ckhvdXJzXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICBpZiAoc3RyTWludXRlcyA+PSAwICYmIHN0ck1pbnV0ZXMgPD0gOSkge1xcXFxuICAgICAgICAgICAgICAgIHN0ck1pbnV0ZXMgPSBcXFxcXFxcIjBcXFxcXFxcIiArIHN0ck1pbnV0ZXNcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIGlmIChzdHJTZWNvbmRzID49IDAgJiYgc3RyU2Vjb25kcyA8PSA5KSB7XFxcXG4gICAgICAgICAgICAgICAgc3RyU2Vjb25kcyA9IFxcXFxcXFwiMFxcXFxcXFwiICsgc3RyU2Vjb25kc1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgLy9sZXQgY3VycmVudGRhdGUgPSBkYXRlLmdldEZ1bGxZZWFyKCkgKyBzZXBlcmF0b3IxICsgbW9udGggKyBzZXBlcmF0b3IxICsgc3RyRGF0ZSArIFxcXFxcXFwiIFxcXFxcXFwiICsgc3RySG91cnMgKyBzZXBlcmF0b3IyICsgc3RyTWludXRlcyArIHNlcGVyYXRvcjIgKyBzdHJTZWNvbmRzO1xcXFxuICAgICAgICAgICAgbGV0IGN1cnJlbnRkYXRlID0gKGRhdGUuZ2V0RnVsbFllYXIoKS0yMDIwKSsnJysgbW9udGggKycnKyBzdHJEYXRlICsnJysgc3RySG91cnMrJycgKyBzdHJNaW51dGVzICsnJysgTWF0aC5jZWlsKHN0clNlY29uZHMvNyk7XFxcXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoY3VycmVudGRhdGUpXFxcXG4gICAgICAgIH1cXFxcbiQuZXhwb3J0cy5nZXROb3dGb3JtYXREYXRlID0gZ2V0Tm93Rm9ybWF0RGF0ZTtcXFxcbiQuZXhwb3J0cy5odG1sVGFnID0gaHRtbFRhZztcXFxcbiQuZXhwb3J0cy5zbWFsbCA9IGZ1bmN0aW9uKHRleHQpIHtcXFxcbiAgICByZXR1cm4gaHRtbFRhZyhcXFxcXFxcInNtYWxsXFxcXFxcXCIsIHRleHQpO1xcXFxufVxcXFxuJC5leHBvcnRzLmdldEZpbGUgPSBmdW5jdGlvbigpIHtcXFxcbiAgICB2YXIgRmlsZSA9IHJlcXVlc3QoXFxcXFxcXCJoaWtlcjovL2ZpbGVzL1dhcmVob3VzZVVTRVIuanNvblxcXFxcXFwiKSB8fCBcXFxcXFxcInt9XFxcXFxcXCI7XFxcXG4gICAgdHJ5IHtcXFxcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoRmlsZSk7XFxcXG4gICAgfSBjYXRjaCAoZSkge1xcXFxuICAgICAgICB3cml0ZUZpbGUoXFxcXFxcXCJoaWtlcjovL2ZpbGVzL1dhcmVob3VzZVVTRVIuanNvblxcXFxcXFwiLCBcXFxcXFxcInt9XFxcXFxcXCIpO1xcXFxuICAgICAgICByZXR1cm4ge307XFxcXG4gICAgfVxcXFxufVxcXFxuJC5leHBvcnRzLmdldFVzZXJEYXRlID1mdW5jdGlvbigpe1xcXFxuICAgIHZhciBGaWxlID0gcmVxdWVzdChcXFxcXFxcImhpa2VyOi8vZmlsZXMvV2FyZWhvdXNlVVNFUkEuanNvblxcXFxcXFwiKSB8fCBcXFxcXFxcIltdXFxcXFxcXCI7XFxcXG4gICAgdHJ5IHtcXFxcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoRmlsZSk7XFxcXG4gICAgfSBjYXRjaCAoZSkge1xcXFxuICAgICAgICB3cml0ZUZpbGUoXFxcXFxcXCJoaWtlcjovL2ZpbGVzL1dhcmVob3VzZVVTRVJBLmpzb25cXFxcXFxcIiwgXFxcXFxcXCJbXVxcXFxcXFwiKTtcXFxcbiAgICAgICAgcmV0dXJuIFtdO1xcXFxuICAgIH1cXFxcbn1cXFxcbiQuZXhwb3J0cy5leGlzdEZpbGUgPSBmdW5jdGlvbihzcGF0aCwgaXBhdGgsIGhlYWRlcnMpIHtcXFxcbiAgICBsZXQgc2NvZGUgPSByZXF1ZXN0KHNwYXRoKTtcXFxcbiAgICBpZiAoIXNjb2RlKSB7XFxcXG4gICAgICAgIHdyaXRlRmlsZShzcGF0aCwgcmVxdWVzdChpcGF0aCwgaGVhZGVycykpO1xcXFxuICAgIH1cXFxcbn1cXFxcblxcXFxubGV0IG5ld0FwaSA9IHtcXFxcbiAgICBcXFxcXFxcImRpc19uZXdcXFxcXFxcIjogXFxcXFxcXCIvaGlrZXJ1bGUvbmV3X3J1bGVfZGlzY3Vzcy9cXFxcXFxcIixcXFxcbiAgICBcXFxcXFxcImRpc192ZXJpZnlcXFxcXFxcIjogXFxcXFxcXCIvaGlrZXJ1bGUvcnVsZV9kaXNjdXNzL2dldF95em1cXFxcXFxcIixcXFxcbiAgICBcXFxcXFxcImRpc19nZXRcXFxcXFxcIjogXFxcXFxcXCIvaGlrZXJ1bGUvcnVsZV9kaXNjdXNzL1xcXFxcXFwiLFxcXFxuICAgIFxcXFxcXFwiZGlzX3NldFxcXFxcXFwiOiBcXFxcXFxcIi9oaWtlcnVsZS9tb2RpZnkvY2FuX2Rpc2N1c3MvXFxcXFxcXCIsXFxcXG4gICAgXFxcXFxcXCJkaXNfbmV3X3VzZXJcXFxcXFxcIjogXFxcXFxcXCIvaGlrZXJ1bGUvcnVsZV9kaXNjdXNzL25ld191c2VyXFxcXFxcXCIsXFxcXG4gICAgXFxcXFxcXCJkaXNfbG9naW5cXFxcXFxcIjpcXFxcXFxcIi9oaWtlcnVsZS9ydWxlX2Rpc2N1c3MvdXNlcl9sb2dpblxcXFxcXFwiLFxcXFxuICAgIFxcXFxcXFwiZGlzX2Rldl9kaXNjdXNzXFxcXFxcXCI6XFxcXFxcXCIvaGlrZXJ1bGUvbW9kaWZ5L2Rldl9jYW5fZGlzY3Vzc1xcXFxcXFwiLFxcXFxuICAgIFxcXFxcXFwiZGlzX2Rldl9jb250cm9sXFxcXFxcXCI6XFxcXFxcXCIvaGlrZXJ1bGUvcnVsZV9kaXNjdXNzL3JlbW92ZS9cXFxcXFxcIixcXFxcbiAgICBcXFxcXFxcImFsbF9ydWxlXFxcXFxcXCI6XFxcXFxcXCIvaGlrZXJ1bGUvZ2V0X3J1bGVzXFxcXFxcXCIsXFxcXG4gICAgXFxcXFxcXCJkaXNfZ2V0X3JlcGx5XFxcXFxcXCI6XFxcXFxcXCIvaGlrZXJ1bGUvZ2V0X3JlcGx5X3J1bGVfZGlzY3Vzc1xcXFxcXFwiLFxcXFxuICAgIFxcXFxcXFwiZGlzX3JlcGx5XFxcXFxcXCI6XFxcXFxcXCIvaGlrZXJ1bGUvZGV2X25ld19ydWxlX2Rpc2N1c3MvXFxcXFxcXCIsXFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIHNldEFwaShvYmplY3QpIHtcXFxcbiAgICBsZXQgdGFyZ2V0ID0ge307XFxcXG4gICAgZm9yIChsZXQga2V5IGluIG9iamVjdCkge1xcXFxuICAgICAgICB0YXJnZXRba2V5XT1ob3N0K29iamVjdFtrZXldXFxcXG4gICAgfVxcXFxuICAgIHJldHVybiB0YXJnZXQ7XFxcXG59XFxcXG5cXFxcbiQuZXhwb3J0cy5hcGkgPSBzZXRBcGkobmV3QXBpKTtcXFxcbiQuZXhwb3J0cy5hcGkuaG9zdD1ob3N0O1xcXFxuJC5leHBvcnRzLmFwaS5ob21lPWhvbWU7XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5byA5Y+R6ICF55m75b2VXFxcIixcXFwicGF0aFxcXCI6XFxcImRldkxvZ2luXFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxuc2V0UGFnZVRpdGxlKFxcXFxcXFwi5byA5Y+R6ICF55m75b2VXFxcXFxcXCIpO1xcXFxuY29uc3Qge1xcXFxuICAgIGdldEFwaSxcXFxcbiAgICBodG1sVGFnLFxcXFxuICAgIG1hcENvbFR5cGUsXFxcXG4gICAgc21hbGwsXFxcXG5nZXRGaWxlXFxcXG59ID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3V0aWxpeVxcXFxcXFwiKTtcXFxcbnZhciBkYXRhID0gW107XFxcXG5hZGRMaXN0ZW5lcignb25DbG9zZScsICQudG9TdHJpbmcoKCk9PntcXFxcbiAgICBjbGVhclZhcihcXFxcXFxcIldhcmVob3VzZVVzZXJuYW1lXFxcXFxcXCIpO1xcXFxuICAgIGNsZWFyVmFyKFxcXFxcXFwiV2FyZWhvdXNlUGFzc3dvcmRcXFxcXFxcIik7XFxcXG59KSlcXFxcbmRhdGEucHVzaCh7XFxcXG4gICAgdGl0bGU6ICfotKblj7cnLFxcXFxuICAgIGNvbF90eXBlOiAnaW5wdXQnLFxcXFxuICAgIGV4dHJhOiB7XFxcXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogZ2V0VmFyKCdXYXJlaG91c2VVc2VybmFtZScsJycpLFxcXFxuICAgICAgICB0eXBlOlxcXFxcXFwibnVtYmVyXFxcXFxcXCIsXFxcXG4gICAgICAgIG9uQ2hhbmdlOiAncHV0VmFyKFxcXFxcXFwiV2FyZWhvdXNlVXNlcm5hbWVcXFxcXFxcIixpbnB1dCknXFxcXG4gICAgfVxcXFxufSwge1xcXFxuICAgIHRpdGxlOiAn5a+G56CBJyxcXFxcbiAgICBjb2xfdHlwZTogJ2lucHV0JyxcXFxcbiAgICBleHRyYToge1xcXFxuICAgICAgICBkZWZhdWx0VmFsdWU6IGdldFZhcignV2FyZWhvdXNlUGFzc3dvcmQnLCAnJyksXFxcXG4gICAgICAgIHR5cGU6IFxcXFxcXFwicGFzc3dvcmRcXFxcXFxcIixcXFxcbiAgICAgICAgb25DaGFuZ2U6ICdwdXRWYXIoXFxcXFxcXCJXYXJlaG91c2VQYXNzd29yZFxcXFxcXFwiLGlucHV0KSdcXFxcbiAgICB9XFxcXG59KTtcXFxcblxcXFxuZGF0YS5wdXNoKHtcXFxcbiAgICB0aXRsZTpcXFxcXFxcIiZuYnNwOyZuYnNwOzxhIGhyZWY9J2hpa2VyOi8vcGFnZS9SZWdpc3Rlcic+5rOo5YaMPC9hPlxcXFxcXFwiLFxcXFxuICAgIGNvbF90eXBlOlxcXFxcXFwicmljaF90ZXh0XFxcXFxcXCJcXFxcbn0pO1xcXFxubWFwQ29sVHlwZShkYXRhLCBcXFxcXFxcImxpbmVfYmxhbmtcXFxcXFxcIiwgMSk7XFxcXG5sZXQgdXNlciA9IGdldEZpbGUoKTtcXFxcbmRhdGEucHVzaCh7XFxcXG4gICAgdGl0bGU6IGh0bWxUYWcoXFxcXFxcXCJiXFxcXFxcXCIsIFxcXFxcXFwi55m75b2VXFxcXFxcXCIpLFxcXFxuICAgIHVybDogJCgpLmxhenlSdWxlKCh1cmwsIGYpPT4ge1xcXFxuICAgICAgICBsZXQgdXNlcm5hbWUgPSBnZXRWYXIoJ1dhcmVob3VzZVVzZXJuYW1lJywgJycpLFxcXFxuICAgICAgICAgICAgcGFzc3dvcmQgPSBnZXRWYXIoJ1dhcmVob3VzZVBhc3N3b3JkJywgJycpO1xcXFxuICAgICAgICBpZih1c2VybmFtZSA9PT0gXFxcXFxcXCJcXFxcXFxcIiAmJiBwYXNzd29yZCA9PT1cXFxcXFxcIlxcXFxcXFwiKXtcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v6LSm5Y+35ZKM5a+G56CB5LiN6IO95Li656m6XFxcXFxcXCJcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBsZXQgbXlVcmwgPSB1cmwgKyAnP3FxPScgKyB1c2VybmFtZSArICcmcGFzc3dvcmQ9JyArIHBhc3N3b3JkO1xcXFxuICAgICAgICBsZXQgY29kZV9zdHIgPSByZXF1ZXN0KG15VXJsKTtcXFxcbiAgICAgICAgbGV0IGNvZGUgPSBKU09OLnBhcnNlKGNvZGVfc3RyKTtcXFxcbiAgICAgICAgaWYgKGNvZGUuc3RhdHVzID09IDApIHtcXFxcbiAgICAgICAgICAgIGYudXNlcm5hbWU9dXNlcm5hbWU7XFxcXG4gICAgICAgICAgICBmLnBhc3N3b3JkPXBhc3N3b3JkXFxcXG4gICAgICAgICAgICB3cml0ZUZpbGUoJ2hpa2VyOi8vZmlsZXMvV2FyZWhvdXNlVVNFUi5qc29uJywgSlNPTi5zdHJpbmdpZnkoZikpO1xcXFxuICAgICAgICAgICAgYmFjaygpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/nmbvlvZXmiJDlip9cXFxcXFxcIjtcXFxcbiAgICAgICAgfWVsc2V7XFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+i0puWPt+aIluWvhueggemUmeivr1xcXFxcXFwiO1xcXFxuICAgICAgICB9XFxcXG4gICAgfSwgZ2V0QXBpKFxcXFxcXFwicnVsZXNBbGxVcmxcXFxcXFxcIiksdXNlciksXFxcXG4gICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJ1xcXFxufSk7XFxcXG5zZXRSZXN1bHQoZGF0YSk7XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcImljb25fMl9yb3VuZFxcXCIsXFxcIm5hbWVcXFwiOlxcXCLlvIDlj5HogIXnrqHnkIZcXFwiLFxcXCJwYXRoXFxcIjpcXFwiZGV2TWFuYWdlXFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxuc2V0UGFnZVRpdGxlKFxcXFxcXFwi6KeE5YiZ566h55CGXFxcXFxcXCIpO1xcXFxuYWRkTGlzdGVuZXIoJ29uQ2xvc2UnLCAnY2xlYXJWYXIoXFxcXFxcXCJXYXJlaG91c2UuYmFja1xcXFxcXFwiLFxcXFxcXFwiXFxcXFxcXCIpOycpO1xcXFxuaWYgKGdldFZhcihcXFxcXFxcIldhcmVob3VzZS5iYWNrXFxcXFxcXCIpID09PSBcXFxcXFxcIjFcXFxcXFxcIikge1xcXFxuICAgIGJhY2soKTtcXFxcbn1cXFxcbmNvbnN0IHtcXFxcbiAgICBnZXRBcGksXFxcXG4gICAgY29sb3IsXFxcXG4gICAgc21hbGwsXFxcXG4gICAgZ2V0RmlsZSxcXFxcbiAgICBleGlzdEZpbGUsXFxcXG4gICAgbWFwQ29sVHlwZSxcXFxcbiAgICBhcGlcXFxcbn0gPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvdXRpbGl5XFxcXFxcXCIpO1xcXFxubGV0IHtcXFxcbiAgICBkZXZcXFxcbn0gPSBNWV9QQVJBTVM7XFxcXG5sZXQge1xcXFxuICAgIHVzZXJuYW1lLFxcXFxuICAgIHBhc3N3b3JkLFxcXFxufSA9IGdldEZpbGUoKTtcXFxcbi8vZXhpc3RGaWxlKFxcXFxcXFwiaGlrZXI6Ly9maWxlcy9ydWxlcy9kekhvdXNlL2h0bWwv5byA5Y+R6ICF5YiG5LqrLmh0bWxcXFxcXFxcIiwgXFxcXFxcXCJodHRwczovL2VycC5zY3dpbmJhby5jb20vaGlrZXJ1bGUvcnVsZWxpc3QuanNvbj9pZD01MzlcXFxcXFxcIik7XFxcXG5sZXQgcnVsZUxpc3QgPSBKU09OLnBhcnNlKHJlcXVlc3QoZ2V0QXBpKFxcXFxcXFwicnVsZXNBbGxVcmxcXFxcXFxcIikgKyAnP3FxPScgKyB1c2VybmFtZSArICcmcGFzc3dvcmQ9JyArIHBhc3N3b3JkKSkucmVzdWx0O1xcXFxubGV0IE1PQklMRV9VQSA9ICdNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNS4wOyBTTS1HOTAwUCBCdWlsZC9MUlgyMVQpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS84OC4wLjQzMjQuMTQ2IE1vYmlsZSBTYWZhcmkvNTM3LjM2JztcXFxcbmxldCBpbmZvU2V0VXJsID0gZ2V0QXBpKFxcXFxcXFwiaW5mb1NldFVybFxcXFxcXFwiKTtcXFxcbmxldCBpbmZvR2V0VXJsID0gZ2V0QXBpKFxcXFxcXFwiaW5mb0dldFVybFxcXFxcXFwiKSArIHVzZXJuYW1lO1xcXFxubGV0IHNldHRpbmdzR2V0VXJsID0gZ2V0QXBpKFxcXFxcXFwic2V0dGluZ3NHZXRVcmxcXFxcXFxcIikgKyB1c2VybmFtZTtcXFxcbnB1dE15VmFyKFxcXFxcXFwiZGV2X3NldF9pbmZvXFxcXFxcXCIsIFt1c2VybmFtZSwgcGFzc3dvcmQsIGluZm9TZXRVcmwsIE1PQklMRV9VQSwgaW5mb0dldFVybF0uam9pbihcXFxcXFxcIiQkXFxcXFxcXCIpKTtcXFxcbmxldCBkYXRhID0gW107XFxcXG5kYXRhLnB1c2goe1xcXFxuICAgIHRpdGxlOiAn4oCc4oCc4oCd4oCdPGJpZz7ku5PlupPorr7nva48L2JpZz4mbmJzcDsmbmJzcDsmbmJzcDs8c21hbGw+PHU+77yIIOS4quS6uui1hOaWmSA+77yJPC91Pjwvc21hbGw+JyxcXFxcbiAgICBkZXNjOiAn4oCc4oCc4oCd4oCd5oKo5YWx5pyJIDxzcGFuIHN0eWxlPVxcXFxcXFwiY29sb3I6ICNmZjcwMDBcXFxcXFxcIj4nICsgcnVsZUxpc3QubGVuZ3RoICsgJzwvc3Bhbj4nICsgXFxcXFxcXCIg5p2h6KeE5YiZ44CCXFxcXFxcXFxu54K55Ye76KeE5YiZ5Y+v6L+b6KGM5YiG5Lqr44CB5Yig6Zmk44CB5a+85YWl5pON5L2c5Y+K5p+l55yL6K+m5oOFXFxcXFxcXCIsXFxcXG4gICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vcGFnZS9QZXJzb25hbERhdGEjbm9IaXN0b3J5IyNub1JlY29yZEhpc3RvcnkjXFxcXFxcXCIsXFxcXG4gICAgZXh0cmE6e2lkOmRldi5pZH0sXFxcXG4gICAgY29sX3R5cGU6ICd0ZXh0XzEnXFxcXG59KTtcXFxcbm1hcENvbFR5cGUoZGF0YSwgXFxcXFxcXCJsaW5lXFxcXFxcXCIsIDIpO1xcXFxuZGF0YS5wdXNoKHtcXFxcbiAgICB0aXRsZTogc21hbGwoY29sb3IoXFxcXFxcXCLmm7TmlLnlhazlkYrinI1cXFxcXFxcIiwgXFxcXFxcXCIjMzRiMWZmXFxcXFxcXCIpKSxcXFxcbiAgICAvLyB1cmw6IFxcXFxcXFwieDU6Ly9maWxlOi8vL3N0b3JhZ2UvZW11bGF0ZWQvMC9BbmRyb2lkL2RhdGEvY29tLmV4YW1wbGUuaGlrZXJ2aWV3L2ZpbGVzL0RvY3VtZW50cy9ydWxlcy9kekhvdXNlL2h0bWwvZGV2X2luZm9fZWRpdC5odG1sXFxcXFxcXCIsXFxcXG4gICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vcGFnZS9kZXZJbmZvRWRpdFxcXFxcXFwiLFxcXFxuICAgIGNvbF90eXBlOiAndGV4dF8zJ1xcXFxufSk7XFxcXG5kYXRhLnB1c2goe1xcXFxuICAgIHRpdGxlOiBzbWFsbChjb2xvcihcXFxcXFxcIuabtOWkmuWIhuS6q/Cfk7JcXFxcXFxcIiwgXFxcXFxcXCIjMzRiMWZmXFxcXFxcXCIpKSxcXFxcbiAgICAvL3VybDogXFxcXFxcXCJ4NTovL2ZpbGU6Ly8vc3RvcmFnZS9lbXVsYXRlZC8wL0FuZHJvaWQvZGF0YS9jb20uZXhhbXBsZS5oaWtlcnZpZXcvZmlsZXMvRG9jdW1lbnRzL3J1bGVzL2R6SG91c2UvaHRtbC/lvIDlj5HogIXliIbkuqsuaHRtbFxcXFxcXFwiLFxcXFxuICAgIHVybDogXFxcXFxcXCJoaWtlcjovL3BhZ2UvbW9yZVNoYXJlXFxcXFxcXCIsXFxcXG4gICAgY29sX3R5cGU6ICd0ZXh0XzMnXFxcXG59KTtcXFxcbmRhdGEucHVzaCh7XFxcXG4gICAgdGl0bGU6IHNtYWxsKGNvbG9yKFxcXFxcXFwi5Y2H57qn5L6d6LWW8J+TpVxcXFxcXFwiLCBcXFxcXFxcIiMzNGIxZmZcXFxcXFxcIikpLFxcXFxuICAgIHVybDogJChcXFxcXFxcIuWNh+e6p+S8mumHjeaWsOS7juS7k+W6k+aLieWPluebuOWFs+eahOmdmeaAgemhtemdouWIsOacrOWcsFxcXFxcXFxcbuehruiupOWNh+e6p+WQlz9cXFxcXFxcIikuY29uZmlybSgoaG9zdCkgPT4ge1xcXFxuICAgICAgICB3cml0ZUZpbGUoXFxcXFxcXCJoaWtlcjovL2ZpbGVzL3J1bGVzL2R6SG91c2UvaHRtbC/lvIDlj5HogIXliIbkuqsuaHRtbFxcXFxcXFwiLCByZXF1ZXN0KGhvc3QrJy9oaWtlcnVsZS9ydWxlbGlzdC5qc29uP2lkPTUzOScpKTtcXFxcbiAgICAgICAgd3JpdGVGaWxlKFxcXFxcXFwiaGlrZXI6Ly9maWxlcy9ydWxlcy9kekhvdXNlL2h0bWwvZGV2X2luZm9fZWRpdC5odG1sXFxcXFxcXCIsIHJlcXVlc3QoaG9zdCsnL2hpa2VydWxlL3J1bGVsaXN0Lmpzb24/aWQ9NDAyJykpO1xcXFxuICAgICAgICB3cml0ZUZpbGUoXFxcXFxcXCJoaWtlcjovL2ZpbGVzL3J1bGVzL2R6SG91c2UvaHRtbC9kZXZfaW5mb19nZXQuaHRtbFxcXFxcXFwiLCByZXF1ZXN0KGhvc3QrJy9oaWtlcnVsZS9ydWxlbGlzdC5qc29uP2lkPTQwNCcpKTtcXFxcbiAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcXFxuICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+W3sumHjee9ruW8gOWPkeiAheWIhuS6qyznroDku4vmn6XnnIss566A5LuL57yW6L6R562J6Z2Z5oCB5paH5Lu2XFxcXFxcXCI7XFxcXG4gICAgfSxhcGkuaG9zdCksXFxcXG4gICAgY29sX3R5cGU6ICd0ZXh0XzMnXFxcXG59KTtcXFxcbmxldCBkZXZTZXRCYWNrO1xcXFxudHJ5IHtcXFxcbiAgICBkZXZTZXRCYWNrID0gSlNPTi5wYXJzZShyZXF1ZXN0KHNldHRpbmdzR2V0VXJsKSk7XFxcXG59IGNhdGNoIChlKSB7XFxcXG4gICAgZGV2U2V0QmFjayA9IHt9O1xcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiBzZXRTZXR0aW5nSXRlbShiYXNpYykge1xcXFxuICAgIGxldCB0ZW1wID0ge1xcXFxuICAgICAgICB0aXRsZTogYmFzaWMudGl0bGUsXFxcXG4gICAgICAgIGNvbF90eXBlOiBiYXNpYy5jb2xfdHlwZSxcXFxcbiAgICAgICAgdXJsOiAkKGJhc2ljLmNvbmZpcm0pLmNvbmZpcm0oKHVybCwgbXNnKSA9PiB7XFxcXG4gICAgICAgICAgICBsZXQgYmFjayA9IHJlcXVlc3QodXJsKTtcXFxcbiAgICAgICAgICAgIGxldCByZXQgPSBKU09OLnBhcnNlKGJhY2spO1xcXFxuICAgICAgICAgICAgaWYgKHJldC5zdGF0dXMgPT0gMCkge1xcXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKHRydWUpO1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8vXFxcXFxcXCIgKyBtc2dbMF07XFxcXG4gICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL1xcXFxcXFwiICsgbXNnWzFdICsgXFxcXFxcXCJcXFxcXFxcXG5cXFxcXFxcIiArIHJldC5kZXRhaWw7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0sIGJhc2ljLnVybCwgYmFzaWMubXNnKVxcXFxuICAgIH07XFxcXG4gICAgcmV0dXJuIHRlbXA7XFxcXG59XFxcXG5pZiAoZGV2U2V0QmFjay5zdGF0dXMgPT0gMCkge1xcXFxuICAgIGxldCBkZXZTZXR0aW5ncyA9IGRldlNldEJhY2sucmVzdWx0O1xcXFxuICAgIGxldCBzaGFyZSA9IHtcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF8zXFxcXFxcXCJcXFxcbiAgICB9O1xcXFxuICAgIGlmIChkZXZTZXR0aW5ncy5zaGFyZV9wdWJsaWMpIHtcXFxcbiAgICAgICAgc2hhcmUudGl0bGUgPSBzbWFsbChjb2xvcihcXFxcXFxcIuWFrOW8gOS4iuS8oFxcXFxcXFwiLCBcXFxcXFxcImdyZWVuXFxcXFxcXCIpICsgY29sb3IoXFxcXFxcXCIo56eB6JePKVxcXFxcXFwiLCBcXFxcXFxcIiMwMGJmZmZcXFxcXFxcIikpO1xcXFxuICAgICAgICBzaGFyZS51cmwgPSBnZXRBcGkoXFxcXFxcXCJndXBsb2FkXFxcXFxcXCIpICsgXFxcXFxcXCI/cXE9XFxcXFxcXCIgKyB1c2VybmFtZSArIFxcXFxcXFwiJnBhc3N3b3JkPVxcXFxcXFwiICsgcGFzc3dvcmQgKyBcXFxcXFxcIiZmbGFnPTFcXFxcXFxcIjtcXFxcbiAgICAgICAgc2hhcmUuY29uZmlybSA9IFxcXFxcXFwi5piv5ZCm56Gu6K6k56eB6JeP5Lul5ZCO5o+Q5Lqk55qE6KeE5YiZP1xcXFxcXFwiO1xcXFxuICAgICAgICBzaGFyZS5tc2cgPSBbXFxcXFxcXCLlt7Lnp4Hol49cXFxcXFxcIiwgXFxcXFxcXCLnp4Hol4/lpLHotKVcXFxcXFxcIl07XFxcXG4gICAgfSBlbHNlIHtcXFxcbiAgICAgICAgc2hhcmUudGl0bGUgPSBzbWFsbChjb2xvcihcXFxcXFxcIuengeWvhuS4iuS8oFxcXFxcXFwiLCBcXFxcXFxcInJlZFxcXFxcXFwiKSArIGNvbG9yKFxcXFxcXFwiKOWFrOW8gClcXFxcXFxcIiwgXFxcXFxcXCIjYWRmZjJmXFxcXFxcXCIpKTtcXFxcbiAgICAgICAgc2hhcmUudXJsID0gZ2V0QXBpKFxcXFxcXFwiZ3VwbG9hZFxcXFxcXFwiKSArIFxcXFxcXFwiP3FxPVxcXFxcXFwiICsgdXNlcm5hbWUgKyBcXFxcXFxcIiZwYXNzd29yZD1cXFxcXFxcIiArIHBhc3N3b3JkO1xcXFxuICAgICAgICBzaGFyZS5jb25maXJtID0gXFxcXFxcXCLmmK/lkKbnoa7orqTlhazlvIDku6XlkI7mj5DkuqTnmoTop4TliJk/XFxcXFxcXCI7XFxcXG4gICAgICAgIHNoYXJlLm1zZyA9IFtcXFxcXFxcIuW3suWFrOW8gFxcXFxcXFwiLCBcXFxcXFxcIuWFrOW8gOWksei0pVxcXFxcXFwiXTtcXFxcbiAgICB9XFxcXG4gICAgZGF0YS5wdXNoKHNldFNldHRpbmdJdGVtKHNoYXJlKSk7XFxcXG4gICAgbGV0IHRpbWVPdmVyID0ge1xcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0XzNcXFxcXFxcIlxcXFxuICAgIH07XFxcXG4gICAgaWYgKGRldlNldHRpbmdzLnRpbWVfb3Zlcikge1xcXFxuICAgICAgICB0aW1lT3Zlci50aXRsZSA9IHNtYWxsKGNvbG9yKFxcXFxcXFwi55+t5pe256eY6ZKlXFxcXFxcXCIsIFxcXFxcXFwiZ3JlZW5cXFxcXFxcIikgKyBjb2xvcihcXFxcXFxcIijmsLjkuYUpXFxcXFxcXCIsIFxcXFxcXFwiIzAwYmZmZlxcXFxcXFwiKSk7XFxcXG4gICAgICAgIHRpbWVPdmVyLnVybCA9IGdldEFwaShcXFxcXFxcImd0aW1lb3ZlclxcXFxcXFwiKSArIFxcXFxcXFwiP3FxPVxcXFxcXFwiICsgdXNlcm5hbWUgKyBcXFxcXFxcIiZwYXNzd29yZD1cXFxcXFxcIiArIHBhc3N3b3JkICsgXFxcXFxcXCImZmxhZz0xXFxcXFxcXCI7XFxcXG4gICAgICAgIHRpbWVPdmVyLmNvbmZpcm0gPSBcXFxcXFxcIuaYr+WQpuehruiupOS7peWQjueahOengeiXj+inhOWImeWIhuS6q+S4jei/h+acnz9cXFxcXFxcIjtcXFxcbiAgICAgICAgdGltZU92ZXIubXNnID0gW1xcXFxcXFwi5bey6K6+5Li65rC45LmFXFxcXFxcXCIsIFxcXFxcXFwi6K6+5Li65rC45LmF5aSx6LSlXFxcXFxcXCJdO1xcXFxuICAgIH0gZWxzZSB7XFxcXG4gICAgICAgIHRpbWVPdmVyLnRpdGxlID0gc21hbGwoY29sb3IoXFxcXFxcXCLmsLjkuYXnp5jpkqVcXFxcXFxcIiwgXFxcXFxcXCJyZWRcXFxcXFxcIikgKyBjb2xvcihcXFxcXFxcIijov4fmnJ8pXFxcXFxcXCIsIFxcXFxcXFwiI2FkZmYyZlxcXFxcXFwiKSk7XFxcXG4gICAgICAgIHRpbWVPdmVyLnVybCA9IGdldEFwaShcXFxcXFxcImd0aW1lb3ZlclxcXFxcXFwiKSArIFxcXFxcXFwiP3FxPVxcXFxcXFwiICsgdXNlcm5hbWUgKyBcXFxcXFxcIiZwYXNzd29yZD1cXFxcXFxcIiArIHBhc3N3b3JkO1xcXFxuICAgICAgICB0aW1lT3Zlci5jb25maXJtID0gXFxcXFxcXCLnoa7orqTopoHku6XlkI7liIbkuqvnmoTnp4Hol4/op4TliJnoh6rliqjliLDmnJ8/XFxcXFxcXCI7XFxcXG4gICAgICAgIHRpbWVPdmVyLm1zZyA9IFtcXFxcXFxcIuW3suiuvuS4uui/h+acn1xcXFxcXFwiLCBcXFxcXFxcIuiuvuS4uui/h+acn+Wksei0pVxcXFxcXFwiXTtcXFxcbiAgICB9XFxcXG4gICAgZGF0YS5wdXNoKHNldFNldHRpbmdJdGVtKHRpbWVPdmVyKSk7XFxcXG4gICAgbGV0IGRpc2N1c3MgPSB7XFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfM1xcXFxcXFwiXFxcXG4gICAgfTtcXFxcbiAgICBpZiAoZGV2U2V0dGluZ3MuY2FuX2Rpc2N1c3MpIHtcXFxcbiAgICAgICAgZGlzY3Vzcy50aXRsZSA9IHNtYWxsKGNvbG9yKFxcXFxcXFwi5YWB6K646K+E6K66XFxcXFxcXCIsIFxcXFxcXFwicmVkXFxcXFxcXCIpICsgY29sb3IoXFxcXFxcXCIo5LiN6K64KVxcXFxcXFwiLCBcXFxcXFxcIiNhZGZmMmZcXFxcXFxcIikpO1xcXFxuICAgICAgICBkaXNjdXNzLnVybCA9IGFwaS5kaXNfZGV2X2Rpc2N1c3MgKyBcXFxcXFxcIj9xcT1cXFxcXFxcIiArIHVzZXJuYW1lICsgXFxcXFxcXCImcGFzc3dvcmQ9XFxcXFxcXCIgKyBwYXNzd29yZCsgXFxcXFxcXCImZmxhZz0xXFxcXFxcXCI7XFxcXG4gICAgICAgIGRpc2N1c3MuY29uZmlybSA9IFxcXFxcXFwi5piv5ZCm56Gu6K6k5Lul5ZCO5LiK5Lyg55qE6KeE5YiZ5YWB6K646K+E6K66P1xcXFxcXFwiO1xcXFxuICAgICAgICBkaXNjdXNzLm1zZyA9IFtcXFxcXFxcIuW3suiuvuS4uuS4jeiuuFxcXFxcXFwiLCBcXFxcXFxcIuiuvue9ruWksei0pVxcXFxcXFwiXTtcXFxcblxcXFxuICAgIH0gZWxzZSB7XFxcXG4gICAgICAgIGRpc2N1c3MudGl0bGUgPSBzbWFsbChjb2xvcihcXFxcXFxcIuS4jeiuuOivhOiuulxcXFxcXFwiLCBcXFxcXFxcImdyZWVuXFxcXFxcXCIpICsgY29sb3IoXFxcXFxcXCIo5YWB6K64KVxcXFxcXFwiLCBcXFxcXFxcIiMwMGJmZmZcXFxcXFxcIikpO1xcXFxuICAgICAgICBkaXNjdXNzLnVybCA9IGFwaS5kaXNfZGV2X2Rpc2N1c3MgKyBcXFxcXFxcIj9xcT1cXFxcXFxcIiArIHVzZXJuYW1lICsgXFxcXFxcXCImcGFzc3dvcmQ9XFxcXFxcXCIgKyBwYXNzd29yZDtcXFxcbiAgICAgICAgZGlzY3Vzcy5jb25maXJtID0gXFxcXFxcXCLmmK/lkKbnoa7orqTku6XlkI7kuIrkvKDnmoTop4TliJnlhYHorrjor4Torro/XFxcXFxcXCI7XFxcXG4gICAgICAgIGRpc2N1c3MubXNnID0gW1xcXFxcXFwi5bey6K6+5Li65YWB6K64XFxcXFxcXCIsIFxcXFxcXFwi6K6+572u5aSx6LSlXFxcXFxcXCJdO1xcXFxuICAgIH1cXFxcbiAgICBkYXRhLnB1c2goc2V0U2V0dGluZ0l0ZW0oZGlzY3VzcykpO1xcXFxufVxcXFxubWFwQ29sVHlwZShkYXRhLCBcXFxcXFxcImxpbmVcXFxcXFxcIiwgMik7XFxcXG5mb3IgKGxldCBpdGVtIG9mIHJ1bGVMaXN0KSB7XFxcXG4gICAgbGV0IG15X3RfZXhjb2RlMSA9ICcnO1xcXFxuICAgIGxldCBteV90X2V4Y29kZTIgPSAnJztcXFxcbiAgICBpZiAoaXRlbS5zdGF0ZSAhPSAncHVibGljJykge1xcXFxuICAgICAgICBteV90X2V4Y29kZTEgKz0gJ+OKme+4jyc7XFxcXG4gICAgfSBlbHNlIHtcXFxcbiAgICAgICAgbXlfdF9leGNvZGUxICs9ICcnO1xcXFxuICAgIH1cXFxcbiAgICBkYXRhLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogbXlfdF9leGNvZGUxICsgaXRlbS5uYW1lICsgbXlfdF9leGNvZGUyLFxcXFxuICAgICAgICB1cmw6IFxcXFxcXFwiaGlrZXI6Ly9wYWdlL21hbmFnZVJ1bGUjbm9IaXN0b3J5IyNub1JlY29yZEhpc3RvcnkjXFxcXFxcXCIsXFxcXG4gICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICBpZDogaXRlbS5pZCxcXFxcbiAgICAgICAgICAgIC8vdXNlcm5hbWU6IHVzZXJuYW1lLFxcXFxuICAgICAgICAgICAgLy9wYXNzd29yZDogcGFzc3dvcmRcXFxcbiAgICAgICAgfSxcXFxcbiAgICAgICAgcGljX3VybDogaXRlbS5waWMsXFxcXG4gICAgfSlcXFxcbn1cXFxcbmlmIChydWxlTGlzdC5sZW5ndGggPT09IDApIHtcXFxcbiAgICBkYXRhLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogXFxcXFxcXCI8aDUgc3R5bGU9J3RleHQtYWxpZ246Y2VudGVyJz7lv6vmnaXkuIrkvKDkvaDnmoTnrKzkuIDmnaHop4TliJnlkKfvvIE8L2g1PlxcXFxcXFwiLFxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJyaWNoX3RleHRcXFxcXFxcIlxcXFxuICAgIH0pO1xcXFxufVxcXFxuc2V0UmVzdWx0KGRhdGEpO1xcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIuinhOWImeivpue7hi1kZXZcXFwiLFxcXCJwYXRoXFxcIjpcXFwibWFuYWdlUnVsZVxcXCIsXFxcInJ1bGVcXFwiOlxcXCJqczpcXFxcbiAgICBjb25zdCB7XFxcXG4gICAgICAgIGdldEFwaSxcXFxcbiAgICAgICAgY29sb3IsXFxcXG4gICAgICAgIHNtYWxsLFxcXFxuICAgICAgICBnZXRGaWxlLFxcXFxuICAgICAgICBleGlzdEZpbGUsXFxcXG4gICAgICAgIG1hcENvbFR5cGUsXFxcXG4gICAgICAgIGh0bWxUYWcsXFxcXG4gICAgICAgIGFwaSxcXFxcbiAgICAgICAgbWQsXFxcXG4gICAgfSA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS91dGlsaXlcXFxcXFxcIik7XFxcXG5sZXQge1xcXFxuICAgIGlkXFxcXG59ID0gTVlfUEFSQU1TO1xcXFxubGV0IHtcXFxcbiAgICB1c2VybmFtZSxcXFxcbiAgICBwYXNzd29yZCxcXFxcbn0gPSBnZXRGaWxlKCk7XFxcXG5hZGRMaXN0ZW5lcignb25DbG9zZScsICQudG9TdHJpbmcoKCkgPT4ge1xcXFxuICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXFxcbn0pKTtcXFxcbmxldCBkYXRhSXRlbSA9IEpTT04ucGFyc2UocmVxdWVzdChnZXRBcGkoXFxcXFxcXCJnZXRieWlkXFxcXFxcXCIpICsgXFxcXFxcXCI/aWQ9XFxcXFxcXCIgKyBpZCkpLnJlc3VsdDtcXFxcbnNldFBhZ2VUaXRsZShcXFxcXFxcIue8lui+keOAjFxcXFxcXFwiICsgZGF0YUl0ZW0ubmFtZSArIFxcXFxcXFwi44CNXFxcXFxcXCIpO1xcXFxubGV0IHJlcUJ5R2V0ID0gXFxcXFxcXCI/aWQ9XFxcXFxcXCIgKyBkYXRhSXRlbS5pZCArIFxcXFxcXFwiJnFxPVxcXFxcXFwiICsgdXNlcm5hbWUgKyBcXFxcXFxcIiZwYXNzd29yZD1cXFxcXFxcIiArIHBhc3N3b3JkO1xcXFxubGV0IHJ1bGVMaXN0SnNvbiA9IGdldEFwaShcXFxcXFxcInJ1bGVMaXN0SnNvblxcXFxcXFwiKSArIFxcXFxcXFwiP2lkPVxcXFxcXFwiO1xcXFxubGV0IGRhdGEgPSBbXTtcXFxcbmRhdGEucHVzaCh7XFxcXG4gICAgdGl0bGU6IGh0bWxUYWcoXFxcXFxcXCJiaWdcXFxcXFxcIiwgXFxcXFxcXCLniYjmnKxcXFxcXFxcIiksXFxcXG4gICAgZGVzYzogXFxcXFxcXCLigJzigJzigJ3igJ3kupHnq6/niYjmnKw6XFxcXFxcXCIgKyBjb2xvcihkYXRhSXRlbS52ZXIsIFxcXFxcXFwiIzVjZmYyY1xcXFxcXFwiKSArIFxcXFxcXFwiXFxcXFxcXFxu5LiK5qyh5o+Q5Lqk5LqOOiBbXFxcXFxcXCIgKyBjb2xvcihkYXRhSXRlbS5sYXN0X3VwZGF0ZSwgXFxcXFxcXCIjZmY3MDAwXFxcXFxcXCIpICsgXFxcXFxcXCJdXFxcXFxcXCIsXFxcXG4gICAgdXJsOiAkKFxcXFxcXFwiPOW8gOWPkeiAhT5cXFxcXFxcXG5cXFxcXFxcIiArIGRhdGFJdGVtLmF1dGhvciArIFxcXFxcXFwiXFxcXFxcXFxuPOWQjeensD5cXFxcXFxcXG5cXFxcXFxcIiArIGRhdGFJdGVtLm5hbWUgKyBcXFxcXFxcIlxcXFxcXFxcbjzkupHnq6/niYjmnKw+XFxcXFxcXFxuXFxcXFxcXCIgKyBkYXRhSXRlbS52ZXIgKyBcXFxcXFxcIlxcXFxcXFxcbjzmm7TmlrDml7bpl7Q+XFxcXFxcXFxuW1xcXFxcXFwiICsgZGF0YUl0ZW0ubGFzdF91cGRhdGUgKyBcXFxcXFxcIl1cXFxcXFxcIikuY29uZmlybSgoKSA9PiB7fSksXFxcXG4gICAgY29sX3R5cGU6ICd0ZXh0XzEnXFxcXG59KTtcXFxcbmxldCBkYXRhVHlwZSA9IHtcXFxcbiAgICBob21lX3J1bGVfdXJsOiAn6aaW6aG15LqR6KeE5YiZJyxcXFxcbiAgICBwdWJsaXNoOiAn5o+Q5Lqk5LqR5LuT5bqT6KeE5YiZJyxcXFxcbiAgICBqc191cmw6ICfnvZHpobXmj5Lku7bop4TliJknLFxcXFxuICAgIGh0bWw6ICfpnZnmgIHpobXpnaInLFxcXFxuICAgIGNvbmZpZzogJ+S4u+mhtemFjee9ridcXFxcbn07XFxcXG5cXFxcbmxldCBiYXNpYyA9IHtcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0XzFcXFxcXFxcIixcXFxcbiAgICB1cmw6IFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiXFxcXG59O1xcXFxubGV0IGRhdGFUeXBlVGlwcyA9IGRhdGFUeXBlW2RhdGFJdGVtLmRhdGFfdHlwZV0gfHwgJ+acquefpeinhOWImTonICsgZGF0YUl0ZW0uZGF0YV90eXBlO1xcXFxuXFxcXG5iYXNpYy50aXRsZSA9IGh0bWxUYWcoXFxcXFxcXCJiaWdcXFxcXFxcIiwgXFxcXFxcXCLnsbvlnotcXFxcXFxcIikgKyBcXFxcXFxcIlxcXFxcXFxcdFxcXFxcXFxcdFxcXFxcXFxcdFxcXFxcXFwiICsgc21hbGwoXFxcXFxcXCIoaWQ6XFxcXFxcXCIgKyBkYXRhSXRlbS5pZCArIFxcXFxcXFwiKVxcXFxcXFwiKTtcXFxcbmJhc2ljLmRlc2MgPSBcXFxcXFxcIuaVsOaNruexu+Wei++8mlxcXFxcXFwiICsgY29sb3IoZGF0YVR5cGVUaXBzLCBcXFxcXFxcIiNjYjU0ZmZcXFxcXFxcIikgKyBcXFxcXFxcIlxcXFxcXFxcbuWIhuS6q+eKtuaAgeS4uu+8mlxcXFxcXFwiICsgZGF0YUl0ZW0uc3RhdGU7XFxcXG5pZiAoW1xcXFxcXFwiaHRtbFxcXFxcXFwiLCBcXFxcXFxcImNvbmZpZ1xcXFxcXFwiLCBcXFxcXFxcImpzX3VybFxcXFxcXFwiXS5pbmNsdWRlcyhkYXRhSXRlbS5kYXRhX3R5cGUpKSB7XFxcXG4gICAgYmFzaWMuZGVzYyArPSBcXFxcXFxcIlxcXFxcXFxcbuKAnOKAnOKAneKAnSA9PlxcXFxcXFwiICsgc21hbGwoXFxcXFxcXCLngrnmraTpooTop4hcXFxcXFxcIik7XFxcXG4gICAgYmFzaWMudXJsID0gcnVsZUxpc3RKc29uICsgZGF0YUl0ZW0uaWQ7XFxcXG59XFxcXG5sZXQgYXV0aCA9IFxcXFxcXFwiXFxcXFxcXCI7XFxcXG5pZiAoZGF0YUl0ZW0uc3RhdGUgPT0gXFxcXFxcXCJwcml2YXRlXFxcXFxcXCIpIHtcXFxcbiAgICBsZXQgYXV0aF9iYWNrID0gSlNPTi5wYXJzZShyZXF1ZXN0KGdldEFwaShcXFxcXFxcImF1dGhcXFxcXFxcIikgKyByZXFCeUdldCkpO1xcXFxuICAgIGJhc2ljLnRpdGxlID0gYmFzaWMudGl0bGUgKyBcXFxcXFxcIlxcXFxcXFxcblxcXFxcXFwiICsgc21hbGwoY29sb3IoYXV0aF9iYWNrLnJlc3VsdCwgXFxcXFxcXCJncmV5XFxcXFxcXCIpKTtcXFxcbiAgICBhdXRoID0gJyZhdXRoPScgKyBhdXRoX2JhY2sucmVzdWx0O1xcXFxuICAgIGJhc2ljLnVybCA9IGJhc2ljLnVybCA9PT0gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCIgPyBiYXNpYy51cmwgOiBiYXNpYy51cmwgKyBhdXRoO1xcXFxufVxcXFxuZGF0YS5wdXNoKGJhc2ljKTtcXFxcbmxldCBub3RlcyA9IHJlcXVlc3QoZ2V0QXBpKFxcXFxcXFwiZ2V0X3J1bGVfbm90ZVxcXFxcXFwiKSArIGlkKTtcXFxcbm5vdGVzID0gSlNPTi5wYXJzZShub3RlcykucmVzdWx0O1xcXFxucmVxdWlyZShtZCk7XFxcXG5sZXQgbm90ZXNIdG1sPVxcXFxcXFwiXFxcXFxcXCJcXFxcbnRyeXtcXFxcbiAgICBub3Rlc0h0bWw9bWFya2VkLnBhcnNlKG5vdGVzKTtcXFxcbn1jYXRjaChlKXt9XFxcXG5pZiAobm90ZXMgIT09IGZhbHNlKSB7XFxcXG4gICAgZGF0YS5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IGh0bWxUYWcoXFxcXFxcXCJiaWdcXFxcXFxcIiwgXFxcXFxcXCLlpIfms6hcXFxcXFxcIikgKyBcXFxcXFxcIlxcXFxcXFxcdFxcXFxcXFxcdFxcXFxcXFxcdFxcXFxcXFwiICsgc21hbGwoaHRtbFRhZyhcXFxcXFxcInVcXFxcXFxcIiwgXFxcXFxcXCLmn6XnnIvlrozmlbTlhazlkYogPlxcXFxcXFwiKSksXFxcXG4gICAgICAgIGRlc2M6IG5vdGVzLFxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0XzFcXFxcXFxcIixcXFxcbiAgICAgICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vcGFnZS9pbmZvXFxcXFxcXCIsXFxcXG4gICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICB0ZXh0OiBub3Rlc0h0bWwsXFxcXG4gICAgICAgICAgICBuYW1lOiBkYXRhSXRlbS5uYW1lLFxcXFxuICAgICAgICAgICAgLy8gdHlwZTogXFxcXFxcXCJsb25nX3RleHRcXFxcXFxcIlxcXFxuICAgICAgICAgICAgdHlwZTogXFxcXFxcXCJyaWNoX3RleHRcXFxcXFxcIlxcXFxuICAgICAgICB9XFxcXG4gICAgfSk7XFxcXG59XFxcXG5kYXRhLnB1c2goe1xcXFxuICAgIHRpdGxlOiBodG1sVGFnKFxcXFxcXFwiYmlnXFxcXFxcXCIsIFxcXFxcXFwi5pON5L2cXFxcXFxcXCIpLFxcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMVxcXFxcXFwiLFxcXFxuICAgIHVybDogXFxcXFxcXCJ0b2FzdDovL+S9oOaJjeaYr+acgOW4heeahOmCo+S4quS6uu+8gVxcXFxcXFwiXFxcXG59KTtcXFxcbmxldCBpbXBvcnRVcmwsIHJ1bGVDb2RlLCBzaGFyZVVybCwgYmFja0NvZGUgPSBcXFxcXFxcIlxcXFxcXFwiO1xcXFxubGV0IHN1YlVybCA9IHJ1bGVMaXN0SnNvbiArIGRhdGFJdGVtLmlkICsgYXV0aDtcXFxcbmlmICghZGF0YUl0ZW0uaXNfanNvbikge1xcXFxuICAgIGJhY2tDb2RlID0gcmVxdWVzdChzdWJVcmwpO1xcXFxufVxcXFxuc3dpdGNoIChkYXRhSXRlbS5kYXRhX3R5cGUpIHtcXFxcbiAgICBjYXNlIFxcXFxcXFwiaG9tZV9ydWxlX3VybFxcXFxcXFwiOlxcXFxuICAgICAgICBydWxlQ29kZSA9IFxcXFxcXFwi5rW36ZiU6KeG55WM6aaW6aG16aKR6YGT6KeE5YiZ44CQXFxcXFxcXCIgKyBkYXRhSXRlbS5uYW1lICsgXFxcXFxcXCLjgJHvv6Vob21lX3J1bGVfdXJs77+lXFxcXFxcXCIgKyBydWxlTGlzdEpzb24gKyBkYXRhSXRlbS5pZCArIGF1dGg7XFxcXG4gICAgICAgIGltcG9ydFVybCA9IFxcXFxcXFwicnVsZTovL1xcXFxcXFwiICsgYmFzZTY0RW5jb2RlKHJ1bGVDb2RlKVxcXFxuICAgICAgICBicmVhaztcXFxcbiAgICBjYXNlICdwdWJsaXNoJzpcXFxcbiAgICAgICAgcnVsZUNvZGUgPSAn5rW36ZiU6KeG55WM6KeE5YiZ5YiG5Lqr77yM5b2T5YmN5YiG5Lqr55qE5piv77yaJyArIGRhdGFJdGVtLm5hbWUgKyAn77+lcHVibGlzaO+/pScgKyBiYXNlNjRFbmNvZGUoYmFja0NvZGUpO1xcXFxuICAgICAgICBpbXBvcnRVcmwgPSAncnVsZTovLycgKyBiYXNlNjRFbmNvZGUocnVsZUNvZGUpO1xcXFxuICAgICAgICBicmVhaztcXFxcbiAgICBjYXNlICdqc191cmwnOlxcXFxuICAgICAgICBydWxlQ29kZSA9ICfmtbfpmJTop4bnlYzop4TliJnliIbkuqvvvIzlvZPliY3liIbkuqvnmoTmmK/vvJrnvZHpobXmj5Lku7bvv6Vqc191cmzvv6UnICsgZGF0YUl0ZW0ubmFtZSArICdAYmFzZTY0Oi8vJyArIGJhc2U2NEVuY29kZShiYWNrQ29kZSk7XFxcXG4gICAgICAgIGltcG9ydFVybCA9ICdydWxlOi8vJyArIGJhc2U2NEVuY29kZShydWxlQ29kZSk7XFxcXG4gICAgICAgIGJyZWFrO1xcXFxuICAgIGNhc2UgJ2h0bWwnOlxcXFxuICAgICAgICBsZXQgZmlsZV90bXAgPSBkYXRhSXRlbS5uYW1lLnNwbGl0KCcuJyk7XFxcXG4gICAgICAgIGxldCBmaWxlX3BhdGggPSBmaWxlX3RtcC5sZW5ndGggPiAxID8gZmlsZV90bXBbZmlsZV90bXAubGVuZ3RoIC0gMV0gKyBcXFxcXFxcIi9cXFxcXFxcIiArIGRhdGFJdGVtLm5hbWUgOiBkYXRhSXRlbS5uYW1lO1xcXFxuICAgICAgICBydWxlQ29kZSA9IFxcXFxcXFwi5rW36ZiU6KeG55WM5pys5Zyw5paH5Lu25YiG5Lqr77+lZmlsZV91cmzvv6VoaWtlcjovL2ZpbGVzL3J1bGVzL2R6SG91c2UvXFxcXFxcXCIgKyBmaWxlX3BhdGggKyBcXFxcXFxcIkBcXFxcXFxcIiArIHJ1bGVMaXN0SnNvbiArIGRhdGFJdGVtLmlkICsgYXV0aDtcXFxcbiAgICAgICAgaW1wb3J0VXJsID0gJ3J1bGU6Ly8nICsgYmFzZTY0RW5jb2RlKHJ1bGVDb2RlKTtcXFxcbiAgICAgICAgYnJlYWtcXFxcbiAgICBjYXNlIFxcXFxcXFwiY29uZmlnXFxcXFxcXCI6XFxcXG4gICAgICAgIGltcG9ydFVybCA9ICQoKS5ydWxlKHBhc3N3b3JkID0+IHtcXFxcbiAgICAgICAgICAgIGV2YWwoZmV0Y2goXFxcXFxcXCJoaWtlcjovL2Fzc2V0cy9ob21lLmpzXFxcXFxcXCIpKTtcXFxcbiAgICAgICAgICAgIEhpa2VySG9tZS5sb2FkKFxcXFxcXFwiaW1wb3J0XFxcXFxcXCIsIHBhc3N3b3JkKTtcXFxcbiAgICAgICAgfSwgYmFja0NvZGUpO1xcXFxuICAgICAgICBicmVhaztcXFxcbn1cXFxcbmxldCBteV9jb2xfdHlwZSA9IFxcXFxcXFwidGV4dF8yXFxcXFxcXCI7XFxcXG5pZiAoaW1wb3J0VXJsKSB7XFxcXG4gICAgZGF0YS5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IFxcXFxcXFwi5a+85YWl6KeE5YiZXFxcXFxcXCIsXFxcXG4gICAgICAgIHVybDogaW1wb3J0VXJsLFxcXFxuICAgICAgICBjb2xfdHlwZTogbXlfY29sX3R5cGVcXFxcbiAgICB9KTtcXFxcbiAgICBpZihkYXRhSXRlbS5pc19qc29uX2xpc3QmJi9ob21lX3J1bGVfdXJsfGh0bWwvLnRlc3QoZGF0YUl0ZW0uZGF0YV90eXBlKSl7XFxcXG4gICAgICAgIGRhdGEucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZTogJ+KAnOKAnOKAneKAnTxzcGFuIHN0eWxlPVxcXFxcXFwiY29sb3I6ICNmZjcwMDBcXFxcXFxcIj7lr7zlhaXpgZPlvrfnu488L3NwYW4+JyxcXFxcbiAgICAgICAgICAgIHVybDogJCgpLmxhenlSdWxlKChkYXRhSXRlbSxzdWJVcmwpPT57XFxcXG4gICAgICAgICAgICAgICAgLy8gbGV0IHRpdGxlID0gXFxcXFxcXCJILVxcXFxcXFwiK2RhdGFJdGVtLm5hbWUrXFxcXFxcXCIuXFxcXFxcXCIrZGF0YUl0ZW0uYXV0aG9yO1xcXFxuICAgICAgICAgICAgICAgIGxldCB0aXRsZSA9IFxcXFxcXFwiSi1cXFxcXFxcIitkYXRhSXRlbS5uYW1lLnNwbGl0KCcuJylbMF07XFxcXG4gICAgICAgICAgICAgICAgbGV0IHN1Yk9iaiA9IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxcXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHN1YlVybCxcXFxcbiAgICAgICAgICAgICAgICAgICAgZGVzYzogXFxcXFxcXCJoaWtlcjovL2ZpbGVzL3J1bGVzL2R6SG91c2UvcnVsZUNhY2hlL1xcXFxcXFwiK3RpdGxlK1xcXFxcXFwiLmpzb25cXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogXFxcXFxcXCJcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlOiBmYWxzZSwvL+emgeeUqOW5tuWPkeabtOaWsFxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICBsZXQgc2hhcmVUZXh0ID0gYmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KHN1Yk9iaikpO1xcXFxuICAgICAgICAgICAgICAgIHZhciBwYXN0ZXMgPSBnZXRQYXN0ZXMoKTtcXFxcbiAgICAgICAgICAgICAgICB2YXIgdXJsID0gc2hhcmVQYXN0ZShzaGFyZVRleHQscGFzdGVzLnNsaWNlKC0xKVswXSk7XFxcXG4gICAgICAgICAgICAgICAgbGV0IGltcG9ydF9ydWxlPSBcXFxcXFxcIui9u+WQiOmbhuiuoumYhe+8mlxcXFxcXFwiK3RpdGxlKydcXFxcXFxcXG4nK3VybDtcXFxcbiAgICAgICAgICAgICAgICBjb3B5KGltcG9ydF9ydWxlKTtcXFxcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gJ2hpa2VyOi8vZmlsZXMvcnVsZXMvZHpIb3VzZS9ydWxlQ2FjaGUvc3ViLmpzb24nO1xcXFxuICAgICAgICAgICAgICAgICQucmMoY29uZmlnLmxpYi5zdWIpO1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiDorqLpmIXlr7zlhaUocGF0aClcXFxcbiAgICAgICAgICAgIH0sZGF0YUl0ZW0sc3ViVXJsKSxcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBteV9jb2xfdHlwZVxcXFxuICAgICAgICB9KTtcXFxcbiAgICB9XFxcXG59XFxcXG5pZiAocnVsZUNvZGUpIHtcXFxcbiAgICBkYXRhLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogXFxcXFxcXCLliIbkuqvop4TliJlcXFxcXFxcIixcXFxcbiAgICAgICAgdXJsOiBcXFxcXFxcImNvcHk6Ly9cXFxcXFxcIiArIHJ1bGVDb2RlLFxcXFxuICAgICAgICBjb2xfdHlwZTogbXlfY29sX3R5cGVcXFxcbiAgICB9KTtcXFxcbn1cXFxcblxcXFxuZnVuY3Rpb24gc2V0U2V0dGluZ0l0ZW0oYmFzaWMsIHBhdHRlcm4pIHtcXFxcbiAgICBsZXQgdGVtcCA9IHtcXFxcbiAgICAgICAgdGl0bGU6IGJhc2ljLnRpdGxlLFxcXFxuICAgICAgICBjb2xfdHlwZTogYmFzaWMuY29sX3R5cGUsXFxcXG4gICAgICAgIHVybDogJChiYXNpYy5jb25maXJtKS5jb25maXJtKCh1cmwsIG1zZywgcGF0dGVybikgPT4ge1xcXFxuICAgICAgICAgICAgbGV0IGJhY2tBID0gcmVxdWVzdCh1cmwpO1xcXFxuICAgICAgICAgICAgbGV0IHJldCA9IEpTT04ucGFyc2UoYmFja0EpO1xcXFxuICAgICAgICAgICAgaWYgKHJldC5zdGF0dXMgPT0gMCkge1xcXFxuICAgICAgICAgICAgICAgIHBhdHRlcm4gPyBiYWNrKCkgOiByZWZyZXNoUGFnZShmYWxzZSk7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly9cXFxcXFxcIiArIG1zZ1swXTtcXFxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgcGF0dGVybiA/IGJhY2soKSA6IHJlZnJlc2hQYWdlKGZhbHNlKTtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL1xcXFxcXFwiICsgbXNnWzFdICsgXFxcXFxcXCJcXFxcXFxcXG5cXFxcXFxcIiArIHJldC5kZXRhaWw7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0sIGJhc2ljLnVybCwgYmFzaWMubXNnLCBwYXR0ZXJuKVxcXFxuICAgIH07XFxcXG4gICAgcmV0dXJuIHRlbXA7XFxcXG59XFxcXG5pZiAoZGF0YUl0ZW0uc3RhdGUgPT0gJ3ByaXZhdGUnKSB7XFxcXG4gICAgZGF0YS5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IFxcXFxcXFwi6K6+5Li65YWs5byAXFxcXFxcXCIsXFxcXG4gICAgICAgIHVybDogJChnZXRBcGkoXFxcXFxcXCJzaGFyZVxcXFxcXFwiKSArIHJlcUJ5R2V0ICsgXFxcXFxcXCImZmxhZ1xcXFxcXFwiICsgXFxcXFxcXCIjbm9Mb2FkaW5nI1xcXFxcXFwiKS5sYXp5UnVsZSgoKSA9PiB7XFxcXG4gICAgICAgICAgICByZXF1ZXN0KGlucHV0KTtcXFxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5bey6K6+5Li65YWs5byAXFxcXFxcXCI7XFxcXG4gICAgICAgIH0pLFxcXFxuICAgICAgICBjb2xfdHlwZTogbXlfY29sX3R5cGVcXFxcbiAgICB9LCB7XFxcXG4gICAgICAgIHRpdGxlOiBcXFxcXFxcIumaj+acuuWvhumSpVxcXFxcXFwiLFxcXFxuICAgICAgICBjb2xfdHlwZTogbXlfY29sX3R5cGUsXFxcXG4gICAgICAgIHVybDogJChnZXRBcGkoXFxcXFxcXCJnZW5BdXRoXFxcXFxcXCIpICsgcmVxQnlHZXQgKyBcXFxcXFxcIiNub0xvYWRpbmcjXFxcXFxcXCIpLmxhenlSdWxlKCgpID0+IHtcXFxcbiAgICAgICAgICAgIGxldCBiYWNrID0gcmVxdWVzdChpbnB1dCk7XFxcXG4gICAgICAgICAgICBsZXQgcmV0ID0gSlNPTi5wYXJzZShiYWNrKTtcXFxcbiAgICAgICAgICAgIGlmIChyZXQuc3RhdHVzID09IDApIHtcXFxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/lt7LnlJ/miJDpmo/mnLrlr4bnoIFcXFxcXFxcXG5cXFxcXFxcIiArIHJldC5yZXN1bHRcXFxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UodHJ1ZSk7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/pmo/mnLrlr4bnoIHnlJ/miJDlpLHotKVcXFxcXFxcIlxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9KVxcXFxuICAgIH0pO1xcXFxuICAgIGxldCB0aW1lT3ZlciA9IHtcXFxcbiAgICAgICAgY29sX3R5cGU6IG15X2NvbF90eXBlXFxcXG4gICAgfTtcXFxcbiAgICBpZiAoZGF0YUl0ZW0udGltZV9vdmVyKSB7XFxcXG4gICAgICAgIHRpbWVPdmVyLnRpdGxlID0gc21hbGwoY29sb3IoXFxcXFxcXCLnn63ml7blr4bpkqVcXFxcXFxcIiwgXFxcXFxcXCJncmVlblxcXFxcXFwiKSArIGNvbG9yKFxcXFxcXFwiKOKGkuawuOS5hSlcXFxcXFxcIiwgXFxcXFxcXCJyZWRcXFxcXFxcIikpO1xcXFxuICAgICAgICB0aW1lT3Zlci51cmwgPSBnZXRBcGkoXFxcXFxcXCJ0aW1lb3ZlclxcXFxcXFwiKSArIHJlcUJ5R2V0ICsgXFxcXFxcXCImZmxhZz0xXFxcXFxcXCI7XFxcXG4gICAgICAgIHRpbWVPdmVyLmNvbmZpcm0gPSBcXFxcXFxcIuaYr+WQpuehruiupOS7peWQjueahOengeiXj+inhOWImeWIhuS6q+S4jei/h+acnz9cXFxcXFxcIjtcXFxcbiAgICAgICAgdGltZU92ZXIubXNnID0gW1xcXFxcXFwi5bey6K6+5Li65rC45LmFXFxcXFxcXCIsIFxcXFxcXFwi6K6+5Li65rC45LmF5aSx6LSlXFxcXFxcXCJdO1xcXFxuICAgIH0gZWxzZSB7XFxcXG4gICAgICAgIHRpbWVPdmVyLnRpdGxlID0gc21hbGwoY29sb3IoXFxcXFxcXCLmsLjkuYXlr4bpkqVcXFxcXFxcIiwgXFxcXFxcXCJyZWRcXFxcXFxcIikgKyBjb2xvcihcXFxcXFxcIijihpLnn63ml7YpXFxcXFxcXCIsIFxcXFxcXFwiZ3JlZW5cXFxcXFxcIikpO1xcXFxuICAgICAgICB0aW1lT3Zlci51cmwgPSBnZXRBcGkoXFxcXFxcXCJ0aW1lb3ZlclxcXFxcXFwiKSArIHJlcUJ5R2V0O1xcXFxuICAgICAgICB0aW1lT3Zlci5jb25maXJtID0gXFxcXFxcXCLnoa7orqTopoHku6XlkI7liIbkuqvnmoTnp4Hol4/op4TliJnoh6rliqjliLDmnJ8/XFxcXFxcXCI7XFxcXG4gICAgICAgIHRpbWVPdmVyLm1zZyA9IFtcXFxcXFxcIuW3suiuvuS4uui/h+acn1xcXFxcXFwiLCBcXFxcXFxcIuiuvuS4uui/h+acn+Wksei0pVxcXFxcXFwiXTtcXFxcbiAgICB9XFxcXG4gICAgZGF0YS5wdXNoKHNldFNldHRpbmdJdGVtKHRpbWVPdmVyKSk7XFxcXG59IGVsc2UgaWYgKGRhdGFJdGVtLnN0YXRlID09ICdwdWJsaWMnKSB7XFxcXG4gICAgZGF0YS5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IFxcXFxcXFwi6K6+5Li656eB5pyJXFxcXFxcXCIsXFxcXG4gICAgICAgIHVybDogJChnZXRBcGkoXFxcXFxcXCJzaGFyZVxcXFxcXFwiKSArIHJlcUJ5R2V0ICsgXFxcXFxcXCImZmxhZz0xI25vTG9hZGluZyNcXFxcXFxcIikubGF6eVJ1bGUoKCkgPT4ge1xcXFxuICAgICAgICAgICAgcmVxdWVzdChpbnB1dCk7XFxcXG4gICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+W3suiuvuS4uuengeaciVxcXFxcXFwiO1xcXFxuICAgICAgICB9KSxcXFxcbiAgICAgICAgY29sX3R5cGU6IG15X2NvbF90eXBlXFxcXG4gICAgfSk7XFxcXG59XFxcXG5kYXRhLnB1c2goc2V0U2V0dGluZ0l0ZW0oe1xcXFxuICAgIHRpdGxlOiBcXFxcXFxcIuWIoOmZpOaVsOaNrlxcXFxcXFwiLFxcXFxuICAgIGNvbmZpcm06IFxcXFxcXFwi5piv5ZCm56Gu6K6k5Yig6ZmkXFxcXFxcXCIsXFxcXG4gICAgbXNnOiBbXFxcXFxcXCLlt7LliKDpmaRcXFxcXFxcIiwgXFxcXFxcXCLliKDpmaTlpLHotKVcXFxcXFxcIl0sXFxcXG4gICAgdXJsOiBnZXRBcGkoXFxcXFxcXCJkZWxldGVVcmxcXFxcXFxcIikgKyByZXFCeUdldCxcXFxcbiAgICBjb2xfdHlwZTogbXlfY29sX3R5cGVcXFxcbn0sIHRydWUpKTtcXFxcbmRhdGEucHVzaCh7XFxcXG4gICAgdGl0bGU6IFxcXFxcXFwi6K6+572u5Zu+5qCHXFxcXFxcXCIsXFxcXG4gICAgdXJsOiAkKGRhdGFJdGVtLnBpY191cmwsIFxcXFxcXFwi6L6T5YWl5Zu+5qCH5Zyw5Z2AXFxcXFxcXCIpLmlucHV0KGFwaSA9PiB7XFxcXG4gICAgICAgIGlmIChpbnB1dCA9PT0gXFxcXFxcXCJcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/kvaDlnKjpgJfmiJHpk77mjqXlk6o/XFxcXFxcXCJcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBsZXQgcmVzdWx0ID0gcmVxdWVzdChhcGkgKyBcXFxcXFxcIiZydWxlX3BpYz1cXFxcXFxcIiArIGlucHV0KTtcXFxcbiAgICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZShyZXN1bHQpO1xcXFxuICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyAhPT0gMCkge1xcXFxuICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly9cXFxcXFxcIiArIHJlc3VsdC5kZXRhaWw7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/kv67mlLnmiJDlip9cXFxcXFxcIjtcXFxcbiAgICB9LCBnZXRBcGkoXFxcXFxcXCJzZXRfcnVsZV9waWNcXFxcXFxcIikgKyBkYXRhSXRlbS5pZCArIHJlcUJ5R2V0KSxcXFxcbiAgICBjb2xfdHlwZTogbXlfY29sX3R5cGVcXFxcbn0pO1xcXFxuXFxcXG5kYXRhLnB1c2goe1xcXFxuICAgIHRpdGxlOiBkYXRhSXRlbS5jYW5fZGlzY3VzcyA/IFxcXFxcXFwi56aB5q2i6K+E6K66XFxcXFxcXCIgOiBcXFxcXFxcIuW8gOWQr+ivhOiuulxcXFxcXFwiLFxcXFxuICAgIHVybDogJChhcGkuZGlzX3NldCArIGRhdGFJdGVtLmlkICsgcmVxQnlHZXQgKyBcXFxcXFxcIiZzdGF0ZT1cXFxcXFxcIiArIChkYXRhSXRlbS5jYW5fZGlzY3VzcyA/IFxcXFxcXFwiXFxcXFxcXCIgOiAxKSkubGF6eVJ1bGUoKGNhbl9kaXNjdXNzKSA9PiB7XFxcXG4gICAgICAgIHJlcXVlc3QoaW5wdXQpO1xcXFxuICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxcXG4gICAgICAgIHJldHVybiBjYW5fZGlzY3VzcyA/IFxcXFxcXFwidG9hc3Q6Ly/lt7LnpoHmraLor4TorrpcXFxcXFxcIiA6IFxcXFxcXFwidG9hc3Q6Ly/lt7LlvIDlkK/or4TorrpcXFxcXFxcIjtcXFxcbiAgICB9LCBkYXRhSXRlbS5jYW5fZGlzY3VzcyksXFxcXG4gICAgY29sX3R5cGU6IG15X2NvbF90eXBlXFxcXG59KTtcXFxcbk1ZX1BBUkFNUy5uYW1lID0gZGF0YUl0ZW0ubmFtZTtcXFxcbk1ZX1BBUkFNUy51c2VybmFtZT11c2VybmFtZTtcXFxcbk1ZX1BBUkFNUy5wYXNzd29yZD1wYXNzd29yZDtcXFxcbmRhdGEucHVzaCh7XFxcXG4gICAgdGl0bGU6IFxcXFxcXFwi6K6+572u5aSH5rOoXFxcXFxcXCIsXFxcXG4gICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vcGFnZS9zZXRfcnVsZV9ub3Rlc1xcXFxcXFwiLFxcXFxuICAgIGV4dHJhOiBNWV9QQVJBTVMsXFxcXG4gICAgY29sX3R5cGU6IG15X2NvbF90eXBlXFxcXG59KTtcXFxcbmlmIChkYXRhSXRlbS5pc19qc29uICYmIGRhdGFJdGVtLmRhdGFfdHlwZSA9PT0gXFxcXFxcXCJob21lX3J1bGVfdXJsXFxcXFxcXCIgJiYgIWRhdGFJdGVtLmlzX2pzb25fbGlzdCkge1xcXFxuICAgIGRhdGEucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiAn6L+b5YWl6aKR6YGTJyxcXFxcbiAgICAgICAgdXJsOiAkKCAvKlxcXFxcXFwiI25vTG9hZGluZyNcXFxcXFxcIiovICkubGF6eVJ1bGUoKG5hbWUsaG9tZSkgPT4ge1xcXFxuICAgICAgICAgICAgbGV0IHJ1bGVMaXN0ID0gSlNPTi5wYXJzZShyZXF1ZXN0KGhvbWUpKTtcXFxcbiAgICAgICAgICAgIGxldCBoYXNSdWxlID0gcnVsZUxpc3Quc29tZShpdGVtID0+IGl0ZW0udGl0bGUgPT09IG5hbWUpO1xcXFxuICAgICAgICAgICAgaWYgKGhhc1J1bGUpIHtcXFxcbiAgICAgICAgICAgICAgICBwdXRWYXIoXFxcXFxcXCJXYXJlaG91c2UuYmFja1xcXFxcXFwiLCBcXFxcXFxcIjFcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgYmFjaygpO1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBob21lK1xcXFxcXFwic0BcXFxcXFxcIiArIG5hbWU7XFxcXG4gICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5pyq5a6J6KOFXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0sIGRhdGFJdGVtLm5hbWUsYXBpLmhvbWUpLFxcXFxuICAgICAgICBjb2xfdHlwZTogbXlfY29sX3R5cGVcXFxcbiAgICB9KTtcXFxcbn1cXFxcbmRhdGEucHVzaCh7XFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwibGluZV9ibGFua1xcXFxcXFwiXFxcXG59KTtcXFxcbmRhdGEucHVzaCh7XFxcXG4gICAgdGl0bGU6IGRhdGFJdGVtLmdvb2RfbnVtLFxcXFxuICAgIHBpY191cmw6IFxcXFxcXFwiaGlrZXI6Ly9maWxlcy9pY29uL+i1ni5zdmdcXFxcXFxcIixcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJpY29uX3NtYWxsXzNcXFxcXFxcIixcXFxcbiAgICB1cmw6IFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiXFxcXG59KTtcXFxcbmRhdGEucHVzaCh7XFxcXG4gICAgdGl0bGU6IGRhdGFJdGVtLmJhZF9udW0sXFxcXG4gICAgcGljX3VybDogXFxcXFxcXCJoaWtlcjovL2ZpbGVzL2ljb24v6LipLnN2Z1xcXFxcXFwiLFxcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcImljb25fc21hbGxfM1xcXFxcXFwiLFxcXFxuICAgIHVybDogXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCJcXFxcbn0pO1xcXFxuZGF0YS5wdXNoKHtcXFxcbiAgICB0aXRsZTogXFxcXFxcXCLor4TorrpcXFxcXFxcIixcXFxcbiAgICBwaWNfdXJsOiBcXFxcXFxcImhpa2VyOi8vZmlsZXMvaWNvbi/or4Torrouc3ZnXFxcXFxcXCIsXFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwiaWNvbl9zbWFsbF8zXFxcXFxcXCIsXFxcXG4gICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vcGFnZS9SZXBseSNub0hpc3RvcnkjI25vUmVjb3JkSGlzdG9yeSNcXFxcXFxcIixcXFxcbiAgICBleHRyYToge1xcXFxuICAgICAgICBydWxlSWQ6IGRhdGFJdGVtLmlkLFxcXFxuICAgICAgICBuYW1lOiBkYXRhSXRlbS5hdXRob3IsXFxcXG4gICAgICAgIHBhc3N3b3JkOiBwYXNzd29yZCxcXFxcbiAgICAgICAgdXNlcm5hbWU6IHVzZXJuYW1lXFxcXG4gICAgfVxcXFxufSk7XFxcXG5sZXQgdG90YWxTdW0gPSBkYXRhSXRlbS5nb29kX251bSArIGRhdGFJdGVtLmJhZF9udW07XFxcXG5cXFxcbmRhdGEucHVzaCh7XFxcXG4gICAgdGl0bGU6IGh0bWxUYWcoXFxcXFxcXCJiaWdcXFxcXFxcIiwgXFxcXFxcXCLor4TorrooXFxcXFxcXCIgKyB0b3RhbFN1bSArIFxcXFxcXFwiKVxcXFxcXFwiKSArIFxcXFxcXFwiXFxcXFxcXFx0XFxcXFxcXFx0XFxcXFxcXFx0XFxcXFxcXCIgKyBzbWFsbChodG1sVGFnKFxcXFxcXFwidVxcXFxcXFwiLCBcXFxcXFxcIuafpeeci+WFqOmDqOivhOiuuijmjqfor4QpID5cXFxcXFxcIikpLFxcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMVxcXFxcXFwiLFxcXFxuICAgIHVybDogXFxcXFxcXCJoaWtlcjovL3BhZ2UvQ29tbWVudFxcXFxcXFwiLFxcXFxuICAgIGV4dHJhOiB7XFxcXG4gICAgICAgIHVybDogXFxcXFxcXCJoaWtlcjovL2VtcHR5I2Z5cGFnZSNub0hpc3RvcnkjI25vUmVjb3JkSGlzdG9yeSNcXFxcXFxcIixcXFxcbiAgICAgICAgaWQ6IGRhdGFJdGVtLmlkLFxcXFxuICAgICAgICB0b3RhbFN1bTogdG90YWxTdW0sXFxcXG4gICAgICAgIG5vX2FjdGl2ZTogdHJ1ZSxcXFxcbiAgICAgICAgdXNlcm5hbWU6IHVzZXJuYW1lLFxcXFxuICAgICAgICBwYXNzd29yZDogcGFzc3dvcmRcXFxcbiAgICB9XFxcXG59KTtcXFxcbi8vY29uc3QgbG9uZ2VzdFN1bT0xMjA7XFxcXG5sZXQgaWNvbiA9IHtcXFxcbiAgICBcXFxcXFxcImdvb2RcXFxcXFxcIjogXFxcXFxcXCLwn5GNXFxcXFxcXCIsXFxcXG4gICAgXFxcXFxcXCJiYWRcXFxcXFxcIjogXFxcXFxcXCLwn5GOXFxcXFxcXCIsXFxcXG4gICAgXFxcXFxcXCJyZXBseVxcXFxcXFwiOiBcXFxcXFxcIuW8gOWPkeiAhfCfl6NcXFxcXFxcIlxcXFxufVxcXFxuaWYgKHRvdGFsU3VtID09PSAwKSB7XFxcXG4gICAgZGF0YS5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IFxcXFxcXFwiPGg1IHN0eWxlPSd0ZXh0LWFsaWduOmNlbnRlcic+5LiA5p2h6K+E6K665Lmf5rKh5pyJ77yM5b+r5p2l5oqi5rKZ5Y+R5ZCn77yBPC9oNT5cXFxcXFxcIixcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwicmljaF90ZXh0XFxcXFxcXCJcXFxcbiAgICB9KTtcXFxcbn0gZWxzZSB7XFxcXG4gICAgbGV0IGNvbW1lbnRMaXN0ID0gSlNPTi5wYXJzZShyZXF1ZXN0KGFwaS5kaXNfZ2V0ICsgZGF0YUl0ZW0uaWQgKyBcXFxcXFxcIj9saW1pdD01XFxcXFxcXCIpKS5yZXN1bHQ7XFxcXG4gICAgZm9yIChsZXQgaXRlbSBvZiBjb21tZW50TGlzdCkge1xcXFxuICAgICAgICBsZXQgUmVwbHkgPSBpdGVtLmRpc2N1c3NfdHlwZT09PVxcXFxcXFwicmVwbHlcXFxcXFxcIiYmaXRlbS5yZXBseV90b19uYW1lIT09ZmFsc2UmJml0ZW0ucmVwbHlfdG9faWQhPT1mYWxzZT9cXFxcXFxcIuKAmOKAmOWbnuWkjUBcXFxcXFxcIitpdGVtLnJlcGx5X3RvX25hbWUrXFxcXFxcXCIgI1xcXFxcXFwiK2l0ZW0uZGlzY3Vzc19pZCtcXFxcXFxcIuKAmeKAmVxcXFxcXFxcblxcXFxcXFwiOlxcXFxcXFwiXFxcXFxcXCI7XFxcXG4gICAgICAgIGRhdGEucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZTogaXRlbS5uYW1lICsgXFxcXFxcXCImbmJzcDsmbmJzcDs8Zm9udCBjb2xvcj0nZ3JheSc+PHNtYWxsPiNcXFxcXFxcIiArIGl0ZW0uaWQgKyBcXFxcXFxcIjwvc21hbGw+PGZvbnQ+XFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJhdmF0YXJcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIHVybDogXFxcXFxcXCJoaWtlcjovL3BhZ2UvUmVwbHlcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGV4dHJhOntcXFxcbiAgICAgICAgICAgICAgICBydWxlSWQ6IGRhdGFJdGVtLmlkLFxcXFxuICAgICAgICAgICAgICAgIG5hbWU6IGl0ZW0ubmFtZSxcXFxcbiAgICAgICAgICAgICAgICBwYXNzd29yZDogcGFzc3dvcmQsXFxcXG4gICAgICAgICAgICAgICAgdXNlcm5hbWU6IHVzZXJuYW1lLFxcXFxuICAgICAgICAgICAgICAgIHJlcGx5SWQ6aXRlbS5pZFxcXFxuICAgICAgICAgICAgfSxcXFxcbiAgICAgICAgICAgIHBpY191cmw6IGl0ZW0uYXZhdGFyX3VybFxcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgZGF0YS5wdXNoKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiBpdGVtLmRpc2N1c3NfdGV4dCxcXFxcbiAgICAgICAgICAgIGRlc2M6IFJlcGx5K2l0ZW0uY3JlYXRlX2RhdGUgKyBcXFxcXFxcIsK3XFxcXFxcXCIgKyBpY29uW2l0ZW0uZGlzY3Vzc190eXBlXSxcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vcGFnZS9pbmZvXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgIG5hbWU6IGl0ZW0ubmFtZSxcXFxcbiAgICAgICAgICAgICAgICB0eXBlOiBcXFxcXFxcImxvbmdfdGV4dFxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIHRleHQ6IGl0ZW0uZGlzY3Vzc190ZXh0XFxcXG4gICAgICAgICAgICB9LFxcXFxuICAgICAgICAgICAgcGljX3VybDogaXRlbS5hdmF0YXJfdXJsXFxcXG4gICAgICAgIH0pO1xcXFxuICAgIH1cXFxcbn1cXFxcbmRhdGEucHVzaCh7XFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwibGluZV9ibGFua1xcXFxcXFwiXFxcXG59KTtcXFxcbnNldFJlc3VsdChkYXRhKTtcXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwiaWNvbl8yX3JvdW5kXFxcIixcXFwibmFtZVxcXCI6XFxcIuinhOWImeWIl+ihqFxcXCIsXFxcInBhdGhcXFwiOlxcXCJydWxlc1xcXCIsXFxcInJ1bGVcXFwiOlxcXCJqczpcXFxcbiAgICBhZGRMaXN0ZW5lcignb25DbG9zZScsJC50b1N0cmluZygoKT0+e1xcXFxuICAgICAgICBjbGVhclZhcihcXFxcXFxcIldhcmVob3VzZS5iYWNrXFxcXFxcXCIpO1xcXFxuICAgICAgICBjbGVhclZhcihcXFxcXFxcIldhcmVob3VzZS5maWx0ZXJcXFxcXFxcIik7XFxcXG4gICAgICAgIGNsZWFyVmFyKFxcXFxcXFwiV2FyZWhvdXNlLnR5cGVcXFxcXFxcIik7XFxcXG4gICAgICAgIGlmKGdldFZhcignV2FyZWhvdXNlLmNhbl91cGxvYWQnLCcnKSl7XFxcXG4gICAgICAgICAgICBsb2coJ+aTjeS9nOi/h+emgeatouS4iuS8oDonK2dldFZhcignV2FyZWhvdXNlLmNhbl91cGxvYWQnKSk7XFxcXG4gICAgICAgICAgICBjbGVhclZhcihcXFxcXFxcIldhcmVob3VzZS5jYW5fdXBsb2FkXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UodHJ1ZSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9KSk7XFxcXG5cXFxcbmlmIChnZXRWYXIoXFxcXFxcXCJXYXJlaG91c2UuYmFja1xcXFxcXFwiKSA9PT0gXFxcXFxcXCIxXFxcXFxcXCIpIHtcXFxcbiAgICBiYWNrKGZhbHNlKTtcXFxcbn1cXFxcblxcXFxuY29uc3Qge1xcXFxuICAgIGdldEFwaSxcXFxcbiAgICBhcGksXFxcXG4gICAgY29sb3IsXFxcXG4gICAgc21hbGwsXFxcXG4gICAgbG9jYWxSdWxlVmVyLFxcXFxuICAgIGh0bWxUYWcsXFxcXG4gICAgbWRcXFxcbn0gPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvdXRpbGl5XFxcXFxcXCIpO1xcXFxuY29uc3QgeyBub3JtYWxTb3J0IH0gPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2Uvc29ydFxcXFxcXFwiKTtcXFxcbmxldCB7XFxcXG4gICAgYXZhdGFyVXJsLFxcXFxuICAgIHFxLFxcXFxuICAgIGlkLFxcXFxuICAgIGNhbl91cGxvYWRcXFxcbn0gPSBNWV9QQVJBTVM7XFxcXG5sZXQgZGF0YVR5cGUgPSBnZXRWYXIoXFxcXFxcXCJXYXJlaG91c2UudHlwZVxcXFxcXFwiLFxcXFxcXFwiXFxcXFxcXCIpO1xcXFxubGV0IGJhY2tDb2RlID0gSlNPTi5wYXJzZShyZXF1ZXN0KGdldEFwaShcXFxcXFxcInJ1bGVzVXJsXFxcXFxcXCIpICsgXFxcXFxcXCI/bmFtZT1cXFxcXFxcIiArIHFxK1xcXFxcXFwiJmRhdGFfdHlwZT1cXFxcXFxcIitkYXRhVHlwZSkpO1xcXFxubGV0IGRldk5hbWUgPSBiYWNrQ29kZS5kZXZfbmFtZTtcXFxcbnB1dFZhcihcXFxcXFxcIldhcmVob3VzZS5maWx0ZXJcXFxcXFxcIiwgZGV2TmFtZSk7XFxcXG5sZXQgcnVsZUxpc3QgPSBiYWNrQ29kZS5yZXN1bHQ7XFxcXG5sZXQgc3ViVXJsID0gZ2V0QXBpKFxcXFxcXFwianNvbkxpc3RcXFxcXFxcIikgKyBcXFxcXFxcIj9uYW1lPVxcXFxcXFwiICsgcXE7XFxcXG5sZXQgaGFzU3ViID0gaGFzSG9tZVN1YihzdWJVcmwpO1xcXFxubGV0IGRldkluZm8gPSBcXFxcXFxcIui/meS4quS6uuW+iOaHkizku4DkuYjpg73msqHlhpnlk6Z+XFxcXFxcXCI7XFxcXG5sZXQgdG1wSnNvbiA9IEpTT04ucGFyc2UocmVxdWVzdChnZXRBcGkoXFxcXFxcXCJpbmZvR2V0VXJsXFxcXFxcXCIpICsgcXEpKTtcXFxcbmlmICh0bXBKc29uLnN0YXR1cyA9PSAwKSB7XFxcXG4gICAgZGV2SW5mbyA9IHRtcEpzb24ucmVzdWx0IHx8IGRldkluZm87XFxcXG59XFxcXG5sZXQgc3ViRmxhZyA9IGhhc1N1YiA/ICfwn4aXJyA6ICfwn5OhJztcXFxcbmxldCBkYXRhID0gW107XFxcXG5yZXF1aXJlKG1kKTtcXFxcbmRldkluZm89bWFya2VkLnBhcnNlKGRldkluZm8pO1xcXFxuZGF0YS5wdXNoKHtcXFxcbiAgICB0aXRsZTogXFxcXFxcXCLigJzigJzigJ3igJ1cXFxcXFxcIiArIGRldk5hbWUgKyBcXFxcXFxcIlxcXFxcXFxcblxcXFxcXFxcblxcXFxcXFwiICsgc21hbGwoaHRtbFRhZyhcXFxcXFxcInVcXFxcXFxcIiwgXFxcXFxcXCLngrnlh7vmn6XnnIvlrozmlbTlhazlkYpcXFxcXFxcIikpLFxcXFxuICAgIGRlc2M6IHNtYWxsKGRldkluZm8pLFxcXFxuICAgIHVybDogJ2hpa2VyOi8vcGFnZS9pbmZvJyxcXFxcbiAgICBleHRyYToge1xcXFxuICAgICAgICB0ZXh0OiBkZXZJbmZvLFxcXFxuICAgICAgICBuYW1lOiBkZXZOYW1lLFxcXFxuICAgICAgICB0eXBlOlxcXFxcXFwicmljaF90ZXh0XFxcXFxcXCJcXFxcbiAgICB9LFxcXFxuICAgIHBpY191cmw6IGF2YXRhclVybCxcXFxcbiAgICBjb2xfdHlwZTogJ21vdmllXzFfdmVydGljYWxfcGljJ1xcXFxufSk7XFxcXG5kYXRhLnB1c2goe1xcXFxuICAgIHRpdGxlOiBcXFxcXFxcIjxiaWc+6K6i6ZiF566h55CGPC9iaWc+Jm5ic3A7Jm5ic3A7PHNtYWxsPijlvZPliY1cXFxcXFxcIiArIChoYXNTdWIgPyBcXFxcXFxcIuW3suiuoumYhVxcXFxcXFwiIDogXFxcXFxcXCLmnKrorqLpmIVcXFxcXFxcIikgKyBcXFxcXFxcIik8L3NtYWxsPlxcXFxcXFwiLFxcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcInJpY2hfdGV4dFxcXFxcXFwiXFxcXG59KTtcXFxcblxcXFxubGV0IHN1Yl9jb2RlID0gJ+a1t+mYlOinhueVjOWQiOmbhuinhOWImeiuoumYhe+/pWhvbWVfc3Vi77+lJyArIGRldk5hbWUgKyBcXFxcXFxcIuWQiOmbhkBAXFxcXFxcXCIgKyBzdWJVcmw7XFxcXG5sZXQgcnVsZXNDb2RlID0gJ+a1t+mYlOinhueVjOWQiOmbhuinhOWIme+/pWhvbWVfcnVsZV91cmzvv6UnICsgc3ViVXJsO1xcXFxuZGF0YS5wdXNoKHtcXFxcbiAgICB0aXRsZTogJ+KAnOKAnOKAneKAnTxzcGFuIHN0eWxlPVxcXFxcXFwiY29sb3I6ICNmZjcwMDBcXFxcXFxcIj7kuIDplK7orqLpmIU8L3NwYW4+JyxcXFxcbiAgICBkZXNjOiAn6K6i6ZiF4oCc4oCc4oCd4oCdPHNwYW4gc3R5bGU9XFxcXFxcXCJjb2xvcjogIzVjZmYyY1xcXFxcXFwiPicgKyBkZXZOYW1lICsgJzwvc3Bhbj7nmoTmiYDmnInljZXop4TliJnvvIzlkIjpm4bpnIDljZXni6zorqLpmIUnLFxcXFxuICAgIHVybDogc3ViX2NvZGUsXFxcXG4gICAgY29sX3R5cGU6ICd0ZXh0XzInXFxcXG59KTtcXFxcbmRhdGEucHVzaCh7XFxcXG4gICAgdGl0bGU6ICfigJzigJzigJ3igJ08c3BhbiBzdHlsZT1cXFxcXFxcImNvbG9yOiAjZmY3MDAwXFxcXFxcXCI+5a+85YWl5YWo6YOoPC9zcGFuPicsXFxcXG4gICAgdXJsOiBydWxlc0NvZGUsXFxcXG4gICAgY29sX3R5cGU6ICd0ZXh0XzInXFxcXG59KTtcXFxcbmRhdGEucHVzaCh7XFxcXG4gICAgdGl0bGU6ICfigJzigJzigJ3igJ08c3BhbiBzdHlsZT1cXFxcXFxcImNvbG9yOiAjZmY3MDAwXFxcXFxcXCI+5a+85YWl6L275ZCI6ZuGPC9zcGFuPicsXFxcXG4gICAgdXJsOiAkKCkubGF6eVJ1bGUoKGRldk5hbWUsc3ViVXJsLGF2YXRhclVybCk9PntcXFxcbiAgICAgICAgY29uc3Qge2dlblJ1bGV9PSQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9nZW5BcGlcXFxcXFxcIik7XFxcXG4gICAgICAgIGxvZyhcXFxcXFxcIui9u+WQiOmbhuWbvuagh+mTvuaOpTpcXFxcXFxcIithdmF0YXJVcmwpO1xcXFxuICAgICAgICBsZXQgaW1wb3J0X3J1bGU9Z2VuUnVsZShcXFxcXFxcIui9u+WQiOmbhi5cXFxcXFxcIitkZXZOYW1lLHN1YlVybCxhdmF0YXJVcmwpO1xcXFxuICAgICAgICAvL2NvcHkoaW1wb3J0X3J1bGUpO1xcXFxuICAgICAgICBsZXQgcnVsZUNvZGU9cGFyc2VQYXN0ZShpbXBvcnRfcnVsZS5zcGxpdChcXFxcXFxcIlxcXFxcXFxcblxcXFxcXFwiKVswXSk7XFxcXG4gICAgICAgIC8vcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiXFxcXG4gICAgICAgIGltcG9ydFVybCA9ICdydWxlOi8vJyArIGJhc2U2NEVuY29kZShydWxlQ29kZSk7XFxcXG4gICAgICAgIHJldHVybiBpbXBvcnRVcmxcXFxcbiAgICB9LGRldk5hbWUsc3ViVXJsLGF2YXRhclVybCksXFxcXG4gICAgY29sX3R5cGU6ICd0ZXh0XzInXFxcXG59KTtcXFxcbmRhdGEucHVzaCh7XFxcXG4gICAgdGl0bGU6ICfigJzigJzigJ3igJ08c3BhbiBzdHlsZT1cXFxcXFxcImNvbG9yOiAjZmY3MDAwXFxcXFxcXCI+5a+85YWl6YGT5b6357uPPC9zcGFuPicsXFxcXG4gICAgdXJsOiAkKCkubGF6eVJ1bGUoKGRldk5hbWUsc3ViVXJsLGF2YXRhclVybCk9PntcXFxcbiAgICAgICAgbGV0IHRpdGxlID0gXFxcXFxcXCJILVxcXFxcXFwiK2Rldk5hbWU7XFxcXG4gICAgICAgIGxldCBzdWJPYmogPSB7XFxcXG4gICAgICAgICAgICB0aXRsZTogdGl0bGUsXFxcXG4gICAgICAgICAgICB1cmw6IHN1YlVybCxcXFxcbiAgICAgICAgICAgIGRlc2M6IFxcXFxcXFwiaGlrZXI6Ly9maWxlcy9ydWxlcy9kekhvdXNlL3J1bGVDYWNoZS9cXFxcXFxcIit0aXRsZStcXFxcXFxcIi5qc29uXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBjb2RlOiBcXFxcXFxcIlxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgYWN0aXZlOiBmYWxzZSwvL+emgeeUqOW5tuWPkeabtOaWsFxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGxldCBzaGFyZVRleHQgPSBiYXNlNjRFbmNvZGUoSlNPTi5zdHJpbmdpZnkoc3ViT2JqKSk7XFxcXG4gICAgICAgIHZhciBwYXN0ZXMgPSBnZXRQYXN0ZXMoKTtcXFxcbiAgICAgICAgdmFyIHVybCA9IHNoYXJlUGFzdGUoc2hhcmVUZXh0LHBhc3Rlcy5zbGljZSgtMSlbMF0pO1xcXFxuICAgICAgICBsZXQgaW1wb3J0X3J1bGU9IFxcXFxcXFwi6L275ZCI6ZuG6K6i6ZiF77yaXFxcXFxcXCIrdGl0bGUrJ1xcXFxcXFxcbicrdXJsO1xcXFxuICAgICAgICBjb3B5KGltcG9ydF9ydWxlKTtcXFxcbiAgICAgICAgY29uc3QgcGF0aCA9ICdoaWtlcjovL2ZpbGVzL3J1bGVzL2R6SG91c2UvcnVsZUNhY2hlL3N1Yi5qc29uJztcXFxcbiAgICAgICAgJC5yYyhjb25maWcubGliLnN1Yik7XFxcXG4gICAgICAgIHJldHVybiDorqLpmIXlr7zlhaUocGF0aClcXFxcbiAgICB9LGRldk5hbWUsc3ViVXJsLGF2YXRhclVybCksXFxcXG4gICAgY29sX3R5cGU6ICd0ZXh0XzInXFxcXG59KTtcXFxcbmxldCBjYW5fdXBsb2FkX2FwaSA9IGdldEFwaShcXFxcXFxcIm1hbkNhblVwbG9hZFxcXFxcXFwiKStpZDtcXFxcbmlmKGdldFZhcignaG91c2UuaXNfbWFuYWdlcicpKXtcXFxcbiAgICBsZXQgdGlwcyA9IGNhbl91cGxvYWQ/J+iDvSc6J+WQpic7XFxcXG4gICAgLy8gbG9nKCd0aXBzOicrdGlwcyk7XFxcXG4gICAgLy8gbG9nKCdjYW5fdXBsb2FkOicrY2FuX3VwbG9hZCk7XFxcXG4gICAgZGF0YS5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6J+KaoOiDveWQpuS4iuS8oDonKyhnZXRWYXIoJ1dhcmVob3VzZS5jYW5fdXBsb2FkJyl8fHRpcHMpLFxcXFxuICAgICAgICBjb2xfdHlwZTonc2Nyb2xsX2J1dHRvbicsXFxcXG4gICAgICAgIHVybDonaGlrZXI6Ly9lbXB0eSdcXFxcbiAgICB9KTtcXFxcbiAgICBmdW5jdGlvbiBzZXRVcGxvYWQoZmxhZyxjYW5fdXBsb2FkX2FwaSkge1xcXFxuICAgICAgICBmbGFnID0gZmxhZyB8fCAnJztcXFxcbiAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICAgIGxldCBjb2RlID0gZmV0Y2goY2FuX3VwbG9hZF9hcGksIHtcXFxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxcXFxcXCJVc2VyLUFnZW50XFxcXFxcXCI6IE1PQklMRV9VQX0sXFxcXG4gICAgICAgICAgICAgICAgYm9keToge1xcXFxuICAgICAgICAgICAgICAgICAgICBcXFxcXFxcInBhcmFtc1xcXFxcXFwiOlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXFxcXFwidXNlcm5hbWVcXFxcXFxcIjogZ2V0VmFyKCdob3VzZS51c2VybmFtZScpLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXFxcXFwicGFzc3dvcmRcXFxcXFxcIjogZ2V0VmFyKCdob3VzZS5wYXNzd29yZCcpLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiY2FuX3VwbG9hZFxcXFxcXFwiOiAhIWZsYWdcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgIGNvZGUgPSBKU09OLnBhcnNlKGNvZGUpLnJlc3VsdDtcXFxcbiAgICAgICAgICAgIGlmIChjb2RlLnN0YXR1cyA9PT0gMCkge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBjb2RlLmRldGFpbFxcXFxuICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+aTjeS9nOWksei0pTonICsgY29kZS5kZXRhaWxcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcXFxuICAgICAgICAgICAgcmV0dXJuICfmk43kvZzlpLHotKU6JyArIGUubWVzc2FnZVxcXFxuICAgICAgICB9XFxcXG4gICAgfVxcXFxuICAgIGRhdGEucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOifwn5qr56aB5q2i5LiK5LygJyxcXFxcbiAgICAgICAgY29sX3R5cGU6J3Njcm9sbF9idXR0b24nLFxcXFxuICAgICAgICB1cmw6JCgn56aB5q2i6K+l5byA5Y+R6ICF5LiK5Lyg6KeE5YiZP+S9oOeahOaTjeS9nOWwhuiiq+ezu+e7n+iusOW9lScpLmNvbmZpcm0oKGlkLGNhbl91cGxvYWRfYXBpLHNldFVwbG9hZCk9PntcXFxcbiAgICAgICAgICAgIGxldCByZXQgPSBzZXRVcGxvYWQoZmFsc2UsY2FuX3VwbG9hZF9hcGkpO1xcXFxuICAgICAgICAgICAgaWYoIS/mk43kvZzlpLHotKUvLnRlc3QocmV0KSl7XFxcXG4gICAgICAgICAgICAgICAgcHV0VmFyKCdXYXJlaG91c2UuY2FuX3VwbG9hZCcsJ+WQpicpO1xcXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly8nK3JldFxcXFxuICAgICAgICB9LGlkLGNhbl91cGxvYWRfYXBpLHNldFVwbG9hZClcXFxcbiAgICB9KTtcXFxcbiAgICBkYXRhLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTon4pyF5YWB6K645LiK5LygJyxcXFxcbiAgICAgICAgY29sX3R5cGU6J3Njcm9sbF9idXR0b24nLFxcXFxuICAgICAgICB1cmw6JCgn5YWB6K646K+l5byA5Y+R6ICF5LiK5Lyg6KeE5YiZP+S9oOeahOaTjeS9nOWwhuiiq+ezu+e7n+iusOW9lScpLmNvbmZpcm0oKGlkLGNhbl91cGxvYWRfYXBpLHNldFVwbG9hZCk9PntcXFxcbiAgICAgICAgICAgIGxldCByZXQgPSBzZXRVcGxvYWQodHJ1ZSxjYW5fdXBsb2FkX2FwaSk7XFxcXG4gICAgICAgICAgICBpZighL+aTjeS9nOWksei0pS8udGVzdChyZXQpKXtcXFxcbiAgICAgICAgICAgICAgICBwdXRWYXIoJ1dhcmVob3VzZS5jYW5fdXBsb2FkJywn5pivJyk7XFxcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovLycrcmV0XFxcXG4gICAgICAgIH0saWQsY2FuX3VwbG9hZF9hcGksc2V0VXBsb2FkKVxcXFxuICAgIH0pO1xcXFxufVxcXFxuZGF0YS5wdXNoKHtcXFxcbiAgICB0aXRsZTogXFxcXFxcXCI8c21hbGw+5o+Q56S677ya5byA5Y+R6ICF5Y2V54us5YiG5Lqr55qE5ZCI6ZuG5paH5Lu25Y+q6IO95Y2V54us5a+85YWl44CCPC9zbWFsbD5cXFxcXFxcIixcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJyaWNoX3RleHRcXFxcXFxcIlxcXFxufSk7XFxcXG5kYXRhLnB1c2goe1xcXFxuICAgIHRpdGxlOiBcXFxcXFxcIjxiaWc+6KeE5YiZ5YiX6KGoPC9iaWc+Jm5ic3A7Jm5ic3A7PHNtYWxsPijlhbFcXFxcXFxcIiArIHJ1bGVMaXN0Lmxlbmd0aCArIFxcXFxcXFwi5p2hKTwvc21hbGw+XFxcXFxcXCIsXFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwicmljaF90ZXh0XFxcXFxcXCJcXFxcbn0pO1xcXFxubGV0IGRhdGFUeXBlTGlzdCA9IHtcXFxcbiAgICBcXFxcXFxcIlxcXFxcXFwiOlxcXFxcXFwi5YWo6YOoXFxcXFxcXCIsXFxcXG4gICAgXFxcXFxcXCJob21lX3J1bGVfdXJsXFxcXFxcXCI6ICflsI/nqIvluo8nLFxcXFxuICAgIC8vXFxcXFxcXCJwdWJsaXNoXFxcXFxcXCI6ICfmj5DkuqTkupHku5PlupPop4TliJknLFxcXFxuICAgIFxcXFxcXFwianNfdXJsXFxcXFxcXCI6ICfnvZHpobXmj5Lku7YnLFxcXFxuICAgIFxcXFxcXFwiaHRtbFxcXFxcXFwiOiAn6Z2Z5oCB6aG16Z2iJyxcXFxcbiAgICBcXFxcXFxcImNvbmZpZ1xcXFxcXFwiOiAn5Li76aKYJ1xcXFxufTtcXFxcbmZvcihsZXQga2V5IGluIGRhdGFUeXBlTGlzdCl7XFxcXG4gICAgZGF0YS5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6ZGF0YVR5cGU9PT1rZXk/XFxcXFxcXCLigJzigJxcXFxcXFxcIitkYXRhVHlwZUxpc3Rba2V5XStcXFxcXFxcIuKAneKAnVxcXFxcXFwiOmRhdGFUeXBlTGlzdFtrZXldLFxcXFxuICAgICAgICB1cmw6JChcXFxcXFxcIiNub0xvYWRpbmcjXFxcXFxcXCIpLmxhenlSdWxlKChrZXkpPT57XFxcXG4gICAgICAgICAgICBwdXRWYXIoXFxcXFxcXCJXYXJlaG91c2UudHlwZVxcXFxcXFwiLGtleSk7XFxcXG4gICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCI7XFxcXG4gICAgICAgIH0sa2V5KSxcXFxcbiAgICAgICAgY29sX3R5cGU6XFxcXFxcXCJzY3JvbGxfYnV0dG9uXFxcXFxcXCJcXFxcbiAgICB9KTtcXFxcbn1cXFxcbmlmIChydWxlTGlzdC5sZW5ndGggPiAyMCkge1xcXFxuICAgIGRhdGEucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiBcXFxcXFxcIuaQnOe0olxcXFxcXFwiLFxcXFxuICAgICAgICB1cmw6ICQudG9TdHJpbmcobmFtZSA9PiBcXFxcXFxcImhpa2VyOi8vc2VhcmNoP3M9XFxcXFxcXCIgKyBpbnB1dCArIFxcXFxcXFwiJnJ1bGU9XFxcXFxcXCIgKyBuYW1lLCBNWV9SVUxFLnRpdGxlKSxcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiaW5wdXRcXFxcXFxcIixcXFxcbiAgICAgICAgZGVzYzogXFxcXFxcXCLmkJzntKLlvZPliY3lvIDlj5HogIXnmoTop4TliJlcXFxcXFxcIlxcXFxuICAgIH0pO1xcXFxufVxcXFxubGV0IGhvbWVMaXN0ID0gSlNPTi5wYXJzZShyZXF1ZXN0KGFwaS5ob21lKSk7XFxcXG5sZXQgbVJ1bGVMaXN0ID0gW107XFxcXG5mb3IgKHZhciBpdGVtIG9mIHJ1bGVMaXN0KSB7XFxcXG4gICAgdmFyIG5hbWUgPSBpdGVtLm5hbWU7XFxcXG4gICAgaWYgKGl0ZW0uaXNfdGFwKSB7XFxcXG4gICAgICAgIGxldCBsb2NhdGlvbiA9IEpTT04ucGFyc2UocmVxdWVzdChnZXRBcGkoXFxcXFxcXCJydWxlTGlzdEpzb25cXFxcXFxcIikgKyBcXFxcXFxcIj9pZD1cXFxcXFxcIiArIGl0ZW0uaWQpKTtcXFxcbiAgICAgICAgaXRlbS5pZCA9IGxvY2F0aW9uLmlkO1xcXFxuICAgICAgICBpdGVtLm5hbWUgPSBsb2NhdGlvbi5uYW1lO1xcXFxuICAgICAgICBpdGVtLmF1dGhvciA9IGxvY2F0aW9uLmF1dGhvcjtcXFxcbiAgICAgICAgaXRlbS5kYXRhX3R5cGUgPSBsb2NhdGlvbi5kYXRhX3R5cGU7XFxcXG4gICAgICAgIGl0ZW0udmVyID0gbG9jYXRpb24udmVyXFxcXG4gICAgfVxcXFxuICAgIGl0ZW0udmVyc2lvbiA9IGl0ZW0udmVyO1xcXFxuICAgIGxldCBsYWJlbCA9IFxcXFxcXFwiXFxcXFxcXCIsXFxcXG4gICAgICAgIGx2ZXIgPSAtMjtcXFxcbiAgICBpZiAoaXRlbS5pc19qc29uICYmIGl0ZW0uZGF0YV90eXBlID09PSBcXFxcXFxcImhvbWVfcnVsZV91cmxcXFxcXFxcIikge1xcXFxuICAgICAgICBsdmVyID0gbG9jYWxSdWxlVmVyKGhvbWVMaXN0LCBpdGVtKTtcXFxcbiAgICAgICAgaWYgKGx2ZXIgPT09IC0xKSB7XFxcXG4gICAgICAgICAgICBsYWJlbCA9IFxcXFxcXFwi8J+GlVxcXFxcXFwiO1xcXFxuICAgICAgICB9IGVsc2UgaWYgKGx2ZXIgPCBpdGVtLnZlcikge1xcXFxuICAgICAgICAgICAgbGFiZWwgPSBcXFxcXFxcIvCfhplcXFxcXFxcIjtcXFxcbiAgICAgICAgfVxcXFxuICAgIH1cXFxcbiAgICBtUnVsZUxpc3QucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiBsYWJlbCArIG5hbWUsXFxcXG4gICAgICAgIHVybDogXFxcXFxcXCJoaWtlcjovL3BhZ2UvcnVsZURldGFpbCNub0hpc3RvcnkjI25vUmVjb3JkSGlzdG9yeSNcXFxcXFxcIixcXFxcbiAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgIGx2ZXI6IGx2ZXIsXFxcXG4gICAgICAgICAgICBpZDogaXRlbS5pZFxcXFxuICAgICAgICB9LFxcXFxuICAgICAgICBwaWNfdXJsOiBpdGVtLnBpYyxcXFxcbiAgICB9KTtcXFxcbn1cXFxcbi8qIOW9kuW5tuaOkuW6jyBTdGFydCAqL1xcXFxuaWYoZ2V0SXRlbShcXFxcXFxcIuaOkuW6j1xcXFxcXFwiLFxcXFxcXFwi5pe26Ze05LyY5YWIXFxcXFxcXCIpPT09J+aWsOeJiOS8mOWFiCcpe1xcXFxuICAgIG1SdWxlTGlzdCA9IG5vcm1hbFNvcnQobVJ1bGVMaXN0KTtcXFxcbn1cXFxcbi8qIOW9kuW5tuaOkuW6jyBFbmQgKi9cXFxcbmRhdGEucHVzaC5hcHBseShkYXRhLCBtUnVsZUxpc3QpXFxcXG5zZXRSZXN1bHQoZGF0YSk7XFxcXG5cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLop4TliJnor6bnu4YtdXNlclxcXCIsXFxcInBhdGhcXFwiOlxcXCJydWxlRGV0YWlsXFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxuICAgIGNvbnN0IHtcXFxcbiAgICAgICAgZ2V0QXBpLFxcXFxuICAgICAgICBjb2xvcixcXFxcbiAgICAgICAgc21hbGwsXFxcXG4gICAgICAgIGh0bWxUYWcsXFxcXG4gICAgICAgIGFwaSxcXFxcbiAgICAgICAgbWRcXFxcbiAgICB9ID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3V0aWxpeVxcXFxcXFwiKTtcXFxcbmxldCB7XFxcXG4gICAgaWQsXFxcXG4gICAgbHZlcixcXFxcbiAgICBpc0FsbFxcXFxufSA9IE1ZX1BBUkFNUztcXFxcbmlmKGdldFBhcmFtKFxcXFxcXFwiaWRcXFxcXFxcIikpe1xcXFxuICAgIGlzQWxsID0gdHJ1ZTtcXFxcbiAgICBpZCA9IGdldFBhcmFtKFxcXFxcXFwiaWRcXFxcXFxcIik7XFxcXG4gICAgbHZlciA9IGx2ZXIgfHwgXFxcXFxcXCLmnKrojrflj5bniYjmnKzlj7dcXFxcXFxcIjtcXFxcbn1cXFxcbmFkZExpc3RlbmVyKCdvbkNsb3NlJywgJC50b1N0cmluZygoaXNBbGwpID0+IHtcXFxcbiAgICBpZighaXNBbGwpe1xcXFxuICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxcXG4gICAgfVxcXFxufSxpc0FsbCkpO1xcXFxubGV0IGRhdGFJdGVtID0gSlNPTi5wYXJzZShyZXF1ZXN0KGdldEFwaShcXFxcXFxcImdldGJ5aWRcXFxcXFxcIikgKyBcXFxcXFxcIj9pZD1cXFxcXFxcIiArIGlkKSkucmVzdWx0O1xcXFxuc2V0UGFnZVRpdGxlKFxcXFxcXFwi44CMXFxcXFxcXCIgKyBkYXRhSXRlbS5uYW1lICsgXFxcXFxcXCLjgI1cXFxcXFxcIilcXFxcbmxldCBydWxlTGlzdEpzb24gPSBnZXRBcGkoXFxcXFxcXCJydWxlTGlzdEpzb25cXFxcXFxcIikgKyBcXFxcXFxcIj9pZD1cXFxcXFxcIjtcXFxcbmxldCBkYXRhID0gW107XFxcXG52YXIgaGFzU3ViID0gZmFsc2U7XFxcXG5cXFxcbmlmIChkYXRhSXRlbS5pc19qc29uX2xpc3QpIHtcXFxcbiAgICBoYXNTdWIgPSBoYXNIb21lU3ViKHJ1bGVMaXN0SnNvbiArIGRhdGFJdGVtLmlkKTtcXFxcbn0gZWxzZSBpZiAoIWRhdGFJdGVtLmlzX2pzb25fbGlzdCAmJiBkYXRhSXRlbS5kYXRhX3R5cGUgPT0gJ2hvbWVfcnVsZV91cmwnKSB7XFxcXG4gICAgaGFzU3ViID0gaGFzSG9tZVN1YihydWxlTGlzdEpzb24gKyBkYXRhSXRlbS5pZCArICcmZGVidWc9dHJ1ZScpO1xcXFxufVxcXFxuXFxcXG5kYXRhLnB1c2goe1xcXFxuICAgIHRpdGxlOiBodG1sVGFnKFxcXFxcXFwiYmlnXFxcXFxcXCIsIFxcXFxcXFwi54mI5pysXFxcXFxcXCIpLFxcXFxuICAgIGRlc2M6IFxcXFxcXFwi4oCc4oCc4oCd4oCd5byA5Y+R6ICF77yaXFxcXFxcXCIgKyBjb2xvcihkYXRhSXRlbS5hdXRob3IsIFxcXFxcXFwiIzIyOEJFNlxcXFxcXFwiKSArIFxcXFxcXFwiXFxcXFxcXFxu5LqR56uv54mI5pys77yaXFxcXFxcXCIgKyBjb2xvcihkYXRhSXRlbS52ZXIsIFxcXFxcXFwiIzVjZmYyY1xcXFxcXFwiKSArIFxcXFxcXFwiXFxcXFxcXFx0XFxcXFxcXFx05pys5Zyw54mI5pys77yaXFxcXFxcXCIgKyBjb2xvcihsdmVyLCBcXFxcXFxcIiM1Y2ZmMmNcXFxcXFxcIikgKyBcXFxcXFxcIlxcXFxcXFxcbuabtOaWsOS6jjogW1xcXFxcXFwiICsgY29sb3IoZGF0YUl0ZW0ubGFzdF91cGRhdGUsIFxcXFxcXFwiI2ZmNzAwMFxcXFxcXFwiKSArIFxcXFxcXFwiXVxcXFxcXFwiLFxcXFxuICAgIHVybDogJChcXFxcXFxcIjzlvIDlj5HogIU+XFxcXFxcXFxuXFxcXFxcXCIgKyBkYXRhSXRlbS5hdXRob3IgKyBcXFxcXFxcIlxcXFxcXFxcbjzlkI3np7A+XFxcXFxcXFxuXFxcXFxcXCIgKyBkYXRhSXRlbS5uYW1lICsgXFxcXFxcXCJcXFxcXFxcXG485LqR56uv54mI5pysPlxcXFxcXFxcblxcXFxcXFwiICsgZGF0YUl0ZW0udmVyICsgXFxcXFxcXCJcXFxcXFxcXG485pys5Zyw54mI5pysPlxcXFxcXFxcblxcXFxcXFwiICsgbHZlciArIFxcXFxcXFwiXFxcXFxcXFxuPOabtOaWsOaXtumXtD5cXFxcXFxcXG5bXFxcXFxcXCIgKyBkYXRhSXRlbS5sYXN0X3VwZGF0ZSArIFxcXFxcXFwiXVxcXFxcXFwiKS5jb25maXJtKCgpID0+IHt9KSxcXFxcbiAgICBjb2xfdHlwZTogJ3RleHRfMSdcXFxcbn0pO1xcXFxubGV0IGRhdGFUeXBlID0ge1xcXFxuICAgIGhvbWVfcnVsZV91cmw6ICfpppbpobXkupHop4TliJknLFxcXFxuICAgIHB1Ymxpc2g6ICfmj5DkuqTkupHku5PlupPop4TliJknLFxcXFxuICAgIGpzX3VybDogJ+e9kemhteaPkuS7tuinhOWImScsXFxcXG4gICAgaHRtbDogJ+mdmeaAgemhtemdoicsXFxcXG4gICAgY29uZmlnOiAn5Li76aG16YWN572uJ1xcXFxufTtcXFxcblxcXFxubGV0IGJhc2ljID0ge1xcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMVxcXFxcXFwiLFxcXFxuICAgIHVybDogXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCJcXFxcbn07XFxcXG5sZXQgZGF0YVR5cGVUaXBzID0gZGF0YVR5cGVbZGF0YUl0ZW0uZGF0YV90eXBlXSB8fCAn5pyq55+l6KeE5YiZ77yaJyArIGRhdGFJdGVtLmRhdGFfdHlwZTtcXFxcblxcXFxubGV0IHNhZmVfdGlwPWRhdGFJdGVtLmlzX3NhZmU/XFxcXFxcXCLlronlhahcXFxcXFxcIjpcXFxcXFxcIuWNsemZqVxcXFxcXFwiO1xcXFxubGV0IGdvb2RfdGlwID0gZGF0YUl0ZW0uaXNfZ29vZD9zbWFsbChjb2xvcihcXFxcXFxcIuOAkOS8mOi0qOinhOWImeOAkVxcXFxcXFwiLCcjZmY3MDAwJykpOlxcXFxcXFwiXFxcXFxcXCI7XFxcXG5sZXQgbm90X3NhZmVfbm90ZT1kYXRhSXRlbS5ub3Rfc2FmZV9ub3RlO1xcXFxuYmFzaWMudGl0bGUgPSBodG1sVGFnKFxcXFxcXFwiYmlnXFxcXFxcXCIsIFxcXFxcXFwi57G75Z6LXFxcXFxcXCIpICsgXFxcXFxcXCJcXFxcXFxcXHRcXFxcXFxcXHRcXFxcXFxcXHRcXFxcXFxcIiArIHNtYWxsKFxcXFxcXFwiKGlkOlxcXFxcXFwiICsgZGF0YUl0ZW0uaWQgKyBcXFxcXFxcIilcXFxcXFxcIikrXFxcXFxcXCJcXFxcXFxcXHRcXFxcXFxcXHRcXFxcXFxcXHRcXFxcXFxcIiArIHNtYWxsKFxcXFxcXFwiKOmjjumZqeajgOa1izpcXFxcXFxcIiArc2FmZV90aXArXFxcXFxcXCIpXFxcXFxcXCIpK2dvb2RfdGlwO1xcXFxuYmFzaWMuZGVzYyA9IFxcXFxcXFwi5pWw5o2u57G75Z6L77yaXFxcXFxcXCIgKyBjb2xvcihkYXRhVHlwZVRpcHMsIFxcXFxcXFwiI2NiNTRmZlxcXFxcXFwiKSArIFxcXFxcXFwiXFxcXFxcXFxu5YiG5Lqr54q25oCB5Li677yaXFxcXFxcXCIgKyBkYXRhSXRlbS5zdGF0ZTtcXFxcbmlmIChbXFxcXFxcXCJodG1sXFxcXFxcXCIsIFxcXFxcXFwiY29uZmlnXFxcXFxcXCIsIFxcXFxcXFwianNfdXJsXFxcXFxcXCJdLmluY2x1ZGVzKGRhdGFJdGVtLmRhdGFfdHlwZSkpIHtcXFxcbiAgICBiYXNpYy5kZXNjICs9IFxcXFxcXFwiXFxcXFxcXFxu4oCc4oCc4oCd4oCdID0+XFxcXFxcXCIgKyBzbWFsbChcXFxcXFxcIueCueatpOmihOiniFxcXFxcXFwiKTtcXFxcbiAgICBiYXNpYy51cmwgPSBydWxlTGlzdEpzb24gKyBkYXRhSXRlbS5pZDtcXFxcbn1cXFxcblxcXFxuZGF0YS5wdXNoKGJhc2ljKTtcXFxcbmxldCBoYXNTdWJzID0gXFxcXFxcXCJcXFxcXFxcIjtcXFxcbmlmIChoYXNTdWIpIHtcXFxcbiAgICBoYXNTdWJzID0gXFxcXFxcXCJcXFxcXFxcXHRcXFxcXFxcXHRcXFxcXFxcXHRcXFxcXFxcIiArIHNtYWxsKFxcXFxcXFwi5bey6K6i6ZiFXFxcXFxcXCIpXFxcXG59XFxcXG5cXFxcbmxldCBub3RlcyA9IHJlcXVlc3QoZ2V0QXBpKFxcXFxcXFwiZ2V0X3J1bGVfbm90ZVxcXFxcXFwiKSArIGlkKTtcXFxcbm5vdGVzID0gSlNPTi5wYXJzZShub3RlcykucmVzdWx0O1xcXFxucmVxdWlyZShtZCk7XFxcXG5sZXQgbm90ZXNIdG1sPVxcXFxcXFwiXFxcXFxcXCJcXFxcbnRyeXtcXFxcbiAgICBub3Rlc0h0bWw9bWFya2VkLnBhcnNlKG5vdGVzKTtcXFxcbn1jYXRjaChlKXt9XFxcXG5cXFxcbmlmIChub3RlcyAhPT0gZmFsc2UpIHtcXFxcbiAgICBkYXRhLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogaHRtbFRhZyhcXFxcXFxcImJpZ1xcXFxcXFwiLCBcXFxcXFxcIuWkh+azqFxcXFxcXFwiKSArIFxcXFxcXFwiXFxcXFxcXFx0XFxcXFxcXFx0XFxcXFxcXFx0XFxcXFxcXCIgKyBzbWFsbChodG1sVGFnKFxcXFxcXFwidVxcXFxcXFwiLCBcXFxcXFxcIuafpeeci+WujOaVtOWFrOWRiiA+XFxcXFxcXCIpKSxcXFxcbiAgICAgICAgZGVzYzogbm90ZXMsXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMVxcXFxcXFwiLFxcXFxuICAgICAgICB1cmw6IFxcXFxcXFwiaGlrZXI6Ly9wYWdlL2luZm9cXFxcXFxcIixcXFxcbiAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgIHRleHQ6IG5vdGVzSHRtbCxcXFxcbiAgICAgICAgICAgIG5hbWU6IGRhdGFJdGVtLm5hbWUsXFxcXG4gICAgICAgICAgICAvLyB0eXBlOiBcXFxcXFxcImxvbmdfdGV4dFxcXFxcXFwiXFxcXG4gICAgICAgICAgICB0eXBlOiBcXFxcXFxcInJpY2hfdGV4dFxcXFxcXFwiXFxcXG4gICAgICAgIH1cXFxcbiAgICB9KTtcXFxcbn1cXFxcbmRhdGEucHVzaCh7XFxcXG4gICAgdGl0bGU6IGh0bWxUYWcoXFxcXFxcXCJiaWdcXFxcXFxcIiwgXFxcXFxcXCLmk43kvZwo5YiG5Lqr6K+m57uG6aG1KVxcXFxcXFwiKSArIGhhc1N1YnMsXFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF8xXFxcXFxcXCIsXFxcXG4gICAgdXJsOiBcXFxcXFxcImNvcHk6Ly/pgZPplb/ku5PlupPjgIxcXFxcXFxcIitkYXRhSXRlbS5uYW1lK1xcXFxcXFwi44CNXFxcXFxcXFxuXFxcXFxcXCIraWQrJ0BpbXBvcnQ9anM6JC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3J1bGVEZXRhaWxJbXBvcnQ/cnVsZT3pgZPplb/ku5PlupNQcm9cXFxcXFxcIiwgaW5wdXQpJ1xcXFxufSk7XFxcXG5sZXQgaW1wb3J0VXJsLCBydWxlQ29kZSwgc2hhcmVVcmwsIGJhY2tDb2RlID0gXFxcXFxcXCJcXFxcXFxcIjtcXFxcbmlmICghZGF0YUl0ZW0uaXNfanNvbikge1xcXFxuICAgIGJhY2tDb2RlID0gcmVxdWVzdChydWxlTGlzdEpzb24gKyBkYXRhSXRlbS5pZCk7XFxcXG59XFxcXG5zd2l0Y2ggKGRhdGFJdGVtLmRhdGFfdHlwZSkge1xcXFxuICAgIGNhc2UgXFxcXFxcXCJob21lX3J1bGVfdXJsXFxcXFxcXCI6XFxcXG4gICAgICAgIHJ1bGVDb2RlID0gXFxcXFxcXCLmtbfpmJTop4bnlYzpppbpobXpopHpgZPop4TliJnjgJBcXFxcXFxcIiArIGRhdGFJdGVtLm5hbWUgKyBcXFxcXFxcIuOAke+/pWhvbWVfcnVsZV91cmzvv6VcXFxcXFxcIiArIHJ1bGVMaXN0SnNvbiArIGRhdGFJdGVtLmlkO1xcXFxuICAgICAgICBpbXBvcnRVcmwgPSBcXFxcXFxcInJ1bGU6Ly9cXFxcXFxcIiArIGJhc2U2NEVuY29kZShydWxlQ29kZSlcXFxcbiAgICAgICAgYnJlYWs7XFxcXG4gICAgY2FzZSAncHVibGlzaCc6XFxcXG4gICAgICAgIHJ1bGVDb2RlID0gJ+a1t+mYlOinhueVjOinhOWImeWIhuS6q++8jOW9k+WJjeWIhuS6q+eahOaYr++8micgKyBkYXRhSXRlbS5uYW1lICsgJ++/pXB1Ymxpc2jvv6UnICsgYmFzZTY0RW5jb2RlKGJhY2tDb2RlKTtcXFxcbiAgICAgICAgaW1wb3J0VXJsID0gJ3J1bGU6Ly8nICsgYmFzZTY0RW5jb2RlKHJ1bGVDb2RlKTtcXFxcbiAgICAgICAgYnJlYWs7XFxcXG4gICAgY2FzZSAnanNfdXJsJzpcXFxcbiAgICAgICAgcnVsZUNvZGUgPSAn5rW36ZiU6KeG55WM6KeE5YiZ5YiG5Lqr77yM5b2T5YmN5YiG5Lqr55qE5piv77ya572R6aG15o+S5Lu277+lanNfdXJs77+lJyArIGRhdGFJdGVtLm5hbWUgKyAnQGJhc2U2NDovLycgKyBiYXNlNjRFbmNvZGUoYmFja0NvZGUpO1xcXFxuICAgICAgICBpbXBvcnRVcmwgPSAncnVsZTovLycgKyBiYXNlNjRFbmNvZGUocnVsZUNvZGUpO1xcXFxuICAgICAgICBicmVhaztcXFxcbiAgICBjYXNlICdodG1sJzpcXFxcbiAgICAgICAgbGV0IGZpbGVfdG1wID0gZGF0YUl0ZW0ubmFtZS5zcGxpdCgnLicpO1xcXFxuICAgICAgICBsZXQgZmlsZV9wYXRoID0gZmlsZV90bXAubGVuZ3RoID4gMSA/IGZpbGVfdG1wW2ZpbGVfdG1wLmxlbmd0aCAtIDFdICsgXFxcXFxcXCIvXFxcXFxcXCIgKyBkYXRhSXRlbS5uYW1lIDogZGF0YUl0ZW0ubmFtZTtcXFxcbiAgICAgICAgcnVsZUNvZGUgPSBcXFxcXFxcIua1t+mYlOinhueVjOacrOWcsOaWh+S7tuWIhuS6q++/pWZpbGVfdXJs77+laGlrZXI6Ly9maWxlcy9ydWxlcy9kekhvdXNlL1xcXFxcXFwiICsgZmlsZV9wYXRoICsgXFxcXFxcXCJAXFxcXFxcXCIgKyBydWxlTGlzdEpzb24gKyBkYXRhSXRlbS5pZDtcXFxcbiAgICAgICAgaW1wb3J0VXJsID0gJ3J1bGU6Ly8nICsgYmFzZTY0RW5jb2RlKHJ1bGVDb2RlKTtcXFxcbiAgICAgICAgYnJlYWtcXFxcbiAgICBjYXNlIFxcXFxcXFwiY29uZmlnXFxcXFxcXCI6XFxcXG4gICAgICAgIGltcG9ydFVybCA9ICQoKS5ydWxlKHBhc3N3b3JkID0+IHtcXFxcbiAgICAgICAgICAgIGV2YWwoZmV0Y2goXFxcXFxcXCJoaWtlcjovL2Fzc2V0cy9ob21lLmpzXFxcXFxcXCIpKTtcXFxcbiAgICAgICAgICAgIEhpa2VySG9tZS5sb2FkKFxcXFxcXFwiaW1wb3J0XFxcXFxcXCIsIHBhc3N3b3JkKTtcXFxcbiAgICAgICAgfSwgYmFja0NvZGUpO1xcXFxuICAgICAgICBicmVhaztcXFxcbn1cXFxcbmxldCBteV9jb2xfdHlwZSA9IFxcXFxcXFwidGV4dF8yXFxcXFxcXCI7XFxcXG5sZXQgbXlfY29sX3R5cGUyID0gXFxcXFxcXCJ0ZXh0XzNcXFxcXFxcIjtcXFxcbmlmIChpbXBvcnRVcmwpIHtcXFxcbiAgICBkYXRhLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogXFxcXFxcXCLlr7zlhaXop4TliJlcXFxcXFxcIixcXFxcbiAgICAgICAgdXJsOiBkYXRhSXRlbS5pc19zYWZlP2ltcG9ydFVybDondG9hc3Q6Ly/po47pmanop4TliJnnpoHmraLlr7zlhaUhISEnLFxcXFxuICAgICAgICBjb2xfdHlwZTogbXlfY29sX3R5cGVcXFxcbiAgICB9KTtcXFxcbn1cXFxcbmlmIChydWxlQ29kZSkge1xcXFxuICAgIGRhdGEucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiBcXFxcXFxcIuWIhuS6q+WPo+S7pFxcXFxcXFwiLFxcXFxuICAgICAgICB1cmw6IFxcXFxcXFwiY29weTovL1xcXFxcXFwiICsgcnVsZUNvZGUsXFxcXG4gICAgICAgIGNvbF90eXBlOiBteV9jb2xfdHlwZVxcXFxuICAgIH0pO1xcXFxufVxcXFxuXFxcXG5pZiAoaW1wb3J0VXJsKSB7XFxcXG4gICAgaWYgKGRhdGFJdGVtLmlzX2pzb25fbGlzdCAmJiAhaGFzU3ViKSB7XFxcXG4gICAgICAgIGxldCBzdWJfcnVsZV9jb2RlID0gJ+a1t+mYlOinhueVjOWQiOmbhuinhOWImeiuoumYhe+/pWhvbWVfc3Vi77+lJyArIGRhdGFJdGVtLm5hbWUgKyBcXFxcXFxcIkBAXFxcXFxcXCIgKyBydWxlTGlzdEpzb24gKyBkYXRhSXRlbS5pZDtcXFxcbiAgICAgICAgbGV0IHN1Yl91cmwgPSAncnVsZTovLycgKyBiYXNlNjRFbmNvZGUoc3ViX3J1bGVfY29kZSk7XFxcXG4gICAgICAgIGRhdGEucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZTogJ+iuoumYheWQiOmbhicsXFxcXG4gICAgICAgICAgICB1cmw6IHN1Yl91cmwsXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogbXlfY29sX3R5cGUyXFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgICBkYXRhLnB1c2goe1xcXFxuICAgICAgICAgICAgdGl0bGU6ICfigJzigJzigJ3igJ08c3BhbiBzdHlsZT1cXFxcXFxcImNvbG9yOiAjZmY3MDAwXFxcXFxcXCI+5a+85YWl6L275ZCI6ZuGPC9zcGFuPicsXFxcXG4gICAgICAgICAgICB1cmw6ICQoKS5sYXp5UnVsZSgoZGF0YUl0ZW0sc3ViVXJsKT0+e1xcXFxuICAgICAgICAgICAgICAgIGNvbnN0IHtnZW5SdWxlfT0kLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvZ2VuQXBpXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgIGxldCBpbXBvcnRfcnVsZT1nZW5SdWxlKGRhdGFJdGVtLm5hbWUrXFxcXFxcXCIuXFxcXFxcXCIrZGF0YUl0ZW0uYXV0aG9yLHN1YlVybCk7XFxcXG4gICAgICAgICAgICAgICAgLy9jb3B5KGltcG9ydF9ydWxlKTtcXFxcbiAgICAgICAgICAgICAgICBsZXQgcnVsZUNvZGU9cGFyc2VQYXN0ZShpbXBvcnRfcnVsZS5zcGxpdChcXFxcXFxcIlxcXFxcXFxcblxcXFxcXFwiKVswXSk7XFxcXG4gICAgICAgICAgICAgICAgLy9yZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCJcXFxcbiAgICAgICAgICAgICAgICBpbXBvcnRVcmwgPSAncnVsZTovLycgKyBiYXNlNjRFbmNvZGUocnVsZUNvZGUpO1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBpbXBvcnRVcmxcXFxcbiAgICAgICAgICAgIH0sZGF0YUl0ZW0scnVsZUxpc3RKc29uICsgZGF0YUl0ZW0uaWQpLFxcXFxuICAgICAgICAgICAgY29sX3R5cGU6IG15X2NvbF90eXBlMlxcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgZGF0YS5wdXNoKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiAn4oCc4oCc4oCd4oCdPHNwYW4gc3R5bGU9XFxcXFxcXCJjb2xvcjogI2ZmNzAwMFxcXFxcXFwiPuWvvOWFpemBk+W+t+e7jzwvc3Bhbj4nLFxcXFxuICAgICAgICAgICAgdXJsOiAkKCkubGF6eVJ1bGUoKGRhdGFJdGVtLHN1YlVybCk9PntcXFxcbiAgICAgICAgICAgICAgICAvLyBsZXQgdGl0bGUgPSBcXFxcXFxcIkgtXFxcXFxcXCIrZGF0YUl0ZW0ubmFtZStcXFxcXFxcIi5cXFxcXFxcIitkYXRhSXRlbS5hdXRob3I7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHRpdGxlID0gXFxcXFxcXCJKLVxcXFxcXFwiK2RhdGFJdGVtLm5hbWUuc3BsaXQoJy4nKVswXTtcXFxcbiAgICAgICAgICAgICAgICBsZXQgc3ViT2JqID0ge1xcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGUsXFxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogc3ViVXJsLFxcXFxuICAgICAgICAgICAgICAgICAgICBkZXNjOiBcXFxcXFxcImhpa2VyOi8vZmlsZXMvcnVsZXMvZHpIb3VzZS9ydWxlQ2FjaGUvXFxcXFxcXCIrdGl0bGUrXFxcXFxcXCIuanNvblxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBcXFxcXFxcIlxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICBhY3RpdmU6IGZhbHNlLC8v56aB55So5bm25Y+R5pu05pawXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIGxldCBzaGFyZVRleHQgPSBiYXNlNjRFbmNvZGUoSlNPTi5zdHJpbmdpZnkoc3ViT2JqKSk7XFxcXG4gICAgICAgICAgICAgICAgdmFyIHBhc3RlcyA9IGdldFBhc3RlcygpO1xcXFxuICAgICAgICAgICAgICAgIHZhciB1cmwgPSBzaGFyZVBhc3RlKHNoYXJlVGV4dCxwYXN0ZXMuc2xpY2UoLTEpWzBdKTtcXFxcbiAgICAgICAgICAgICAgICBsZXQgaW1wb3J0X3J1bGU9IFxcXFxcXFwi6L275ZCI6ZuG6K6i6ZiF77yaXFxcXFxcXCIrdGl0bGUrJ1xcXFxcXFxcbicrdXJsO1xcXFxuICAgICAgICAgICAgICAgIGNvcHkoaW1wb3J0X3J1bGUpO1xcXFxuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSAnaGlrZXI6Ly9maWxlcy9ydWxlcy9kekhvdXNlL3J1bGVDYWNoZS9zdWIuanNvbic7XFxcXG4gICAgICAgICAgICAgICAgJC5yYyhjb25maWcubGliLnN1Yik7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIOiuoumYheWvvOWFpShwYXRoKVxcXFxuICAgICAgICAgICAgfSxkYXRhSXRlbSxydWxlTGlzdEpzb24gKyBkYXRhSXRlbS5pZCksXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogbXlfY29sX3R5cGUyXFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgICBkYXRhLnB1c2goe1xcXFxuICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwiPHNtYWxsPuaPkOekuu+8muW8gOWPkeiAheWNleeLrOWIhuS6q+eahOWQiOmbhuaWh+S7tuWPquiDveWNleeLrOWvvOWFpeOAgjwvc21hbGw+XFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJyaWNoX3RleHRcXFxcXFxcIlxcXFxuICAgICAgICB9KTtcXFxcbiAgICB9IGVsc2UgaWYgKCFkYXRhSXRlbS5pc19qc29uX2xpc3QgJiYgIWhhc1N1YiAmJiBkYXRhSXRlbS5kYXRhX3R5cGUgPT0gJ2hvbWVfcnVsZV91cmwnKSB7XFxcXG4gICAgICAgIGxldCBzdWJfcnVsZV9jb2RlID0gJ+a1t+mYlOinhueVjOWNleinhOWImeiuoumYhe+/pWhvbWVfc3Vi77+lJyArIGRhdGFJdGVtLm5hbWUgKyBcXFxcXFxcIkBAXFxcXFxcXCIgKyBydWxlTGlzdEpzb24gKyBkYXRhSXRlbS5pZCArICcmZGVidWc9dHJ1ZSc7XFxcXG4gICAgICAgIGxldCBzdWJfdXJsID0gJ3J1bGU6Ly8nICsgYmFzZTY0RW5jb2RlKHN1Yl9ydWxlX2NvZGUpO1xcXFxuICAgICAgICBkYXRhLnB1c2goe1xcXFxuICAgICAgICAgICAgdGl0bGU6ICforqLpmIXop4TliJknLFxcXFxuICAgICAgICAgICAgdXJsOiBzdWJfdXJsLFxcXFxuICAgICAgICAgICAgY29sX3R5cGU6IG15X2NvbF90eXBlXFxcXG4gICAgICAgIH0pXFxcXG4gICAgfVxcXFxufVxcXFxuaWYgKGRhdGFJdGVtLmlzX2pzb24gJiYgZGF0YUl0ZW0uZGF0YV90eXBlID09PSBcXFxcXFxcImhvbWVfcnVsZV91cmxcXFxcXFxcIiAmJiAhZGF0YUl0ZW0uaXNfanNvbl9saXN0KSB7XFxcXG4gICAgZGF0YS5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6ICfov5vlhaXpopHpgZMnLFxcXFxuICAgICAgICB1cmw6ICQoIC8qXFxcXFxcXCIjbm9Mb2FkaW5nI1xcXFxcXFwiKi8gKS5sYXp5UnVsZSgobmFtZSxob21lKSA9PiB7XFxcXG4gICAgICAgICAgICBsZXQgcnVsZUxpc3QgPSBKU09OLnBhcnNlKHJlcXVlc3QoaG9tZSkpO1xcXFxuICAgICAgICAgICAgbGV0IGhhc1J1bGUgPSBydWxlTGlzdC5zb21lKGl0ZW0gPT4gaXRlbS50aXRsZSA9PT0gbmFtZSk7XFxcXG4gICAgICAgICAgICBpZiAoaGFzUnVsZSkge1xcXFxuICAgICAgICAgICAgICAgIHB1dFZhcihcXFxcXFxcIldhcmVob3VzZS5iYWNrXFxcXFxcXCIsIFxcXFxcXFwiMVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICBiYWNrKCk7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvbWUrXFxcXFxcXCJzQFxcXFxcXFwiICsgbmFtZTtcXFxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/mnKrlronoo4VcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSwgZGF0YUl0ZW0ubmFtZSxhcGkuaG9tZSksXFxcXG4gICAgICAgIGNvbF90eXBlOiBteV9jb2xfdHlwZVxcXFxuICAgIH0pXFxcXG59XFxcXG5sZXQgbWFuX3J1bGVfc2FmZSA9IGdldEFwaShcXFxcXFxcIm1hblJ1bGVTYWZlXFxcXFxcXCIpK2RhdGFJdGVtLmlkO1xcXFxubGV0IG1hbl9ydWxlX2dvb2QgPSBnZXRBcGkoXFxcXFxcXCJtYW5SdWxlR29vZFxcXFxcXFwiKStkYXRhSXRlbS5pZDtcXFxcbi8vIGRhdGFJdGVtLmlzX3NhZmU7XFxcXG5pZihnZXRWYXIoJ2hvdXNlLmlzX21hbmFnZXInKSl7XFxcXG4gICAgZnVuY3Rpb24gc2V0SXNTYWZlKGZsYWcsbWFuX3J1bGVfc2FmZSkge1xcXFxuICAgICAgICBmbGFnID0gZmxhZyB8fCAnJztcXFxcbiAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICAgIGxldCBjb2RlID0gZmV0Y2gobWFuX3J1bGVfc2FmZSwge1xcXFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcXFxcIlVzZXItQWdlbnRcXFxcXFxcIjogTU9CSUxFX1VBfSxcXFxcbiAgICAgICAgICAgICAgICBib2R5OiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwicGFyYW1zXFxcXFxcXCI6XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJ1c2VybmFtZVxcXFxcXFwiOiBnZXRWYXIoJ2hvdXNlLnVzZXJuYW1lJyksXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJwYXNzd29yZFxcXFxcXFwiOiBnZXRWYXIoJ2hvdXNlLnBhc3N3b3JkJyksXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJpc19zYWZlXFxcXFxcXCI6ICEhZmxhZ1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgY29kZSA9IEpTT04ucGFyc2UoY29kZSkucmVzdWx0O1xcXFxuICAgICAgICAgICAgaWYgKGNvZGUuc3RhdHVzID09PSAwKSB7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvZGUuZGV0YWlsXFxcXG4gICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiAn5pON5L2c5aSx6LSlOicgKyBjb2RlLmRldGFpbFxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9IGNhdGNoIChlKSB7XFxcXG4gICAgICAgICAgICByZXR1cm4gJ+aTjeS9nOWksei0pTonICsgZS5tZXNzYWdlXFxcXG4gICAgICAgIH1cXFxcbiAgICB9XFxcXG4gICAgZnVuY3Rpb24gc2V0SXNHb29kKGZsYWcsbWFuX3J1bGVfZ29vZCkge1xcXFxuICAgICAgICBmbGFnID0gZmxhZyB8fCAnJztcXFxcbiAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICAgIGxldCBjb2RlID0gZmV0Y2gobWFuX3J1bGVfZ29vZCwge1xcXFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcXFxcIlVzZXItQWdlbnRcXFxcXFxcIjogTU9CSUxFX1VBfSxcXFxcbiAgICAgICAgICAgICAgICBib2R5OiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwicGFyYW1zXFxcXFxcXCI6XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJ1c2VybmFtZVxcXFxcXFwiOiBnZXRWYXIoJ2hvdXNlLnVzZXJuYW1lJyksXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJwYXNzd29yZFxcXFxcXFwiOiBnZXRWYXIoJ2hvdXNlLnBhc3N3b3JkJyksXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJpc19nb29kXFxcXFxcXCI6ICEhZmxhZ1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgY29kZSA9IEpTT04ucGFyc2UoY29kZSkucmVzdWx0O1xcXFxuICAgICAgICAgICAgaWYgKGNvZGUuc3RhdHVzID09PSAwKSB7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvZGUuZGV0YWlsXFxcXG4gICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiAn5pON5L2c5aSx6LSlOicgKyBjb2RlLmRldGFpbFxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9IGNhdGNoIChlKSB7XFxcXG4gICAgICAgICAgICByZXR1cm4gJ+aTjeS9nOWksei0pTonICsgZS5tZXNzYWdlXFxcXG4gICAgICAgIH1cXFxcbiAgICB9XFxcXG4gICAgZGF0YS5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6J/Cfmqvpo47pmaknLFxcXFxuICAgICAgICBjb2xfdHlwZTonc2Nyb2xsX2J1dHRvbicsXFxcXG4gICAgICAgIHVybDokKCfmoIforrDor6Xop4TliJnkuLrpo47pmak/6aOO6Zmp6KeE5YiZ5peg5rOV6KKr5a+85YWlJykuY29uZmlybSgoaWQsbWFuX3J1bGVfc2FmZSxzZXRJc1NhZmUpPT57XFxcXG4gICAgICAgICAgICBsZXQgcmV0ID0gc2V0SXNTYWZlKGZhbHNlLG1hbl9ydWxlX3NhZmUpO1xcXFxuICAgICAgICAgICAgaWYoIS/mk43kvZzlpLHotKUvLnRlc3QocmV0KSl7XFxcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovLycrcmV0XFxcXG4gICAgICAgIH0sZGF0YUl0ZW0uaWQsbWFuX3J1bGVfc2FmZSxzZXRJc1NhZmUpXFxcXG4gICAgfSk7XFxcXG4gICAgZGF0YS5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6J+Kcheato+W4uCcsXFxcXG4gICAgICAgIGNvbF90eXBlOidzY3JvbGxfYnV0dG9uJyxcXFxcbiAgICAgICAgdXJsOiQoJ+agh+iusOivpeinhOWImeS4uuato+W4uD8nKS5jb25maXJtKChpZCxtYW5fcnVsZV9zYWZlLHNldElzU2FmZSk9PntcXFxcbiAgICAgICAgICAgIGxldCByZXQgPSBzZXRJc1NhZmUodHJ1ZSxtYW5fcnVsZV9zYWZlKTtcXFxcbiAgICAgICAgICAgIGlmKCEv5pON5L2c5aSx6LSlLy50ZXN0KHJldCkpe1xcXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly8nK3JldFxcXFxuICAgICAgICB9LGRhdGFJdGVtLmlkLG1hbl9ydWxlX3NhZmUsc2V0SXNTYWZlKVxcXFxuICAgIH0pO1xcXFxuICAgIGRhdGEucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOifimaXpnZ7kvJjotKgnLFxcXFxuICAgICAgICBjb2xfdHlwZTonc2Nyb2xsX2J1dHRvbicsXFxcXG4gICAgICAgIHVybDokKCfmoIforrDor6Xop4TliJnkuLrpnZ7kvJjotKg/JykuY29uZmlybSgoaWQsbWFuX3J1bGVfZ29vZCxzZXRJc0dvb2QpPT57XFxcXG4gICAgICAgICAgICBsZXQgcmV0ID0gc2V0SXNHb29kKGZhbHNlLG1hbl9ydWxlX2dvb2QpO1xcXFxuICAgICAgICAgICAgaWYoIS/mk43kvZzlpLHotKUvLnRlc3QocmV0KSl7XFxcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovLycrcmV0XFxcXG4gICAgICAgIH0sZGF0YUl0ZW0uaWQsbWFuX3J1bGVfZ29vZCxzZXRJc0dvb2QpXFxcXG4gICAgfSk7XFxcXG4gICAgZGF0YS5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6J/CfkpbkvJjotKgnLFxcXFxuICAgICAgICBjb2xfdHlwZTonc2Nyb2xsX2J1dHRvbicsXFxcXG4gICAgICAgIHVybDokKCfmoIforrDor6Xop4TliJnkuLrkvJjotKg/JykuY29uZmlybSgoaWQsbWFuX3J1bGVfZ29vZCxzZXRJc0dvb2QpPT57XFxcXG4gICAgICAgICAgICBsZXQgcmV0ID0gc2V0SXNHb29kKHRydWUsbWFuX3J1bGVfZ29vZCk7XFxcXG4gICAgICAgICAgICBpZighL+aTjeS9nOWksei0pS8udGVzdChyZXQpKXtcXFxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8vJytyZXRcXFxcbiAgICAgICAgfSxkYXRhSXRlbS5pZCxtYW5fcnVsZV9nb29kLHNldElzR29vZClcXFxcbiAgICB9KTtcXFxcbn1cXFxcblxcXFxuZGF0YS5wdXNoKHtcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJsaW5lX2JsYW5rXFxcXFxcXCJcXFxcbn0pO1xcXFxuZGF0YS5wdXNoKHtcXFxcbiAgICB0aXRsZTogZGF0YUl0ZW0uZ29vZF9udW0sXFxcXG4gICAgcGljX3VybDogXFxcXFxcXCJoaWtlcjovL2ZpbGVzL2ljb24v6LWeLnN2Z1xcXFxcXFwiLFxcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcImljb25fc21hbGxfM1xcXFxcXFwiLFxcXFxuICAgIHVybDogXFxcXFxcXCJoaWtlcjovL3BhZ2UvTWFrZUFjb21tZW50I25vSGlzdG9yeSMjbm9SZWNvcmRIaXN0b3J5I1xcXFxcXFwiLFxcXFxuICAgIGV4dHJhOiB7XFxcXG4gICAgICAgIGlkOiBkYXRhSXRlbS5pZCxcXFxcbiAgICAgICAgbmFtZTogZGF0YUl0ZW0ubmFtZVxcXFxuICAgIH1cXFxcbn0pO1xcXFxuZGF0YS5wdXNoKHtcXFxcbiAgICB0aXRsZTogZGF0YUl0ZW0uYmFkX251bSxcXFxcbiAgICBwaWNfdXJsOiBcXFxcXFxcImhpa2VyOi8vZmlsZXMvaWNvbi/ouKkuc3ZnXFxcXFxcXCIsXFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwiaWNvbl9zbWFsbF8zXFxcXFxcXCIsXFxcXG4gICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vcGFnZS9NYWtlQWNvbW1lbnQjbm9IaXN0b3J5IyNub1JlY29yZEhpc3RvcnkjXFxcXFxcXCIsXFxcXG4gICAgZXh0cmE6IHtcXFxcbiAgICAgICAgaWQ6IGRhdGFJdGVtLmlkLFxcXFxuICAgICAgICBuYW1lOiBkYXRhSXRlbS5uYW1lLFxcXFxuICAgICAgICBkZWZhdWx0VHlwZTpcXFxcXFxcImJhZFxcXFxcXFwiXFxcXG4gICAgfVxcXFxufSk7XFxcXG5kYXRhLnB1c2goe1xcXFxuICAgIHRpdGxlOiBcXFxcXFxcIuivhOiuulxcXFxcXFwiLFxcXFxuICAgIHBpY191cmw6IFxcXFxcXFwiaGlrZXI6Ly9maWxlcy9pY29uL+ivhOiuui5zdmdcXFxcXFxcIixcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJpY29uX3NtYWxsXzNcXFxcXFxcIixcXFxcbiAgICB1cmw6IFxcXFxcXFwiaGlrZXI6Ly9wYWdlL01ha2VBY29tbWVudCNub0hpc3RvcnkjI25vUmVjb3JkSGlzdG9yeSNcXFxcXFxcIixcXFxcbiAgICBleHRyYToge1xcXFxuICAgICAgICBpZDogZGF0YUl0ZW0uaWQsXFxcXG4gICAgICAgIG5hbWU6IGRhdGFJdGVtLm5hbWVcXFxcbiAgICB9XFxcXG59KTtcXFxcbmxldCB0b3RhbFN1bSA9IGRhdGFJdGVtLmdvb2RfbnVtICsgZGF0YUl0ZW0uYmFkX251bTtcXFxcblxcXFxuZGF0YS5wdXNoKHtcXFxcbiAgICB0aXRsZTogaHRtbFRhZyhcXFxcXFxcImJpZ1xcXFxcXFwiLCBcXFxcXFxcIuivhOiuuihcXFxcXFxcIiArIHRvdGFsU3VtICsgXFxcXFxcXCIpXFxcXFxcXCIpICsgXFxcXFxcXCJcXFxcXFxcXHRcXFxcXFxcXHRcXFxcXFxcXHRcXFxcXFxcIiArIHNtYWxsKGh0bWxUYWcoXFxcXFxcXCJ1XFxcXFxcXCIsIFxcXFxcXFwi5p+l55yL5YWo6YOo6K+E6K66ID5cXFxcXFxcIikpLFxcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMVxcXFxcXFwiLFxcXFxuICAgIHVybDogXFxcXFxcXCJoaWtlcjovL3BhZ2UvQ29tbWVudFxcXFxcXFwiLFxcXFxuICAgIGV4dHJhOiB7XFxcXG4gICAgICAgIHVybDogXFxcXFxcXCJoaWtlcjovL2VtcHR5I2Z5cGFnZSNub0hpc3RvcnkjI25vUmVjb3JkSGlzdG9yeSNcXFxcXFxcIixcXFxcbiAgICAgICAgaWQ6IGRhdGFJdGVtLmlkLFxcXFxuICAgICAgICB0b3RhbFN1bTogdG90YWxTdW0sXFxcXG4gICAgICAgIG5vX2FjdGl2ZTogZmFsc2VcXFxcbiAgICB9XFxcXG59KTtcXFxcbi8vY29uc3QgbG9uZ2VzdFN1bT0xMjA7XFxcXG5sZXQgaWNvbiA9IHtcXFxcbiAgICBcXFxcXFxcImdvb2RcXFxcXFxcIjogXFxcXFxcXCLwn5GNXFxcXFxcXCIsXFxcXG4gICAgXFxcXFxcXCJiYWRcXFxcXFxcIjogXFxcXFxcXCLwn5GOXFxcXFxcXCIsXFxcXG4gICAgXFxcXFxcXCJyZXBseVxcXFxcXFwiOlxcXFxcXFwi5byA5Y+R6ICF8J+Xo1xcXFxcXFwiXFxcXG59XFxcXG5pZiAodG90YWxTdW0gPT09IDApIHtcXFxcbiAgICBkYXRhLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogXFxcXFxcXCI8aDUgc3R5bGU9J3RleHQtYWxpZ246Y2VudGVyJz7kuIDmnaHor4TorrrkuZ/msqHmnInvvIzlv6vmnaXmiqLmspnlj5HlkKfvvIE8L2g1PlxcXFxcXFwiLFxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJyaWNoX3RleHRcXFxcXFxcIlxcXFxuICAgIH0pO1xcXFxufSBlbHNlIHtcXFxcbiAgICBsZXQgY29tbWVudExpc3QgPSBKU09OLnBhcnNlKHJlcXVlc3QoYXBpLmRpc19nZXQgKyBkYXRhSXRlbS5pZCArIFxcXFxcXFwiP2xpbWl0PTVcXFxcXFxcIikpLnJlc3VsdDtcXFxcbiAgICBmb3IgKGxldCBpdGVtIG9mIGNvbW1lbnRMaXN0KSB7XFxcXG4gICAgICAgIGxldCBSZXBseSA9IGl0ZW0uZGlzY3Vzc190eXBlPT09XFxcXFxcXCJyZXBseVxcXFxcXFwiJiZpdGVtLnJlcGx5X3RvX25hbWUhPT1mYWxzZSYmaXRlbS5yZXBseV90b19pZCE9PWZhbHNlP1xcXFxcXFwi4oCY4oCY5Zue5aSNQFxcXFxcXFwiK2l0ZW0ucmVwbHlfdG9fbmFtZStcXFxcXFxcIiAjXFxcXFxcXCIraXRlbS5kaXNjdXNzX2lkK1xcXFxcXFwi4oCZ4oCZXFxcXFxcXFxuXFxcXFxcXCI6XFxcXFxcXCJcXFxcXFxcIjtcXFxcbiAgICAgICAgZGF0YS5wdXNoKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiBpdGVtLm5hbWUgKyBcXFxcXFxcIiZuYnNwOyZuYnNwOzxmb250IGNvbG9yPSdncmF5Jz48c21hbGw+I1xcXFxcXFwiICsgaXRlbS5pZCArIFxcXFxcXFwiPC9zbWFsbD48Zm9udD5cXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImF2YXRhclxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgLy91cmw6IFxcXFxcXFwidG9hc3Q6Ly9cXFxcXFxcIiArIGl0ZW0ucXEsXFxcXG4gICAgICAgICAgICB1cmw6XFxcXFxcXCJtcXF3cGE6Ly9pbS9jaGF0P2NoYXRfdHlwZT13cGEmdWluPVxcXFxcXFwiK2l0ZW0ucXEsXFxcXG4gICAgICAgICAgICBwaWNfdXJsOiBpdGVtLmF2YXRhcl91cmxcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgICAgIGRhdGEucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZTogaXRlbS5kaXNjdXNzX3RleHQsXFxcXG4gICAgICAgICAgICBkZXNjOiBSZXBseStpdGVtLmNyZWF0ZV9kYXRlICsgXFxcXFxcXCLCt1xcXFxcXFwiICsgaWNvbltpdGVtLmRpc2N1c3NfdHlwZV0sXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0XzFcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIHVybDogXFxcXFxcXCJoaWtlcjovL3BhZ2UvaW5mb1xcXFxcXFwiLFxcXFxuICAgICAgICAgICAgZXh0cmE6e1xcXFxuICAgICAgICAgICAgICAgIG5hbWU6aXRlbS5uYW1lLFxcXFxuICAgICAgICAgICAgICAgIHR5cGU6XFxcXFxcXCJsb25nX3RleHRcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICB0ZXh0Oml0ZW0uZGlzY3Vzc190ZXh0XFxcXG4gICAgICAgICAgICB9LFxcXFxuICAgICAgICAgICAgcGljX3VybDogaXRlbS5hdmF0YXJfdXJsXFxcXG4gICAgICAgIH0pO1xcXFxuICAgIH1cXFxcbiAgICBkYXRhLnB1c2goe1xcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJsaW5lX2JsYW5rXFxcXFxcXCJcXFxcbiAgICB9KTtcXFxcbn1cXFxcblxcXFxuc2V0UmVzdWx0KGRhdGEpO1xcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJyaWNoX3RleHRcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5p+l55yLXFxcIixcXFwicGF0aFxcXCI6XFxcImluZm9cXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5zZXRQYWdlVGl0bGUoXFxcXFxcXCLmn6XnnIvjgIxcXFxcXFxcIitNWV9QQVJBTVMubmFtZStcXFxcXFxcIuOAjVxcXFxcXFwiKVxcXFxuc2V0UmVzdWx0KFt7XFxcXG4gICAgdGl0bGU6IE1ZX1BBUkFNUy50ZXh0LFxcXFxuICAgIGNvbF90eXBlOk1ZX1BBUkFNUy50eXBlXFxcXG59XSk7XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5byA5Y+R6ICF5rOo5YaMXFxcIixcXFwicGF0aFxcXCI6XFxcIlJlZ2lzdGVyXFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxuc2V0UGFnZVRpdGxlKFxcXFxcXFwi5byA5Y+R6ICF5rOo5YaMXFxcXFxcXCIpO1xcXFxuY29uc3Qge1xcXFxuICAgIGdldEFwaSxcXFxcbiAgICBodG1sVGFnLFxcXFxuICAgIG1hcENvbFR5cGUsXFxcXG4gICAgc21hbGxcXFxcbn0gPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvdXRpbGl5XFxcXFxcXCIpO1xcXFxudmFyIGRhdGEgPSBbXTtcXFxcbmFkZExpc3RlbmVyKCdvbkNsb3NlJywgJC50b1N0cmluZygoKSA9PiB7XFxcXG4gICAgY2xlYXJWYXIoXFxcXFxcXCJXYXJlaG91c2UuUGFzc3dvcmRcXFxcXFxcIik7XFxcXG4gICAgY2xlYXJWYXIoXFxcXFxcXCJXYXJlaG91c2UuVXNlcm5hbWVcXFxcXFxcIik7XFxcXG4gICAgY2xlYXJWYXIoXFxcXFxcXCJXYXJlaG91c2UuRGVzY3JpcHRpb25cXFxcXFxcIik7XFxcXG4gICAgY2xlYXJWYXIoXFxcXFxcXCJXYXJlaG91c2UuVXNlckFkZHJlc3NcXFxcXFxcIik7XFxcXG59KSk7XFxcXG5hZGRMaXN0ZW5lcignb25SZWZyZXNoJywgJC50b1N0cmluZygoKT0+e1xcXFxuICAgIHB1dFZhcihcXFxcXFxcIldhcmVob3VzZS5XYWl0XFxcXFxcXCIsIFxcXFxcXFwiXFxcXFxcXCIpO1xcXFxufSkpO1xcXFxuZGF0YS5wdXNoKHtcXFxcbiAgICB0aXRsZTogJ+i0puWPtycsXFxcXG4gICAgZGVzYzogXFxcXFxcXCLor7fovpPlhaXotKblj7co5b+F5aGrKVxcXFxcXFwiLFxcXFxuICAgIGNvbF90eXBlOiAnaW5wdXQnLFxcXFxuICAgIGV4dHJhOiB7XFxcXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogZ2V0VmFyKCdXYXJlaG91c2UuVXNlcm5hbWUnLCAnJyksXFxcXG4gICAgICAgIHR5cGU6IFxcXFxcXFwibnVtYmVyXFxcXFxcXCIsXFxcXG4gICAgICAgIG9uQ2hhbmdlOiAncHV0VmFyKFxcXFxcXFwiV2FyZWhvdXNlLlVzZXJuYW1lXFxcXFxcXCIsaW5wdXQpJ1xcXFxuICAgIH1cXFxcbn0sIHtcXFxcbiAgICB0aXRsZTogJ+WvhueggScsXFxcXG4gICAgZGVzYzogXFxcXFxcXCLor7fovpPlhaXlr4bnoIEo5b+F5aGrKVxcXFxcXFwiLFxcXFxuICAgIGNvbF90eXBlOiAnaW5wdXQnLFxcXFxuICAgIGV4dHJhOiB7XFxcXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogZ2V0VmFyKCdXYXJlaG91c2UuUGFzc3dvcmQnLCAnJyksXFxcXG4gICAgICAgIHR5cGU6IFxcXFxcXFwicGFzc3dvcmRcXFxcXFxcIixcXFxcbiAgICAgICAgb25DaGFuZ2U6ICdwdXRWYXIoXFxcXFxcXCJXYXJlaG91c2UuUGFzc3dvcmRcXFxcXFxcIixpbnB1dCknXFxcXG4gICAgfVxcXFxufSk7XFxcXG5tYXBDb2xUeXBlKGRhdGEsIFxcXFxcXFwibGluZV9ibGFua1xcXFxcXFwiLCAxKTtcXFxcbmRhdGEucHVzaCh7XFxcXG4gICAgdGl0bGU6ICfmmLXnp7AnLFxcXFxuICAgIGRlc2M6IFxcXFxcXFwi6K+36L6T5YWl5pi156ewKOW/heWhqylcXFxcXFxcIixcXFxcbiAgICBjb2xfdHlwZTogJ2lucHV0JyxcXFxcbiAgICBleHRyYToge1xcXFxuICAgICAgICBkZWZhdWx0VmFsdWU6IGdldFZhcignV2FyZWhvdXNlLlVzZXJBZGRyZXNzJywgJycpLFxcXFxuICAgICAgICBvbkNoYW5nZTogJ3B1dFZhcihcXFxcXFxcIldhcmVob3VzZS5Vc2VyQWRkcmVzc1xcXFxcXFwiLGlucHV0KSdcXFxcbiAgICB9XFxcXG59LCB7XFxcXG4gICAgdGl0bGU6ICfmj4/ov7AnLFxcXFxuICAgIGRlc2M6IFxcXFxcXFwi6K+06K+05Li65LuA5LmI6KaB5rOo5YaM5ZCnXFxcXFxcXFxuKOWPr+S7peWinuWKoOmAmui/h+amgueOhyzpgInloaspXFxcXFxcXCIsXFxcXG4gICAgY29sX3R5cGU6ICdpbnB1dCcsXFxcXG4gICAgZXh0cmE6IHtcXFxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBnZXRWYXIoJ1dhcmVob3VzZS5EZXNjcmlwdGlvbicsICcnKSxcXFxcbiAgICAgICAgdHlwZTogXFxcXFxcXCJ0ZXh0YXJlYVxcXFxcXFwiLFxcXFxuICAgICAgICBvbkNoYW5nZTogJ3B1dFZhcihcXFxcXFxcIldhcmVob3VzZS5EZXNjcmlwdGlvblxcXFxcXFwiLGlucHV0KSdcXFxcbiAgICB9XFxcXG59KVxcXFxuXFxcXG5tYXBDb2xUeXBlKGRhdGEsIFxcXFxcXFwibGluZV9ibGFua1xcXFxcXFwiLCAxKTtcXFxcblxcXFxuZGF0YS5wdXNoKHtcXFxcbiAgICB0aXRsZTogaHRtbFRhZyhcXFxcXFxcImJcXFxcXFxcIiwgXFxcXFxcXCLms6jlhoxcXFxcXFxcIiksXFxcXG4gICAgdXJsOiAkKGdldEFwaShcXFxcXFxcIm5ld19kZXZcXFxcXFxcIikrXFxcXFxcXCIjbm9Mb2FkaW5nI1xcXFxcXFwiKS5sYXp5UnVsZSgoZ2V0SWQsIGNvbmZpcm0pID0+IHtcXFxcbiAgICAgICAgbGV0IHVzZXJuYW1lID0gZ2V0VmFyKCdXYXJlaG91c2UuVXNlcm5hbWUnLCBcXFxcXFxcIlxcXFxcXFwiKSxcXFxcbiAgICAgICAgICAgIHBhc3N3b3JkID0gZ2V0VmFyKCdXYXJlaG91c2UuUGFzc3dvcmQnLCBcXFxcXFxcIlxcXFxcXFwiKSxcXFxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gZ2V0VmFyKCdXYXJlaG91c2UuRGVzY3JpcHRpb24nLCBcXFxcXFxcIlxcXFxcXFwiKSxcXFxcbiAgICAgICAgICAgIG5hbWUgPSBnZXRWYXIoXFxcXFxcXCJXYXJlaG91c2UuVXNlckFkZHJlc3NcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIik7XFxcXG4gICAgICAgIGlmIChbdXNlcm5hbWUsIHBhc3N3b3JkLCBuYW1lXS5pbmNsdWRlcyhcXFxcXFxcIlxcXFxcXFwiKSkge1xcXFxuICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/otKblj7cs5a+G56CB5ZKM5pi156ew5LiN6IO95Li656m6XFxcXFxcXCI7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgc2hvd0xvYWRpbmcoXFxcXFxcXCLmraPlnKjmj5DkuqTnlLPor7fooahcXFxcXFxcIik7XFxcXG4gICAgICAgIGxldCByZXN1bHQgPSByZXF1ZXN0KGlucHV0LCB7XFxcXG4gICAgICAgICAgICBoZWFkZXJzOiB7XFxcXG4gICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xcXFxuICAgICAgICAgICAgfSxcXFxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcXFxcbiAgICAgICAgICAgICAgICBcXFxcXFxcInBhcmFtc1xcXFxcXFwiOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwicmVhc29uXFxcXFxcXCI6IGRlc2NyaXB0aW9uLFxcXFxuICAgICAgICAgICAgICAgICAgICBcXFxcXFxcIm5hbWVcXFxcXFxcIjogbmFtZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJwYXNzd29yZFxcXFxcXFwiOiBwYXNzd29yZCxcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJxcVxcXFxcXFwiOiB1c2VybmFtZVxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH0pLFxcXFxuICAgICAgICAgICAgbWV0aG9kOiAncG9zdCdcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgICAgIHJlc3VsdCA9IEpTT04ucGFyc2UocmVzdWx0KS5yZXN1bHQ7XFxcXG4gICAgICAgIGhpZGVMb2FkaW5nKCk7XFxcXG4gICAgICAgIGlmIChyZXN1bHQuc3RhdHVzICE9PSAwKSB7XFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL1xcXFxcXFwiICsgcmVzdWx0LmRldGFpbDtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBsZXQgaWRyZXN1bHQgPSBKU09OLnBhcnNlKHJlcXVlc3QoZ2V0SWQgKyBcXFxcXFxcIj9xcT1cXFxcXFxcIiArIHVzZXJuYW1lKSk7XFxcXG4gICAgICAgIGlmIChpZHJlc3VsdC5zdGF0dXMgIT09IDApIHtcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8vXFxcXFxcXCIgKyBpZHJlc3VsdC5kZXRhaWw7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgXFxcXG4gICAgICAgIHJldHVybiAkKFxcXFxcXFwiXFxcXFxcXCIsIFxcXFxcXFwi6L6T5YWl6YKu566x6aqM6K+B56CBXFxcXFxcXFxuXFxcXFxcXCIgKyByZXN1bHQuZGV0YWlsKS5pbnB1dCgoY29uZmlybSwgaWQsIGFjY291bnQpID0+IHtcXFxcbiAgICAgICAgICAgIHNob3dMb2FkaW5nKFxcXFxcXFwi6K+36ICQ5b+D562J5b6FXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gcmVxdWVzdChjb25maXJtLCB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcXFxcbiAgICAgICAgICAgICAgICAgICAgfSxcXFxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJwYXJhbXNcXFxcXFxcIjoge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXFxcXFwicmVnaXN0X2lkXFxcXFxcXCI6IGlkLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXFxcXFwieXptXFxcXFxcXCI6IGlucHV0XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgICAgIH0pLFxcXFxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJ1xcXFxuICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IEpTT04ucGFyc2UocmVzdWx0KS5yZXN1bHQ7XFxcXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgIT09IDApIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgaGlkZUxvYWRpbmcoKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly9cXFxcXFxcIiArIHJlc3VsdC5kZXRhaWw7XFxcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgcHV0VmFyKFxcXFxcXFwiV2FyZWhvdXNlVXNlcm5hbWVcXFxcXFxcIiwgYWNjb3VudFswXSk7XFxcXG4gICAgICAgICAgICAgICAgICAgIHB1dFZhcihcXFxcXFxcIldhcmVob3VzZVBhc3N3b3JkXFxcXFxcXCIsIGFjY291bnRbMV0pO1xcXFxuICAgICAgICAgICAgICAgICAgICBoaWRlTG9hZGluZygpO1xcXFxuICAgICAgICAgICAgICAgICAgICBiYWNrKCk7XFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5oiQ5Yqf5o+Q5Lqk5rOo5YaM5rOo5YaMXFxcXFxcXFxuXFxcXFxcXCIrcmVzdWx0LmRldGFpbDtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XFxcXG4gICAgICAgICAgICAgICAgaGlkZUxvYWRpbmcoKTtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+WHuumUmeS6huWRkFxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9LCBjb25maXJtLCBpZHJlc3VsdC5yZXN1bHQsIFt1c2VybmFtZSwgcGFzc3dvcmRdKTtcXFxcbiAgICB9LCBnZXRBcGkoXFxcXFxcXCJuZXdfZ2V0SWRcXFxcXFxcIiksIGdldEFwaShcXFxcXFxcIm5ld19jb25maXJtXFxcXFxcXCIpKSxcXFxcbiAgICBjb2xfdHlwZTogJ3RleHRfY2VudGVyXzEnXFxcXG59KTtcXFxcbnNldFJlc3VsdChkYXRhKTtcXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwidGV4dF8xXFxcIixcXFwibmFtZVxcXCI6XFxcIuS4quS6uui1hOaWmVxcXCIsXFxcInBhdGhcXFwiOlxcXCJQZXJzb25hbERhdGFcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5zZXRQYWdlVGl0bGUoXFxcXFxcXCLkuKrkurrotYTmlplcXFxcXFxcIik7XFxcXG52YXIgZGF0YT1bXTtcXFxcbmNvbnN0IHtcXFxcbiAgICBnZXRBcGksXFxcXG4gICAgZ2V0RmlsZSxcXFxcbiAgICBhcGlcXFxcbn0gPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvdXRpbGl5XFxcXFxcXCIpO1xcXFxuXFxcXG5kYXRhLnB1c2goe1xcXFxuICAgIGNvbF90eXBlOlxcXFxcXFwibGluZV9ibGFua1xcXFxcXFwiXFxcXG59KTtcXFxcblxcXFxubGV0IHt1c2VybmFtZSxwYXNzd29yZH0gPSBnZXRGaWxlKCk7XFxcXG5sZXQgZGV2ID0gSlNPTi5wYXJzZShyZXF1ZXN0KGdldEFwaShcXFxcXFxcInVzZXJcXFxcXFxcIikrTVlfUEFSQU1TLmlkKSkucmVzdWx0O1xcXFxuZGF0YS5wdXNoKHtcXFxcbiAgICB0aXRsZTpcXFxcXFxcIuWktOWDj1xcXFxcXFwiLFxcXFxuICAgIGRlc2M6ZGV2LmF2YXRhcixcXFxcbiAgICB1cmw6XFxcXFxcXCJoaWtlcjovL3BhZ2UvbW9kaWZ5X1BlcnNvbmFsRGF0YSNub0hpc3RvcnkjI25vUmVjb3JkSGlzdG9yeSNcXFxcXFxcIixcXFxcbiAgICBleHRyYTp7XFxcXG4gICAgICAgIGRldjpkZXYsXFxcXG4gICAgICAgIHVzZXJuYW1lOnVzZXJuYW1lLFxcXFxuICAgICAgICBwYXNzd29yZDpwYXNzd29yZCxcXFxcbiAgICAgICAgUGF0dGVybjowXFxcXG4gICAgfSxcXFxcbiAgICBjb2xfdHlwZTpcXFxcXFxcInRleHRfMVxcXFxcXFwiXFxcXG59KTtcXFxcblxcXFxuXFxcXG5kYXRhLnB1c2goe1xcXFxuICAgIHRpdGxlOlxcXFxcXFwi5pi156ewXFxcXFxcXCIsXFxcXG4gICAgZGVzYzpkZXYubmFtZSxcXFxcbiAgICB1cmw6XFxcXFxcXCJoaWtlcjovL3BhZ2UvbW9kaWZ5X1BlcnNvbmFsRGF0YSNub0hpc3RvcnkjI25vUmVjb3JkSGlzdG9yeSNcXFxcXFxcIixcXFxcbiAgICBleHRyYTp7XFxcXG4gICAgICAgIGRldjpkZXYsXFxcXG4gICAgICAgIHVzZXJuYW1lOnVzZXJuYW1lLFxcXFxuICAgICAgICBwYXNzd29yZDpwYXNzd29yZCxcXFxcbiAgICAgICAgUGF0dGVybjoxXFxcXG4gICAgfSxcXFxcbiAgICBjb2xfdHlwZTpcXFxcXFxcInRleHRfMVxcXFxcXFwiXFxcXG59KTtcXFxcblxcXFxuZGF0YS5wdXNoKHtcXFxcbiAgICB0aXRsZTpcXFxcXFxcIuWvhueggVxcXFxcXFwiLFxcXFxuICAgIHVybDpcXFxcXFxcImhpa2VyOi8vcGFnZS9tb2RpZnlfUGVyc29uYWxEYXRhI25vSGlzdG9yeSMjbm9SZWNvcmRIaXN0b3J5I1xcXFxcXFwiLFxcXFxuICAgIGV4dHJhOntcXFxcbiAgICAgICAgZGV2OmRldixcXFxcbiAgICAgICAgdXNlcm5hbWU6dXNlcm5hbWUsXFxcXG4gICAgICAgIHBhc3N3b3JkOnBhc3N3b3JkLFxcXFxuICAgICAgICBQYXR0ZXJuOjJcXFxcbiAgICB9LFxcXFxuICAgIGNvbF90eXBlOlxcXFxcXFwidGV4dF8xXFxcXFxcXCJcXFxcbn0pO1xcXFxuZGF0YS5wdXNoKHtcXFxcbiAgICBjb2xfdHlwZTpcXFxcXFxcImxpbmVfYmxhbmtcXFxcXFxcIlxcXFxufSk7XFxcXG5kYXRhLnB1c2goe1xcXFxuICAgIHRpdGxlOlxcXFxcXFwi6LSm5Y+377yaXFxcXFxcXCIrdXNlcm5hbWUsXFxcXG4gICAgdXJsOlxcXFxcXFwiY29weTovL1xcXFxcXFwiK3VzZXJuYW1lLFxcXFxuICAgIGNvbF90eXBlOlxcXFxcXFwidGV4dF8xXFxcXFxcXCJcXFxcbn0pO1xcXFxuZGF0YS5wdXNoKHtcXFxcbiAgICB0aXRsZTpcXFxcXFxcIlVJRO+8mlxcXFxcXFwiK2Rldi5pZCxcXFxcbiAgICB1cmw6XFxcXFxcXCJjb3B5Oi8vXFxcXFxcXCIrZGV2LmlkLFxcXFxuICAgIGNvbF90eXBlOlxcXFxcXFwidGV4dF8xXFxcXFxcXCJcXFxcbn0pO1xcXFxuZGF0YS5wdXNoKHtcXFxcbiAgICBjb2xfdHlwZTpcXFxcXFxcImxpbmVfYmxhbmtcXFxcXFxcIlxcXFxufSk7XFxcXG5kYXRhLnB1c2goe1xcXFxuICAgIHRpdGxlOlxcXFxcXFwi5o+Q5Lqk5LqR5LuT5bqT6KeE5YiZXFxcXFxcXCIsXFxcXG4gICAgdXJsOiQoXFxcXFxcXCIjbm9Mb2FkaW5nI1xcXFxcXFwiKS5sYXp5UnVsZSgoaG9zdCk9PntcXFxcbiAgICAgICAgbGV0IGNvZGU9cmVxdWVzdChob3N0K1xcXFxcXFwiL2hpa2VydWxlL3J1bGVsaXN0Lmpzb24/aWQ9MTQ1XFxcXFxcXCIpO1xcXFxuICAgICAgICBsZXQgd29yZD1cXFxcXFxcIu+/pXB1Ymxpc2jvv6VcXFxcXFxcIitiYXNlNjRFbmNvZGUoY29kZSk7XFxcXG4gICAgICAgIHJldHVybiBcXFxcXFxcInJ1bGU6Ly9cXFxcXFxcIitiYXNlNjRFbmNvZGUod29yZCk7XFxcXG4gICAgfSxhcGkuaG9zdCksXFxcXG4gICAgY29sX3R5cGU6XFxcXFxcXCJ0ZXh0XzFcXFxcXFxcIlxcXFxufSk7XFxcXG5kYXRhLnB1c2goe1xcXFxuICAgIHRpdGxlOlxcXFxcXFwi5ZCM5q2l5o+Q5Lqk5LqR5LuT5bqT6LSm5Y+35a+G56CBXFxcXFxcXCIsXFxcXG4gICAgdXJsOlxcXFxcXFwicnVsZTovL1xcXFxcXFwiK2Jhc2U2NEVuY29kZShcXFxcXFxcIu+/pXB1Ymxpc2hfYWNjb3VudO+/pVxcXFxcXFwiK3VzZXJuYW1lK1xcXFxcXFwiQFxcXFxcXFwiK3Bhc3N3b3JkKSxcXFxcbiAgICBjb2xfdHlwZTpcXFxcXFxcInRleHRfMVxcXFxcXFwiXFxcXG59KTtcXFxcbmRhdGEucHVzaCh7XFxcXG4gICAgY29sX3R5cGU6XFxcXFxcXCJsaW5lX2JsYW5rXFxcXFxcXCJcXFxcbn0pO1xcXFxuZGF0YS5wdXNoKHtcXFxcbiAgICB0aXRsZTpcXFxcXFxcIuS9oOS4gOWFseWPkeW4g+S6huOAjFxcXFxcXFwiK2Rldi5ydWxlX251bStcXFxcXFxcIuOAjeadoeinhOWImVxcXFxcXFwiLFxcXFxuICAgIHVybDpcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIixcXFxcbiAgICBjb2xfdHlwZTpcXFxcXFxcInRleHRfMVxcXFxcXFwiXFxcXG59KTtcXFxcbmRhdGEucHVzaCh7XFxcXG4gICAgY29sX3R5cGU6XFxcXFxcXCJsaW5lX2JsYW5rXFxcXFxcXCJcXFxcbn0pO1xcXFxubGV0IHVzZXIgPSBnZXRGaWxlKCk7XFxcXG5kYXRhLnB1c2goe1xcXFxuICAgIHRpdGxlOlxcXFxcXFwi5rOo6ZSA55m75b2VXFxcXFxcXCIsXFxcXG4gICAgdXJsOiQoXFxcXFxcXCLnoa7orqTms6jplIDnmbvlvZU/XFxcXFxcXCIpLmNvbmZpcm0oZiA9PiB7XFxcXG4gICAgICAgIGYudXNlcm5hbWU9XFxcXFxcXCJcXFxcXFxcIjtcXFxcbiAgICAgICAgZi5wYXNzd29yZD1cXFxcXFxcIlxcXFxcXFwiO1xcXFxuICAgICAgICB3cml0ZUZpbGUoJ2hpa2VyOi8vZmlsZXMvV2FyZWhvdXNlVVNFUi5qc29uJywgSlNPTi5zdHJpbmdpZnkoZikpO1xcXFxuICAgICAgICBwdXRWYXIoXFxcXFxcXCJXYXJlaG91c2UuYmFja1xcXFxcXFwiLFxcXFxcXFwiMVxcXFxcXFwiKTtcXFxcbiAgICAgICAgYmFjaygpO1xcXFxuICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+W3suazqOmUgFxcXFxcXFwiO1xcXFxuICAgIH0sdXNlciksXFxcXG4gICAgY29sX3R5cGU6XFxcXFxcXCJ0ZXh0X2NlbnRlcl8xXFxcXFxcXCJcXFxcbn0pO1xcXFxuc2V0UmVzdWx0KGRhdGEpO1xcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIuabtOaUueS4quS6uui1hOaWmVxcXCIsXFxcInBhdGhcXFwiOlxcXCJtb2RpZnlfUGVyc29uYWxEYXRhXFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxuY29uc3Qge1xcXFxuICAgIGdldEFwaSxcXFxcbiAgICBjb2xvcixcXFxcbiAgICBzbWFsbCxcXFxcbiAgICBnZXRGaWxlLFxcXFxuICAgIGh0bWxUYWdcXFxcbn0gPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvdXRpbGl5XFxcXFxcXCIpO1xcXFxubGV0IHtcXFxcbiAgICBkZXYsXFxcXG4gICAgdXNlcm5hbWUsXFxcXG4gICAgcGFzc3dvcmQsXFxcXG4gICAgUGF0dGVyblxcXFxufSA9IE1ZX1BBUkFNUztcXFxcbnZhciBkYXRhID0gW107XFxcXG5sZXQgcGF0aCA9IFxcXFxcXFwiP3FxPVxcXFxcXFwiICsgdXNlcm5hbWUgKyBcXFxcXFxcIiZwYXNzd29yZD1cXFxcXFxcIiArIHBhc3N3b3JkO1xcXFxuYWRkTGlzdGVuZXIoJ29uQ2xvc2UnLCAkLnRvU3RyaW5nKCgpID0+IHtcXFxcbiAgICBjbGVhclZhcihcXFxcXFxcIldhcmVob3VzZS5tLnBldE5hbWVcXFxcXFxcIik7XFxcXG4gICAgY2xlYXJWYXIoXFxcXFxcXCJXYXJlaG91c2UubS5hdmF0YXJcXFxcXFxcIik7XFxcXG4gICAgY2xlYXJWYXIoXFxcXFxcXCJXYXJlaG91c2UubS5QYXNzd29yZC5jXFxcXFxcXCIpO1xcXFxuICAgIGNsZWFyVmFyKFxcXFxcXFwiV2FyZWhvdXNlLm0uUGFzc3dvcmQueFxcXFxcXFwiKTtcXFxcbiAgICBjbGVhclZhcihcXFxcXFxcIldhcmVob3VzZS5tLlBhc3N3b3JkLnlcXFxcXFxcIik7XFxcXG59KSk7XFxcXG5mdW5jdGlvbiBtX3BldE5hbWUoKSB7XFxcXG4gICAgZGF0YS5wdXNoKHtcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwibGluZV9ibGFua1xcXFxcXFwiXFxcXG4gICAgfSk7XFxcXG4gICAgZGF0YS5wdXNoKHtcXFxcbiAgICAgICAgY29sX3R5cGU6ICdpbnB1dCcsXFxcXG4gICAgICAgIGRlc2M6IFxcXFxcXFwi6K+36L6T5YWl5paw5pi156ewXFxcXFxcXCIsXFxcXG4gICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICB0aXRsZVZpc2libGU6IGZhbHNlLFxcXFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBnZXRWYXIoJ1dhcmVob3VzZS5tLnBldE5hbWUnLCAnJyl8fGRldi5uYW1lLFxcXFxuICAgICAgICAgICAgb25DaGFuZ2U6ICdwdXRWYXIoXFxcXFxcXCJXYXJlaG91c2UubS5wZXROYW1lXFxcXFxcXCIsaW5wdXQpJ1xcXFxuICAgICAgICB9XFxcXG4gICAgfSk7XFxcXG4gICAgZGF0YS5wdXNoKHtcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwibGluZV9ibGFua1xcXFxcXFwiXFxcXG4gICAgfSk7XFxcXG4gICAgZGF0YS5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IFxcXFxcXFwi5L+d5a2YXFxcXFxcXCIsXFxcXG4gICAgICAgIHVybDogJChnZXRBcGkoXFxcXFxcXCJtb2RpZnlfbmFtZVxcXFxcXFwiKSArIHBhdGgpLmxhenlSdWxlKCgpID0+IHtcXFxcbiAgICAgICAgICAgIGxldCBuZXdQZXROYW1lID0gZ2V0VmFyKCdXYXJlaG91c2UubS5wZXROYW1lJywgJycpO1xcXFxuICAgICAgICAgICAgaWYgKG5ld1BldE5hbWUgPT0gXFxcXFxcXCJcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5L2g6L+Y5LuA5LmI6YO95rKh5aGr5ZWKIVxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHJlcXVlc3QoaW5wdXQgKyBcXFxcXFxcIiZuYW1lPVxcXFxcXFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KG5ld1BldE5hbWUpKTtcXFxcbiAgICAgICAgICAgIHJlc3VsdCA9IEpTT04ucGFyc2UocmVzdWx0KTtcXFxcbiAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSAwKSB7XFxcXG4gICAgICAgICAgICAgICAgYmFjaygpO1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5L+u5pS55oiQ5YqfXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8vXFxcXFxcXCIgKyByZXN1bHQuZGV0YWlsO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9KSxcXFxcbiAgICAgICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJ1xcXFxuICAgIH0pO1xcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiBtX2F2YXRhcigpIHtcXFxcbiAgICBkYXRhLnB1c2goe1xcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJsaW5lX2JsYW5rXFxcXFxcXCJcXFxcbiAgICB9KTtcXFxcbiAgICBkYXRhLnB1c2goe1xcXFxuICAgICAgICBjb2xfdHlwZTogJ2lucHV0JyxcXFxcbiAgICAgICAgZGVzYzogXFxcXFxcXCLor7fovpPlhaXmlrDnmoTlpLTlg4/pk77mjqVcXFxcXFxcIixcXFxcbiAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgIHRpdGxlVmlzaWJsZTogZmFsc2UsXFxcXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IGdldFZhcignV2FyZWhvdXNlLm0uYXZhdGFyJywgJycpIHx8IGRldi5hdmF0YXIsXFxcXG4gICAgICAgICAgICBvbkNoYW5nZTogJ3B1dFZhcihcXFxcXFxcIldhcmVob3VzZS5tLmF2YXRhclxcXFxcXFwiLGlucHV0KSdcXFxcbiAgICAgICAgfVxcXFxuICAgIH0pO1xcXFxuICAgIGRhdGEucHVzaCh7XFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImxpbmVfYmxhbmtcXFxcXFxcIlxcXFxuICAgIH0pO1xcXFxuICAgIGRhdGEucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiBcXFxcXFxcIuS/neWtmFxcXFxcXFwiLFxcXFxuICAgICAgICB1cmw6ICQoZ2V0QXBpKFxcXFxcXFwibW9kaWZ5X2F2YVxcXFxcXFwiKSArIHBhdGgpLmxhenlSdWxlKCgpID0+IHtcXFxcbiAgICAgICAgICAgIGxldCBuZXdBdmF0YXIgPSBnZXRWYXIoJ1dhcmVob3VzZS5tLmF2YXRhcicsICcnKTtcXFxcbiAgICAgICAgICAgIFxcXFxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHJlcXVlc3QoaW5wdXQgKyBcXFxcXFxcIiZhdmF0YXJfdXJsPVxcXFxcXFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KG5ld0F2YXRhcikpO1xcXFxuICAgICAgICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZShyZXN1bHQpO1xcXFxuICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IDApIHtcXFxcbiAgICAgICAgICAgICAgICBiYWNrKCk7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/kv67mlLnmiJDlip9cXFxcXFxcIjtcXFxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly9cXFxcXFxcIiArIHJlc3VsdC5kZXRhaWw7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0pLFxcXFxuICAgICAgICBjb2xfdHlwZTogJ3RleHRfY2VudGVyXzEnXFxcXG4gICAgfSk7XFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIG1fcHdkKCkge1xcXFxuICAgIGRhdGEucHVzaCh7XFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImxpbmVfYmxhbmtcXFxcXFxcIlxcXFxuICAgIH0pO1xcXFxuICAgIGRhdGEucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOlxcXFxcXFwi5Y6f5a+G56CBXFxcXFxcXCIsXFxcXG4gICAgICAgIGNvbF90eXBlOiAnaW5wdXQnLFxcXFxuICAgICAgICBkZXNjOiBcXFxcXFxcIuivt+i+k+WFpeWOn+WvhueggVxcXFxcXFwiLFxcXFxuICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgdHlwZTpcXFxcXFxcInBhc3N3b3JkXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IGdldFZhcignV2FyZWhvdXNlLm0uUGFzc3dvcmQueScsICcnKSxcXFxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiAncHV0VmFyKFxcXFxcXFwiV2FyZWhvdXNlLm0uUGFzc3dvcmQueVxcXFxcXFwiLGlucHV0KSdcXFxcbiAgICAgICAgfVxcXFxuICAgIH0pO1xcXFxuICAgIGRhdGEucHVzaCh7XFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImxpbmVfYmxhbmtcXFxcXFxcIlxcXFxuICAgIH0pO1xcXFxuICAgIGRhdGEucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOlxcXFxcXFwi5paw5a+G56CBXFxcXFxcXCIsXFxcXG4gICAgICAgIGNvbF90eXBlOiAnaW5wdXQnLFxcXFxuICAgICAgICBkZXNjOiBcXFxcXFxcIuivt+i+k+WFpeaWsOWvhueggVxcXFxcXFwiLFxcXFxuICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgdHlwZTpcXFxcXFxcInBhc3N3b3JkXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IGdldFZhcignV2FyZWhvdXNlLm0uUGFzc3dvcmQueCcsICcnKSxcXFxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiAncHV0VmFyKFxcXFxcXFwiV2FyZWhvdXNlLm0uUGFzc3dvcmQueFxcXFxcXFwiLGlucHV0KSdcXFxcbiAgICAgICAgfVxcXFxuICAgIH0pO1xcXFxuICAgIGRhdGEucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOlxcXFxcXFwi6YeN5aSN5paw5a+G56CBXFxcXFxcXCIsXFxcXG4gICAgICAgIGNvbF90eXBlOiAnaW5wdXQnLFxcXFxuICAgICAgICBkZXNjOiBcXFxcXFxcIuivt+mHjeWkjeaWsOWvhueggVxcXFxcXFwiLFxcXFxuICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgdHlwZTpcXFxcXFxcInBhc3N3b3JkXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICB0aXRsZVZpc2libGU6IGZhbHNlLFxcXFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBnZXRWYXIoJ1dhcmVob3VzZS5tLlBhc3N3b3JkLmMnLCAnJyksXFxcXG4gICAgICAgICAgICBvbkNoYW5nZTogJ3B1dFZhcihcXFxcXFxcIldhcmVob3VzZS5tLlBhc3N3b3JkLmNcXFxcXFxcIixpbnB1dCknXFxcXG4gICAgICAgIH1cXFxcbiAgICB9KTtcXFxcbiAgICBkYXRhLnB1c2goe1xcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJsaW5lX2JsYW5rXFxcXFxcXCJcXFxcbiAgICB9KTtcXFxcbiAgICBkYXRhLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogXFxcXFxcXCLkv53lrZhcXFxcXFxcIixcXFxcbiAgICAgICAgdXJsOiAkKGdldEFwaShcXFxcXFxcIm1vZGlmeV9wd2RcXFxcXFxcIikrcGF0aCkubGF6eVJ1bGUoKHBhc3N3b3JkLHVzZXJuYW1lKSA9PiB7XFxcXG4gICAgICAgICAgICBsZXQgb2xkX3Bhc3N3b3JkID0gZ2V0VmFyKCdXYXJlaG91c2UubS5QYXNzd29yZC55JywgJycpO1xcXFxuICAgICAgICAgICAgbGV0IG5ld19wYXNzd29yZCA9IGdldFZhcignV2FyZWhvdXNlLm0uUGFzc3dvcmQueCcsICcnKTtcXFxcbiAgICAgICAgICAgIGxldCBuZXdfcGFzc3dvcmRfYWdhaW4gPSBnZXRWYXIoJ1dhcmVob3VzZS5tLlBhc3N3b3JkLmMnLCAnJyk7XFxcXG4gICAgICAgICAgICBpZiAob2xkX3Bhc3N3b3JkIT09cGFzc3dvcmQpIHtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+WOn+WvhueggemUmeivr1xcXFxcXFwiO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgaWYobmV3X3Bhc3N3b3JkPT09XFxcXFxcXCJcXFxcXFxcIil7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/or7fovpPlhaXmlrDlr4bnoIFcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIGlmKG5ld19wYXNzd29yZCE9PW5ld19wYXNzd29yZF9hZ2Fpbil7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/kuKTmrKHlr4bnoIHkuI3lkIxcXFxcXFxcIlxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHJlcXVlc3QoaW5wdXQgKyBcXFxcXFxcIiZuZXdfcGFzc3dvcmQ9XFxcXFxcXCIgKyBuZXdfcGFzc3dvcmQrXFxcXFxcXCImbmV3X3Bhc3N3b3JkX3JlPVxcXFxcXFwiK25ld19wYXNzd29yZF9hZ2Fpbik7XFxcXG4gICAgICAgICAgICByZXN1bHQgPSBKU09OLnBhcnNlKHJlc3VsdCk7XFxcXG4gICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gMCkge1xcXFxuICAgICAgICAgICAgICAgIHdyaXRlRmlsZShcXFxcXFxcImhpa2VyOi8vZmlsZXMvV2FyZWhvdXNlVVNFUi5qc29uXFxcXFxcXCIsSlNPTi5zdHJpbmdpZnkoe1xcXFxuICAgICAgICAgICAgICAgICAgICB1c2VybmFtZTp1c2VybmFtZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQ6bmV3X3Bhc3N3b3JkXFxcXG4gICAgICAgICAgICAgICAgfSkpO1xcXFxuICAgICAgICAgICAgICAgIGJhY2soKTtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+S/ruaUueaIkOWKn1xcXFxcXFwiO1xcXFxuICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL1xcXFxcXFwiICsgcmVzdWx0LmRldGFpbDtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSxwYXNzd29yZCx1c2VybmFtZSksXFxcXG4gICAgICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMSdcXFxcbiAgICB9KTtcXFxcbn1cXFxcblxcXFxuc3dpdGNoIChQYXR0ZXJuKSB7XFxcXG4gICAgY2FzZSAwOlxcXFxuICAgICAgICBzZXRQYWdlVGl0bGUoXFxcXFxcXCLkv67mlLnlpLTlg49cXFxcXFxcIik7XFxcXG4gICAgICAgIG1fYXZhdGFyKCk7XFxcXG4gICAgICAgIGJyZWFrO1xcXFxuICAgIGNhc2UgMTpcXFxcbiAgICAgICAgc2V0UGFnZVRpdGxlKFxcXFxcXFwi5L+u5pS55pi156ewXFxcXFxcXCIpO1xcXFxuICAgICAgICBtX3BldE5hbWUoKTtcXFxcbiAgICAgICAgYnJlYWs7XFxcXG4gICAgY2FzZSAyOlxcXFxuICAgICAgICBzZXRQYWdlVGl0bGUoXFxcXFxcXCLkv67mlLnlr4bnoIFcXFxcXFxcIik7XFxcXG4gICAgICAgIG1fcHdkKCk7XFxcXG4gICAgICAgIGJyZWFrO1xcXFxufVxcXFxuc2V0UmVzdWx0KGRhdGEpO1xcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIue8lui+keinhOWImeWkh+azqFxcXCIsXFxcInBhdGhcXFwiOlxcXCJzZXRfcnVsZV9ub3Rlc1xcXCIsXFxcInJ1bGVcXFwiOlxcXCJqczpcXFxcbmxldCBkYXRhID0gW107XFxcXG5jb25zdCB7XFxcXG4gICAgZ2V0QXBpXFxcXG59ID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3V0aWxpeVxcXFxcXFwiKTtcXFxcbmxldCB7XFxcXG4gICAgaWQsXFxcXG4gICAgdXNlcm5hbWUsXFxcXG4gICAgcGFzc3dvcmQsXFxcXG4gICAgbmFtZVxcXFxufSA9IE1ZX1BBUkFNUztcXFxcbnNldFBhZ2VUaXRsZShcXFxcXFxcIuWkh+azqOOAjFxcXFxcXFwiK25hbWUrXFxcXFxcXCLjgI1cXFxcXFxcIik7XFxcXG5hZGRMaXN0ZW5lcignb25DbG9zZScsXFxcXFxcXCJjbGVhclZhcignV2FyZWhvdXNlLnJ1bGUubm90ZXMnLCAnJylcXFxcXFxcIik7XFxcXG5sZXQgbm90ZXM9cmVxdWVzdChnZXRBcGkoXFxcXFxcXCJnZXRfcnVsZV9ub3RlXFxcXFxcXCIpK2lkKTtcXFxcbm5vdGVzPUpTT04ucGFyc2Uobm90ZXMpLnJlc3VsdDtcXFxcbmRhdGEucHVzaCh7XFxcXG4gICAgZGVzYzogXFxcXFxcXCLop4TliJnlpIfms6guLi4uLi5cXFxcXFxcIixcXFxcbiAgICBjb2xfdHlwZTogJ2lucHV0JyxcXFxcbiAgICBleHRyYToge1xcXFxuICAgICAgICB0aXRsZVZpc2libGU6IGZhbHNlLFxcXFxuICAgICAgICBkZWZhdWx0VmFsdWU6IGdldFZhcignV2FyZWhvdXNlLnJ1bGUubm90ZXMnLCAnJyl8fG5vdGVzfHxcXFxcXFxcIlxcXFxcXFwiLFxcXFxuICAgICAgICB0eXBlOiBcXFxcXFxcInRleHRhcmVhXFxcXFxcXCIsXFxcXG4gICAgICAgIGhlaWdodDotMSxcXFxcbiAgICAgICAgb25DaGFuZ2U6ICdwdXRWYXIoXFxcXFxcXCJXYXJlaG91c2UucnVsZS5ub3Rlc1xcXFxcXFwiLGlucHV0KSdcXFxcbiAgICB9XFxcXG59KTtcXFxcblxcXFxuZGF0YS5wdXNoKHtcXFxcbiAgICB0aXRsZTogXFxcXFxcXCLkv53lrZhcXFxcXFxcIixcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0X2NlbnRlcl8xXFxcXFxcXCIsXFxcXG4gICAgdXJsOiAkKGdldEFwaShcXFxcXFxcInNldF9ydWxlX25vdGVcXFxcXFxcIikgKyBpZCkubGF6eVJ1bGUoKHVzZXJuYW1lLCBwYXNzd29yZCkgPT4ge1xcXFxuICAgICAgICBsZXQgbm90ZXMgPSBnZXRWYXIoJ1dhcmVob3VzZS5ydWxlLm5vdGVzJywgJycpO1xcXFxuICAgICAgICBsZXQgcmVzdWx0ID0gcmVxdWVzdChpbnB1dCwge1xcXFxuICAgICAgICAgICAgaGVhZGVyczoge1xcXFxuICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcXFxcbiAgICAgICAgICAgIH0sXFxcXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJwYXJhbXNcXFxcXFxcIjoge1xcXFxuICAgICAgICAgICAgICAgICAgICBcXFxcXFxcInFxXFxcXFxcXCI6IHVzZXJuYW1lLFxcXFxuICAgICAgICAgICAgICAgICAgICBcXFxcXFxcInBhc3N3b3JkXFxcXFxcXCI6IHBhc3N3b3JkLFxcXFxuICAgICAgICAgICAgICAgICAgICBcXFxcXFxcIm5vdGVcXFxcXFxcIjpub3Rlc1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH0pLFxcXFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCdcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgICAgIHJlc3VsdCA9IEpTT04ucGFyc2UocmVzdWx0KS5yZXN1bHQ7XFxcXG4gICAgICAgIGlmIChyZXN1bHQuc3RhdHVzICE9PSAwKSB7XFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL1xcXFxcXFwiICsgcmVzdWx0LmRldGFpbDtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBiYWNrKGZhbHNlKTtcXFxcbiAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/kv67mlLnmiJDlip9cXFxcXFxcIjtcXFxcbiAgICB9LCB1c2VybmFtZSwgcGFzc3dvcmQpXFxcXG59KTtcXFxcbnNldFJlc3VsdChkYXRhKTtcXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibGluZVxcXCIsXFxcIm5hbWVcXFwiOlxcXCLor4TorrrliJfooahcXFwiLFxcXCJwYXRoXFxcIjpcXFwiQ29tbWVudFxcXCIsXFxcInJ1bGVcXFwiOlxcXCJqczpcXFxcbnNldFBhZ2VUaXRsZShcXFxcXFxcIuivhOiuuuWIl+ihqFxcXFxcXFwiKTtcXFxcbmNvbnN0IHtcXFxcbiAgICBhcGlcXFxcbn0gPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvdXRpbGl5XFxcXFxcXCIpO1xcXFxubGV0IGRhdGEgPSBbXTtcXFxcbmxldCB7XFxcXG4gICAgdG90YWxTdW0sXFxcXG4gICAgaWQsXFxcXG4gICAgbm9fYWN0aXZlLFxcXFxuICAgIHVzZXJuYW1lLFxcXFxuICAgIHBhc3N3b3JkXFxcXG59ID0gTVlfUEFSQU1TO1xcXFxubGV0IHBhZ2UgPSBwYXJzZUludChNWV9VUkwuc3BsaXQoXFxcXFxcXCIjXFxcXFxcXCIpWzFdKTtcXFxcbmxldCBkaXNjdXNzX3R5cGUgPSBnZXRWYXIoXFxcXFxcXCJXYXJlaG91c2UuY29tbWVudC5kaXNjdXNzX3R5cGVcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIik7XFxcXG5pZiAocGFnZSA9PT0gMSkge1xcXFxuICAgIGRhdGEucHVzaCh7XFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImxpbmVfYmxhbmtcXFxcXFxcIlxcXFxuICAgIH0pO1xcXFxuICAgIGFkZExpc3RlbmVyKCdvbkNsb3NlJywgJC50b1N0cmluZygoKSA9PiB7XFxcXG4gICAgICAgIHB1dFZhcihcXFxcXFxcIldhcmVob3VzZS5jb21tZW50LmRpc2N1c3NfdHlwZVxcXFxcXFwiLCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbiAgICB9KSk7XFxcXG4gICAgZGF0YS5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IFxcXFxcXFwi5YWo6YOoXFxcXFxcXCIgKyAoZGlzY3Vzc190eXBlID09PSBcXFxcXFxcIlxcXFxcXFwiID8gXFxcXFxcXCLil4lcXFxcXFxcIiA6IFxcXFxcXFwi4peLXFxcXFxcXCIpLFxcXFxuICAgICAgICB1cmw6ICQoXFxcXFxcXCIjbm9Mb2FkaW5nI1xcXFxcXFwiKS5sYXp5UnVsZSgoKSA9PiB7XFxcXG4gICAgICAgICAgICBwdXRWYXIoXFxcXFxcXCJXYXJlaG91c2UuY29tbWVudC5kaXNjdXNzX3R5cGVcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiO1xcXFxuICAgICAgICB9KSxcXFxcbiAgICAgICAgY29sX3R5cGU6ICd0ZXh0XzQnXFxcXG5cXFxcbiAgICB9KTtcXFxcbiAgICBkYXRhLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogXFxcXFxcXCLwn5GN6LWeXFxcXFxcXCIgKyAoZGlzY3Vzc190eXBlID09PSBcXFxcXFxcImdvb2RcXFxcXFxcIiA/IFxcXFxcXFwi4peJXFxcXFxcXCIgOiBcXFxcXFxcIuKXi1xcXFxcXFwiKSxcXFxcbiAgICAgICAgdXJsOiAkKFxcXFxcXFwiI25vTG9hZGluZyNcXFxcXFxcIikubGF6eVJ1bGUoKCkgPT4ge1xcXFxuICAgICAgICAgICAgcHV0VmFyKFxcXFxcXFwiV2FyZWhvdXNlLmNvbW1lbnQuZGlzY3Vzc190eXBlXFxcXFxcXCIsIFxcXFxcXFwiZ29vZFxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCI7XFxcXG4gICAgICAgIH0pLFxcXFxuICAgICAgICBjb2xfdHlwZTogJ3RleHRfNCdcXFxcblxcXFxuICAgIH0pO1xcXFxuICAgIGRhdGEucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiBcXFxcXFxcIvCfkY7ouKlcXFxcXFxcIiArIChkaXNjdXNzX3R5cGUgPT09IFxcXFxcXFwiYmFkXFxcXFxcXCIgPyBcXFxcXFxcIuKXiVxcXFxcXFwiIDogXFxcXFxcXCLil4tcXFxcXFxcIiksXFxcXG4gICAgICAgIHVybDogJChcXFxcXFxcIiNub0xvYWRpbmcjXFxcXFxcXCIpLmxhenlSdWxlKCgpID0+IHtcXFxcbiAgICAgICAgICAgIHB1dFZhcihcXFxcXFxcIldhcmVob3VzZS5jb21tZW50LmRpc2N1c3NfdHlwZVxcXFxcXFwiLCBcXFxcXFxcImJhZFxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCI7XFxcXG4gICAgICAgIH0pLFxcXFxuICAgICAgICBjb2xfdHlwZTogJ3RleHRfNCdcXFxcbiAgICB9KTtcXFxcbiAgICBkYXRhLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogXFxcXFxcXCLlm57lpI1cXFxcXFxcIiArIChkaXNjdXNzX3R5cGUgPT09IFxcXFxcXFwicmVwbHlcXFxcXFxcIiA/IFxcXFxcXFwi4peJXFxcXFxcXCIgOiBcXFxcXFxcIuKXi1xcXFxcXFwiKSxcXFxcbiAgICAgICAgdXJsOiAkKFxcXFxcXFwiI25vTG9hZGluZyNcXFxcXFxcIikubGF6eVJ1bGUoKCkgPT4ge1xcXFxuICAgICAgICAgICAgcHV0VmFyKFxcXFxcXFwiV2FyZWhvdXNlLmNvbW1lbnQuZGlzY3Vzc190eXBlXFxcXFxcXCIsIFxcXFxcXFwicmVwbHlcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiO1xcXFxuICAgICAgICB9KSxcXFxcbiAgICAgICAgY29sX3R5cGU6ICd0ZXh0XzQnXFxcXG4gICAgfSk7XFxcXG59XFxcXG5cXFxcblxcXFxubGV0IGljb24gPSB7XFxcXG4gICAgXFxcXFxcXCJnb29kXFxcXFxcXCI6IFxcXFxcXFwi8J+RjVxcXFxcXFwiLFxcXFxuICAgIFxcXFxcXFwiYmFkXFxcXFxcXCI6IFxcXFxcXFwi8J+RjlxcXFxcXFwiLFxcXFxuICAgIFxcXFxcXFwicmVwbHlcXFxcXFxcIjpcXFxcXFxcIuW8gOWPkeiAhfCfl6NcXFxcXFxcIlxcXFxufVxcXFxubGV0IGNvbnRyb2w9KHBpZCxhY3RpdmUpPT52b2lkIDA7XFxcXG5pZihub19hY3RpdmUpe1xcXFxuICAgIGNvbnRyb2w9ZnVuY3Rpb24ocGlkLGFjdGl2ZSl7XFxcXG4gICAgICAgIGRhdGEucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZTphY3RpdmU/XFxcXFxcXCLpmpDol4/or4TorrpcXFxcXFxcIjpcXFxcXFxcIuWxleekuuivhOiuulxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgdXJsOiQoYXBpLmRpc19kZXZfY29udHJvbCtwaWQrXFxcXFxcXCI/cXE9XFxcXFxcXCIgKyB1c2VybmFtZSArIFxcXFxcXFwiJnBhc3N3b3JkPVxcXFxcXFwiICsgcGFzc3dvcmQrXFxcXFxcXCIjbm9Mb2FkaW5nI1xcXFxcXFwiKS5sYXp5UnVsZSgoKT0+e1xcXFxuICAgICAgICAgICAgICAgIGxldCByZXN1bHQ9SlNPTi5wYXJzZShyZXF1ZXN0KGlucHV0KSk7XFxcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly9cXFxcXFxcIityZXN1bHQuZGV0YWlsO1xcXFxuICAgICAgICAgICAgfSksXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTpcXFxcXFxcInRleHRfMlxcXFxcXFwiXFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgICBkYXRhLnB1c2goe1xcXFxuICAgICAgICAgICAgdGl0bGU6XFxcXFxcXCLliKDpmaTor4TorrpcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIHVybDokKFxcXFxcXFwi56Gu6K6k5Yig6Zmk6K+l6K+E6K66P1xcXFxcXFwiKS5jb25maXJtKChpbnB1dCk9PntcXFxcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0PUpTT04ucGFyc2UocmVxdWVzdChpbnB1dCkpO1xcXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKVxcXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8vXFxcXFxcXCIrcmVzdWx0LmRldGFpbDtcXFxcbiAgICAgICAgICAgIH0sYXBpLmRpc19kZXZfY29udHJvbCtwaWQrXFxcXFxcXCI/cXE9XFxcXFxcXCIgKyB1c2VybmFtZSArIFxcXFxcXFwiJnBhc3N3b3JkPVxcXFxcXFwiICsgcGFzc3dvcmQrXFxcXFxcXCImZGVsZXRlPTFcXFxcXFxcIiksXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTpcXFxcXFxcInRleHRfMlxcXFxcXFwiXFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgICBkYXRhLnB1c2goe1xcXFxuICAgICAgICAgICAgY29sX3R5cGU6XFxcXFxcXCJsaW5lXFxcXFxcXCJcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgICAgIGRhdGEucHVzaCh7XFxcXG4gICAgICAgICAgICBjb2xfdHlwZTpcXFxcXFxcImxpbmVcXFxcXFxcIlxcXFxuICAgICAgICB9KTtcXFxcbiAgICB9XFxcXG59XFxcXG5pZiAodG90YWxTdW0gPT09IDApIHtcXFxcbiAgICBkYXRhLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogXFxcXFxcXCI8aDUgc3R5bGU9J3RleHQtYWxpZ246Y2VudGVyJz7kuIDmnaHor4TorrrkuZ/msqHmnInvvIzlv6vmnaXmiqLmspnlj5HlkKfvvIE8L2g1PlxcXFxcXFwiLFxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJyaWNoX3RleHRcXFxcXFxcIlxcXFxuICAgIH0pO1xcXFxufSBlbHNlIHtcXFxcbiAgICBsZXQgY29tbWVudExpc3QgPSBKU09OLnBhcnNlKHJlcXVlc3QoYXBpLmRpc19nZXQgKyBpZCArIFxcXFxcXFwiP2xpbWl0PTUmcGFnZT1cXFxcXFxcIiArIHBhZ2UgKyBcXFxcXFxcIiZub19hY3RpdmU9XFxcXFxcXCIgKyBub19hY3RpdmUgKyBcXFxcXFxcIiZkaXNjdXNzX3R5cGU9XFxcXFxcXCIgKyBkaXNjdXNzX3R5cGUpKS5yZXN1bHQ7XFxcXG4gICAgZm9yIChsZXQgaXRlbSBvZiBjb21tZW50TGlzdCkge1xcXFxuICAgICAgICBsZXQgUmVwbHkgPSBpdGVtLmRpc2N1c3NfdHlwZT09PVxcXFxcXFwicmVwbHlcXFxcXFxcIiYmaXRlbS5yZXBseV90b19uYW1lIT09ZmFsc2UmJml0ZW0ucmVwbHlfdG9faWQhPT1mYWxzZT9cXFxcXFxcIuKAmOKAmOWbnuWkjUBcXFxcXFxcIitpdGVtLnJlcGx5X3RvX25hbWUrXFxcXFxcXCIgI1xcXFxcXFwiK2l0ZW0uZGlzY3Vzc19pZCtcXFxcXFxcIuKAmeKAmVxcXFxcXFxcblxcXFxcXFwiOlxcXFxcXFwiXFxcXFxcXCI7XFxcXG4gICAgICAgIGRhdGEucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZTogaXRlbS5uYW1lICsgXFxcXFxcXCImbmJzcDsmbmJzcDs8Zm9udCBjb2xvcj0nZ3JheSc+PHNtYWxsPiNcXFxcXFxcIiArIGl0ZW0uaWQgKyBcXFxcXFxcIjwvc21hbGw+PGZvbnQ+XFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJhdmF0YXJcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIC8vdXJsOiBub19hY3RpdmU/XFxcXFxcXCJoaWtlcjovL3BhZ2UvUmVwbHlcXFxcXFxcIjpcXFxcXFxcInRvYXN0Oi8vXFxcXFxcXCIgKyBpdGVtLnFxLFxcXFxuXFxcXHRcXFxcdCAgICAgICB1cmw6bm9fYWN0aXZlP1xcXFxcXFwiaGlrZXI6Ly9wYWdlL1JlcGx5XFxcXFxcXCI6XFxcXFxcXCJtcXF3cGE6Ly9pbS9jaGF0P2NoYXRfdHlwZT13cGEmdWluPVxcXFxcXFwiK2l0ZW0ucXEsXFxcXG4gICAgICAgICAgICBleHRyYTp7XFxcXG4gICAgICAgICAgICAgICAgcnVsZUlkOiBpZCxcXFxcbiAgICAgICAgICAgICAgICBuYW1lOiBpdGVtLm5hbWUsXFxcXG4gICAgICAgICAgICAgICAgcGFzc3dvcmQ6IHBhc3N3b3JkLFxcXFxuICAgICAgICAgICAgICAgIHVzZXJuYW1lOiB1c2VybmFtZSxcXFxcbiAgICAgICAgICAgICAgICByZXBseUlkOml0ZW0uaWRcXFxcbiAgICAgICAgICAgIH0sXFxcXG4gICAgICAgICAgICBwaWNfdXJsOiBpdGVtLmF2YXRhcl91cmxcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgICAgIGRhdGEucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZTogaXRlbS5kaXNjdXNzX3RleHQsXFxcXG4gICAgICAgICAgICBkZXNjOiBSZXBseStpdGVtLmNyZWF0ZV9kYXRlICsgXFxcXFxcXCLCt1xcXFxcXFwiICsgaWNvbltpdGVtLmRpc2N1c3NfdHlwZV0sXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0XzFcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIHVybDogXFxcXFxcXCJoaWtlcjovL3BhZ2UvaW5mb1xcXFxcXFwiLFxcXFxuICAgICAgICAgICAgZXh0cmE6e1xcXFxuICAgICAgICAgICAgICAgIG5hbWU6aXRlbS5uYW1lLFxcXFxuICAgICAgICAgICAgICAgIHR5cGU6XFxcXFxcXCJsb25nX3RleHRcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICB0ZXh0Oml0ZW0uZGlzY3Vzc190ZXh0XFxcXG4gICAgICAgICAgICB9LFxcXFxuICAgICAgICAgICAgcGljX3VybDogaXRlbS5hdmF0YXJfdXJsXFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgICBjb250cm9sKGl0ZW0uaWQsaXRlbS5hY3RpdmUpO1xcXFxuICAgIH1cXFxcbiAgICBpZiAoY29tbWVudExpc3QubGVuZ3RoID09PSAwKSB7XFxcXG4gICAgICAgIGRhdGEucHVzaCh7XFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJsaW5lX2JsYW5rXFxcXFxcXCJcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgfVxcXFxufVxcXFxuXFxcXG5zZXRSZXN1bHQoZGF0YSlcXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLlj5Hooajor4TorrpcXFwiLFxcXCJwYXRoXFxcIjpcXFwiTWFrZUFjb21tZW50XFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxubGV0IGRhdGEgPSBbXTtcXFxcbmNvbnN0IHtcXFxcbiAgICBhcGksXFxcXG4gICAgZ2V0RmlsZVxcXFxufSA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS91dGlsaXlcXFxcXFxcIik7XFxcXG5sZXQge1xcXFxuICAgIGlkLFxcXFxuICAgIG5hbWUsXFxcXG4gICAgZGVmYXVsdFR5cGVcXFxcbn0gPSBNWV9QQVJBTVM7XFxcXG5sZXQgdXNlcj1nZXRGaWxlKCkudXNlcnx8W1xcXFxcXFwiXFxcXFxcXCIsXFxcXFxcXCJcXFxcXFxcIl07XFxcXG5cXFxcbnNldFBhZ2VUaXRsZShcXFxcXFxcIuivhOiuuihcXFxcXFxcIiArIG5hbWUgKyBcXFxcXFxcIilcXFxcXFxcIik7XFxcXG5hZGRMaXN0ZW5lcignb25DbG9zZScsICQudG9TdHJpbmcoKCkgPT4ge1xcXFxuICAgIGNsZWFyVmFyKFxcXFxcXFwiV2FyZWhvdXNlLmNvbW1lbnQudHlwZVxcXFxcXFwiKTtcXFxcbiAgICBjbGVhclZhcihcXFxcXFxcIldhcmVob3VzZS5jb21tZW50LnRleHRcXFxcXFxcIik7XFxcXG4gICAgY2xlYXJWYXIoXFxcXFxcXCJXYXJlaG91c2UuY29tbWVudC5xcVxcXFxcXFwiKTtcXFxcbiAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxcXG59KSk7XFxcXG5sZXQgdHlwZSA9IGdldFZhcihcXFxcXFxcIldhcmVob3VzZS5jb21tZW50LnR5cGVcXFxcXFxcIikgfHwgZGVmYXVsdFR5cGV8fFxcXFxcXFwiZ29vZFxcXFxcXFwiO1xcXFxuZGF0YS5wdXNoKHtcXFxcbiAgICBkZXNjOiBcXFxcXFxcIuivhOiuui4uLi4uLlxcXFxcXFwiLFxcXFxuICAgIGNvbF90eXBlOiAnaW5wdXQnLFxcXFxuICAgIGV4dHJhOiB7XFxcXG4gICAgICAgIHRpdGxlVmlzaWJsZTogZmFsc2UsXFxcXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogZ2V0VmFyKCdXYXJlaG91c2UuY29tbWVudC50ZXh0JywgJycpLFxcXFxuICAgICAgICB0eXBlOiBcXFxcXFxcInRleHRhcmVhXFxcXFxcXCIsXFxcXG4gICAgICAgIGhlaWdodDo3LFxcXFxuICAgICAgICBvbkNoYW5nZTogJ3B1dFZhcihcXFxcXFxcIldhcmVob3VzZS5jb21tZW50LnRleHRcXFxcXFxcIixpbnB1dCknXFxcXG4gICAgfVxcXFxufSk7XFxcXG5kYXRhLnB1c2goe1xcXFxuICAgIHRpdGxlOlxcXFxcXFwi6LSm5Y+377yaXFxcXFxcXCIrKHVzZXJbMF18fFxcXFxcXFwiXFxcXFxcXCIpLFxcXFxuICAgIGRlc2M6XFxcXFxcXCLpqozor4HnoIHvvJpcXFxcXFxcIisodXNlclsxXXx8XFxcXFxcXCJcXFxcXFxcIiksXFxcXG4gICAgdXJsOlxcXFxcXFwiaGlrZXI6Ly9wYWdlL1VzZXJyZWdpc3RyYXRpb25cXFxcXFxcIixcXFxcbiAgICBjb2xfdHlwZTogJ3RleHRfMScsXFxcXG4gICAgXFxcXG59KTtcXFxcblxcXFxuZGF0YS5wdXNoKHtcXFxcbiAgICB0aXRsZTogICh0eXBlID09PSBcXFxcXFxcImdvb2RcXFxcXFxcIiA/IFxcXFxcXFwi4peJXFxcXFxcXCIgOiBcXFxcXFxcIuKXi1xcXFxcXFwiKStcXFxcXFxcIiDwn5GNXFxcXFxcXCIsXFxcXG4gICAgdXJsOiAkKFxcXFxcXFwiI25vTG9hZGluZyNcXFxcXFxcIikubGF6eVJ1bGUoKCkgPT4ge1xcXFxuICAgICAgICBwdXRWYXIoXFxcXFxcXCJXYXJlaG91c2UuY29tbWVudC50eXBlXFxcXFxcXCIsIFxcXFxcXFwiZ29vZFxcXFxcXFwiKTtcXFxcbiAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcbiAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiO1xcXFxuICAgIH0pLFxcXFxuICAgIGNvbF90eXBlOiAndGV4dF8yJ1xcXFxuXFxcXG59KTtcXFxcbmRhdGEucHVzaCh7XFxcXG4gICAgdGl0bGU6ICAodHlwZSA9PT0gXFxcXFxcXCJiYWRcXFxcXFxcIiA/IFxcXFxcXFwi4peJXFxcXFxcXCIgOiBcXFxcXFxcIuKXi1xcXFxcXFwiKStcXFxcXFxcIiDwn5GOXFxcXFxcXCIsXFxcXG4gICAgdXJsOiAkKFxcXFxcXFwiI25vTG9hZGluZyNcXFxcXFxcIikubGF6eVJ1bGUoKCkgPT4ge1xcXFxuICAgICAgICBwdXRWYXIoXFxcXFxcXCJXYXJlaG91c2UuY29tbWVudC50eXBlXFxcXFxcXCIsIFxcXFxcXFwiYmFkXFxcXFxcXCIpO1xcXFxuICAgICAgICByZWZyZXNoUGFnZSgpO1xcXFxuICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCI7XFxcXG4gICAgfSksXFxcXG4gICAgY29sX3R5cGU6ICd0ZXh0XzInXFxcXG59KTtcXFxcblxcXFxuZGF0YS5wdXNoKHtcXFxcbiAgICB0aXRsZTogXFxcXFxcXCLmj5DkuqRcXFxcXFxcIixcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0X2NlbnRlcl8xXFxcXFxcXCIsXFxcXG4gICAgdXJsOiAkKGFwaS5kaXNfbmV3ICsgaWQpLmxhenlSdWxlKChBY2NvdW50KSA9PiB7XFxcXG4gICAgICAgIGxldCB0ZXh0ID0gZ2V0VmFyKCdXYXJlaG91c2UuY29tbWVudC50ZXh0JywgJycpO1xcXFxuICAgICAgICBsZXQgW3FxLGF1dGhfY29kZV0gPSBBY2NvdW50O1xcXFxuICAgICAgICBsZXQgdHlwZSA9IGdldFZhcignV2FyZWhvdXNlLmNvbW1lbnQudHlwZScpIHx8ICdnb29kJztcXFxcbiAgICAgICAgcXE9cXF8fFxcXFxcXFwiXFxcXFxcXCI7XFxcXG4gICAgICAgIGF1dGhfY29kZT1hdXRoX2NvZGV8fFxcXFxcXFwiXFxcXFxcXCI7XFxcXG4gICAgICAgIGlmKHFxPT1cXFxcXFxcIlxcXFxcXFwifHxhdXRoX2NvZGU9PVxcXFxcXFwiXFxcXFxcXCIpe1xcXFxuICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/mnKrnmbvlvZXotKblj7dcXFxcXFxcIjtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBpZih0ZXh0PT1cXFxcXFxcIlxcXFxcXFwiKXtcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5L2g6L+Y5LuA5LmI6YO95rKh5YaZ5ZWKXFxcXFxcXCI7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgZnVuY3Rpb24gcihwKSB7XFxcXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gcmVxdWVzdChpbnB1dCwge1xcXFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xcXFxuICAgICAgICAgICAgICAgIH0sXFxcXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocCksXFxcXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCdcXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmVzdWx0KS5yZXN1bHQ7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgbGV0IHAgPSB7XFxcXG4gICAgICAgICAgICBcXFxcXFxcInBhcmFtc1xcXFxcXFwiOiB7XFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJkaXNjdXNzX3RleHRcXFxcXFxcIjogdGV4dCxcXFxcbiAgICAgICAgICAgICAgICBcXFxcXFxcInFxXFxcXFxcXCI6IHFxLFxcXFxuICAgICAgICAgICAgICAgIFxcXFxcXFwiZGlzY3Vzc190eXBlXFxcXFxcXCI6IHR5cGUsXFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJhdXRoX2NvZGVcXFxcXFxcIjogYXV0aF9jb2RlXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgbGV0IHJlc3VsdCA9IHIocCk7XFxcXG4gICAgICAgIGlmKHJlc3VsdC5zdGF0dXM9PT0wKXtcXFxcbiAgICAgICAgICAgIGJhY2soZmFsc2UpO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8vXFxcXFxcXCIrcmVzdWx0LmRldGFpbDtcXFxcblxcXFxuICAgIH0sdXNlcilcXFxcbn0pO1xcXFxuXFxcXG5zZXRSZXN1bHQoZGF0YSk7XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5Lyq55So5oi35rOo5YaMXFxcIixcXFwicGF0aFxcXCI6XFxcIlVzZXJyZWdpc3RyYXRpb25cXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5jb25zdCB7XFxcXG4gICAgYXBpLFxcXFxuICAgIGdldEZpbGUsXFxcXG4gICAgZ2V0VXNlckRhdGVcXFxcbn0gPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvdXRpbGl5XFxcXFxcXCIpO1xcXFxubGV0IGRhdGEgPSBbXTtcXFxcbmRhdGEucHVzaCh7XFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwibGluZV9ibGFua1xcXFxcXFwiXFxcXG59KTtcXFxcbnNldFBhZ2VUaXRsZShcXFxcXFxcIueUqOaIt+WIl+ihqOeuoeeQhlxcXFxcXFwiKTtcXFxcbmFkZExpc3RlbmVyKCdvbkNsb3NlJywgJC50b1N0cmluZygoKSA9PiB7XFxcXG4gICAgY2xlYXJWYXIoXFxcXFxcXCJXYXJlaG91c2UubS5xcVxcXFxcXFwiKTtcXFxcbiAgICBjbGVhclZhcihcXFxcXFxcIldhcmVob3VzZS5tLnl6bVxcXFxcXFwiKTtcXFxcbn0pKTtcXFxcbmxldCB1c2VyID0gZ2V0RmlsZSgpO1xcXFxubGV0IHVzZXJOYW1lID0gdXNlci51c2VyIHx8IFtcXFxcXFxcIlxcXFxcXFwiXTtcXFxcbnVzZXJOYW1lID0gdXNlck5hbWVbMF07XFxcXG5kYXRhLnB1c2goe1xcXFxuICAgIHRpdGxlOiBcXFxcXFxcIuKAnOKAnOKAneKAnTxiaWc+KOa3u+WKoC/pqozor4Ep6LSm5Y+3PC9iaWc+XFxcXFxcXCIsXFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF8xXFxcXFxcXCIsXFxcXG4gICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIlxcXFxufSk7XFxcXG5cXFxcbmRhdGEucHVzaCh7XFxcXG4gICAgdGl0bGU6IFxcXFxcXFwi6I635Y+WXFxcXFxcXCIsXFxcXG4gICAgY29sX3R5cGU6ICdpbnB1dCcsXFxcXG4gICAgZGVzYzogXFxcXFxcXCLor7fovpPlhaVxcVxcXFxcXFwiLFxcXFxuICAgIHVybDogJC50b1N0cmluZygoYSwgYikgPT4ge1xcXFxuICAgICAgICBsZXQgcXEgPSBpbnB1dDtcXFxcbiAgICAgICAgaWYgKHFxID09IFxcXFxcXFwiXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5L2g6L+Y5LuA5LmI6YO95rKh5aGr5ZWKIVxcXFxcXFwiO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHNob3dMb2FkaW5nKFxcXFxcXFwi6I635Y+W5LitLi4uXFxcXFxcXCIpXFxcXG4gICAgICAgIHJldHVybiAkKFxcXFxcXFwiI25vTG9hZGluZyNcXFxcXFxcIikubGF6eVJ1bGUoKHFxLCBhLCBiKSA9PiB7XFxcXG4gICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gcmVxdWVzdChhLCB7XFxcXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xcXFxuICAgICAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXFxcXG4gICAgICAgICAgICAgICAgfSxcXFxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwicGFyYW1zXFxcXFxcXCI6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcXFxcXFwicXFcXFxcXFxcIjogcXFcXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIH0pLFxcXFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnXFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgIHJlc3VsdCA9IEpTT04ucGFyc2UocmVzdWx0KS5yZXN1bHQ7XFxcXG4gICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gMCkge1xcXFxuICAgICAgICAgICAgICAgIGhpZGVMb2FkaW5nKCk7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly9cXFxcXFxcIiArIHJlc3VsdC5kZXRhaWw7XFxcXG4gICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgIGxldCByZXN1bHQyID0gSlNPTi5wYXJzZShyZXF1ZXN0KGIgKyBcXFxcXFxcIj9xcT1cXFxcXFxcIiArIHFxKSk7XFxcXG4gICAgICAgICAgICAgICAgaGlkZUxvYWRpbmcoKTtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL1xcXFxcXFwiICsgcmVzdWx0Mi5kZXRhaWw7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICAgIGhpZGVMb2FkaW5nKCk7XFxcXG4gICAgICAgICAgICB0aHJvdyBlO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIH0sIHFxLCBhLCBiKTtcXFxcblxcXFxuICAgIH0sIGFwaS5kaXNfbmV3X3VzZXIsIGFwaS5kaXNfdmVyaWZ5KSxcXFxcbiAgICBleHRyYToge1xcXFxuICAgICAgICB0eXBlOiBcXFxcXFxcIm51bWJlclxcXFxcXFwiLFxcXFxuICAgICAgICBkZWZhdWx0VmFsdWU6IGdldFZhcignV2FyZWhvdXNlLm0ucXEnLCAnJykgfHwgdXNlck5hbWUsXFxcXG4gICAgICAgIG9uQ2hhbmdlOiAncHV0VmFyKFxcXFxcXFwiV2FyZWhvdXNlLm0ucXFcXFxcXFxcIixpbnB1dCknXFxcXG4gICAgfVxcXFxufSk7XFxcXG5cXFxcbmRhdGEucHVzaCh7XFxcXG4gICAgY29sX3R5cGU6ICdpbnB1dCcsXFxcXG4gICAgZGVzYzogXFxcXFxcXCLor7fovpPlhaXpqozor4HnoIFcXFxcXFxcIixcXFxcbiAgICBleHRyYToge1xcXFxuICAgICAgICB0aXRsZVZpc2libGU6IGZhbHNlLFxcXFxuICAgICAgICBkZWZhdWx0VmFsdWU6IGdldFZhcignV2FyZWhvdXNlLm0ueXptJywgJycpLFxcXFxuICAgICAgICBvbkNoYW5nZTogJ3B1dFZhcihcXFxcXFxcIldhcmVob3VzZS5tLnl6bVxcXFxcXFwiLGlucHV0KSdcXFxcbiAgICB9XFxcXG59KTtcXFxcbmRhdGEucHVzaCh7XFxcXG4gICAgY29sX3R5cGU6ICdyaWNoX3RleHQnLFxcXFxuICAgIHRpdGxlOiBcXFxcXFxcIjxzbWFsbD7mj5DnpLrvvJoxLuavj+WkqeWPquiDveiOt+WPljXmrKHpqozor4HnoIEuPGJyPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOzIuPHM+6aqM6K+B56CB5pyJ5pWI5pyf5oyB57ut5LiA5ZGo5bem5Y+zPC9zPijmmoLml7bkuI3kvJrvvIzlv5jorrDpqozor4HnoIHlj6/pgJrov4dRUeWPt+iOt+WPlik8L3NtYWxsPlxcXFxcXFwiXFxcXG59KTtcXFxcblxcXFxubGV0IHVzZXJMaXN0ID0gZ2V0VXNlckRhdGUoKTtcXFxcbmRhdGEucHVzaCh7XFxcXG4gICAgdGl0bGU6IFxcXFxcXFwi6aqM6K+BL+eZu+W9lVxcXFxcXFwiLFxcXFxuICAgIHVybDogJChcXFxcXFxcIuehruWumuS/neWtmO+8jOmqjOivgeeggeWhq+mUme+8jOaXoOazleivhOiuuuWTplxcXFxcXFwiKS5jb25maXJtKChmLCBsLCBsb2dpbikgPT4ge1xcXFxuICAgICAgICBsZXQgcXEgPSBnZXRWYXIoJ1dhcmVob3VzZS5tLnFxJywgJycpO1xcXFxuICAgICAgICBsZXQgeXptID0gZ2V0VmFyKCdXYXJlaG91c2UubS55em0nLCAnJyk7XFxcXG4gICAgICAgIGlmIChxcSA9PSBcXFxcXFxcIlxcXFxcXFwiIHx8IHl6bSA9PSBcXFxcXFxcIlxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL3Fx5oiW6aqM6K+B56CB5Li656m6XFxcXFxcXCI7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgbGV0IHJlc3VsdCA9IHJlcXVlc3QobG9naW4sIHtcXFxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXFxcXG4gICAgICAgICAgICB9LFxcXFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xcXFxuICAgICAgICAgICAgICAgIFxcXFxcXFwicGFyYW1zXFxcXFxcXCI6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJxcVxcXFxcXFwiOiBxcSxcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJhdXRoX2NvZGVcXFxcXFxcIjogeXptXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSksXFxcXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJ1xcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZShyZXN1bHQpLnJlc3VsdDtcXFxcbiAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IDApIHtcXFxcbiAgICAgICAgICAgIGYudXNlciA9IFtxcSwgeXptXTtcXFxcbiAgICAgICAgICAgIHdyaXRlRmlsZShcXFxcXFxcImhpa2VyOi8vZmlsZXMvV2FyZWhvdXNlVVNFUi5qc29uXFxcXFxcXCIsIEpTT04uc3RyaW5naWZ5KGYpKTtcXFxcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGwuZmluZEluZGV4KGl0ZW0gPT4gaXRlbVswXSA9PT0gcXEpO1xcXFxuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcXFxcbiAgICAgICAgICAgICAgICBsLnNwbGljZShpbmRleCwgMSwgW3FxLCB5em1dKTtcXFxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobC5sZW5ndGggPCA2KSB7XFxcXG4gICAgICAgICAgICAgICAgbC5wdXNoKFtxcSwgeXptXSk7XFxcXG4gICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgIGwuc3BsaWNlKDAsIDEpO1xcXFxuICAgICAgICAgICAgICAgIGwucHVzaChbcXEsIHl6bV0pO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgd3JpdGVGaWxlKFxcXFxcXFwiaGlrZXI6Ly9maWxlcy9XYXJlaG91c2VVU0VSQS5qc29uXFxcXFxcXCIsIEpTT04uc3RyaW5naWZ5KGwpKTtcXFxcbiAgICAgICAgICAgIGJhY2soKTtcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v6aqM6K+B5oiQ5YqfXFxcXFxcXCI7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly9cXFxcXFxcIiArIHJlc3VsdC5kZXRhaWw7XFxcXG4gICAgfSwgdXNlciwgdXNlckxpc3QsIGFwaS5kaXNfbG9naW4pLFxcXFxuICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMSdcXFxcbn0pO1xcXFxuZGF0YS5wdXNoKHtcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJsaW5lX2JsYW5rXFxcXFxcXCJcXFxcbn0pO1xcXFxuZGF0YS5wdXNoKHtcXFxcbiAgICB0aXRsZTogXFxcXFxcXCLigJzigJzigJ3igJ08YmlnPui0puWPt+WIl+ihqDwvYmlnPlxcXFxcXFxcdFxcXFxcXFxcdFxcXFxcXFxcdDxzbWFsbD4o5L+d55WZNeadoeiusOW9lSk8L3NtYWxsPlxcXFxcXFwiLFxcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMVxcXFxcXFwiLFxcXFxuICAgIHVybDogXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCJcXFxcbn0pO1xcXFxudXNlckxpc3QucmV2ZXJzZSgpO1xcXFxuXFxcXG5mb3IgKGxldCBpdGVtIG9mIHVzZXJMaXN0KSB7XFxcXG4gICAgZGF0YS5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IFxcXFxcXFwi6LSm5Y+377yaXFxcXFxcXCIgKyBpdGVtWzBdICsgKHVzZXJOYW1lID09PSBpdGVtWzBdID8gXFxcXFxcXCJcXFxcXFxcXHRcXFxcXFxcXHRcXFxcXFxcXHTigJzigJxb5b2T5YmN6LSm5Y+3XeKAneKAnVxcXFxcXFwiIDogXFxcXFxcXCJcXFxcXFxcIiksXFxcXG4gICAgICAgIGRlc2M6IFxcXFxcXFwi6aqM6K+B56CB77yaXFxcXFxcXCIgKyBpdGVtWzFdLFxcXFxuICAgICAgICB1cmw6ICQoXFxcXFxcXCLmmK/lkKbliIfmjaLkuLror6VbXFxcXFxcXCIgKyBpdGVtWzBdICsgXFxcXFxcXCJd6LSm5Y+3XFxcXFxcXCIpLmNvbmZpcm0oKGYsIGl0ZW0pID0+IHtcXFxcbiAgICAgICAgICAgIGYudXNlciA9IGl0ZW07XFxcXG4gICAgICAgICAgICB3cml0ZUZpbGUoXFxcXFxcXCJoaWtlcjovL2ZpbGVzL1dhcmVob3VzZVVTRVIuanNvblxcXFxcXFwiLCBKU09OLnN0cmluZ2lmeShmKSk7XFxcXG4gICAgICAgICAgICBiYWNrKCk7XFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+WIh+aNouaIkOWKn1xcXFxcXFwiO1xcXFxuICAgICAgICB9LCB1c2VyLCBpdGVtKSxcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF8xXFxcXFxcXCJcXFxcbiAgICB9KTtcXFxcbn1cXFxcbmRhdGEucHVzaCh7XFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwibGluZV9ibGFua1xcXFxcXFwiXFxcXG59KTtcXFxcbmRhdGEucHVzaCh7XFxcXG4gICAgdGl0bGU6IFxcXFxcXFwi6YCA5Ye66LSm5Y+3XFxcXFxcXCIsXFxcXG4gICAgdXJsOiAkKFxcXFxcXFwi56Gu6K6k6YCA5Ye655m75b2V54q25oCBXFxcXFxcXCIpLmNvbmZpcm0oKGYpID0+IHtcXFxcbiAgICAgICAgZi51c2VyID0gW107XFxcXG4gICAgICAgIHdyaXRlRmlsZShcXFxcXFxcImhpa2VyOi8vZmlsZXMvV2FyZWhvdXNlVVNFUi5qc29uXFxcXFxcXCIsIEpTT04uc3RyaW5naWZ5KGYpKTtcXFxcbiAgICAgICAgYmFjaygpO1xcXFxuICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+mAgOWHuuaIkOWKn1xcXFxcXFwiO1xcXFxuICAgIH0sIHVzZXIpLFxcXFxuICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMSdcXFxcbn0pO1xcXFxuc2V0UmVzdWx0KGRhdGEpO1xcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIuWIl+ihqOaOkuW6j+eul+azlVxcXCIsXFxcInBhdGhcXFwiOlxcXCJzb3J0XFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxuLyog6KeE5YiZ5YiX6KGo5o6S5bqPIFsgVVDjgIFORVfjgIHml6Dmm7TmlrAgXSDpobrluo8gKi9cXFxcbi8qIOW9kuW5tuaOkuW6jyBTdGFydCAqL1xcXFxuLypcXFxcbmZ1bmN0aW9uIG1lcmdlU29ydChhcnIpIHtcXFxcbiAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcXFxcbiAgICBpZiAobGVuIDwgMikge1xcXFxuICAgICAgICByZXR1cm4gYXJyO1xcXFxuICAgIH1cXFxcbiAgICB2YXIgbWlkZGxlID0gTWF0aC5mbG9vcihsZW4gLyAyKSxcXFxcbiAgICAgICAgbGVmdCA9IGFyci5zbGljZSgwLCBtaWRkbGUpLFxcXFxuICAgICAgICByaWdodCA9IGFyci5zbGljZShtaWRkbGUpO1xcXFxuICAgIHJldHVybiBtZXJnZShtZXJnZVNvcnQobGVmdCksIG1lcmdlU29ydChyaWdodCkpO1xcXFxufVxcXFxuZnVuY3Rpb24gbWVyZ2UobGVmdCwgcmlnaHQpIHtcXFxcbiAgICB2YXIgcmVzdWx0ID0gW107XFxcXG4gICAgdmFyIGlzVGhpc1ZlcnNpb25MaXN0ID0gW107XFxcXG5cXFxcbiAgICB3aGlsZSAobGVmdC5sZW5ndGggPiAwICYmIHJpZ2h0Lmxlbmd0aCA+IDApIHtcXFxcbiAgICAgICAgaWYgKGxlZnRbMF0udGl0bGUuaW5jbHVkZXMoXFxcXFxcXCLwn4aZXFxcXFxcXCIpKSB7XFxcXG4gICAgICAgICAgICByZXN1bHQucHVzaChsZWZ0LnNoaWZ0KCkpO1xcXFxuICAgICAgICB9IGVsc2UgaWYgKHJpZ2h0WzBdLnRpdGxlLmluY2x1ZGVzKFxcXFxcXFwi8J+GmVxcXFxcXFwiKSkge1xcXFxuICAgICAgICAgICAgcmVzdWx0LnB1c2gocmlnaHQuc2hpZnQoKSk7XFxcXG4gICAgICAgIH0gZWxzZSBpZiAobGVmdFswXS50aXRsZS5pbmNsdWRlcyhcXFxcXFxcIvCfhpVcXFxcXFxcIikpIHtcXFxcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGxlZnQuc2hpZnQoKSk7XFxcXG4gICAgICAgIH0gZWxzZSBpZiAocmlnaHRbMF0udGl0bGUuaW5jbHVkZXMoXFxcXFxcXCLwn4aVXFxcXFxcXCIpKSB7XFxcXG4gICAgICAgICAgICByZXN1bHQucHVzaChyaWdodC5zaGlmdCgpKTtcXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIGlzVGhpc1ZlcnNpb25MaXN0LnB1c2gobGVmdC5zaGlmdCgpKTtcXFxcbiAgICAgICAgICAgIGlzVGhpc1ZlcnNpb25MaXN0LnB1c2gocmlnaHQuc2hpZnQoKSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9XFxcXG5cXFxcbiAgICB3aGlsZSAoaXNUaGlzVmVyc2lvbkxpc3QubGVuZ3RoKSByZXN1bHQucHVzaChpc1RoaXNWZXJzaW9uTGlzdC5zaGlmdCgpKTtcXFxcblxcXFxuICAgIHdoaWxlIChsZWZ0Lmxlbmd0aClcXFxcbiAgICAgICAgcmVzdWx0LnB1c2gobGVmdC5zaGlmdCgpKTtcXFxcblxcXFxuICAgIHdoaWxlIChyaWdodC5sZW5ndGgpXFxcXG4gICAgICAgIHJlc3VsdC5wdXNoKHJpZ2h0LnNoaWZ0KCkpO1xcXFxuXFxcXG4gICAgcmV0dXJuIHJlc3VsdDtcXFxcbn1cXFxcbiQuZXhwb3J0cy5tZXJnZVNvcnQgPSBtZXJnZVNvcnQ7XFxcXG4qL1xcXFxuLyog5b2S5bm25o6S5bqPIEVuZCAqL1xcXFxuLyog5pmu6YCa5YiG57G75o6S5bqPIFN0YXJ0ICovXFxcXG5mdW5jdGlvbiBub3JtYWxTb3J0KGFycikge1xcXFxuICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xcXFxuICAgIGlmIChsZW4gPCAyKSB7XFxcXG4gICAgICAgIHJldHVybiBhcnI7XFxcXG4gICAgfVxcXFxuICAgIGxldCB1cFJlc3VsdCA9IFtdO1xcXFxuICAgIGxldCBvdGhlclJlc3VsdCA9IFtdO1xcXFxuICAgIHdoaWxlKGFyci5sZW5ndGgpIHtcXFxcbiAgICAgICAgbGV0IGl0ZW0gPSBhcnIuc2hpZnQoKTtcXFxcbiAgICAgICAgaWYoaXRlbS50aXRsZS5pbmNsdWRlcyhcXFxcXFxcIvCfhplcXFxcXFxcIikpIHtcXFxcbiAgICAgICAgICAgIHVwUmVzdWx0LnB1c2goaXRlbSlcXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIG90aGVyUmVzdWx0LnB1c2goaXRlbSlcXFxcbiAgICAgICAgfVxcXFxuICAgIH1cXFxcbiAgICByZXR1cm4gdXBSZXN1bHQuY29uY2F0KG90aGVyUmVzdWx0KTtcXFxcbn1cXFxcbiQuZXhwb3J0cy5ub3JtYWxTb3J0ID0gbm9ybWFsU29ydDtcXFxcbi8qIOaZrumAmuWIhuexu+aOkuW6jyBFbmQgKi9cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwiaWNvbl8yX3JvdW5kXFxcIixcXFwibmFtZVxcXCI6XFxcIuWFqOmDqOWFrOW8gOinhOWImVxcXCIsXFxcInBhdGhcXFwiOlxcXCJBbGxQdWJsaWNSdWxlXFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxuICAgIGNvbnN0IHtcXFxcbiAgICAgICAgYXBpLFxcXFxuICAgICAgICBsb2NhbFJ1bGVWZXIsXFxcXG4gICAgICAgIGdldEFwaVxcXFxuICAgIH0gPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvdXRpbGl5XFxcXFxcXCIpO1xcXFxuY29uc3Qge1xcXFxuICAgIG1lcmdlU29ydFxcXFxufSA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9zb3J0XFxcXFxcXCIpO1xcXFxubGV0IGRhdGFUeXBlID0gZ2V0VmFyKFxcXFxcXFwiV2FyZWhvdXNlLnR5cGVcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIik7XFxcXG5sZXQgb3JkZXIgPSBnZXRWYXIoXFxcXFxcXCJXYXJlaG91c2Uub3JkZXJcXFxcXFxcIiwgXFxcXFxcXCIwXFxcXFxcXCIpO1xcXFxubGV0IHNvcnQgPSBnZXRWYXIoXFxcXFxcXCJXYXJlaG91c2Uuc29ydFxcXFxcXFwiLCBcXFxcXFxcIjBcXFxcXFxcIik7XFxcXG5sZXQgZ29vZCA9IGdldFZhcihcXFxcXFxcIldhcmVob3VzZS5nb29kXFxcXFxcXCIsIFxcXFxcXFwiXFxcXFxcXCIpO1xcXFxubGV0IHBhZ2UgPSBNWV9VUkwuc3BsaXQoXFxcXFxcXCIjXFxcXFxcXCIpWzFdIHx8IDE7XFxcXG5sZXQgcnVsZUxpc3QgPSBKU09OLnBhcnNlKHJlcXVlc3QoYXBpLmFsbF9ydWxlICsgXFxcXFxcXCI/ZGF0YV90eXBlPVxcXFxcXFwiICsgZGF0YVR5cGUgKyBcXFxcXFxcIiZwYWdlPVxcXFxcXFwiICsgcGFnZSArIFxcXFxcXFwiJmxpbWl0PTIwJm9yZGVyPVxcXFxcXFwiICsgb3JkZXIgKyBcXFxcXFxcIiZzb3J0PVxcXFxcXFwiICsgc29ydCsgXFxcXFxcXCImaXNfZ29vZD1cXFxcXFxcIiArIGdvb2QpKS5yZXN1bHQ7XFxcXG5hZGRMaXN0ZW5lcignb25DbG9zZScsICQudG9TdHJpbmcoKCkgPT4ge1xcXFxuICAgIGNsZWFyVmFyKFxcXFxcXFwiV2FyZWhvdXNlLnR5cGVcXFxcXFxcIik7XFxcXG4gICAgY2xlYXJWYXIoXFxcXFxcXCJXYXJlaG91c2Uub3JkZXJcXFxcXFxcIik7XFxcXG4gICAgY2xlYXJWYXIoXFxcXFxcXCJXYXJlaG91c2Uuc29ydFxcXFxcXFwiKTtcXFxcbiAgICBjbGVhclZhcihcXFxcXFxcIldhcmVob3VzZS5nb29kXFxcXFxcXCIpO1xcXFxuICAgIGNsZWFyVmFyKFxcXFxcXFwiV2FyZWhvdXNlLmJhY2tcXFxcXFxcIik7XFxcXG59KSk7XFxcXG5sZXQgZGF0YSA9IFtdO1xcXFxuaWYgKGdldFZhcihcXFxcXFxcIldhcmVob3VzZS5iYWNrXFxcXFxcXCIpID09PSBcXFxcXFxcIjFcXFxcXFxcIikge1xcXFxuICAgIGJhY2soKTtcXFxcbn1cXFxcbmZ1bmN0aW9uIHRhYihhcnIsIHR5cGUsIGNvbnRyYXN0KSB7XFxcXG4gICAgZm9yIChsZXQgaXRlbSBvZiBhcnIpIHtcXFxcbiAgICAgICAgZGF0YS5wdXNoKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiBpdGVtWzFdID09PSBjb250cmFzdCA/IFxcXFxcXFwi4oCc4oCcXFxcXFxcXCIgKyBpdGVtWzBdICsgXFxcXFxcXCLigJ3igJ1cXFxcXFxcIiA6IGl0ZW1bMF0sXFxcXG4gICAgICAgICAgICB1cmw6ICQoXFxcXFxcXCIjbm9Mb2FkaW5nI1xcXFxcXFwiKS5sYXp5UnVsZSgoa2V5LCB0eXBlKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgcHV0VmFyKHR5cGUsIGtleSk7XFxcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgIH0sIGl0ZW1bMV0sIHR5cGUpLFxcXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwic2Nyb2xsX2J1dHRvblxcXFxcXFwiXFxcXG4gICAgICAgIH0pO1xcXFxuICAgIH1cXFxcbiAgICBkYXRhLnB1c2goe1xcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJibGFua19ibG9ja1xcXFxcXFwiXFxcXG4gICAgfSk7XFxcXG59XFxcXG5pZiAocGFnZSA9PT0gXFxcXFxcXCIxXFxcXFxcXCIpIHtcXFxcbiAgICB0YWIoW1xcXFxuICAgICAgICBbXFxcXFxcXCLlhajpg6hcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIl0sXFxcXG4gICAgICAgIFtcXFxcXFxcIuWwj+eoi+W6j1xcXFxcXFwiLCBcXFxcXFxcImhvbWVfcnVsZV91cmxcXFxcXFxcIl0sXFxcXG4gICAgICAgIFtcXFxcXFxcIuaPkOS6pOS6keS7k+W6k+inhOWImVxcXFxcXFwiLCBcXFxcXFxcInB1Ymxpc2hcXFxcXFxcIl0sXFxcXG4gICAgICAgIFtcXFxcXFxcIue9kemhteaPkuS7tlxcXFxcXFwiLCBcXFxcXFxcImpzX3VybFxcXFxcXFwiXSxcXFxcbiAgICAgICAgW1xcXFxcXFwi6Z2Z5oCB6aG16Z2iXFxcXFxcXCIsIFxcXFxcXFwiaHRtbFxcXFxcXFwiXSxcXFxcbiAgICAgICAgW1xcXFxcXFwi5Li76aKYXFxcXFxcXCIsIFxcXFxcXFwiY29uZmlnXFxcXFxcXCJdXFxcXG4gICAgXSwgXFxcXFxcXCJXYXJlaG91c2UudHlwZVxcXFxcXFwiLCBkYXRhVHlwZSk7XFxcXG4gICAgdGFiKFtcXFxcbiAgICAgICAgW1xcXFxcXFwi5pe26Ze0XFxcXFxcXCIsIFxcXFxcXFwiMFxcXFxcXFwiXSxcXFxcbiAgICAgICAgW1xcXFxcXFwiSURcXFxcXFxcIiwgXFxcXFxcXCIxXFxcXFxcXCJdLFxcXFxuICAgICAgICBbXFxcXFxcXCLlpb3or4TluqZcXFxcXFxcIiwgXFxcXFxcXCIyXFxcXFxcXCJdLFxcXFxuICAgICAgICBbXFxcXFxcXCLlt67or4TluqZcXFxcXFxcIiwgXFxcXFxcXCIzXFxcXFxcXCJdLFxcXFxuICAgICAgICBbXFxcXFxcXCLlm57lpI3mlbBcXFxcXFxcIiwgXFxcXFxcXCI0XFxcXFxcXCJdXFxcXG4gICAgXSwgXFxcXFxcXCJXYXJlaG91c2Uub3JkZXJcXFxcXFxcIiwgb3JkZXIpO1xcXFxuICAgIHRhYihbXFxcXG4gICAgICAgIFtcXFxcXFxcIuWAkuW6j1xcXFxcXFwiLCBcXFxcXFxcIjBcXFxcXFxcIl0sXFxcXG4gICAgICAgIFtcXFxcXFxcIuato+W6j1xcXFxcXFwiLCBcXFxcXFxcIjFcXFxcXFxcIl1cXFxcbiAgICBdLCBcXFxcXFxcIldhcmVob3VzZS5zb3J0XFxcXFxcXCIsIHNvcnQpO1xcXFxuICAgIHRhYihbXFxcXG4gICAgICAgIFtcXFxcXFxcIuS4jeiuulxcXFxcXFwiLCBcXFxcXFxcIlxcXFxcXFwiXSxcXFxcbiAgICAgICAgW1xcXFxcXFwi5LyY6LSoXFxcXFxcXCIsIFxcXFxcXFwiMVxcXFxcXFwiXVxcXFxuICAgIF0sIFxcXFxcXFwiV2FyZWhvdXNlLmdvb2RcXFxcXFxcIiwgZ29vZCk7XFxcXG4gICAgZGF0YS5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IFxcXFxcXFwi5pCc57SiXFxcXFxcXCIsXFxcXG4gICAgICAgIHVybDogJC50b1N0cmluZyhuYW1lID0+IFxcXFxcXFwiaGlrZXI6Ly9zZWFyY2g/cz1cXFxcXFxcIiArIGlucHV0ICsgXFxcXFxcXCImcnVsZT1cXFxcXFxcIiArIG5hbWUsIE1ZX1JVTEUudGl0bGUpLFxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJpbnB1dFxcXFxcXFwiLFxcXFxuICAgICAgICBkZXNjOiBcXFxcXFxcIuaQnOe0ouWFqOmDqOinhOWImVxcXFxcXFwiXFxcXG4gICAgfSk7XFxcXG59XFxcXG5cXFxcbmxldCBob21lTGlzdCA9IEpTT04ucGFyc2UocmVxdWVzdChhcGkuaG9tZSkpO1xcXFxubGV0IG1SdWxlTGlzdCA9IFtdO1xcXFxuZm9yICh2YXIgaXRlbSBvZiBydWxlTGlzdCkge1xcXFxuICAgIHZhciBuYW1lID0gaXRlbS5uYW1lO1xcXFxuICAgIGlmIChpdGVtLmlzX3RhcCkge1xcXFxuICAgICAgICBsZXQgbG9jYXRpb24gPSBKU09OLnBhcnNlKHJlcXVlc3QoZ2V0QXBpKFxcXFxcXFwicnVsZUxpc3RKc29uXFxcXFxcXCIpICsgXFxcXFxcXCI/aWQ9XFxcXFxcXCIgKyBpdGVtLmlkKSk7XFxcXG4gICAgICAgIGl0ZW0uaWQgPSBsb2NhdGlvbi5pZDtcXFxcbiAgICAgICAgaXRlbS5uYW1lID0gbG9jYXRpb24ubmFtZTtcXFxcbiAgICAgICAgaXRlbS5hdXRob3IgPSBsb2NhdGlvbi5hdXRob3I7XFxcXG4gICAgICAgIGl0ZW0uZGF0YV90eXBlID0gbG9jYXRpb24uZGF0YV90eXBlO1xcXFxuICAgICAgICBpdGVtLnZlciA9IGxvY2F0aW9uLnZlclxcXFxuICAgIH1cXFxcbiAgICBpdGVtLnZlcnNpb24gPSBpdGVtLnZlcjtcXFxcbiAgICBsZXQgbGFiZWwgPSBcXFxcXFxcIlxcXFxcXFwiLFxcXFxuICAgICAgICBsdmVyID0gLTI7XFxcXG4gICAgaWYgKGl0ZW0uaXNfanNvbiAmJiBpdGVtLmRhdGFfdHlwZSA9PT0gXFxcXFxcXCJob21lX3J1bGVfdXJsXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgbHZlciA9IGxvY2FsUnVsZVZlcihob21lTGlzdCwgaXRlbSk7XFxcXG4gICAgICAgIGlmIChsdmVyID09PSAtMSkge1xcXFxuICAgICAgICAgICAgbGFiZWwgPSBcXFxcXFxcIvCfhpVcXFxcXFxcIjtcXFxcbiAgICAgICAgfSBlbHNlIGlmIChsdmVyIDwgaXRlbS52ZXIpIHtcXFxcbiAgICAgICAgICAgIGxhYmVsID0gXFxcXFxcXCLwn4aZXFxcXFxcXCI7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9XFxcXG4gICAgbVJ1bGVMaXN0LnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogbGFiZWwgKyBuYW1lLFxcXFxuICAgICAgICB1cmw6IFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3J1bGVEZXRhaWwjbm9IaXN0b3J5IyNub1JlY29yZEhpc3RvcnkjXFxcXFxcXCIsXFxcXG4gICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICBsdmVyOiBsdmVyLFxcXFxuICAgICAgICAgICAgaWQ6IGl0ZW0uaWQsXFxcXG4gICAgICAgICAgICBpc0FsbDp0cnVlXFxcXG4gICAgICAgIH0sXFxcXG4gICAgICAgIHBpY191cmw6IGl0ZW0ucGljLFxcXFxuICAgIH0pXFxcXG59XFxcXG4vKiDlvZLlubbmjpLluo8gU3RhcnQgKi9cXFxcbi8vbVJ1bGVMaXN0ID0gbWVyZ2VTb3J0KG1SdWxlTGlzdCk7XFxcXG4vKiDlvZLlubbmjpLluo8gRW5kICovXFxcXG5kYXRhLnB1c2guYXBwbHkoZGF0YSwgbVJ1bGVMaXN0KVxcXFxuc2V0UmVzdWx0KGRhdGEpO1xcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIuWbnuWkjVxcXCIsXFxcInBhdGhcXFwiOlxcXCJSZXBseVxcXCIsXFxcInJ1bGVcXFwiOlxcXCJqczpcXFxcbmxldCBkYXRhID0gW107XFxcXG5jb25zdCB7XFxcXG4gICAgYXBpXFxcXG59ID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3V0aWxpeVxcXFxcXFwiKTtcXFxcbmxldCB7XFxcXG4gICAgcmVwbHlJZCxcXFxcbiAgICBydWxlSWQsXFxcXG4gICAgbmFtZSxcXFxcbiAgICBwYXNzd29yZCxcXFxcbiAgICB1c2VybmFtZVxcXFxufSA9IE1ZX1BBUkFNUztcXFxcblxcXFxuXFxcXG5zZXRQYWdlVGl0bGUoXFxcXFxcXCLlm57lpI0oXFxcXFxcXCIgKyBuYW1lICsgXFxcXFxcXCIpXFxcXFxcXCIpO1xcXFxuYWRkTGlzdGVuZXIoJ29uQ2xvc2UnLCAkLnRvU3RyaW5nKCgpID0+IHtcXFxcbiAgICBjbGVhclZhcihcXFxcXFxcIldhcmVob3VzZS5jb21tZW50LnRleHRcXFxcXFxcIik7XFxcXG4gICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcXFxufSkpO1xcXFxuXFxcXG5kYXRhLnB1c2goe1xcXFxuICAgIGRlc2M6IFxcXFxcXFwi5Zue5aSNLi4uLi4uXFxcXFxcXCIsXFxcXG4gICAgY29sX3R5cGU6ICdpbnB1dCcsXFxcXG4gICAgZXh0cmE6IHtcXFxcbiAgICAgICAgdGl0bGVWaXNpYmxlOiBmYWxzZSxcXFxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBnZXRWYXIoJ1dhcmVob3VzZS5jb21tZW50LnRleHQnLCAnJyksXFxcXG4gICAgICAgIHR5cGU6IFxcXFxcXFwidGV4dGFyZWFcXFxcXFxcIixcXFxcbiAgICAgICAgaGVpZ2h0OjcsXFxcXG4gICAgICAgIG9uQ2hhbmdlOiAncHV0VmFyKFxcXFxcXFwiV2FyZWhvdXNlLmNvbW1lbnQudGV4dFxcXFxcXFwiLGlucHV0KSdcXFxcbiAgICB9XFxcXG59KTtcXFxcblxcXFxuXFxcXG5kYXRhLnB1c2goe1xcXFxuICAgIHRpdGxlOiBcXFxcXFxcIuaPkOS6pFxcXFxcXFwiLFxcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfY2VudGVyXzFcXFxcXFxcIixcXFxcbiAgICB1cmw6ICQoYXBpLmRpc19yZXBseSArIHJ1bGVJZCkubGF6eVJ1bGUoKHBhc3N3b3JkLCB1c2VybmFtZSwgcnVsZUlkKSA9PiB7XFxcXG4gICAgICAgIGxldCB0ZXh0ID0gZ2V0VmFyKCdXYXJlaG91c2UuY29tbWVudC50ZXh0JywgJycpO1xcXFxuICAgICAgICBpZiAocGFzc3dvcmQgPT0gXFxcXFxcXCJcXFxcXFxcIiB8fCB1c2VybmFtZSA9PSBcXFxcXFxcIlxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+acqueZu+W9lei0puWPt1xcXFxcXFwiO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGlmICh0ZXh0ID09IFxcXFxcXFwiXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5L2g6L+Y5LuA5LmI6YO95rKh5YaZ5ZWKXFxcXFxcXCI7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgbGV0IHJlc3VsdCA9IHJlcXVlc3QoaW5wdXQsIHtcXFxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXFxcXG4gICAgICAgICAgICB9LFxcXFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xcXFxuICAgICAgICAgICAgICAgIFxcXFxcXFwicGFyYW1zXFxcXFxcXCI6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJkaXNjdXNzX3RleHRcXFxcXFxcIjogdGV4dCxcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJxcVxcXFxcXFwiOiB1c2VybmFtZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJwYXNzd29yZFxcXFxcXFwiOiBwYXNzd29yZCxcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJkaXNjdXNzX2lkXFxcXFxcXCI6IHJ1bGVJZFxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH0pLFxcXFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCdcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgICAgIHJlc3VsdCA9IEpTT04ucGFyc2UocmVzdWx0KS5yZXN1bHQ7XFxcXG4gICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSAwKSB7XFxcXG4gICAgICAgICAgICBiYWNrKGZhbHNlKTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL1xcXFxcXFwiICsgcmVzdWx0LmRldGFpbDtcXFxcblxcXFxuICAgIH0sIHBhc3N3b3JkLCB1c2VybmFtZSwgcmVwbHlJZClcXFxcbn0pO1xcXFxuXFxcXG5zZXRSZXN1bHQoZGF0YSk7XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5oiR55qE5Zue5aSNXFxcIixcXFwicGF0aFxcXCI6XFxcIk15UmVwbHlcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5jb25zdCB7XFxcXG4gICAgYXBpXFxcXG59ID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3V0aWxpeVxcXFxcXFwiKTtcXFxcbmxldCB7XFxcXG4gICAgYXV0aF9jb2RlLFxcXFxuICAgIHFxXFxcXG59ID0gTVlfUEFSQU1TO1xcXFxubGV0IHBhZ2UgPSBwYXJzZUludChNWV9VUkwuc3BsaXQoXFxcXFxcXCIjXFxcXFxcXCIpWzFdKTtcXFxcbmxldCBkYXRhPVtdO1xcXFxubGV0IGNvbW1lbnRMaXN0ID0gSlNPTi5wYXJzZShyZXF1ZXN0KGFwaS5kaXNfZ2V0X3JlcGx5ICsgXFxcXFxcXCI/bGltaXQ9NSZwYWdlPVxcXFxcXFwiICsgcGFnZSArIFxcXFxcXFwiJnFxPVxcXFxcXFwiICsgcXEgKyBcXFxcXFxcIiZhdXRoX2NvZGU9XFxcXFxcXCIgKyBhdXRoX2NvZGUpKS5yZXN1bHQ7XFxcXG5pZiAoY29tbWVudExpc3QubGVuZ3RoID09PSAwKSB7XFxcXG4gICAgZGF0YS5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IFxcXFxcXFwiPGg1IHN0eWxlPSd0ZXh0LWFsaWduOmNlbnRlcic+5Yir5ouJ5LqG5LiA5p2h5Lmf5LiN5Ymp5LqGPC9oNT5cXFxcXFxcIixcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwicmljaF90ZXh0XFxcXFxcXCJcXFxcbiAgICB9KTtcXFxcbn0gZWxzZSB7XFxcXG4gICAgZm9yIChsZXQgaXRlbSBvZiBjb21tZW50TGlzdCkge1xcXFxuICAgICAgICBkYXRhLnB1c2goe1xcXFxuICAgICAgICAgICAgdGl0bGU6IGl0ZW0ubmFtZSArIFxcXFxcXFwiJm5ic3A7Jm5ic3A7PGZvbnQgY29sb3I9J2dyYXknPjxzbWFsbD4jXFxcXFxcXCIgKyBpdGVtLmlkICsgXFxcXFxcXCI8L3NtYWxsPjxmb250PlxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiYXZhdGFyXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICB1cmw6IFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3J1bGVEZXRhaWwjbm9IaXN0b3J5IyNub1JlY29yZEhpc3RvcnkjXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgIGx2ZXI6IFxcXFxcXFwi5Zue5aSN6L+b5YWl5LiN5pSv5oyB5p+l55yLXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgaWQ6IGl0ZW0ucnVsZV9pZFswXVxcXFxuICAgICAgICAgICAgfSxcXFxcbiAgICAgICAgICAgIHBpY191cmw6IGl0ZW0uYXZhdGFyX3VybFxcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgZGF0YS5wdXNoKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiBpdGVtLmRpc2N1c3NfdGV4dCxcXFxcbiAgICAgICAgICAgIGRlc2M6IGl0ZW0uY3JlYXRlX2RhdGUgKyBcXFxcXFxcIsK3XFxcXFxcXCIraXRlbS5ydWxlX2lkWzFdK1xcXFxcXFwiwrdcXFxcXFxcIitcXFxcXFxcIuW8gOWPkeiAhfCfl6NcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vcGFnZS9pbmZvXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBleHRyYTp7XFxcXG4gICAgICAgICAgICAgICAgbmFtZTppdGVtLm5hbWUsXFxcXG4gICAgICAgICAgICAgICAgdHlwZTpcXFxcXFxcImxvbmdfdGV4dFxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIHRleHQ6aXRlbS5kaXNjdXNzX3RleHRcXFxcbiAgICAgICAgICAgIH0sXFxcXG4gICAgICAgICAgICBwaWNfdXJsOiBpdGVtLmF2YXRhcl91cmxcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgfVxcXFxuICAgIFxcXFxufVxcXFxuc2V0UmVzdWx0KGRhdGEpO1xcXFxuXFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5pu05aSa5YiG5LqrXFxcIixcXFwicGF0aFxcXCI6XFxcIm1vcmVTaGFyZVxcXCIsXFxcInJ1bGVcXFwiOlxcXCJqczpcXFxcbiAgICBhZGRMaXN0ZW5lcignb25DbG9zZScsICQudG9TdHJpbmcoKCk9PntcXFxcbiAgICAgICAgY2xlYXJWYXIoXFxcXFxcXCJob3VzZS51cGxvYWRfY29kZVxcXFxcXFwiKTtcXFxcbiAgICB9KSk7XFxcXG5jb25zdCB7Y29sb3Isc21hbGwsYXBpLCBnZXRGaWxlfSA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS91dGlsaXlcXFxcXFxcIik7XFxcXG5sZXQgaG91c2VGaWxlID0gZ2V0RmlsZXx8ZmFsc2U7XFxcXG5sZXQgcHV0X3VybCA9IGFwaS5ob3N0KycvaGlrZXJ1bGUvZGV2L3B1dCc7XFxcXG5pZighaG91c2VGaWxlKXtcXFxcbiAgICBzZXRJdGVtKCdpc19ob3VzZV92aXAnLCAnZmFsc2UnKTtcXFxcbn1cXFxcbmxldCBob3VzZV9kYXRhID0gaG91c2VGaWxlKCk7XFxcXG4vLyBsb2coaG91c2VfZGF0YS51c2VybmFtZSsnLScraG91c2VfZGF0YS5wYXNzd29yZCk7XFxcXG52YXIgY2FudXAgPSBob3VzZV9kYXRhLnVzZXJuYW1lLmxlbmd0aCA+PSA2ICYmIGhvdXNlX2RhdGEucGFzc3dvcmQubGVuZ3RoID4gMjtcXFxcbmxvZygn5Y+v5Lul5LiK5LygPycrY2FudXApO1xcXFxubGV0IGQgPSBbXTtcXFxcbmxldCBmaWxlX3R5cGUgPSBbe25hbWU6J+mdmeaAgeaWh+S7ticsdmFsdWU6J2h0bWwnfSx7bmFtZTon572R6aG15o+S5Lu2Jyx2YWx1ZTonanNfdXJsJ30se25hbWU6J+S4u+mhtemFjee9ricsdmFsdWU6J2NvbmZpZyd9XTsgLy/kuIrkvKDnsbvlnotcXFxcbmxldCBmaWxlX3JlZGlyZWN0ID0gW3tuYW1lOifmnKzlnLAnLHZhbHVlOidmYWxzZSd9LHtuYW1lOifnm7Tpk74zMDInLHZhbHVlOid0cnVlJ31dOyAvL+aYr+WQpumHjeWumuWQkVxcXFxubGV0IGZpbGVfdWEgPSBbe25hbWU6J+eUteiEkScsdmFsdWU6J3BjJ30se25hbWU6J+aJi+acuicsdmFsdWU6J21vYmlsZSd9XTtcXFxcbmxldCBmaWxlX3R5cGVfdGl0bGUgPSBmaWxlX3R5cGUubWFwKChpdGVtKSA9PiB7XFxcXG4gICAgbGV0IG5hbWUgPSBnZXRJdGVtKCdob3VzZS5maWxlX3R5cGUnLCfpnZnmgIHmlofku7YnKTtcXFxcbiAgICBpZihpdGVtLm5hbWU9PT1uYW1lKXtcXFxcbiAgICAgICAgcmV0dXJuICfwn5GJJytpdGVtLm5hbWU7XFxcXG4gICAgfWVsc2V7XFxcXG4gICAgICAgIHJldHVybiBpdGVtLm5hbWU7XFxcXG4gICAgfVxcXFxufSk7XFxcXG5sZXQgZmlsZV9yZWRpcmVjdF90aXRsZSA9IGZpbGVfcmVkaXJlY3QubWFwKChpdGVtKSA9PiB7XFxcXG4gICAgbGV0IG5hbWUgPSBnZXRJdGVtKCdob3VzZS5maWxlX3JlZGlyZWN0Jywn5pys5ZywJyk7XFxcXG4gICAgaWYoaXRlbS5uYW1lPT09bmFtZSl7XFxcXG4gICAgICAgIHJldHVybiAn8J+RiScraXRlbS5uYW1lO1xcXFxuICAgIH1lbHNle1xcXFxuICAgICAgICByZXR1cm4gaXRlbS5uYW1lO1xcXFxuICAgIH1cXFxcbn0pO1xcXFxubGV0IGZpbGVfdWFfdGl0bGUgPSBmaWxlX3VhLm1hcCgoaXRlbSkgPT4ge1xcXFxuICAgIGxldCBuYW1lID0gZ2V0SXRlbSgnaG91c2UuZmlsZV91YScsJ+eUteiEkScpO1xcXFxuICAgIGlmKGl0ZW0ubmFtZT09PW5hbWUpe1xcXFxuICAgICAgICByZXR1cm4gJ/CfkYknK2l0ZW0ubmFtZTtcXFxcbiAgICB9ZWxzZXtcXFxcbiAgICAgICAgcmV0dXJuIGl0ZW0ubmFtZTtcXFxcbiAgICB9XFxcXG59KTtcXFxcbmQucHVzaCh7Y29sX3R5cGU6ICd4NV93ZWJ2aWV3X3NpbmdsZScsIGV4dHJhOiB7anM6ICdjb25zb2xlLmxvZyhcXFxcXFxcIuaIkeWKoOi9veS6hlxcXFxcXFwiKSd9fSk7XFxcXG5kLnB1c2goe1xcXFxuICAgIHRpdGxlOiAn6I635Y+WJyxcXFxcbiAgICBkZXNjOiBcXFxcXFxcIuaWh+S7tui3r+W+hCzmlK/mjIFoaWtlcixmaWxlLGh0dHAs5Li76aKYXFxcXFxcXCIsXFxcXG4gICAgZXh0cmE6IHtcXFxcbiAgICAgICAgb25DaGFuZ2U6IFxcXFxcXFwicHV0VmFyKCdob3VzZS53ZWJfdXJsJyxpbnB1dClcXFxcXFxcIixcXFxcbiAgICAgICAgdGl0bGVWaXNpYmxlOiB0cnVlLFxcXFxuICAgICAgICBpZDonZmlsZVBhdGgnLFxcXFxuICAgICAgICBkZWZhdWx0VmFsdWU6Z2V0VmFyKCdob3VzZS53ZWJfdXJsJylcXFxcbiAgICB9LFxcXFxuICAgIHVybDokLnRvU3RyaW5nKCgpID0+IHtcXFxcbiAgICAgICAgbGV0IGlucHV0ID0gZ2V0VmFyKCdob3VzZS53ZWJfdXJsJywnJyk7XFxcXG4gICAgICAgIGlmKGlucHV0Lmxlbmd0aDwyKXtcXFxcbiAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/pk77mjqXkuI3lj6/ku6XkuLrnqbonXFxcXG4gICAgICAgIH0gZWxzZSBpZigvXmhpa2VyOnxeZmlsZTp8Xmh0dHA6fF5odHRwczp8XlxcXFxcXFxcL3N0b3JhZ2VcXFxcXFxcXC98XlxcXFxcXFxcL3NkY2FyZFxcXFxcXFxcLy8udGVzdChpbnB1dCkpe1xcXFxuICAgICAgICAgICAgaWYoL15cXFxcXFxcXC9zdG9yYWdlXFxcXFxcXFwvfF5cXFxcXFxcXC9zZGNhcmRcXFxcXFxcXC8vLnRlc3QoaW5wdXQpKXtcXFxcbiAgICAgICAgICAgICAgICBpbnB1dCA9ICdmaWxlOi8vJytpbnB1dDtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIGxvZygn5q2j5bi46ZO+5o6lOicraW5wdXQpO1xcXFxuICAgICAgICAgICAgbGV0IHVhID0gZ2V0SXRlbSgnaG91c2UuZmlsZV91YScpPT09J+eUteiEkSc/J01vemlsbGEvNS4wIChXaW5kb3dzIE5UIDEwLjA7IFdpbjY0OyB4NjQpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS84OC4wLjQzMjQuMTQ2IFNhZmFyaS81MzcuMzYnOidNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgOTsgTUkgNikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzg5LjAuNDM4OS45MCBNb2JpbGUgU2FmYXJpLzUzNy4zNic7XFxcXG4gICAgICAgICAgICBsZXQgd2ViX3VybF9hcnIgPSBpbnB1dC5zcGxpdCgnOycpO1xcXFxuICAgICAgICAgICAgbGV0IHdlYl91cmwgPSB3ZWJfdXJsX2FyclswXTtcXFxcbiAgICAgICAgICAgIGxldCBoZWFkZXJzID0ge1xcXFxuICAgICAgICAgICAgICAgICdSZWZlcmVyJzonaHR0cHM6Ly9ibG9nLmNzZG4ubmV0JyxcXFxcbiAgICAgICAgICAgICAgICAnVXNlci1BZ2VudCc6dWEsXFxcXG4gICAgICAgICAgICAgICAgJ0FjY2VwdCc6J2FwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdCwgKi8qOyBxPTAuMDEnLFxcXFxuICAgICAgICAgICAgICAgICdBY2NlcHQtTGFuZ3VhZ2UnOid6aC1DTicsXFxcXG4gICAgICAgICAgICB9O1xcXFxuICAgICAgICAgICAgaWYod2ViX3VybF9hcnIubGVuZ3RoPj0zJiZ3ZWJfdXJsX2FyclsyXS5sZW5ndGg+Mil7IC8v6K6+572u57yW56CBXFxcXG4gICAgICAgICAgICAgICAgaGVhZGVyc1snY29udGVudC10eXBlJ10gPSAnY2hhcnNldD0nK3dlYl91cmxfYXJyWzJdLnRvVXBwZXJDYXNlKCk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICBsZXQgcGFyYW1zID0ge2hlYWRlcnM6aGVhZGVycyx3aXRoSGVhZGVyczpmYWxzZSxyZWRpcmVjdDpmYWxzZX07XFxcXG4gICAgICAgICAgICBpZih3ZWJfdXJsX2Fyci5sZW5ndGg+PTImJndlYl91cmxfYXJyWzFdLmxlbmd0aD4yKXsgLy8g6K6+572u6K+35rGC5pa55rOVXFxcXG4gICAgICAgICAgICAgICAgcGFyYW1zWydtZXRob2QnXSA9IHdlYl91cmxfYXJyWzFdLnRvVXBwZXJDYXNlKCk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICBsb2coJ+W8gOWni+iOt+WPlua6kOeggScpO1xcXFxuICAgICAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICAgICAgICAvKlxcXFxuICAgICAgICAgICAgICAgIHJlcXVlc3RBc3luYyh3ZWJfdXJsLHBhcmFtcyxmdW5jdGlvbiAoa2V5LGNvZGUpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJhY2tfY29kZSA9IGNvZGU7XFxcXG4gICAgICAgICAgICAgICAgICAgIGlmKGJhY2tfY29kZS5sZW5ndGg+MjApe1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcHV0VmFyKCdob3VzZS51cGxvYWRfY29kZScsYmFja19jb2RlKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKHRydWUpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+a6kOeggeW3suiOt+WPlizlubbpg6jliIbmj5LlhaXliLDmlofmnKzljLrln58nXFxcXG4gICAgICAgICAgICAgICAgICAgIH1lbHNle1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+mUmeivr++8jOacrOasoeiOt+WPluWIsOepuuaWh+acrO+8jOeWkeS8vOS9oOayoeacieatpOaWh+S7tiEnO1xcXFxuICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICAgICAgKi9cXFxcbiAgICAgICAgICAgICAgICBsZXQgYmFja19jb2RlID0gZ2V0SXRlbSgnaG91c2UuZmlsZV91YScpPT09J+eUteiEkSc/ZmV0Y2god2ViX3VybCxwYXJhbXMpOnJlcXVlc3Qod2ViX3VybCxwYXJhbXMpO1xcXFxuICAgICAgICAgICAgICAgIGlmKGJhY2tfY29kZS5sZW5ndGg+MjApe1xcXFxuICAgICAgICAgICAgICAgICAgICBwdXRWYXIoJ2hvdXNlLnVwbG9hZF9jb2RlJyxiYWNrX2NvZGUpO1xcXFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSh0cnVlKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+a6kOeggeW3suiOt+WPlizlubbpg6jliIbmj5LlhaXliLDmlofmnKzljLrln58nXFxcXG4gICAgICAgICAgICAgICAgfWVsc2V7XFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/plJnor6/vvIzmnKzmrKHojrflj5bliLDnqbrmlofmnKzvvIznlpHkvLzkvaDmsqHmnInmraTmlofku7YhJztcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9Y2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICAgICAgICBsb2coZS5tZXNzYWdlKTtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5Y+R55Sf5LqG6ZSZ6K+vOlxcXFxcXFxcbicrZS5tZXNzYWdlO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9ZWxzZSBpZigv5Li76aKY77+lfOWFg+e0oO+/pS8udGVzdChpbnB1dCkpe1xcXFxuICAgICAgICAgICAgbG9nKCfkuLvpopjpk77mjqUnKTtcXFxcbiAgICAgICAgICAgIGxldCB3ZWJfdXJsX2FyciA9IGlucHV0LnNwbGl0KCfvv6UnKTtcXFxcbiAgICAgICAgICAgIGxldCB3ZWJfdXJsID0gd2ViX3VybF9hcnJbd2ViX3VybF9hcnIubGVuZ3RoLTFdO1xcXFxuICAgICAgICAgICAgbGV0IGJhY2tfY29kZSA9IHBhcnNlUGFzdGUod2ViX3VybCk7XFxcXG4gICAgICAgICAgICBpZihiYWNrX2NvZGUubGVuZ3RoPjIwKSB7XFxcXG4gICAgICAgICAgICAgICAgcHV0VmFyKCdob3VzZS51cGxvYWRfY29kZScsYmFja19jb2RlKTtcXFxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSh0cnVlKTtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5rqQ56CB5bey6I635Y+WLOW5tumDqOWIhuaPkuWFpeWIsOaWh+acrOWMuuWfnydcXFxcbiAgICAgICAgICAgIH1lbHNle1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/plJnor6/vvIzmnKzmrKHojrflj5bov5Tlm57kuLo6XFxcXFxcXFxuJytiYWNrX2NvZGU7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH1lbHNle1xcXFxuICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+mdnuazlemTvuaOpTpcXFxcXFxcXG4nK2dldFZhcignaG91c2Uud2ViX3VybCcpO1xcXFxuICAgICAgICB9XFxcXG4gICAgfSksXFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwiaW5wdXRcXFxcXFxcIlxcXFxufSk7XFxcXG5kLnB1c2goe1xcXFxuICAgIHRpdGxlOiBcXFxcXFxcIumAieaLqeaWh+S7tui3r+W+hFxcXFxcXFwiLFxcXFxuICAgIHVybDokKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKCgpPT57XFxcXG4gICAgICAgIC8qXFxcXG4gICAgICAgIGxldCBmcCA9ICdodHRwczovL2dpdGNvZGUubmV0L3FxXzMyMzk0MzUxL2RyLy0vcmF3L21hc3Rlci9qcy9maWxlU2VsZWN0LmpzJztcXFxcbiAgICAgICAgbGV0IGYgPSByZXF1aXJlKGZwKTtcXFxcbiAgICAgICAgKi9cXFxcbiAgICAgICAgbGV0IGZwPWNvbmZpZy5saWIuZmlsZVNlbGVjdDtcXFxcbiAgICAgICAgbGV0IGY9JC5yYyhmcCk7XFxcXG4gICAgICAgIHJldHVybiBmLmZpbGVTZWxlY3Rpb25Vcmkoe1xcXFxuICAgICAgICAgICAgY2FsbGJhY2s6ICQudG9TdHJpbmcoKCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIGxldCB0YXJnZXQgPSBmaW5kSXRlbShcXFxcXFxcImZpbGVQYXRoXFxcXFxcXCIpLmV4dHJhO1xcXFxuICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0oXFxcXFxcXCJmaWxlUGF0aFxcXFxcXFwiLCB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhOiBPYmplY3QuYXNzaWduKHRhcmdldCwge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBQQVRIXFxcXG4gICAgICAgICAgICAgICAgICAgIH0pXFxcXG4gICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICAgICAgcHV0VmFyKCdob3VzZS53ZWJfdXJsJyxQQVRIKTtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXFxcbiAgICAgICAgICAgIH0pLFxcXFxuICAgICAgICAgICAgb25DbGlja1R5cGU6J2NvbmZpcm0nLFxcXFxuICAgICAgICAgICAgZmlsZVR5cGU6IFxcXFxcXFwiLmpzfC50eHR8Lmhpa2VyfC5qc29ufC5odG1sXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBwYXR0ZXJuOiAwLFxcXFxuICAgICAgICAgICAgcmVxdWlyZVVybDpmcCxcXFxcbiAgICAgICAgICAgIGluaXRpYWxQYXRoOmdldFBhdGgoJ2hpa2VyOi8vZmlsZXMvcnVsZXMvZHpIb3VzZS8nKS5zbGljZSg3KSxcXFxcbiAgICAgICAgICAgIG1lbW9yeTondHJ1ZScsXFxcXG4gICAgICAgIH0pO1xcXFxuICAgIH0pLFxcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfY2VudGVyXzFcXFxcXFxcIixcXFxcbn0pO1xcXFxuZC5wdXNoKHtcXFxcbiAgICB0aXRsZTon5LiK5Lyg57G75Z6LJyxcXFxcbiAgICBkZXNjOifkuIrkvKDmlofku7bnmoTnsbvlnoss5b2T5YmN5Li6OicrY29sb3IoZ2V0SXRlbSgnaG91c2UuZmlsZV90eXBlJywn6Z2Z5oCB5paH5Lu2JyksJyNmZjcwMDAnKSxcXFxcbiAgICBjb2xfdHlwZTondGV4dF8xJyxcXFxcbiAgICB1cmw6JChmaWxlX3R5cGVfdGl0bGUsMikuc2VsZWN0KCgpID0+IHtcXFxcbiAgICAgICAgc2V0SXRlbSgnaG91c2UuZmlsZV90eXBlJyxpbnB1dC5yZXBsYWNlKCfwn5GJJywnJykpO1xcXFxuICAgICAgICByZWZyZXNoUGFnZSh0cnVlKTtcXFxcbiAgICAgICAgcmV0dXJuICd0b2FzdDovL+S9oOmAieaLqeS6hjonK2lucHV0O1xcXFxuICAgIH0pXFxcXG59KTtcXFxcblxcXFxuZC5wdXNoKHtcXFxcbiAgICB0aXRsZTon5paH5Lu25a6a5L2NJyxcXFxcbiAgICBkZXNjOifmlofku7bmmK/lkKblsZ7kuo7ph43lrprlkJEs5b2T5YmN5Li6OicrY29sb3IoZ2V0SXRlbSgnaG91c2UuZmlsZV9yZWRpcmVjdCcsJ+acrOWcsCcpLCcjZmY3MDAwJyksXFxcXG4gICAgY29sX3R5cGU6J3RleHRfMScsXFxcXG4gICAgdXJsOiQoZmlsZV9yZWRpcmVjdF90aXRsZSwyKS5zZWxlY3QoKCkgPT4ge1xcXFxuICAgICAgICBzZXRJdGVtKCdob3VzZS5maWxlX3JlZGlyZWN0JyxpbnB1dC5yZXBsYWNlKCfwn5GJJywnJykpO1xcXFxuICAgICAgICByZWZyZXNoUGFnZSh0cnVlKTtcXFxcbiAgICAgICAgcmV0dXJuICd0b2FzdDovL+S9oOmAieaLqeS6hjonK2lucHV0O1xcXFxuICAgIH0pXFxcXG59KTtcXFxcblxcXFxuZC5wdXNoKHtcXFxcbiAgICB0aXRsZTon6K6+5aSHVUEnLFxcXFxuICAgIGRlc2M6J+WPkei1t+e9kemhteivt+axguWktOagh+ivhizlvZPliY3kuLo6Jytjb2xvcihnZXRJdGVtKCdob3VzZS5maWxlX3VhJywn55S16ISRJyksJyNmZjcwMDAnKSxcXFxcbiAgICBjb2xfdHlwZTondGV4dF8xJyxcXFxcbiAgICB1cmw6JChmaWxlX3VhX3RpdGxlLDIpLnNlbGVjdCgoKSA9PiB7XFxcXG4gICAgICAgIHNldEl0ZW0oJ2hvdXNlLmZpbGVfdWEnLGlucHV0LnJlcGxhY2UoJ/CfkYknLCcnKSk7XFxcXG4gICAgICAgIHJlZnJlc2hQYWdlKHRydWUpO1xcXFxuICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5L2g6YCJ5oup5LqGOicraW5wdXQ7XFxcXG4gICAgfSlcXFxcbn0pO1xcXFxuZnVuY3Rpb24gY29tcGFyZShuYW1lKSB7XFxcXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGl0ZW0pIHtcXFxcbiAgICAgICAgcmV0dXJuIGl0ZW0ubmFtZSA9PT0gbmFtZTtcXFxcbiAgICB9XFxcXG59XFxcXG5kLnB1c2goe1xcXFxuICAgIHRpdGxlOifwn5eE77iP546v5aKDJyxcXFxcbiAgICBjb2xfdHlwZTonZmxleF9idXR0b24nLFxcXFxuICAgIHVybDokKCkubGF6eVJ1bGUoKGZpbGVfdHlwZSxjb21wYXJlKT0+e1xcXFxuICAgICAgICBsb2coJ+afpeeci+eOr+Wig+WPmOmHjycpO1xcXFxuICAgICAgICB0cnkge1xcXFxuICAgICAgICAgICAgbGV0IHVwX2NvZGUgPSBnZXRWYXIoJ2hvdXNlLnVwbG9hZF9jb2RlJywnJyk7XFxcXG4gICAgICAgICAgICBsZXQgZnR5cGUgPSAgZmlsZV90eXBlLmZpbHRlcihjb21wYXJlKGdldEl0ZW0oJ2hvdXNlLmZpbGVfdHlwZScsJ+mdmeaAgeaWh+S7ticpKSlbMF0udmFsdWU7XFxcXG4gICAgICAgICAgICBsZXQgcmVkaXJlY3QgPSBnZXRJdGVtKCdob3VzZS5maWxlX3JlZGlyZWN0Jywn5pys5ZywJykhPT0n5pys5ZywJztcXFxcbiAgICAgICAgICAgIGxldCBjb2RlID0gIXJlZGlyZWN0P3VwX2NvZGU6aW5wdXQ7XFxcXG4gICAgICAgICAgICBsZXQgZW52ID0ge1xcXFxuICAgICAgICAgICAgICAgIHdlYl91cmw6Z2V0VmFyKCdob3VzZS53ZWJfdXJsJywnJyksXFxcXG4gICAgICAgICAgICAgICAgZGV2aWNlOmdldEl0ZW0oJ2hvdXNlLmZpbGVfdWEnLCfnlLXohJEnKSxcXFxcbiAgICAgICAgICAgICAgICBmdHlwZTpmdHlwZXx8XFxcXFxcXCJcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICByZWRpcmVjdDpyZWRpcmVjdCxcXFxcbiAgICAgICAgICAgICAgICBjb2RlOmNvZGUuc3Vic3RyaW5nKDAsNDApfHxcXFxcXFxcIlxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgbG9nKGVudik7XFxcXG4gICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8vJytKU09OLnN0cmluZ2lmeShlbnYpO1xcXFxuICAgICAgICAgICAgLy8gYWxlcnQoSlNPTi5zdHJpbmdpZnkoZW52KSk7XFxcXG4gICAgICAgIH1jYXRjaCAoZSkge1xcXFxuICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovLycrZS5tZXNzYWdlO1xcXFxuICAgICAgICAgICAgLy8gYWxlcnQoZS5tZXNzYWdlKTtcXFxcbiAgICAgICAgfVxcXFxuICAgIH0sZmlsZV90eXBlLGNvbXBhcmUpXFxcXG59KTtcXFxcblxcXFxuZC5wdXNoKHtcXFxcbiAgICB0aXRsZTon8J+Tg+aVmeeoiycsXFxcXG4gICAgY29sX3R5cGU6J2ZsZXhfYnV0dG9uJyxcXFxcbiAgICB1cmw6JCgpLng1UnVsZSgoKT0+e1xcXFxuICAgICAgICBsZXQgbXNnID0gJ+asoui/juS9v+eUqOW8gOWPkeiAheabtOWkmuWIhuS6q+W3peWFt1xcXFxcXFxcbjEu6L6T5YWl572R5Z2A5Li65pys5Zyw5paH5Lu26Lev5b6ELGhpa2VyOi8v5oiW6ICFZmlsZTovL+W8gOWktFxcXFxcXFxcbjIu54K55Ye7572R5Z2A6L6T5YWl5qCP5ZCO6Z2i55qE5oyJ6ZKuXFxcXFxcXFxuMy7nnIvmlofmnKzpooTop4jljLrmmK/lkKbmraPnoa5cXFxcXFxcXG40LueCueWHu+S4iuS8oOaMiemSruaPkOS6pOWIsOS7k+W6kyc7XFxcXG4gICAgICAgIGFsZXJ0KG1zZyk7XFxcXG4gICAgfSlcXFxcbn0pO1xcXFxuXFxcXG5kLnB1c2goe1xcXFxuICAgIHRpdGxlOifwn5eR77iP5riF56m6JyxcXFxcbiAgICBjb2xfdHlwZTonZmxleF9idXR0b24nLFxcXFxuICAgIHVybDokKCkubGF6eVJ1bGUoKCk9PntcXFxcbiAgICAgICAgY2xlYXJWYXIoJ2hvdXNlLnVwbG9hZF9jb2RlJyk7XFxcXG4gICAgICAgIHJlZnJlc2hQYWdlKHRydWUpO1xcXFxuICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5bey5riF6Zmk6aKE6KeI5Yy65Z+f5YaF5a65J1xcXFxuICAgIH0pXFxcXG59KTtcXFxcblxcXFxuZC5wdXNoKHtcXFxcbiAgICB0aXRsZTon8J+TsuekuuS+iycsXFxcXG4gICAgY29sX3R5cGU6J2ZsZXhfYnV0dG9uJyxcXFxcbiAgICB1cmw6JCgpLmxhenlSdWxlKCgpPT57XFxcXG4gICAgICAgIGxldCBkZW1vX2NvZGUgPSBnZXRJdGVtKCdob3VzZS5kZW1vJywnMCcpO1xcXFxuICAgICAgICBpZihkZW1vX2NvZGU9PScwJyl7XFxcXG4gICAgICAgICAgICBwdXRWYXIoJ2hvdXNlLndlYl91cmwnLCdoaWtlcjovL2ZpbGVzL3J1bGVzL2R6SG91c2UvaHRtbC/otYTmupDnvZHkuabnrb4uaHRtbCcpO1xcXFxuICAgICAgICAgICAgZGVtb19jb2RlID0gcGFyc2VJbnQoZGVtb19jb2RlKSsxO1xcXFxuICAgICAgICAgICAgc2V0SXRlbSgnaG91c2UuZGVtbycsZGVtb19jb2RlKycnKTtcXFxcbiAgICAgICAgfWVsc2V7XFxcXG4gICAgICAgICAgICBwdXRWYXIoJ2hvdXNlLndlYl91cmwnLCdmaWxlOi8vL3N0b3JhZ2UvZW11bGF0ZWQvMC9BbmRyb2lkL2RhdGEvY29tLmV4YW1wbGUuaGlrZXJ2aWV3L2ZpbGVzL0RvY3VtZW50cy9ydWxlcy9kekhvdXNlL2h0bWwv6LWE5rqQ572R5Lmm562+Lmh0bWwnKTtcXFxcbiAgICAgICAgICAgIHNldEl0ZW0oJ2hvdXNlLmRlbW8nLCcwJyk7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcmVmcmVzaFBhZ2UodHJ1ZSk7XFxcXG4gICAgICAgIHJldHVybiAndG9hc3Q6Ly/lt7Lorr7nva7npLrkvovlnLDlnYAnXFxcXG4gICAgfSlcXFxcbn0pO1xcXFxuXFxcXG5kLnB1c2goe1xcXFxuICAgIHRpdGxlOifwn5Ok5LiK5LygJyxcXFxcbiAgICBjb2xfdHlwZTonZmxleF9idXR0b24nLFxcXFxuICAgIHVybDokKCkubGF6eVJ1bGUoKGNhbnVwLGhvdXNlX2RhdGEscHV0X3VybCxmaWxlX3R5cGUpID0+e1xcXFxuICAgICAgICBmdW5jdGlvbiBjb21wYXJlKG5hbWUpIHtcXFxcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihpdGVtKSB7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0ubmFtZSA9PT0gbmFtZTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBjb25zdCB7Z2V0Tm93Rm9ybWF0RGF0ZX09JC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3V0aWxpeVxcXFxcXFwiKTtcXFxcbiAgICAgICAgbGV0IHVwX2NvZGUgPSBnZXRWYXIoJ2hvdXNlLnVwbG9hZF9jb2RlJywnJyk7XFxcXG4gICAgICAgIGlmKHVwX2NvZGUubGVuZ3RoIDwgMil7XFxcXG4gICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5rqQ56CB5Yy65peg5YaF5a6577yM6K+35YWI6K6/6Zeu5LiA5Liq6Z2Z5oCB6aG16Z2iJ1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGlmKCFjYW51cCl7XFxcXG4gICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5L2g5LiN5piv5byA5Y+R6ICF77yM5rKh5pyJ5o+Q5Lqk5Yiw5LuT5bqT55qE5p2D5YipISdcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBsZXQgaW5wdXQgPSBnZXRWYXIoJ2hvdXNlLndlYl91cmwnLCcnKTtcXFxcbiAgICAgICAgbGV0IHdlYl91cmwgPSBpbnB1dC5zcGxpdCgnOycpWzBdO1xcXFxuICAgICAgICBsZXQgZmlsZU5hbWUgPSAnJztcXFxcbiAgICAgICAgaWYoL15oaWtlcjp8XmZpbGU6fF5odHRwOnxeaHR0cHM6fF5cXFxcXFxcXC9zdG9yYWdlXFxcXFxcXFwvfF5cXFxcXFxcXC9zZGNhcmRcXFxcXFxcXC8vLnRlc3Qod2ViX3VybCkpe1xcXFxuICAgICAgICAgICAgZmlsZU5hbWUgPSB3ZWJfdXJsLnNwbGl0KCcvJylbd2ViX3VybC5zcGxpdCgnLycpLmxlbmd0aC0xXTtcXFxcbiAgICAgICAgfWVsc2UgaWYoL+S4u+mimO+/pXzlhYPntKDvv6UvLnRlc3QoaW5wdXQpKXtcXFxcbiAgICAgICAgICAgIGxldCBia2FyciA9IHVwX2NvZGUuc3BsaXQoJ++/pScpO1xcXFxuICAgICAgICAgICAgaWYoYmthcnIubGVuZ3RoPDMpe1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/kupHliarotLTmnb/lhoXlrrnmnInor68nXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICBzd2l0Y2ggKGJrYXJyWzFdKSB7XFxcXG4gICAgICAgICAgICAgICAgY2FzZSAnbXlfaG9tZV90aGVtZSc6XFxcXG4gICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lID0gdXBfY29kZS5zcGxpdCgn44CMJylbMV0uc3BsaXQoJ+OAjScpWzBdO1xcXFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXFxcbiAgICAgICAgICAgICAgICBjYXNlICdteV9ob21lX3NpbmdsZSc6XFxcXG4gICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lID0gdXBfY29kZS5zcGxpdCgn44CMJylbMV0uc3BsaXQoJ+OAjScpWzBdO1xcXFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXFxcbiAgICAgICAgICAgICAgICBjYXNlICdqc191cmwnOlxcXFxuICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZSA9IHVwX2NvZGUuc3BsaXQoJ++/pScpWzJdLnNwbGl0KCdAJylbMF07XFxcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9ZWxzZXtcXFxcbiAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/plJnor6/vvIznvZHpobXpk77mjqXml6DlhoXlrrkhJztcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBsZXQgdWEgPSBnZXRJdGVtKCdob3VzZS5maWxlX3VhJyk9PT0n55S16ISRJz8nTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzg4LjAuNDMyNC4xNDYgU2FmYXJpLzUzNy4zNic6J01vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCA5OyBNSSA2KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvODkuMC40Mzg5LjkwIE1vYmlsZSBTYWZhcmkvNTM3LjM2JztcXFxcbiAgICAgICAgbGV0IGhlYWRlcnMgPSB7XFxcXG4gICAgICAgICAgICAnUmVmZXJlcic6J2h0dHBzOi8vYmxvZy5jc2RuLm5ldCcsXFxcXG4gICAgICAgICAgICBcXFxcXFxcImNvbnRlbnQtdHlwZVxcXFxcXFwiOiBcXFxcXFxcImFwcGxpY2F0aW9uL2pzb25cXFxcXFxcIixcXFxcbiAgICAgICAgICAgICdVc2VyLUFnZW50Jzp1YSxcXFxcbiAgICAgICAgICAgICdBY2NlcHQnOidhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHQsICovKjsgcT0wLjAxJyxcXFxcbiAgICAgICAgICAgICdBY2NlcHQtTGFuZ3VhZ2UnOid6aC1DTicsXFxcXG4gICAgICAgIH07XFxcXG4gICAgICAgIGxldCB0b0NvbXBhcmUgPSAnJztcXFxcbiAgICAgICAgaWYoZmlsZU5hbWUuZW5kc1dpdGgoJy5odG1sJykpe1xcXFxuICAgICAgICAgICAgdG9Db21wYXJlID0gJ+mdmeaAgeaWh+S7tic7XFxcXG4gICAgICAgIH1lbHNlIGlmKC/kuLvpopgvLnRlc3QoZmlsZU5hbWUpKXtcXFxcbiAgICAgICAgICAgIHRvQ29tcGFyZSA9ICfkuLvpobXphY3nva4nXFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgbGV0IGZ0eXBlID0gIGZpbGVfdHlwZS5maWx0ZXIoY29tcGFyZSh0b0NvbXBhcmV8fGdldEl0ZW0oJ2hvdXNlLmZpbGVfdHlwZScsJ+mdmeaAgeaWh+S7ticpKSlbMF0udmFsdWU7XFxcXG4gICAgICAgIGxldCByZWRpcmVjdCA9IGdldEl0ZW0oJ2hvdXNlLmZpbGVfcmVkaXJlY3QnLCfmnKzlnLAnKSE9PSfmnKzlnLAnO1xcXFxuICAgICAgICBpZihyZWRpcmVjdCYmIXdlYl91cmwuc3RhcnRzV2l0aCgnaHR0cCcpKXtcXFxcbiAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/nm7Tpk74zMDLph43lrprlkJHnvZHlnYDpk77mjqXlv4XpobtodHRw5byA5aS0JztcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBsZXQgY29kZSA9ICFyZWRpcmVjdD91cF9jb2RlOndlYl91cmw7XFxcXG4gICAgICAgIGxldCBkYXRhID0ge1xcXFxcXFwicGFyYW1zXFxcXFxcXCI6XFxcXG4gICAgICAgICAgICAgICAge1xcXFxcXFwiZGF0YVxcXFxcXFwiOiB7cnVsZV9uYW1lOiBmaWxlTmFtZSwgXFxcXFxcXCJydWxlX3R5cGVcXFxcXFxcIjogJ+abtOWkmuWIhuS6qycsIFxcXFxcXFwidmVyc2lvblxcXFxcXFwiOmdldE5vd0Zvcm1hdERhdGUoKSxcXFxcXFxcInJ1bGVfdmFsdWVcXFxcXFxcIjogY29kZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFfdHlwZTpmdHlwZSwgaXNfcmVkaXJlY3Q6cmVkaXJlY3QsZGV2aWNlVWE6Z2V0SXRlbSgnaG91c2UuZmlsZV91YScpLFxcXFxuICAgICAgICAgICAgICAgICAgICB9LFxcXFxuICAgICAgICAgICAgICAgICAgICBcXFxcXFxcIm5hbWVcXFxcXFxcIjogaG91c2VfZGF0YS51c2VybmFtZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJwYXNzd29yZFxcXFxcXFwiOiBob3VzZV9kYXRhLnBhc3N3b3JkfVxcXFxuICAgICAgICB9O1xcXFxuICAgICAgICBsZXQgdXBwYXJhbXMgPSB7aGVhZGVyczpoZWFkZXJzLGJvZHk6SlNPTi5zdHJpbmdpZnkoZGF0YSksd2l0aEhlYWRlcnM6ZmFsc2UscmVkaXJlY3Q6ZmFsc2UsbWV0aG9kOidQT1NUJ307XFxcXG4gICAgICAgIGxldCBiYWNrbXNnID0gZ2V0SXRlbSgnaG91c2UuZmlsZV91YScpPT09J+eUteiEkSc/ZmV0Y2gocHV0X3VybCx1cHBhcmFtcyk6cmVxdWVzdChwdXRfdXJsLHVwcGFyYW1zKTtcXFxcbiAgICAgICAgdHJ5e1xcXFxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IEpTT04ucGFyc2UoYmFja21zZykucmVzdWx0O1xcXFxuICAgICAgICAgICAgbGV0IGRldGFpbCA9IHJlc3VsdC5kZXRhaWw7XFxcXG4gICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8vJytkZXRhaWw7XFxcXG4gICAgICAgIH1jYXRjaCAoZSkge1xcXFxuICAgICAgICAgICAgbG9nKGUubWVzc2FnZSk7XFxcXG4gICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5Y+R55Sf5LqG6ZSZ6K+vXFxcXFxcXFxuJytlLm1lc3NhZ2U7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9LGNhbnVwLGhvdXNlX2RhdGEscHV0X3VybCxmaWxlX3R5cGUpXFxcXG59KTtcXFxcblxcXFxuZC5wdXNoKHtcXFxcbiAgICB0aXRsZTon6ZW/5paH5pys6aKE6KeI5Yy65Z+fJyxcXFxcbiAgICBjb2xfdHlwZTondGV4dF8xJyxcXFxcbiAgICB1cmw6J2hpa2VyOi8vZW1wdHknLFxcXFxuICAgIGV4dHJhOiB7dGV4dFNpemU6IDExLGxpbmVWaXNpYmxlOmZhbHNlfVxcXFxufSk7XFxcXG5cXFxcbmQucHVzaCh7XFxcXG4gICAgdGl0bGU6Z2V0VmFyKCdob3VzZS51cGxvYWRfY29kZScsJycpLnN1YnN0cmluZygwLDEwMjQwKSxcXFxcbiAgICBjb2xfdHlwZTonbG9uZ190ZXh0JyxcXFxcbiAgICBleHRyYToge3RleHRTaXplOiAxMX1cXFxcbn0pO1xcXFxuc2V0UGFnZVRpdGxlKFxcXFxcXFwi5pu05aSa5YiG5LqrXFxcXFxcXCIpO1xcXFxuc2V0UmVzdWx0KGQpO1xcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIui9u+WQiOmbhueUn+aIkOaOpeWPo1xcXCIsXFxcInBhdGhcXFwiOlxcXCJnZW5BcGlcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5mdW5jdGlvbiBnZW5SdWxlKG5hbWUsdXJsLGljb24pe1xcXFxuICAgIGljb249aWNvbnx8J2h0dHBzOi8vejMuYXgxeC5jb20vMjAyMS8xMS8xNi9JV0poeGYucG5nJztcXFxcbiAgICBjb25zdCB7Z2V0Tm93Rm9ybWF0RGF0ZSxhcGksZ2V0QXBpfT0kLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvdXRpbGl5P3J1bGU96YGT6ZW/5LuT5bqTUHJvXFxcXFxcXCIpO1xcXFxuICAgIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZUFsbCA9IGZ1bmN0aW9uKG9sZCxuZXdfc3RyKXtcXFxcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BsaXQob2xkKS5qb2luKG5ld19zdHIpO1xcXFxuICAgIH07XFxcXG4gICAgbGV0IG11YmFuID0gZ2V0QXBpKCdpbXBvcnRVcmwnKStcXFxcXFxcIjE2OTBcXFxcXFxcIjtcXFxcbiAgICBsZXQgbXViYW5fd29yZD17bmFtZTpcXFxcXFxcIkDovbvlkIjpm4ZcXFxcXFxcIix1cmw6XFxcXFxcXCJA5Zyw5Z2AXFxcXFxcXCIsdmVyOlxcXFxcXFwiQOeJiOacrFxcXFxcXFwiLGljb246XFxcXFxcXCJA5Zu+5qCHXFxcXFxcXCJ9O1xcXFxuICAgIGxldCBtdWJhbl9jb2RlID0gZmV0Y2gobXViYW4pO1xcXFxuICAgIG11YmFuX2NvZGU9bXViYW5fY29kZS5yZXBsYWNlQWxsKG11YmFuX3dvcmQubmFtZSxuYW1lKS5yZXBsYWNlQWxsKG11YmFuX3dvcmQudmVyLGdldE5vd0Zvcm1hdERhdGUoKSkucmVwbGFjZUFsbChtdWJhbl93b3JkLnVybCx1cmwpLnJlcGxhY2VBbGwobXViYW5fd29yZC5pY29uLGljb24pO1xcXFxuICAgIGxldCBpbXBvcnRfY29kZT1cXFxcXFxcIua1t+mYlOinhueVjOinhOWImeWIhuS6q++8jOW9k+WJjeWIhuS6q+eahOaYr++8muWwj+eoi+W6j++8jOaXoOagueagke+8jOiKseato+a4he+8jOS4jeaWreiNpOiFpeS4jeaIkua3q++/pWhvbWVfcnVsZV92Mu+/pWJhc2U2NDovL0BcXFxcXFxcIituYW1lK1xcXFxcXFwiQFxcXFxcXFwiK2Jhc2U2NEVuY29kZShtdWJhbl9jb2RlKTtcXFxcbiAgICB2YXIgcGFzdGVzID0gZ2V0UGFzdGVzKCk7XFxcXG4gICAgdmFyIHVybCA9IHNoYXJlUGFzdGUoaW1wb3J0X2NvZGUscGFzdGVzLnNsaWNlKC0xKVswXSk7XFxcXG4gICAgbGV0IGltcG9ydF9ydWxlPSB1cmwrXFxcXFxcXCJcXFxcXFxcXG5cXFxcXFxcXG7lsI/nqIvluo/vvJpcXFxcXFxcIituYW1lO1xcXFxuICAgIHJldHVybiBpbXBvcnRfcnVsZTtcXFxcbn1cXFxcbiQuZXhwb3J0cy5nZW5SdWxlPWdlblJ1bGU7XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5YWo5bGA6Kej5p6Q5YWN5ZeFXFxcIixcXFwicGF0aFxcXCI6XFxcImdsb2JhbFBhcnNlXFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxuICAgIGZ1bmN0aW9uIGdldEhlYWRlcnMocGxheVVybCl7XFxcXG4gICAgICAgIGxldCBoZWFkZXJzID0ge307XFxcXG4gICAgICAgIGxldCByZWZlcj1wbGF5VXJsLnNwbGl0KFxcXFxcXFwiLy9cXFxcXFxcIilbMF0rXFxcXFxcXCIvL1xcXFxcXFwiK3BsYXlVcmwuc3BsaXQoXFxcXFxcXCIvL1xcXFxcXFwiKVsxXS5zcGxpdChcXFxcXFxcIi9cXFxcXFxcIilbMF07XFxcXG4gICAgICAgIGlmKC9sZWNsb3VkXFxcXFxcXFwuY29tfGJpbGl2aWRlb1xcXFxcXFxcLmNvbS8udGVzdChwbGF5VXJsKSl7XFxcXG4gICAgICAgICAgICBoZWFkZXJzID0ge1xcXFxcXFwiUmVmZXJlclxcXFxcXFwiOiAnaHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tLycsXFxcXFxcXCJVc2VyLUFnZW50XFxcXFxcXCI6XFxcXFxcXCJNb3ppbGxhLzUuMFxcXFxcXFwifVxcXFxuICAgICAgICB9ZWxzZSBpZigvbWd0dlxcXFxcXFxcLmNvbS8udGVzdChwbGF5VXJsKSl7XFxcXG4gICAgICAgICAgICBoZWFkZXJzID0ge1xcXFxcXFwiUmVmZXJlclxcXFxcXFwiOiByZWZlcixcXFxcXFxcIlVzZXItQWdlbnRcXFxcXFxcIjpcXFxcXFxcIk1vemlsbGEvNS4wXFxcXFxcXCJ9XFxcXG4gICAgICAgIH1lbHNlIGlmKC9peGlndWFcXFxcXFxcXC5jb20vLnRlc3QocGxheVVybCkpe1xcXFxuICAgICAgICAgICAgaGVhZGVycyA9IHtcXFxcXFxcIlJlZmVyZXJcXFxcXFxcIjogJ2h0dHBzOi8vd3d3Lml4aWd1YS5jb20vJyxcXFxcXFxcIlVzZXItQWdlbnRcXFxcXFxcIjpcXFxcXFxcIk1vemlsbGEvNS4wXFxcXFxcXCJ9XFxcXG4gICAgICAgIH1lbHNle1xcXFxuICAgICAgICAgICAgLy8gaGVhZGVycyA9IHtcXFxcXFxcIlJlZmVyZXJcXFxcXFxcIjogcmVmZXIsJ1VzZXItQWdlbnQnOidEYXJ0LzIuMTMgKGRhcnQ6aW8pJ31cXFxcbiAgICAgICAgICAgIC8vIGhlYWRlcnMgPSB7XFxcXFxcXCJSZWZlcmVyXFxcXFxcXCI6IHJlZmVyLCdVc2VyLUFnZW50JzpNT0JJTEVfVUF9O1xcXFxuICAgICAgICAgICAgaGVhZGVycyA9IHsnVXNlci1BZ2VudCc6TU9CSUxFX1VBfTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICByZXR1cm4gaGVhZGVyc1xcXFxuICAgIH1cXFxcbmZ1bmN0aW9uIGlzUGljKHN0cil7XFxcXG4gICAgcmV0dXJuIC9cXFxcXFxcXC4oZ2lmfGpwZ3xqcGVnfHBuZ3xHSUZ8SlBHfFBORykkLy50ZXN0KHN0cik7XFxcXG59XFxcXG5mdW5jdGlvbiBpc1ZpZGVvKHBsYXlVcmwscmVjaGFuZ2Upe1xcXFxuICAgIC8v5rOo5oSPLnBocOS4jeWPr+S7peiiq+aOkumZpOWQpuWImeiejeWFtOino+aekOS4jeS6hiB8LnBocCRcXFxcbiAgICAvL+WmguaenOaYr+aSreaUvuWcsOWdgOWwseebtOaOpei/lOWbnuWcsOWdgOWKoOS4ilVB77yM5LiN5piv55qE6K+d5bCx6L+U5ZueZmFsc2VcXFxcbiAgICAvLyBsZXQgdDEgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcXFxcbiAgICBsZXQgY2FjaGVSZWd4ID0gbmV3IFJlZ0V4cCgnZmlsZTovLy9zdG9yYWdlL2VtdWxhdGVkLyguKj8pXFxcXFxcXFxcXFxcXFxcXC5tM3U4fGhpa2VyOi8vZmlsZXMvKC4qPylcXFxcXFxcXFxcXFxcXFxcLm0zdTgnKTtcXFxcbiAgICBpZihjYWNoZVJlZ3gudGVzdChwbGF5VXJsKSl7XFxcXG4gICAgICAgIHJldHVybiBwbGF5VXJsXFxcXG4gICAgfVxcXFxuICAgIGZ1bmN0aW9uIGdldEhvc3QodXJsKXtcXFxcbiAgICAgICAgLy8gZmJh55qEcGFyc2VMYXp55aSq5oWi5LqG5Y2D5LiH5Yir55SoXFxcXG4gICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICByZXR1cm4gdXJsLm1hdGNoKC9eaHR0cChzKT86XFxcXFxcXFwvXFxcXFxcXFwvKC4qPylcXFxcXFxcXC8vKVswXS5zbGljZSgwLC0xKTtcXFxcbiAgICAgICAgfWNhdGNoIChlKSB7XFxcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICAvKlxcXFxuICAgICAgICBpZih0eXBlb2YobG9nKT09PSd1bmRlZmluZWQnKXtcXFxcbiAgICAgICAgICAgIHJldHVybiAgZmJhLnBhcnNlTGF6eVJ1bGUoJCQkKCkubGF6eVJ1bGUoKHVybCk9PntcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0SG9tZSh1cmwpXFxcXG4gICAgICAgICAgICB9LHVybCkpXFxcXG4gICAgICAgIH1lbHNlIHtcXFxcbiAgICAgICAgICAgIHJldHVybiBnZXRIb21lKHVybClcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICAqL1xcXFxuICAgIH1cXFxcbiAgICBsZXQgcFVybD1wbGF5VXJsLnNwbGl0KFxcXFxcXFwiO1xcXFxcXFwiKVswXTsvL+iOt+WPluaKoOaOiea1t+mYlHVh562J5Y+C5pWw55qE572R6aG15pKt5pS+6ZO+5o6lXFxcXG4gICAgbGV0IGhvc3QgPSBnZXRIb3N0KHBVcmwpOyAvLyDojrflj5bln5/lkI1cXFxcbiAgICBpZighaG9zdCl7Ly/liKTmlq3ml6Dln5/lkI3nm7TmjqXkuI3mmK/op4bpopFcXFxcbiAgICAgICAgcmV0dXJuIGZhbHNlXFxcXG4gICAgfVxcXFxuICAgIGZ1bmN0aW9uIHByaW50KGRhdGEpe1xcXFxuICAgICAgICBpZih0eXBlb2YobG9nKT09PSd1bmRlZmluZWQnKXtcXFxcbiAgICAgICAgICAgIHJldHVybiAgZmJhLmxvZyhkYXRhKVxcXFxuICAgICAgICB9ZWxzZSB7XFxcXG4gICAgICAgICAgICByZXR1cm4gbG9nKGRhdGEpXFxcXG4gICAgICAgIH1cXFxcbiAgICB9XFxcXG4gICAgcmVjaGFuZ2U9dHlwZW9mKHJlY2hhbmdlKT09PVxcXFxcXFwiZnVuY3Rpb25cXFxcXFxcIj9yZWNoYW5nZTpmdW5jdGlvbihwbGF5VXJsKXtyZXR1cm4gcGxheVVybH07XFxcXG4gICAgbGV0IGV4Y2VwdFdvcmRzID0gJy5qcyR8LmNzcyR8LnRzJHwuaHRtbCR8Lmh0bSR8LmdpZiR8LmpwZyR8LmpwZWckfC5wbmckfC5pY28kfC5zdmckfC50eHQkJy5zcGxpdCgnfCcpLm1hcChpdD0+J1xcXFxcXFxcXFxcXFxcXFwnK2l0KS5qb2luKCd8Jyk7XFxcXG4gICAgdmFyIGV4Y2VwdEtleXMgPSBuZXcgUmVnRXhwKGV4Y2VwdFdvcmRzKTtcXFxcbiAgICBsZXQgZXhjZXB0V29yZHMxID0gJ3JlZmVyZXI9fHVybD0nLnNwbGl0KCd8JykubWFwKGl0PT5pdCkuam9pbignfCcpO1xcXFxuICAgIHZhciBleGNlcHRLZXlzMSA9IG5ldyBSZWdFeHAoZXhjZXB0V29yZHMxKTtcXFxcbiAgICBsZXQgcmVwbGFjZVdvcmRzID0gJ3BsYXltM3U4fG0zdThcXFxcXFxcXC50dicuc3BsaXQoJ3wnKS5tYXAoaXQ9Pml0KS5qb2luKCd8Jyk7XFxcXG4gICAgbGV0IHJlcGxhY2VLZXlzID0gbmV3IFJlZ0V4cChyZXBsYWNlV29yZHMsJ2cnKTtcXFxcbiAgICBsZXQgdmlkZW9Xb3JkcyA9IFxcXFxcXFwiL3ZpZGVvL3Rvc3wubXA0JHwubTN1OCR8LmZsdiR8LmF2aSR8LjNncCR8Lm1wZWckfC53bXYkfC5tb3YkfHJtdmJ8LmRhdCR8Lm1wMyR8Lm00YSR8cXFCRmRvd25sb2FkfG1pbWU9dmlkZW8lMkZ8bWltZV90eXBlPXZpZGVvX3x0eXBlPW0zdTh8cHQ9bTN1OFxcXFxcXFwiLnNwbGl0KCd8JykubWFwKChpdCk9PntcXFxcbiAgICAgICAgLy90eXBlPW1wNFxcXFxuICAgICAgICBpZihpdC5zdGFydHNXaXRoKFxcXFxcXFwiLlxcXFxcXFwiKSl7XFxcXG4gICAgICAgICAgICByZXR1cm4gJ1xcXFxcXFxcXFxcXFxcXFwnK2l0XFxcXG4gICAgICAgIH1lbHNle1xcXFxuICAgICAgICAgICAgcmV0dXJuIGl0XFxcXG4gICAgICAgIH1cXFxcbiAgICB9KS5qb2luKFxcXFxcXFwifFxcXFxcXFwiKTtcXFxcbiAgICBsZXQgdmlkZW9LZXlzID0gbmV3IFJlZ0V4cCh2aWRlb1dvcmRzKTtcXFxcbiAgICBsZXQgclVybCA9IHBVcmwucmVwbGFjZShob3N0LCcnKTsvL+iOt+WPlumZpOW8gOWfn+WQjeeahOWJqeS9memTvuaOpVxcXFxuICAgIGxldCBwVXJsMj1wVXJsLnNwbGl0KFxcXFxcXFwiJlxcXFxcXFwiKVswXS5zcGxpdChcXFxcXFxcIj9cXFxcXFxcIilbMF07Ly/ojrflj5bkuI3luKblj4LmlbDnmoTnvZHpobXpk77mjqVcXFxcbiAgICBsZXQgcnVybDIgPSBwVXJsMi5yZXBsYWNlKGhvc3QsJycpOy8v6I635Y+W6Zmk5byA5Z+f5ZCN55qE5Ymp5L2Z5LiN5bim5Y+C5pWw6ZO+5o6lXFxcXG4gICAgbGV0IGhhc0tleSA9IHZpZGVvS2V5cy50ZXN0KHJVcmwpfHx2aWRlb0tleXMudGVzdChydXJsMik7XFxcXG4gICAgbGV0IHBhclVybCA9IHBVcmwucmVwbGFjZShwVXJsLnNwbGl0KFxcXFxcXFwiP1xcXFxcXFwiKVswXSwnJyk7IC8vIOWIhuWJsumXruWPt+WQjuWJqeS9meWPguaVsOeahOWujOaVtOmTvuaOpVxcXFxuICAgIGxldCBleGNLZXkgPSBleGNlcHRLZXlzMS50ZXN0KHBhclVybCk7XFxcXG4gICAgaWYoclVybC5zcGxpdCgnPycpLmxlbmd0aD4yKXtcXFxcbiAgICAgICAgbGV0IHJVcmwzPXJVcmwuc3BsaXQoXFxcXFxcXCI/XFxcXFxcXCIpWzFdOy8v6I635Y+WP+WIhuWJsuWQjueahOesrOS4gOautVxcXFxuICAgICAgICBoYXNLZXkgPSBoYXNLZXl8fHZpZGVvS2V5cy50ZXN0KHJVcmwzKTtcXFxcbiAgICB9XFxcXG4gICAgaWYoaGFzS2V5JiYhZXhjS2V5KXtcXFxcbiAgICAgICAgbGV0IHRpcHMgPSAn5qOA5rWL5Yiw55aR5Ly85aSa5aqS5L2T55qE5Zyw5Z2AOic7XFxcXG4gICAgICAgIHByaW50KFxcXFxcXFwianPkuK1cXFxcXFxcIit0aXBzK3BVcmwpO1xcXFxuICAgICAgICBwcmludChcXFxcXFxcIuWIhuWJsumXruWPt+WQjjpcXFxcXFxcIitwYXJVcmwpO1xcXFxuICAgIH1cXFxcbiAgICAvLyBsb2coJzE6JysodmlkZW9LZXlzLnRlc3QocFVybCl8fHZpZGVvS2V5cy50ZXN0KHBVcmwyKXx8dmlkZW9LZXlzLnRlc3QocFVybC5yZXBsYWNlKHJlcGxhY2VLZXlzLFxcXFxcXFwiXFxcXFxcXCIpLnNwbGl0KFxcXFxcXFwiJlxcXFxcXFwiKVswXS5zcGxpdChcXFxcXFxcIj9cXFxcXFxcIilbMF0pKSk7XFxcXG4gICAgLy8gbG9nKCcyOicrIWV4Y2VwdEtleXMudGVzdChwVXJsLnNwbGl0KFxcXFxcXFwiP1xcXFxcXFwiKVswXS5zcGxpdCgnJicpWzBdKSk7XFxcXG4gICAgLy8gbG9nKCczOicrIWV4Y2VwdEtleXMxLnRlc3QocFVybC5yZXBsYWNlKHBVcmwuc3BsaXQoXFxcXFxcXCI/XFxcXFxcXCIpWzBdLCcnKSkpO1xcXFxuICAgIGlmICgoaGFzS2V5fHx2aWRlb0tleXMudGVzdChyVXJsLnJlcGxhY2UocmVwbGFjZUtleXMsXFxcXFxcXCJcXFxcXFxcIikuc3BsaXQoXFxcXFxcXCImXFxcXFxcXCIpWzBdLnNwbGl0KFxcXFxcXFwiP1xcXFxcXFwiKVswXSkgKSYmICFleGNlcHRLZXlzLnRlc3QocFVybDIpJiYhZXhjZXB0S2V5czEudGVzdChwVXJsMikpIHtcXFxcbiAgICAgICAgaWYoISgvVXNlci1BZ2VudHxSZWZlcmVyQC8udGVzdChwbGF5VXJsKSkpe1xcXFxuICAgICAgICAgICAgaWYoL2xlY2xvdWRcXFxcXFxcXC5jb218YmlsaXZpZGVvLy50ZXN0KHBsYXlVcmwpKXtcXFxcbiAgICAgICAgICAgICAgICBwbGF5VXJsKz1cXFxcXFxcIjt7UmVmZXJlckBodHRwczovL3d3dy5iaWxpYmlsaS5jb20vJiZVc2VyLUFnZW50QE1vemlsbGEvNS4wfVxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgfWVsc2UgaWYoL2l4aWd1YVxcXFxcXFxcLmNvbS8udGVzdChwbGF5VXJsKSl7XFxcXG4gICAgICAgICAgICAgICAgcGxheVVybCs9XFxcXFxcXCIjaXN2aWRlbz10cnVlIzt7UmVmZXJlckBodHRwczovL3d3dy5peGlndWEuY29tLyYmVXNlci1BZ2VudEBNb3ppbGxhLzUuMH1cXFxcXFxcIjtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIGVsc2UgaWYoL21ndHZcXFxcXFxcXC5jb218Ynl0ZWFtb25lLy50ZXN0KHBsYXlVcmwpKXtcXFxcbiAgICAgICAgICAgICAgICBwbGF5VXJsKz1cXFxcXFxcIjt7VXNlci1BZ2VudEBNb3ppbGxhLzUuMH1cXFxcXFxcIjtcXFxcbiAgICAgICAgICAgIH1lbHNlIGlmKC9wdHdvXFxcXFxcXFwud2tmaWxlXFxcXFxcXFwuY29tLy50ZXN0KHBsYXlVcmwpJiYvdXJsPS8udGVzdChwbGF5VXJsKSl7XFxcXG4gICAgICAgICAgICAgICAgcGxheVVybD1wbGF5VXJsLnNwbGl0KFxcXFxcXFwidXJsPVxcXFxcXFwiKVsxXStcXFxcXFxcIjt7UmVmZXJlckBodHRwczovL2ZhbnR1YW4udHZ9XFxcXFxcXCJcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIC8vIOWkhOeQhuWkp+W4iOWFhOS5i+exu+eahGFwcFxcXFxuICAgICAgICAgICAgLy8gZWxzZXtcXFxcbiAgICAgICAgICAgIC8vICAgICBwbGF5VXJsKz1cXFxcXFxcIjt7VXNlci1BZ2VudEBNb3ppbGxhLzUuMH1cXFxcXFxcIjtcXFxcbiAgICAgICAgICAgIC8vIH1cXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBwbGF5VXJsPXJlY2hhbmdlKHBsYXlVcmwpO1xcXFxuICAgICAgICBpZighLyNpc1ZpZGVvPXRydWUjLy50ZXN0KHBsYXlVcmwpKXtcXFxcbiAgICAgICAgICAgIHBsYXlVcmwrPVxcXFxcXFwiI2lzVmlkZW89dHJ1ZSNcXFxcXFxcIjtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICAvLyBsZXQgdDIgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcXFxcbiAgICAgICAgLy8gcHJpbnQoJ+WIpOaWrWlzVmlkZW/ogJfml7Y6JysodDItdDEpKTtcXFxcbiAgICAgICAgcmV0dXJuIHBsYXlVcmw7XFxcXG4gICAgfWVsc2V7XFxcXG4gICAgICAgIC8vIGxldCB0MiA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xcXFxuICAgICAgICAvLyBwcmludCgn5Yik5pataXNWaWRlb+iAl+aXtjonKyh0Mi10MSkpO1xcXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxcXG4gICAgfVxcXFxufVxcXFxuZnVuY3Rpb24gY29tUGFyc2UocGFyU3RyLGVqLG9ubHliYWNrLGh0bWwpe1xcXFxuICAgIC8v5YiX6KGo77yM5qCH6aKY77yM5Zu+54mH77yM5o+P6L+w77yM6ZO+5o6l77yM5YaF5a65XFxcXG4gICAgZWogPSBlanx8ZmFsc2U7Ly/mnInkuoznuqdcXFxcbiAgICBvbmx5YmFjaz1vbmx5YmFja3x8ZmFsc2U7Ly/lj6rov5Tlm57mlbDmja5cXFxcbiAgICBodG1sID0gaHRtbHx8Z2V0UmVzQ29kZSgpO1xcXFxuICAgIGh0bWwgPSB0eXBlb2YoaHRtbCk9PT0nc3RyaW5nJz9odG1sOmh0bWwuaHRtbDtcXFxcbiAgICByZXR1cm4gJC50b1N0cmluZygocGFyU3RyLGVqLG9ubHliYWNrLGh0bWwsaXNQaWMpPT57XFxcXG4gICAgICAgIGxldCB0PXBhclN0ci5zcGxpdChcXFxcXFxcIjtcXFxcXFxcIik7XFxcXG4gICAgICAgIGxldCBkPVtdO1xcXFxuICAgICAgICAvLyBsZXQgbGlzdD1wZGZhKGdldFJlc0NvZGUoKSx0WzBdKTtcXFxcbiAgICAgICAgbGV0IGxpc3Q9cGRmYShodG1sLHRbMF0pO1xcXFxuICAgICAgICBsZXQgbGF6eSA9ICQoJycpLmxhenlSdWxlKCgpPT57XFxcXG4gICAgICAgICAgICBjb25zdCB7bGF6eVBhcnNlfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2dsb2JhbFBhcnNlP3J1bGU96YGT6ZW/5LuT5bqTUHJvJyk7XFxcXG4gICAgICAgICAgICByZXR1cm4gbGF6eVBhcnNlKGlucHV0KVxcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgZm9yKGxldCBpIGluIGxpc3Qpe1xcXFxuICAgICAgICAgICAgbGV0IF9waWMgPSB0WzJdP3BkKGxpc3RbaV0sdFsyXSk6Jyc7XFxcXG4gICAgICAgICAgICBpZihpc1BpYyhfcGljKSYmIS9AUmVmZXJlcj0vLnRlc3QoX3BpYykpe1xcXFxuICAgICAgICAgICAgICAgIF9waWMrPSdAUmVmZXJlcj0nXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICBsZXQgaXQ9e1xcXFxuICAgICAgICAgICAgICAgIHRpdGxlOnBkZmgobGlzdFtpXSx0WzFdKSxcXFxcbiAgICAgICAgICAgICAgICBwaWNfdXJsOl9waWMsXFxcXG4gICAgICAgICAgICAgICAgZGVzYzpwZGZoKGxpc3RbaV0sdFszXSksXFxcXG4gICAgICAgICAgICAgICAgdXJsOmVqP3BkKGxpc3RbaV0sdFs0XSk6cGQobGlzdFtpXSx0WzRdKStsYXp5XFxcXG4gICAgICAgICAgICB9O1xcXFxuICAgICAgICAgICAgaWYodC5sZW5ndGg+NSl7Ly/lhoXlrrnvvIznlKjkuo7mkJzntKJcXFxcbiAgICAgICAgICAgICAgICBpdC5jb250ZW50PXBkZmgobGlzdFtpXSx0WzVdKVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgZC5wdXNoKGl0KTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBpZihvbmx5YmFjayl7XFxcXG4gICAgICAgICAgICByZXR1cm4gZFxcXFxuICAgICAgICB9ZWxzZXtcXFxcbiAgICAgICAgICAgIHNldFJlc3VsdChkKVxcXFxuICAgICAgICB9XFxcXG4gICAgfSxwYXJTdHIsZWosb25seWJhY2ssaHRtbCxpc1BpYylcXFxcbn1cXFxcblxcXFxuZnVuY3Rpb24gaXNCYWRWaWRlbyh2aWRlb1VybCkgey8v5piv5Z2P55qE6KeG6aKRXFxcXG4gICAgbGV0IGRtUGF0aCA9ICdoaWtlcjovL2ZpbGVzL2NhY2hlL2RpYW9tYW8udHh0JzsvL+WQiuavm+aooeW8j+i/h+a7pOaWh+S7tui3r+W+hFxcXFxuICAgIGxldCBkbVVybHM7XFxcXG4gICAgdHJ5IHtcXFxcbiAgICAgICAgZG1VcmxzID0gcmVxdWVzdChkbVBhdGgpLnRyaW0oKS5zcGxpdCgnXFxcXFxcXFxuJykuZmlsdGVyKGl0ID0+IGl0ICYmICFpdC5zdGFydHNXaXRoKCcvLycpKTtcXFxcbiAgICB9IGNhdGNoIChlKSB7XFxcXG4gICAgICAgIGRtVXJscyA9IFtdO1xcXFxuICAgIH1cXFxcblxcXFxuICAgIGZ1bmN0aW9uIGhhc0RtKHZpZGVvVXJsLCBkbVVybHMpIHsvL+aSreaUvuWcsOWdgOaYr+WQpuS4uuWQiuavm+inhumikVxcXFxuICAgICAgICBpZiAoZG1VcmxzLmxlbmd0aCA8IDEpIHtcXFxcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGZ1bmN0aW9uIHByaW50KHN0cil7XFxcXG4gICAgICAgICAgICBpZih0eXBlb2YobG9nKSE9PSd1bmRlZmluZWQnKXtcXFxcbiAgICAgICAgICAgICAgICBsb2coc3RyKTtcXFxcbiAgICAgICAgICAgIH1lbHNle1xcXFxuICAgICAgICAgICAgICAgIGZiYS5sb2coc3RyKTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBmb3IgKGxldCBkbVVybCBvZiBkbVVybHMpIHtcXFxcbiAgICAgICAgICAgIGlmICgobmV3IFJlZ0V4cChkbVVybCkpLnRlc3QodmlkZW9VcmwpKSB7Ly/mkq3mlL7lnLDlnYDljIXlkKvlkIrmr5vmoIflv5fnmoTlnLDlnYBcXFxcbiAgICAgICAgICAgICAgICBwcmludCgn5ZCK5q+b6KeG6aKRLOiHquWKqOi/h+a7pDonK3ZpZGVvVXJsKTtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHByaW50KCfpnZ7lkIrmr5vop4bpopEs5Y+v5pKt5pS+OicrdmlkZW9VcmwpO1xcXFxuICAgICAgICByZXR1cm4gZmFsc2VcXFxcbiAgICB9XFxcXG5cXFxcbiAgICBmdW5jdGlvbiBpc0RtKHJldCkge1xcXFxuICAgICAgICBpZiAoIXJldCkge1xcXFxuICAgICAgICAgICAgcmV0dXJuIHRydWVcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICByZXR1cm4gaGFzRG0ocmV0LnNwbGl0KCcjJylbMF0uc3BsaXQoJzsnKVswXSwgZG1VcmxzKVxcXFxuICAgIH1cXFxcbiAgICByZXR1cm4gaXNEbSh2aWRlb1VybClcXFxcbn1cXFxcblxcXFxuZnVuY3Rpb24gbGF6eVBhcnNlKHBsYXlVcmwsbXMsdG0scmVjaGFuZ2Upe1xcXFxuICAgIC8vIGxvZygn6LCD55So5LuT5bqT5YWN5ZeF5o6i5Lyg5Y+C6LaF5pe25Li6OicrbXMpO1xcXFxuICAgIHRtID0gcGFyc2VJbnQodG0pfHw1MDAwO1xcXFxuICAgIGNvbnN0IHtpc1ZpZGVvLGdldEhlYWRlcnMsaXNCYWRWaWRlb30gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9nbG9iYWxQYXJzZT9ydWxlPemBk+mVv+S7k+W6k1BybycpO1xcXFxuICAgIGxldCByZWFsVXJsID0gaXNWaWRlbyhwbGF5VXJsLHJlY2hhbmdlKTtcXFxcbiAgICAvL2xvZyhyZWFsVXJsKTtcXFxcbiAgICBpZih0eXBlb2YocmVhbFVybCk9PSdzdHJpbmcnKXsvL2Jvb2zlgLzlsLHmmK/lpLHotKVcXFxcbiAgICAgICAgdHJ5e1xcXFxuICAgICAgICAgICAgbGV0IHJ1cmw9cmVhbFVybC5zcGxpdChcXFxcXFxcIjtcXFxcXFxcIilbMF0uc3BsaXQoXFxcXFxcXCIjXFxcXFxcXCIpWzBdO1xcXFxuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmVxdWVzdChydXJsLHt0aW1lb3V0OnRtfSkpLnVybFxcXFxuICAgICAgICB9Y2F0Y2goZSl7XFxcXG4gICAgICAgICAgICByZXR1cm4gcmVhbFVybFxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIC8vcmV0dXJuIHJlYWxVcmxcXFxcbiAgICB9XFxcXG5cXFxcbiAgICAvL2xvZyhcXFxcXFxcIuiuv+mXrui2heaXtjpcXFxcXFxcIit0bSk7XFxcXG4gICAgbG9nKFxcXFxcXFwi5bCd6K+V6YGT6ZW/5LuT5bqTeDXlhY3ll4U6XFxcXFxcXCIrcGxheVVybCk7XFxcXG4gICAgY2xlYXJWYXIoXFxcXFxcXCJfeDVqeFVybFxcXFxcXFwiKTtcXFxcbiAgICBsZXQgYmFkPSQoXFxcXFxcXCLnvZHnu5zkuI3kvbPmiJbogIXnlpHkvLzlr7nmlrnnvZHnq5nmjILkuobvvIzkvaDopoHmn6XnnIvlhbbnvZHpobXlkJfvvJ9cXFxcXFxcIikuY29uZmlybSgocGxheVVybCk9PntcXFxcbiAgICAgICAgbG9nKFxcXFxcXFwi572R56uZ55yL6LW35p2l5oyC5LqGOlxcXFxcXFwiK3BsYXlVcmwpO1xcXFxuICAgICAgICByZXR1cm4gcGxheVVybFxcXFxuICAgIH0scGxheVVybCk7XFxcXG4gICAgdHJ5e1xcXFxuICAgICAgICB2YXIgYmFjaz1yZXF1ZXN0KHBsYXlVcmwse2hlYWRlcnM6IGdldEhlYWRlcnMocGxheVVybCksdGltZW91dDp0bX0pO1xcXFxuICAgICAgICAvL3ZhciBiYWNrPWZldGNoKHBsYXlVcmwse2hlYWRlcnM6IHsnVXNlci1BZ2VudCc6IFBDX1VBfX0pO1xcXFxuICAgICAgICBpZighYmFjayl7XFxcXG4gICAgICAgICAgICBsb2coXFxcXFxcXCLnvZHnq5lcXFxcXFxcIitwbGF5VXJsK1xcXFxcXFwi56Gu5a6e5ZWl5Lmf5rKh6L+U5ZueXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIGJhZFxcXFxuICAgICAgICB9ZWxzZSBpZigvI0VYVElORi8udGVzdChiYWNrKSl7XFxcXG4gICAgICAgICAgICAvL2xldCBsY2FjaGU9XFxcXFxcXCIvc3RvcmFnZS9lbXVsYXRlZC8wL0FuZHJvaWQvZGF0YS9jb20uZXhhbXBsZS5oaWtlcnZpZXcvZmlsZXMvRG9jdW1lbnRzL2NhY2hlL3ZpZGVvLm0zdThcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgIC8vd3JpdGVGaWxlKGxjYWNoZSxiYWNrKTtcXFxcbiAgICAgICAgICAgIC8vcmV0dXJuIGxjYWNoZStcXFxcXFxcIiMjXFxcXFxcXCIrcGxheVVybCtcXFxcXFxcIiNpc1ZpZGVvPXRydWUjXFxcXFxcXCJcXFxcbiAgICAgICAgICAgIHBsYXlVcmw9Y2FjaGVNM3U4KHBsYXlVcmwpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIHBsYXlVcmxcXFxcbiAgICAgICAgfWVsc2UgaWYoKCEv6Kem5Y+R5LqG6Ziy55uX6ZO+fOacquaOiOadg3zmjqXlj6PpmLLnm5cvLnRlc3QoYmFjaykpJiYoIS9odHRwfHVybC8udGVzdChiYWNrKSkmJighL21zZ3xjb2RlfGh0bWwvLnRlc3QoYmFjaykpKXtcXFxcbiAgICAgICAgICAgIGxvZyhiYWNrKTtcXFxcbiAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/nlpHkvLzlr7nmlrnmlbDmja7liqDlr4bkuobvvIzlhbfkvZPmlbDmja7nnIvml6Xlv5cnXFxcXG4gICAgICAgIH1cXFxcbiAgICB9Y2F0Y2goZSl7XFxcXG4gICAgICAgIGxvZyhlLm1lc3NhZ2UpO1xcXFxuICAgICAgICByZXR1cm4gYmFkXFxcXG4gICAgfVxcXFxuICAgIHRyeSB7XFxcXG4gICAgICAgIGJhY2s9SlNPTi5wYXJzZShiYWNrKTtcXFxcbiAgICAgICAgbGV0IHJlYWxVcmw9YmFjay51cmw7XFxcXG4gICAgICAgIGlmKHR5cGVvZihyZWFsVXJsKT09XFxcXFxcXCJ1bmRlZmluZWRcXFxcXFxcInx8IXJlYWxVcmwpe1xcXFxuICAgICAgICAgICAgbG9nKGJhY2spO1xcXFxuICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/pgZPplb/ku5PlupPop6PmnpDlpLHotKXvvIHov5Tlm57mkq3mlL7lnLDlnYDkuLrnqbpcXFxcXFxcIlxcXFxuICAgICAgICB9IGVsc2UgaWYodHlwZW9mKGlzVmlkZW8ocmVhbFVybCxyZWNoYW5nZSkpPT0nc3RyaW5nJyl7XFxcXG4gICAgICAgICAgICByZXR1cm4gaXNWaWRlbyhyZWFsVXJsLHJlY2hhbmdlKTtcXFxcbiAgICAgICAgfWVsc2V7XFxcXG4gICAgICAgICAgICByZXR1cm4gcmVhbFVybCtcXFxcXFxcIiNpc1ZpZGVvPXRydWUjXFxcXFxcXCI7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgLy9lbHNle1xcXFxuICAgICAgICAvL3JlYWxVcmwrPVxcXFxcXFwiO3tVc2VyLUFnZW50QE1vemlsbGEvNS4wfVxcXFxcXFwiO1xcXFxuICAgICAgICAvLyB9XFxcXG4gICAgfWNhdGNoIChlKSB7XFxcXG4gICAgICAgIGxvZyhcXFxcXFxcIuajgOa1i+WIsOino+aekOWPo+mdnmpzb27plJnor686XFxcXFxcXCIrZS5tZXNzYWdlKycs5byA5aeLeDXlhY3ll4XmjqInKTtcXFxcbiAgICAgICAgLy8gcmVxdWlyZSgnaHR0cHM6Ly9oamRobnguY29kaW5nLm5ldC9wL2hpa2VyL2QvZHIvZ2l0L3Jhdy9tYXN0ZXIvanMvbHNnLmpzJyk7Ly/lvJXnlKjmnKzlnLDlgqjlrZjmj5Lku7ZcXFxcbiAgICAgICAgY29uc3QgbHNnPSQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9sb2NhbFN0b3JhZ2U/cnVsZT3pgZPplb/ku5PlupNQcm9cXFxcXFxcIik7Ly/lvJXnlKjlrZDpobXpnaLmnKzlnLDlgqjlrZjmj5Lku7ZcXFxcbiAgICAgICAgbGV0IGxvY2FsX21zID0gbHNnLmdldEl0ZW0oJ3RpbWVvdXQnKTtcXFxcbiAgICAgICAgbGV0IG1zID0gcGFyc2VJbnQobXMpfHxwYXJzZUludChsb2NhbF9tcyl8fDUwMDA7XFxcXG4gICAgICAgIGxldCBtYXhfY291bnQ9TWF0aC5jZWlsKG1zLzI1MCk7XFxcXG4gICAgICAgIGxvZyhcXFxcXFxcIuacrOasoeWXheaOoui2heaXtjpcXFxcXFxcIittcytcXFxcXFxcIuWFseiuoeW+heaKk+WMhTpcXFxcXFxcIittYXhfY291bnQrXFxcXFxcXCLmrKFcXFxcXFxcIik7XFxcXG4gICAgICAgIHNob3dMb2FkaW5nKCfll4XmjqLkuK3vvIzoi6XlpLHotKXlsLHliIfmjaJ3ZWLll4XmjqIuLi4nKTtcXFxcbiAgICAgICAgbGV0IF94NSA9ICQudG9TdHJpbmcoKGlzVmlkZW8scmVjaGFuZ2UscGxheVVybCxtYXhfY291bnQsUENfVUEsaXNCYWRWaWRlbyk9PntcXFxcbiAgICAgICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICAgICAgaWYodHlwZW9mKGZiYSk9PSd1bmRlZmluZWQnfHwhZmJhKXtcXFxcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZiYSA9IGZ5X2JyaWRnZV9hcHA7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZihyZXF1ZXN0KT09J3VuZGVmaW5lZCd8fCFyZXF1ZXN0KXtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2YWwoZmJhLmdldEludGVybmFsSnMoKSk7XFxcXG4gICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICB9Y2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgZmJhLmxvZyhlLm1lc3NhZ2UpO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICBmYmEucHV0VmFyKFxcXFxcXFwiX3g1anhVcmxcXFxcXFxcIixwbGF5VXJsKTtcXFxcbiAgICAgICAgICAgICAgICBpZih3aW5kb3cuY291bnQgPT0gbnVsbCl7XFxcXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jb3VudD0xO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICBsZXQgdGV4dD0nJztcXFxcbiAgICAgICAgICAgICAgICB0cnkge1xcXFxuICAgICAgICAgICAgICAgICAgICB0ZXh0PWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXFxcXFxcXCJib2R5XFxcXFxcXCIpLmlubmVyVGV4dDtcXFxcbiAgICAgICAgICAgICAgICB9Y2F0Y2ggKGUpIHtmYmEubG9nKGUubWVzc2FnZSl9XFxcXG4gICAgICAgICAgICAgICAgaWYoL+inpuWPkeS6humYsuebl+mTvnzmnKrmjojmnYN85o6l5Y+j6Ziy55uXLy50ZXN0KHRleHQpJiZ3aW5kb3cuY291bnQ9PT0xKXtcXFxcbiAgICAgICAgICAgICAgICAgICAgZmJhLmxvZyhcXFxcXFxcIuajgOa1i+WIsOacieaOiOadg++8jOW8gOWni+i/h+aOiOadg1xcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgLy9sb2NhdGlvbi5yZWxvYWQoKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb24uaHJlZj1mYmEuZ2V0VmFyKFxcXFxcXFwiX3g1anhVcmxcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIHdpbmRvdy5jb3VudCsrO1xcXFxuICAgICAgICAgICAgICAgIC8vIGZiYS5sb2coJ2NvdW50Oicrd2luZG93LmNvdW50KycsbWF4X2NvdW50OicrbWF4X2NvdW50KTtcXFxcbiAgICAgICAgICAgICAgICBpZiggd2luZG93LmNvdW50ID49IG1heF9jb3VudCl7XFxcXG4gICAgICAgICAgICAgICAgICAgIGZiYS5sb2coXFxcXFxcXCLotoXov4dcXFxcXFxcIittYXhfY291bnQqMjUwK1xcXFxcXFwi5q+r56eS5pyq6I635Y+W5Yiw6LWE5rqQ5Zyw5Z2A77yM6Lez5Yiw5rqQ572R6aG1LOS7peS4i+aYr+WKoOi9vei/h+eahOWcsOWdgFxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0PWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXFxcXFxcXCJib2R5XFxcXFxcXCIpLmlubmVyVGV4dDtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZiYS5sb2codGV4dCk7XFxcXG4gICAgICAgICAgICAgICAgICAgIH1jYXRjaCAoZSkge2ZiYS5sb2coZS5tZXNzYWdlKX1cXFxcbiAgICAgICAgICAgICAgICAgICAgZmJhLmxvZyhKU09OLnN0cmluZ2lmeShfZ2V0VXJscygpKSk7XFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYmEuZ2V0VmFyKFxcXFxcXFwiX3g1anhVcmxcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG11dGVNZShlbGVtKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnBhdXNlKCk7XFxcXG4gICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICB2YXIgdmlkZW9zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcXFxcXFxcInZpZGVvXFxcXFxcXCIpLCBhdWRpb3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFxcXFxcXFwiYXVkaW9cXFxcXFxcIiksIHYyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcXFxcXFxcImVtYmVkXFxcXFxcXCIpLCB2MyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXFxcXFxcXCIjcGxheWVyXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIFtdLmZvckVhY2guY2FsbCh2aWRlb3MsIGZ1bmN0aW9uICh2aWRlbykge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgbXV0ZU1lKHZpZGVvKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cXFxcbiAgICAgICAgICAgICAgICB0cnkge1xcXFxuICAgICAgICAgICAgICAgICAgICBbXS5mb3JFYWNoLmNhbGwoYXVkaW9zLCBmdW5jdGlvbiAoYXVkaW8pIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGVNZShhdWRpbyk7XFxcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XFxcXG4gICAgICAgICAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgW10uZm9yRWFjaC5jYWxsKHYyLCBmdW5jdGlvbiAodikge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgbXV0ZU1lKHYpO1xcXFxuICAgICAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxcXFxuICAgICAgICAgICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIFtdLmZvckVhY2guY2FsbCh2MywgZnVuY3Rpb24gKHYpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGVNZSh2KTtcXFxcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cXFxcbiAgICAgICAgICAgICAgICB2YXIgdXJscyA9IF9nZXRVcmxzKCk7XFxcXG4gICAgICAgICAgICAgICAgLy8gZmJhLmxvZyhKU09OLnN0cmluZ2lmeSh1cmxzKSk7XFxcXG4gICAgICAgICAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpIGluIHVybHMpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB1PXVybHNbaV07XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnl7dT1kZWNvZGVVUklDb21wb25lbnQodSk7fWNhdGNoKGUpe1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHU9dW5lc2NhcGUodSk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoL3VybD1odHRwLy50ZXN0KHUpKXtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ID0gdS5zcGxpdChcXFxcXFxcInVybD1cXFxcXFxcIikuc2xpY2UoLTEpWzBdO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZiYS5sb2coXFxcXFxcXCJ1cmzliIblibI6XFxcXFxcXCIrdSk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZSBpZigvdXJsPVxcXFxcXFxcLy8udGVzdCh1KSYmL1xcXFxcXFxcLm0zdTgvLnRlc3QodSkpe1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBob3N0ID0gdS5tYXRjaCgvKC4qKVxcXFxcXFxcL1xcXFxcXFxcLyguKj8pXFxcXFxcXFwvLylbMF07XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdSA9IGhvc3QrdS5zcGxpdChcXFxcXFxcInVybD1cXFxcXFxcIikuc2xpY2UoLTEpWzBdO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZiYS5sb2coXFxcXFxcXCJ1cmzliIblibI6XFxcXFxcXCIrdSk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKC92aWQ9aHR0cC8udGVzdCh1KSl7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdSA9IHUuc3BsaXQoXFxcXFxcXCJ2aWQ9XFxcXFxcXCIpLnNsaWNlKC0xKVswXTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYmEubG9nKFxcXFxcXFwidmlk5YiG5YmyOlxcXFxcXFwiK3UpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2UgaWYoL3ZpZD1cXFxcXFxcXC8vLnRlc3QodSkmJi9cXFxcXFxcXC5tM3U4Ly50ZXN0KHUpKXtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaG9zdCA9IHUubWF0Y2goLyguKilcXFxcXFxcXC9cXFxcXFxcXC8oLio/KVxcXFxcXFxcLy8pWzBdO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUgPSBob3N0K3Uuc3BsaXQoXFxcXFxcXCJ2aWQ9XFxcXFxcXCIpLnNsaWNlKC0xKVswXTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYmEubG9nKFxcXFxcXFwidmlk5YiG5YmyOlxcXFxcXFwiK3UpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZigvXFxcXFxcXFw/KC4qKT1odHRwLy50ZXN0KHUpJiYvXFxcXFxcXFwubTN1OC8udGVzdCh1KSl7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdSA9IFxcXFxcXFwiaHR0cFxcXFxcXFwiK3Uuc3BsaXQoL1xcXFxcXFxcPyguKik9aHR0cC8pLnNsaWNlKC0xKVswXTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYmEubG9nKFxcXFxcXFwi5YW25LuW5YiG5YmyOlxcXFxcXFwiK3UpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy98aW5kZXhcXFxcXFxcXC5tM3U4JFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZigvXFxcXFxcXFwvMVxcXFxcXFxcLm0zdTgvLnRlc3QodSkpe1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdT11LnJlcGxhY2UoLyZmcm9tPS4qfCZuZXh0PS4qfCZqdW1wPS4qLywnJyk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVhbFVybCA9IGlzVmlkZW8odSxyZWNoYW5nZSk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2YocmVhbFVybCk9PSdzdHJpbmcnJiYhaXNCYWRWaWRlbyh1KSl7Ly/ov4fmu6TlkIrmr5vop4bpopFcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2Z5X2JyaWRnZV9hcHAuc2V0V2ViVWEoUENfVUEpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZihmYmEuZ2V0SGVhZGVyVXJsKSE9PSd1bmRlZmluZWQnJiZ0eXBlb2YocmVjaGFuZ2UpIT09J2Z1bmN0aW9uJyl7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxldCBiYWNrVXJsID0gZmJhLmdldEhlYWRlclVybCh1LnJlcGxhY2UoXFxcXFxcXCI7e1xcXFxcXFwiLFxcXFxcXFwiI2lzVmlkZW89dHJ1ZSM7e1xcXFxcXFwiKSk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBiYWNrVXJsID0gZmJhLmdldEhlYWRlclVybCh1cmxzW2ldKS5yZXBsYWNlKCc7eycsJyNpZ25vcmVJbWc9dHJ1ZSMjaXNWaWRlbz10cnVlIzt7Jyk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB1MSA9IGJhY2tVcmwuc3BsaXQoJyNpZ25vcmVJbWcnKVswXTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHUyID0gJyNpZ25vcmVJbWcnK2JhY2tVcmwuc3BsaXQoJyNpZ25vcmVJbWcnKVsxXTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdTEgPSB1MS5yZXBsYWNlKC8mZnJvbT0uKnwmbmV4dD0uKnwmanVtcD0uKi8sJycpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZigvdXJsPWh0dHAvLnRlc3QodTEpKXtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUxID0gdTEuc3BsaXQoXFxcXFxcXCJ1cmw9XFxcXFxcXCIpLnNsaWNlKC0xKVswXTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2UgaWYoL3VybD1cXFxcXFxcXC8vLnRlc3QodTEpJiYvXFxcXFxcXFwubTN1OC8udGVzdCh1MSkpe1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGhvc3QxID0gdTEubWF0Y2goLyguKilcXFxcXFxcXC9cXFxcXFxcXC8oLio/KVxcXFxcXFxcLy8pWzBdO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdTEgPSBob3N0MSt1MS5zcGxpdChcXFxcXFxcInVybD1cXFxcXFxcIikuc2xpY2UoLTEpWzBdO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmJhLmxvZyhcXFxcXFxcInVybOWIhuWJsjpcXFxcXFxcIit1KTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKC92aWQ9aHR0cC8udGVzdCh1MSkpe1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdTEgPSB1MS5zcGxpdChcXFxcXFxcInZpZD1cXFxcXFxcIikuc2xpY2UoLTEpWzBdO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZSBpZigvdmlkPVxcXFxcXFxcLy8udGVzdCh1MSkmJi9cXFxcXFxcXC5tM3U4Ly50ZXN0KHUxKSl7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaG9zdDEgPSB1MS5tYXRjaCgvKC4qKVxcXFxcXFxcL1xcXFxcXFxcLyguKj8pXFxcXFxcXFwvLylbMF07XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1MSA9IGhvc3QxK3UxLnNwbGl0KFxcXFxcXFwidmlkPVxcXFxcXFwiKS5zbGljZSgtMSlbMF07XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZigvXFxcXFxcXFw/KC4qKT1odHRwLy50ZXN0KHUxKSYmL1xcXFxcXFxcLm0zdTgvLnRlc3QodTEpKXtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUxID0gXFxcXFxcXCJodHRwXFxcXFxcXCIrdTEuc3BsaXQoL1xcXFxcXFxcPyguKik9aHR0cC8pLnNsaWNlKC0xKVswXTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrVXJsID0gdTEgKyB1MjtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmJhLmxvZygn6L+U5Zue6Ieq5Yqo5YqgY29va2ll6ZO+5o6lOicrYmFja1VybCk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZiYS5sb2coJ+i/lOWbnumTvuaOpTonK3UrJ+W5tuiHquWKqOWKoOS6hmNvb2tpZSzlhbfkvZNjb29raWXlnKjop4bpopHmkq3mlL7lpITmn6XnnIsnKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhY2tVcmw7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZiYS5sb2coXFxcXFxcXCLov5Tlm57ku5PlupN4NeWFjeWXhee7k+aenDpcXFxcXFxcIityZWFsVXJsKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWxVcmxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICB9Y2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgZmJhLmxvZyhlLm1lc3NhZ2UpXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfWNhdGNoIChlKSB7XFxcXG4gICAgICAgICAgICAgICAgLy8gZnlfYnJpZGdlX2FwcC5sb2coJ3g15aSn6IyD5Zu06ZSZ6K+vOicrZS5tZXNzYWdlKTtcXFxcbiAgICAgICAgICAgICAgICBhbGVydCgneDXlpKfojIPlm7TplJnor686JytlLm1lc3NhZ2UpO1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/miqXplJnnu5PmnZ94NSdcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSxpc1ZpZGVvLHJlY2hhbmdlLHBsYXlVcmwsbWF4X2NvdW50LFBDX1VBLGlzQmFkVmlkZW8pO1xcXFxuICAgICAgICBsZXQgdXNlV2ViPWxzZy5nZXRJdGVtKFxcXFxcXFwi6YCa5YWNXFxcXFxcXCIsXFxcXFxcXCJYNVxcXFxcXFwiKT09PVxcXFxcXFwiV0VCXFxcXFxcXCI7XFxcXG4gICAgICAgIC8vbG9nKFxcXFxcXFwi5LuT5bqT5L2/55Sod2Vi6YCa5YWN5pu/5LujeDU6XFxcXFxcXCIrdXNlV2ViKTtcXFxcbiAgICAgICAgbGV0IHJ1bGVIZWFkPXVzZVdlYiYmcGFyc2VJbnQoZ2V0QXBwVmVyc2lvbigpKT49MjMzOT9cXFxcXFxcIndlYlJ1bGU6Ly9cXFxcXFxcIjpcXFxcXFxcIng1UnVsZTovL1xcXFxcXFwiO1xcXFxuICAgICAgICBsZXQgeDVVcmwgPSBydWxlSGVhZCtwbGF5VXJsKyAnQCcgK194NTtcXFxcbiAgICAgICAgcmV0dXJuIHg1VXJsXFxcXG4gICAgfVxcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiB4NVBhcnNlUHJvKHg1bGlzdCx4NVRpbWVvdXQsaXNWaWRlbyl7XFxcXG4gICAgbGV0IGJwYXRoID0gJ2ZpbGU6Ly8vc3RvcmFnZS9lbXVsYXRlZC8wL0FuZHJvaWQvZGF0YS9jb20uZXhhbXBsZS5oaWtlcnZpZXcvZmlsZXMvRG9jdW1lbnRzL3J1bGVzL2R6SG91c2UvaHRtbC/mtbfpmJTll4XmjqLlmaguaHRtbCc7XFxcXG4gICAgbGV0IGJjb2RlID0gZmV0Y2goYnBhdGgpO1xcXFxuICAgIGlmKCFiY29kZXx8IS9meV9icmlkZ2VfYXBwLy50ZXN0KGJjb2RlKSl7XFxcXG4gICAgICAgIGxvZygn5pys5Zyw5pyq5a6J6KOF5ZeF5o6i5Zmo77yM5byA5aeL5a6J6KOFJyk7XFxcXG4gICAgICAgIGNvbnN0IHthcGl9ID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3V0aWxpeT9ydWxlPemBk+mVv+S7k+W6k1Byb1xcXFxcXFwiKTtcXFxcbiAgICAgICAgbGV0IGh0bWwgPSBmZXRjaChhcGkuaG9zdCsnL3J1bGVsaXN0Lmpzb24/aWQ9MjA1NScpO1xcXFxuICAgICAgICBpZigv5rW36ZiU6KeG55WMLy50ZXN0KGh0bWwpKXtcXFxcbiAgICAgICAgICAgIHdyaXRlRmlsZShicGF0aCxodG1sKTtcXFxcbiAgICAgICAgfWVsc2V7XFxcXG4gICAgICAgICAgICB3cml0ZUZpbGUoYnBhdGgsZmV0Y2goJ2h0dHBzOi8vaGpkaG54LmNvZGluZy5uZXQvcC9oaWtlci9kL2RyL2dpdC9yYXcvbWFzdGVyL2h0bWwvZ2V0VmlkZW8uaHRtbCcpKVxcXFxuICAgICAgICB9XFxcXG4gICAgfVxcXFxuICAgIHg1VGltZW91dCA9IHBhcnNlSW50KHg1VGltZW91dCl8fDUwMDA7XFxcXG4gICAgbGV0IG1heF9jb3VudD0oeDVUaW1lb3V0LzI1MCk7IC8v5qC55o2u6LaF5pe26Ieq5Yqo6K6h566X5LqG5Y+v5omn6KGM55qE5qyh5pWwXFxcXG4gICAgcHV0VmFyKCd4NUxpc3QnLEpTT04uc3RyaW5naWZ5KHg1bGlzdCkpO1xcXFxuICAgIGxldCBfeDUgPSAkLnRvU3RyaW5nKChpc1ZpZGVvLCBtYXhfY291bnQseDVUaW1lb3V0LGlzQmFkVmlkZW8pID0+IHtcXFxcbiAgICAgICAgLy/liJ3lp4vljJZmYmHlkoxyZXF1c3RcXFxcbiAgICAgICAgaWYgKHR5cGVvZiAoZmJhKSA9PSAndW5kZWZpbmVkJyB8fCAhZmJhKSB7XFxcXG4gICAgICAgICAgICB2YXIgZmJhID0gZnlfYnJpZGdlX2FwcDtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICB0cnkge1xcXFxuICAgICAgICAgICAgaWYgKHR5cGVvZiAocmVxdWVzdCkgPT0gJ3VuZGVmaW5lZCcgfHwgIXJlcXVlc3QpIHtcXFxcbiAgICAgICAgICAgICAgICBldmFsKGZiYS5nZXRJbnRlcm5hbEpzKCkpO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9IGNhdGNoIChlKSB7XFxcXG4gICAgICAgICAgICBmYmEubG9nKGUubWVzc2FnZSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS1cXFxcbiAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICAgIGlmICh3aW5kb3cuY291bnQgPT0gbnVsbCkge1xcXFxuICAgICAgICAgICAgICAgIHdpbmRvdy5jb3VudCA9IDE7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICBsZXQgdGV4dD0nJztcXFxcbiAgICAgICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICAgICAgdGV4dD1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxcXFxcXFwiYm9keVxcXFxcXFwiKS5pbm5lclRleHQ7XFxcXG4gICAgICAgICAgICB9Y2F0Y2ggKGUpIHtmYmEubG9nKGUubWVzc2FnZSl9XFxcXG4gICAgICAgICAgICBpZigv6Kem5Y+R5LqG6Ziy55uX6ZO+fOacquaOiOadg3zmjqXlj6PpmLLnm5cvLnRlc3QodGV4dCkmJndpbmRvdy5jb3VudD09MSl7XFxcXG4gICAgICAgICAgICAgICAgbG9jYXRpb24ucmVsb2FkKCk7XFxcXG4gICAgICAgICAgICAgICAgZmJhLmxvZyhcXFxcXFxcIuajgOa1i+WIsOacieaOiOadg++8jOW8gOWni+i/h+aOiOadg1xcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIHdpbmRvdy5jb3VudCsrO1xcXFxuICAgICAgICAgICAgLy8gZmJhLmxvZygnY291bnQ6JyArIHdpbmRvdy5jb3VudCArICcsbWF4X2NvdW50OicgKyBtYXhfY291bnQpO1xcXFxuICAgICAgICAgICAgaWYgKHdpbmRvdy5jb3VudCA+PSBtYXhfY291bnQpIHtcXFxcbiAgICAgICAgICAgICAgICBmYmEuY2xlYXJWYXIoJ3g1TGlzdCcpO1xcXFxuICAgICAgICAgICAgICAgIGZiYS5oaWRlTG9hZGluZygpO1xcXFxuICAgICAgICAgICAgICAgIGxldCBmbXNnID0gJ+mBk+mVv+S7k+W6k+mAmuWFjeino+aekOWksei0pSzljp/lm6A66LaF5pe2Jyt4NVRpbWVvdXQrJ+avq+enkic7XFxcXG4gICAgICAgICAgICAgICAgZmJhLmxvZyhmbXNnKTtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8vJytmbXNnO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9Y2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICAgIGZiYS5sb2coZS5tZXNzYWdlKTtcXFxcbiAgICAgICAgfVxcXFxuXFxcXG4gICAgICAgIGZ1bmN0aW9uIG11dGVNZShlbGVtKSB7XFxcXG4gICAgICAgICAgICB0cnkge1xcXFxuICAgICAgICAgICAgICAgIGVsZW0ucGF1c2UoKTtcXFxcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfVxcXFxuXFxcXG4gICAgICAgIHZhciB2aWRlb3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFxcXFxcXFwidmlkZW9cXFxcXFxcIiksIGF1ZGlvcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXFxcXFxcXCJhdWRpb1xcXFxcXFwiKSxcXFxcbiAgICAgICAgICAgIHYyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcXFxcXFxcImVtYmVkXFxcXFxcXCIpLCB2MyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXFxcXFxcXCIjcGxheWVyXFxcXFxcXCIpO1xcXFxuICAgICAgICB0cnkge1xcXFxuICAgICAgICAgICAgW10uZm9yRWFjaC5jYWxsKHZpZGVvcywgZnVuY3Rpb24gKHZpZGVvKSB7XFxcXG4gICAgICAgICAgICAgICAgbXV0ZU1lKHZpZGVvKTtcXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICB9IGNhdGNoIChlKSB7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICAgIFtdLmZvckVhY2guY2FsbChhdWRpb3MsIGZ1bmN0aW9uIChhdWRpbykge1xcXFxuICAgICAgICAgICAgICAgIG11dGVNZShhdWRpbyk7XFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICBbXS5mb3JFYWNoLmNhbGwodjIsIGZ1bmN0aW9uICh2KSB7XFxcXG4gICAgICAgICAgICAgICAgbXV0ZU1lKHYpO1xcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICB0cnkge1xcXFxuICAgICAgICAgICAgW10uZm9yRWFjaC5jYWxsKHYzLCBmdW5jdGlvbiAodikge1xcXFxuICAgICAgICAgICAgICAgIG11dGVNZSh2KTtcXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICB9IGNhdGNoIChlKSB7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgdmFyIHVybHMgPSBfZ2V0VXJscygpO1xcXFxuICAgICAgICB0cnkge1xcXFxuICAgICAgICAgICAgZm9yIChsZXQgaSBpbiB1cmxzKSB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHU9dXJsc1tpXTtcXFxcbiAgICAgICAgICAgICAgICAvL3U9ZGVjb2RlVVJJQ29tcG9uZW50KHUpO1xcXFxuICAgICAgICAgICAgICAgIHRyeXt1PWRlY29kZVVSSUNvbXBvbmVudCh1KTt9Y2F0Y2goZSl7XFxcXG4gICAgICAgICAgICAgICAgICAgIHU9dW5lc2NhcGUodSk7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIGlmKC91cmw9aHR0cC8udGVzdCh1KSl7XFxcXG4gICAgICAgICAgICAgICAgICAgIHUgPSB1LnNwbGl0KFxcXFxcXFwidXJsPVxcXFxcXFwiKS5zbGljZSgtMSlbMF07XFxcXG4gICAgICAgICAgICAgICAgfWVsc2UgaWYoL3ZpZD1odHRwLy50ZXN0KHUpKXtcXFxcbiAgICAgICAgICAgICAgICAgICAgdSA9IHUuc3BsaXQoXFxcXFxcXCJ2aWQ9XFxcXFxcXCIpLnNsaWNlKC0xKVswXTtcXFxcbiAgICAgICAgICAgICAgICB9ZWxzZSBpZigvXFxcXFxcXFw/KC4qKT1odHRwLy50ZXN0KHUpKXtcXFxcbiAgICAgICAgICAgICAgICAgICAgdSA9IFxcXFxcXFwiaHR0cFxcXFxcXFwiK3Uuc3BsaXQoL1xcXFxcXFxcPyguKik9aHR0cC8pLnNsaWNlKC0xKVswXTtcXFxcbiAgICAgICAgICAgICAgICAgICAgLy9mYmEubG9nKFxcXFxcXFwi5YW25LuW5YiG5YmyOlxcXFxcXFwiK3UpO1xcXFxuICAgICAgICAgICAgICAgIH1lbHNlIGlmKC9cXFxcXFxcXC8xXFxcXFxcXFwubTN1OCQvLnRlc3QodSkpe1xcXFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgdT11LnJlcGxhY2UoLyZmcm9tPS4qfCZuZXh0PS4qfCZqdW1wPS4qLywnJyk7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHJlYWxVcmwgPSBpc1ZpZGVvKHUpO1xcXFxuICAgICAgICAgICAgICAgIGlmIChyZWFsVXJsJiYhaXNCYWRWaWRlbyh1KSkgey8v6L+H5ruk5ZCK5q+bXFxcXG4gICAgICAgICAgICAgICAgICAgIGZiYS5sb2coXFxcXFxcXCLku5PlupN4NeWFjeWXhee7k+aenDpcXFxcXFxcIiArIHJlYWxVcmwpO1xcXFxuICAgICAgICAgICAgICAgICAgICBmYmEuY2xlYXJWYXIoJ3g1TGlzdCcpO1xcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhbFVybFxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcXFxuICAgICAgICAgICAgZmJhLmxvZyhlLm1lc3NhZ2UpXFxcXG4gICAgICAgIH1cXFxcbiAgICB9LCBpc1ZpZGVvLCBtYXhfY291bnQseDVUaW1lb3V0LGlzQmFkVmlkZW8pO1xcXFxuICAgIGNvbnN0IGxzZz0kLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvbG9jYWxTdG9yYWdlP3J1bGU96YGT6ZW/5LuT5bqTUHJvXFxcXFxcXCIpO1xcXFxuICAgIGxldCB1c2VXZWI9bHNnLmdldEl0ZW0oXFxcXFxcXCLpgJrlhY1cXFxcXFxcIixcXFxcXFxcIlg1XFxcXFxcXCIpPT09XFxcXFxcXCJXRUJcXFxcXFxcIjtcXFxcbiAgICAvL2xvZyhcXFxcXFxcIuS7k+W6k+S9v+eUqHdlYumAmuWFjeabv+S7o3g1OlxcXFxcXFwiK3VzZVdlYik7XFxcXG4gICAgbGV0IHJ1bGVIZWFkPXVzZVdlYiYmcGFyc2VJbnQoZ2V0QXBwVmVyc2lvbigpKT49MjMzOT9cXFxcXFxcIndlYlJ1bGU6Ly9cXFxcXFxcIjpcXFxcXFxcIng1UnVsZTovL1xcXFxcXFwiO1xcXFxuICAgIHJldHVybiBydWxlSGVhZCticGF0aCsnQCcgKyBfeDU7XFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIExhenlQYXJzZUZhc3QocGxheVVybExpc3QsZ2V0VGltZW91dCx4NVRpbWVvdXQpe1xcXFxuICAgIGNvbnN0IHtpc1ZpZGVvLGdldEhlYWRlcnMseDVQYXJzZVByb30gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9nbG9iYWxQYXJzZT9ydWxlPemBk+mVv+S7k+W6k1BybycpO1xcXFxuICAgIC8vIGxvZygn5byA5aeL5omn6KGMJytwbGF5VXJsTGlzdC5sZW5ndGgrJ+S4quWcsOWdgOeahOaJuemHj+WXheaOojonK3BsYXlVcmxMaXN0KTtcXFxcbiAgICBsb2coJ+W8gOWni+aJp+ihjCcrcGxheVVybExpc3QubGVuZ3RoKyfkuKrlnLDlnYDnmoTmibnph4/ll4XmjqInKTtcXFxcbiAgICBsZXQgcGxheVVybHMgPSBwbGF5VXJsTGlzdC5tYXAoKGl0KT0+e1xcXFxuICAgICAgICByZXR1cm4ge1xcXFxuICAgICAgICAgICAgdXJsOml0LnNwbGl0KFxcXFxcXFwiO1xcXFxcXFwiKVswXSxcXFxcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcXFxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIC8vXFxcXFxcXCJVc2VyLUFnZW50XFxcXFxcXCI6IFxcXFxcXFwiRGFydC8yLjEzIChkYXJ0OmlvKVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICBcXFxcXFxcIlVzZXItQWdlbnRcXFxcXFxcIjpcXFxcXFxcIk1vemlsbGEvNS4wXFxcXFxcXCJcXFxcbiAgICAgICAgICAgICAgICB9LFxcXFxuICAgICAgICAgICAgICAgIHRpbWVvdXQ6IGdldFRpbWVvdXRcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfVxcXFxuICAgIH0pO1xcXFxuICAgIGxldCBiaHRtbCA9IGJhdGNoRmV0Y2gocGxheVVybHMpO1xcXFxuICAgIGxldCB2aWRlb3MgPSBbXTtcXFxcbiAgICBsZXQgeDVsaXN0ID0gW107XFxcXG4gICAgZm9yKGxldCBpIGluIGJodG1sKXtcXFxcbiAgICAgICAgbGV0IG9yZGVyID0gcGFyc2VJbnQoaSkrMTtcXFxcbiAgICAgICAgbGV0IHRuYW1lPW9yZGVyKyflj7fop6PmnpDnvZHlnYA6JztcXFxcbiAgICAgICAgLy9sb2codG5hbWUpO1xcXFxuICAgICAgICBsZXQgdHVybD1wbGF5VXJsTGlzdFtpXS5zcGxpdChcXFxcXFxcIjtcXFxcXFxcIilbMF07XFxcXG4gICAgICAgIGxldCBqbmFtZT1wbGF5VXJsTGlzdFtpXS5zcGxpdChcXFxcXFxcIjtcXFxcXFxcIikubGVuZ3RoPjE/cGxheVVybExpc3RbaV0uc3BsaXQoXFxcXFxcXCI7XFxcXFxcXCIpWzFdOlxcXFxcXFwiXFxcXFxcXCI7XFxcXG4gICAgICAgIHRuYW1lKz1qbmFtZTtcXFxcbiAgICAgICAgbGV0IGJhY2tjb2RlID0gYmh0bWxbaV07XFxcXG4gICAgICAgIGlmKCghL3VybHxodHRwLy50ZXN0KGJhY2tjb2RlKSkmJighLyNFWFRJTkYvLnRlc3QoYmFja2NvZGUpKSl7XFxcXG4gICAgICAgICAgICBsb2codG5hbWUrdHVybCsn5pyJ6Zeu6aKYLOWPr+iDveWKoOWvhuaIluiAheaMguS6hicpO1xcXFxuICAgICAgICAgICAgY29udGludWU7XFxcXG4gICAgICAgIH1lbHNlIGlmKC8jRVhUSU5GLy50ZXN0KGJhY2tjb2RlKSl7XFxcXG4gICAgICAgICAgICAvL2xldCBsY2FjaGU9XFxcXFxcXCIvc3RvcmFnZS9lbXVsYXRlZC8wL0FuZHJvaWQvZGF0YS9jb20uZXhhbXBsZS5oaWtlcnZpZXcvZmlsZXMvRG9jdW1lbnRzL2NhY2hlL3ZpZGVvX1xcXFxcXFwiK3RuYW1lK1xcXFxcXFwiLm0zdThcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgIC8vd3JpdGVGaWxlKGxjYWNoZSxiYWNrY29kZSk7XFxcXG4gICAgICAgICAgICAvL3ZpZGVvcy5wdXNoKGxjYWNoZSk7XFxcXG4gICAgICAgICAgICBsZXQgcFVybD1jYWNoZU0zdTgodHVybCk7XFxcXG4gICAgICAgICAgICB2aWRlb3MucHVzaChwVXJsKTtcXFxcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICBsZXQgdXJsID0gSlNPTi5wYXJzZShiYWNrY29kZSkudXJsO1xcXFxuICAgICAgICAgICAgaWYoL15odHRwLy50ZXN0KHVybCkpe1xcXFxuICAgICAgICAgICAgICAgIGxldCByZWFsVmlkZW8gPSBpc1ZpZGVvKHVybCk7XFxcXG4gICAgICAgICAgICAgICAgaWYodHlwZW9mKHJlYWxWaWRlbyk9PSdzdHJpbmcnKXtcXFxcbiAgICAgICAgICAgICAgICAgICAgbG9nKHRuYW1lKyflt7Lop6PmnpDlh7rop4bpopE6JytyZWFsVmlkZW8pO1xcXFxuICAgICAgICAgICAgICAgICAgICBpZihqbmFtZSl7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFsVmlkZW8rPVxcXFxcXFwi4piFXFxcXFxcXCIram5hbWVcXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICB2aWRlb3MucHVzaChyZWFsVmlkZW8pO1xcXFxuICAgICAgICAgICAgICAgIH1lbHNle1xcXFxuICAgICAgICAgICAgICAgICAgICBsb2codG5hbWUrJ+ino+aekOWHuuS4jeefpemBk+S7gOS5iOS4nOilvzonK3VybCk7XFxcXG4gICAgICAgICAgICAgICAgICAgIHVybCs9XFxcXFxcXCIjaXNWaWRlbz10cnVlI1xcXFxcXFwiO1xcXFxuICAgICAgICAgICAgICAgICAgICBpZihqbmFtZSl7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwrPVxcXFxcXFwi4piFXFxcXFxcXCIram5hbWVcXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICB2aWRlb3MucHVzaCh1cmwpO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH1lbHNle1xcXFxuICAgICAgICAgICAgICAgIGxvZyh0bmFtZSsn5Li6anNvbuaOpeWPo+S4lOaXoOi/lOWbnuinhumikeWcsOWdgOaVsOaNrjonK3BsYXlVcmxMaXN0W2ldKydcXFxcXFxcXG4nK2JhY2tjb2RlKTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfWNhdGNoIChlKSB7XFxcXG4gICAgICAgICAgICBsb2codG5hbWUrJ+S4ung15o6l5Y+jLOWKoOWFpXg15ZeF5o6i5YiX6KGoJyk7XFxcXG4gICAgICAgICAgICB4NWxpc3QucHVzaChwbGF5VXJsTGlzdFtpXSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9XFxcXG4gICAgLy8gbG9nKHZpZGVvcyk7XFxcXG4gICAgaWYodmlkZW9zLmxlbmd0aD4wKXtcXFxcbiAgICAgICAgaWYoZ2V0VmFyKCdkcC5jYWNoZVZpZGVvJywndHJ1ZScpPT09J3RydWUnJiZwYXJzZUludChnZXRBcHBWZXJzaW9uKCkpPj0yMjU1KVxcXFxuICAgICAgICB7XFxcXG4gICAgICAgICAgICBsb2coXFxcXFxcXCLlsIrmlaznmoTprZTmlq3nlKjmiLfvvIzop4bpopHnvJPlrZjlt7LlkK/nlKjvvIzor7flsL3mg4Xkuqvlj5fnnIvliafml7blhYlcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICBsZXQgdmlkZW9zQ2FjaGU9dmlkZW9zLm1hcCgoaXQpPT57XFxcXG4gICAgICAgICAgICAgICAgbGV0IGhlYWRlcnM9e307XFxcXG4gICAgICAgICAgICAgICAgaWYoaXQuc3BsaXQoXFxcXFxcXCI7XFxcXFxcXCIpLmxlbmd0aD4xKXtcXFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGhlYWQgPSBpdC5zcGxpdCgnOycpWzFdO1xcXFxuICAgICAgICAgICAgICAgICAgICBpZigvQC8udGVzdChoZWFkKSYmL3t8fS8udGVzdChoZWFkKSl7XFxcXG4vL2hlYWQgPSBoZWFkLnJlcGxhY2UoL3t8fS9nLCcnKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWQgPSBoZWFkLnNwbGl0KFxcXFxcXFwie1xcXFxcXFwiKVsxXS5zcGxpdChcXFxcXFxcIn1cXFxcXFxcIilbMF07XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkID0gaGVhZC5zcGxpdCgnJiYnKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSBpbiBoZWFkKXtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQga2V5ID0gaGVhZFtpXS5zcGxpdCgnQCcpWzBdO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9aGVhZFtpXS5zcGxpdCgnQCcpWzFdLnJlcGxhY2UoLzsvLCfvvJvvvJsnKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW2tleV0gPSB2YWx1ZTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xcXFxuICAgICAgICAgICAgICAgICAgICB1cmw6aXQuc3BsaXQoXFxcXFxcXCI7XFxcXFxcXCIpWzBdLnNwbGl0KFxcXFxcXFwi4piFXFxcXFxcXCIpWzBdLFxcXFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOntcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6aGVhZGVyc1xcXFxuICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICB2YXIgZGF0YT1iYXRjaENhY2hlTTN1OCh2aWRlb3NDYWNoZSk7XFxcXG4gICAgICAgICAgICBkYXRhPWRhdGEubWFwKChpdCxpZCk9PntcXFxcbiAgICAgICAgICAgICAgICBsZXQgZXh0cmE9XFxcXFxcXCJcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgICAgICBpZih2aWRlb3NbaWRdLnNwbGl0KFxcXFxcXFwiO1xcXFxcXFwiKS5sZW5ndGg+MSl7XFxcXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhPVxcXFxcXFwiO1xcXFxcXFwiK3ZpZGVvc1tpZF0uc3BsaXQoXFxcXFxcXCI7XFxcXFxcXCIpWzFdO1xcXFxuICAgICAgICAgICAgICAgIH1lbHNlIGlmKHZpZGVvc1tpZF0uc3BsaXQoXFxcXFxcXCLimIVcXFxcXFxcIikubGVuZ3RoPjEpe1xcXFxuICAgICAgICAgICAgICAgICAgICBleHRyYT1cXFxcXFxcIuKYhVxcXFxcXFwiK3ZpZGVvc1tpZF0uc3BsaXQoXFxcXFxcXCLimIVcXFxcXFxcIilbMV07XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuXFxcXG4gICAgICAgICAgICAgICAgaWYoaXQrXFxcXFxcXCJcXFxcXFxcIiE9XFxcXFxcXCJudWxsXFxcXFxcXCIpe1xcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXQrZXh0cmFcXFxcbiAgICAgICAgICAgICAgICB9ZWxzZXtcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpZGVvc1tpZF1cXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgIC8vbG9nKGRhdGEpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIGRhdGFcXFxcbiAgICAgICAgICAgIC8vcmV0dXJuIHZpZGVvc1xcXFxuICAgICAgICB9ZWxzZXtcXFxcbiAgICAgICAgICAgIHJldHVybiB2aWRlb3NcXFxcbiAgICAgICAgfVxcXFxuICAgIH1cXFxcbiAgICBsb2coJ+WFseaciScreDVsaXN0Lmxlbmd0aCsn5LiqeDXlnLDlnYDov5vooYzova7mtYHll4XmjqInKTtcXFxcbiAgICAvL+ayoeacieeahOivneWwseW8gOWni+S+neasoXg15ZeF5o6iXFxcXG4gICAgc2hvd0xvYWRpbmcoJ+WXheaOouS4re+8jOiLpeWksei0peWwseWIh+aNondlYuWXheaOoi4uLicpO1xcXFxuICAgIHJldHVybiB4NVBhcnNlUHJvKHg1bGlzdCx4NVRpbWVvdXQsaXNWaWRlbyk7XFxcXG59XFxcXG52YXIgbGF6eT0kKCcnKS5sYXp5UnVsZSgoKT0+e1xcXFxuICAgIHRyeXtcXFxcbiAgICAgICAgcmVhbFVybD1pbnB1dDtcXFxcbiAgICAgICAgZXZhbChcXFxcXFxcInZhciBjb25maWdfZHAgPVxcXFxcXFwiICsgZmV0Y2goXFxcXFxcXCJoaWtlcjovL2ZpbGVzL2NhY2hlL015UGFyc2VTZXQuanNvblxcXFxcXFwiKSk7XFxcXG4gICAgICAgIGV2YWwoZmV0Y2goY29uZmlnX2RwLmNqKSk7XFxcXG4gICAgICAgIGxvZyhpbnB1dCsnLT7mraPlnKjmlq3mj5LprZTmlLnniYjop6PmnpAuLi4nKTtcXFxcbiAgICAgICAgLy8g5Yqg5YWl6LaF5pe26K6+572u77yM5bu66K6u5Zyo6aaW6aG16K6+572uXFxcXG4gICAgICAgIHJldHVybiBheXRtUGFyc2UocmVhbFVybClcXFxcbiAgICB9Y2F0Y2goZSl7XFxcXG4gICAgICAgIHJldHVybiBpbnB1dFxcXFxuICAgIH1cXFxcbn0pO1xcXFxuJC5leHBvcnRzLmlzUGljPWlzUGljO1xcXFxuJC5leHBvcnRzLmlzVmlkZW89aXNWaWRlbztcXFxcbiQuZXhwb3J0cy5pc0JhZFZpZGVvPWlzQmFkVmlkZW87XFxcXG4kLmV4cG9ydHMuY29tUGFyc2U9Y29tUGFyc2U7XFxcXG4kLmV4cG9ydHMuZ2V0SGVhZGVycz1nZXRIZWFkZXJzO1xcXFxuJC5leHBvcnRzLmxhenlQYXJzZT1sYXp5UGFyc2U7XFxcXG4kLmV4cG9ydHMueDVQYXJzZVBybz14NVBhcnNlUHJvO1xcXFxuJC5leHBvcnRzLkxhenlQYXJzZUZhc3Q9TGF6eVBhcnNlRmFzdDtcXFxcbiQuZXhwb3J0cy5sYXp5PWxhenk7XFxcIn0se1xcXCJuYW1lXFxcIjpcXFwi5Lu75Yqh5LuT5bqT5o6l5Y+jXFxcIixcXFwicGF0aFxcXCI6XFxcInRhc2tDYWxsXFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxuU3RyaW5nLnByb3RvdHlwZS5zdHJpcCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucmVwbGFjZSgvKF5cXFxcXFxcXHMqKXwoXFxcXFxcXFxzKiQpL2csIFxcXFxcXFwiXFxcXFxcXCIpOyB9O1xcXFxuZnVuY3Rpb24gdGFza19yZXEodGFza19hcGksdGFzaykgeyAvLyDpgJrnlKjlj5HpgIHku5PlupNwb3N06LCD55So5Lu75Yqh6K+35rGCXFxcXG4gICAgY29uc3Qge2dldEZpbGV9ID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3V0aWxpeT9ydWxlPemBk+mVv+S7k+W6k1Byb1xcXFxcXFwiKTtcXFxcbiAgICBsZXQgaG91c2VGaWxlID0gZ2V0RmlsZXx8ZmFsc2U7XFxcXG4gICAgaWYoIWhvdXNlRmlsZSl7XFxcXG4gICAgICAgIHNldEl0ZW0oJ2lzX2hvdXNlX3ZpcCcsICdmYWxzZScpO1xcXFxuICAgIH1cXFxcbiAgICBsZXQgaG91c2VfZGF0YSA9IGhvdXNlRmlsZSgpO1xcXFxuICAgIGxldCByZXN1bHQgPSByZXF1ZXN0KHRhc2tfYXBpLCB7XFxcXG4gICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcXFxcbiAgICAgICAgfSxcXFxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xcXFxuICAgICAgICAgICAgXFxcXFxcXCJwYXJhbXNcXFxcXFxcIjoge1xcXFxuICAgICAgICAgICAgICAgIFxcXFxcXFwiZGF0YVxcXFxcXFwiOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwidHlwZVxcXFxcXFwiOiB0YXNrLm1vZGV8fCdydW4nLFxcXFxuICAgICAgICAgICAgICAgICAgICBcXFxcXFxcImZ1bmNcXFxcXFxcIjogdGFzay5mdW5jfHwnJyxcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJwYXJhbXNcXFxcXFxcIjogdGFzay5wYXJhbXN8fFtdXFxcXG4gICAgICAgICAgICAgICAgfSxcXFxcbiAgICAgICAgICAgICAgICBcXFxcXFxcImF1dGhcXFxcXFxcIjoge1xcXFxuICAgICAgICAgICAgICAgICAgICBcXFxcXFxcIm5hbWVcXFxcXFxcIjogaG91c2VfZGF0YS51c2VybmFtZXx8XFxcXFxcXCJcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJwYXNzd29yZFxcXFxcXFwiOiBob3VzZV9kYXRhLnBhc3N3b3JkfHxcXFxcXFxcIlxcXFxcXFwiXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9KSxcXFxcbiAgICAgICAgbWV0aG9kOiAnUE9TVCdcXFxcbiAgICB9KTtcXFxcbiAgICByZXR1cm4gSlNPTi5wYXJzZShyZXN1bHQpLnJlc3VsdDtcXFxcbn1cXFxcblxcXFxuZnVuY3Rpb24gdGFza191cGxvYWQodGFzayl7IC8vIOmAmueUqOS7u+WKoeWPkeW4g+aWsOWinuWPiuS/ruaUueWKn+iDvVxcXFxuICAgIGNvbnN0IHthcGksZ2V0RmlsZX0gPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvdXRpbGl5P3J1bGU96YGT6ZW/5LuT5bqTUHJvXFxcXFxcXCIpO1xcXFxuICAgIGxldCBob3VzZUZpbGUgPSBnZXRGaWxlfHxmYWxzZTtcXFxcbiAgICBpZighaG91c2VGaWxlKXtcXFxcbiAgICAgICAgc2V0SXRlbSgnaXNfaG91c2VfdmlwJywgJ2ZhbHNlJyk7XFxcXG4gICAgfVxcXFxuICAgIGxldCBhcGlfdXJsID0gYXBpLmhvc3QrJy9oaWtlcnVsZS90YXNrL2FkZCc7XFxcXG4gICAgbGV0IGhvdXNlX2RhdGEgPSBob3VzZUZpbGUoKTtcXFxcbiAgICBsZXQgcmVzdWx0ID0gcmVxdWVzdChhcGlfdXJsLCB7XFxcXG4gICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcXFxcbiAgICAgICAgfSxcXFxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xcXFxuICAgICAgICAgICAgXFxcXFxcXCJwYXJhbXNcXFxcXFxcIjoge1xcXFxuICAgICAgICAgICAgICAgIFxcXFxcXFwiZGF0YVxcXFxcXFwiOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwibmFtZVxcXFxcXFwiOiB0YXNrLm5hbWUsXFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwicHljb2RlXFxcXFxcXCI6IHRhc2sucHljb2RlLFxcXFxuICAgICAgICAgICAgICAgICAgICBcXFxcXFxcIm5vdGVcXFxcXFxcIjogdGFzay5ub3RlLFxcXFxuICAgICAgICAgICAgICAgICAgICBcXFxcXFxcInRlc3RfY29kZVxcXFxcXFwiOiB0YXNrLnRlc3RfY29kZSxcXFxcbiAgICAgICAgICAgICAgICB9LFxcXFxuICAgICAgICAgICAgICAgIFxcXFxcXFwiYXV0aFxcXFxcXFwiOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwibmFtZVxcXFxcXFwiOiBob3VzZV9kYXRhLnVzZXJuYW1lfHxcXFxcXFxcIlxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICBcXFxcXFxcInBhc3N3b3JkXFxcXFxcXCI6IGhvdXNlX2RhdGEucGFzc3dvcmR8fFxcXFxcXFwiXFxcXFxcXCJcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0pLFxcXFxuICAgICAgICBtZXRob2Q6ICdQT1NUJ1xcXFxuICAgIH0pO1xcXFxuICAgIHJldHVybiBKU09OLnBhcnNlKHJlc3VsdCkucmVzdWx0O1xcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiB0YXNrX2NhbGwoaWQsZnVuYyxwYXJhbXMpe1xcXFxuICAgIGNvbnN0IHthcGl9ID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3V0aWxpeT9ydWxlPemBk+mVv+S7k+W6k1Byb1xcXFxcXFwiKTtcXFxcbiAgICBsZXQgdGFza19hcGkgPSBhcGkuaG9zdCsnL2hpa2VydWxlL3Rhc2svcnVuLycraWQ7XFxcXG4gICAgbGV0IHRhc2sgPSB7XFxcXG4gICAgICAgIG1vZGU6J2NhbGwnLFxcXFxuICAgICAgICBmdW5jOmZ1bmMsXFxcXG4gICAgICAgIHBhcmFtczpwYXJhbXN8fFtdXFxcXG4gICAgfTtcXFxcbiAgICByZXR1cm4gdGFza19yZXEodGFza19hcGksdGFzayk7XFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIHRhc2tfcmVuYW1lKGlkLG5ld190YXNrX25hbWUpe1xcXFxuICAgIGNvbnN0IHthcGksZ2V0RmlsZX0gPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvdXRpbGl5P3J1bGU96YGT6ZW/5LuT5bqTUHJvXFxcXFxcXCIpO1xcXFxuICAgIGxldCBob3VzZUZpbGUgPSBnZXRGaWxlfHxmYWxzZTtcXFxcbiAgICBpZighaG91c2VGaWxlKXtcXFxcbiAgICAgICAgc2V0SXRlbSgnaXNfaG91c2VfdmlwJywgJ2ZhbHNlJyk7XFxcXG4gICAgfVxcXFxuICAgIGxldCBob3VzZV9kYXRhID0gaG91c2VGaWxlKCk7XFxcXG4gICAgbGV0IHRhc2tfYXBpID0gYXBpLmhvc3QrJy9oaWtlcnVsZS90YXNrL3JlbmFtZS8nK2lkO1xcXFxuICAgIHRhc2tfYXBpID0gdGFza19hcGkrJz9uYW1lPScraG91c2VfZGF0YS51c2VybmFtZSsnJnBhc3N3b3JkPScraG91c2VfZGF0YS5wYXNzd29yZCsnJnRhc2tfbmFtZT0nK25ld190YXNrX25hbWU7XFxcXG4gICAgdHJ5IHtcXFxcbiAgICAgICAgbGV0IHJlc3VsdCA9IEpTT04ucGFyc2UoZmV0Y2godGFza19hcGkse30pKTtcXFxcbiAgICAgICAgaWYocmVzdWx0LnN0YXR1cz09MCl7XFxcXG4gICAgICAgICAgICByZXR1cm4gIHJlc3VsdC5kZXRhaWxcXFxcbiAgICAgICAgfWVsc2V7XFxcXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdCsnJytyZXN1bHQuZGV0YWlsXFxcXG4gICAgICAgIH1cXFxcbiAgICB9Y2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgbG9nKGUubWVzc2FnZSk7XFxcXG4gICAgICAgIHJldHVybiAnJytlLm1lc3NhZ2VcXFxcbiAgICB9XFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIHRhc2tfY2hhbmdlX3N0YXRlKGlkKXtcXFxcbiAgICBjb25zdCB7YXBpLGdldEZpbGV9ID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3V0aWxpeT9ydWxlPemBk+mVv+S7k+W6k1Byb1xcXFxcXFwiKTtcXFxcbiAgICBsZXQgaG91c2VGaWxlID0gZ2V0RmlsZXx8ZmFsc2U7XFxcXG4gICAgaWYoIWhvdXNlRmlsZSl7XFxcXG4gICAgICAgIHNldEl0ZW0oJ2lzX2hvdXNlX3ZpcCcsICdmYWxzZScpO1xcXFxuICAgIH1cXFxcbiAgICBsZXQgaG91c2VfZGF0YSA9IGhvdXNlRmlsZSgpO1xcXFxuICAgIGxldCB0YXNrX2FwaSA9IGFwaS5ob3N0KycvaGlrZXJ1bGUvdGFzay9jaGFuZ2Vfc3RhdGUvJytpZDtcXFxcbiAgICB0YXNrX2FwaSA9IHRhc2tfYXBpKyc/bmFtZT0nK2hvdXNlX2RhdGEudXNlcm5hbWUrJyZwYXNzd29yZD0nK2hvdXNlX2RhdGEucGFzc3dvcmQ7XFxcXG4gICAgdHJ5IHtcXFxcbiAgICAgICAgbGV0IHJlc3VsdCA9IEpTT04ucGFyc2UoZmV0Y2godGFza19hcGkse30pKTtcXFxcbiAgICAgICAgaWYocmVzdWx0LnN0YXR1cz09MCl7XFxcXG4gICAgICAgICAgICByZXR1cm4gIHJlc3VsdC5kZXRhaWxcXFxcbiAgICAgICAgfWVsc2V7XFxcXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdCsnJytyZXN1bHQuZGV0YWlsXFxcXG4gICAgICAgIH1cXFxcbiAgICB9Y2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgbG9nKGUubWVzc2FnZSk7XFxcXG4gICAgICAgIHJldHVybiAnJytlLm1lc3NhZ2VcXFxcbiAgICB9XFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIHRhc2tfcnVuKGlkKXtcXFxcbiAgICBjb25zdCB7YXBpfSA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS91dGlsaXk/cnVsZT3pgZPplb/ku5PlupNQcm9cXFxcXFxcIik7XFxcXG4gICAgbGV0IHRhc2tfYXBpID0gYXBpLmhvc3QrJy9oaWtlcnVsZS90YXNrL3J1bi8nK2lkO1xcXFxuICAgIGxldCB0YXNrID0ge307XFxcXG4gICAgcmV0dXJuIHRhc2tfcmVxKHRhc2tfYXBpLHRhc2spO1xcXFxufVxcXFxuXFxcXG4kLmV4cG9ydHMudGFza0NhbGwgPSB0YXNrX2NhbGw7XFxcXG4kLmV4cG9ydHMudGFza1J1biA9IHRhc2tfcnVuO1xcXFxuJC5leHBvcnRzLnRhc2tSZXEgPSB0YXNrX3JlcTtcXFxcbiQuZXhwb3J0cy50YXNrVXBsb2FkID0gdGFza191cGxvYWQ7XFxcXG4kLmV4cG9ydHMudGFza1JlbmFtZSA9IHRhc2tfcmVuYW1lO1xcXFxuJC5leHBvcnRzLnRhc2tDaGFuZ2VTdGF0ZSA9IHRhc2tfY2hhbmdlX3N0YXRlO1xcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIuWFqOWxgOWCqOWtmFxcXCIsXFxcInBhdGhcXFwiOlxcXCJsb2NhbFN0b3JhZ2VcXFwiLFxcXCJydWxlXFxcIjpcXFwibGV0IGxvY2FsU3RvcmFnZSA9IChmdW5jdGlvbigpIHtcXFxcbiAgICBldmFsUHJpdmF0ZUpTKFxcXFxcXFwiandVS3dOVGlQR2NXU0xDWEI1WHRBWHdiNkxRYlZ5SEQrMFhKN2wwN2NlMD1cXFxcXFxcIik7XFxcXG4gICAgLy9wYXRodG89dW5kZWZpbmVkO1xcXFxuICAgIGV2YWxQcml2YXRlSlMoXFxcXFxcXCI0QzBZeFJZbkdDWWtnRlJYdHBsL0N6NXpMNWhoNGpDQ3p0YituZytXb2t5bVE4b1VyelM5bEE4eXhDNWFGYWRuU0VteUhLTWJyYWZsUnFYQ25OUkhEbGs2dWU4eUhUTzE2bEJQcnB3Z3M1amYwUGhyQXRvVEpJRTBaSG45bUthUTRKZDJlcnFiNEk1NWJlV0lldWdLc0RzMjExU3pJTlE1eUpnU2gxZFZ1Tnp6eFJHSmc0MEZtVHVWbVhWZk4xeGcyV0lHSEJFbWtWbkd4bU9SaFBPTkErUTVWd1BtZHA0MS9oemUzZUlzVXZobzdWQ0JnSzRyYUptUGFsSVJCQlZsQ1ZnbjhGa1dtZktxWm8rVlcrb0JjSDdocmNyc1NsQ1NqQmFuZ1QvN3N5V0h4S1loZWhVMGthTVlqbldGZzFFbTBjbU5SdG9tQ3NIejFCOHEzMk9lUUhvYXdkV3h6S09hTUhPWERCalJvakE4RS9haDBXUk95emlxUlN4bC9tOGRoQmQwZjlwaFl6LzVTVS96SkQ1MlgvOUVDMTZXVlZkcFNXMzNha1JIUnNsUHBSbFRXRjkrQXlSbVJ3MGVaT0VzMW85UU1QQVFVZkF4Yll5RkhnenR3L08yZEpScEh5VG1pQmlhYXFUY2l2eDZ2OXp5dkJ6MDR3STFBYVNDdWkrZFR1VTNsdTV4ZEV0M0FqdDZaM2lEWE9WY0VQMEVERjc0NzRQUVU2SkVadXdlOTdTY2g0Ymkxd0IxWEhaU2ZJdGRsWVlvR2VkM0xMcGJtREFJUmNpdjByQW9wOFZtUWNUdDJLM0xmaDFSRFlZMFl0dlJjSDQ5T3ZwRFJIL3hhNUZjOE1ZM0RyRm9BN3Fjb0Y0ZUNnaVZCZkJnSlI2OCtMcFFLN3RPa2c4azllYyszTlN4SlRoY2w4ZDZ5Tnd4VDlUazE3emVKZ2Q2TW95WVpJcFdRTGxGNll2Yk9kRVdoam1uQTc4d0MwaFd6K1htNmhRTVNxdEZ3K2JoRmY3Y0JHVTNhYXRQRm1kQ1kyRWRYZmgwSVlXODV3ZE95TWZpd1c3L3ZWVHA5aUUwMEkzRjA5d0dIa0dLaFZiTHVlQWtZZTd6ekpYUjd0aGFGb3I2SDdxTG1KamJSUWs5ZXZOdEJRWE5SN0RpZmlYdVFmMmx0N25PSDgwU1dtMWZESEh6am1Qc05JcHMyVFhHVCtpd1ZWNjlnL3RXaXBWUTZEOEJUeCtjQ1FwNDdubVRJclkrcU40a2gyRlloNUxsd1hkZ0l5eTFWSXVDM3gwNTNld0FJSVVtbFk5bmlFcHFZdCsxZkZQWE9DdENHdFliU2QzN3ZWUjFFT2oyazVHdS8rOUpXZzJxdndsMXR3ZWxnMUowdHhhcklpNGtUYlRydnJuRkxOOTJwb2ZwWlFVZm9XbzRjZTdIV05kYnU0SktFcmFMUVVmZGZHRVBkMVRJdWZ1dVJWYTM5ZXE5R1p5U0R1Qkw2ME1QZGxkeEt3MXpvK2ZCNVpZK1lNajNMTDJnR3REYnM5OCtBc1JWOUxKV21VbXN4OTFobUp0RlVNV0QzeG5qOEhNWldzME5QbENGVXI5NDg1S3FUcG81a1J6R2ZGK2svTmwySnpydjVjdmtxdFVuTGdLcFhFT2ovc2Uvb0R6T0FyUUtJNVROVWJ2WXdjd2NkampNU2ZqSzY4S3J3aHMrbjZTbVdaNFpkZ1JIZ0FLNU1vRmkzWG1MVjQ3UDN2U1JXdTV6eUVzTWs0eTN1dUNGaXVSUFJsdTRRNXBKdnVPZW03SDdVTGlJaENlbXY1RGdrR3RETDFjR0w0RVFoWVJCNklTelZ2c2IyRWFQOXdRRTZEVlJuTTdPK3BuU3pldDZsenAzcEZkR25ib3gxTFJmQzYwdXRYWitDakltNGlFTW10YkIyTjV6RFNoR2JlTTNYVWJKUWRDQmlzOFhJcmhoMmJpQjVoQkNWd24zWTNldHQ3R0RQVnRvaTFHUmp6K0piZ00rWVI5MjhLYmRXUzV0RmFNTTNLajNYdjZvdEl4ek1CbkRDOXVXM2QrSVh4NnZMUEowSlJ1aDN5UDdwVGxhNmMzaVI0cDluV1lEcUorWlNtcHJIRm5ET3pzTFdtRmphcGplL01xd01KZDZUazNuQVd3aWNNT1B1WXBNeXFJRjA0Zmw0bXFndHNITFNNV1JSTkhQWmpFVFE5Z1JtZURZZTZhUnRsVzAycUwyb2xERU5xTFFNdEFkb2lyTldSY1A5VkwzVGQ4SGFVTzZmU2xHTmFiTWFrSkQvMDBYQ2hPU1VPSVArN2ZNN1YwL2wxYkxXUHRFejFpN0x5Z1RWN3BkR29EbnRxU0NFbkpyQnloQkF6TFJnNVFJYzk0MzhJaEtteWZuMC8zYXdvRDFJcjc4MGV5cC9YY0k2eE5jdzZUdi9FVGZIZzBlN2lZQzBVWWNKSUU1UVVYdjBzK1lvR0lFcTVHSXpLdWI4SE5qU1RVcHN2bmtWeCtkYmUyalJuM1liOVc3SkNaNVlTNkY1TXlVVnNwak1EN05ZYytEV2pVTDJiMnNWeUFmZVlwQzhVaGFoOXR1bWF2YkJ2N2EzYTlrZ0ZicTU4bHJIeHpZN2lKUVZpZ3pxM2UxYTJCU2IwUGNXMWFKOEJEN05rTnBoS1lheVR4eWtnd2lsRVJMOGpxcUJFbmlIVmRCeERKWUxiK1h3M2FsTG1sdHVURVY2S0d0Qm50QlgreXozNlJQRE15R0lLZSszZnpjeGZuQ0RuMjBNb2RWVmtWTm96UHFNWFowRzVMNGFMVEFRYWtZS1Vqc1ZNUWpBaFFrVGxIQmVPL2FMUHg5c3hsKytqMVo1ckxnRzEyVE40WEoxZWljdnc0QVZFNThMb3JhcTBRaUUwY1M3UEgxcGJyWldyZnQ3TFlHaXlCU2hvcjcrMGppb1VoMXBkV3EycU1ZTHFlTUVldUNST1F0NTdtRnJPanlQSDQ5cXA5N2NXT3JnZWcyV3lmV1NER1FQamU1K1AweVFvQ3BEL0QzUkFNdVdtYjl3bEJ0Y3EyajhXSlB0OTFFM2tLYXd1UUl5dmQycjJVang0K0hUTnRWS2I5a01MT084NUk2NWJOR0JIKzRpclN5NWdRWWxFMjZBMmNTR0ljTEtRUmx2Sm9NbmE3TC85d3lyeTRIek9yemtyQXZMZGdzU05sWWpwSFFFUmlPSTgwc0o1ak5DQ25mdzAxM0YrQStzQWZMbXlTL0JETE5RMXFhUTNwNmg4L0pxQWZoWDVPR0hnU2lSVk9DRWp1YURCL013Wk5DdTNRTDllaGhvQWo3dU9mOFBrcjNtSWpiaGg5SGlqc2p4MTkxKzBlMkpRckZhMDFBVkpLRVZ0dVB0SWMyaC8xcFBLTXZ5ZW54alRPMk94UG5qanQrODRuSUtLaHhESi9naFB0N2l2OFBtVEowbEtLeVBSc3NsOGYvUWRIZHh1cGI2alRzSTZVS216OVk0NlBNQnVENlAzd2g4cXAzNk82b2liTkRpUWQxc0UxMHZKaDl6MUZ5c0tJZThFcU1wbk5kRW1HMlRmRUJ4UnBtUXJoS0VxZWUwcDYrYTZzUW84Y1ZsUkprS1FBWUthd2NhTkVTNVhjNmRRWTVucWVpcThzVWl6ZjFzcGZIZUhlbER1MU02QlJYdUNqRmFmWGh6OGkzbFBXZ1lxVnBmeDEzaWdWQ1JmNDdVSDY1MnlMbnNtZXBDQldneUJUV0FjT3lGMVF4OFlHdFpub2IxVE4rNnhFd3pwY1dWeTdRTzlQOTJzS0E5U0srL05Ic3FmMTNDT3QwSkhDdFRWMU9sVFFXK0pBS3l4ZTFIbDcrczk1ejNLQ2dGS1FTKzNBczFKVjdOYStnK0xDUjJJZXZ1OGQ1RDBMN0d3b0RyZVV2NDM3NExSYUZrTnNIT3FXYlU5bmhRamRNVnI3YS9pOE8vNGhicHRhU3pxcWtnWUZpTkZVL29tVzVxd0l6N3NwNG5zY0lUUkUzZ3VhNmJ6a2xNWjhFQ24xaXFBV3QwYTZnZWtpNURhTDhxWWFwVENDaGpsV3NFeHFGdXhpV1AzNVRVQ2RkRWQ4QUNiTUdzK2dRRnlET296ZkJERzE3ZFpPMG1Dd1crUHpDTDJqYklDRE5haTUvam0xUXI2TUw1Nmp6VWFJRHowR0xQVFNhZXgxVUREd2tROW83bVhXQzBSN2pXbnpia0hSV2NvbVZiV21HcUwxcmpkb2Fjcy9SOXVqcVV1QkE2QTVWTC9xa1ExeEhMNDJFWG9vcHJDOHdycmZSNjh6TU1GeE93VTdDWUhKN2JoRy9RNHJOc1hEQmNNbzFBZGlxOUxYYlhtL1FKajB1L2pnWkdzc3owbm5LS1VGSmN4enVBTks5NnpXd2YxRFhhc1VjT29FdUVhdG0xcm1QNXdyQkptVy9ad1Q2YUJCaVIyT1NKMHhyOHRRNk9ibWRLanliKzFlRVhiMTQzN1IySWRoRFVkazVQUnp0SDJZRnQycG11TDQvTG1JTEZBdlBkaXlNdERITmorS2g0c1Y0TWxYYldQcnJJOTdZQk9GcEZsWCtnbmV3S0tmRlprSEU3ZGl0eTM0ZFVRMkduZTZzQUd4MXp4eWpadjVLQk0yNmxSSEY0NVhxRk5KMVJRM2hNeW1KSHN5WU5zTU80MUJXckd2MTlQQTQ2OGVjdzlIY1JOMHdoalVUZ25zOFpWYUM0aGlKc2dZMDdhQUVCSG05MC91aGhqTy9XbWI3d3VWYWRobDlSbkhlUWpweDRnd0NyTHo1aTVzNUl0MXNCd2ZEYjBGZStQQ3BMa2Mrd0lJTksyWTg2a1B0aFI2Z0p3Vzc1enVvTjVDMENBaUR3ZlU3M3ZhQVphaHpmNFZMTmxNMFUwNE90SFlCaTEzWWdQb05tR0hSZWxaVkV5Mkt1S1ZaZ2hEMTR2U2xZK0pyTUJEZG0yeTJ0aEZWK0JyaWhMNytmUTV3Y1lueEdlbGF3RHVvU1I1K2JERGtyNlJMNDBMNHh5ZkFoeGxyT24wdUEyOGdoR2VXZ3VhV0tFdjVuQnJydmV1MXVlVnkxTXZHVVlCWStJbEVyOE5kRE5SZG1Felh0MzlrR2xkODZ4T2ZBSC94TDFWbXVnYVhPR2FQQjJxYzdXRFJrVzZrNUY2bjNQa0l6ZFBYeU9OS3AxRGtPZzNvY1NNWk1UczZHS2o5QzN2T0RaNlpRcHdORFlMTVQrQ21FTDE4R1JqWE5jWmxQL0xuaGlBSXNjWVRMMStpSFdEWXZSbXZQTXd0T0hoQ25FWElVM0ZUYlArNlFSR0E2cXlkYm5uZXFWaFhvd2NMbWJNSXoxNklDMWt3aFpqNzUvTTUzc0tZWDJ6UmdPU1RBZk5TRC81bFpZU05VeEpmS1REZ2lhRkVnZ3JDcmQrM0NjK2NoenNsSTN6RFhFS1RydmxjWDJJbkM5dUgrZnN5cHlIdytBdlkyT21CR1FNSUljOGZFM3ROTzBnQlRWcVhzZHNFNzZZd0hyMjlkelFja3VzdXlKc0JmU1ZjbHJ2c05DWjFQUURMOEgzY1JzM0hFOW5Va3g1YmJKWVdzUHhiODI1Z25FcFdVOVo5S3R6dnNsaTcvaGVPbERLcEh4SmIxdUNyV3FmOGdSbldtcTN6ZlNTclVYQkhTTHU2Mk1ya1hUaldnYXBVVnhNR2tybnpSMEU0UE15MWJGY3lEcEVRZTE1VGF5V0JNMUI2anJJRyswRFJSOU9hQ1VQd0Q3ZXhObWpaYjlNODF1cytBSVJmeXpKUFpHbWZIdVQ5U056RmZOdVFkRlp5aVpWdGFZYW92V3VOMmlySTN6UWF0S0NEblFJWHByMFZoRzBHb3A4Yy96cm9XQm9OL2FWS21uOHNrU0Z2QURPam9aQWl4ZzZLMXk5d0ZpOHBlQ21pbUZaM1p6Q1ZzRzZFVTlTdmxicTUrd243RDZ5K2RBWWRhUG1zNGd3Q3JMejVpNXM1SXQxc0J3ZkRiejRYNFZ4cUlwY1RDOU5hWUtxQTdHS0srYVRyWldVd3dOMjFRT3RyOGVxeFNnSjFVOWVDT2NXWFFkK3AzNkd5NGZZK3Q5YzJDc1ZOYk5sMWdoeGE5Ykk4VTZlNkZUZC92dkJhcTlqcktkaXRxNG1OQ2Fpb2dtZlBLNk00OFVZSThqWk1DZGQvOUM4QnF2VWo0YllVNWJ5V0FTRUc2QkJHZEs4S2xmaS9hNExXdDNpdkM0dTlRQlRmYi92Q21OSmkvUUFmYWJjUEcrVXNXbXNZTlJLK2c4aE1jc3VCbWhoNDhOcGhSdmViVlFxcTZuY0t4YzFuRkhXTVc1TTZvZit6OGMxSGRkbmllRFA5R2FCc3EreXNsaktzbFlydDk4OVBZOXhzYm1rcjNYL29DZmlGVTROZmNPaGVlKytuZ1cwWHBaQVZ0MUkyUW5jMWFsd2Jub05xTU1oWElCOTVpa0x4U0ZxSDIyNlpxOXNHL3RyZHIyU0FWdXJueVdzZkhOanVJbEJXS0RPcmQ3VnJZRkp2UTl4YlZvbUtxUWp1aDlkemYybnZWckJ6YkVGMENaWTZpemtZL1JRWTVyOWs5My95Mk5HN28wN25NWWpPdFpZWWVOVW9pazdHYksvSHpRbDFTN3MvRkNobnQ5TTZmRTBVeXVQbXR0Tzk4aHF6eFFidGVNYWxNdFNjZTJXTGNqeVhWR2ZwcWRCa1l5bTRnWkJ5Y2NTNmFudHQ0b0xkbHVXU1NKc0hYMUljWGhReTZvSitBaGp3OWhGWXdYTEhQTG9DbzNqRWxpVUFLNDE3OXd0WXRIc08wYWJMeDQraG10TTVGejd3VVZhaEJBOXN1cE9UZi9GRDRzaVpNTW9mNVczdm01RGVkaHFHQU5saHQzbUk2Um1JaHY0OFFWdG5lTXNVellDNE5EaFpENE01UjZwN0dYQnFjcHUzRmFFRi8wSTBlM0xjZVgxSE4raURxS1JQdUd6dnBhYy8xdHNHUEl0ZUFEeHU5T1lvYXAyejNGMUN6U2cvVXVhOGwvS0V6dEFLRGN2YmhOVS9ZVWMybGhneGdmZGI0ZStQOVRaN1JhWDgyczYyN3UwQ2JGc2ZHRS8xaExwYjVNYzJ2azF1REdyZEljYldBNnhocFlBSFloRVlVbDljNzVZL1IvMGdsNnI5K202Y0kwQnZCWTVBYTVOQlJjNlVNdnNPL1BPdzVDY3I3OXNKemljZWFWM1l3cllFa2pwNktpK09Zckd1OTU0QUErZEo5V3N2TkdCRkdNcktBZlE5VlVDL0FUa0pmVGxvTWx0RGVWNUFvOXprYWF5M2RLQWE1L1B4QUdSREFVY1FMREY3dVZYYkQxdkZnRS8rUlhpd3pTNU43Y3IzYUZCZFJZN1hBbUZ6L2ZiMC9LU3BSOENRL2xva3BtTTJtbHRKOXZHUGdpcWI1blpsOUt1N2QyR2xnQWRpRVJoU1gxenZsajlIL1NCdWpCUG9PMWZwb091NUYzNWNkSGE1a1NGdkFET2pvWkFpeGc2SzF5OXdGbGowRXo1a3NVVzNXVTYzRTdlNHF0RFVDS1d3ampVNWYwRmQ1N1Z5VnpwQzZDZENTY0JqWVN6VDlyWkxWc2txNjFhT1dyRERVTktxQVEzK25YL0JCVzNjUVRFY09WZGMxNW5nVlhjU1MvYUsyUUZNZGlLUWxxbTE1ZkVySmR3cXllemE3aGZsS1RpQ3pVZHU1VkdsRlc5cUN0OHN5SG9vc0EyTnpmb3NKZFRkTjhiV0hub0RyNU4yNWV0K3AvbnZqak96WlJhTFlvWS9mci9rNWhxcHRPaz1cXFxcXFxcIik7XFxcXG4gICAgcmV0dXJuICQuZXhwb3J0cztcXFxcbn0pKCk7XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi57yW6L6R5YWs5ZGKXFxcIixcXFwicGF0aFxcXCI6XFxcImRldkluZm9FZGl0XFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxuYWRkTGlzdGVuZXIoJ29uQ2xvc2UnLCAkLnRvU3RyaW5nKCgpPT57XFxcXG4gICAgcHV0TXlWYXIoXFxcXFxcXCJkZXZJbmZvXFxcXFxcXCIsJycpOyAvL+a4hemZpOWOhuWPsuWFrOWRilxcXFxufSkpO1xcXFxuc2V0UGFnZVRpdGxlKCfnvJbovpHlhazlkYonKTtcXFxcbi8vIGxldCB7bm93SngsTXlKaWV4aSxqeHNSb3V0ZX0gPSBNWV9QQVJBTVM7XFxcXG5jb25zdCB7Y29sb3Isc21hbGwsYXBpLCBnZXRGaWxlLGdldEFwaX0gPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvdXRpbGl5XFxcXFxcXCIpO1xcXFxuLy8gbGV0IGhvdXNlRmlsZSA9IGdldEZpbGV8fGZhbHNlO1xcXFxudmFyIGRldl9pbmZvX3VybCA9IGdldEFwaSgnaW5mb0dldFVybCcpO1xcXFxuLy8gbG9nKGRldl9pbmZvX3VybCk7XFxcXG52YXIgZ2V0X2luZm8gPSBmdW5jdGlvbihxcSl7XFxcXG4gICAgcXEgPSBxcXx8JzQzNDg1NzAwNSc7XFxcXG4gICAgbGV0IGRldl9pbmZvX3VybCA9IGRldl9pbmZvX3VybCtxcTtcXFxcbiAgICBsZXQgYmFja19jb2RlID0gSlNPTi5wYXJzZShyZXF1ZXN0KGRldl9pbmZvX3VybCkpO1xcXFxuICAgIGxldCBkZXZfaW5mbz1iYWNrX2NvZGUucmVzdWx0fHxiYWNrX2NvZGUuZGV0YWlsO1xcXFxuICAgIHJldHVybiBkZXZfaW5mbztcXFxcbn07XFxcXG52YXIgYmVmb3JlX3JlZnJlc2ggPSBmdW5jdGlvbigpe1xcXFxuICAgIGxldCBkZXZfc2V0X2luZm8gPSBnZXRNeVZhcihcXFxcXFxcImRldl9zZXRfaW5mb1xcXFxcXFwiKS5zcGxpdCgnJCQnKTtcXFxcbiAgICBsZXQgZGV2X2luZm9fdXJsID0gZGV2X3NldF9pbmZvLnNsaWNlKC0xKVswXTtcXFxcbiAgICBsZXQgYmFja19jb2RlID0gSlNPTi5wYXJzZShyZXF1ZXN0KGRldl9pbmZvX3VybCkpO1xcXFxuICAgIGxldCBkZXZfaW5mbz1iYWNrX2NvZGUucmVzdWx0fHxiYWNrX2NvZGUuZGV0YWlsO1xcXFxuICAgIHB1dE15VmFyKFxcXFxcXFwiZGV2SW5mb1xcXFxcXFwiLGRldl9pbmZvKTtcXFxcbiAgICByZXR1cm4gZGV2X2luZm9cXFxcbn07XFxcXG5sZXQgZCA9IFtdO1xcXFxuZC5wdXNoKHtcXFxcbiAgICB0aXRsZTon57yW6L6R5YWs5ZGKJyxcXFxcbiAgICBkZXNjOifmlK/mjIFtZOivreazlSzngrnlh7vov5vlhaXlrabkuaBNZOivreazlVxcXFxcXFxcbuS/neWtmOWFrOWRiuaMiemSruWcqOaWh+acrOahhuacgOS4i+mdoicsXFxcXG4gICAgY29sX3R5cGU6J3RleHRfMScsXFxcXG4gICAgdXJsOidodHRwczovL3d3dy5ydW5vb2IuY29tL21hcmtkb3duL21kLXR1dG9yaWFsLmh0bWwnXFxcXG59KTtcXFxcbmQucHVzaCh7XFxcXG4gICAgdGl0bGU6J+i/lOWbnicsXFxcXG4gICAgY29sX3R5cGU6J3RleHRfMicsXFxcXG4gICAgdXJsOiQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKCk9PntcXFxcbiAgICAgICAgYmFjayhmYWxzZSk7XFxcXG4gICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXFxcbiAgICB9KVxcXFxufSk7XFxcXG5pZighZ2V0TXlWYXIoJ2RldkluZm8nKSl7XFxcXG4gICAgYmVmb3JlX3JlZnJlc2goKTtcXFxcbn1cXFxcbmxldCBlbXB0eSA9ICdoaWtlcjovL2VtcHR5JztcXFxcbmQucHVzaCh7XFxcXG4gICAgdGl0bGU6J+mYheiniOafpemYhScsXFxcXG4gICAgY29sX3R5cGU6J3RleHRfMicsXFxcXG4gICAgLy8gdXJsOiQoZ2V0TXlWYXIoJ2RldkluZm8nKSkuY29uZmlybSgpXFxcXG4gICAgdXJsOiQoZW1wdHkpLnJ1bGUoKCk9PntcXFxcbiAgICAgICAgcmVxdWlyZShcXFxcXFxcImh0dHBzOi8vZ2l0bGFiLmNvbS9oamRobngvaGlrZXIvLS9yYXcvbWFpbi9qcy9tYXJrZWQubWluLmpzXFxcXFxcXCIpO1xcXFxuICAgICAgIGxldCBkZXZJbmZvPVxcXFxcXFwiXFxcXFxcXCI7XFxcXG4gICAgICAgdHJ5e1xcXFxuICAgICAgICAgIGRldkluZm89bWFya2VkLnBhcnNlKGdldE15VmFyKCdkZXZJbmZvJykpO1xcXFxuICAgICAgIH1jYXRjaChlKXt9XFxcXG4gICAgICAgIHNldFJlc3VsdChbXFxcXG4gICAgICAgICAgICB7XFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6ZGV2SW5mbyxcXFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZToncmljaF90ZXh0JyxcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgXSk7XFxcXG4gICAgfSlcXFxcbn0pO1xcXFxuZC5wdXNoKHtcXFxcbiAgICBkZXNjOiBcXFxcXFxcIuW/q+adpee8lui+keS9oOeahOWFrOWRiuWQp35cXFxcXFxcIixcXFxcbiAgICBjb2xfdHlwZTogJ2lucHV0JyxcXFxcbiAgICBleHRyYToge1xcXFxuICAgICAgICB0aXRsZVZpc2libGU6IGZhbHNlLFxcXFxuICAgICAgICBkZWZhdWx0VmFsdWU6IGdldE15VmFyKCdkZXZJbmZvJywgJycpfHxcXFxcXFxcIlxcXFxcXFwiLFxcXFxuICAgICAgICB0eXBlOiBcXFxcXFxcInRleHRhcmVhXFxcXFxcXCIsXFxcXG4gICAgICAgIGhlaWdodDotMSxcXFxcbiAgICAgICAgb25DaGFuZ2U6ICdwdXRNeVZhcihcXFxcXFxcImRldkluZm9cXFxcXFxcIixpbnB1dCknXFxcXG4gICAgfVxcXFxufSk7XFxcXG5kLnB1c2goe1xcXFxuICAgIHRpdGxlOlxcXFxcXFwi5L+d5a2Y5YWs5ZGKXFxcXFxcXCIsXFxcXG4gICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJyxcXFxcbiAgICB1cmw6JCgn56Gu6K6k5L+d5a2Y5YWs5ZGK5ZCX77yf5bCG5Lya5LiO6YGT6ZW/5LuT5bqT5pyN5Yqh5Zmo6YCa6K6vJykuY29uZmlybSgoKT0+e1xcXFxuICAgICAgICBsZXQgZGV2X3NldF9pbmZvID0gZ2V0TXlWYXIoXFxcXFxcXCJkZXZfc2V0X2luZm9cXFxcXFxcIikuc3BsaXQoJyQkJyk7XFxcXG4gICAgICAgIGxldCBpbnB1dF90ZXh0ID0gZ2V0TXlWYXIoJ2RldkluZm8nLCAnJyk7XFxcXG4gICAgICAgIGlmKGlucHV0X3RleHQubGVuZ3RoID49IDQpe1xcXFxuICAgICAgICAgICAgbGV0IGluZm9fc2V0X3VybD0gZGV2X3NldF9pbmZvWzJdO1xcXFxuICAgICAgICAgICAgbGV0IHNlbmRfZGF0YSA9IHtcXFxcXFxcInBhcmFtc1xcXFxcXFwiOlxcXFxuICAgICAgICAgICAgICAgICAgICB7XFxcXFxcXCJkYXRhXFxcXFxcXCI6IHtcXFxcXFxcImluZm9cXFxcXFxcIjogaW5wdXRfdGV4dH0sXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXFxcXFxcIm5hbWVcXFxcXFxcIjogZGV2X3NldF9pbmZvWzBdLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJwYXNzd29yZFxcXFxcXFwiOiBkZXZfc2V0X2luZm9bMV19XFxcXG4gICAgICAgICAgICB9O1xcXFxuICAgICAgICAgICAgLy8gbG9nKHNlbmRfZGF0YSk7XFxcXG4gICAgICAgICAgICBsZXQgcGFyMiA9IHtoZWFkZXJzOnsnY29udGVudC10eXBlJzonYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PVVURi04JywnVXNlci1BZ2VudCc6ZGV2X3NldF9pbmZvWzNdfSxib2R5OkpTT04uc3RyaW5naWZ5KHNlbmRfZGF0YSksbWV0aG9kOidQT1NUJ307XFxcXG4gICAgICAgICAgICAvLyBwYXIyID0gSlNPTi5zdHJpbmdpZnkocGFyMik7IC8veDXph4zpnaLor7fmsYLmiY3pnIDopoHnvJbnoIFcXFxcbiAgICAgICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IGJhY2tfcmV0ID0gcmVxdWVzdChpbmZvX3NldF91cmwsIHBhcjIpO1xcXFxuICAgICAgICAgICAgICAgIGJhY2tfcmV0ID0gSlNPTi5wYXJzZShiYWNrX3JldCkucmVzdWx0O1xcXFxuICAgICAgICAgICAgICAgIGlmKGJhY2tfcmV0LnN0YXR1cz09PTApe1xcXFxuICAgICAgICAgICAgICAgICAgICAvLyByZWZyZXNoUGFnZSgpO1xcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5L+d5a2Y5oiQ5YqfXFxcXFxcXFxuJytiYWNrX3JldC5kZXRhaWw7XFxcXG4gICAgICAgICAgICAgICAgfWVsc2V7XFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/kv53lrZjlpLHotKVcXFxcXFxcXG4nK2JhY2tfcmV0LmRldGFpbDtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9Y2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v6ZSZ6K+vXFxcXFxcXFxuJytlLm1lc3NhZ2U7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH1lbHNle1xcXFxuICAgICAgICAgICAgY29uZmlybSh7dGl0bGU6J+mBk+mVv+aPkOekuicsY29udGVudDon6Jm954S25L2g5b6I5oeS77yM5L2G5piv5YWs5ZGK6Iez5bCR5YaZNOS4quWtl+WQp++8gSd9KTtcXFxcbiAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXFxcbiAgICAgICAgfVxcXFxuICAgIH0pXFxcXG59KTtcXFxcblxcXFxuc2V0UmVzdWx0KGQpO1xcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIumihOWkhOeQhuS+nei1luaWh+S7tlxcXCIsXFxcInBhdGhcXFwiOlxcXCJsaWJzXFxcIixcXFwicnVsZVxcXCI6XFxcImlmKGdldEFwcFZlcnNpb24oKT49MzIwMCl7XFxcXG4gICAgdHJ5e1xcXFxuICAgICAgICByYyhcXFxcXFxcImhpa2VyOi8vZmlsZXMvcnVsZXMvanMvJGhpa2VyLmpzXFxcXFxcXCIsIC0xKTtcXFxcbiAgICAgICAgLy8kLnNldFJvb3QoJ2h0dHBzOi8vaGpkaG54LmNvZGluZy5uZXQvcHVibGljL2hpa2VyL2hpa2VyL2dpdC9maWxlcy9tYXN0ZXIvanMvJyk7XFxcXG4gICAgICAgICQuc2V0Um9vdCgpO1xcXFxuICAgICAgICAkLnNldExpYih7XFxcXG4gICAgICAgICAgICBsc2c6IFxcXFxcXFwibHNnLmpzXFxcXFxcXCIsIC8v5pys5Zyw5YKo5a2YXFxcXG4gICAgICAgICAgICBmaWxlOiBcXFxcXFxcImZpbGUuanNcXFxcXFxcIiwgLy/mlofku7Zvc1xcXFxuICAgICAgICAgICAgZmlsZVNlbGVjdDogXFxcXFxcXCJmaWxlU2VsZWN0LmpzXFxcXFxcXCIsIC8v5paH5Lu26YCJ5oup5ZmoXFxcXG4gICAgICAgICAgICBkdDogXFxcXFxcXCJkdC5qc1xcXFxcXFwiLCAvL+WKqOaAgeWIhuexu1xcXFxuICAgICAgICAgICAgZHI6IFxcXFxcXFwiZHIuanNcXFxcXFxcIiwgLy9kcuaooeadv+S+nei1llxcXFxuICAgICAgICAgICAgZHJwcmU6IFxcXFxcXFwiZHJwcmUuanNcXFxcXFxcIiwgLy9kcuaooeadv+mihOWkhOeQhlxcXFxuICAgICAgICAgICAgZHJ1cDogXFxcXFxcXCJkcnVwLmpzXFxcXFxcXCIsIC8vZHLmqKHmnb/oh6rliqjmm7TmlrBcXFxcbiAgICAgICAgICAgIGRybWF0Y2g6IFxcXFxcXFwiZHJtYXRjaC5qc1xcXFxcXFwiLCAvL2Ry5qih5p2/6Ieq5Yqo5qih5p2/5Yy56YWNXFxcXG4gICAgICAgICAgICBkcm06IFxcXFxcXFwiZHJtLmpzXFxcXFxcXCIsIC8vZHLmqKHmnb/lsI/nqIvluo9cXFxcbiAgICAgICAgICAgIGNtczogXFxcXFxcXCJjbXMuanNcXFxcXFxcIiwgLy9jbXPmqKHmnb/kvp3otZZcXFxcbiAgICAgICAgICAgIGNtc3ByZTogXFxcXFxcXCJjbXNwcmUuanNcXFxcXFxcIiwgLy9jbXPpooTlpITnkIZcXFxcbiAgICAgICAgICAgIGNtc206IFxcXFxcXFwiY21zbS5qc1xcXFxcXFwiLCAvL2Ntc+aooeadv+Wwj+eoi+W6j1xcXFxuICAgICAgICAgICAgbGliY2hlY2s6IFxcXFxcXFwibGliY2hlY2suanNcXFxcXFxcIiwgLy9kcuajgOa1i+S+nei1llxcXFxuICAgICAgICAgICAgcnVsZUVkaXRvcjogXFxcXFxcXCJydWxlRWRpdG9yLmpzXFxcXFxcXCIsIC8v5YaZ6aG15rqQ56We5Zmo5bCP56iL5bqPXFxcXG4gICAgICAgICAgICBob3VzZUxhenk6IFxcXFxcXFwiaG91c2VMYXp5LmpzXFxcXFxcXCIsIC8v5LuT5bqT6YCa5YWNXFxcXG4gICAgICAgICAgICBsYXp5OiBcXFxcXFxcImxhenkuanNcXFxcXFxcIiwgLy/pppnlhY1cXFxcbiAgICAgICAgICAgIHN1YjogXFxcXFxcXCJzdWIuanNcXFxcXFxcIiwgLy/pgZPlvrfnu4/orqLpmIVcXFxcbiAgICAgICAgICAgIGhpa2VyVWk6IFxcXFxcXFwiaGlrZXJVaS5qc1xcXFxcXFwiLCAvL+a1t+mYlOe7hOS7tuS+nei1llxcXFxuICAgICAgICAgICAgaGlrZXJMaWJzOiBcXFxcXFxcImhpa2VyTGlicy5qc1xcXFxcXFwiLCAvL+a1t+mYlOWFqOiDveS+nei1llxcXFxuICAgICAgICB9KTtcXFxcbiAgICB9Y2F0Y2goZSl7XFxcXG4gICAgICAgIC8vdG9hc3QoJ+ivt+WwneivleeCueWHu+S7k+W6k+S4u+mhteeahOWNh+e6p+S7k+W6k+aXgei+ueeahOaMiemSruWNh+e6pyTmianlsZXvvIzlkKbliJnmn5Dkupvlip/og73kuI3og73mraPluLjkvb/nlKgnKTtcXFxcbiAgICAgICAgY29uZmlybSh7XFxcXG4gICAgICAgICAgICB0aXRsZTogJ+aPkOekui3ngrnlh7vnoa7lrprlj6/ku6Xlr7zlhaUnLFxcXFxuICAgICAgICAgICAgY29udGVudDogJ+ivt+WwneivleeCueWHu+S7k+W6k+S4u+mhteeahOWNh+e6p+S7k+W6k+aXgei+ueeahOaMiemSruWNh+e6pyTmianlsZXvvIzlkKbliJnmn5Dkupvlip/og73kuI3og73mraPluLjkvb/nlKgnLFxcXFxuICAgICAgICAgICAgY29uZmlybTogJC50b1N0cmluZygoKT0+e1xcXFxuICAgICAgICAgICAgICAgIGNvbnN0IHtnZXRBcGl9ID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3V0aWxpeT9ydWxlPemBk+mVv+S7k+W6k1Byb1xcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICBsZXQgcnVsZUhlYWQgPSAn5rW36ZiU6KeG55WM77yM572R6aG15o+S5Lu277+lanNfdXJs77+lJGhpa2VyQCc7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHVybCA9IGdldEFwaSgnaW1wb3J0VXJsJykrXFxcXFxcXCI1MTExXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICAgICAgbGV0IGltcG9ydFVybCA9ICdydWxlOi8vJytiYXNlNjRFbmNvZGUocnVsZUhlYWQrdXJsKTtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gaW1wb3J0VXJsXFxcXG4gICAgICAgICAgICB9KSxcXFxcbiAgICAgICAgICAgIGNhbmNlbDogJC50b1N0cmluZygoKT0+e1xcXFxuXFxcXG4gICAgICAgICAgICB9KSxcXFxcbiAgICAgICAgfSlcXFxcbiAgICB9XFxcXG59XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwiSW1wb3J06K+m57uGXFxcIixcXFwicGF0aFxcXCI6XFxcInJ1bGVEZXRhaWxJbXBvcnRcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG4kLmV4cG9ydHMgPSBcXFxcXFxcImhpa2VyOi8vcGFnZS9ydWxlRGV0YWlsP3J1bGU96YGT6ZW/5LuT5bqTUHJvJmlkPVxcXFxcXFwiICsgJC5pbXBvcnRQYXJhbTtcXFxcblxcXCJ9XVwiLFwicHJveHlcIjpcIlwifSIsInBpY1VybCI6Imh0dHBzOi8vaW1nMS5pbWd0cC5jb20vMjAyMy8wMi8wNy84ZXduV0UxVC5naWYiLCJ0aXRsZSI6IuOAjOeyvuWTgee+juWls+WQpy5keeOAjSJ9
DyaHzC2X,QueueSpinLock,ludaludaed,C++,Sunday 21st of May 2023 09:19:20 AM CDT,"//
// Created by ludaludaed on 08.05.2023.
//

#ifndef ALLIGATOR_SPIN_LOCK_H
#define ALLIGATOR_SPIN_LOCK_H

#include <thread>

namespace lu {
    class QueueSpinLock {
        struct Node {
            Node *next;
            bool value;

            Node() : next(nullptr), value(false) {}
        };

        friend class QueueSpinLockGuard;

    private:
        void lock(Node *node) {
            Node *prev_tail = tail_.exchange(node);
            if (prev_tail != nullptr) {
                prev_tail->next = node;
                while (!node->value) {
                    std::this_thread::yield();
                }
            }
        }

    public:
        QueueSpinLock() : tail_(nullptr) {}

    private:
        std::atomic<Node *> tail_;
    };

    class QueueSpinLockGuard {
    public:
        explicit QueueSpinLockGuard(QueueSpinLock &lock) : lock_(lock) {
            lock_.lock(&node_);
        }

        ~QueueSpinLockGuard() {
            if (node_.next != nullptr) {
                node_.next->value = true;
            }
        }

    private:
        QueueSpinLock &lock_;
        QueueSpinLock::Node node_;
    };
}

#endif //ALLIGATOR_SPIN_LOCK_H
"
YGapJFUh,lb3,maxim_shlyahtin,Python,Sunday 21st of May 2023 09:16:06 AM CDT,"from sklearn.datasets import load_iris
from sklearn.cluster import MiniBatchKMeans


def load():
    X, y = load_iris(return_X_y=True)
    return X[:100]


def train_and_predict(X, n_clusters=1, random_state=42):
    model = MiniBatchKMeans(n_clusters=n_clusters, random_state=random_state)
    model.fit(X)
    preds = model.predict(X)
    return preds


def optimal_n_clusters(X, с_clusters=1, random_state=42):
    model = MiniBatchKMeans(n_clusters=с_clusters, random_state=random_state)
    model.fit(X)
    return model.inertia_
"
Uc7FHP5n,Untitled,Derga,C++,Sunday 21st of May 2023 09:01:17 AM CDT,"//Билет 6
//Дружетвенные функции
/*
Дружественные функции - это функции, которые не являются членами класса, 
однако имеют доступ к его закрытым членам - переменным и функциям, которые имеют спецификатор private.
Для определения дружественных функций используется ключевое слово friend.
*/

#include <iostream>

class Auto {
    friend void drive(const Auto&);
    friend void setPrice(Auto&, unsigned);
public:
    Auto(std::string autoName, unsigned autoPrice) {
        name = autoName;
        price = autoPrice;
    }

    void print() {
        std::cout << name << "" : "" << price << std::endl;
    }

private:
    std::string name;   // название автомобиля
    unsigned price;  // цена автомобиля
};

void drive(const Auto& car) {
    std::cout << car.name << "" is driven"" << std::endl;
}

void setPrice(Auto& car, unsigned price) {
    car.price = price;
}

int main() {
    Auto tesla(""Tesla"", 5000);
    tesla.print();
    drive(tesla);
    setPrice(tesla, 4000);
    tesla.print();
}"
rXRAr0XH,Untitled,Arexils,YAML,Sunday 21st of May 2023 08:53:59 AM CDT,"publish:
  stage: publish
  needs: [ pytest ]
  image: docker:latest
  only:
    - master
  services:
    - docker:dind
  script:
    - docker build -t $TAG_LATEST .
    - docker login -u gitlab-ci-token --password-stdin $CI_BUILD_TOKEN $TAG_LATEST
    - printf ""${ENV}"" > .env
    - docker push $TAG_LATEST
"
nkvT7EHm,E - Crested Ibis vs Monster,Patrickmeme,C++,Sunday 21st of May 2023 08:45:27 AM CDT,"#include <iostream>
using namespace std;
 
unsigned long long INF=999999999999999999;
 
unsigned long long v[20001];
unsigned long long a[1001],b[1001];
 
int main()
{
    unsigned long long h,n,i,j,cnt,min1;
    cin>>h>>n;
    for(i=1;i<=n;i++){
        cin>>a[i]>>b[i];
    }
    for(j=0;j<=2*h;j++){
        v[j]=INF;
    }
    v[0]=0;
    for(i=1;i<=n;i++){
        for(j=0;j<=h;j++){
            cnt=0;
            if(v[j]!=INF){
                while(j+cnt*a[i]<h){
                    v[j+cnt*a[i]]=min(v[j+cnt*a[i]],v[j]+cnt*b[i]);
                    cnt++;
                }
                v[j+cnt*a[i]]=min(v[j+cnt*a[i]],v[j]+cnt*b[i]);
            }
 
        }
    }
    min1=INF;
    for(i=h;i<=2*h;i++){
        min1=min(min1,v[i]);
    }
    cout<<min1;
    return 0;
}"
SAscErEZ,Cuburi3,Patrickmeme,C++,Sunday 21st of May 2023 08:43:54 AM CDT,"#include <fstream>
#include <algorithm>
using namespace std;

ifstream cin(""cuburi3.in"");
ofstream cout(""cuburi3.out"");

struct cub{
    int lat,gre,dp,sum,vin,ind;
}v[10000];

int rasp[10000];

bool cmp(cub a,cub b){
    if(a.lat>b.lat)
        return 1;
    else if(b.lat<a.lat)
        return 0;
    else{
        if(a.gre>b.gre)
            return 1;
        else
            return 0;
    }
}

int main()
{
    int n,i,j,max1,nr,ci,l;
    cin>>n;
    for(i=0;i<n;i++){
        cin>>v[i].lat>>v[i].gre;
        v[i].ind=i+1;
    }
    sort(v,v+n,cmp);
    v[0].dp=1;v[0].sum=v[0].lat;v[0].vin=-1;
    for(i=1;i<n;i++){
        max1=v[i].lat;nr=1;
        for(j=i-1;j>=0;j--){
            if(v[j].gre>=v[i].gre && v[j].sum>max1){
                max1=v[j].sum+v[i].lat;
                nr=v[j].dp+1;
                v[i].vin=j;
            }
        }
        if(max1==v[i].lat)
            v[i].vin=-1;
        v[i].sum=max1;
        v[i].dp=nr;
    }
    max1=ci=0;
    for(i=n-1;i>=0;i--){
        if(v[i].sum>max1){
            max1=v[i].sum;
            ci=i;
        }
    }
    cout<<v[ci].dp<<"" ""<<max1<<""\n"";
    l=ci;
    i=0;
    while(l!=-1){
        rasp[i]=v[l].ind;
        i++;
        l=v[l].vin;
    }
    i--;
    while(i>=0){
        cout<<rasp[i]<<""\n"";
        i--;
    }

    return 0;
}"
NjEtQzNt,Carte2- 88 p,Patrickmeme,C++,Sunday 21st of May 2023 08:41:19 AM CDT,"#include <fstream>
#include <string>
using namespace std;

ifstream cin(""carte.in"");
ofstream cout(""carte.out"");

#define MAXSUM 1050000

int conv[128],frv[MAXSUM+1];

void atribuire(){
    string s=""0123456789abcdefghij"";
    int put=1,i;
    for(i=0;i<s.size();i++){
        conv[(int)s[i]]=put;
        put*=2;
    }
}
string v[100000];

bool ver(int i,int n,int sum){
    int cnt,j;
    cnt=0;
    if(v[i].size()==v[n-1].size()){
        cnt=0;
        for(j=0;j<v[i].size();j++){
            if((sum/conv[(int)v[i][j]])%2==0)
                cnt++;

        }
    }
    if(cnt==1)
        return 1;
    else
        return 0;
}

int main()
{
    int cer,n,i,j,max1,cnt,sum;
    string s;
    cin>>cer>>n;
    atribuire();
    if(cer==1){
        for(i=0;i<n;i++){
            cin>>s;
            sum=0;
            for(j=0;j<s.size();j++){
                sum+=conv[s[j]];
            }
            frv[sum]++;
        }
        max1=cnt=0;
        for(i=1;i<=MAXSUM;i++){
            if(frv[i]>max1){
                max1=frv[i];
                cnt=1;
            }else if(frv[i]==max1)
                cnt++;
        }
        cout<<max1<<""\n""<<cnt;
    }else{
        for(i=0;i<n;i++){
            cin>>v[i];
        }
        sum=cnt=0;
        for(j=0;j<v[n-1].size();j++){
            sum+=conv[(int)v[n-1][j]];
        }
        for(i=0;i<n-1;i++){
            cnt+=ver(i,n,sum);
        }
        cout<<cnt;
    }
    return 0;
}"
5yek1BNC,Untitled,Derga,C++,Sunday 21st of May 2023 08:31:53 AM CDT,"/*
Билет 5
  статические поля и методы класса.
  Если у нас в классе есть статическая переменная - она будет общей для всех объектов класса.
  Например с помощью статической переменной можно вести подсчет числа созданных объектов нашего класса.
*/
#include <iostream>

class Point {
public:
    Point() {
        points_counter++;
    }
    ~Point() {
        points_counter--;
    }
    double x, y;
    static int points_counter;

    static int GetPointsCount() {
        return points_counter;
    }

    
    /*
    В статическом методе класса нельзя обращаться к не статическим полям и к объекут this
    static void DoSomthing(){
    this->x = 10;
    y = 11; //тут не понятно к какому объекту класса Point мы обращаемся.
    }
    */

    static void ChangePoint(Point& point, int x, int y) {
        //тут понятно к какому объъекту класса point мы обращаемся, мы получили этот объект в качестве аргумета
        point.x = x;
        point.y = y;
    }

};

int Point::points_counter = 0;

int main(){
    Point a;
    std::cout << Point::points_counter << '\n';
    Point b;
    std::cout << Point::points_counter << '\n';
    Point c;
    std::cout << Point::points_counter << '\n';

    /*
    Так как наша переменная points_counter лежит в public области видимости - мы можем обратиться к ней напрямую и 
    поменять значение. Так мы испортим ее смысл (поэтому ее следовало бы держать в области видимости private), но 
    проиллюстрируем, что такое static переменная.
    запишем в нее другое значение в объекте с именем - a, 
    затем выведем значение этого поля в других объектах класса Point
    */
    a.points_counter = 10;
    std::cout << b.points_counter << ' ' << c.points_counter << '\n';

    /*
    Статичесие методы - методы, это например методы, 
    которые работают со статическими переменными класса или 
    вызывают внутри себя другие статические методы класса. 
    Например метод GetPointsCount() - работает со статической переменной класса Point
    Можновызывать его нессколькими способами
    */
    std::cout << Point::GetPointsCount() << '\n';
    std::cout << a.GetPointsCount() << '\n';

    //ниже два способа работы со статическим методом. Один через объект класса, другой через namespace класса
    std::cout << a.x << ' ' << a.y << '\n';
    a.ChangePoint(a, 0, 0);
    std::cout << a.x << ' ' << a.y << '\n';
    Point::ChangePoint(a, 1, 1);
    std::cout << a.x << ' ' << a.y << '\n';

    return 0;
}"
6UhX5DbZ,Starter wisielca,PrezesSmoku,Python,Sunday 21st of May 2023 08:29:08 AM CDT,"rysunki_wisielca = ["""",'''
  +---+
  |   |
      |
      |
      |
      |
=========''', '''
  +---+
  |   |
  O   |
      |
      |
      |
=========''', '''
  +---+
  |   |
  O   |
  |   |
      |
      |
=========''', '''
  +---+
  |   |
  O   |
 /|   |
      |
      |
=========''', '''
  +---+
  |   |
  O   |
 /|\  |
      |
      |
=========''', '''
  +---+
  |   |
  O   |
 /|\  |
 /    |
      |
=========''', '''
  +---+
  |   |
  O   |
 /|\  |
 / \  |
      |
=========''']"
ku5fvijt,Wisielec,PrezesSmoku,Python,Sunday 21st of May 2023 08:28:34 AM CDT,"rysunki_wisielca = ["""",'''
  +---+
  |   |
      |
      |
      |
      |
=========''', '''
  +---+
  |   |
  O   |
      |
      |
      |
=========''', '''
  +---+
  |   |
  O   |
  |   |
      |
      |
=========''', '''
  +---+
  |   |
  O   |
 /|   |
      |
      |
=========''', '''
  +---+
  |   |
  O   |
 /|\  |
      |
      |
=========''', '''
  +---+
  |   |
  O   |
 /|\  |
 /    |
      |
=========''', '''
  +---+
  |   |
  O   |
 /|\  |
 / \  |
      |
=========''']

#print(rysunki_wisielca[2])
import random
lista_hasel = [""programista"", ""obóz"", ""zakopane"",""język programowania""]

#losowanie hasła z listy
wylosowany_numer_hasla = random.randint(0, len(lista_hasel)-1)
print(wylosowany_numer_hasla)

wylosowane_haslo = lista_hasel[wylosowany_numer_hasla]
print(wylosowane_haslo)

#Wyświetlanie zakrytego hasła
liczba_nie_liter = 0
haslo_do_wyswietlenia = []
for litera in wylosowane_haslo:
    if litera.isalpha():
        haslo_do_wyswietlenia.append(""_"")
    else:
        haslo_do_wyswietlenia.append(litera)
        liczba_nie_liter += 1

#print(''.join(haslo_do_wyswietlenia))

#odgadywanie hasła
liczba_pomylek = 0
liczba_odslonietych_liter = 0
uzyte_litery = []

while liczba_odslonietych_liter < len(wylosowane_haslo)-liczba_nie_liter:
    print(''.join(haslo_do_wyswietlenia))
    print(rysunki_wisielca[liczba_pomylek])
    print(f'Użyte litery: {"","".join(uzyte_litery)}')
    wpisana_litera = input(""podaj literę: "")
    uzyte_litery.append(wpisana_litera)
    if wpisana_litera in wylosowane_haslo and not wpisana_litera in haslo_do_wyswietlenia:
        for i in range(len(wylosowane_haslo)):
            if wpisana_litera == wylosowane_haslo[i]:
                haslo_do_wyswietlenia[i] = wpisana_litera
                liczba_odslonietych_liter += 1
    else:
        liczba_pomylek+=1
        if liczba_pomylek == 7:
            print(rysunki_wisielca[liczba_pomylek])
            break

if(liczba_pomylek < 7):
    print(f""Brawo wygrałeś!!! Hasłem do zgadnięcia było '{wylosowane_haslo}'"")
else:
    print(f""Niestety przegrałeś!!! Hasłem do zgadnięcia było '{wylosowane_haslo}'"")"
qKi0Df8g,邀您一起看：我的书架-,xiaomianao666,JavaScript,Sunday 21st of May 2023 08:13:30 AM CDT,海阔视界规则分享，当前分享的是：二级页面详情￥page_detail￥我的书架-@@eyJkYXRhIjoie1wiYXNzb2NpYXRlZE1vZGVsc01hcEZvckpvaW5UYWJsZVwiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhGS1wiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhvdXRGS1wiOnt9LFwiZmllbGRzVG9TZXRUb0RlZmF1bHRcIjpbXSxcImdtdE1vZGlmaWVkXCI6MCxcImlkXCI6MCxcImxhc3RfY2hhcHRlcl9ydWxlXCI6XCJcIixcImxpc3RUb0NsZWFyQXNzb2NpYXRlZEZLXCI6W10sXCJsaXN0VG9DbGVhclNlbGZGS1wiOltdLFwicGFnZUxpc3RcIjpbe1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuS+nei1luaWh+S7tlwiLFwicGF0aFwiOlwiY29uZmlnXCIsXCJydWxlXCI6XCJqczpcXG5sZXQgbWV0aG9kO1xcbmxldCBjZmdmaWxlID0gXFxcImhpa2VyOi8vZmlsZXMvcnVsZXMvU3JjL0p1L2NvbmZpZy5qc29uXFxcIjtcXG5pZiAoZmlsZUV4aXN0KGNmZ2ZpbGUpKSB7XFxuICAgIGV2YWwoXFxcImxldCBKdWNvbmZpZz1cXFwiICsgZmV0Y2goY2ZnZmlsZSkgKyBcXFwiO1xcXCIpO1xcbiAgICBtZXRob2QgPSBKdWNvbmZpZ1tcXFwi5L6d6LWWXFxcIl07XFxufVxcbiQuZXhwb3J0cy5tZXRob2QgPSBtZXRob2Q7XFxuJC5leHBvcnRzLnZlcnNpb24gPSAxMDtcIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuaOpeWPo+e8k+WtmFwiLFwicGF0aFwiOlwiamlla291XCIsXCJydWxlXCI6XCJqczpcXG5sZXQgbWV0aG9kO1xcbmxldCBjZmdmaWxlID0gXFxcImhpa2VyOi8vZmlsZXMvcnVsZXMvU3JjL0p1L2NvbmZpZy5qc29uXFxcIjtcXG5pZiAoZmlsZUV4aXN0KGNmZ2ZpbGUpKSB7XFxuICAgIGV2YWwoXFxcImxldCBKdWNvbmZpZz1cXFwiICsgZmV0Y2goY2ZnZmlsZSkgKyBcXFwiO1xcXCIpO1xcbiAgICBtZXRob2QgPSBKdWNvbmZpZ1tcXFwi5L6d6LWWXFxcIl0ucmVwbGFjZShcXFwiLmpzXFxcIixcXFwiMi5qc1xcXCIpO1xcbn1cXG5yZXF1aXJlKG1ldGhvZCk7XFxuXFxuJC5leHBvcnRzID0ge1xcbiAgICDkuIDnuqc6IOS4gOe6pyxcXG4gICAg5LqM57qnOiDkuoznuqcsXFxuICAgIOWFrOWFsTog5YWs5YWxLFxcbiAgICDlsZ7mgKc6IOWxnuaAp1xcbn1cIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuS6keWPo+S7pOWvvOWFpVwiLFwicGF0aFwiOlwiaW1wb3J0XCIsXCJydWxlXCI6XCJqczpcXG5mdW5jdGlvbiBjbG91ZGltcG9ydCgpIHtcXG4gICAgbGV0IHJlbW90ZWZpbGU7XFxuICAgIGxldCBjZmdmaWxlID0gXFxcImhpa2VyOi8vZmlsZXMvcnVsZXMvU3JjL0p1L2NvbmZpZy5qc29uXFxcIjtcXG4gICAgaWYgKGZpbGVFeGlzdChjZmdmaWxlKSkge1xcbiAgICAgICAgZXZhbChcXFwibGV0IEp1Y29uZmlnPVxcXCIgKyBmZXRjaChjZmdmaWxlKSArIFxcXCI7XFxcIik7XFxuICAgICAgICByZW1vdGVmaWxlID0gSnVjb25maWdbXFxcIuS+nei1llxcXCJdLm1hdGNoKC9odHRwKHMpPzpcXFxcL1xcXFwvLipcXFxcLy8pWzBdICsgJ1NyY0p1U2V0LmpzJztcXG4gICAgfVxcbiAgICBpZihyZW1vdGVmaWxlKXtcXG4gICAgICAgIHJlcXVpcmUocmVtb3RlZmlsZSk7XFxuICAgICAgICByZXR1cm4gSllpbXBvcnQoaW5wdXQpO1xcbiAgICB9ZWxzZXtcXG4gICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/msqHmnInnlKjov4fogZrpmIXiiJrlsI/nqIvluo/vvJ9cXFwiO1xcbiAgICB9XFxufVxcbiQuZXhwb3J0cyA9IGNsb3VkaW1wb3J0KCk7XCJ9XSxcInBhcmFtc1wiOlwie1xcXCJjbHNcXFwiOlxcXCJjYXNlbGlzdFxcXCIsXFxcImltZ1xcXCI6XFxcImh0dHBzOi8vbGFubWVpZ3VvamlhbmcuY29tL3R1Ymlhby9tb3JlLzEyOS5wbmdcXFwiLFxcXCJsaW5lVmlzaWJsZVxcXCI6ZmFsc2V9XCIsXCJzYXZlZFwiOmZhbHNlLFwidGl0bGVcIjpcIuiBmumYheKImlwiLFwidmVyc2lvblwiOjAsXCJ1cmxcIjpcImhpa2VyOi8vZW1wdHkjaW1tZXJzaXZlVGhlbWUjI2F1dG9DYWNoZSM7Z2V0O1VURi04O3tVc2VyLUFnZW50QE1vemlsbGEvNS4wIChXaW5kb3dzIE5UIDEwLjDvvJvvvJsgV2luNjTvvJvvvJsgeDY0KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvMTA1LjAuMC4wIFNhZmFyaS81MzcuMzZ9XCIsXCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwiZmluZF9ydWxlXCI6XCJqczooXFxuKCkgPT4ge1xcbiAgICByZXF1aXJlKGNvbmZpZy7kvp3otZYpO1xcbiAgICBlcmppKCk7XFxuICAgIHB1dE15VmFyKFxcXCJTcmNCb29rQ2FzZVxcXCIsIFxcXCIxXFxcIik7XFxufVxcbikoKVwiLFwiZ3JvdXBcIjpcIumYheivu1wiLFwidWFcIjpcInBjXCIsXCJwcmVSdWxlXCI6XCJpZiAoIWNvbmZpZy7kvp3otZYpIHtcXG4gICAgLy/ov5znqIvkvp3otZbntKLlvJXmlofku7bku6PnkIblnLDlnYDliJfooahcXG4gICAgbGV0IHJlcXVpcmVsaXN0ID0gWydodHRwczovL3Jhdy5pcWlxLmlvLycsICdodHRwczovL2docHJveHkubmV0L2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS8nLCAnaHR0cHM6Ly9naHByb3h5LmNvbS9odHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vJywgJ2h0dHBzOi8vY2RuLnN0YXRpY2FseS5jb20vZ2gvJywgJ2h0dHBzOi8vZ2l0aHViLmpldm9ucy52aXAvaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tLyddXFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVxdWlyZWxpc3QubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIHRyeSB7IC8v6L+c56iL5L6d6LWW57Si5byVXFxuICAgICAgICAgICAgcmVxdWlyZShyZXF1aXJlbGlzdFtpXSArICdzcmM0ODU5Nzk2Mi9oay9KdS9yZXF1aXJlLmpzJyk7XFxuICAgICAgICAgICAgaWYgKHJlbHlmaWxlKSB7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgICBsb2coZS5tZXNzYWdlKTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBpbml0Q29uZmlnKHtcXG4gICAgICAgIOS+nei1ljogcmVseWZpbGVcXG4gICAgfSk7XFxuICAgIGxldCBjZmdmaWxlID0gXFxcImhpa2VyOi8vZmlsZXMvcnVsZXMvU3JjL0p1L2NvbmZpZy5qc29uXFxcIjtcXG4gICAgaWYgKGZpbGVFeGlzdChjZmdmaWxlKSkge1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICBldmFsKFxcXCJsZXQgSnVjb25maWc9XFxcIiArIGZldGNoKGNmZ2ZpbGUpICsgXFxcIjtcXFwiKTtcXG4gICAgICAgICAgICBKdWNvbmZpZ1tcXFwi5L6d6LWWXFxcIl0gPSByZWx5ZmlsZS5tYXRjaCgvaHR0cChzKT86XFxcXC9cXFxcLy4qXFxcXC8vKVswXSArICdTcmNKdU1ldGhvZC5qcyc7XFxuICAgICAgICAgICAgd3JpdGVGaWxlKGNmZ2ZpbGUsIEpTT04uc3RyaW5naWZ5KEp1Y29uZmlnKSk7XFxuICAgICAgICB9IGNhdGNoIChlKSB7fVxcbiAgICB9XFxufVxcbi8vYnku5biF4oiaYOS6uuaJjSDogZrmqKHmnb/vvIFcIixcInBhZ2VzXCI6XCJbe1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5L6d6LWW5paH5Lu2XFxcIixcXFwicGF0aFxcXCI6XFxcImNvbmZpZ1xcXCIsXFxcInJ1bGVcXFwiOlxcXCJqczpcXFxcbmxldCBtZXRob2Q7XFxcXG5sZXQgY2ZnZmlsZSA9IFxcXFxcXFwiaGlrZXI6Ly9maWxlcy9ydWxlcy9TcmMvSnUvY29uZmlnLmpzb25cXFxcXFxcIjtcXFxcbmlmIChmaWxlRXhpc3QoY2ZnZmlsZSkpIHtcXFxcbiAgICBldmFsKFxcXFxcXFwibGV0IEp1Y29uZmlnPVxcXFxcXFwiICsgZmV0Y2goY2ZnZmlsZSkgKyBcXFxcXFxcIjtcXFxcXFxcIik7XFxcXG4gICAgbWV0aG9kID0gSnVjb25maWdbXFxcXFxcXCLkvp3otZZcXFxcXFxcIl07XFxcXG59XFxcXG4kLmV4cG9ydHMubWV0aG9kID0gbWV0aG9kO1xcXFxuJC5leHBvcnRzLnZlcnNpb24gPSAxMDtcXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLmjqXlj6PnvJPlrZhcXFwiLFxcXCJwYXRoXFxcIjpcXFwiamlla291XFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxubGV0IG1ldGhvZDtcXFxcbmxldCBjZmdmaWxlID0gXFxcXFxcXCJoaWtlcjovL2ZpbGVzL3J1bGVzL1NyYy9KdS9jb25maWcuanNvblxcXFxcXFwiO1xcXFxuaWYgKGZpbGVFeGlzdChjZmdmaWxlKSkge1xcXFxuICAgIGV2YWwoXFxcXFxcXCJsZXQgSnVjb25maWc9XFxcXFxcXCIgKyBmZXRjaChjZmdmaWxlKSArIFxcXFxcXFwiO1xcXFxcXFwiKTtcXFxcbiAgICBtZXRob2QgPSBKdWNvbmZpZ1tcXFxcXFxcIuS+nei1llxcXFxcXFwiXS5yZXBsYWNlKFxcXFxcXFwiLmpzXFxcXFxcXCIsXFxcXFxcXCIyLmpzXFxcXFxcXCIpO1xcXFxufVxcXFxucmVxdWlyZShtZXRob2QpO1xcXFxuXFxcXG4kLmV4cG9ydHMgPSB7XFxcXG4gICAg5LiA57qnOiDkuIDnuqcsXFxcXG4gICAg5LqM57qnOiDkuoznuqcsXFxcXG4gICAg5YWs5YWxOiDlhazlhbEsXFxcXG4gICAg5bGe5oCnOiDlsZ7mgKdcXFxcbn1cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLkupHlj6Pku6Tlr7zlhaVcXFwiLFxcXCJwYXRoXFxcIjpcXFwiaW1wb3J0XFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxuZnVuY3Rpb24gY2xvdWRpbXBvcnQoKSB7XFxcXG4gICAgbGV0IHJlbW90ZWZpbGU7XFxcXG4gICAgbGV0IGNmZ2ZpbGUgPSBcXFxcXFxcImhpa2VyOi8vZmlsZXMvcnVsZXMvU3JjL0p1L2NvbmZpZy5qc29uXFxcXFxcXCI7XFxcXG4gICAgaWYgKGZpbGVFeGlzdChjZmdmaWxlKSkge1xcXFxuICAgICAgICBldmFsKFxcXFxcXFwibGV0IEp1Y29uZmlnPVxcXFxcXFwiICsgZmV0Y2goY2ZnZmlsZSkgKyBcXFxcXFxcIjtcXFxcXFxcIik7XFxcXG4gICAgICAgIHJlbW90ZWZpbGUgPSBKdWNvbmZpZ1tcXFxcXFxcIuS+nei1llxcXFxcXFwiXS5tYXRjaCgvaHR0cChzKT86XFxcXFxcXFwvXFxcXFxcXFwvLipcXFxcXFxcXC8vKVswXSArICdTcmNKdVNldC5qcyc7XFxcXG4gICAgfVxcXFxuICAgIGlmKHJlbW90ZWZpbGUpe1xcXFxuICAgICAgICByZXF1aXJlKHJlbW90ZWZpbGUpO1xcXFxuICAgICAgICByZXR1cm4gSllpbXBvcnQoaW5wdXQpO1xcXFxuICAgIH1lbHNle1xcXFxuICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+ayoeacieeUqOi/h+iBmumYheKImuWwj+eoi+W6j++8n1xcXFxcXFwiO1xcXFxuICAgIH1cXFxcbn1cXFxcbiQuZXhwb3J0cyA9IGNsb3VkaW1wb3J0KCk7XFxcIn1dXCJ9IiwicGljVXJsIjoiaHR0cHM6Ly9sYW5tZWlndW9qaWFuZy5jb20vdHViaWFvL21vcmUvMTI5LnBuZyIsInRpdGxlIjoi5oiR55qE5Lmm5p62LSJ9
ETNu2uFG,game_finish.py,DrAungWinHtut,Python,Sunday 21st of May 2023 08:10:34 AM CDT,"import random

coin = 0  # global variable,


def SaveFile():
    global coin
    game_file = open('gamedata.txt', 'w')  # w - write (override) , a - append
    game_file.write('\n'+str(coin))  # str - string - text
    game_file.close()


def LoadFile():
    global coin
    game_file = open('gamedata.txt', 'r')  # r - read only
    data = game_file.read().rstrip()
    coin = eval(data)
    game_file.close()
    Game()
# Program Start Here


def Menu():
    global coin
    coin = eval(input('how much coin?: '))
    while (1):
        print('0-Exit')
        print('1-Play Game')
        print('2-Save Game')
        print('3-Load saved Game')
        ans = input('please enter your choice: ')
        if ans == '0':
            exit()
        elif ans == '1':
            print('Playing Game now...')
            Game()
        elif ans == '2':
            print('Saving now....')
            SaveFile()
        elif ans == '3':
            print('Loading Game...')
            LoadFile()
        else:
            print('Wrong choice, only (0,1,2), please try again: ')


def Game():
    global coin
    print(f'\n\nYou have {coin} coins')
    bet = eval(input('how much coin to bet: '))

    if bet > coin:
        bet = coin
        print('you cannot bet more than you have')
        print(f'your bet become: {bet}')

    input('press ENTER to roll the dice for PLAYER: ')
    player = random.randint(1, 6)
    print(f'your number is : {player}')

    input('press ENTER to roll the dice for COMPUTER: ')
    computer = random.randint(1, 6)
    print(f'computer number is : {computer}')

    if computer > player:
        coin = coin - bet
        print('Computer wins')
        print(f'Your coin is: {coin}')
        if coin == 0:
            ans1 = input('you lost everything! want to buy more coin: y\\n: ')
            if ans1 == 'y':
                coin = eval(input('how much coin?: '))
            else:
                print('No money: No more game! Bye bye')
                exit()

    elif player > computer:
        coin = coin + bet
        print('Player wins')
        print(f'Your coin is: {coin}')

    else:
        print('Draw')
        print(f'Your coin is: {coin}')


# Program Start Here
Menu()
"
A1chLjQc,Untitled,Derga,C++,Sunday 21st of May 2023 07:48:42 AM CDT,"/*
Билет 5
  this

С помощью этого слова можно присваивать значения переменным внутри класса. Дальше пример
*/

class MyClass {
    int x;

    void foo() {
        x = 6;       //эти две строки делают одно и то же
        this->x = 5; 
    }

    void foo() const {
         x = 7; // тут ошибка, почему?
    }

    void foo(int x) {// тут совпадает имя аргумента функции - x и поля класса x. 
        this->x = x; // использование this-> позволяет устранить неоднозначность
    }

    MyClass& operator=(const MyClass& b) {
        x = b.x;
        return *this; // многе перегруженные операторы возвращают *this, например оператор копирующего присваивания
        //Тут мы находимся внутри объекта класса MyClass, инициализируем его поле x и затем
        //возвращаем разыменованный указатель на объект класса MyClass внутри которого мы находимся. 
    }
};"
AgZ5QM5e,Untitled,Derga,C++,Sunday 21st of May 2023 07:35:22 AM CDT,"/*
Билет 5
  Константные методы

Методом класса называют функцию из класса. 
Ниже класс Time - в нем хранится время - часы, минуты, секунды.
Константный метод не меняет состояние класса. Это добавляет удобства и безопасности в работе с классами.

Например - в классе Time есть константные методы GetHours() const, GetMinutes() const -
они не меняют оюъект класса, а только возвращают значения из соответствующих полей.

Также в классе есть метод AddSeconds(int s) - этот метод меняет состояние объекта класса, 
добавляет секунды в поле seconds. Так как этот метод меняет состояние - он не может быть константным 
и также не может работать с константными объектами класса.
*/

class Time {
private:
    int hours, minutes, seconds;

public:
    Time(int h, int m, int s) : hours(h), minutes(m), seconds(s) {}

    int GetHours() const {
        return hours;
    }
    int GetMinutes() const {
        return minutes;
    }
    int GetSeconds() const {
        return seconds;
    }

    void AddSeconds(int s) {
        seconds += s; //понятно, что секунд не может быть больше 60, 
                      //не настраиваем этот нюанс, так как разбираем тут другую тему - константность методов
    }
};

#include <iostream>

int main() {
    Time t(10, 8, 0);  // 10:08:00
    t.AddSeconds(40);  // 10:08:40

    // Константная ссылка: через псевдоним cref объект нельзя изменять
    const Time& cref = t;

    // Константную функцию из класса вызвать можно
    std::cout << cref.GetHours() << ""\n"";  // OK

    // Неконстантную функцию из класса нельзя вызвать у константной сущности
    cref.AddSeconds(20);  // ошибка компиляции
}"
2AsZb032,Untitled,JackOUT,Java,Sunday 21st of May 2023 07:34:12 AM CDT,"package games.coob.portals.model;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import org.bukkit.block.Block;
import org.mineacademy.fo.ReflectionUtil;

import java.lang.reflect.Constructor;

@RequiredArgsConstructor
public enum PortalType {

	TARGETED(Targeted.class),
	COSMIC(Cosmic.class),
	ROULETTE(Roulette.class);

	@Getter
	private final Class<? extends PortalData> instanceClass;

	protected <T extends PortalData> T instantiate(final String id, final Block block) {
		final Constructor<?> constructor = ReflectionUtil.getConstructor(this.instanceClass, String.class, Block.class, PortalType.class);

		return (T) ReflectionUtil.instantiate(constructor, id, block, this);
	}
}
"
MqL5i0k9,Untitled,JackOUT,Java,Sunday 21st of May 2023 07:33:39 AM CDT,"package games.coob.portals;

import games.coob.portals.model.PortalData;
import games.coob.portals.settings.Settings;
import games.coob.portals.task.CosmicTeleportTask;
import games.coob.portals.task.HologramTask;
import games.coob.portals.task.RouletteTeleportTask;
import games.coob.portals.task.TargetedTeleportTask;
import org.bukkit.Bukkit;
import org.mineacademy.fo.Common;
import org.mineacademy.fo.MinecraftVersion;
import org.mineacademy.fo.plugin.SimplePlugin;

/**
 * PluginTemplate is a simple template you can use every time you make
 * a new plugin. This will save you time because you no longer have to
 * recreate the same skeleton and features each time.
 * <p>
 * It uses Foundation for fast and efficient development process.
 */
public final class AnchorPortals extends SimplePlugin {

	/**
	 * Automatically perform login ONCE when the plugin starts.
	 */
	@Override
	protected void onPluginStart() {
		Common.setLogPrefix(""[AnchorPortals]"");

		if (!MinecraftVersion.atLeast(MinecraftVersion.V.v1_16)) {
			Common.log(""Disabled because the version you are using is too old."");
			this.setEnabled(false);
		}

		if (!Bukkit.getPluginManager().isPluginEnabled(""DecentHolograms"")) {
			Common.log(""Disabled do to DecentHolograms not being installed or not enabled."");
			this.setEnabled(false);
		}
	}

	@Override
	protected void onPluginStop() {
		//	Hologram.deleteAll();
	}

	@Override
	protected void onPluginReload() {
		//	Hologram.deleteAll();
	}

	/**
	 * Automatically perform login when the plugin starts and each time it is reloaded.
	 */
	@Override
	protected void onReloadablesStart() {
		// You can check for necessary plugins and disable loading if they are missing
		PortalData.loadPortals();

		Common.runTimer(Settings.PortalSection.CHARGE_SPEED, new HologramTask());
		Common.runTimer(5, new RouletteTeleportTask());
		Common.runTimer(5, new CosmicTeleportTask());
		Common.runTimer(5, new TargetedTeleportTask());

		for (final PortalData portalData : PortalData.getPortals()) {
			portalData.setChargePercentage(100);
		}

		// Uncomment to load variables
		// Variable.loadVariables();

		//
		// Add your own plugin parts to load automatically here
		// Please see @AutoRegister for parts you do not have to register manually
		//
	}

	/* ------------------------------------------------------------------------------- */
	/* Static */
	/* ------------------------------------------------------------------------------- */

	/**
	 * Return the instance of this plugin, which simply refers to a static
	 * field already created for you in SimplePlugin but casts it to your
	 * specific plugin instance for your convenience.
	 *
	 * @return
	 */
	public static AnchorPortals getInstance() {
		return (AnchorPortals) SimplePlugin.getInstance();
	}
}
"
AUL0Knac,DBManager.java,Vitrecan,Java,Sunday 21st of May 2023 07:25:17 AM CDT,"package uts.isd.model.dao;

import uts.isd.model.User;
import java.util.ArrayList;
import java.sql.*;
import java.util.List;
import uts.isd.model.Order;
import uts.isd.model.Staff;
import uts.isd.model.Product;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;

/**
 *
 * @author Richard Renshaw, Vincent Tran
 */

public class DBManager {

    private Statement st;
    private Connection conn;

    public DBManager(Connection conn) throws SQLException {
        st = conn.createStatement();
    }

    public User findUser(String email, String password) throws SQLException {
        String fetch = ""SELECT * FROM APP.Users WHERE Email = '"" + email + ""' AND Password = '"" + password + ""'"";
        ResultSet rs = st.executeQuery(fetch);

        while (rs.next()) {
            String userEmail = rs.getString(""Email"");
            String userPassword = rs.getString(""Password"");

            if (userEmail.equals(email) && userPassword.equals(password)) {
                String userFirstName = rs.getString(""FirstName"");
                String userLastName = rs.getString(""LastName"");
                String userMobile = rs.getString(""MobileNumber"");
                return new User(userFirstName, userLastName, userMobile, userEmail, userPassword);
            }
        }

        return null;
    }

    public void addUser(String firstName, String lastName, String mobileNumber, String email, String password) throws SQLException {
        String insertQuery = ""INSERT INTO APP.Users (FirstName, LastName, MobileNumber, Email, Password) ""
                + ""VALUES ('"" + firstName + ""', '"" + lastName + ""', "" + Integer.parseInt(mobileNumber) + "", '"" + email + ""', '"" + password + ""')"";

        st.executeUpdate(insertQuery);
    }

    public void updateUser(String firstName, String lastName, String mobileNumber, String email, String password) throws SQLException {
        st.executeUpdate(""UPDATE APP.Users SET FIRST_NAME='"" + firstName + ""', LAST_NAME='"" + lastName + ""', MOBILE_NUMBER='"" + mobileNumber + ""', PASSWORD='"" + password + ""' WHERE EMAIL='"" + email + ""'"");
    }

    public void deleteUser(String email) throws SQLException {
        st.executeUpdate(""DELETE FROM APP.Users WHERE EMAIL='"" + email + ""'"");
    }

    public ArrayList<User> fetchUsers() throws SQLException {
        String fetch = ""select * from APP.Users"";

        ResultSet rs = st.executeQuery(fetch);
        ArrayList<User> temp = new ArrayList();

        while (rs.next()) {
            String firstName = rs.getString(1);
            String lastName = rs.getString(2);
            String mobileNumber = rs.getString(3);
            String email = rs.getString(4);
            String password = rs.getString(5);
            temp.add(new User(firstName, lastName, mobileNumber, email, password));
        }
        return temp;
    }

    public boolean checkUser(String email, String password) throws SQLException {
        String fetch = ""select * from APP.Users WHERE EMAIL = '"" + email + ""' AND PASSWORD='"" + password + ""'"";
        ResultSet rs = st.executeQuery(fetch);

        while (rs.next()) {
            String userEmail = rs.getString(4);
            String userPassword = rs.getString(5);
            if (userEmail.equals(email) && userPassword.equals(password)) {
                return true;
            }
        }
        return false;
    }

    public Staff findStaff(String name, String position) throws SQLException {
        String fetch = ""select * from App.Staffs Where name = '"" + name + ""' and position='"" + position + ""'"";
        ResultSet rs = st.executeQuery(fetch);

        while (rs.next()) {
            String staffName = rs.getString(1);
            String staffPosition = rs.getString(3);

            if (staffName.equals(name) && staffPosition.equals(position)) {
                String staffEmail = rs.getString(2);
                String staffAddress = rs.getString(4);
                return new Staff(staffName, staffEmail, staffPosition, staffAddress);
            }
        }

        return null;
    }

    public void addStaff(String name, String email, String position, String address) throws SQLException {
        st.executeUpdate(""Insert into App.Staffs "" + ""values ( '"" + name + ""','"" + email + ""','"" + position + ""','"" + address + ""')"");
    }

    public void updateStaff(String name, String email, String position, String address) throws SQLException {
        st.executeUpdate(""Update App.Staffs Set staff_name= '"" + name + ""', email='"" + email + ""', staff_position='"" + position + ""', staff_addres='"" + address + ""'"");
    }

    public void deleteStaff(String name) throws SQLException {
        st.executeUpdate(""Delete From APP.Staffs Where staff_name='"" + name + ""'"");
    }

    public ArrayList<Staff> fetchStaffs() throws SQLException {
        String fetch = ""select * from APP.Staffs"";

        ResultSet rs = st.executeQuery(fetch);
        ArrayList<Staff> temp = new ArrayList();

        while (rs.next()) {
            String name = rs.getString(1);
            String email = rs.getString(2);
            String position = rs.getString(3);
            String address = rs.getString(4);
            temp.add(new Staff(name, email, position, address));
        }
        return temp;
    }

    public void addProduct(Product product) throws SQLException {
        String query = ""INSERT INTO APP.PRODUCTS (productID, supplierEmail, productName, productType, productPrice, productStock) ""
                + ""VALUES ("" + product.getProductID() + "", '"" + product.getSupplierEmail() + ""', '"" + product.getProductName() + ""', '"" + product.getProductType() + ""', "" + product.getProductPrice() + "", "" + product.getProductStock() + "")"";
        st.executeUpdate(query);
    }
    
    public List<Order> getOrders() throws SQLException {
        String sql = ""SELECT * FROM APP.ORDERS"";
        PreparedStatement ps = st.getConnection().prepareStatement(sql);
        ResultSet rs = ps.executeQuery();
        List<Order> orders = new ArrayList<>();
        while (rs.next()) {
            int orderNumber = rs.getInt(""ORDERID"");
            String device = rs.getString(""DEVICE"");
            int quantity = rs.getInt(""ORDERAMOUNT"");
            java.util.Date date = new java.util.Date(rs.getDate(""DATE"").getTime());
            orders.add(new Order(orderNumber, device, quantity, new java.sql.Date(date.getTime())));
        }
        return orders;
    }
    
    public void createOrder(Order order) throws SQLException {
        String checkSql = ""SELECT ORDERAMOUNT FROM APP.ORDERS WHERE DEVICE = ?"";
        PreparedStatement checkPs = st.getConnection().prepareStatement(checkSql);
        checkPs.setString(1, order.getDevice());
        ResultSet rs = checkPs.executeQuery();
        if (rs.next()) {
            int stock = rs.getInt(""ORDERAMOUNT"");
            if (stock < order.getQuantity()) {
                throw new SQLException(""Not enough stock for device: "" + order.getDevice());
            }
        } else {
            throw new SQLException(""Device not found: "" + order.getDevice());
        }

        String sql = ""INSERT INTO APP.ORDERS (DEVICE, ORDERAMOUNT, DATE) VALUES (?, ?, ?)"";
        PreparedStatement ps = st.getConnection().prepareStatement(sql);
        ps.setString(1, order.getDevice());
        ps.setInt(2, order.getQuantity());
        ps.setDate(3, new java.sql.Date(order.getDate().getTime()));
        ps.executeUpdate();

        sql = ""UPDATE APP.ORDERS SET ORDERAMOUNT = ORDERAMOUNT - ? WHERE DEVICE = ?"";
        ps = st.getConnection().prepareStatement(sql);
        ps.setInt(1, order.getQuantity());
        ps.setString(2, order.getDevice());
        ps.executeUpdate();
    }

    public void updateOrder(Order order) throws SQLException {
        String sql = ""UPDATE APP.ORDERS SET DEVICE=?, ORDERAMOUNT=?, DATE=? WHERE ORDERID=?"";
        PreparedStatement ps = st.getConnection().prepareStatement(sql);
        ps.setString(1, order.getDevice());
        ps.setInt(2, order.getQuantity());
        ps.setDate(3, new java.sql.Date(order.getDate().getTime()));
        ps.setInt(4, order.getOrderNumber());
        ps.executeUpdate();
    }
    
    public void cancelOrder(int orderNumber) throws SQLException {
        String sql = ""UPDATE APP.ORDERS SET ORDERSTATUS='Cancelled' WHERE ORDERID=?"";
        PreparedStatement ps = st.getConnection().prepareStatement(sql);
        ps.setInt(1, orderNumber);
        ps.executeUpdate();

        sql = ""SELECT DEVICE, ORDERAMOUNT FROM APP.ORDERS WHERE ORDERID=?"";
        ps = st.getConnection().prepareStatement(sql);
        ps.setInt(1, orderNumber);
        ResultSet rs = ps.executeQuery();
        if (rs.next()) {
            String device = rs.getString(""DEVICE"");
            int quantity = rs.getInt(""ORDERAMOUNT"");

            sql = ""UPDATE APP.ORDERS SET ORDERAMOUNT = ORDERAMOUNT + ? WHERE DEVICE = ?"";
            ps = st.getConnection().prepareStatement(sql);
            ps.setInt(1, quantity);
            ps.setString(2, device);
            ps.executeUpdate();
        }
    }
    
    public void submitOrder(int orderNumber) throws SQLException {
        String sql = ""UPDATE APP.ORDERS SET ORDERSTATUS='Submitted' WHERE ORDERID=?"";
        PreparedStatement ps = st.getConnection().prepareStatement(sql);
        ps.setInt(1, orderNumber);
        ps.executeUpdate();
    }
    
    public List<Order> searchOrders(String orderNumber, String date) throws SQLException {
        String sql = ""SELECT * FROM APP.ORDERS WHERE ORDERID=? OR DATE=?"";
        PreparedStatement ps = st.getConnection().prepareStatement(sql);
        ps.setString(1, orderNumber);
        ps.setString(2, date);
        ResultSet rs = ps.executeQuery();
        List<Order> orders = new ArrayList<>();
        while (rs.next()) {
            int orderNum = rs.getInt(""ORDERID"");
            String device = rs.getString(""DEVICE"");
            int quantity = rs.getInt(""ORDERAMOUNT"");
            java.util.Date orderDate = new java.util.Date(rs.getDate(""DATE"").getTime());
            orders.add(new Order(orderNum, device, quantity, new java.sql.Date(orderDate.getTime())));
        }
        return orders;
    }

    public Product findProductByID(int productID) throws SQLException {
        String query = ""SELECT * FROM APP.Products WHERE productID = "" + productID;
        ResultSet rs = st.executeQuery(query);

        Product product = null;
        if (rs.next()) {
            String productName = rs.getString(""productName"");
            String supplierEmail = rs.getString(""supplierEmail"");
            double productPrice = rs.getDouble(""productPrice"");
            String productType = rs.getString(""productType"");
            int productStock = rs.getInt(""productStock"");

            product = new Product(productID, productName, supplierEmail, productPrice, productType, productStock);
        }

        return product;
    }

    public List<Product> getAllProducts() throws SQLException {
        List<Product> products = new ArrayList<>();
        String query = ""SELECT * FROM APP.Products"";
        ResultSet rs = st.executeQuery(query);

        while (rs.next()) {
            int productID = rs.getInt(""productID"");
            String productName = rs.getString(""productName"");
            String supplierEmail = rs.getString(""supplierEmail"");
            double productPrice = rs.getDouble(""productPrice"");
            String productType = rs.getString(""productType"");
            int productStock = rs.getInt(""productStock"");

            Product product = new Product(productID, productName, supplierEmail, productPrice, productType, productStock);
            products.add(product);
        }

        return products;
    }
}"
UVh0rmWx,Untitled,askador,YAML,Sunday 21st of May 2023 07:23:28 AM CDT,"apiVersion: apps/v1
kind: Deployment
metadata:
  name: achievementsbot-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: achievementsbot
  template:
    metadata:
      labels:
        app: achievementsbot
    spec:
      containers:

        - name: achievementsbot
          image: achievementsbot
          imagePullPolicy: Never
          ports:
            - containerPort: 80

        - name: dbpostgre
          image: postgres:14.1
          env:
            - name: POSTGRES_DB
              value: ${DB_NAME}
            - name: POSTGRES_USER
              value: ${DB_USER}
            - name: POSTGRES_PASSWORD
              value: ${DB_PASSWORD}
          ports:
            - containerPort: 5432
          volumeMounts:
            - name: pg-data
              mountPath: /var/lib/postgresql/data

        - name: dbredis
          image: redis:6.2-alpine
          env:
            - name: REDIS_HOST
              value: ${REDIS_HOST}
            - name: REDIS_PASSWORD
              value: ${REDIS_PASSWORD}
          ports:
            - containerPort: 6379
          volumeMounts:
            - name: redis-data
              mountPath: /data
      volumes:
        - name: pg-data
          emptyDir: {}
        - name: redis-data
          emptyDir: {}"
dPwheSBW,Order.java,Vitrecan,Java,Sunday 21st of May 2023 07:23:24 AM CDT,"/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package uts.isd.model;

/**
 *
 * @author Vincent Tran
 */
import java.sql.Date;

    public class Order {
    private int orderNumber;
    private String device;
    private int quantity;
    private Date date;

    public Order(int orderNumber, String device, int quantity, Date date) {
        this.orderNumber = orderNumber;
        this.device = device;
        this.quantity = quantity;
        this.date = date;
    }

    public int getOrderNumber() {
    	return orderNumber;
    }

    public void setOrderNumber(int orderNumber) {
    	this.orderNumber = orderNumber;
    }

    public String getDevice() {
    	return device;
    }

    public void setDevice(String device) {
    	this.device = device;
    }

    public int getQuantity() {
    	return quantity;
    }

    public void setQuantity(int quantity) {
    	this.quantity = quantity;
    }

    public Date getDate() {
    	return date;
    }

    public void setDate(Date date) {
    	this.date = date;
    }
}"
AtftrDsj,UpdateOrderServlet.java,Vitrecan,Java,Sunday 21st of May 2023 07:22:38 AM CDT,"/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package uts.isd.controller;

/**
 *
 * @author Vincent Tran
 */
import uts.isd.model.Order;
import uts.isd.model.dao.DBConnector;
import uts.isd.model.dao.DBManager;
import java.io.IOException;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class UpdateOrderServlet extends HttpServlet {
    private DBManager dbManager;

    @Override
    public void init() {
        try {
            DBConnector db = new DBConnector();
            Connection conn = db.openConnection();
            dbManager = new DBManager(conn);
        } catch (ClassNotFoundException | SQLException e) {
            Logger.getLogger(UpdateOrderServlet.class.getName()).log(Level.SEVERE, null, e);
        }
    }

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        int orderNumber = Integer.parseInt(request.getParameter(""orderNumber""));
        String device = request.getParameter(""device"");
        int quantity = Integer.parseInt(request.getParameter(""quantity""));
        Order order = new Order(orderNumber, device, quantity, null);
        try {
            dbManager.updateOrder(order);
            request.getSession().setAttribute(""order"", order);
            response.sendRedirect(""order.jsp"");
        } catch (IOException | SQLException e) {
            Logger.getLogger(UpdateOrderServlet.class.getName()).log(Level.SEVERE, null, e);
        }
    }
}"
pYq0RRtY,SubmitOrderServlet.java,Vitrecan,Java,Sunday 21st of May 2023 07:21:45 AM CDT,"/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package uts.isd.controller;

/**
 *
 * @author Vincent Tran
 */
import uts.isd.model.dao.DBConnector;
import uts.isd.model.dao.DBManager;
import java.io.IOException;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class SubmitOrderServlet extends HttpServlet {
    private DBManager dbManager;

    @Override
    public void init() {
        try {
            DBConnector db = new DBConnector();
            Connection conn = db.openConnection();
            dbManager = new DBManager(conn);
        } catch (ClassNotFoundException | SQLException e) {
            Logger.getLogger(SubmitOrderServlet.class.getName()).log(Level.SEVERE, null, e);
        }
    }

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        int orderNumber = Integer.parseInt(request.getParameter(""orderNumber""));
        try {
            dbManager.submitOrder(orderNumber);
            request.getSession().removeAttribute(""order"");
            response.sendRedirect(""order.jsp"");
        } catch (SQLException e) {
            Logger.getLogger(SubmitOrderServlet.class.getName()).log(Level.SEVERE, null, e);
        }
    }
}

"
ngCdAKyX,SearchOrdersServlet.java,Vitrecan,Java,Sunday 21st of May 2023 07:20:53 AM CDT,"/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package uts.isd.controller;

/**
 *
 * @author Vincent Tran
 */
import uts.isd.model.Order;
import uts.isd.model.dao.DBConnector;
import uts.isd.model.dao.DBManager;
import java.io.IOException;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class SearchOrdersServlet extends HttpServlet {
    private DBManager dbManager;

    @Override
    public void init() {
        try {
            DBConnector db = new DBConnector();
            Connection conn = db.openConnection();
            dbManager = new DBManager(conn);
        } catch (ClassNotFoundException | SQLException e) {
            Logger.getLogger(SearchOrdersServlet.class.getName()).log(Level.SEVERE, null, e);
        }
    }

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        String orderNumber = request.getParameter(""orderNumber"");
        String date = request.getParameter(""date"");
        try {
            List<Order> orders = dbManager.searchOrders(orderNumber, date);
        	request.getSession().setAttribute(""orders"", orders);
            response.sendRedirect(""order.jsp"");
        } catch (Exception e) {
            Logger.getLogger(SearchOrdersServlet.class.getName()).log(Level.SEVERE, null, e);
        }
    }
}"
K9wqUQed,CreateOrderServlet.java,Vitrecan,Java,Sunday 21st of May 2023 07:19:58 AM CDT,"/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package uts.isd.controller;

/**
 *
 * @author Vincent Tran
 */
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import uts.isd.model.Order;
import uts.isd.model.dao.DBConnector;
import uts.isd.model.dao.DBManager;
import java.io.IOException;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class CreateOrderServlet extends HttpServlet {
    private DBManager dbManager;

    @Override
    public void init() {
        try {
            DBConnector db = new DBConnector();
            Connection conn = db.openConnection();
            dbManager = new DBManager(conn);
        } catch (ClassNotFoundException | SQLException e) {
            Logger.getLogger(CreateOrderServlet.class.getName()).log(Level.SEVERE, null, e);
        }
    }

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        String device = request.getParameter(""device"");
        int quantity = Integer.parseInt(request.getParameter(""quantity""));
        java.sql.Date date = new java.sql.Date(new java.util.Date().getTime());
        Order order = new Order(0, device, quantity, date);
        try {
            dbManager.createOrder(order);
            request.getSession().setAttribute(""order"", order);
            response.sendRedirect(""order.jsp"");
        } catch (IOException | SQLException e) {
            Logger.getLogger(CreateOrderServlet.class.getName()).log(Level.SEVERE, null, e);
        }
    }
}"
bTCaS7xq,WirelesComputerSend,robkatt,Lua,Sunday 21st of May 2023 07:19:37 AM CDT,"term.clear ()
term.setCursorPos(1,1)

local modem = peripheral.find(""modem"")

modem.open(69)
while true do

    input = read()
    
    modem.transmit(69,69,read)
    print(""Sent!"")
   
end"
JGGFZLgV,CancelOrderServlet.java,Vitrecan,Java,Sunday 21st of May 2023 07:18:07 AM CDT,"/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package uts.isd.controller;

/**
 *
 * @author Vincent Tran
 */
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import uts.isd.model.dao.DBConnector;
import uts.isd.model.dao.DBManager;
import java.io.IOException;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class CancelOrderServlet extends HttpServlet {
    private DBManager dbManager;

    @Override
    public void init() {
        try {
            DBConnector db = new DBConnector();
            Connection conn = db.openConnection();
            dbManager = new DBManager(conn);
        } catch (ClassNotFoundException | SQLException e) {
            Logger.getLogger(CancelOrderServlet.class.getName()).log(Level.SEVERE, null, e);
        }
    }

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        int orderNumber = Integer.parseInt(request.getParameter(""orderNumber""));
        try {
            dbManager.cancelOrder(orderNumber);
            request.getSession().removeAttribute(""order"");
            response.sendRedirect(""order.jsp"");
        } catch (IOException | SQLException e) {
            Logger.getLogger(CancelOrderServlet.class.getName()).log(Level.SEVERE, null, e);
        }
    }
}"
aMEh1e9J,Untitled,iko1133,JavaScript,Sunday 21st of May 2023 06:58:56 AM CDT,"{
	""config"": {
		""adapter"": [Function xhrAdapter],
		""baseURL"": ""https://sss.self.ge/api/"",
		""data"": ""DomainName=td.self.ge"",
		""headers"": {
			""Accept"": ""application/json"",
			""Content-Type"": ""application/x-www-form-urlencoded""
		},
		""maxBodyLength"": -1,
		""maxContentLength"": -1,
		""method"": ""post"",
		""timeout"": 0,
		""transformRequest"": [
			[Function transformRequest]
		],
		""transformResponse"": [
			[Function transformResponse]
		],
		""transitional"": {
			""clarifyTimeoutError"": false,
			""forcedJSONParsing"": true,
			""silentJSONParsing"": true
		},
		""url"": ""InitDomain"",
		""validateStatus"": [Function validateStatus],
		""xsrfCookieName"": ""XSRF-TOKEN"",
		""xsrfHeaderName"": ""X-XSRF-TOKEN""
	},
	""data"": {},
	""duration"": 60,
	""headers"": {
		""access-control-allow-origin"": ""*"",
		""connection"": ""close"",
		""content-length"": ""2"",
		""content-type"": ""application/json"",
		""date"": ""Sun, 21 May 2023 11:55:02 GMT"",
		""server"": ""Apache"",
		""x-frame-options"": ""sameorigin""
	},
	""ok"": false,
	""originalError"": [Error: Request failed with status code 400],
	""problem"": ""CLIENT_ERROR"",
	""status"": 400
}"
3RS50GcZ,Untitled,nnv-nick,C++,Sunday 21st of May 2023 06:48:51 AM CDT,"#include <bits/stdc++.h>
#define pb push_back
#define sz(a) (int)a.size()
#define x first
#define y second
#define ll long long
#define ull unsigned long long

using namespace std;

const int MAX_N = 605;

const ll H1 = 997;
const ll H2 = 1187;
const ll MOD = 1e9 + 7;
const ll MOD2 = 998244353;
const ll MOD3 = 1000000123;

ll h1[MAX_N];
ll h2[MAX_N];
ll h12[MAX_N];
ll h22[MAX_N];
ll h13[MAX_N];
ll h23[MAX_N];
ull h14[MAX_N];
ull h24[MAX_N];
ll dp[MAX_N][MAX_N];
ll dp2[MAX_N][MAX_N];
ll dp3[MAX_N][MAX_N];
ull dp4[MAX_N][MAX_N];


char c[MAX_N][MAX_N];

int n, m, k;

ll get1(int x1, int y1, int x2, int y2) {
    ll sum = (dp[x2][y2] - dp[x2][y1 - 1] - dp[x1 - 1][y2] + dp[x1 - 1][y1 - 1] + MOD + MOD) % MOD;
    return (sum * ((h1[n - x2] * h2[m - y2]) % MOD)) % MOD;
}

ll get2(int x1, int y1, int x2, int y2) {
    ll sum = (dp2[x2][y2] - dp2[x2][y1 - 1] - dp2[x1 - 1][y2] + dp2[x1 - 1][y1 - 1] + MOD2 + MOD2) % MOD2;
    return (sum * ((h12[n - x2] * h22[m - y2]) % MOD2)) % MOD2;
}

ll get3(int x1, int y1, int x2, int y2) {
    ll sum = (dp3[x2][y2] - dp3[x2][y1 - 1] - dp3[x1 - 1][y2] + dp3[x1 - 1][y1 - 1] + MOD3 + MOD3) % MOD3;
    return (sum * ((h13[n - x2] * h23[m - y2]) % MOD3)) % MOD3;
}

ll get4(int x1, int y1, int x2, int y2) {
    ll sum = dp4[x2][y2] - dp4[x2][y1 - 1] - dp4[x1 - 1][y2] + dp4[x1 - 1][y1 - 1];
    return sum * h14[n - x2] * h24[m - y2];
}


bool check(int f) {
    map<pair<pair<ll, ll>, pair<ll, ll>>, int> cnt;
    for (int i = 1; i <= n - f + 1; ++i) {
        for (int j = 1; j <= m - f + 1; ++j) {
            ll cur1 = get1(i, j, i + f - 1, j + f - 1);
            ll cur2 = get2(i, j, i + f - 1, j + f - 1);
            ll cur3 = get3(i, j, i + f - 1, j + f - 1);
            ll cur4 = get4(i, j, i + f - 1, j + f - 1);
            cnt[{{cur1, cur2}, {cur3, cur4}}]++;
            if (cnt[{{cur1, cur2}, {cur3, cur4}}] >= k)
                return true;
        }
    }
    return false;
}

signed main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    h1[0] = h2[0] = h12[0] = h22[0] = h13[0] = h23[0] = h14[0] = h24[0] = 1;
    for (int i = 1; i < MAX_N; ++i) {
        h1[i] = (h1[i - 1] * H1) % MOD;
        h2[i] = (h2[i - 1] * H2) % MOD;
        h12[i] = (h12[i - 1] * H1) % MOD2;
        h22[i] = (h22[i - 1] * H2) % MOD2;
        h13[i] = (h13[i - 1] * H1) % MOD3;
        h23[i] = (h23[i - 1] * H2) % MOD3;
        h14[i] = (h14[i - 1] * H1);
        h24[i] = (h24[i - 1] * H2);
    }

    cin >> n >> m >> k;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            cin >> c[i][j];
        }
    }
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + (c[i][j] * ((h1[i] * h2[j]) % MOD)) % MOD + MOD) % MOD;
            dp2[i][j] = (dp2[i - 1][j] + dp2[i][j - 1] - dp2[i - 1][j - 1] + (c[i][j] * ((h12[i] * h22[j]) % MOD2)) % MOD2 + MOD2) % MOD2;
            dp3[i][j] = (dp3[i - 1][j] + dp3[i][j - 1] - dp3[i - 1][j - 1] + (c[i][j] * ((h13[i] * h23[j]) % MOD3)) % MOD3 + MOD3) % MOD3;
            dp4[i][j] = dp4[i - 1][j] + dp4[i][j - 1] - dp4[i - 1][j - 1] + (c[i][j] * ((h14[i] * h24[j])));
        }
    }

    int l = 0;
    int r = min(n, m) + 1;
    while (r - l > 1) {
        int f = (l + r) / 2;
        if (check(f)) {
            l = f;
        } else {
            r = f;
        }
    }
    if (l == 0) {
        cout << ""-1\n"";
    } else {
        cout << l << endl;
    }
    return 0;
}

"
avSNceAU,cntCredits,cleverus,JavaScript,Sunday 21st of May 2023 06:27:18 AM CDT,"/* This is your custom Javascript */
jQuery(document).ready(function ($) {
    $(""#header-aside .signin-button"").attr(""href"", '//earn.community/login');
    setLoginLink();

    $("".kv-login-link"").click(function (event) {
        if ( $(""body"").hasClass(""logged-in"") ) {
      $('.bb-mobile-header-wrapper .header-aside .sub-menu').toggleClass('active');      
        }
        else {
            window.location.href = ""https://earn.community/login"";
        }
    });

	$('.user-wrap .sub-menu').clone(true).insertAfter('.bb-mobile-header-wrapper .kv-login-link');  

	var cntCredits;

	if($('body').hasClass('logged-in')){
		if ($('.gamipress-user-points-amount').length > 0) {
			cntCredits = $(""span.gamipress-user-points-amount"").html();
			localStorage.setItem('credits', cntCredits);
			
			console.log('источник есть-' + cntCredits);
		} else {
			cntCredits = localStorage.getItem('credits');
			
			console.log('источника нет- ' + cntCredits);
		}		

		$('<div class=""kv-menu-credits""> <div class=""kv-menu-credits__ico""> <img src=""/wp-content/uploads/2022/11/Untitled-design-2022-11-07T151629.047.png"" alt=""""> </div> <div class=""kv-menu-credits__counter"">' + cntCredits + '</div></div>').insertBefore($('.header-aside .header-aside-inner'));
		 
		$('<div class=""kv-menu-credits""> <div class=""kv-menu-credits__ico""> <img src=""/wp-content/uploads/2022/11/Untitled-design-2022-11-07T151629.047.png"" alt=""""> </div> <div class=""kv-menu-credits__counter"">' + cntCredits + '</div></div>').insertBefore($('.header-aside .kv-login-link'));	
	}
});


function setLoginLink() {
    jQuery("".bb-mobile-header .header-search-link"").addClass(""kv-login-link"");
    jQuery("".bb-mobile-header .kv-login-link"").removeClass(""header-search-link"");
    jQuery("".bb-mobile-header .kv-login-link"").attr(""data-balloon"", """");
    jQuery("".bb-mobile-header .kv-login-link .bb-icon-l"").removeClass(""bb-icon-search"");
    jQuery("".bb-mobile-header .kv-login-link .bb-icon-l"").addClass(""bb-icon-key"");
}
"
pNhAw0MX,cntCredits,cleverus,JavaScript,Sunday 21st of May 2023 06:06:31 AM CDT,"/* This is your custom Javascript */
jQuery(document).ready(function ($) {
    $(""#header-aside .signin-button"").attr(""href"", '//earn.community/login');
    setLoginLink();

    $("".kv-login-link"").click(function (event) {
        if ( $(""body"").hasClass(""logged-in"") ) {
      $('.bb-mobile-header-wrapper .header-aside .sub-menu').toggleClass('active');      
        }
        else {
            window.location.href = ""https://earn.community/login"";
        }
    });

	$('.user-wrap .sub-menu').clone(true).insertAfter('.bb-mobile-header-wrapper .kv-login-link');  

	if($('body').hasClass('logged-in')){
		if ($('.gamipress-user-points-amount').length > 0) {
			var cntCredits = $(""span.gamipress-user-points-amount"").html();
			localStorage.setItem('credits', cntCredits);
		} else {
			var cntCredits = localStorage.getItem('credits');
		}		

		$('<div class=""kv-menu-credits""> <div class=""kv-menu-credits__ico""> <img src=""/wp-content/uploads/2022/11/Untitled-design-2022-11-07T151629.047.png"" alt=""""> </div> <div class=""kv-menu-credits__counter"">' + cntCredits + '</div></div>').insertBefore($('.header-aside .header-aside-inner'));
		 
		$('<div class=""kv-menu-credits""> <div class=""kv-menu-credits__ico""> <img src=""/wp-content/uploads/2022/11/Untitled-design-2022-11-07T151629.047.png"" alt=""""> </div> <div class=""kv-menu-credits__counter"">' + cntCredits + '</div></div>').insertBefore($('.header-aside .kv-login-link'));	
	}
});


function setLoginLink() {
    jQuery("".bb-mobile-header .header-search-link"").addClass(""kv-login-link"");
    jQuery("".bb-mobile-header .kv-login-link"").removeClass(""header-search-link"");
    jQuery("".bb-mobile-header .kv-login-link"").attr(""data-balloon"", """");
    jQuery("".bb-mobile-header .kv-login-link .bb-icon-l"").removeClass(""bb-icon-search"");
    jQuery("".bb-mobile-header .kv-login-link .bb-icon-l"").addClass(""bb-icon-key"");
}"
VVFtiCCa,data579,TestGuy1,JSON,Sunday 21st of May 2023 06:00:10 AM CDT,"{
  status: 'Success',
  method: 'server',
  maindata: '985c599236bef5915a64069e9014d09fe445aed621c6e427083b826db097b64af961cec0d43c6caf8410f2837bebda32de60228141b0a3f68d7ecd515cfdbcf16d62d4fc0d7a78c474ef3f44dab9fdbb04e161b4351de042789b6c0889af399e2f9eed30f9bd49e19941f3909480bc3c20c45fea7d14706f9d310ec629a89a87',
  otherdata: [
    '576e14a2afdcca23b3231b2087d78ad4',
    'bd298e92f53a888af646bc7dc6ba7424',
    '93025138d5213e54646d2f4ff86180b6',
    '8dffce9a364da97b34feffa817928aae',
    'e5fcf95df144889b7e761699fbd30a20',
    '077dff3a83de4d056be17a22e0c636a7',
    'c82c6f943558827770ed15d01c113dc6',
    '28203210d4e41f2a33c539648d45a76f'
  ]
}"
Cabjybq8,Untitled,pasholnahuy,C++,Sunday 21st of May 2023 05:44:51 AM CDT,"#include <iostream>
#include <tuple>
#include <random>

using std::pair;
using std::cin;
using std::cout;
using std::vector;
using int64 = int64_t;
using std::max;
using std::min;

class SegmentTree {
public:
    int64 log_size;
    vector<int64> nodes = std::vector<int64>((2 << log_size) - 1);
    vector<int> SubtreeAdd;

    static int64 IntLog(int64 n) {
        int64 temp = 1;
        int64 ans = 0;
        while (temp < n) {
            temp *= 2;
            ++ans;
        }
        return ans;
    }

    static int64 Pow2(int64 n) {
        return 1 << n;
    }

    explicit SegmentTree(const vector<int64> &vec) : log_size(IntLog(vec.size())) {
        std::copy(vec.begin(), vec.end(), nodes.begin() + (1 << log_size) - 1);
        SubtreeAdd.assign(IntLog(vec.size()), 0);
        for (int64 i = Pow2(log_size) - 2; i >= 0; --i) {
            nodes[i] = nodes[2 * i + 1] + nodes[2 * i + 2];
        }
    }

    void Modify(int64 l, int64 r, int64 val) {
        Modify(l, r, 0, 0, Pow2(log_size) - 1, val);
    }

    int64 GetSum(int64 l, int64 r) {
        return GetSum(l, r, 0, 0, Pow2(log_size) - 1);
    }

private:

    int64 GetSum(int64 l, int64 r, int64 n, int64 nl, int64 nr) {
        if (l > r) {
            return 0;
        }
        if (l == nl && r == nr) {
            return nodes[n];
        }
        int64 mid = (nl + nr) / 2;
        return GetSum(l, min(r, mid), n * 2 + 1, nl, mid) +
               GetSum(max(l, mid + 1), r, n * 2 + 2, mid + 1, nr);
    }

    void push(int64 v, int64 vl, int64 vr) {
        if (SubtreeAdd[v]) {
            nodes[v] += SubtreeAdd[v] * (vr - vl + 1);
            if (vl != vr) {
                SubtreeAdd[2 * v + 1] += SubtreeAdd[v];
                SubtreeAdd[2 * v + 2] += SubtreeAdd[v];
            }
            SubtreeAdd[v] = 0;
        }
    }

    void Modify(int64 l, int64 r, int64 n, int64 nl, int64 nr, int64 val) {
        push(n, nl, nr);
        if (l > nr || r < nl) {
            return;
        }
        if (l <= nl && r >= nr) {
            nodes[n] += val;
            push(n, nl, nr);
            return;
        } else {
            int64 mid = (nl + nr) / 2;
            Modify(l, r, n * 2 + 1, nl, mid, val);
            Modify(l, r, n * 2 + 2, mid + 1, nr, val);
            nodes[n] = nodes[2 * n + 1] + nodes[2 * n + 2];
        }
    }


};

int main() {
    int64 n;
    cin >> n;
    vector<int64> vec(n);
    for (size_t i = 0; i < n; ++i) {
        cin >> vec[i];
    }
    SegmentTree st(vec);
    int k;
    cin >> k;
    for (size_t i = 0; i < k; ++i) {
        int num;
        cin >> num;
        if (num == 1) {
            int64 l, r;
            cin >> l >> r;
            cout << st.GetSum(l, r) << '\n';
        } else {
            int64 l, r, x;
            cin >> l >> r >> x;
            st.Modify(l, r, x);
        }
    }
    return 0;
}"
tBYxCig6,08. Tennis Ranklist,myrdok123,Java,Sunday 21st of May 2023 05:38:28 AM CDT,"package L04_ForLoop;

import java.util.Scanner;

public class P08_TennisRanklist {


    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);


        int countTournaments = Integer.parseInt(scanner.nextLine());
        int startingPoints = Integer.parseInt(scanner.nextLine());

        //правим фор цикъл -> като броя на повторенията трябва да е равен на броя турнири

        int countWins = 0;
        int allTournamentsPoints = 0;
        for (int i = 1; i <= countTournaments ; i++) {

            //прочитаме до кой етап на турнира е достигнал
            String currentStage = scanner.nextLine();

            //правим проверка до какъв етап е достигнал -> прибавим необходимите точки
            if (currentStage.equals(""W"")){
                countWins++;
                allTournamentsPoints += 2000;

            } else if (currentStage.equals(""F"")) {
                allTournamentsPoints += 1200;
                
            } else if (currentStage.equals(""SF"")) {
                allTournamentsPoints += 720;
            }

        }

        //пресмятаме общия брой точки
        int finalPoints = allTournamentsPoints + startingPoints;

        //пресмятаме средно колко точки печели за турнир
        int averagePoints = allTournamentsPoints / countTournaments;

        double percentWins = (countWins * 1.0 / countTournaments) * 100;

        System.out.printf(""Final points: %d%n"", finalPoints);
        System.out.printf(""Average points: %d%n"", averagePoints);
        System.out.printf(""%.2f%%"", percentWins);




    }
}
"
hRKvtSRU,06. Oscars,myrdok123,Java,Sunday 21st of May 2023 05:37:46 AM CDT,"package L04_ForLoop;

import java.util.Scanner;

public class P06_Oscars {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);


        String actorName = scanner.nextLine();
        double academyPoints = Double.parseDouble(scanner.nextLine());
        int countExaminers = Integer.parseInt(scanner.nextLine());

        double sumAllPoint = academyPoints;

        //правим цикъл за всечки оценяващи
        for (int i = 1; i <= countExaminers ; i++) {
            //прочитаме име и точки, които е дал конкретният оценяващ
            String examinerName = scanner.nextLine();
            double currentPoints = Double.parseDouble(scanner.nextLine());

            //пресмятаме колко точки трябва да прибавим към общият брой точки
            sumAllPoint += (examinerName.length() * currentPoints) / 2;

            //проверяваме дали сме достигнали 1250.5 -> ако сме ги достиганали -> принтираме и прекратяваме програмата

            if(sumAllPoint >= 1250.5){
                System.out.printf(""Congratulations, %s got a nominee for leading role with %.1f!"", actorName, sumAllPoint);
                break;
            }

        }


        //проверяваме дали точките са под 1250.5
        if(sumAllPoint < 1250.5){

            System.out.printf(""Sorry, %s you need %.1f more!"", actorName, 1250.5 - sumAllPoint);
        }
    }
}
"
yEL41VCY,05. Salary,myrdok123,Java,Sunday 21st of May 2023 05:36:24 AM CDT,"package L04_ForLoop;

import java.util.Scanner;

public class P05_Salary {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int tabs = Integer.parseInt(scanner.nextLine());
        int salary = Integer.parseInt(scanner.nextLine());

        for (int i = 1; i <=tabs ; i++) {

            String websiteName = scanner.nextLine();


            //todo -> проверка за име на сайта - намалене на заплата

            if(salary <= 0){
                System.out.println(""You have lost your salary."");
                break;
            }

        }

        //todo -> проверка дали заплатата е над -> 0


    }
}
"
VTNpE2Sw,04. Clever Lily,myrdok123,Java,Sunday 21st of May 2023 05:35:29 AM CDT,"package L04_ForLoop;

import java.util.Scanner;

public class P04_CleverLily {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);



        int age = Integer.parseInt(scanner.nextLine());
        double priceWashingMachine = Double.parseDouble(scanner.nextLine());
        int priceToy = Integer.parseInt(scanner.nextLine());

        double sum = 0;
        int countToys = 0;

        // for -> минавеме през всяка от годините(рождените дни) -> за четните получава пари, а за нечетните получава играчка

        //int moneyEvenAge = 10;

        for (int currentAge = 1; currentAge <= age ; currentAge++) {

            //проверка дали годината е четна или нечетна
            if (currentAge % 2 == 0){
                /*sum += moneyEvenAge;
                moneyEvenAge += 10;
                sum--;*/

                //парите, които получава
                sum = sum + (currentAge * 5 - 1);// sum += currentAge * 5 - 1

            }else {
                //нечетна година/рожден ден -> увеличаваме броя на играчките
                countToys++;
            }


        }


        //към досегашната сума прибавяме и парите от играчките
        sum += countToys * priceToy;

        double diff = Math.abs(priceWashingMachine - sum);

        if (sum >= priceWashingMachine){

            System.out.printf(""Yes! %.2f"", diff);
        }else {
            System.out.printf(""No! %.2f"", diff);
        }


    }
}
"
n9gFau2e,03. Histogram,myrdok123,Java,Sunday 21st of May 2023 05:34:54 AM CDT,"package L04_ForLoop;

import java.util.Scanner;

public class P03_Histogram {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);


        int n = Integer.parseInt(scanner.nextLine());

        //създаваме променливи за броя числа в конкретен диапазон

        int countP1 = 0;
        int countP2 = 0;
        int countP3 = 0;
        int countP4 = 0;
        int countP5 = 0;

        //правим цикъл и прочитаме n на брой числа



        for (int i = 1; i <= n ; i++) {

            int currentNum = Integer.parseInt(scanner.nextLine());

            //проверяваме в кой диапазон попада текущото число
            if (currentNum < 200){
                countP1++;
            } else if (currentNum < 400) {
                countP2++;
            } else if (currentNum < 600) {
                countP3++;
            } else if (currentNum < 800) {
                countP4++;
            }else {
                countP5++;
            }

        }

        double p1Percent = (countP1 * 1.0 / n) * 100;
        double p2Percent = (countP2 * 1.0 / n) * 100;
        double p3Percent = (countP3 * 1.0 / n) * 100;
        double p4Percent = (countP4 * 1.0 / n) * 100;
        double p5Percent = (countP5 * 1.0 / n) * 100;


        System.out.printf(""%.2f%%%n"", p1Percent);
        System.out.printf(""%.2f%%%n"", p2Percent);
        System.out.printf(""%.2f%%%n"", p3Percent);
        System.out.printf(""%.2f%%%n"", p4Percent);
        System.out.printf(""%.2f%%%n"", p5Percent);
    }
}
"
WFPigb9R,02. Half Sum Element,myrdok123,Java,Sunday 21st of May 2023 05:34:11 AM CDT,"package L04_ForLoop;

import java.util.Scanner;

public class P02_HalfSumElement {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);


        int n = Integer.parseInt(scanner.nextLine());

        int maxNumber = Integer.MIN_VALUE;

        int sum = 0;

        for (int i = 1; i <= n ; i++) {

            int currentNumber = Integer.parseInt(scanner.nextLine());
            sum += currentNumber;


            if(currentNumber > maxNumber){
                maxNumber = currentNumber;
            }


        }

        int sumWithoutMaxNumber = sum - maxNumber;

        if (sumWithoutMaxNumber == maxNumber){
            System.out.println(""Yes"");
            System.out.printf(""Sum = %d"", sumWithoutMaxNumber);
        }else {
            int diff = Math.abs(sumWithoutMaxNumber - maxNumber);
            System.out.println(""No"");
            System.out.printf(""Diff = %d"", diff);

        }


    }
}
"
LTgHYkvL,01. Numbers Ending in 7,myrdok123,Java,Sunday 21st of May 2023 05:33:31 AM CDT,"package L04_ForLoop;

public class P01_NumbersEnding7 {

    public static void main(String[] args) {


        for (int i = 7; i <= 997 ; i+=10) {

            System.out.println(i);


        }
    }
}
"
hndHe2uc,Untitled,DFNNOT,Python,Sunday 21st of May 2023 05:21:57 AM CDT,"import requests
import time

def search_free_limiteds(search_terms):
    while True:
        for term in search_terms:
            try:
                # Search on RblxTrade API
                rblxtrade_url = f""https://rblxtrade.com/api/trades/search?query={term}&limit=10&sort=desc""
                rblxtrade_response = requests.get(rblxtrade_url)
                
                if rblxtrade_response.status_code == 200:
                    rblxtrade_results = rblxtrade_response.json()
                    for item in rblxtrade_results:
                        print(""---------------------"")
                        print(f""Item Name: {item['name']}"")
                        print(f""Item Price: {item['price']}"")
                        print(f""Item URL: {item['url']}"")
                        print(""---------------------"")
                        
                        # Auto-buy if item is listed for free and for sale
                        if item['free'] and item['canBuy']:
                            item_id = item['assetId']
                            buy_url = f""https://www.roblox.com/Trade/TradeHandler.ashx?ep=buyitem&tradeid={item_id}""
                            
                            while True:
                                try:
                                    response = requests.get(buy_url)
                                    response.raise_for_status()
                                    
                                    result = response.json()
                                    if result['status'] == 'ok':
                                        print(f""Item {item_id} successfully purchased!"")
                                        break
                                    elif result['status'] == 'error':
                                        print(f""Failed to purchase item {item_id}: {result['message']}"")
                                        break
                                except requests.exceptions.RequestException as e:
                                    print(f""Error occurred during purchase attempt for item {item_id}: {str(e)}"")
                                time.sleep(0.45)  # Wait for 0.45 seconds before retrying the purchase

                else:
                    print(f""No results found for search term: {term} (RblxTrade API)"")
            except requests.exceptions.RequestException as e:
                print(f""Error occurred while searching for search term: {term} (RblxTrade API): {str(e)}"")

            try:
                # Search on Rolimon's Marketplace API
                rolimons_url = f""https://www.rolimons.com/api/trades?searchQuery={term}&resultLimit=10""
                rolimons_response = requests.get(rolimons_url)
                
                if rolimons_response.status_code == 200:
                    rolimons_results = rolimons_response.json()
                    if rolimons_results:
                        for item in rolimons_results:
                            print(""---------------------"")
                            print(f""Item Name: {item['name']}"")
                            print(f""Item Price: {item['price']}"")
                            print(f""Item URL: {item['tradeId']}"")
                            print(""---------------------"")
                            
                            # Auto-buy if item is listed for free and for sale
                            if item['free'] and item['canBuy']:
                                item_id = item['tradeId']
                                buy_url = f""https://www.roblox.com/Trade/TradeHandler.ashx?ep=buyitem&tradeid={item_id}""
                                
                                while True:
                                    try:
                                        response = requests.get(buy_url)
                                        response.raise_for_status()
                                        
                                        result = response.json()
                                        if result['status'] == 'ok':
                                            print(f""Item {item_id} successfully purchased!"")
                                            break
                                        elif result['status'] == 'error':
                                            print(f""Failed to purchase item {item_id}: {result['message']}"")
                                            break
                                    except requests.exceptions.RequestException as e:
                                        print(f""Error occurred during purchase attempt for item {item_id}: {str(e)}"")
                                    time.sleep(0.45)  # Wait for 0.45 seconds before retrying the purchase
                    else:
                        print(f""No results found for search term: {term} (Rolimon's Marketplace API)"")
                else:
                    print(f""Error occurred while searching for search term: {term} (Rolimon's Marketplace API): {rolimons_response.status_code}"")
            except requests.exceptions.RequestException as e:
                print(f""Error occurred while searching for search term: {term} (Rolimon's Marketplace API): {str(e)}"")

        time.sleep(0.75)  # Wait for 0.75 seconds before performing the next search

# Example usage
search_terms = [""limited item 1"", ""rare item 2"", ""special item 3""]
search_free_limiteds(search_terms)
"
