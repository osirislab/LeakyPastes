id,title,username,language,date,content
t485NbLs,BTC Wallet Credentials have been reset,refortzari_33,GetText,Saturday 3rd of June 2023 06:58:19 PM CDT,"Dear User
We have received a request to reset the login information for your Bitcoin wallet. If you did not make this request, please disregard this message.
Your new login credentials will be 
smesu23:3UYL6h on 193.233.202.76(SSH)
Regards"
d9grAYT3,Untitled,coffeepls,C,Saturday 3rd of June 2023 06:32:45 PM CDT,"Event Headgear Shop NPC
Name				CP	ID		Aegis_Name
Bombring Hat		200	39362	bomb_poring_hat
Antler Fedora		400	18662	Antler_Fedora
Blue Arara Hat		500	5778	Blue_Arara_Hat
Black Devil Mask 	600	18599	Black_Devil_Mask
Piamtte Brown Ear	600	18909	Isabella_Brown_Ear
Heartwing Hairband 	700	18563	Heart_Wing_Hairband
Palace Guard Cap 	700	18878	Palace_Guard_Cap
Chibi Pope			700	18673	Tare_Pope_

Event Costume Shop NPC
Name						CP		ID		Aegis_Name
Upper Hair Ext				250		38001	Shadow_Upper
Lovelove balloon 			300		18917	LoveLove_Balloon
Eremes Scarf 				300		20405	C_Eremes_Scarf
ALice Wig 					300		31329	C_Alice_Wig
Alice Wig Peach 			300		31407	C_Alice_Wig_PK
Middle Hair 				500		38002	Shadow_Middle
Lower Hair					500		38003	Shadow_Lower
Moon and Stars 				500		18742	C_MoonStar_Accessory
Evil Druid Hat 				500		19824	C_Evil_Druid_Hat
Secret Zipper 				500		20266	C_Secret_Zipper
Costume Eleanor Wig 		500		31062	C_Eleanor_Wig
Costume Eleanor Yellow 		500		31405	C_Eleanor_Wig_YL
Costume Nidhog wig 			500		31149	C_Nydhog_Wig
Costume Nidhog Wig white	500		31406	C_Nydhog_Wig_WH
Costume Sleeping Cat		1000	19739	C_Sleeping_Kitty_Cat"
BXuG5Wr2,Untitled,sinancetinkaya,C++,Saturday 3rd of June 2023 05:59:30 PM CDT,"void OnStart()
{
    // Create and initialize the list of lists
    double myList[][3] = { {4.2, 2.5, ""abc""}, {1.1, 5.3, ""def""}, {3.7, 0.9, ""ghi""} };
    int myListSize = ArraySize(myList);

	ArraySort(myList,WHOLE_ARRAY,0,MODE_ASCEND);
    // Print the sorted list
    for (int i = 0; i < myListSize; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            Print(myList[i][j]);
        }
    }
}
"
ub0S6xfH,CEOI '20 - Star Trek,erek1e,C++,Saturday 3rd of June 2023 05:52:35 PM CDT,"#include <iostream>
#include <vector>
#include <algorithm>
// #include <cassert>
 
using namespace std;
 
const int BASE = 1e9 + 7;
 
int add(int x, int y) {
    x += y;
    if (x >= BASE) return x-BASE;
    return x;
}
int sub(int x, int y) {
    x -= y;
    if (x < 0) return x+BASE;
    return x;
}
int mult(int x, int y) {
    return (long long)x*y % BASE;
}
int bin_pow(int x, int y) {
    int res = 1;
    while (y) {
        if (y & 1) res = mult(res, x);
        y >>= 1;
        x = mult(x, x);
    }
    return res;
}
int inverse(int x) {
    return bin_pow(x, BASE-2);
}
 
vector<vector<int>> g;
vector<int> S, A;
vector<int> S_subtree, A_subtree; // state in subtree, cnt of change nodes in subtree
 
void dfsSubtree(int node, int parent = -1) {
    int s[2]{}, a[2]{};
    for (int child : g[node]) {
        if (child != parent) {
            dfsSubtree(child, node);
            s[S_subtree[child]]++, a[S_subtree[child]] += A_subtree[child];
        }
    }
    if (s[0] == 0) { // no losing child, so this node is losing
        S_subtree[node] = 0;
        A_subtree[node] = a[1]; // any losing node would make it winning
        ++A_subtree[node]; // this node itself could become winning
    } else {
        S_subtree[node] = 1;
        A_subtree[node] = (s[0] > 1 ? 0 : a[0]);
    }
}
void dfsOutside(int node, int parent = -1, int S_parent = 1, int A_parent = 0) {
    vector<pair<int, int>> d[2]{}; // directions: (node, A_direction[node])
    int a[2]{};
    if (parent != -1) d[S_parent].emplace_back(parent, A_parent), a[S_parent] += A_parent;
    for (int child : g[node]) {
        if (child != parent) {
            d[S_subtree[child]].emplace_back(child, A_subtree[child]);
            a[S_subtree[child]] += A_subtree[child];
        }
    }
 
    if (d[0].size() == 0) { // no losing children, so losing node
        S[node] = 0;
        A[node] = a[1];
        ++A[node]; // this node itself could become winning
        for (int child : g[node]) {
            if (child != parent) {
                dfsOutside(child, node, 0, A[node] - A_subtree[child]);
            }
        }
    } else {
        S[node] = 1;
        if (d[0].size() == 1) {
            A[node] = a[0];
            int x = d[0][0].first;
            for (int child : g[node]) {
                if (child != parent) {
                    if (child == x) dfsOutside(child, node, 0, a[1]+1); // +1 since this node itself can change
                    else dfsOutside(child, node, 1, a[0]);
                }
            }
        } else if (d[0].size() == 2) {
            A[node] = 0;
            int x = d[0][0].first, y = d[0][1].first;
            int ax = (x == parent ? A_parent : A_subtree[x]);
            int ay = (y == parent ? A_parent : A_subtree[y]);
            for (int child : g[node]) {
                if (child != parent) {
                    if (child == x) dfsOutside(child, node, 1, ay);
                    else if (child == y) dfsOutside(child, node, 1, ax);
                    else dfsOutside(child, node, 1, 0);
                }
            }
        } else {
            A[node] = 0;
            for (int child : g[node]) {
                if (child != parent) dfsOutside(child, node, 1, 0);
            }
        }
    }
}
 
struct Matrix {
    int N, M;
    vector<vector<int>> v;
    Matrix(){}
    Matrix(int N, int M): N(N), M(M) {v.assign(N, vector<int>(M));}
    Matrix operator * (const Matrix &m2) {
        // assert(M == m2.N);
        int K = m2.M;
        Matrix m(N, K);
        for (int i = 0; i < N; ++i) {
            for (int k = 0; k < K; ++k) {
                for (int j = 0; j < M; ++j) {
                    m.v[i][k] = add(m.v[i][k], mult(v[i][j], m2.v[j][k]));
                }
            }
        }
        return m;
    }
    Matrix operator ^ (long long int n) {
        // assert(N == M);
        Matrix m(N, N);
        for (int i = 0; i < N; ++i) m.v[i][i] = 1; // identity
        Matrix p2 = *this;
        while (n) {
            if (n & 1) m = m * p2;
            n >>= 1;
            p2 = p2 * p2;
        }
        return m;
    }
    void print() const {
        for (int i = 0; i < N; ++i) {
            for (int j = 0; j < M; ++j) cout << v[i][j] << ' ';
            cout << endl;
        }
    }
};
 
int main() {
    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    int N; long long D; cin >> N >> D;
    g.resize(1+N);
    for (int i = 1; i <= N-1; ++i) {
        int u, v; cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
 
    /*
    Let's define a losing combination over some suffix of dimensions as the number of
    combinations of start node and portals in that suffix that lead to a loss for the
    player whose turn it is at the start node.
    Then the number of losing combinations over a larger suffix can be calculated.
    */
 
    /* Find A[r] for all ""roots"" - the number of losing nodes s.t. if that node was turned into
    a winning node, that would change the state of the root r */
    S_subtree.resize(1+N), A_subtree.resize(1+N);
    dfsSubtree(1);
    S.resize(1+N), A.resize(1+N);
    dfsOutside(1);
 
    int cnt[2]{}, sumA[2]{};
    for (int i = 1; i <= N; ++i) ++cnt[S[i]], sumA[S[i]] = add(sumA[S[i]], A[i]);
 
    // This is the O(D) version:
    // int L = 0, N2d = 1; // N^(2d)
    // for (int d = 0; d <= D-1; ++d) {
    //     L = add(mult(N2d, cnt[0]), mult(L, sub(sumA[1], sumA[0])));
    //     N2d = mult(N2d, mult(N, N));
    // }
 
    // O(log D) using Matrix Exponentiation
    int T = sub(sumA[1], sumA[0]);
    Matrix m(2, 2);
    m.v = {{T, cnt[0]}, {0, mult(N, N)}};
    Matrix v(2, 1);
    v.v = {{0}, {1}};
    
    // m^D * v
    Matrix m2 = m ^ D;
    Matrix m3 = m2 * v;
    int L = m3.v[0][0], N2d = m3.v[1][0];
 
    int win = 0;
    if (S[1] == 0) win = mult(A[1], L);
    else win = sub(N2d, mult(A[1], L));
    cout << win << endl;
    return 0;
}"
tN0ENyXG,Rows & Columns generator - Python,ArafatGS,Python,Saturday 3rd of June 2023 05:36:45 PM CDT,"import tkinter as tk

def generate_pattern(rows, cols):
    pattern = """"
    for i in range(rows):
        for j in range(cols):
            if (i + j) % 2 == 0:
                pattern += ""*""
            else:
                pattern += ""-""
        pattern += ""\n""
    return pattern

def show_pattern():
    num_rows = int(rows_entry.get())
    num_cols = int(cols_entry.get())

    pattern = generate_pattern(num_rows, num_cols)
    pattern_text.configure(state='normal')
    pattern_text.delete(""1.0"", tk.END)
    pattern_text.insert(tk.END, pattern)
    pattern_text.configure(state='disabled')

def toggle_dark_mode():
    dark_mode.set(not dark_mode.get())
    if dark_mode.get():
        pattern_frame.config(bg=""black"")
        pattern_text.config(bg=""black"", fg=""white"", insertbackground=""white"")
        dark_mode_button.config(text=""\u263E"")  # Moon symbol
    else:
        pattern_frame.config(bg=""white"")
        pattern_text.config(bg=""white"", fg=""black"", insertbackground=""black"")
        dark_mode_button.config(text=""\u2600"")  # Sun symbol

window = tk.Tk()
window.title(""Pattern Generator"")

dark_mode = tk.BooleanVar()
dark_mode_button = tk.Button(window, text=""\u2600"", font=(""Arial"", 12), command=toggle_dark_mode)
dark_mode_button.pack()

rows_label = tk.Label(window, text=""Number of Rows:"")
rows_label.pack()

rows_entry = tk.Entry(window)
rows_entry.pack()

cols_label = tk.Label(window, text=""Number of Columns:"")
cols_label.pack()

cols_entry = tk.Entry(window)
cols_entry.pack()

generate_button = tk.Button(window, text=""Generate Pattern"", command=show_pattern)
generate_button.pack()

pattern_frame = tk.Frame(window, bg=""white"")
pattern_frame.pack()

pattern_text = tk.Text(pattern_frame, state='disabled')
pattern_text.pack()

window.mainloop()"
hTUvKWDw,Semana4-CuatroOperaciones,knomo,Python,Saturday 3rd of June 2023 05:20:42 PM CDT,"def suma(a, b): return a + b
def resta(a, b): return a - b
def multiplica(a, b): return a * b
def divide(a, b): return a / b
def sale(): print(""ADIOS!"")

print(""Cuatro operaciones"")
print(""1. Sumar"")
print(""2. Restar"")
print(""3. Multiplicar"")
print(""4. Dividir"")
print(""5. Salir"")

print(""Ingrese el primer valor: "")
a = int(input())
print(""Ingrese el segundo valor: "")
b = int(input())
print(""Los valores ingresados son: "" + str(a) + "" y "" + str(b))
opcion = 0

while(opcion != 5):
    print(""Por favor ingrese opción: "")
    opcion = int(input())
    print(""Opción ingresada : "" + str(opcion))
    if(opcion == 1): print(""la suma es: "", suma(a,b))
    elif(opcion == 2): print(""la resta es: "", resta(a,b))
    elif(opcion == 3): print(""la multiplicación es: "", multiplica(a,b))
    elif(opcion == 4): print(""la división es: "", divide(a,b))
    elif(opcion == 5): sale()
    else: print(""Opción inválida"")"
AbMTHvwy,Untitled,Francisco3i123,JavaScript,Saturday 3rd of June 2023 05:19:44 PM CDT,"<size=30> <align=center> <color=#ff0000>[</color><color=#fffb00>ES</color><color=#ff0000>]</color> | <color=#000fff>F</color><color=#1300ff>o</color><color=#2a00ff>r</color><color=#4d00ff>c</color><color=#5d00ff>e</color> <color=#6800ff>C</color><color=#8000ff>o</color><color=#9700ff>m</color><color=#aa00ff>m</color><color=#bd00ff>u</color><color=#c900ff>n</color><color=#e000ff>i</color><color=#ec00ff>t</color><color=#fb00ff>y</color> </size> </align>
 
<align=center><size=20><color=#000fff>▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃</color></size></align>
 
<align=center><size=20><color=#5d00ff><link=""https://discord.gg/AUkKjbBYER"">Haz clic aquí para unirte a nuestro servidor de Discord y estar al tanto de las actualizaciones del servidor, así como para recibir soporte y reportar cualquier necesidad que tengas. ¡Te esperamos para formar parte de nuestra comunidad!</link></color></size></align>
 
 
<align=center><size=20><color=#0000ff>R</color><color=#4900ff>e</color><color=#9300ff>g</color><color=#ae00ff>l</color><color=#d800ff>a</color><color=#fb00ff>s</color></size></align>
 
<color=#000fff>1. No se permite el metagaming.</color>
 
<color=#1300ff>2. El uso de exploits será sancionado.</color>
 
<color=#2a00ff>3. Se permite el humor y las bromas, pero no se tolerarán ofensas más allá de los límites establecidos.</color>
 
<color=#4d00ff>4. El camping en una habitación por más de 2 minutos está prohibido y será sancionado dependiendo de la situación.</color>
 
<color=#5d00ff>5. Desconectarse intencionalmente al obtener una clase no deseada resultará en una sanción.</color>
 
<color=#6800ff>6. Evita los bugs en la medida de lo posible para no arruinar la experiencia de otros jugadores. El uso intencionado de bugs será sancionado.</color>
 
<color=#8000ff>7. No hagas spam en canales, servidores, etc.</color>
 
<color=#9700ff>8. En casos no especificados en las reglas, utiliza el sentido común.</color>
 
<color=#aa00ff>9. Está terminantemente prohibido reproducir música inapropiada en el modo espectador, como SCP o en el intercomunicador. Tampoco está permitido reproducir música en la radio, a menos que estés vivo y utilices el chat de voz de proximidad. Estas reglas se aplican para garantizar una experiencia de juego adecuada y evitar molestias innecesarias para otros jugadores..</color>
 
<color=#bd00ff>10. Recuerda que los hacks están prohibidos. También se prohíbe invitar a otros jugadores a través de los ""Risquetos"".</color>
 
<color=#c900ff>11.Respeta las decisiones de los administradores y moderadores del servidor. No desafíes o discutas públicamente sus acciones, ni por privado ni de ninguna otra forma.</color>
 
<color=#e000ff>12. No es posible hacer equipo con los SCP, excepto en tres casos particulares:

· Los miembros del CAOS pueden formar equipo con los SCP para eliminar a los Clase D y completar la partida, o para enfrentarse a los MTF o los guardias.
· Si deseas negociar con un SCP para obtener cinco minutos de gracia, deberás convencerlo. Por ejemplo, podrías decir: ""Dame cinco minutos de gracia y te daré la ubicación de mis compañeros"" (es tu responsabilidad decidir si le mientes o no al SCP). La decisión final quedará a cargo del SCP.</color>
 
<color=#ec00ff>13. Está terminantemente prohibido realizar ""free kill"" o ""team kill"", es decir, matar a personas de tu propio equipo. Hacerlo resultará en un ban permanente sin excepciones. Si se produce un asesinato accidental, deberás presentar pruebas que lo demuestren, ya sea mediante testimonios o material audiovisual. Esto también se aplica a los guardias y los Clase D: si los Clase D están armados y los guardias sienten desconfianza o son atacados primero, los guardias tienen autorización para abrir fuego. Sin embargo, si el Clase D está desarmado, se considerará como ""free kill"" o ""team kill"".</color>
 
<color=#ec00ff>14. Importante: Dentro del servidor de SCP y Discord, es imprescindible que tu apodo esté directamente relacionado con el nombre de un SCP.</color>
 
<align=center><size=20><color=#000cff>P</color><color=#4200ff>l</color><color=#4200ff>u</color><color=#6c00ff>g</color><color=#9300ff>i</color><color=#e800ff>n</color><color=#ff00e0>s</color></size></align>
 
<color=#001fff>Remote Keycard. Este plugin te permite abrir puertas que requieren una tarjeta sin necesidad de equiparla. Simplemente acércate a la puerta y pulsa el botón correspondiente para abrirla. Esto facilitará tu movimiento y exploración en el juego sin tener que preocuparte por llevar la tarjeta contigo.</color>
 
<color=#5900ff>Respawn Timer. Cuando te encuentres en modo espectador, el plugin mostrará un temporizador que indicará el tiempo restante para que puedas volver a jugar. Además, cuando quede poco tiempo para tu respawn, recibirás una notificación que te informará que pronto estarás de regreso en acción. Esta función te ayudará a mantener un seguimiento preciso de tu tiempo de espera y te mantendrá informado para que puedas prepararte para tu próxima partida.</color>
 
<color=#8000ff>Admin Tools. Los administradores cuentan con una variedad de comandos divertidos y útiles que les permiten tanto organizar eventos emocionantes como realizar tareas de moderación de manera eficiente. Estos comandos les brindan la capacidad de crear situaciones especiales, agregar elementos sorpresa, interactuar con los jugadores y mantener el orden en el servidor. Ya sea para generar efectos especiales, otorgar objetos únicos, gestionar equipos o aplicar sanciones, los comandos de los administradores agregan un toque especial y dinámico al servidor, asegurando una experiencia agradable y entretenida para todos los usuarios.</color>
 
<color=#ae00ff>Rainbow Tags. A partir del rango de Moderador hasta Propietario, cada uno de estos rangos se destacará por un color arcoíris único. Esta elección de colores vibrantes y cambiantes refleja la diversidad y la vitalidad de nuestra comunidad. Cada vez que veas a un miembro del equipo con uno de estos rangos, podrás identificarlos fácilmente por el color arcoíris que los distingue.</color>

<color=#d800ff>Better079. El plugin añade nuevas mecánicas y comandos para mejorar la experiencia de juego del SCP-079 y algunas clases. Permite al SCP-079 tener un mayor control sobre las instalaciones y a las clases obtener beneficios y habilidades adicionales. El objetivo es equilibrar y diversificar la jugabilidad, brindando a los jugadores más opciones estratégicas y una experiencia renovada y emocionante.</color>

<color=#ff00f3>SCP 1162. El plugin agrega una nueva función a la sala del SCP-173, donde al arrojar un objeto dentro de ella, este se transformará en otro objeto aleatorio. Esta característica brinda una dinámica adicional y sorpresa a la sala, añadiendo un elemento de incertidumbre y diversión para los jugadores."
k5QiZJmi,[НРС] Колоквијум - група 5А,MartinSRB,C++,Saturday 3rd of June 2023 05:09:46 PM CDT,"#include<arduinoPlatform.h>
#include<tasks.h>
#include<interrupts.h>
#include<stdio.h>
#include<serial.h>
#include <pwm.h>
#include<data.h>

extern serial Serial;

const int pin = 33;
int oldState,
    startTime,
    elapsedTime = 0,
    periodTime = 0,
    iteration  = 0,
    jumps[100],
    maxJump;

void resetIterations(){
    iteration = 0,
    maxJump   = 0;
    for(int i = 0; i < 100; ++i){
        jumps[i] = 0;
    }
}

void tracking(int id, void* ptrt){
    static int first = true;
    int newState = digitalRead(pin);
    if(oldState > newState){
        elapsedTime = millis() - startTime;
    }else if(oldState < newState){
        int time = millis();
        periodTime = time - startTime;
        startTime = time;
        if(!first){
            Serial.print('(');
            Serial.print(iteration + 1);
            Serial.print("".) "");
            Serial.print(elapsedTime);
            Serial.print(' ');
            Serial.println(periodTime);
            int humidity = map(elapsedTime, 0, 1500, 0, 100);
            if(iteration == 0){
                jumps[iteration++] = humidity;
            }else if(iteration < 100){
                jumps[iteration++] = humidity;
                int jump = abs(jumps[iteration - 1] - jumps[iteration - 2]);
                if(jump > maxJump){
                    maxJump = jump;
                }
                if(jump > 15){ //mogu da napisem 15 jer je raspon od 0 do 100 isto kao i procenti
                    Serial.print(""[BIG-JUMP] There was a big diff. "");
                    Serial.print(jump);
                    Serial.println("" [%]"");
                }
            }else{
                //druga tacka
                int errCnt = 0;
                for(int i = 1; i < 99; ++i){
                    if( (abs(jumps[i] - jumps[i - 1]) > 20 &&
                       abs(jumps[i] - jumps[i + 1]) > 20) ||
                       (abs(jumps[i] - jumps[i - 1]) < 20 &&
                            abs(jumps[i] - jumps[i + 1]) < 20)){
                        Serial.print(""[ERROR nm. "");
                        Serial.print(++errCnt);
                        Serial.print(""] Approx: "");
                        Serial.println((jumps[i + 1] + jumps[i - 1]) / 2);
                        delay(50);
                   }
                }
                //prva tacka
                Serial.print(""[BIGGEST-JUMP] Biggest diff. was "");
                Serial.println(maxJump);
                resetIterations();
            }
        }else{
            first = false;
        }
    }
    oldState = newState;
}

void setup()
{
    Serial.begin(9600);
    oldState = digitalRead(pin);
    startTime = millis();
    resetIterations();
    pwmSin(33, 1500, 0.1);
    createTask(tracking, 1, TASK_ENABLE, NULL);
}

void loop()
{

}
"
3PRt2yw3,snowball,dimitarbogdanov,C#,Saturday 3rd of June 2023 04:57:08 PM CDT,"int n = int.Parse(Console.ReadLine()!);

double biggestSBV = 0;

for (int i = 0; i < n; i++)
{
    int snowballSnow = int.Parse(Console.ReadLine()!);
    int snowballTime = int.Parse(Console.ReadLine()!);
    int snowballQuality = int.Parse(Console.ReadLine()!);

    double snowballValue = Math.Pow((snowballSnow / snowballTime), snowballQuality);

    if (snowballValue > biggestSBV)
    {
        biggestSBV = snowballValue;
    }
}

Console.WriteLine($""{biggestSBV:F2}"");"
Y6rtpCLw,ascii,dimitarbogdanov,C#,Saturday 3rd of June 2023 04:48:21 PM CDT,"int n = int.Parse(Console.ReadLine()!);

int startLetter = 97;

for (int i = 0; i < n; i++)
{
    for (int j = 0; j < n; j++)
    {
        for (int k = 0; k < n; k++)
        {
            char firstLetter = (char) (startLetter + i);
            Console.Write(firstLetter);
            
            char secondLetter = (char) (startLetter + j);
            Console.Write(secondLetter);
            
            char thirdLetter = (char) (startLetter + k);
            Console.WriteLine(thirdLetter);
        }
    }
}"
ZpWpj2Lp,Área del círculo. Simple. Python,JPablos,Python,Saturday 3rd of June 2023 04:45:09 PM CDT,"# -*- coding: utf-8 -*-
""""""
Created on Sat Jun  3 23:27:44 2023

Este código permite calcular el área del círculo, el usuario debe
ingresar el radio y puede elegir entre 'cm/metros' como unidades.

Se implementa un Control de Errores que sustituye "","" por ""."" evitando el error
de 'float', o genera un mensaje de error si se ingresan valores que no sean
numéricos.

Utiliza tkinter para generar una interfaz gráfica.

@alpha
""""""

import math
import tkinter as tk


def calcular_area():
    """"""
    Este código permite calcular el área del círculo, el usuario debe
    ingresar el radio y puede elegir entre 'cm/metros' como unidades

    Returns
    -------
    Área del círculo.

    """"""
    radio_str = entry_radio.get()
    unidades = var_unidades.get()

    try:
        radio = float(radio_str.replace("","", "".""))
    except ValueError:
        resultado_text.config(state=tk.NORMAL)
        resultado_text.delete(""1.0"", tk.END)
        resultado_text.tag_configure(
            ""error"", foreground=""red"", font=(""Courier New"", 10, ""bold""))
        resultado_text.insert(
            tk.END, ""Error: Radio inválido.\nIngrese un valor numérico."", ""error"")
        resultado_text.config(state=tk.DISABLED)
        return

    area = math.pi * (radio**2)
    resultado_text.config(state=tk.NORMAL)
    resultado_text.delete(""1.0"", tk.END)
    resultado_text.insert(
        tk.END, f""El área del círculo es: {area:.4f} {unidades}^2"")
    resultado_text.config(state=tk.DISABLED)


# Crear ventana
ventana = tk.Tk()
ventana.title(""Cálculo de área de un círculo"")

# Etiqueta y entrada para el radio
label_radio = tk.Label(ventana, text=""Radio:"")
label_radio.pack()
entry_radio = tk.Entry(ventana)
entry_radio.pack()

# Opciones para las unidades
var_unidades = tk.StringVar(value=""cm"")

radio_cm = tk.Radiobutton(
    ventana, text=""cm"", variable=var_unidades, value=""cm"")
radio_cm.pack()
radio_metros = tk.Radiobutton(
    ventana, text=""metros"", variable=var_unidades, value=""metros"")
radio_metros.pack()

# Botón de calcular
boton_calcular = tk.Button(
    ventana, text=""Calcular área"", command=calcular_area)
boton_calcular.pack()

# Resultado
resultado_text = tk.Text(ventana, height=5, width=50)
resultado_text.config(state=tk.DISABLED)
resultado_text.pack()

# Iniciar bucle de eventos
ventana.mainloop()
"
GKW60KG3,factoriel,dimitarbogdanov,C#,Saturday 3rd of June 2023 04:29:13 PM CDT,"// resharper disable all

string input = Console.ReadLine()!;

int factorialSum = 0;
for (int i = 0; i < input.Length; i++)
{
    char currentChar = input[i];
    int parsedChar = int.Parse(currentChar.ToString());
    
    int factForThisChar = 1;
    for (int j = 1; j <= parsedChar; j++)
    {
        factForThisChar = factForThisChar * j;
    }

    factorialSum += factForThisChar;
}

int inputParsed = int.Parse(input);
int factForInput = 1;
for (int i = 1; i <= inputParsed; i++)
{
    factForInput = factForInput * i;
}

if (factForInput != factorialSum)
{
    Console.WriteLine(""not equal :("");
}
else
{
    Console.WriteLine(""equal!!! :D"");
}"
D8ZV3kX8,Nigerian scammers [3-6-2/2023],bombaires,HTML,Saturday 3rd of June 2023 04:22:39 PM CDT,"<a href=""mailto:george.morgan2009@gmail.com"">george.morgan2009@gmail.com</a>
<a href=""mailto:g.e.orge.m.o.rga.n.20.09@gmail.com"">g.e.orge.m.o.rga.n.20.09@gmail.com</a>
<a href=""mailto:g.eorge.mo.rgan.200.9@gmail.com"">g.eorge.mo.rgan.200.9@gmail.com</a>
<a href=""mailto:g.e.org.e..mo.rg.an20.09@gmail.com"">g.e.org.e..mo.rg.an20.09@gmail.com</a>
<a href=""mailto:g.eo.rge...mo.r.gan2.00.9@gmail.com"">g.eo.rge...mo.r.gan2.00.9@gmail.com</a>
<a href=""mailto:g.e.or.g.e...mor.gan.2.009@gmail.com"">g.e.or.g.e...mor.gan.2.009@gmail.com</a>
<a href=""mailto:g.eor.g.e...mor.g.a.n200.9@gmail.com"">g.eor.g.e...mor.g.a.n200.9@gmail.com</a>
<a href=""mailto:geo.rg.e...m.orga.n2009@gmail.com"">geo.rg.e...m.orga.n2009@gmail.com</a>
<a href=""mailto:ge.org.e..m.o.rgan20.0.9@gmail.com"">ge.org.e..m.o.rgan20.0.9@gmail.com</a>
<a href=""mailto:g.eorge..mo.r.g.an20.09@gmail.com"">g.eorge..mo.r.g.an20.09@gmail.com</a>
<a href=""mailto:g.e.o.rge.m.o.rga.n2009@gmail.com"">g.e.o.rge.m.o.rga.n2009@gmail.com</a>
<a href=""mailto:georg.e.mo.r.g.a.n.2.009@gmail.com"">georg.e.mo.r.g.a.n.2.009@gmail.com</a>
<a href=""mailto:g.eo.rge..m.organ2.00.9@gmail.com"">g.eo.rge..m.organ2.00.9@gmail.com</a>
<a href=""mailto:g.e.o.r.g.e...m.o.rga.n.20.09@gmail.com"">g.e.o.r.g.e...m.o.rga.n.20.09@gmail.com</a>
<a href=""mailto:ge.o.r.g.e..mor.gan.2009@gmail.com"">ge.o.r.g.e..mor.gan.2009@gmail.com</a>
<a href=""mailto:geor.ge..m.o.rgan.200.9@gmail.com"">geor.ge..m.o.rgan.200.9@gmail.com</a>
<a href=""mailto:ge.o.r.ge...m.o.rgan2.0.0.9@gmail.com"">ge.o.r.ge...m.o.rgan2.0.0.9@gmail.com</a>
<a href=""mailto:g.eor.ge.morgan.2.0.09@gmail.com"">g.eor.ge.morgan.2.0.09@gmail.com</a>
<a href=""mailto:g.e.o.rg.e..m.org.a.n.2009@gmail.com"">g.e.o.rg.e..m.org.a.n.2009@gmail.com</a>
<a href=""mailto:g.eo.r.ge..mo.r.gan.20.0.9@gmail.com"">g.eo.r.ge..mo.r.gan.20.0.9@gmail.com</a>
<a href=""mailto:ge.o.r.ge..mor.g.an.2.00.9@gmail.com"">ge.o.r.ge..mor.g.an.2.00.9@gmail.com</a>
<a href=""mailto:g.eo.rge...m.or.g.a.n2.0.0.9@gmail.com"">g.eo.rge...m.or.g.a.n2.0.0.9@gmail.com</a>
<a href=""mailto:g.e.o.r.g.e..m.o.r.g.an2.0.0.9@gmail.com"">g.e.o.r.g.e..m.o.r.g.an2.0.0.9@gmail.com</a>
<a href=""mailto:g.e.o.rge...mor.ga.n.20.0.9@gmail.com"">g.e.o.rge...mor.ga.n.20.0.9@gmail.com</a>
<a href=""mailto:g.eorg.e.morgan.2009@gmail.com"">g.eorg.e.morgan.2009@gmail.com</a>
<a href=""mailto:g.eo.rg.e..morgan2.00.9@gmail.com"">g.eo.rg.e..morgan2.00.9@gmail.com</a>
<a href=""mailto:g.eorge..m.o.rga.n20.0.9@gmail.com"">g.eorge..m.o.rga.n20.0.9@gmail.com</a>
<a href=""mailto:g.e.or.g.e..m.o.r.g.a.n.20.09@gmail.com"">g.e.or.g.e..m.o.r.g.a.n.20.09@gmail.com</a>
<a href=""mailto:g.e.orge.m.o.rg.an.20.09@gmail.com"">g.e.orge.m.o.rg.an.20.09@gmail.com</a>
<a href=""mailto:geo.rge...morgan.2.0.0.9@gmail.com"">geo.rge...morgan.2.0.0.9@gmail.com</a>
<a href=""mailto:g.eo.rge..m.o.rg.a.n.200.9@gmail.com"">g.eo.rge..m.o.rg.a.n.200.9@gmail.com</a>
<a href=""mailto:ge.o.r.ge..m.org.a.n.20.09@gmail.com"">ge.o.r.ge..m.org.a.n.20.09@gmail.com</a>
<a href=""mailto:ge.orge.mo.r.ga.n.200.9@gmail.com"">ge.orge.mo.r.ga.n.200.9@gmail.com</a>
<a href=""mailto:georg.e..m.orga.n.2.0.09@gmail.com"">georg.e..m.orga.n.2.0.09@gmail.com</a>
<a href=""mailto:g.e.or.g.e..m.o.r.g.a.n.200.9@gmail.com"">g.e.or.g.e..m.o.r.g.a.n.200.9@gmail.com</a>
<a href=""mailto:ge.or.ge...m.o.r.ga.n2.0.09@gmail.com"">ge.or.ge...m.o.r.ga.n2.0.09@gmail.com</a>
<a href=""mailto:ge.o.r.ge...m.or.gan.200.9@gmail.com"">ge.o.r.ge...m.or.gan.200.9@gmail.com</a>
<a href=""mailto:g.e.org.e..m.o.r.gan.2.009@gmail.com"">g.e.org.e..m.o.r.gan.2.009@gmail.com</a>
<a href=""mailto:g.eorg.e.morga.n.2.0.09@gmail.com"">g.eorg.e.morga.n.2.0.09@gmail.com</a>
<a href=""mailto:geo.rge..mor.g.an2.009@gmail.com"">geo.rge..mor.g.an2.009@gmail.com</a>
<a href=""mailto:g.eo.rge.mor.g.an.200.9@gmail.com"">g.eo.rge.mor.g.an.200.9@gmail.com</a>
<a href=""mailto:g.eo.r.g.e.mo.r.g.a.n.20.09@gmail.com"">g.eo.r.g.e.mo.r.g.a.n.20.09@gmail.com</a>
<a href=""mailto:g.e.org.e.m.o.rgan.20.09@gmail.com"">g.e.org.e.m.o.rgan.20.09@gmail.com</a>
<a href=""mailto:g.eor.ge..m.o.r.ga.n20.0.9@gmail.com"">g.eor.ge..m.o.r.ga.n20.0.9@gmail.com</a>
<a href=""mailto:ge.o.r.ge.mo.rgan20.0.9@gmail.com"">ge.o.r.ge.mo.rgan20.0.9@gmail.com</a>
<a href=""mailto:geo.rg.e...mo.r.g.a.n2009@gmail.com"">geo.rg.e...mo.r.g.a.n2009@gmail.com</a>
<a href=""mailto:ge.org.e...mor.g.an.20.0.9@gmail.com"">ge.org.e...mor.g.an.20.0.9@gmail.com</a>
<a href=""mailto:g.eor.g.e..m.organ2.00.9@gmail.com"">g.eor.g.e..m.organ2.00.9@gmail.com</a>
<a href=""mailto:geo.rge.mo.rgan2009@gmail.com"">geo.rge.mo.rgan2009@gmail.com</a>
<a href=""mailto:geor.g.e...m.o.r.ga.n2.0.09@gmail.com"">geor.g.e...m.o.r.ga.n2.0.09@gmail.com</a>
<a href=""mailto:g.eo.rg.e.mo.rg.a.n.2.009@gmail.com"">g.eo.rg.e.mo.rg.a.n.2.009@gmail.com</a>
<a href=""mailto:geor.g.e..morg.a.n200.9@gmail.com"">geor.g.e..morg.a.n200.9@gmail.com</a>
<a href=""mailto:g.eorg.e..mor.ga.n.2009@gmail.com"">g.eorg.e..mor.ga.n.2009@gmail.com</a>
<a href=""mailto:ge.o.r.g.e..mo.rgan.2.009@gmail.com"">ge.o.r.g.e..mo.rgan.2.009@gmail.com</a>
<a href=""mailto:g.e.org.e..m.organ.2.00.9@gmail.com"">g.e.org.e..m.organ.2.00.9@gmail.com</a>
<a href=""mailto:geo.r.ge.m.org.an.200.9@gmail.com"">geo.r.ge.m.org.an.200.9@gmail.com</a>
<a href=""mailto:g.eo.rg.e.m.o.rgan.2.0.09@gmail.com"">g.eo.rg.e.m.o.rgan.2.0.09@gmail.com</a>
<a href=""mailto:g.eo.r.ge..m.o.r.gan.200.9@gmail.com"">g.eo.r.ge..m.o.r.gan.200.9@gmail.com</a>
<a href=""mailto:geo.rge.morgan.2.00.9@gmail.com"">geo.rge.morgan.2.00.9@gmail.com</a>
<a href=""mailto:ge.o.r.ge...m.org.an2.0.0.9@gmail.com"">ge.o.r.ge...m.org.an2.0.0.9@gmail.com</a>
<a href=""mailto:g.e.or.ge.mo.rga.n2.0.09@gmail.com"">g.e.or.ge.mo.rga.n2.0.09@gmail.com</a>
<a href=""mailto:g.eo.rge..m.o.rga.n.20.0.9@gmail.com"">g.eo.rge..m.o.rga.n.20.0.9@gmail.com</a>
<a href=""mailto:g.eorge..mo.r.g.an2.00.9@gmail.com"">g.eorge..mo.r.g.an2.00.9@gmail.com</a>
<a href=""mailto:g.eor.ge...mor.g.a.n2.0.09@gmail.com"">g.eor.ge...mor.g.a.n2.0.09@gmail.com</a>
<a href=""mailto:g.e.o.r.ge..mo.rg.a.n200.9@gmail.com"">g.e.o.r.ge..mo.rg.a.n200.9@gmail.com</a>
<a href=""mailto:g.e.o.r.g.e.m.o.r.g.a.n2.00.9@gmail.com"">g.e.o.r.g.e.m.o.r.g.a.n2.00.9@gmail.com</a>
<a href=""mailto:geo.rge...m.or.gan.200.9@gmail.com"">geo.rge...m.or.gan.200.9@gmail.com</a>
<a href=""mailto:ge.or.ge.mo.r.gan.2.0.09@gmail.com"">ge.or.ge.mo.r.gan.2.0.09@gmail.com</a>
<a href=""mailto:geo.rge..mor.ga.n20.09@gmail.com"">geo.rge..mor.ga.n20.09@gmail.com</a>
<a href=""mailto:geor.ge.m.or.ga.n.2.0.09@gmail.com"">geor.ge.m.or.ga.n.2.0.09@gmail.com</a>
<a href=""mailto:g.eorge...m.o.rg.an2.009@gmail.com"">g.eorge...m.o.rg.an2.009@gmail.com</a>
<a href=""mailto:george...m.o.r.g.an2.0.09@gmail.com"">george...m.o.r.g.an2.0.09@gmail.com</a>
<a href=""mailto:g.e.org.e...m.o.rgan2.0.09@gmail.com"">g.e.org.e...m.o.rgan2.0.09@gmail.com</a>
<a href=""mailto:geo.rge.m.o.rgan.2.00.9@gmail.com"">geo.rge.m.o.rgan.2.00.9@gmail.com</a>
<a href=""mailto:g.eo.r.ge...m.or.g.a.n.2.009@gmail.com"">g.eo.r.ge...m.or.g.a.n.2.009@gmail.com</a>
<a href=""mailto:g.e.o.r.g.e.mo.rg.a.n2009@gmail.com"">g.e.o.r.g.e.mo.rg.a.n2009@gmail.com</a>
<a href=""mailto:geo.r.ge..m.or.g.an2009@gmail.com"">geo.r.ge..m.or.g.an2009@gmail.com</a>
<a href=""mailto:ge.o.rg.e..m.o.rg.a.n.2.00.9@gmail.com"">ge.o.rg.e..m.o.rg.a.n.2.00.9@gmail.com</a>
<a href=""mailto:g.e.or.g.e.m.org.a.n20.09@gmail.com"">g.e.or.g.e.m.org.a.n20.09@gmail.com</a>
<a href=""mailto:g.e.orge..m.organ.20.0.9@gmail.com"">g.e.orge..m.organ.20.0.9@gmail.com</a>
<a href=""mailto:g.eo.r.g.e...m.or.g.an.2.00.9@gmail.com"">g.eo.r.g.e...m.or.g.an.2.00.9@gmail.com</a>
<a href=""mailto:geo.rge..mor.gan2.0.09@gmail.com"">geo.rge..mor.gan2.0.09@gmail.com</a>
<a href=""mailto:ge.or.g.e..m.o.r.g.a.n20.09@gmail.com"">ge.or.g.e..m.o.r.g.a.n20.09@gmail.com</a>
<a href=""mailto:g.e.o.rge..m.o.rgan.20.0.9@gmail.com"">g.e.o.rge..m.o.rgan.20.0.9@gmail.com</a>
<a href=""mailto:g.eor.ge..m.o.r.gan.20.09@gmail.com"">g.eor.ge..m.o.r.gan.20.09@gmail.com</a>
<a href=""mailto:geor.g.e...m.o.rgan2009@gmail.com"">geor.g.e...m.o.rgan2009@gmail.com</a>
<a href=""mailto:ge.o.rge..mor.gan.2009@gmail.com"">ge.o.rge..mor.gan.2009@gmail.com</a>
<a href=""mailto:geo.r.g.e.mo.r.gan2.00.9@gmail.com"">geo.r.g.e.mo.r.gan2.00.9@gmail.com</a>
<a href=""mailto:g.eo.r.ge..mo.r.g.an.20.0.9@gmail.com"">g.eo.r.ge..mo.r.g.an.20.0.9@gmail.com</a>
<a href=""mailto:ge.org.e..m.o.rgan.2.00.9@gmail.com"">ge.org.e..m.o.rgan.2.00.9@gmail.com</a>
<a href=""mailto:g.e.org.e.mor.g.an.2.0.09@gmail.com"">g.e.org.e.mor.g.an.2.0.09@gmail.com</a>
<a href=""mailto:geo.rge..m.o.r.g.an2.0.0.9@gmail.com"">geo.rge..m.o.r.g.an2.0.0.9@gmail.com</a>
<a href=""mailto:g.eo.r.g.e..morga.n2.0.0.9@gmail.com"">g.eo.r.g.e..morga.n2.0.0.9@gmail.com</a>
<a href=""mailto:ge.or.ge.morg.an.20.0.9@gmail.com"">ge.or.ge.morg.an.20.0.9@gmail.com</a>
<a href=""mailto:ge.o.r.ge.mo.rg.an.2.00.9@gmail.com"">ge.o.r.ge.mo.rg.an.2.00.9@gmail.com</a>
<a href=""mailto:geo.r.g.e..m.org.an.2009@gmail.com"">geo.r.g.e..m.org.an.2009@gmail.com</a>
<a href=""mailto:geo.r.g.e...m.or.g.an.2.0.0.9@gmail.com"">geo.r.g.e...m.or.g.an.2.0.0.9@gmail.com</a>
<a href=""mailto:g.e.o.r.g.e...mo.r.g.an20.09@gmail.com"">g.e.o.r.g.e...mo.r.g.an20.09@gmail.com</a>
<a href=""mailto:georg.e...morgan.2.0.09@gmail.com"">georg.e...morgan.2.0.09@gmail.com</a>
<a href=""mailto:g.e.or.ge.m.o.r.g.an.2.009@gmail.com"">g.e.or.ge.m.o.r.g.an.2.009@gmail.com</a>
<a href=""mailto:g.eo.rg.e..m.org.a.n200.9@gmail.com"">g.eo.rg.e..m.org.a.n200.9@gmail.com</a>
<a href=""mailto:g.e.o.rge..m.or.ga.n.20.09@gmail.com"">g.e.o.rge..m.or.ga.n.20.09@gmail.com</a>
<a href=""mailto:g.e.or.g.e.mo.rga.n.20.09@gmail.com"">g.e.or.g.e.mo.rga.n.20.09@gmail.com</a>
<a href=""mailto:ge.orge.m.org.an.200.9@gmail.com"">ge.orge.m.org.an.200.9@gmail.com</a>
<a href=""mailto:george..m.or.gan.200.9@gmail.com"">george..m.or.gan.200.9@gmail.com</a>
<a href=""mailto:ge.o.r.ge.m.org.a.n2.0.0.9@gmail.com"">ge.o.r.ge.m.org.a.n2.0.0.9@gmail.com</a>
<a href=""mailto:g.eo.rge..morg.an200.9@gmail.com"">g.eo.rge..morg.an200.9@gmail.com</a>
<a href=""mailto:ge.o.rge.mor.gan.200.9@gmail.com"">ge.o.rge.mor.gan.200.9@gmail.com</a>
<a href=""mailto:ge.or.g.e...mo.rgan20.0.9@gmail.com"">ge.or.g.e...mo.rgan20.0.9@gmail.com</a>
<a href=""mailto:g.e.or.g.e..morg.a.n2.0.09@gmail.com"">g.e.or.g.e..morg.a.n2.0.09@gmail.com</a>
<a href=""mailto:g.eo.r.ge.m.or.g.an2.0.09@gmail.com"">g.eo.r.ge.m.or.g.an2.0.09@gmail.com</a>
<a href=""mailto:g.e.orge..m.organ20.0.9@gmail.com"">g.e.orge..m.organ20.0.9@gmail.com</a>
<a href=""mailto:g.eo.rge..morgan2.0.09@gmail.com"">g.eo.rge..morgan2.0.09@gmail.com</a>
<a href=""mailto:g.e.orge...morg.a.n.2.0.09@gmail.com"">g.e.orge...morg.a.n.2.0.09@gmail.com</a>
<a href=""mailto:ge.or.g.e...mo.rg.a.n.2.009@gmail.com"">ge.or.g.e...mo.rg.a.n.2.009@gmail.com</a>
<a href=""mailto:ge.orge...m.o.rg.an20.09@gmail.com"">ge.orge...m.o.rg.an20.09@gmail.com</a>
<a href=""mailto:george.m.o.rg.an.2.00.9@gmail.com"">george.m.o.rg.an.2.00.9@gmail.com</a>
<a href=""mailto:ge.org.e..m.organ2.0.09@gmail.com"">ge.org.e..m.organ2.0.09@gmail.com</a>
<a href=""mailto:g.e.o.r.ge..morga.n2009@gmail.com"">g.e.o.r.ge..morga.n2009@gmail.com</a>
<a href=""mailto:g.eo.r.g.e...m.o.r.g.an.2.009@gmail.com"">g.eo.r.g.e...m.o.r.g.an.2.009@gmail.com</a>
<a href=""mailto:g.eor.ge..mo.r.ga.n2009@gmail.com"">g.eor.ge..mo.r.ga.n2009@gmail.com</a>
<a href=""mailto:g.eor.ge..m.o.r.gan.200.9@gmail.com"">g.eor.ge..m.o.r.gan.200.9@gmail.com</a>
<a href=""mailto:geo.r.g.e...m.o.r.g.a.n2.0.0.9@gmail.com"">geo.r.g.e...m.o.r.g.a.n2.0.0.9@gmail.com</a>
<a href=""mailto:ge.org.e...m.o.r.ga.n2009@gmail.com"">ge.org.e...m.o.r.ga.n2009@gmail.com</a>
<a href=""mailto:ge.org.e..m.o.r.g.an.20.0.9@gmail.com"">ge.org.e..m.o.r.g.an.20.0.9@gmail.com</a>
<a href=""mailto:g.e.or.g.e.mo.r.ga.n.200.9@gmail.com"">g.e.or.g.e.mo.r.ga.n.200.9@gmail.com</a>
<a href=""mailto:g.eorg.e..morg.a.n2.009@gmail.com"">g.eorg.e..morg.a.n2.009@gmail.com</a>
<a href=""mailto:ge.orge...morgan.2.0.09@gmail.com"">ge.orge...morgan.2.0.09@gmail.com</a>
<a href=""mailto:ge.or.g.e...m.o.rg.a.n20.09@gmail.com"">ge.or.g.e...m.o.rg.a.n20.09@gmail.com</a>
<a href=""mailto:georg.e..m.organ20.09@gmail.com"">georg.e..m.organ20.09@gmail.com</a>
<a href=""mailto:g.e.o.rg.e..m.or.g.an.2.0.09@gmail.com"">g.e.o.rg.e..m.or.g.an.2.0.09@gmail.com</a>
<a href=""mailto:g.e.o.r.ge...m.or.g.an.2.00.9@gmail.com"">g.e.o.r.ge...m.or.g.an.2.00.9@gmail.com</a>
<a href=""mailto:g.e.orge..m.or.g.a.n2009@gmail.com"">g.e.orge..m.or.g.a.n2009@gmail.com</a>
<a href=""mailto:g.e.or.ge.m.org.a.n2.009@gmail.com"">g.e.or.ge.m.org.a.n2.009@gmail.com</a>
<a href=""mailto:ge.o.r.ge..m.o.rg.an.2.0.0.9@gmail.com"">ge.o.r.ge..m.o.rg.an.2.0.0.9@gmail.com</a>
<a href=""mailto:geo.r.g.e..mo.rg.a.n2.0.09@gmail.com"">geo.r.g.e..mo.rg.a.n2.0.09@gmail.com</a>
<a href=""mailto:g.e.org.e..mo.rgan20.0.9@gmail.com"">g.e.org.e..mo.rgan20.0.9@gmail.com</a>
<a href=""mailto:ge.o.rge...m.or.g.a.n.2.0.09@gmail.com"">ge.o.rge...m.or.g.a.n.2.0.09@gmail.com</a>
<a href=""mailto:g.e.orge.m.org.an.2.00.9@gmail.com"">g.e.orge.m.org.an.2.00.9@gmail.com</a>
<a href=""mailto:ge.o.r.g.e...mo.rg.a.n20.0.9@gmail.com"">ge.o.r.g.e...mo.rg.a.n20.0.9@gmail.com</a>
<a href=""mailto:geor.ge.morg.an2.0.0.9@gmail.com"">geor.ge.morg.an2.0.0.9@gmail.com</a>
<a href=""mailto:g.eorg.e...m.organ2.009@gmail.com"">g.eorg.e...m.organ2.009@gmail.com</a>
<a href=""mailto:ge.orge..mo.rg.an.2.0.0.9@gmail.com"">ge.orge..mo.rg.an.2.0.0.9@gmail.com</a>
<a href=""mailto:g.e.orge.mo.rg.a.n20.09@gmail.com"">g.e.orge.mo.rg.a.n20.09@gmail.com</a>
<a href=""mailto:geo.r.g.e..mo.r.gan2009@gmail.com"">geo.r.g.e..mo.r.gan2009@gmail.com</a>
<a href=""mailto:g.eo.rge..m.o.rgan2009@gmail.com"">g.eo.rge..m.o.rgan2009@gmail.com</a>
<a href=""mailto:g.eo.r.ge..morg.an2.009@gmail.com"">g.eo.r.ge..morg.an2.009@gmail.com</a>
<a href=""mailto:geor.g.e...mo.rga.n2.00.9@gmail.com"">geor.g.e...mo.rga.n2.00.9@gmail.com</a>
<a href=""mailto:geor.g.e..m.org.an.2009@gmail.com"">geor.g.e..m.org.an.2009@gmail.com</a>
<a href=""mailto:ge.o.r.g.e..morgan200.9@gmail.com"">ge.o.r.g.e..morgan200.9@gmail.com</a>
<a href=""mailto:ge.o.rge...m.o.rg.a.n200.9@gmail.com"">ge.o.rge...m.o.rg.a.n200.9@gmail.com</a>
<a href=""mailto:geo.rg.e..m.or.g.a.n.20.09@gmail.com"">geo.rg.e..m.or.g.a.n.20.09@gmail.com</a>
<a href=""mailto:georg.e..mo.rg.a.n.2.00.9@gmail.com"">georg.e..mo.rg.a.n.2.00.9@gmail.com</a>
<a href=""mailto:g.eorg.e...mo.r.g.a.n2009@gmail.com"">g.eorg.e...mo.r.g.a.n2009@gmail.com</a>
<a href=""mailto:ge.org.e...m.or.g.a.n2.00.9@gmail.com"">ge.org.e...m.or.g.a.n2.00.9@gmail.com</a>
<a href=""mailto:g.e.or.ge.mo.rgan2009@gmail.com"">g.e.or.ge.mo.rgan2009@gmail.com</a>
<a href=""mailto:ge.or.g.e..m.org.an2.0.09@gmail.com"">ge.or.g.e..m.org.an2.0.09@gmail.com</a>
<a href=""mailto:geor.g.e.mo.rgan2.00.9@gmail.com"">geor.g.e.mo.rgan2.00.9@gmail.com</a>
<a href=""mailto:geo.rge..m.o.r.g.an.2.009@gmail.com"">geo.rge..m.o.r.g.an.2.009@gmail.com</a>
<a href=""mailto:g.e.or.g.e..mor.ga.n2.0.09@gmail.com"">g.e.or.g.e..mor.ga.n2.0.09@gmail.com</a>
<a href=""mailto:g.e.o.rg.e.m.o.r.gan.2.00.9@gmail.com"">g.e.o.rg.e.m.o.r.gan.2.00.9@gmail.com</a>
<a href=""mailto:georg.e...m.orga.n.2009@gmail.com"">georg.e...m.orga.n.2009@gmail.com</a>
<a href=""mailto:g.eorge...m.o.rgan.2.009@gmail.com"">g.eorge...m.o.rgan.2.009@gmail.com</a>
<a href=""mailto:g.eo.rge.m.orga.n.2.00.9@gmail.com"">g.eo.rge.m.orga.n.2.00.9@gmail.com</a>
<a href=""mailto:g.eo.rg.e.m.orga.n2.0.09@gmail.com"">g.eo.rg.e.m.orga.n2.0.09@gmail.com</a>
<a href=""mailto:ge.o.rge.m.o.rgan2.00.9@gmail.com"">ge.o.rge.m.o.rgan2.00.9@gmail.com</a>
<a href=""mailto:g.e.orge..m.o.r.gan.200.9@gmail.com"">g.e.orge..m.o.r.gan.200.9@gmail.com</a>
<a href=""mailto:ge.or.g.e..morg.an20.09@gmail.com"">ge.or.g.e..morg.an20.09@gmail.com</a>
<a href=""mailto:g.e.o.r.ge...m.or.g.a.n20.09@gmail.com"">g.e.o.r.ge...m.or.g.a.n20.09@gmail.com</a>
<a href=""mailto:george..m.or.g.an20.09@gmail.com"">george..m.or.g.an20.09@gmail.com</a>
<a href=""mailto:g.e.or.g.e.m.organ2.0.0.9@gmail.com"">g.e.or.g.e.m.organ2.0.0.9@gmail.com</a>
<a href=""mailto:geor.g.e.m.o.rg.an20.09@gmail.com"">geor.g.e.m.o.rg.an20.09@gmail.com</a>
<a href=""mailto:g.eo.rg.e..m.o.r.g.an.2.00.9@gmail.com"">g.eo.rg.e..m.o.r.g.an.2.00.9@gmail.com</a>
<a href=""mailto:g.e.o.rg.e...mo.rga.n.200.9@gmail.com"">g.e.o.rg.e...mo.rga.n.200.9@gmail.com</a>
<a href=""mailto:g.eorge..morg.an.2.009@gmail.com"">g.eorge..morg.an.2.009@gmail.com</a>
<a href=""mailto:g.eo.r.ge.m.organ.2009@gmail.com"">g.eo.r.ge.m.organ.2009@gmail.com</a>
<a href=""mailto:g.e.org.e...m.o.rg.an20.0.9@gmail.com"">g.e.org.e...m.o.rg.an20.0.9@gmail.com</a>
<a href=""mailto:ge.or.g.e...m.or.gan2.009@gmail.com"">ge.or.g.e...m.or.gan2.009@gmail.com</a>
<a href=""mailto:ge.or.g.e..mo.rgan200.9@gmail.com"">ge.or.g.e..mo.rgan200.9@gmail.com</a>
<a href=""mailto:george..m.or.g.an.20.09@gmail.com"">george..m.or.g.an.20.09@gmail.com</a>
<a href=""mailto:g.e.org.e..mor.ga.n.2009@gmail.com"">g.e.org.e..mor.ga.n.2009@gmail.com</a>
<a href=""mailto:g.eor.g.e.mor.g.an20.09@gmail.com"">g.eor.g.e.mor.g.an20.09@gmail.com</a>
<a href=""mailto:george...mor.g.an.20.09@gmail.com"">george...mor.g.an.20.09@gmail.com</a>
<a href=""mailto:geo.r.g.e.morg.a.n2.0.0.9@gmail.com"">geo.r.g.e.morg.a.n2.0.0.9@gmail.com</a>
<a href=""mailto:g.e.o.r.ge...m.or.g.an.200.9@gmail.com"">g.e.o.r.ge...m.or.g.an.200.9@gmail.com</a>
<a href=""mailto:g.eor.ge..mo.rgan2.009@gmail.com"">g.eor.ge..mo.rgan2.009@gmail.com</a>
<a href=""mailto:ge.o.rg.e..m.org.an.20.0.9@gmail.com"">ge.o.rg.e..m.org.an.20.0.9@gmail.com</a>
<a href=""mailto:g.eo.rge..morga.n.2.00.9@gmail.com"">g.eo.rge..morga.n.2.00.9@gmail.com</a>
<a href=""mailto:g.e.or.ge.m.or.gan.200.9@gmail.com"">g.e.or.ge.m.or.gan.200.9@gmail.com</a>
<a href=""mailto:georg.e..mo.rg.an200.9@gmail.com"">georg.e..mo.rg.an200.9@gmail.com</a>
<a href=""mailto:george.m.o.rg.a.n.20.09@gmail.com"">george.m.o.rg.a.n.20.09@gmail.com</a>
<a href=""mailto:g.eorge.mo.r.g.a.n.20.0.9@gmail.com"">g.eorge.mo.r.g.a.n.20.0.9@gmail.com</a>
<a href=""mailto:geo.r.g.e..mo.r.g.a.n.2.0.0.9@gmail.com"">geo.r.g.e..mo.r.g.a.n.2.0.0.9@gmail.com</a>
<a href=""mailto:g.eo.r.ge..m.o.rg.an.2.00.9@gmail.com"">g.eo.r.ge..m.o.rg.an.2.00.9@gmail.com</a>
<a href=""mailto:g.e.o.r.ge.m.or.ga.n.200.9@gmail.com"">g.e.o.r.ge.m.or.ga.n.200.9@gmail.com</a>
<a href=""mailto:geo.r.ge..mor.g.a.n.2.00.9@gmail.com"">geo.r.ge..mor.g.a.n.2.00.9@gmail.com</a>
<a href=""mailto:geo.rg.e.mo.r.ga.n.2.00.9@gmail.com"">geo.rg.e.mo.r.ga.n.2.00.9@gmail.com</a>
<a href=""mailto:g.e.or.ge.mo.rg.an20.09@gmail.com"">g.e.or.ge.mo.rg.an20.09@gmail.com</a>
<a href=""mailto:g.eo.rg.e..m.or.g.a.n2.0.0.9@gmail.com"">g.eo.rg.e..m.or.g.a.n2.0.0.9@gmail.com</a>
<a href=""mailto:g.e.orge...mor.g.an.200.9@gmail.com"">g.e.orge...mor.g.an.200.9@gmail.com</a>
<a href=""mailto:g.e.or.g.e...m.organ.2.0.09@gmail.com"">g.e.or.g.e...m.organ.2.0.09@gmail.com</a>"
iaxbaN5P,Untitled,kjmkj,C++,Saturday 3rd of June 2023 04:05:26 PM CDT,"#include <bits/stdc++.h>

using namespace std;
#define int long long
#define double long double
#define pb push_back
#define randGen mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())

const int INF = 1e18;
const int MOD = 1e9 + 7;
map<int, int> a;

signed main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  cout.tie(NULL);
  int n;
  cin >> n;
  vector<int> sum[n + 1], sum1[n + 1];
  for (int i = 0; i < n; ++i) {
    int h;
    cin >> h;
    for (int j = 1; j * j <= h && j <= n; ++j) {
      if (h / j <= n && h / j != j) {
        sum[h / j].pb(i);
      }
      sum[j].pb(i);
    }
  }

  for (int i = 0; i < n; ++i) {
    if (i > 0) {
      sum1[1].pb(sum1[1].back() + 1);
    } else {
      sum1[1].pb(1);
    }
    sum1[1][sum1[1].size() - 1] %= MOD;
  }
  for (int i = 2; i <= n; ++i) {
    for (int j = 0; j < sum[i].size(); ++j) {
      auto it = lower_bound(sum[i - 1].begin(), sum[i - 1].end(), sum[i][j]);
      int u = it - sum[i - 1].begin(), pl = 0;
      if (u != 0) {
        pl = sum1[i - 1][u - 1];
      }
      if (sum1[i].empty()) {
        sum1[i].pb(pl % MOD);
      } else {
        sum1[i].pb(sum1[i].back() + pl);
        sum1[i][sum1[i].size() - 1] %= MOD;
      }
    }
  }
  int suma = 0;
  for (int i = 1; i <= n; ++i) {
    if (sum1[i].empty()) {
      continue;
    }
    suma += sum1[i].back();
    suma %= MOD;
  }
  cout << suma % MOD;
  return 0;
}
"
sPRqjQHE,Untitled,kjmkj,C++,Saturday 3rd of June 2023 03:51:48 PM CDT,"#include <bits/stdc++.h>

using namespace std;
#define int long long
#define double long double
#define pb push_back
#define randGen mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())

const int INF = 1e18;
const int MOD = 1e9 + 7;
map<int, int> a;

signed main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  cout.tie(NULL);
  int n;
  cin >> n;
  vector<int> sum[n + 1], sum1[n + 1];
  for (int i = 0; i < n; ++i) {
    int h;
    cin >> h;
    for (int j = 1; j * j <= h && j <= n; ++j) {
      if (h / j <= n && h / j != j) {
        sum[h / j].pb(i);
      }
      sum[j].pb(i);
    }
  }

  for (int i = 0; i < n; ++i) {
    if (i > 0) {
      sum1[1].pb(sum1[1].back() + 1);
    } else {
      sum1[1].pb(1);
    }
    sum1[1][sum1[1].size() - 1] %= MOD;
  }
  for (int i = 2; i <= n; ++i) {
    for (int j = 0; j < sum[i].size(); ++j) {
      auto it = lower_bound(sum[i - 1].begin(), sum[i - 1].end(), sum[i][j]);
      int u = it - sum[i - 1].begin(), pl = 0;
      if (u != 0) {
        pl = sum1[i - 1][u - 1];
      }
      if (sum1[i].empty()) {
        sum1[i].pb(pl % MOD);
      } else {
        sum1[i].pb(sum1[i].back() + pl);
        sum1[i][sum1[i].size() - 1] %= MOD;
      }
    }
  }
  int suma = 0;
  for (int i = 1; i <= n; ++i) {
    if (sum1[i].empty()) {
      continue;
    }
    suma += sum1[i].back();
  }
  cout << suma;
  return 0;
}
"
KvcwGbkR,Higman and Kruskal relation,EWTD,Scala,Saturday 3rd of June 2023 03:41:20 PM CDT,"sealed trait Expr{ def HKRelation(expr: Expr): Boolean }

case class Variable(name: String) extends Expr {
  override def toString: String = { name.toLowerCase() }
  override def HKRelation(expr: Expr): Boolean = expr match {
    case Variable(vname) => true
    case Function(fname, fargs) => fargs.nonEmpty && fargs.exists(p => this.HKRelation(p))
    case default => false
  }
}

case class Constant(name: String) extends Expr {
  override def toString: String = { name.toUpperCase() }
  override def HKRelation(expr: Expr): Boolean = expr match {
    case Constant(cname) => name == cname
    case Function(fname, fargs) => fargs.nonEmpty && fargs.exists(p => this.HKRelation(p))
    case default => false
  }
}

case class Function(name: String, args: List[Expr] = List()) extends Expr {
  override def toString: String = {
    val args_str =
      if (args.isEmpty)
        ""()""
      else if (args.length == 1)
        ""("" + args.head.toString + "")""
      else {
        var buffer = args.head.toString
        for(idx <- 1 until args.length) {
          buffer += "", "" + args.apply(idx).toString
        }
        ""("" + buffer + "")""
      }
    name + args_str
  }

  override def HKRelation(expr: Expr): Boolean = expr match {
    case Function(fname, fargs) =>
      fargs.nonEmpty && fargs.exists(p => this.HKRelation(p)) ||
        (name == fname && args.length == fargs.length && args.iterator.zip(fargs.iterator).forall(x => x._1.HKRelation(x._2)))
    case default => false
  }
}

object Main {
  def main(args: Array[String]): Unit = {
    val test1 = ( Function(""Tree"", Function(""Leaf"", Constant(""A"")::Nil) :: Function(""Leaf"", Variable(""x"") :: Nil) :: Nil),
      Function(""Tree"", Function(""Tree"", Function(""Leaf"", Constant(""A"")::Nil) :: Function(""Leaf"", Function(""f"", Variable(""y"") :: Variable(""z"") :: Nil) :: Nil) :: Nil) ::
                       Function(""g"", Variable(""y"") :: Variable(""z"") :: Nil) :: Nil))
    val test2 =( Function(""f"", Function(""g"", Function(""h"", Variable(""x"") :: Nil) :: Nil) :: Nil),
      Function(""f"", Function(""h"", Variable(""x"") :: Nil) :: Nil))
    val tests = test1 :: test2 :: Nil
    var testCnt = 1
    for (test <- tests) {
      println(""Test #"" + testCnt)
      println(test._1.toString + "" <= "" + test._2.toString + "" -> "" + test._1.HKRelation(test._2))
      testCnt += 1
    }
  }
}"
pLeZkXH7,Untitled,Salvens,C++,Saturday 3rd of June 2023 03:24:45 PM CDT,"#include <algorithm>
#include <iostream>
#include <iomanip>
#include <cmath>
#include <vector>
#include <set>
#include <map>
#include <string>
#include <cassert>
#include <numeric>
#include <queue>
#include <cstdint>
#include <string>
#include <unordered_map>
using namespace std;

#define int long long
#define IOS ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);

const long long INF = 1e18 + 7;
const double EPS = 1e-9;
const int N = 5010;
const int MOD = 1e9 + 7;
int P = 23039, P1 = 22943;


int d[N][N];
int power[N], power1[N];

int Get(char c) {
    return c - 'a' + 1;
}

void MakeHash(string s, vector<pair<int, int>>& hse) {
    hse[0].first = Get(s[0]);
    hse[0].second = Get(s[0]);
    for (int i = 1; i < s.size(); ++i) {
        hse[i].first = (hse[i - 1].first * P + Get(s[i])) % MOD;
        hse[i].second = (hse[i - 1].second * P1 + Get(s[i]) * power1[i]) % MOD;
    }
}

bool IsPol(string x) {
    string y = x;
    reverse(y.begin(), y.end());
    return x == y;
}

inline void solve() {
    string s;
    int n;
    cin >> s;
    n = s.size();
    string t = s;
    reverse(t.begin(), t.end());

    power[0] = 1;
    power1[0] = 1;
    for (int i = 1; i < n; ++i) {
        power[i] = power[i - 1] * P % MOD;
        power1[i] = power1[i - 1] * P1 % MOD;
    }

    vector<pair<int, int>> pref(n), suff(n);
    MakeHash(s, pref);
    MakeHash(t, suff);

//    for (auto [x, y]: pref) {
//        cout << x << ' ' << y << ' ';
//    }
//    cout << endl;
//    for (auto [x, y]: suff) {
//        cout << x << ' ' << y << ' ';
//    }
//    cout << endl << endl;


    for (int l = 0; l < n; ++l) {
        for (int r = l; r < n; ++r) {

            int l1 = n - 1 - r, r1 = n - 1 - l;

            int x = (pref[r].first - pref[l].first * power[r - l + 1]) % MOD;
            int y = (suff[r1].first - suff[l1].first * power[r1 - l1 + 1]) % MOD;

            int x2 = (pref[r].second - pref[l].second * power1[r - l + 1]) % MOD;
            int y2 = (suff[r1].second - suff[l1].second * power1[r1 - l1 + 1]) % MOD;

            if (x == y && x2 == y2) {
                d[l][r] = 1;
            }
        }
    }

    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            cout << d[i][j] << ' ';
        }
        cout << endl;
    }

    for (int i = 0; i < n; ++i) {
        d[i][i] = 1;
    }
    for (int i = 1; i < n; ++i) {
        for (int x = 0, y = i; y < n; ++x, ++y) {
            d[x][y] += d[x + 1][y] + d[x][y - 1] - d[x + 1][y - 1];
        }
    }

    int q;
    cin >> q;
    while (q--) {
        int x, y;
        cin >> x >> y;
        cout << d[x - 1][y - 1] << ' ';
    }
}



int32_t main() {
    IOS;

    int tt = 1;
//    cin >> t;
    while (tt--) {
        solve();
    }
    return 0;
}

/*
1.  数组开够了没
2.  文件名写对了没，文件夹建了吗
3.  内存会不会MLE
4.  多测清空？
5.  调试删干净了没
6.  取模有没有溢出
7.  快速幂底数要取模，幂对 mod-1 取模
8.  前向星和欧拉序要开2倍数组
9.  比较函数如果值相同的话有没有第二优先级
10. 线段树 4 倍空间，线段树合并和可持久化线段树 32 倍空间
11. 看清楚 log 的底数是啥，log后面的数是啥
12. long long 只有正负 2^63-1
*/"
hdSD0QiH,Can't Stop 2,PrezesSmoku,Python,Saturday 3rd of June 2023 03:12:24 PM CDT,"import pygame
import random
#szerokość i wysokość ekranu
SZEROKOSC_EKRANU = 1280
WYSOKOSC_EKRANU = 960

pygame.init()
ekran = pygame.display.set_mode([SZEROKOSC_EKRANU, WYSOKOSC_EKRANU])
zegar = pygame.time.Clock()
obraz_tla = pygame.image.load('images/mountain.png') 
czcionka = pygame.font.SysFont('Comic Sans MS', 35) #nazwa i rozmiar czcionki
obrazki_kosci = []
#wyniki kości
kosci = [1,1,1,1]
#kombinacje na kościach
kombinacje = []
mozliwe_ruchy = []
wybrane_kolumny = []
zablokowane_kolumny = []
for i in range(4):
    obrazki_kosci.append(pygame.image.load('images/kosc-1.png'))

teksty = [""Naciśnij Spacje""]
liczba_pol = [3,5,7,9,11,13,11,9,7,5,3]
skok_x = 70
skok_y = 50
start_x = 240
start_y = 900

def budowa_planszy():
    #współrzędne pierwszego pola
    x = start_x
    y = start_y
    #numer kolumny
    num = 2
    #Operacje wykonywane dla każdej kolumny
    for kolumna in liczba_pol:
        #modyfikacja współrzędnych
        #przesuwamy x w prawo po każdej zbudowanej kolumnie
        x += skok_x
        #Wracamy na dół kolumny aby zacząć budować nową
        y = start_y
        #budowa jednej kolumny
        for i in range(kolumna):
            #Przesuwamy współrzędną y w górę
            y -= skok_y
            #rysowanie koła które będzie czarną obwódką 
            pygame.draw.circle(ekran, (0, 0, 0), (x,y), 22)
            #rysowanie środka pola - kolor dowolny
            #ważne aby dać inne kolory graczom potem
            pygame.draw.circle(ekran, (255, 230, 0), (x,y), 20)
        #przekształcamy liczbę na tekst 
        numer_kolumny = czcionka.render(str(num), True,(0,0,0))
        #Wyświetlamy to nad kolumną
        #cofamy x odrobinę aby wyśrodkować napis
        ekran.blit(numer_kolumny, (x-10,y-70))
        #Przechodzimy do kolejnej kolumny
        num += 1

def pokaz_teksty():
    #współrzędne tekstu
    x_tekstu = 800
    y_tekstu = 40
    #przesunięcie tekstu między linijkami
    skok_tekstu = 50
    for tekst in teksty:
        #stworzenie linijki. 
        #Kolor potem zmienimy na kolor aktywnego gracza
        linijka = czcionka.render(tekst, True,(0,0,0))
        ekran.blit(linijka, (x_tekstu,y_tekstu))
        y_tekstu += skok_tekstu

def rzut_kosci():
    for i in range(4):
        #losowanie dla jednej kostki
        kosci[i] = random.randrange(1,6)
        #załadowanie obrazka o nazwie zależnej od wyniku losowania
        obrazki_kosci[i] = pygame.image.load(f'images/kosc-{kosci[i]}.png')

def sprawdz_mozliwe_ruchy():
    kombinacje.clear()
    #Wyznaczenie wszystkich kombinacji
    kombinacje.append([kosci[0]+kosci[1], kosci[2]+kosci[3]])
    kombinacje.append([kosci[0]+kosci[2], kosci[1]+kosci[3]])
    kombinacje.append([kosci[0]+kosci[3], kosci[1]+kosci[2]])
    mozliwe_ruchy.clear()
    liczba_opcji = 0
    for i in range(len(kombinacje)):
        # tworzymy nową pustą listę na możliwe ruchy z tej kombinacji kości, 
        # jeśli ruch nie będzie możliwy z tej kombinacji to 
        # pustą listę później usuniemy
        mozliwe_ruchy.append([])
        #3 pionki postawione
        if len(wybrane_kolumny) == 3:
            #Sprawdzamy czy pierwsza suma kości znajduje się 
            # w liście wybranych kolumn
            if kombinacje[i][0] in wybrane_kolumny:
                mozliwe_ruchy[liczba_opcji].append(kombinacje[i][0])
            #analogicznie z drugą wartością
            if kombinacje[i][1] in wybrane_kolumny:
                mozliwe_ruchy[liczba_opcji].append(kombinacje[i][1])
        #2 pionki postawione
        elif len(wybrane_kolumny) == 2:
            # Sprawdzenie czy pierwszy wynik jest już wybrany 
            if kombinacje[i][0] in wybrane_kolumny:
                mozliwe_ruchy[liczba_opcji].append(kombinacje[i][0])
                #Jeśli pierwsza opcja jest w liście wybranych to druga jeśli 
                # nie jest zablokowana to możemy się poruszyć również w tej kolumnie
                if not kombinacje[i][1] in zablokowane_kolumny:
                    mozliwe_ruchy[liczba_opcji].append(kombinacje[i][1])
            #analogiczne sprawdzenie drugiego wyniku
            elif kombinacje[i][1] in wybrane_kolumny:
                mozliwe_ruchy[liczba_opcji].append(kombinacje[i][1])
                if not kombinacje[i][0] in zablokowane_kolumny:
                    mozliwe_ruchy[liczba_opcji].append(kombinacje[i][0])
            #Jeśli obie wartości nie znajdują się w liście wybranych 
            #to sprawdzam czy pierwsza jest nie zablokowana
            elif not kombinacje[i][0] in zablokowane_kolumny:
                mozliwe_ruchy[liczba_opcji].append(kombinacje[i][1])
                #Jeśli obie nie są zablokowane to musze je dodać oddzielnie 
                # jest to przypadek gdy mamy dwa pionki na planszy 
                # A dodać możemy tylko jeden, więc musimy wybrać który
                #Dlatego zwiększamy liczbę opcji i dodajemy kolejną opcję jako nową listę 
                if not kombinacje[i][1] in zablokowane_kolumny:
                    liczba_opcji += 1
                    mozliwe_ruchy.append([kombinacje[i][1]])
            #Sprawdzenie czy choć druga opcja jest dostępna
            elif not kombinacje[i][1] in zablokowane_kolumny:
                mozliwe_ruchy[liczba_opcji].append(kombinacje[i][1])
        #jeden lub zero użytych pionków
        else:
            if not kombinacje[i][0] in zablokowane_kolumny:
                mozliwe_ruchy[liczba_opcji].append(kombinacje[i][0])
            if not kombinacje[i][1] in zablokowane_kolumny:
                mozliwe_ruchy[liczba_opcji].append(kombinacje[i][1])
        liczba_opcji += 1
    #Usunięcie pustych elementów
    while [] in mozliwe_ruchy:
        mozliwe_ruchy.remove([])
    #wyświetlenie tekstów
    teksty.clear()
    for i in range(len(mozliwe_ruchy)):
        teksty.append(f'{i+1}. Ruch w kolumnach {mozliwe_ruchy[i]}')
        




program_dziala = True
while program_dziala:
    for zdarzenie in pygame.event.get():
        if zdarzenie.type == pygame.KEYDOWN:
            if zdarzenie.key == pygame.K_ESCAPE:
                program_dziala = False
            if zdarzenie.key == pygame.K_SPACE:
                rzut_kosci()
                sprawdz_mozliwe_ruchy()
        elif zdarzenie.type == pygame.QUIT:
            program_dziala = False
    

    #wyświetl tło
    ekran.blit(obraz_tla, (0,0))
    #Kosci
    ekran.blit(obrazki_kosci[0], (16,16))
    ekran.blit(obrazki_kosci[1], (116,16))
    ekran.blit(obrazki_kosci[2], (16,116))
    ekran.blit(obrazki_kosci[3], (116,116))
    #Plansza
    budowa_planszy()
    #Teksty
    pokaz_teksty()
    #odświerz ekran
    pygame.display.flip()
    zegar.tick(60) #liczba klatek na sekunde

pygame.quit() "
6ZZ3mvtm,"Cambiar base a Binario, Octal y Hexadecimal. Simple. Python",JPablos,Python,Saturday 3rd of June 2023 02:50:36 PM CDT,"# -*- coding: utf-8 -*-
""""""
Created on Fri Jun  2 06:33:22 2023
Este código permite cambiar un número decimal ingresado por el usuario
a otras bases, como a Binario, Octal o Hexadecimal.

Utiliza tkinter para crear una interfaz gráfica.

@alpfa
""""""

import tkinter as tk
from tkinter import ttk


def convert():
    """"""
    Código que permite el cambio de base 10 a Binario, Octal y Hexadecimal.

    Returns
    -------
    La correspondencia en las bases citadas.

    """"""
    decimal = int(decimal_entry.get())
    binary = bin(decimal)[2:]
    hexadecimal = hex(decimal)[2:]
    octal = oct(decimal)[2:]

    result_text.delete(""1.0"", tk.END)
    result_text.insert(tk.END, f""Decimal ingresado: {decimal}\n\n"")
    result_text.insert(tk.END, ""Conversión a otras bases:\n\n"")
    result_text.insert(tk.END, f""Binario (0:b):     {binary}\n"")
    result_text.insert(tk.END, f""Octal (0:o):       {octal}\n"")
    result_text.insert(tk.END, f""Hexadecimal (0:x): {hexadecimal}"")


root = tk.Tk()
root.title(""Cambio de Base a Binario, Octal y Hexadecimal"")

mainframe = ttk.Frame(root, padding=""3 3 12 12"")
mainframe.grid(column=0, row=0, sticky=(tk.N, tk.W, tk.E, tk.S))
root.columnconfigure(0, weight=1)
root.rowconfigure(0, weight=1)

decimal_label = tk.Label(
    mainframe, text=""Cambiar base, ingrese un número Decimal y presione:   "")
decimal_label.grid(column=1, row=2, sticky=tk.W)

decimal_entry = tk.Entry(mainframe)
decimal_entry.grid(column=2, row=1, sticky=tk.W)

convert_button = tk.Button(mainframe, text=""Convertir"", command=convert)
convert_button.grid(column=2, row=2, sticky=tk.W)

result_text = tk.Text(mainframe, height=8, width=50)
result_text.grid(column=2, row=3, rowspan=4, sticky=(tk.W, tk.E))
result_text.tag_configure(""title"", font=(""Courier New"", 12, ""bold""))

result_text.insert(tk.END, ""Resultado:\n"", ""title"")

root.mainloop()
"
j8KBgett,Zadania - lekcja 14,drakon-firestone,Python,Saturday 3rd of June 2023 02:16:33 PM CDT,"################## ZADANIA #######################

'''
Zad 1. Utwórz symulator przeglądarki gdzie historia przeglądania będzie zapisywana w
formie stosu. Użytkownik może wchodzić na różne strony w programie i cofać się
w historii przeglądania. Upakuj całą funkcjonalność w klasie BrowserHistory 
natomiast do stworzenia samej historii wykorzystaj stos z zadań poprzednich.

Potrzebne zmienne w klasie BrowserHistory:
 - struktura do przechowywania historii przeglądania
 - zapamiętanie obecnej strony

Wymagane metody:
 - (oczywiście) konstuktor
 - przejście do strony o podanym adresie
 - cofnięcie się do poprzedniej strony
 

Zad. dod. 1.
Dodaj opcję przejścia do następnej strony w historii (jeśli cofnęliśmy się). HINT: Można zastosować 2 listy, jedną na strony przed aktualnie wyświetlaną i drugą na te po aktualnie wyświetlanej. Zmodyfikuj odpowiednio metodę cofnięcia aby współgrała z obecnym metodem przechodzenia po historii.
'''

'''
Zad 2. Utwórz symulator kolejki do kina gdzie elementami kolejki są klienci razem z ich
zamówieniem. Do utworzenia symulatora kolejki użyj naszej struktury Kolejki, którą
stworzyliśmy wcześniej.

Klienci są reprezentowani przez klasę Customer, która ma atrybuty name (imię
klienta) i order (zamówienie klienta). 
Kolejka do kina jest reprezentowana przez
klasę CinemaQueue, która używa implementacji kolejki (klasy Queue) do
przechowywania klientów.
	● Metoda is_empty sprawdza, czy kolejka jest pusta.
	● Metoda add_customer dodaje klienta do kolejki.
	● Metoda remove_customer usuwa klienta z kolejki.
	● Metoda next_customer_order zwraca zamówienie klienta, który jest
	  pierwszy w kolejce, ale go nie usuwa.

Przetestuj działanie klasy i ich metod (dodaj kilku klientów do listy i obsłuż wszystkich klientów czyli po prostu wyświetl ich zamówienia z informacją że zostali obsłużeniu aż kolejka będzie pusta)
'''

'''
Zad. dod. 2.
Napisz funkcję, która sprawdzi, czy dany ciąg znaków jest palindromem,
korzystając z naszej implementacji stosu.

https://sjp.pwn.pl/slowniki/palindrom.html
'''

"
XzzTWaA9,Untitled,A1fredPennyworth,C,Saturday 3rd of June 2023 02:09:30 PM CDT,"void summator(void *state, const void *element) {
    *(int *)state += *(const int *)element;
}

int main() {
    int result = 0;
    int init_val = 0;
    int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    std_accumulate((void *)(&result), a, sizeof(int), 10, &init_val, summator); 
    printf(""%d\n"", result);
}"
HqQSeEBc,Zadania - kolejka,drakon-firestone,Python,Saturday 3rd of June 2023 02:03:45 PM CDT,"# Stwórz klasę Queue (kolejka) która będzie zawierała implementację struktury danych kolejka.
# Niech posiada ona:
# - sprawdzenie czy kolejka jest pusta - metoda is_empty(),
# - dodanie elementu do końca kolejki - metoda enqueue(),
# - usuwanie elementu z początku kolejki - metoda dequeue():,
# - sprawdzenie jaki element znajduje się na początku kolejki bez usuwania go - metoda peek()
# zabezpiecz metody enqueue() oraz peek() przed sytuacją z pustą kolejką

# Wykorzystaj stworzoną klasę do stworzenia przykładowej kolejki, dodaj do niej min. 3 elementy i przetestuj działanie pozostałych metod."
RMSKsTkP,Zadanie - stos,drakon-firestone,Python,Saturday 3rd of June 2023 01:56:38 PM CDT,"# stwóz klasę Stack

    # utwórz jej konstruktor 
    # zawrzyj w nim stworzenie nowej tablicy wewnątrz obiektu
	
    	

    # stwórz metodę size() należącą do klasy
    # niech zwraca ona rozmiar stosu (ilosć elementów przechowywanych na stosie/liście)
    
        

    # stwórz is_empty() należącą do klasy
    # niech zwraca ona wartość True jeśli stos jest pusty
    # oraz wartość False jeśli stos zawiera jakieś elementy
    
        
    
    # stwórz metodę push(item) należącą do klasy 
    # i przyjmującą element item dodawany na koniec stosu
    
        

    # stwórz metodę pop() należącą do klasy 
    # niech zwraca ona ostatni element stosu i usuwa go z listy 
    # zabezpiecz metodę w sytuacji pustego stosu
    
        
            

    
    # stwórz metodę peek() należącą do klasy 
    # niech zwraca ona ostatni element stosu - BEZ usuwania go z listy 
    # zabezpiecz metodę w sytuacji pustego stosu
    
        
            
        
# ========= W GŁÓWNYM PROGRAMIE PRZETESTUJ ZASTOSOWANIE STWORZONEJ KLASY ORAZ JEJ METOD ===================== #
    "
CHG3Qd5A,Sample code for CameraX,thief_g,Kotlin,Saturday 3rd of June 2023 01:45:14 PM CDT,"package com.example.camerax

import android.Manifest
import android.app.ProgressDialog
import android.content.ContentValues
import android.content.pm.PackageManager
import android.os.Build
import android.os.Bundle
import android.os.Environment
import android.os.Handler
import android.os.HandlerThread
import android.os.SystemClock
import android.provider.MediaStore
import android.util.Log
import android.util.Size
import android.view.View
import android.widget.Chronometer
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.camera.core.Camera
import androidx.camera.core.CameraSelector
import androidx.camera.core.ImageCapture
import androidx.camera.core.ImageCaptureException
import androidx.camera.core.Preview
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.camera.video.MediaStoreOutputOptions
import androidx.camera.video.Quality
import androidx.camera.video.QualitySelector
import androidx.camera.video.Recorder
import androidx.camera.video.Recording
import androidx.camera.video.VideoCapture
import androidx.camera.video.VideoRecordEvent
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import androidx.core.content.PermissionChecker
import com.example.camerax.databinding.ActivityMainBinding
import com.otaliastudios.transcoder.Transcoder
import com.otaliastudios.transcoder.TranscoderListener
import com.otaliastudios.transcoder.TranscoderOptions
import com.otaliastudios.transcoder.common.TrackStatus
import com.otaliastudios.transcoder.strategy.DefaultAudioStrategy
import com.otaliastudios.transcoder.strategy.DefaultVideoStrategy
import com.otaliastudios.transcoder.strategy.TrackStrategy
import com.otaliastudios.transcoder.validator.DefaultValidator
import org.mp4parser.muxer.Movie
import org.mp4parser.muxer.Track
import org.mp4parser.muxer.builder.DefaultMp4Builder
import org.mp4parser.muxer.container.mp4.MovieCreator
import org.mp4parser.muxer.tracks.AppendTrack
import java.io.File
import java.io.FileOutputStream
import java.text.SimpleDateFormat
import java.util.Locale
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors
import java.util.concurrent.Future


class MainActivity : AppCompatActivity() {
    private lateinit var mainBinding: ActivityMainBinding
    private var mIsVideoRecording: Boolean = false
    private var mImageCapture: ImageCapture? = null
    private lateinit var mImageCaptureExecutor: ExecutorService
    private lateinit var mCameraSelector:CameraSelector

    private var mVideoCapture: VideoCapture<Recorder>? = null
    private var mRecording: Recording? = null
    private var quality = Quality.HD
    private val qualitySelector = QualitySelector.from(quality)
    private var recorderBuilder = Recorder.Builder()
    private var recorder = Recorder.Builder().build()
    private var mIsVideoPaused: Boolean = false
    private  lateinit var mChronometer: Chronometer
    private var isFlashOn: Boolean = false
    private lateinit var camera: Camera
    private var mIsCameraSwitched: Boolean = false
    private lateinit var mVideoFileList: MutableList<File>
    private lateinit var progressDialogue: ProgressDialog
    private var timeWhenPaused: Long  = 0
    private var cameraSwitchCount:Int = 0
    private var mBackgroundThreadHandler: HandlerThread? = null
    private var mBackgroundHandler: Handler? = null
    private var mTranscodeFuture: Future<Void>? = null
    private val mTranscodeVideoStrategy: TrackStrategy? = null
    private val mTranscodeAudioStrategy: TrackStrategy? = null
    private var outputFile = File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_MOVIES), ""merged_video.mp4"")
    private var rotatedFile = File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_MOVIES), ""Merged_VIDEO.mp4"")
    private lateinit var mScreenSize: Size

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        mainBinding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(mainBinding.root)

        mImageCaptureExecutor = Executors.newSingleThreadExecutor()

        progressDialogue = ProgressDialog(this)


        mVideoFileList = mutableListOf()
        mChronometer = mainBinding.chronometer
        mChronometer.visibility = View.GONE
        mainBinding.rlPauseResumeStop.visibility = View.GONE

        checkPermissions()

        mainBinding.ivStartStop.setOnClickListener {
            if (mIsVideoRecording) {
                mainBinding.ivTakePicture.visibility = View.VISIBLE
                mIsVideoRecording = false
                cameraSwitchCount = 0
                stopRecording()

            } else {
                mainBinding.ivTakePicture.visibility = View.GONE
                mIsVideoRecording = true
                startRecordingVideo()
            }
        }

        timeWhenPaused = 0
        mainBinding.ivPauseResume.setOnClickListener {
            if (mIsVideoPaused) {
                mIsVideoPaused = false
                mRecording!!.resume()

            } else {
                mIsVideoPaused = true
                mRecording!!.pause()
            }
        }

        mainBinding.ivSwitchCamera.setOnClickListener {
            mIsCameraSwitched = true
            cameraSwitchCount++
            if (mIsVideoRecording) {
                stopRecording()
                switchCamera()
                startRecordingVideo()

            } else {
                switchCamera()
            }
        }
        mainBinding.ivTakePicture.setOnClickListener {
            takePhoto() // it will also save the photo
        }

        mainBinding.ivFlash.setOnClickListener {
            onFlashButtonClicked()
        }

    }

    /**
     * this method is responsible for the switch of the camera
     */
    private fun switchCamera() {
        if ( mCameraSelector == CameraSelector.DEFAULT_BACK_CAMERA) {
            camera.cameraControl.enableTorch(false)
            mCameraSelector =  CameraSelector.DEFAULT_FRONT_CAMERA

            mainBinding.ivFlash.setBackgroundResource(R.drawable.ic_flash_off_icon)
        } else {
            mCameraSelector =  CameraSelector.DEFAULT_BACK_CAMERA
        }
        startCamera()
    }

    /**
     * this method will be invoked on click of flash button and turnOn/turnOff flash light accordingly
     */
    private fun onFlashButtonClicked() {
        if(camera.cameraInfo.hasFlashUnit()) {
            if (isFlashOn) {
                isFlashOn = false
                mainBinding.ivFlash.setBackgroundResource(R.drawable.ic_flash_off_icon)
                camera.cameraControl.enableTorch(isFlashOn)
            } else {
                isFlashOn = true
                mainBinding.ivFlash.setBackgroundResource(R.drawable.ic_flash_icon)
                camera.cameraControl.enableTorch(isFlashOn)
            }
        } else {
            isFlashOn = false
            mainBinding.ivFlash.setBackgroundResource(R.drawable.ic_flash_off_icon)
            Toast.makeText(this, ""Flash is not available"", Toast.LENGTH_SHORT).show()
        }
    }

    /**
     * this method will start the camera preview
     */
    private fun startCamera() {
        val preview = Preview.Builder()
            .build()
            .also {
                it.setSurfaceProvider(mainBinding.cameraPreview.surfaceProvider)
            }
        val cameraProviderFuture = ProcessCameraProvider.getInstance(this)
        if(mIsCameraSwitched) {
            recorder = Recorder.Builder().build()
        }
        if (ActivityCompat.checkSelfPermission(
                this,
                Manifest.permission.CAMERA
            ) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(
                this,
                Manifest.permission.WRITE_EXTERNAL_STORAGE
            ) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(
                this,
                Manifest.permission.READ_EXTERNAL_STORAGE
            ) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(
                this,
                Manifest.permission.RECORD_AUDIO
            ) != PackageManager.PERMISSION_GRANTED
        ) {
            ActivityCompat.requestPermissions(
                this,
                arrayOf(
                    Manifest.permission.CAMERA,
                    Manifest.permission.WRITE_EXTERNAL_STORAGE,
                    Manifest.permission.READ_EXTERNAL_STORAGE,
                    Manifest.permission.RECORD_AUDIO
                ),
                REQUEST_CAMERA_PERMISSION
            )
            return
        }

        mVideoCapture = VideoCapture.withOutput(recorder)
        cameraProviderFuture.addListener({
            val cameraProvider = cameraProviderFuture.get()
            mImageCapture = ImageCapture.Builder()
                .setCaptureMode(ImageCapture.CAPTURE_MODE_MINIMIZE_LATENCY)
                .build()

            try {

                cameraProvider.unbindAll()
                camera = cameraProvider.bindToLifecycle(this, mCameraSelector,mImageCapture,mVideoCapture,preview)
                mScreenSize = QualitySelector.getResolution(camera.cameraInfo, Quality.HIGHEST)!!

            } catch (e: Exception) {
                Log.d(""MainActivity"", ""Use case binding failed"")
            }

        }, ContextCompat.getMainExecutor(this))

    }

    /**
     * this method will take the photo and save it to Gallery
     */
    private fun takePhoto() {
        mImageCapture?.let{

            val imageFileName = SimpleDateFormat(FILENAME_FORMAT, Locale.US).format(System.currentTimeMillis())
            val contentValues = ContentValues().apply {
                put(MediaStore.MediaColumns.DISPLAY_NAME, imageFileName)
                put(MediaStore.MediaColumns.MIME_TYPE, ""image/jpeg"")
                if(Build.VERSION.SDK_INT > Build.VERSION_CODES.P) {
                    put(MediaStore.Images.Media.RELATIVE_PATH, ""Pictures/CameraX-Image"")
                }
            }
            val outputFileOptions = ImageCapture.OutputFileOptions
                .Builder(contentResolver, MediaStore.Images.Media.EXTERNAL_CONTENT_URI, contentValues
                ).build()
            it.takePicture(
                outputFileOptions,
                mImageCaptureExecutor,
                object : ImageCapture.OnImageSavedCallback {
                    override fun onImageSaved(outputFileResults: ImageCapture.OutputFileResults){
                        startCamera()
                    }

                    override fun onError(exception: ImageCaptureException) {
                        Toast.makeText(
                            mainBinding.root.context,
                            ""Error occurred in taking photo"",
                            Toast.LENGTH_LONG
                        ).show()
                        Log.d(""MainActivity"", ""Error taking photo:$exception"")
                    }

                })

            Toast.makeText( this@MainActivity , ""The image has been saved to Gallery"", Toast.LENGTH_SHORT).show()

        }
    }

    /**
     * this method will start the recording of video
     */
    private fun startRecordingVideo() {
        mainBinding.ivStartStop.setBackgroundResource(R.drawable.ic_stop_video_icon)
        mVideoCapture!!.let {
            try {
                if (ActivityCompat.checkSelfPermission(
                        this,
                        Manifest.permission.CAMERA
                    ) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(
                        this,
                        Manifest.permission.WRITE_EXTERNAL_STORAGE
                    ) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(
                        this,
                        Manifest.permission.READ_EXTERNAL_STORAGE
                    ) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(
                        this,
                        Manifest.permission.RECORD_AUDIO
                    ) != PackageManager.PERMISSION_GRANTED
                ) {
                    ActivityCompat.requestPermissions(
                        this,
                        arrayOf(
                            Manifest.permission.CAMERA,
                            Manifest.permission.WRITE_EXTERNAL_STORAGE,
                            Manifest.permission.READ_EXTERNAL_STORAGE,
                            Manifest.permission.RECORD_AUDIO
                        ),
                        REQUEST_CAMERA_PERMISSION
                    )
                    return
                }
                val contentValues = ContentValues().apply {
                    put(MediaStore.MediaColumns.DISPLAY_NAME, ""VID_${System.currentTimeMillis()}"")
                    put(MediaStore.MediaColumns.MIME_TYPE, ""video/mp4"")
                }
                val mediaStoreOutputOptions = MediaStoreOutputOptions
                    .Builder(contentResolver, MediaStore.Video.Media.EXTERNAL_CONTENT_URI)
                    .setContentValues(contentValues)
                    .build()
                mRecording = mVideoCapture!!.output
                    .prepareRecording(this, mediaStoreOutputOptions)
                    .apply {
                        // Enable Audio for recording
                        if (PermissionChecker.checkSelfPermission(this@MainActivity, Manifest.permission.RECORD_AUDIO) ==
                            PermissionChecker.PERMISSION_GRANTED ) {
                            withAudioEnabled()
                        }
                    }
                    .start(ContextCompat.getMainExecutor(this)) { recordEvent ->
                        when(recordEvent) {
                            is VideoRecordEvent.Start -> {
                                mainBinding.ivPauseResume.visibility = View.VISIBLE
                                mChronometer.visibility = View.VISIBLE
                                mChronometer.base = SystemClock.elapsedRealtime()
                                mChronometer.start()
                            }
                            is VideoRecordEvent.Pause -> {
                                mIsVideoPaused = true
                                mainBinding.ivPauseResume.setBackgroundResource(R.drawable.ic_resume_icon)
                                timeWhenPaused = mChronometer.base - SystemClock.elapsedRealtime()
                                mChronometer.stop()
                            }
                            is VideoRecordEvent.Finalize -> {
                                if (!recordEvent.hasError()) {

                                    val savedUri = recordEvent.outputResults.outputUri

                                    if (savedUri != null) {
                                        val projection = arrayOf(MediaStore.Video.Media.DATA)
                                        val cursor = contentResolver.query(savedUri, projection, null, null, null)
                                        cursor?.use {
                                            if (it.moveToFirst()) {
                                                val filePath = it.getString(it.getColumnIndexOrThrow(MediaStore.Video.Media.DATA))
                                                val videoFile = File(filePath)


                                                if(videoFile.exists()) {
                                                    mVideoFileList.add(videoFile)
                                                    Toast.makeText(this,  videoFile.absolutePath, Toast.LENGTH_SHORT).show()
                                                }
                                            }
                                        }
                                    }
                                    if(!mIsVideoRecording){
                                        mergeVideosUsingTranscoder(mVideoFileList)
                                    }
                                } else {
                                    mRecording?.close()
                                    mRecording = null
                                    Log.e(""MainActivity"", ""Video capture ends with error: ${recordEvent.error}"")
                                }

                            }
                            is VideoRecordEvent.Resume -> {
                                mIsVideoPaused = false
                                mainBinding.ivPauseResume.setBackgroundResource(R.drawable.ic_pause_icon)
                                mChronometer.base = SystemClock.elapsedRealtime() + timeWhenPaused
                                mChronometer.start()
                            }
                        }
                    }

            } catch (e: Exception) {
                e.printStackTrace()
            }
        }

    }

    private fun stopRecording() {
        mainBinding.ivStartStop.setBackgroundResource(R.drawable.ic_start_video_icon)
        mRecording!!.stop()
        mChronometer.stop()
        mChronometer.visibility = View.GONE
        if(!mIsVideoRecording) {
            mainBinding.ivPauseResume.visibility = View.GONE
            startCamera()
        }
    }

    private fun mergeVideos(videoFiles: List<File>) {
        try {
            progressDialogue.setMessage(""Merging Videos.."")
            progressDialogue.show()
            val movieList = mutableListOf<Movie>()
            for (videoFile  in videoFiles) {


                val movie = MovieCreator.build(videoFile.absolutePath)
                movieList.add(movie)
            }
            val videoTracks = mutableListOf<Track>()
            val audioTracks = mutableListOf<Track>()

            for (movie in movieList) {
                for (track in movie.tracks) {
                    if (track.handler == ""vide"") {
                        videoTracks.add(track)
                    }
                    if (track.handler == ""soun"") {
                        audioTracks.add(track)
                    }
                }
            }

            val mergedMovie = Movie()
            if (videoTracks.size > 0) {
                mergedMovie.addTrack(AppendTrack(*videoTracks.toTypedArray()))
            }

            if (audioTracks.size > 0) {
                mergedMovie.addTrack(AppendTrack(*audioTracks.toTypedArray()))
            }

            val container = DefaultMp4Builder().build(mergedMovie)
            val fileChannel = FileOutputStream(outputFile).channel
            container.writeContainer(fileChannel)
            fileChannel.close()
            progressDialogue.cancel()

            Toast.makeText(this, ""Videos merged successfully"", Toast.LENGTH_SHORT).show()

        } catch (e : Exception) {
            Log.e(TAG, e.message.toString())
        }

    }

    /**
     * this method used for merging multiple videos using Transcoder library
     * @param videoFilesList
     */
    private fun mergeVideosUsingTranscoder(videoFiles: List<File>) {
        progressDialogue.setMessage(""Merging Videos.."")
        progressDialogue.show()
        val builder: TranscoderOptions.Builder =
            Transcoder.into(rotatedFile.absolutePath)
        for(videoFile in videoFiles) {
            builder.addDataSource(videoFile.absolutePath)
        }

        // use DefaultVideoStrategy.exact(2560, 1440).build()  to restore 75% size of the video
        //  use DefaultVideoStrategy.exact(mScreenSize.height, mScreenSize.width).build()  to restore 50% size of the video

        val strategy: DefaultVideoStrategy = DefaultVideoStrategy.exact(2560, 1440).build()

        mTranscodeFuture = builder
            .setAudioTrackStrategy(DefaultAudioStrategy.builder().build())
            .setVideoTrackStrategy(strategy)
            .setVideoRotation(0)
            .setListener(object : TranscoderListener{

                override fun onTranscodeProgress(progress: Double) {}

                override fun onTranscodeCompleted(successCode: Int) {
                    Toast.makeText(this@MainActivity, ""Video Merged Successfully"", Toast.LENGTH_SHORT).show()
                }

                override fun onTranscodeCanceled() {
                    Toast.makeText(this@MainActivity, ""Video rotation cancelled"", Toast.LENGTH_SHORT).show()
                }

                override fun onTranscodeFailed(exception: Throwable) {
                    Toast.makeText(this@MainActivity, exception.message, Toast.LENGTH_SHORT).show()
                }

            })
            .setValidator(object : DefaultValidator() {
                override fun validate(videoStatus: TrackStatus, audioStatus: TrackStatus): Boolean {
                    //  mIsAudioOnly = !videoStatus.isTranscoding
                    return super.validate(videoStatus, audioStatus)
                }

            }).transcode()
        progressDialogue.cancel()
    }

    /**
     * this method will check camera and other required permission to run the app
     */
    private  fun checkPermissions() {
        if (ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED
            && ContextCompat.checkSelfPermission(this,Manifest.permission.WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED
            && ContextCompat.checkSelfPermission(this, Manifest.permission.RECORD_AUDIO) == PackageManager.PERMISSION_GRANTED
            && ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED
        ) {
            mCameraSelector = CameraSelector.DEFAULT_BACK_CAMERA
            startCamera()

        } else {
            if (shouldShowRequestPermissionRationale(Manifest.permission.WRITE_EXTERNAL_STORAGE )) {
                Toast.makeText(this, ""app needs permission to be able to save videos"", Toast.LENGTH_SHORT)
                    .show()
            }
            requestPermissions(
                arrayOf(Manifest.permission.CAMERA,Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.RECORD_AUDIO,Manifest.permission.READ_EXTERNAL_STORAGE),
                REQUEST_CAMERA_PERMISSION
            )
        }

    }

    /**
     * this method receives the status of the permissions granted
     * @param1 requestCode
     * @param2: permissions
     * @param3: grantResults
     */
    override fun onRequestPermissionsResult(
        requestCode: Int,
        permissions: Array<String?>,
        grantResults: IntArray,
    ) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
        if (requestCode == REQUEST_CAMERA_PERMISSION) {
            for(results in grantResults) {
                if (results == PackageManager.PERMISSION_DENIED) {
                    // close the app
                    Toast.makeText(
                        this@MainActivity,
                        ""Sorry!!!, you can't use this app without granting permission"",
                        Toast.LENGTH_LONG
                    ).show()
                    finish()
                }
            }
        }

    }

    override fun onPause() {
        super.onPause()
        Log.e(TAG, ""onPause()"")
        stopBackgroundThread()

    }

    /**
     * this will start the background thread to run the processes
     */
    private fun startBackgroundThread() {
        mBackgroundThreadHandler = HandlerThread(""Camera Background"")
        mBackgroundThreadHandler!!.start()
        mBackgroundHandler = Handler(mBackgroundThreadHandler!!.looper)
    }

    /**
     * this will stop the background thread if all the background processes are executed
     */
    private fun stopBackgroundThread() {
        mBackgroundThreadHandler!!.quitSafely()
        try {
            mBackgroundThreadHandler!!.join()
            mBackgroundThreadHandler = null
            mBackgroundHandler = null
        } catch (e: InterruptedException) {
            e.printStackTrace()
        }
    }

    override fun onStop() {
        super.onStop()
        Log.e(TAG, ""onStop()"")

    }

    override fun onRestart() {
        super.onRestart()
        Log.e(TAG, ""onRestart()"")

    }

    override fun onResume() {
        super.onResume()
        Log.e(TAG, ""onResume()"")
        startBackgroundThread()

        if(mIsVideoRecording) {
            mRecording!!.resume()
            mChronometer.start()
        }
    }
    override fun onDestroy() {
        super.onDestroy()
        if(mIsVideoRecording) {
            mRecording!!.stop()
            mChronometer.stop()
        }
    }
    companion object {
        const val TAG = ""MainActivity""
        const val REQUEST_CAMERA_PERMISSION: Int = 0
        const val STORAGE_PERMISSION_CODE: Int = 1
        const val FILENAME_FORMAT = ""yyyy-MM-dd-HH-mm-ss-SSS""
    }
}"
nP1H5VP1,List + Set (broken),AmirVagapov,C#,Saturday 3rd of June 2023 01:40:50 PM CDT,"using System;
using System.Collections;

class HelloWorld {
    static void Main() {
        Console.WriteLine(""test list"");
        test_list();
        Console.WriteLine(""test set"");
        test_set();
    }
    static void test_list() { /********** TEST LIST **********/ 
        //1
        Console.WriteLine(""1 test"");
        Console.WriteLine(""Создайте пустой список S1. Добавьте элемент 1 в голову, добавьте элемент 10 в хвост. Выведите S1 на экран (используя функцию Print)"");
        List<int> s1 = new List<int>();
        s1.push_front(1);
        s1.push(10);
        Console.Write(""s1 = "");
        s1.Print();
        //2
        Console.WriteLine(""2 test"");
        Console.WriteLine(""Создайте список S2 из 6 случайных чисел. Выведите список S2 на экран, используя потоковый вывод. Найдите в S2 max и min элемент. Отсортируйте S2."");
        List<int> s2 = new List<int>();
        Random rnd = new Random();
        for(int i = 0; i < 6; i++) {
            s2.push(rnd.Next() % 15);
        }
        Console.Write(""s2 = "");
        s2.Print();
        // a[1] = 3;
        Console.WriteLine(""min: ""+ s2.min().getData()+ "" max: ""+ s2.max().getData());
        s2 = s2.mergesort();
        Console.Write(""s2 = "");
        s2.Print();
        //3
        Console.WriteLine(""3 test"");
        Console.WriteLine(""Найдите в S2 2-й элемент и выведите его на экран. Удалите 2-й элемент списка S2."");
        Console.WriteLine(s2[1].getData());
        s2.delete(1);
        Console.Write(""s2 = "");
        s2.Print();
        //4
        Console.WriteLine(""4 test"");
        Console.WriteLine(""Найдите в S2 6-й элемент (т.е. убедитесь, что в списке осталось меньше 6 элементов). Удалите элемент из хвоста S2."");
        Console.Write(""s2[5] = "");
        Console.WriteLine(s2[5]);
        s2.pop();
        Console.Write(""s2 = "");
        s2.Print();
        //5
        Console.WriteLine(""5 test"");
        Console.WriteLine(""Создайте пустой список S3. Инициализируйте его значением S1. Проверьте равенство списков S1 и S3. Проверьте, есть ли в S3 элемент 15."");
        List<int> s3 = s1.clone();
        Console.Write(""s3 = "");
        s3.Print();
        Console.Write(""s3 == s1 "");
        Console.WriteLine(s3 == s1);
        Console.WriteLine(""s3.find(15) == null "");
        Console.WriteLine(s3.find(15) == null);
        //6
        Console.WriteLine(""6 test"");
        Console.WriteLine(""Удалите элемент из головы списка S3. Удалите из списка S3 элемент 10. Выведите S3 на экран. Проверьте S3 на пустоту."");
        s3.pop_front();
        s3.delete_value(10);
        Console.Write(""s3 = "");
        s3.Print();
        Console.Write(""s3.IsNull() "");
        Console.WriteLine(s3.IsNull());
        // 7
        Console.WriteLine(""7 test"");
        Console.WriteLine(""Создайте последовательность из 6 случайных чисел, меньших 20. Превратите ее в список S4 и выведите его на экран. Проверьте, есть ли в S4 элемент 25. Добавьте элемент 25 четвертым в список."");
        List<int> s4 = new List<int>();
        for(int i = 0; i < 6; i++) {
            s4.push(rnd.Next() % 20);
        }
        Console.Write(""s4 = "");
        s4.Print();
        Console.Write(""s4.find(25) == null "");
        Console.WriteLine(s4.find(25) == null);
        s4.insert(25, 3);
        Console.Write(""s4 = "");
        s4.Print();
        //8
        Console.WriteLine(""8 test"");
        Console.WriteLine(""Создайте список S5, проинициализировав его при создании списком S2. Выведите S5 на экран. Проверьте, есть ли в S5 элемент 4 и если есть – удалите его, если нет – добавьте элемент 4 в хвост."");
        List<int> s5 = s2.clone();
        Console.Write(""s5 = "");
        s5.Print();
        Console.Write(""s5.find(4) == null "");
        Console.WriteLine(s5.find(4) == null);
        if (s5.find(4) != null) {
            s5.delete_value(4);
        }
        else {
            s5.push(4);
        }
        Console.Write(""s5 = "");
        s5.Print();
        //9
        Console.WriteLine(""9 test"");
        Console.WriteLine(""Измените S5, записав в него 4 числа: 11, 12, 13, 14 (числа вводятся с клавиатуры). Сравните S5 и S4."");
        s5.read_input();
        Console.Write(""s5 = "");
        s5.Print();
        Console.Write(""s5 == s4 "");
        Console.WriteLine(s5 == s4);
        //10
        Console.WriteLine(""10 test"");
        Console.WriteLine(""Добавьте в хвост S5 список S4. Добавьте в голову S5 список S1."");
        Console.Write(""s5 = "");
        s5.Print();
        s5 = s5 + s4;
        Console.Write(""(s5 + s4) s5 = "");
        s5.Print();
        s5 = s1 + s5;
        Console.Write(""(s1 + s5) s5 = "");
        s5.Print();
    }
    static void test_set() { /********** TEST SET **********/
        //1
        Console.WriteLine(""1 test"");
        Console.WriteLine(""Создайте множество S1, из 10 случайных чисел. Выведите S1 на экран"");
        Set<int> s1 = new Set<int>();
        Random rnd = new Random();
        int j = 0;
        while(j < 10) {
            int val = rnd.Next(20);
            if (s1.find(val) == null) {
                s1.push(val);
                j += 1;
            }
        }
        Console.Write(""s1 = "");
        s1.Print();
        //2
        Console.WriteLine(""2 test"");
        Console.WriteLine(""Создайте множество S2 и инициализируйте его (при создании) значением S1.  Выведите S2 на экран (используйте потоковый вывод). Проверьте равенство множеств S1  и  S2."");
        Set<int> s2 = new Set<int>(s1.clone());
        Console.Write(""s2 = "");
        s2.Print();
        Console.Write(""s1 == s2 "");
        Console.WriteLine(s1 == s2);
        //3
        Console.WriteLine(""3 test"");
        Console.WriteLine(""Проверьте, есть ли в S1 элемент 5. Создайте множество S3, которое получается  удалением/добавлением из S1 элемента 5. Проверьте, что S1 и S3 – не равны."");
        Console.Write(""s1.find(5) != null "");
        Console.WriteLine(s1.find(5) != null);
        Set<int> s3 = new Set<int>(s1.clone());
        if (s3.find(5) != null) {
            s3.delete_value(5);
        }
        else {
            s3.push(5);
        }
        Console.Write(""s3 = "");
        s3.Print();
        Console.Write(""s1 == s3 "");
        Console.WriteLine(s1 == s3);
        //4
        Console.WriteLine(""4 test"");
        Console.WriteLine(""Создайте пустое множество S4. Проверьте его на пустоту.  Добавьте в S4 последовательно числа 5, 10, 15, 5.  Выведите S4 на экран."");
        Set<int> s4 = new Set<int>();
        Console.Write(""s4.IsNull() "");
        Console.WriteLine(s4.IsNull());
        s4.push(5);
        s4.push(10);
        s4.push(15);
        s4.push(5);
        Console.Write(""s4 = "");
        s4.Print();
        //5
        Console.WriteLine(""5 test"");
        Console.WriteLine(""Создайте пустое множество S5.  Инициализируйте его множеством S4.  Проверьте, что во множестве S5 есть элемент 15 и удалите его. Выведите получившееся множество на экран."");
        Set<int> s5 = new Set<int>(s4);
        Console.Write(""s5 = "");
        s4.Print();
        Console.Write(""s5.find(15) != null "");
        Console.WriteLine(s5.find(15) != null);
        s5.delete_value(15);
        Console.WriteLine(""15 deleted"");
        Console.Write(""s5 = "");
        s5.Print();
        //6
        Console.WriteLine(""6 test"");
        Console.WriteLine(""Создайте список T, из 20 случайных чисел. Выведите T на экран. Создайте из T множество S6.  Выведите S6 на экран. Определите количество элементов в S6."");
        List<int> t = new List<int>();
        for(int i = 0; i < 20; i++) {
            t.push(rnd.Next() % 30);
        }
        Console.Write(""t = "");
        t.Print();
        Set<int> s6 = new Set<int>(t);
        Console.Write(""s6 = "");
        s6.Print();
        Console.Write(""s6.len() = "");
        Console.WriteLine(s6.len());
        //7
        Console.WriteLine(""7 test"");
        Console.WriteLine(""Найдите S7 – дополнение S6 до универсального. Найдите множество S8=S7∩S6."");
        Console.WriteLine(""Будем считать, что множество состоит из 30 эелементов"");
        Set<int> s7 = new Set<int>();
        for(int i = 0; i < 30; i++) {
            if (s6.find(i) == null) s7.push(i);
        }
        Console.Write(""s7 = "");
        s7.Print();
        Set<int> s8 = Set<int>.intersection(s7, s6);
        Console.Write(""s8 = "");
        s8.Print();
        //8
        Console.WriteLine(""8 test"");
        Console.WriteLine(""Создайте множество \nS9={1,3,5,7,9,11,13,15,17,19,21,23,25,27,29}\n(используйте потоковый ввод).  Найдите V1 =S7 ∩ S9,  V2 = S7 ∪ S9,  V3 = S7 \\ S9."");
        Set<int> s9 = new Set<int>();
        s9.read_input();
        Console.Write(""s9 = "");
        s9.Print();
        Set<int> v1 = Set<int>.intersection(s7, s9);
        Console.Write(""v1 = "");
        v1.Print();
        Set<int> v2 = Set<int>.union(s7, s9);
        Console.Write(""v2 = "");
        v2.Print();
        Set<int> v3 = Set<int>.difference(s7, s9);
        Console.Write(""v3 = "");
        v3.Print();
        //9
        Console.WriteLine(""9 test"");
        Console.WriteLine(""Измените V1, объединив его с V3. Сравните V1  с S7."");
        v1 = Set<int>.union(v1, v3);
        Console.Write(""v1 = "");
        v1.Print();
        Console.Write(""v1 == v7 "");
        Console.WriteLine(v1 == s7);
        //10
        Console.WriteLine(""10 test"");
        Console.WriteLine(""Измените множество V2, заменив его разностью V2 и V3. Сравните V2  с  S9"");
        v2 = Set<int>.difference(v2, v3);
        Console.Write(""v2 = "");
        v2.Print();
        Console.Write(""v2 == s9 "");
        Console.WriteLine(v2 == s9);
    }
}
class Node {
    protected int data;
    private Node next;
    public void nextSet(Node a) {
        next = a;
    }
    public Node nextGet() {
        return next;
    }
    public Node(int d) {
        data = d;
        nextSet(null);
    }
    public Node clone()
    {
        return new Node(data);
    }
    public Node setData(int newdata) {
        data = newdata;
    }
    public Node getData() {
        return data;
    }
   
}

class List {
    protected Node head;

    // Конструкторы
    public List(int d) {
        head = new Node(d);
    }
    public List(Node d) {
        head = d;
    }
    public List() {
        head = null;
    }

    public List clone() {
        if (head == null) return new List();
        List cl = new List(new Node(head.getData()));
        Node curr = head;
        Node curr2 = cl.head;
        while(curr.nextGet() != null) {
            curr = curr.nextGet();
            curr2.nextSet(new Node(curr.getData()));
            curr2 = curr2.nextGet();
        }
        return cl;
    }
    public void push(int d) {
        Node temp = new Node(d);
        if (IsNull()) {
            head = temp;
            return;
        }
        Node tail = head;
        while(tail.nextGet()!= null) {
            tail = tail.nextGet();
        }
        tail.nextSet(temp);
    }
    public void push_front(int d) {
        Node temp = new Node(d);
        if (IsNull()) {
            head = temp;
            return;
        }
        temp.nextSet(head);
        head = temp;
    }
    public Node pop() {
        if (head == null) {return null;}
        Node tail = head.nextGet();
        if (head.nextGet()== null) {
            head = null;
            return tail;
        }
        Node prev = head;
        while(tail.nextGet()!= null) {
            tail = tail.nextGet();
            prev = prev.nextGet();
        }
        Node res = tail;
        tail = prev;
        tail.nextSet(null);
        return res;
    }
    public Node pop_front() {
        if (IsNull()) {return null;}
        Node res = head;
        if (head.nextGet()== null) {
            Node temp = new Node(head.getData());
            head = null;
            return temp;
        }
        else {
            head = head.nextGet();
        }
        return res;
    }
    public Node insert(int a, int n) {
        Node ins = new Node(a);
        Node cur = head;
        if (cur == null) {
            if (n == 0) {
                head = ins;
                return ins;
            }
            else return null;
        }
        for(int i = 1; i < n; i++) {
            if (cur.nextGet()== null) return null;
            cur = cur.nextGet();
        }
        ins.nextSet(cur.nextGet());
        cur.nextSet(ins);
        return ins;
    }
    public Node insert_after_key(int a, int key) {
        Node ins = new Node(a);
        Node cur = find(key);
        if (cur == null) return null;
        ins.nextSet(cur.nextGet());
        cur.nextSet(ins);
        return ins;
    }
    public Node this[int n] {
        get {
            Node temp = head;
            for(int i = 0; i < n; i++) {
                if(temp == null) {return null;}
                temp = temp.nextGet();
            }
            return temp;
        }
        set {
            if (head == null && n == 0) {head = value; return;}
            Node temp = head;
            for(int i = 0; i < n; i++) {
                if(temp == null) {throw new NullReferenceException(""List size is smaller than n"");}
                temp = temp.nextGet();
            }
            temp.getData() = value.getData();
        }
    }
    public Node delete(int n) {
        if (head == null) return null;
        Node temp = head;
        Node prev = head;
        for(int i = 0; i < n; i++) {
            if (temp.nextGet() == null) return null;
            prev = temp;
            temp = temp.nextGet();
        }
        prev.nextSet(temp.nextGet());
        return temp;
    }
    public Node delete_value(int value) {
        if (head == null) return null;
        Node temp = head;
        Node prev = null;
        do {
            if (temp.getData().CompareTo(value) == 0) {
                if (prev == null) head = temp.nextGet();
                else prev.nextSet(temp.nextGet());
                return temp;
            }
            prev = temp;
            temp = temp.nextGet();
        } while(temp != null);
        return null;
    }
    public void delete_values(int value) {
        if (head == null) return;
        Node temp = head;
        Node prev = null;
        while (temp != null && temp.getData().CompareTo(value) == 0) {
            head = temp.nextGet();
            temp = head;
        }
        while (temp != null) {
            while (temp != null && temp.getData().CompareTo(value) != 0) {
                prev = temp;
                temp = temp.nextGet();
            }
            if (temp == null)
                return;
            prev.nextSet(temp.nextGet());
            temp = prev.nextGet();
        }
    }

    public Node find(int value) {
        if (IsNull()) {return null;}
        Node temp = head;
        while (temp != null) {
            if (temp.getData().CompareTo(value) == 0) {return temp;} //temp.data == value
            temp = temp.nextGet();
        }
        return temp;
    }
    public Node min() {
        if (IsNull()) {return null;}
        Node temp = head;
        Node min = head;
        while(temp != null) {
            if (min.detData().CompareTo(temp.getData()) > 0) {min = temp;}
            temp = temp.nextGet();
        }
        return min;
    }
    public Node max() {
        if (IsNull()) {return null;}
        Node temp = head;
        Node max = head;
        while(temp != null) {
            if (max.getData().CompareTo(temp.getData()) < 0) {max = temp;}
            temp = temp.nextGet();
        }
        return max;
    }
    public bool IsNull() {
        return head == null;
    }
    public void clear() {
        head = null;
    }
    public void read_input() {
        head = null;
        Console.Write(""Enter number of nodes : "");
        int n = (int)Convert.ChangeType(Console.ReadLine(), typeof(int));
        Console.WriteLine(n);
        for (int i = 0; i < n; i++) {
            Node temp = (int)Convert.ChangeType(Console.ReadLine(), typeof(int));
            push(temp);
            Console.WriteLine(""pushed "" + temp);
        }
    }
    Node getmiddle() {
        if (head == null) return head;
        Node slow = head, fast = head;
        while(fast.nextGet()!= null && fast.nextGet().nextGet()!= null) {
            slow = slow.nextGet();
            fast = fast.nextGet().nextGet();
        }
        return slow;
    }
    static List merge(List left, List right) {
        if (left.IsNull()) return right;
        if (right.IsNull()) return left;
        List result = new List();
        if (left.head.getData().CompareTo(right.head.getData()) <= 0) {
            result = left;
            result.head.nextSet(merge(new List(left.head.nextGet()), right).head);
        }
        else {
            result = right;
            result.head.nextSet(merge(left, new List(right.head.nextGet())).head);
        }
        return result;
    }
    public List mergesort() {
        if (head == null || head.nextGet()== null) return (new List(head));
        Node middle = getmiddle();
        List middle_next = new List(middle.nextGet());
        middle.nextSet(null);
        List left = mergesort();
        List right = middle_next.mergesort();
        // Console.WriteLine(""debug"");
        // left.Print();
        // right.Print();
        List result = merge(left, right);
        // result.Print();
        head = result.head;
        return result;
    }
    public void Print() {
        if (IsNull()) {
            Console.Write(""null\n"");
            return;
        }
        Node temp = head;
        Console.Write(""["" + temp.getData());
        temp = temp.nextGet();
        while(temp != null) {
            Console.Write("", "" + temp.getData());
            temp = temp.nextGet();
        }
        Console.Write(""]\n"");
    }

    public static List operator + (List a, List b) {
        if (a.head == null) return b;
        if (b.head == null) return a;
        List result = a;
        Node temp = result.head;
        while(temp.nextGet()!= null) {
            temp = temp.nextGet();
        }
        temp.nextSet(b.head);
        return result;
    }
    public static bool operator == (List a, List b) {
        Node f = a.head;
        Node s = b.head;
        if (f == null ^ s == null) return false;
        if (f == null && s == null) return true;
        while(f.nextGet() != null && s.nextGet() != null) {
            if (f.getData().CompareTo(s.getData()) != 0) return false;
            f = f.nextGet();
            s = s.nextGet();
        }
        if (f.nextGet() == null ^ s.nextGet() == null) return false;
        return true;
    }

    public static bool operator != (List a, List b) {
        return !(a==b);
    }
}

class Set : List {
    public Set() {
    }
    public Set(Node a) {
        head = a.clone();
    }
    public Set(int a) {
        head = new Node(a);
    }
    public Set(List a) {
        head = a.clone()[0];
        delete_repetitions();
    }
    
    void delete_repetitions() {
        Node ptr1 = head;
        Node ptr2 = null;
        while (ptr1 != null && ptr1.nextGet() != null) {
            ptr2 = ptr1;
            while (ptr2.nextGet() != null) {
                if (ptr1.getData().CompareTo(ptr2.nextGet().getData()) == 0) ptr2.nextSet(ptr2.nextGet().nextGet());
                else ptr2 = ptr2.nextGet();
            }
            ptr1 = ptr1.nextGet();
        }
    }
    public new void push(int d) {
        if (base.find(d) == null)
            base.push(d);
    }
    public new void push_front(int d) {
        if (base.find(d) == null)
            base.push_front(d);
    }
    public new Node insert(int a, int n) {
        if (base.find(a) == null)
            return base.insert(a, n);
        return null;
    }
    public new Node insert_after_key(int a, int key) {
        if (base.find(a) == null)
            return base.insert_after_key(a, key);
        return null;
    }
    public new void read_input() {
        base.clear();
        Console.Write(""Enter number of nodes : "");
        int n = (int)Convert.ChangeType(Console.ReadLine(), typeof(int));
        Console.WriteLine(n);
        for (int i = 0; i < n; i++) {
            Node temp = (int)Convert.ChangeType(Console.ReadLine(), typeof(int));
            push(temp);
            Console.WriteLine(""pushed "" + temp);
        }
    }
    public static Set union(Set a, Set b) {
        if (a.IsNull()) return (Set)b.clone();
        if (b.IsNull()) return (Set)a.clone();
        Set res = new Set(a.clone());
        foreach(Node item in b) {
            res.push(item.clone().getData());
        }
        return res;
    }
    public static Set intersection(Set a, Set b) {
        if (a.IsNull() && b.IsNull()) return null;
        Set res = new Set();
        foreach(Node item in b) {
            if (a.find(item.getData()) != null) res.push(item.getData()); 
        }
        foreach(Node item in a) {
            if (b.find(item.getData()) != null) res.push(item.getData()); 
        }
        return res;
    }
    public static Set difference(Set a, Set b) {
        if (a.IsNull()) return null;
        if (b.IsNull()) return new Set(a.clone());
        Set res = new Set(a.clone());
        foreach(Node item in b) {
            res.delete_value(item.getData());
        }
        return res;
    }
    public new Node this[int n] {
        get {return base[n];}
        set {
            if (find(value.getData()) != null)
                base[n] = value;
        }
    }
    public int len() {
        int i = 0;
        foreach(Node item in this) i++;
        return i;
    }
    // public static bool operator == (Set<T> a, Set<T> b) {
    //     if (a.head == null ^ b.head == null) return false;
    //     if (a.head == null && b.head == null) return true;
    //     Set<T> temp = new Set<T>(b);
    //     foreach(Node<T> item in a) {
    //         if (temp.delete_value(item.data) == null) return false;
    //     }
    //     return temp.IsNull();
    // }
    public new void Print() {
        this.mergesort();
        base.Print();
    }
    public static bool operator == (Set a, Set b) {
        a.mergesort();
        b.mergesort();
        return ((List)a == (List)b);
    }
    public static bool operator != (Set a, Set b) {
        return !(a == b);
    }
}
"
Fegr7nW3,4 gpio time machine,Robert_l,C++,Saturday 3rd of June 2023 01:21:31 PM CDT,"/******************************************************************************

                            Online C Compiler.
                Code, Compile, Run and Debug C program online.
Write your code in this editor and press ""Run"" button to compile and execute it.

*******************************************************************************/

#include <stdio.h>
#include <sys/time.h>
#include <inttypes.h>

uint32_t millis(void) {
    struct timeval tv;
    gettimeofday(&tv,NULL);
    return (((uint32_t)tv.tv_sec)*1000)+(tv.tv_usec/1000);
}

enum states {idle, start, t1_expired,t2_expired,t3_expired,t4_expired};

enum states timer_state = idle;
uint32_t delay = 0;
uint32_t last_time = 0;

void timer_start(void){
    timer_state = start;
}

void timer_run(void){
    if (millis() - last_time < delay){
        return;
    }
    switch(timer_state){
        case idle:
            delay = 0;
            last_time = 0;
            break;
        case start:
            delay = 10; //t1
            last_time = millis();
            printf(""start at      %u \n"", millis());
            timer_state = t1_expired;
            break;
        case t1_expired:
            last_time += delay; // not use millis() to not accumulate time error
            delay = 20;//t2
            printf(""t1 expired at %u \n"", millis());
            timer_state = t2_expired;
            break;
        case t2_expired:
            last_time += delay;
            delay = 30;//t3
            printf(""t2 expired at %u \n"", millis());
            timer_state = t3_expired;
            break;
        case t3_expired:
            last_time += delay;
            delay = 40;//t4
            printf(""t3 expired at %u \n"", millis());
            timer_state = t4_expired;
            break;
        case t4_expired:
            printf(""t4 expired at %u \n"", millis());
            timer_state = idle;
            break;
        default:
             printf(""warning: default state %u \n"", millis());
            timer_state = idle;
            break;
    }
}

int main()
{
    timer_run();
    timer_start();
    
    while(timer_state != idle){
        timer_run();
    }
    printf(""end"");

    return 0;
}
"
M9MZY2Mt,Convertir pies a metros. Simple. Python,JPablos,Python,Saturday 3rd of June 2023 01:09:37 PM CDT,"# -*- coding: utf-8 -*-
""""""
Created on Fri Jun  2 06:33:22 2023
Este código permite hacer la converión de pies a metros.
Utiliza tkinter para crear una interfaz gráfica.

@alpfa
""""""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox


def calculate():
    """"""
    Éste código permite el uso de una Interfaz gráfica basada en tkinter
    para hacer la converión de pies a metros

    Returns
    -------
    El cálculo en metros como 'float'.

    """"""
    try:
        value = float(feet.get())
        meters.set(int(0.3048 * value * 10000.0 + 0.5) / 10000.0)
    except ValueError:
        messagebox.showerror(""Error"", ""Por favor, ingrese un valor numérico."")


root = tk.Tk()
root.title(""Pies a Metros"")

mainframe = ttk.Frame(root, padding=""3 3 12 12"")
mainframe.grid(column=0, row=0, sticky=(tk.N, tk.W, tk.E, tk.S))
root.columnconfigure(0, weight=1)
root.rowconfigure(0, weight=1)

feet = tk.StringVar()
feet_entry = ttk.Entry(mainframe, width=7, textvariable=feet)
feet_entry.grid(column=2, row=1, sticky=(tk.W, tk.E))

meters = tk.StringVar()
ttk.Label(mainframe, textvariable=meters).grid(column=2, row=2, sticky=(tk.W, tk.E))

ttk.Button(mainframe, text=""Calcular"", command=calculate).grid(column=3, row=3, sticky=tk.W)

ttk.Label(mainframe, text=""pies"").grid(column=3, row=1, sticky=tk.W)
ttk.Label(mainframe, text=""son equivalentes a"").grid(column=1, row=2, sticky=tk.E)
ttk.Label(mainframe, text=""metros"").grid(column=3, row=2, sticky=tk.W)

for child in mainframe.winfo_children():
    child.grid_configure(padx=5, pady=5)

feet_entry.focus()
root.bind(""<Return>"", calculate)

root.mainloop()
"
wmvKAcQ8,GenCode,KitChaos,C#,Saturday 3rd of June 2023 01:00:43 PM CDT,"using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.Linq;
    
public class Level1Gen : Generation
{
    float elap;
    bool StartCheck;
    float elap2;
    public void Start()
    {
        LastChunk = ChunkForLevel[Random.Range(0, ChunkForLevel.Count)];
        Center = new Coords(0, 0, 0);
        for (int x = -2; x < 3; x++)
        {
            for (int z = -2; z < 3; z++)
            {

                GenerateChunk(new Coords(x, 0, z), true);


            }
        }
        Playerstats = GameObject.Find(""Player"").GetComponent<PlayerStats>();
        Playerstats.LevelStats = this;


        InvokeRepeating(""CheckDespawn"", 1, 1);
     InvokeRepeating(nameof(GenerateFromCenter), 1.2f, 1.2f);
    }
    public override void GenerateChunk(Coords c, bool IsCore = false)
    {
        var ToSpawn = ChunkForLevel[Random.Range(0, ChunkForLevel.Count)];

        var Rand = Mathf.RoundToInt(Random.Range(0, maxInclusive: 35));
        // Debug.Log(Rand);
        if (Rand == 0)
        {
            var C = Instantiate(ToSpawn, new Vector3(c.X * 80, c.Y, c.Z * 80), Quaternion.identity);
            var ChunkData = C.GetComponent<Chunk>();
            ChunkData.Parent = this;
            if (IsCore)
            {
                PlayerIn = ChunkData;
            }
            Chunks.Add(ChunkData);
            //Debug.Log(""Spawnednew"");

            // Debug.Log(ChunkData.Structs.Count);
            try
            {
                ChunkData.coords = c;
                if (DifferenceInCoords(PlayerIn.coords, ChunkData.coords) > 3)
                {
                    Destroy(ChunkData.gameObject);
                }
                else
                {
                    ChunkData.SpawnStuff(ChunkData.Structs[Random.Range(0, ChunkData.Structs.Count)]);
                }


            }
            catch (System.Exception)
            {

                //Debug.Log(ChunkData.Structs.Count);
            }
            LastChunk = ToSpawn;
        }
        else
        {
            //  Debug.Log(""SpawnedSame"");
            var C = Instantiate(LastChunk.gameObject, new Vector3(c.X * 80, c.Y, c.Z * 80), Quaternion.identity);
            var ChunkData = C.GetComponent<Chunk>();
            ChunkData.Parent = this;
            if (IsCore)
            {
                PlayerIn = ChunkData;
            }
            Chunks.Add(ChunkData);
            // Debug.Log(ChunkData.Structs.Count);
            try
            {
                ChunkData.coords = c;
                if (DifferenceInCoords(PlayerIn.coords, ChunkData.coords) > 3)
                {
                    Destroy(ChunkData.gameObject);
                }
                else
                {
                    ChunkData.SpawnStuff(ChunkData.Structs[Random.Range(0, ChunkData.Structs.Count)]);
                }
            }
            catch (System.Exception)
            {

                //Debug.Log(ChunkData.Structs.Count);
            }
        }

        //Debug.Log(C.transform.position);




    }
    void GenerateFromCenter()
    {
        for (int x = -2; x < 3; x++)
        {
            for (int z = -2; z < 3; z++)
            {
                bool Occupied = false;
                foreach (Chunk c in Chunks)
                {
                    if (c.coords.X == x + Center.X && c.coords.Z == z + Center.Z)
                    {
                        Occupied = true;
                    }
                }
                if (!Occupied)
                {
                    GenerateChunk(new Coords(x + Center.X, 0, z + Center.Z));
                }



            }
        }

    }
    //Check if the player is far enough away to spawn new chunks
    void CheckDespawn()
    {
        foreach (Chunk c in Chunks)
        {
            if (DifferenceInCoords(PlayerIn.coords, c.coords) > 3)
            {
                if (c.gameObject != null)
                {
                    Destroy(c.gameObject);
                }

            }
        }
    }

    public void Update()
    {
        elap += Time.deltaTime;
     
        if (elap > 2)
        {
            StartCheck = true;
        }
        if (StartCheck)
        {
            Chunks = Chunks.Where(item => item != null).ToList();
            Center = PlayerIn.coords;
            Playerstats.SanityDrain = SanityDrain;
        }
        
       
    }

    float DifferenceInCoords(Coords a, Coords b)
    {
        var xDist = Mathf.Abs(a.X - b.X);
        var zDist = Mathf.Abs(a.Z - b.Z);
        return (xDist + zDist);
    }
    
}
"
dPsXKsM7,enum con  nombres,Alexiss16,C++,Saturday 3rd of June 2023 12:06:43 PM CDT,"#include <iostream>
#include <stdlib.h>
using namespace std;

enum MesesAnio {
    Enero, Febrero, Marzo, Abril, Mayo, Junio, Julio, Agosto, Septiembre, Octubre, Noviembre, Diciembre
};

string nombres_meses[12] = {""Enero"", ""Febrero"", ""Marzo"", ""Abril"", ""Mayo"", ""Junio"", ""Julio"", ""Agosto"", ""Septiembre"", ""Octubre"", ""Noviembre"", ""Diciembre""};

enum DiasSemana {
    Lunes, Martes, Miercoles, Jueves, Viernes, Sabado, Domingo
};
 string nombre_dias[7] ={""Lunes"", ""Martes"", ""Miercoles"", ""Jueves"", ""Viernes"", ""Sabado"", ""Domingo""}; 
 
 
enum EstacionesAnio {
    Primavera, Verano, Otono, Invierno
};
string estaciones[4] = {""Primavera"", ""Verano"", ""Otono"", ""Invierno""};

int main() {
    int opcion;
    cout << ""Seleccione el modo de ordenamiento:"" << endl;
    cout << ""1. Orden ascendente"" << endl;
    cout << ""2. Orden descendente"" << endl;
    cin >> opcion;

    switch (opcion) {
        case 1:
            cout << ""Meses del anio en orden ascendente:"" << endl;
            for (int i = Enero; i <= Diciembre; i++) {
                cout << nombres_meses[i] << endl;
            }
            cout << endl;

            cout << ""Dias de la semana en orden ascendente:"" << endl;
            for (int i = Lunes; i <= Domingo; i++) {
                cout << nombre_dias[i]<< endl;
            }
            cout << endl;

            cout << ""Estaciones del anio en orden ascendente:"" << endl;
            for (int i = Primavera; i <= Invierno; i++) {
                cout << estaciones[i] << endl;
            }
            cout << endl;
            break;

        case 2:
            cout << ""Meses del anio en orden descendente:"" << endl;
            for (int i = Diciembre; i >= Enero; i--) {
                cout << nombres_meses[i] << endl;
            }
            cout << endl;

            cout << ""Dias de la semana en orden descendente:"" << endl;
            for (int i = Domingo; i >= Lunes; i--) {
                cout << nombre_dias[i]<< endl;
            }
            cout << endl;

            cout << ""Estaciones del anio en orden descendente:"" << endl;
            for (int i = Invierno; i >= Primavera; i--) {
                cout << estaciones[i] << endl;
            }
            cout << endl;
            break;

        default:
            cout << ""Opcion no valida"" << endl;
            break;
    }
    system(""pause"");
    return 0;
}"
Hm91ckjj,jenya vdolbenko klassi,lump3n,Python,Saturday 3rd of June 2023 12:01:09 PM CDT,"class apple_counter:
    def __init__(self):
        self.apple_num = 10

    def sub(self):
        self.apple_num -= 1

    def add(self):
        self.apple_num += 1


eugen_aples = apple_counter()
vanini_aples = apple_counter()
print('Тваи = ', eugen_aples.apple_num, '\n',
      'Маи = ', vanini_aples.apple_num)

eugen_aples.sub()
vanini_aples.add()

eugen_aples.sub()
vanini_aples.add()

eugen_aples.sub()
vanini_aples.add()

print('Я спиздил у тебя 3 яблока, селф же обозначает, что это яблоки определенного объекта класса')
print('Тваи = ', eugen_aples.apple_num, '\n',
      'Маи = ', vanini_aples.apple_num)"
ctJwHHHs,Is Balanced Binary Tree,MuzammiL5,Java,Saturday 3rd of June 2023 11:38:18 AM CDT,"public boolean isBalanced(TreeNode root) {
    return height(root) >= 0;
}

int height(TreeNode root) {
    if (root == null)
        return 0;
    int l, r;

    l = height(root.left);
    if (l == -1)
        return -1;
    r = height(root.right);
    if (r == -1)
        return -1;
    if (Math.abs(l-r) > 1) {
        return -1;
    } else {
        return Math.max(l, r) + 1;
    }
}"
WU4rECkH,Socket API,micuks,C++,Saturday 3rd of June 2023 11:26:38 AM CDT,"void WorkWindow::on_submitRequest_clicked() // 提交充电请求
{
    // 获取用户输入
    usr_mode = ui->modeBox->currentText() == ""slow"" ? ""0"" : ""1"";
    usr_capacity = ui->capacityEdit->text();
    usr_battery = ui->batteryEdit->text();

    // 判断输入是否合法
//    if (usr_capacity.isEmpty() || IsNumber(usr_capacity) == false) { // 判断充电量输入是否合法
//        MessageWindow(this, ""充电量必须是整数！"");
//        return;
//    }
    if (usr_battery.isEmpty() || IsNumber(usr_battery) == false) { // 判断电池容量输入是否合法
        MessageWindow(this, ""电池容量必须是整数！"");
        return;
    }
    if (usr_capacity.toInt() > usr_battery.toInt()) { // 判断充电量是否大于电池容量
        MessageWindow(this, ""充电量不能大于电池容量"");
        return;
    }

    QString request = QString(""startRequest/%1/%2/%3/%4"").arg(carNum, usr_mode, usr_capacity, usr_battery);
    Socket::Instance().SendRequest(request); // 发送充电请求
    SetStateWaiting(); // 转入等待状态
}

void WorkWindow::on_changeMode_clicked()
{
    ui->modeBox->setEnabled(true); // 开启充电模式选择框
    ui->changeMode->setEnabled(false); // 关闭修改充电模式按钮
    ui->changeCapacity->setEnabled(false); // 关闭修改充电量按钮
    ui->submitChange->setEnabled(true); // 开启提交修改按钮
}

void WorkWindow::on_changeCapacity_clicked()
{
    ui->capacityEdit->setEnabled(true); // 开启充电量输入框
    ui->changeMode->setEnabled(false); // 关闭修改充电模式按钮
    ui->changeCapacity->setEnabled(false); // 关闭修改充电量按钮
    ui->submitChange->setEnabled(true); // 开启提交修改按钮
}

void WorkWindow::on_submitChange_clicked()                                // 提交修改申请
{
    QString temp_capacity = ui->capacityEdit->text();
    QString temp_mode = ui->modeBox->currentText() == ""slow"" ? ""0"" : ""1"";

    // 判断输入是否合法
//    if (temp_capacity.isEmpty() || IsNumber(temp_capacity) == false) {    // 判断充电量输入是否合法
//        MessageWindow(this, ""充电量必须是整数！"");
//        Socket::Instance().SendRequest(""state/"" + carNum);
//        return;
//    }
    if (temp_capacity.toInt() > usr_battery.toInt()) {                   // 判断充电量是否大于电池容量
        MessageWindow(this, ""充电量不能大于电池容量"");
        Socket::Instance().SendRequest(""state/"" + carNum);
        return;
    }

    // 提交修改申请
    if (usr_capacity == temp_capacity && usr_mode == temp_mode) {       // 充电量和充电模式没有变化
        MessageWindow(this, ""充电请求没有变化，该请求不会被提交"");
    } else if (usr_mode != temp_mode) {                                 // 充电模式改变，提交修改申请
        Socket::Instance().SendRequest(QString(""changeRequest/%1/mode/%2"").arg(carNum, temp_mode));
    } else if (usr_capacity != temp_capacity) {                         // 充电量改变，提交申请
        Socket::Instance().SendRequest(QString(""changeRequest/%1/capacity/%2"").arg(carNum, temp_capacity));
    }

    // 更新目前状态
    Socket::Instance().SendRequest(""state/"" + carNum);
}

void WorkWindow::on_viewWaitNum_clicked()                               // 查看前车等待数量
{
    Socket::Instance().SendRequest(""getAheadNum/"" + carNum);
}

void WorkWindow::get_ahead_recv(QString responce)
{
    ui->infoBrowser->append(QString(""您前面还有%1辆车正在排队，请您耐心等待。"").arg(responce));
}

void WorkWindow::on_viewQueueNum_clicked()                              // 查看排队号
{
    Socket::Instance().SendRequest(""getQueueNum/"" + carNum);
}

void WorkWindow::get_queue_recv(QString responce)
{
    ui->infoBrowser->append(QString(""您的排队号为：%1"").arg(responce));
}

void WorkWindow::on_viewDetail_clicked()                                //  查看详单
{
    Socket::Instance().SendRequest(""getDetail/"" + carNum);
}

void WorkWindow::get_detail_recv(QString responce)
{
    ui->infoBrowser->append(QString(""本次充电的详细账单如下：""));
    ui->infoBrowser->append(responce);
}

void WorkWindow::on_endORpay_clicked()
{
    if (ui->endORpay->text() == ""结束充电"")
        EndCharging();
    else if (ui->endORpay->text() == ""支付账单"")
        PayBills();
}

void WorkWindow::EndCharging()                                          // 结束充电
{
    Socket::Instance().SendRequest(""endRequest/"" + carNum);
    SetStateFinished();
}

void WorkWindow::PayBills()                                             // 支付账单
{
    Socket::Instance().SendRequest(""bill/"" + carNum);
}

void WorkWindow::get_bill_recv(QString responce)
{
    QString info = QString(""您的账单金额为：%1元\n是否确认支付？"").arg(responce);
    QMessageBox box(QMessageBox::Question, ""支付确认"", info);
    box.setStandardButtons(QMessageBox::Ok | QMessageBox::Cancel);
    box.setButtonText(QMessageBox::Ok, ""支付"");
    box.setButtonText(QMessageBox::Cancel, ""取消"");
    box.setDefaultButton(QMessageBox::Cancel);
    int ret = box.exec();
    switch(ret) {
    case QMessageBox::Ok:
        Socket::Instance().SendRequest(""pay/"" + carNum);
        MessageWindow(this, ""支付成功"");
        SetStateFree();
        ui->infoBrowser->append(""支付成功，感谢您的使用！"");
        break;
    case QMessageBox::Cancel:
        break;
    }
}

// Admin-related
void MainWindow::on_GetReport_clicked()
{
    ui->Report->clear();
    QString text = """";
    for (int i = 1; i <= FastCharingPileNum; i++) {
        QString message = ""getReport/"";
        QString pileNo = QString::number(i);
        QString mode;
        mode = ""F"";
        message = message + mode + pileNo + ""\t"";
        text += ""充电桩："" + mode + pileNo + ""\n"";
        socket->write(message.toLatin1());
        socket->flush();
        allButtonOff();
        loop.exec();
        QByteArray msg = socket->readAll();
        qDebug() << msg;
        ReportInfo* report = reinterpret_cast<ReportInfo*>(msg.data());
        char pileno[8];
        strcpy(pileno, report->pileNo);
        text += ""    充电桩编号："" + QString::fromStdString(pileno) + ""\n"";
        int chargingnumber = report->totalChargingNumber;
        text += ""    累计充电次数："" + QString::number(chargingnumber) + ""\n"";
        time_t chargingtime = report->totalChargingTime;
        // text+=""    累计充电时长：""+timetran(chargingtime)+""\n"";
        double chargingcapacity = report->totalChargingCapacity;
        text += ""    累计充电量："" + QString::number(chargingcapacity) + ""\n"";
        double chargingfee = report->totalChargingFee;
        text += ""    累计充电费用："" + QString::number(chargingfee) + ""\n"";
        double servicefee = report->totalServiceFee;
        text += ""    累计服务费用："" + QString::number(servicefee) + ""\n"";
        double allfee = report->totalAllFee;
        text += ""    累计总费用："" + QString::number(allfee) + ""\n"";
    }
    for (int i = 1; i <= TrickleChargingPileNum; i++) {
        QString message = ""getReport/"";
        QString pileNo = QString::number(i);
        QString mode;
        mode = ""T"";
        message = message + mode + pileNo + ""\t"";
        text += ""充电桩："" + mode + pileNo + ""\n"";
        socket->write(message.toLatin1());
        socket->flush();
        allButtonOff();
        loop.exec();
        QByteArray msg = socket->readAll();
        qDebug() << msg;
        ReportInfo* report = reinterpret_cast<ReportInfo*>(msg.data());
        char pileno[8];
        strcpy(pileno, report->pileNo);
        text += ""    充电桩编号："" + QString::fromStdString(pileno) + ""\n"";
        int chargingnumber = report->totalChargingNumber;
        text += ""    累计充电次数："" + QString::number(chargingnumber) + ""\n"";
        time_t chargingtime = report->totalChargingTime;
        // text+=""    累计充电时长：""+timetran(chargingtime)+""\n"";
        double chargingcapacity = report->totalChargingCapacity;
        text += ""    累计充电量："" + QString::number(chargingcapacity) + ""\n"";
        double chargingfee = report->totalChargingFee;
        text += ""    累计充电费用："" + QString::number(chargingfee) + ""\n"";
        double servicefee = report->totalServiceFee;
        text += ""    累计服务费用："" + QString::number(servicefee) + ""\n"";
        double allfee = report->totalAllFee;
        text += ""    累计总费用："" + QString::number(allfee) + ""\n"";
    }
    ui->Report->setText(text);
}
void MainWindow::on_GetWaiting_clicked()
{
    ui->waiting->clear();
    QString message = ""getWaiting\t"";
    QString text = """";
    socket->write(message.toLatin1());
    socket->flush();
    allButtonOff();
    loop.exec();
    QByteArray msg = socket->readAll();
    qDebug() << msg;
    msg = msg.remove(0, 4);
    qDebug() << msg;
    int usernum = msg.size() / sizeof(CarInfo);
    QByteArray carinfo;
    for (int i = 0; i < usernum; i++) {
        carinfo = msg.left(sizeof(CarInfo));
        msg.remove(0, sizeof(CarInfo));
        CarInfo* c = reinterpret_cast<CarInfo*>(carinfo.data());
        int vnum = c->Vnum;
        text += ""    *车号："" + QString::number(vnum) + ""\n"";
        char ownID[8];
        strcpy(ownID, c->ownerID);
        std::string ownid = ownID;
        text += ""    用户ID："" + QString::fromStdString(ownID) + ""\n"";
        double batterycapacity = c->batteryCapacity;
        text += ""    电池容量："" + QString::number(batterycapacity) + ""\n"";
        double request = c->requestChargingCapacity;
        text += ""    *请求充电量："" + QString::number(request) + ""\n"";
        time_t time = c->queueTime;
        // text+=""    排队时长：""+timetran(time)+""\n"";
        int queuenum = c->queueNum;
        text += ""    排队号："" + QString::number(queuenum) + ""\n"";
        int mode = c->chargingMode;
        if (mode == 0)
            text += ""    *充电模式：T\n"";
        else
            text += ""    *充电模式：F\n"";
        double alreadycapacity = c->alreadyChargingCapacity;
        text += ""    已冲电量："" + QString::number(alreadycapacity, 'g', 5)
            + ""\n"";
        double nowfee = c->nowFee;
        text += ""    当前费用："" + QString::number(nowfee, 'g', 5) + ""\n"";
        text += ""\n"";
    }
    ui->waiting->setText(text);
    static int times = 0;
    QString filepath = QString::number(++times) + ""_waitingcarinfo.txt"";
    QFile data(filepath);
    data.open(QIODevice::WriteOnly);
    QString str = ui->waiting->toPlainText();
    QByteArray context = str.toUtf8();
    data.write(context);
    data.close();
}"
dYGpqVRx,Buy Sell Stocks,MuzammiL5,Java,Saturday 3rd of June 2023 11:14:13 AM CDT,"// Greedy Approach: Iterate through the prices and maintain buy price and maxprofit gained up until that point. -> O(N), O(1)
int maxProfit(int[] prices, int n) {
    int buy = prices[0], max_profit = 0;
    for (int i=1; i<n; i++) {
        if (buy > prices[i]) {
            buy = prices[i];
        } else if (prices[i] - buy > max_profit) {
            max_profit = prices[i] - buy;
        }
    }
    return max_profit;
}"
SgutaVTt,Lowest Common Ancestor,MuzammiL5,Java,Saturday 3rd of June 2023 11:09:49 AM CDT,"Node LCA(Node root, int n1, int n2) {
    if (root == null)
        return null;

    if (root.data == n1 || root.data == n2)
        return root;

    Node left_LCA = LCA(root.left, n1, n2);
    Node right_LCA = LCA(root.right, n1, n2);

    if (left_LCA != null && right_LCA != null) {
        return root;  // Possible LCA
    }

    return (left_LCA != null) ? left_LCA : right_LCA;
}"
L4iQEEbu,primer script,teslariu,Python,Saturday 3rd of June 2023 11:01:21 AM CDT,"#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''
Script que imprime la suma de 3 nros
'''
a = 25
b = 14 -25.3 + 5
c = 14
d = a + b + c
print(d)

# lo mismo
print(a+b+c)

# otra forma de impresión
print(""La suma es"",d)
print(""Suma ="", d)

# otra forma de impresión
print(""25 + 11 ="", 25 + 11,"", 25 ** 2 ="", 25**2)"
p5aX73RP,KlasaStudent,cuniszkiewicz,C#,Saturday 3rd of June 2023 11:00:13 AM CDT,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace PierwszaKlasa {
    internal class Student {
        //pola klasy (zmienne w klasie)
        //modyfikatorami dostępu: public, private
        public string imie;
        public string nazwisko;
        private int numerIndeksu;
        public double sredniaOcen;

        private double temperatura;

        public double TemperaturaC {
            get { return temperatura; }
            set {
                if (value < 34 || value > 42)
                    temperatura = 36.6;
                else
                    temperatura = value; 
                }
        }
        public double TemperaturaK {
            get { return temperatura + 273; }
            set {
                if (value < 307 || value > 315)
                    temperatura = 36.6;
                else
                    temperatura = value - 273;
            }
        }

        //właściwości
        public string Imie { get { return imie; } set { imie = value; } }
        public int NumerIndeksu {
            get {
                return numerIndeksu;
            }
            set {
                if (value <= 0)
                    numerIndeksu = 1000;
                else
                    numerIndeksu = value;
            } }
        public void SetNumerIndeksu(int indeks) {
            if (indeks <= 0)
                numerIndeksu = 1000;
            else
                numerIndeksu = indeks;
        }
        public int GetNumerIndeksu() {  return numerIndeksu; }


        //metody (funkcje w klasie)

        public void PrzedstawSie() {
            //Console.WriteLine(""Nazywam się "" + imie + "" "" + nazwisko + ""."");
            //Console.WriteLine(""Nazywam się {0} {1}."", imie, nazwisko);
            Console.WriteLine($""Nazywam się {imie} {nazwisko}, mój numer indeku: {numerIndeksu}."");
        }
        public void ZdajEgzamin(string przedmiot, double ocena = 3) {
            Console.WriteLine($""Student {imie} {nazwisko} zdał egzamin z "" +
                $""{przedmiot} na ocenę: {ocena}"");
        }
        //https://pastebin.com/H9ZmDKSg
    }
}
"
MQh2tYjB,crash report 06/3/23,XxLen_KagaminexX,Java,Saturday 3rd of June 2023 10:58:07 AM CDT,"---- Minecraft Crash Report ----
// You should try our sister game, Minceraft!

Time: 2023-06-03 11:21:27
Description: Exception in server tick loop

java.util.NoSuchElementException: null
	at java.util.LinkedList$ListItr.next(LinkedList.java:894) ~[?:?] {}
	at it.zerono.mods.zerocore.lib.data.UnmodifiableChildrenIterator.computeNext(UnmodifiableChildrenIterator.java:53) ~[ZeroCore2-1.19.2-2.1.34.jar%23250!/:1.19.2-2.1.34] {re:classloading}
	at com.google.common.collect.AbstractIterator.tryToComputeNext(AbstractIterator.java:146) ~[guava-31.0.1-jre.jar%23121!/:?] {}
	at com.google.common.collect.AbstractIterator.hasNext(AbstractIterator.java:141) ~[guava-31.0.1-jre.jar%23121!/:?] {}
	at it.zerono.mods.extremereactors.gamecontent.multiblock.reactor.client.ClientFuelRodsLayout.updateFuelRodsOcclusion(ClientFuelRodsLayout.java:133) ~[ExtremeReactors2-1.19.2-2.0.63.jar%23223!/:1.19.2-2.0.63] {re:classloading}
	at it.zerono.mods.extremereactors.gamecontent.multiblock.reactor.MultiblockReactor.onMachineAssembled(MultiblockReactor.java:824) ~[ExtremeReactors2-1.19.2-2.0.63.jar%23223!/:1.19.2-2.0.63] {re:classloading}
	at it.zerono.mods.zerocore.lib.multiblock.AbstractMultiblockController.assembleMachine(AbstractMultiblockController.java:1333) ~[ZeroCore2-1.19.2-2.1.34.jar%23250!/:1.19.2-2.1.34] {re:classloading}
	at it.zerono.mods.zerocore.lib.multiblock.AbstractMultiblockController.checkIfMachineIsWhole(AbstractMultiblockController.java:472) ~[ZeroCore2-1.19.2-2.1.34.jar%23250!/:1.19.2-2.1.34] {re:classloading}
	at it.zerono.mods.zerocore.lib.multiblock.registry.MultiblockWorldRegistry.processMultiblockChanges(MultiblockWorldRegistry.java:337) ~[ZeroCore2-1.19.2-2.1.34.jar%23250!/:1.19.2-2.1.34] {re:classloading}
	at it.zerono.mods.zerocore.lib.multiblock.registry.MultiblockRegistry.tickStart(MultiblockRegistry.java:161) ~[ZeroCore2-1.19.2-2.1.34.jar%23250!/:1.19.2-2.1.34] {re:classloading}
	at it.zerono.mods.zerocore.lib.multiblock.registry.MultiblockRegistry.onWorldTick(MultiblockRegistry.java:197) ~[ZeroCore2-1.19.2-2.1.34.jar%23250!/:1.19.2-2.1.34] {re:classloading}
	at net.minecraftforge.eventbus.EventBus.doCastFilter(EventBus.java:260) ~[eventbus-6.0.3.jar%2385!/:?] {}
	at net.minecraftforge.eventbus.EventBus.lambda$addListener$11(EventBus.java:252) ~[eventbus-6.0.3.jar%2385!/:?] {}
	at net.minecraftforge.eventbus.EventBus.post(EventBus.java:315) ~[eventbus-6.0.3.jar%2385!/:?] {}
	at net.minecraftforge.eventbus.EventBus.post(EventBus.java:296) ~[eventbus-6.0.3.jar%2385!/:?] {}
	at net.minecraftforge.event.ForgeEventFactory.onPreLevelTick(ForgeEventFactory.java:815) ~[forge-1.19.2-43.2.9-universal.jar%23256!/:?] {re:classloading}
	at net.minecraft.server.MinecraftServer.m_5703_(MinecraftServer.java:863) ~[client-1.19.2-20220805.130853-srg.jar%23251!/:?] {re:mixin,pl:accesstransformer:B,re:classloading,pl:accesstransformer:B,pl:mixin:APP:ae2.mixins.json:spatial.MinecraftServerMixin,pl:mixin:APP:balm.mixins.json:MinecraftServerMixin,pl:mixin:A}
	at net.minecraft.server.MinecraftServer.m_5705_(MinecraftServer.java:806) ~[client-1.19.2-20220805.130853-srg.jar%23251!/:?] {re:mixin,pl:accesstransformer:B,re:classloading,pl:accesstransformer:B,pl:mixin:APP:ae2.mixins.json:spatial.MinecraftServerMixin,pl:mixin:APP:balm.mixins.json:MinecraftServerMixin,pl:mixin:A}
	at net.minecraft.client.server.IntegratedServer.m_5705_(IntegratedServer.java:84) ~[client-1.19.2-20220805.130853-srg.jar%23251!/:?] {re:classloading,pl:runtimedistcleaner:A}
	at net.minecraft.server.MinecraftServer.m_130011_(MinecraftServer.java:654) ~[client-1.19.2-20220805.130853-srg.jar%23251!/:?] {re:mixin,pl:accesstransformer:B,re:classloading,pl:accesstransformer:B,pl:mixin:APP:ae2.mixins.json:spatial.MinecraftServerMixin,pl:mixin:APP:balm.mixins.json:MinecraftServerMixin,pl:mixin:A}
	at net.minecraft.server.MinecraftServer.m_206580_(MinecraftServer.java:244) ~[client-1.19.2-20220805.130853-srg.jar%23251!/:?] {re:mixin,pl:accesstransformer:B,re:classloading,pl:accesstransformer:B,pl:mixin:APP:ae2.mixins.json:spatial.MinecraftServerMixin,pl:mixin:APP:balm.mixins.json:MinecraftServerMixin,pl:mixin:A}
	at java.lang.Thread.run(Thread.java:833) [?:?] {}


A detailed walkthrough of the error, its code path and all known details is as follows:
---------------------------------------------------------------------------------------

-- System Details --
Details:
	Minecraft Version: 1.19.2
	Minecraft Version ID: 1.19.2
	Operating System: Windows 10 (amd64) version 10.0
	Java Version: 17.0.3, Microsoft
	Java VM Version: OpenJDK 64-Bit Server VM (mixed mode), Microsoft
	Memory: 4359920264 bytes (4157 MiB) / 10242490368 bytes (9768 MiB) up to 12884901888 bytes (12288 MiB)
	CPUs: 32
	Processor Vendor: AuthenticAMD
	Processor Name: AMD Ryzen 9 5950X 16-Core Processor            
	Identifier: AuthenticAMD Family 25 Model 33 Stepping 2
	Microarchitecture: Zen 3
	Frequency (GHz): 3.39
	Number of physical packages: 1
	Number of physical CPUs: 16
	Number of logical CPUs: 32
	Graphics card #0 name: NVIDIA GeForce RTX 3060
	Graphics card #0 vendor: NVIDIA (0x10de)
	Graphics card #0 VRAM (MB): 4095.00
	Graphics card #0 deviceId: 0x2504
	Graphics card #0 versionInfo: DriverVersion=31.0.15.3161
	Memory slot #0 capacity (MB): 8192.00
	Memory slot #0 clockSpeed (GHz): 2.13
	Memory slot #0 type: DDR4
	Memory slot #1 capacity (MB): 8192.00
	Memory slot #1 clockSpeed (GHz): 2.13
	Memory slot #1 type: DDR4
	Memory slot #2 capacity (MB): 16384.00
	Memory slot #2 clockSpeed (GHz): 2.13
	Memory slot #2 type: DDR4
	Memory slot #3 capacity (MB): 16384.00
	Memory slot #3 clockSpeed (GHz): 2.13
	Memory slot #3 type: DDR4
	Virtual memory max (MB): 56247.32
	Virtual memory used (MB): 46415.07
	Swap memory total (MB): 7168.00
	Swap memory used (MB): 58.97
	JVM Flags: 4 total; -XX:HeapDumpPath=MojangTricksIntelDriversForPerformance_javaw.exe_minecraft.exe.heapdump -Xss1M -Xmx12288m -Xms256m
	Server Running: true
	Player Count: 1 / 8; [ServerPlayer['Discord_chan'/135, l='ServerLevel[Survival World II]', x=263.91, y=-11.00, z=-74.06]]
	Data Packs: vanilla, mod:mcwbridges, mod:terrablender, mod:create_things_and_misc, mod:botanytrees (incompatible), mod:biomesoplenty, mod:botarium, mod:jei (incompatible), mod:ae2 (incompatible), mod:prefab, mod:resourcefulconfig, mod:flywheel (incompatible), mod:curios, mod:mekanism, mod:patchouli (incompatible), mod:create, mod:waystones (incompatible), mod:glassential (incompatible), mod:create_sa, mod:journeymap (incompatible), mod:cookingforblockheads (incompatible), mod:controlling (incompatible), mod:tiab (incompatible), mod:configured (incompatible), mod:useitemonblockevent (incompatible), mod:botanypots (incompatible), mod:macawsbridgesbop, mod:bookshelf (incompatible), mod:resourcefullib (incompatible), mod:worldedit (incompatible), mod:mekanismtools, mod:limitmobspawn, mod:betterfurnacesreforged (incompatible), mod:architectury (incompatible), mod:ftblibrary (incompatible), mod:mekanismgenerators, mod:balm (incompatible), mod:ftbteams (incompatible), mod:ftbchunks (incompatible), mod:forge, mod:mctb (incompatible), mod:codechickenlib (incompatible), mod:enderstorage (incompatible), mod:morered (incompatible), mod:createaddition (incompatible), mod:zerocore, mod:bigreactors, mod:mcwfurnituresbop, mod:mcwroofs, mod:macawsroofsbop, mod:mcwfurnitures, mod:ctm (incompatible), mod:chipped (incompatible)
	World Generation: Stable
	Type: Integrated Server (map_client.txt)
	Is Modded: Definitely; Client brand changed to 'forge'; Server brand changed to 'forge'
	Launched Version: forge-43.2.9
	ModLauncher: 10.0.8+10.0.8+main.0ef7e830
	ModLauncher launch target: forgeclient
	ModLauncher naming: srg
	ModLauncher services: 
		mixin-0.8.5.jar mixin PLUGINSERVICE 
		eventbus-6.0.3.jar eventbus PLUGINSERVICE 
		fmlloader-1.19.2-43.2.9.jar slf4jfixer PLUGINSERVICE 
		fmlloader-1.19.2-43.2.9.jar object_holder_definalize PLUGINSERVICE 
		fmlloader-1.19.2-43.2.9.jar runtime_enum_extender PLUGINSERVICE 
		fmlloader-1.19.2-43.2.9.jar capability_token_subclass PLUGINSERVICE 
		accesstransformers-8.0.4.jar accesstransformer PLUGINSERVICE 
		fmlloader-1.19.2-43.2.9.jar runtimedistcleaner PLUGINSERVICE 
		modlauncher-10.0.8.jar mixin TRANSFORMATIONSERVICE 
		modlauncher-10.0.8.jar fml TRANSFORMATIONSERVICE 
	FML Language Providers: 
		minecraft@1.0
		lowcodefml@null
		javafml@null
	Mod List: 
		create_misc_and_things_  1.19.2_3.0.jar           |create: things and misc       |create_things_and_misc        |1.0.0               |DONE      |Manifest: NOSIGNATURE
		botarium-forge-1.19.2-1.8.2.jar                   |Botarium                      |botarium                      |1.8.2               |DONE      |Manifest: NOSIGNATURE
		jei-1.19.2-forge-11.6.0.1015.jar                  |Just Enough Items             |jei                           |11.6.0.1015         |DONE      |Manifest: NOSIGNATURE
		appliedenergistics2-forge-12.9.5.jar              |Applied Energistics 2         |ae2                           |12.9.5              |DONE      |Manifest: NOSIGNATURE
		prefab-1.9.2.5.jar                                |Prefab                        |prefab                        |1.9.2.5             |DONE      |Manifest: NOSIGNATURE
		waystones-forge-1.19.2-11.4.0.jar                 |Waystones                     |waystones                     |11.4.0              |DONE      |Manifest: NOSIGNATURE
		glassential-forge-1.19-1.2.4.jar                  |Glassential                   |glassential                   |1.19-1.2.4          |DONE      |Manifest: NOSIGNATURE
		mcwfurnituresbop-1.19.2-1.2.jar                   |Macaw's Furnitures - BOP      |mcwfurnituresbop              |1.19.2-1.2          |DONE      |Manifest: NOSIGNATURE
		journeymap-1.19.2-5.9.7-forge.jar                 |Journeymap                    |journeymap                    |5.9.7               |DONE      |Manifest: NOSIGNATURE
		CTM-1.19.2-1.1.6+8.jar                            |ConnectedTexturesMod          |ctm                           |1.19.2-1.1.6+8      |DONE      |Manifest: NOSIGNATURE
		cookingforblockheads-forge-1.19.2-13.3.2.jar      |CookingForBlockheads          |cookingforblockheads          |13.3.2              |DONE      |Manifest: NOSIGNATURE
		Controlling-forge-1.19.2-10.0+7.jar               |Controlling                   |controlling                   |10.0+7              |DONE      |Manifest: NOSIGNATURE
		configured-2.1.1-1.19.2.jar                       |Configured                    |configured                    |2.1.1               |DONE      |Manifest: NOSIGNATURE
		useitemonblockevent-1.19-1.0.0.1.jar              |Use Item on Block Event       |useitemonblockevent           |1.0.0.1             |DONE      |Manifest: NOSIGNATURE
		BotanyPots-Forge-1.19.2-9.0.33.jar                |BotanyPots                    |botanypots                    |9.0.33              |DONE      |Manifest: NOSIGNATURE
		macawsbridgesbop-1.19.2-1.2.jar                   |Macaw's Bridges - BOP         |macawsbridgesbop              |1.19.2-1.2          |DONE      |Manifest: NOSIGNATURE
		Bookshelf-Forge-1.19.2-16.3.20.jar                |Bookshelf                     |bookshelf                     |16.3.20             |DONE      |Manifest: eb:c4:b1:67:8b:f9:0c:db:dc:4f:01:b1:8e:61:64:39:4c:10:85:0b:a6:c4:c7:48:f0:fa:95:f2:cb:08:3a:e5
		LimitMobSpawn-19.3.jar                            |Limit Mob Spawn               |limitmobspawn                 |19.3                |DONE      |Manifest: 1a:13:52:63:6f:dc:0c:ad:7f:8a:64:ac:46:58:8a:0c:90:ea:2c:5d:11:ac:4c:d4:62:85:c7:d1:00:fa:9c:76
		balm-forge-1.19.2-4.5.7.jar                       |Balm                          |balm                          |4.5.7               |DONE      |Manifest: NOSIGNATURE
		forge-1.19.2-43.2.9-universal.jar                 |Forge                         |forge                         |43.2.9              |DONE      |Manifest: 84:ce:76:e8:45:35:e4:0e:63:86:df:47:59:80:0f:67:6c:c1:5f:6e:5f:4d:b3:54:47:1a:9f:7f:ed:5e:f2:90
		[1.19.2] More Crafting Tables Forge 4.2.0.jar     |More Crafting Tables Mod      |mctb                          |1.19.2              |DONE      |Manifest: NOSIGNATURE
		chipped-forge-1.19.2-2.1.5.jar                    |Chipped                       |chipped                       |2.1.5               |DONE      |Manifest: NOSIGNATURE
		ZeroCore2-1.19.2-2.1.34.jar                       |Zero CORE 2                   |zerocore                      |1.19.2-2.1.34       |DONE      |Manifest: NOSIGNATURE
		client-1.19.2-20220805.130853-srg.jar             |Minecraft                     |minecraft                     |1.19.2              |DONE      |Manifest: a1:d4:5e:04:4f:d3:d6:e0:7b:37:97:cf:77:b0:de:ad:4a:47:ce:8c:96:49:5f:0a:cf:8c:ae:b2:6d:4b:8a:3f
		mcw-bridges-2.0.7-mc1.19.2forge.jar               |Macaw's Bridges               |mcwbridges                    |2.0.7               |DONE      |Manifest: NOSIGNATURE
		TerraBlender-forge-1.19.2-2.0.1.136.jar           |TerraBlender                  |terrablender                  |2.0.1.136           |DONE      |Manifest: NOSIGNATURE
		BotanyTrees-Forge-1.19.2-5.0.8.jar                |BotanyTrees                   |botanytrees                   |5.0.8               |DONE      |Manifest: NOSIGNATURE
		BiomesOPlenty-1.19.2-17.1.1.162.jar               |Biomes O' Plenty              |biomesoplenty                 |17.1.1.162          |DONE      |Manifest: NOSIGNATURE
		resourcefulconfig-forge-1.19.2-1.0.20.jar         |Resourcefulconfig             |resourcefulconfig             |1.0.20              |DONE      |Manifest: NOSIGNATURE
		flywheel-forge-1.19.2-0.6.8.a.jar                 |Flywheel                      |flywheel                      |0.6.8.a             |DONE      |Manifest: NOSIGNATURE
		create-1.19.2-0.5.1.b.jar                         |Create                        |create                        |0.5.1.b             |DONE      |Manifest: NOSIGNATURE
		curios-forge-1.19.2-5.1.4.1.jar                   |Curios API                    |curios                        |1.19.2-5.1.4.1      |DONE      |Manifest: NOSIGNATURE
		Mekanism-1.19.2-10.3.8.477.jar                    |Mekanism                      |mekanism                      |10.3.8              |DONE      |Manifest: NOSIGNATURE
		MekanismGenerators-1.19.2-10.3.8.477.jar          |Mekanism: Generators          |mekanismgenerators            |10.3.8              |DONE      |Manifest: NOSIGNATURE
		Patchouli-1.19.2-77.jar                           |Patchouli                     |patchouli                     |1.19.2-77           |DONE      |Manifest: NOSIGNATURE
		create-stuff-additions1.19.2_v2.0.3b.jar          |Create Stuff & Additions      |create_sa                     |2.0.3.              |DONE      |Manifest: NOSIGNATURE
		time-in-a-bottle-3.0.1-mc1.19.jar                 |Time In A Bottle              |tiab                          |3.0.1-mc1.19        |DONE      |Manifest: NOSIGNATURE
		resourcefullib-forge-1.19.2-1.1.24.jar            |Resourceful Lib               |resourcefullib                |1.1.24              |DONE      |Manifest: NOSIGNATURE
		worldedit-mod-7.2.12.jar                          |WorldEdit                     |worldedit                     |7.2.12+6240-87f4ae1 |DONE      |Manifest: NOSIGNATURE
		MekanismTools-1.19.2-10.3.8.477.jar               |Mekanism: Tools               |mekanismtools                 |10.3.8              |DONE      |Manifest: NOSIGNATURE
		mcw-roofs-2.2.3-mc1.19.2forge.jar                 |Macaw's Roofs                 |mcwroofs                      |2.2.3               |DONE      |Manifest: NOSIGNATURE
		macawsroofsbop-1.19.2-1.4.jar                     |Macaw's Roofs - BOP           |macawsroofsbop                |1.19.2-1.4          |DONE      |Manifest: NOSIGNATURE
		BetterFurnacesReforged-1.19.2-1.0.3.jar           |BetterFurnaces Reforged       |betterfurnacesreforged        |1.19.2-1.0.3        |DONE      |Manifest: NOSIGNATURE
		architectury-6.5.85-forge.jar                     |Architectury                  |architectury                  |6.5.85              |DONE      |Manifest: NOSIGNATURE
		ftb-library-forge-1902.3.19-build.214.jar         |FTB Library                   |ftblibrary                    |1902.3.19-build.214 |DONE      |Manifest: NOSIGNATURE
		ftb-teams-forge-1902.2.13-build.100.jar           |FTB Teams                     |ftbteams                      |1902.2.13-build.100 |DONE      |Manifest: NOSIGNATURE
		ftb-chunks-forge-1902.3.21-build.266.jar          |FTB Chunks                    |ftbchunks                     |1902.3.21-build.266 |DONE      |Manifest: NOSIGNATURE
		mcw-furniture-3.1.0-mc1.19.2forge.jar             |Macaw's Furniture             |mcwfurnitures                 |3.1.0               |DONE      |Manifest: NOSIGNATURE
		ExtremeReactors2-1.19.2-2.0.63.jar                |Extreme Reactors              |bigreactors                   |1.19.2-2.0.63       |DONE      |Manifest: NOSIGNATURE
		CodeChickenLib-1.19.2-4.3.1.481-universal.jar     |CodeChicken Lib               |codechickenlib                |4.3.1.481           |DONE      |Manifest: 31:e6:db:63:47:4a:6e:e0:0a:2c:11:d1:76:db:4e:82:ff:56:2d:29:93:d2:e5:02:bd:d3:bd:9d:27:47:a5:71
		EnderStorage-1.19.2-2.10.1.181-universal.jar      |EnderStorage                  |enderstorage                  |2.10.1.181          |DONE      |Manifest: 31:e6:db:63:47:4a:6e:e0:0a:2c:11:d1:76:db:4e:82:ff:56:2d:29:93:d2:e5:02:bd:d3:bd:9d:27:47:a5:71
		morered-1.19.2-3.0.0.1.jar                        |More Red                      |morered                       |3.0.0.1             |DONE      |Manifest: NOSIGNATURE
		createaddition-1.19.2-20230527a.jar               |Create Crafts & Additions     |createaddition                |1.19.2-20230527a    |DONE      |Manifest: NOSIGNATURE
	Flywheel Backend: GL33 Instanced Arrays
	Crash Report UUID: 36d13e64-c768-4217-a941-5782280dd8c1
	FML: 43.2
	Forge: net.minecraftforge:43.2.9"
5X3xY6en,Untitled,kjmkj,C++,Saturday 3rd of June 2023 10:36:44 AM CDT,"#include <bits/stdc++.h>

using namespace std;
#define int long long
#define double long double
#define pb push_back
#define randGen mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())

const int INF = 1e18;

double rast(vector<int> a, vector<int> b) {
  int rast = abs(a[0] - b[0]) * abs(a[0] - b[0]) +
      abs(a[1] - b[1]) * abs(a[1] - b[1]);
  if (rast <= (a[2] + b[2]) * (a[2] + b[2])) {
    return 0;
  } else {
    double h = sqrt(rast) - (double)(a[2] + b[2]);
    return h;
  }
}

signed main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  cout.tie(NULL);
  int x1, y1, x2, y2;
  cin >> x1 >> y1 >> x2 >> y2;
  int n;
  cin >> n;
  vector<int> a[n + 2];
  for (int i = 0; i < n; ++i) {
    int x, y, r;
    cin >> x >> y >> r;
    a[i] = {x, y, r};
  }
  n += 2;
  a[n - 2] = {x1, y1, 0};
  a[n - 1] = {x2, y2, 0};
  vector<pair<int, double>> g[n];
  for (int i = 0; i < n; ++i) {
    for (int j = 0; j < n; ++j) {
      if (i != j) {
        g[i].pb({j, rast(a[i], a[j])});
      }
    }
  }
  int s = n - 2, t = n - 1;
  set<pair<double, int>> q;
  vector<double> dist(n, INF);
  dist[s] = 0;
  for (int i = 0; i < n; ++i) {
    q.insert({dist[i], i});
  }
  while (!q.empty()) {
    auto [w4, v] = *q.begin();
    q.erase(q.begin());
    for (auto [u, w] : g[v]) {
      if (dist[u] > dist[v] + w) {
        q.erase({dist[u], u});
        dist[u] = dist[v] + w;
        q.insert({dist[u], u});
      }
    }
  }
  cout << setprecision(12) << dist[t];
  return 0;
}
"
XegRPJiW,Untitled,cepxuozab,C++,Saturday 3rd of June 2023 09:33:06 AM CDT,"
void Test1() {
  HotelManager hm;
  ASSERT_EQUAL(hm.clients(""M""), 0);
  ASSERT_EQUAL(hm.rooms(""M""), 0);
  hm.book({ 10,""F"",1,2 });
  hm.book({ 10,""M"",1,1 });
  hm.book({ 86409,""F"",2,1 });
  ASSERT_EQUAL(hm.clients(""F""), 2);
  ASSERT_EQUAL(hm.rooms(""F""), 3);
  ASSERT_EQUAL(hm.clients(""M""), 1);
  hm.book({ 86410,""M"",2,10 });
  ASSERT_EQUAL(hm.rooms(""F""), 1);
  ASSERT_EQUAL(hm.rooms(""M""), 10);
}
void Test2() {
  HotelManager hm;

  ASSERT_EQUAL(hm.rooms(""a""), 0);
  ASSERT_EQUAL(hm.clients(""a""), 0);
  hm.book({ -100000, ""a"", 100000, 1000 });
  hm.book({ -100000, ""a"", 100003, 1000 });
  hm.book({ -100000, ""b"", 100002, 1000 });
  ASSERT_EQUAL(hm.rooms(""a""), 2000);
  ASSERT_EQUAL(hm.clients(""a""), 2);
  hm.book({ -10000, ""a"", 100002, 1000 });
  ASSERT_EQUAL(hm.rooms(""a""), 1000);
  ASSERT_EQUAL(hm.clients(""a""), 1);
  ASSERT_EQUAL(hm.rooms(""b""), 0);
  ASSERT_EQUAL(hm.clients(""b""), 0);
}
void Test3() {
  HotelManager manager;

  // Test empty bookings
  ASSERT_EQUAL(manager.clients(""mariott""), 0);
  ASSERT_EQUAL(manager.rooms(""mariott""), 0);

  manager.book({ 0, ""mariott"", 1, 10 });
  manager.book({ 0, ""mariott"", 2, 1 });
  manager.book({ 0, ""mariott"", 3, 1 });
  manager.book({ 0, ""mariott"", 4, 1 });
  manager.book({ 0, ""hilton"", 1, 1 });
  manager.book({ 1, ""hilton"", 2, 1 });

  // Test correctness
  ASSERT_EQUAL(manager.clients(""mariott""), 4);
  ASSERT_EQUAL(manager.rooms(""mariott""), 13);
  ASSERT_EQUAL(manager.clients(""hilton""), 2);
  ASSERT_EQUAL(manager.rooms(""hilton""), 2);

  // Test event past 1 day resets statics
  manager.book({ 86400, ""mariott"", 1, 1 });
  ASSERT_EQUAL(manager.clients(""mariott""), 1);
  ASSERT_EQUAL(manager.rooms(""mariott""), 1);
  ASSERT_EQUAL(manager.clients(""hilton""), 1);
  ASSERT_EQUAL(manager.rooms(""hilton""), 1);

  // Test no clients and room for the last day
  manager.book({ 86401, ""mariott"", 5, 1 });
  ASSERT_EQUAL(manager.clients(""mariott""), 2);
  ASSERT_EQUAL(manager.rooms(""mariott""), 2);
  ASSERT_EQUAL(manager.clients(""hilton""), 0);
  ASSERT_EQUAL(manager.rooms(""hilton""), 0);
}
void Test4() {
  HotelManager b;

  ASSERT_EQUAL(b.rooms(""a""),0);
  ASSERT_EQUAL(b.clients(""a""),0);

  ASSERT_EQUAL(b.rooms(""b""),0);
  ASSERT_EQUAL(b.clients(""c""),0);

  b.book({ -100000,""a"",100000,1000 });
  b.book({ -100000,""a"",100003,1000 });
  b.book({ -100000,""b"",100002,1000 });
  ASSERT_EQUAL(b.rooms(""a""),2000);
  ASSERT_EQUAL(b.clients(""a""),2);

  b.book({ -10000,""a"",100002,1000 });
  ASSERT_EQUAL(b.rooms(""a""),1000);
  ASSERT_EQUAL(b.clients(""a""),1);
  ASSERT_EQUAL(b.rooms(""b""),0);
  ASSERT_EQUAL(b.clients(""b""),0);
}
void Test5() {
  HotelManager b;

  b.book({ 0, ""a"", 0, 1 });
  b.book({ 1, ""a"", 1, 2 });
  b.book({ 86400, ""a"", 1, 3 });
  ASSERT_EQUAL(b.clients(""a""), 1);
  ASSERT_EQUAL(b.rooms(""a""), 5);
}
void Test6() {
  HotelManager b;

  b.book({ -86400, ""a"", 2, 2 });
  b.book({ 0, ""a"", 1, 5 });
  ASSERT_EQUAL(b.clients(""a""), 1);
  ASSERT_EQUAL(b.rooms(""a""), 5);
}
void Test7() {
  HotelManager b;

  b.book({ 1, ""a"", 11, 4 });
  b.book({ 50000, ""a"", 11, 5 });
  b.book({ 90000, ""a"", 22, 2 });
  ASSERT_EQUAL(b.clients(""a""), 2);
  ASSERT_EQUAL(b.rooms(""a""), 7);
}
void Test8() {
  HotelManager b;

  b.book({ 2147483647, ""a"", 1, 3 });
  b.book({ 2147483648, ""a"", 2, 11 });
  b.book({ 4147483648, ""a"", 3, 13 });
  ASSERT_EQUAL(b.clients(""a""), 1);
  ASSERT_EQUAL(b.rooms(""a""), 13);
}


void AllTests() {
  TestRunner tr;
  RUN_TEST(tr, Test1);
  RUN_TEST(tr, Test2);
  RUN_TEST(tr, Test3);
  RUN_TEST(tr, Test4);
  RUN_TEST(tr, Test5);
  RUN_TEST(tr, Test6);
  RUN_TEST(tr, Test7);
  RUN_TEST(tr, Test8);
}

"
SrqY07Ni,Untitled,lazyflavor,Java,Saturday 3rd of June 2023 09:24:37 AM CDT,"class Solution {
    public int solution(int[][] triangle) {
        int[][] dp = new int[triangle.length][triangle[triangle.length-1].length];
        
        dp[0][0] = triangle[0][0];
        
        int max = 0;
        
        for (int i = 1; i < triangle.length; i++) {
            for (int j = 0; j < triangle[i].length; j++) {
                // 왼쪽과 오른쪽 비교
                if (j == 0) {
                    dp[i][j] = dp[i-1][j] + triangle[i][j];
                }
                else if (j == triangle[i].length - 1) {
                    dp[i][j] = dp[i-1][j-1] + triangle[i][j];
                    // System.out.println(dp[i][j]);
                }
                else {
                dp[i][j] = dp[i-1][j-1] > dp[i-1][j] ?
                    dp[i-1][j-1] + triangle[i][j] :
                    dp[i-1][j] + triangle[i][j];
                }
                
                max = max < dp[i][j] ? dp[i][j] : max;
                // System.out.println(max);
            }
        }
        
        return max;
    }
}"
vp4mXwGz,邀您一起看：流浪地球-HD高清,xiaomianao666,JavaScript,Saturday 3rd of June 2023 09:11:42 AM CDT,海阔视界规则分享，当前分享的是：二级页面详情￥page_detail￥流浪地球-HD高清@@eyJkYXRhIjoie1wiYXNzb2NpYXRlZE1vZGVsc01hcEZvckpvaW5UYWJsZVwiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhGS1wiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhvdXRGS1wiOnt9LFwiZmllbGRzVG9TZXRUb0RlZmF1bHRcIjpbXSxcImdtdE1vZGlmaWVkXCI6MCxcImlkXCI6MCxcImxhc3RfY2hhcHRlcl9ydWxlXCI6XCJcIixcImxpc3RUb0NsZWFyQXNzb2NpYXRlZEZLXCI6W10sXCJsaXN0VG9DbGVhclNlbGZGS1wiOltdLFwicGFnZUxpc3RcIjpbe1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuS6jOe6p+ino+aekFwiLFwicGF0aFwiOlwicFwiLFwicnVsZVwiOlwianM6XFxuYWRkTGlzdGVuZXIoXFxcIm9uQ2xvc2VcXFwiLCAkLnRvU3RyaW5nKCgpID0+IHtcXG4gICAgdXBkYXRlSXRlbSgncGFyc2V0Jywge1xcbiAgICAgICAgdGl0bGU6IGdldEl0ZW0oJ+WXheaOoicsICfop4bpopHll4XmjqInKSwgICAgICAgIFxcbiAgICB9KTtcXG4gICAgY2xlYXJNeVZhcignd2VidXJsJyk7XFxuICAgIHB1dE15VmFyKCdibScsICcwJyk7XFxuICAgIHN0b3JhZ2UwLnB1dE15VmFyKFxcXCJkdW9zZWxlY3RcXFwiLFtdKTtcXG4gICAgLy9iYWNrKGZhbHNlKVxcbn0pKTtcXG5cXG52YXIgQml0VFMgPSBbXTtcXG5cXG4vL3B1dE15VmFyKFxcXCJtdWJhblxcXCIsIHvlkI3np7A6J+aegeWuouW9seinhid9KVxcblxcbmV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvenRvb2xzJykpLnJ1bGUpXFxuXFxudmFyIHVybCA9ICcnO1xcbnZhciBodG1sID0gJyc7XFxuXFxudmFyIGtleXMgPSBNWV9QQVJBTVM7XFxudmFyIGZyb20gPSBrZXlzLmZyb20gIT0gdW5kZWZpbmVkID8ga2V5cy5mcm9tIDogJyc7XFxudmFyIGR0aXRsZSA9IGtleXMucGFnZVRpdGxlICE9IHVuZGVmaW5lZCA/IGtleXMucGFnZVRpdGxlIDogJyc7XFxuXFxuXFxuaWYgKGdldE15VmFyKCd3ZWJ1cmwnLCAnJykgPT0gJycpIHtcXG4gICAgLy9NWV9VUkwgPSBNWV9VUkwucmVwbGFjZSgnI2ltbWVyc2l2ZVRoZW1lIycsICcnKTtcXG4gICAgTVlfVVJMID0gTVlfVVJMLmluY2x1ZGVzKCcjJykgPyBNWV9VUkwuc3BsaXQoJyMnKVswXSA6IE1ZX1VSTDtcXG4gICAgdmFyIHUgPSBnZXRQYXJhbShcXFwidVxcXCIpXFxuICAgIGlmICh1ID09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgdSA9IE1ZX1VSTFxcbiAgICB9XFxuICAgIGxvZygndTonICsgdSk7XFxuICAgIHVybCA9IGdldFR1cmwodSk7XFxuICAgIC8v6aKE6K+7XFxuICAgIC8vbG9nKCd1cmw6Jyt1cmwpO1xcbiAgICB2YXIgdGVtcCA9IGZldGNoKHVybCk7XFxuICAgIHZhciBhbCA9IHBkZmEodGVtcCwgXFxcImJvZHkmJmFcXFwiKTtcXG4gICAgaWYgKHRlbXAuc2VhcmNoKC93aW5kb3cubG9jYXRpb24uaHJlZi8pICE9IC0xICYmIGFsLmxlbmd0aCA9PSAwKSB7XFxuICAgICAgICBNWV9VUkwgPSB1cmw7XFxuICAgICAgICB2YXIgdGUgPSB0ZW1wLnJlcGxhY2UoLy4raHJlZj1cXFwiKC4qPylcXFwiLisvZywgJzxhIGhyZWY9XFxcIiQxXFxcIj48L2E+Jyk7XFxuICAgICAgICB1cmwgPSBwZCh0ZSwgXFxcImEmJmhyZWZcXFwiKTtcXG4gICAgICAgIGxvZygnanPph43lrprlkJE6JyArIHVybCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBodG1sID0gdGVtcDtcXG4gICAgfVxcblxcbiAgICBwdXRNeVZhcignd2VidXJsJywgdXJsKTtcXG5cXG59IGVsc2Uge1xcbiAgICB1cmwgPSBnZXRNeVZhcignd2VidXJsJyk7XFxufVxcbnZhciBkdXJsID0gdXJsO1xcbmxvZygn5LqM57qn6aG16Z2iOicgKyBkdXJsKTtcXG5cXG5pZiAoZ2V0SXRlbSgnYWknLCAnMCcpID09ICcxJykge1xcbiAgICB2YXIgbGF6eSA9ICQoJycpLmxhenlSdWxlKCgpID0+IHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgdmFyIGh0bWwgPSBKU09OLnBhcnNlKHJlcXVlc3QoaW5wdXQpLm1hdGNoKC9yIHBsYXllcl8uKj89KC4qPyk8LylbMV0pXFxuICAgICAgICAgICAgdmFyIHVybCA9IGh0bWwudXJsXFxuICAgICAgICAgICAgaWYgKGh0bWwuZW5jcnlwdCA9PSAnMScpIHtcXG4gICAgICAgICAgICAgICAgdXJsID0gdW5lc2NhcGUodXJsKTtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGh0bWwuZW5jcnlwdCA9PSAnMicpIHtcXG4gICAgICAgICAgICAgICAgdXJsID0gdW5lc2NhcGUoYmFzZTY0RGVjb2RlKHVybCkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoL20zdTh8bXA0Ly50ZXN0KHVybCkpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybFxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiAndmlkZW86Ly8nICsgaW5wdXRcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICAgICAgcmV0dXJuICd2aWRlbzovLycgKyBpbnB1dFxcbiAgICAgICAgfVxcbiAgICB9KVxcblxcbiAgICB0cnkge1xcbiAgICAgICAgbG9nKHVybClcXG4gICAgICAgIE1ZX1VSTCA9ICdoaWtlcjovL2VtcHR5IyMnICsgdXJsXFxuICAgICAgICByZXF1aXJlKGNvbmZpZy7oh6rliqjljLnphY0pO1xcbiAgICAgICAg6Ieq5Yqo5LqM57qnKGxhenkpO1xcbiAgICAgICAgcHV0TXlWYXIoJ2JtJywgJzEnKVxcbiAgICB9IGNhdGNoIHtcXG4gICAgICAgIHB1dE15VmFyKCdibScsICcwJylcXG4gICAgfVxcbn1cXG5cXG5cXG5sb2coJ+aooeadvzonICsgZ2V0TXlWYXIoJ2JtJywgJzAnKSlcXG5cXG5pZiAoZ2V0TXlWYXIoJ2JtJywgJzAnKSA9PSAnMCcpIHtcXG5cXG4gICAgdmFyIGQgPSBbXTtcXG4gICAgTVlfVVJMID0gdXJsXFxuXFxuICAgIGZ1bmN0aW9uIGdldFRpdGxlKGh0bWwsIHMpIHtcXG4gICAgICAgIHZhciB0aXRsZSA9ICcnO1xcbiAgICAgICAgdmFyIHRpdGxlcyA9IHBkZmEoaHRtbCwgcyk7XFxuICAgICAgICAvL2xvZyh0aXRsZXMpO1xcbiAgICAgICAgaWYgKHRpdGxlcy5sZW5ndGggPT0gMCkge1xcbiAgICAgICAgICAgIHJldHVybiB0aXRsZVxcbiAgICAgICAgfVxcbiAgICAgICAgZm9yIChsZXQgeCBvZiB0aXRsZXMpIHtcXG4gICAgICAgICAgICBpZiAoeC5pbmNsdWRlcygnPGZvbnQnKSkge1xcbiAgICAgICAgICAgICAgICB0aXRsZSA9IHBkZmgoeCwgJ2gxLS1mb250JiZUZXh0Jyk7XFxuICAgICAgICAgICAgfSBlbHNlIGlmICh4LmluY2x1ZGVzKCc8c3BhbicpKSB7XFxuICAgICAgICAgICAgICAgIHRpdGxlID0gcGRmaCh4LCAnaDEtLXNwYW4mJlRleHQnKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICB0aXRsZSA9IHBkZmgoeCwgJ1RleHQnKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKHRpdGxlICE9ICcnKSB7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiB0aXRsZVxcbiAgICB9XFxuXFxuICAgIGlmIChodG1sID09IFxcXCJcXFwiKSB7XFxuICAgICAgICBodG1sID0gZmV0Y2hQQyh1cmwpXFxuICAgIH1cXG5cXG4gICAgbGV0IGFsaXN0ID0gcGRmYShodG1sLCBcXFwiYm9keSYmYVxcXCIpO1xcbiAgICAvKmlmKGh0bWwuc2VhcmNoKC93aW5kb3cubG9jYXRpb24uaHJlZi8pIT0tMSYmYWxpc3QubGVuZ3RoPT0wKXtcXG4gICAgICAgIE1ZX1VSTD11cmw7XFxuICAgIHZhciB0ZW1wPWh0bWwucmVwbGFjZSgvLitocmVmPVxcXCIoLio/KVxcXCIuKy9nLCc8YSBocmVmPVxcXCIkMVxcXCI+PC9hPicpO1xcbiAgICB1cmw9cGQodGVtcCxcXFwiYSYmaHJlZlxcXCIpO1xcbiAgICBsb2coJ2pz6YeN5a6a5ZCROicrdXJsKTtcXG4gICAgcHV0TXlWYXIoJ3dlYnVybCcsIHVybCk7XFxuICAgIGh0bWwgPSBmZXRjaFBDKHVybCk7XFxuICAgIGFsaXN0ID0gcGRmYShodG1sLCBcXFwiYm9keSYmYVxcXCIpO1xcbiAgICB9Ki9cXG5cXG4gICAgbGV0IGFyciA9IGFsaXN0Lm1hcChpdCA9PiB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgIC8vaHRtbDogaXQsXFxuICAgICAgICAgICAgdGV4dDogcGRmaChpdCwgXFxcImEmJlRleHRcXFwiKSxcXG4gICAgICAgICAgICB0aXRsZTogcGRmaChpdCwgXFxcImEmJnRpdGxlXFxcIiksXFxuICAgICAgICAgICAgaHJlZjogcGQoaXQsIFxcXCJhJiZocmVmXFxcIiwgdXJsKVxcbiAgICAgICAgfVxcbiAgICB9KTtcXG5cXG5cXG4gICAgdmFyIHRpdGxlID0gZ2V0VGl0bGUoaHRtbCwgJ2JvZHkmJmgxJyk7XFxuICAgIGlmICh0aXRsZSA9PSAnJykge1xcbiAgICAgICAgdGl0bGUgPSBnZXRUaXRsZShodG1sLCBcXFwiYm9keSYmaDNbY2xhc3MqPSd0aXRsZSddXFxcIik7XFxuICAgIH1cXG4gICAgaWYgKHRpdGxlID09ICcnKSB7XFxuICAgICAgICB0aXRsZSA9IGdldFRpdGxlKGh0bWwsIFxcXCJoZWFkJiZ0aXRsZVxcXCIpO1xcbiAgICB9XFxuICAgIGlmIChkdGl0bGUgIT0gXFxcIlxcXCIpIHtcXG4gICAgICAgIHNldFBhZ2VUaXRsZShkdGl0bGUpO1xcbiAgICB9IGVsc2UgaWYgKGdldFBhZ2VUaXRsZSgpLmluY2x1ZGVzKCfor6bmg4UnKSkge1xcbiAgICAgICAgaWYgKHRpdGxlICE9ICcnKSB7XFxuICAgICAgICAgICAgaWYgKHRpdGxlLmluY2x1ZGVzKCctJykpIHtcXG4gICAgICAgICAgICAgICAgdGl0bGUgPSB0aXRsZS5zcGxpdCgnLScpWzBdLnRyaW0oKVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBzZXRQYWdlVGl0bGUodGl0bGUpXFxuICAgICAgICB9XFxuICAgIH1cXG5cXG5cXG4gICAgLy9sb2coYXJyKTtcXG4gICAgbGV0IGRlYnVnID0gZmFsc2U7XFxuXFxuICAgIGZ1bmN0aW9uIGNsZWFyVGV4dChpdCkge1xcbiAgICAgICAgcmV0dXJuIGl0LnJlcGxhY2UoL+esrHzpm4Z856ugL2csIFxcXCJcXFwiKTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBpc01vdmllKGl0KSB7XFxuICAgICAgICBpZiAoaXQgPT0gbnVsbCB8fCBpdC50ZXh0ID09IG51bGwpIHtcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAobm9maWxlKGl0KSkge1xcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGxldCB0aXQgPSBpdC50aXRsZSB8fCBcXFwiXFxcIjtcXG4gICAgICAgIGl0ID0gaXQudGV4dCB8fCBcXFwiXFxcIjtcXG4gICAgICAgIGlmIChpdCA9PSBcXFwiXFxcIiB8fCBpdC5sZW5ndGggPiA4KSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgICAgLy/mjpLpmaRcXG4gICAgICAgIGxldCByZWcgPSAvXFxcXC586auY5riF55u05pKtfOWGmeecn+aOqOiNkHzlvbHpmaJ85b2x6KeGfOiTneWFieeUteW9sXzpq5jmuIXnlLXlvbF856ys5LiA5a2jfOesrOS6jOWto3znrKzkuInlraN856ys5Zub5a2jfOesrOS6lOWtoy87XFxuICAgICAgICBpZiAodGl0ICE9IFxcXCJcXFwiICYmICF0aXQuaW5jbHVkZXMoaXQpIHx8IHJlZy50ZXN0KGl0KSkge1xcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBpdC5tYXRjaCgv5Y6f55S7fOWkh+eUqHzok53lhYl86LaF5riFfOmrmOa4hXzmraPniYd86Z+p54mIfDRLfDRrfDEwODBQfDcyMFB8VEN8SER8QkR85Lit5a2XLylcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBub3RDaGFwdGVyKGl0KSB7XFxuICAgICAgICBpZiAoaXQgPT0gbnVsbCB8fCBpdC50ZXh0ID09IG51bGwpIHtcXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBpdC50ZXh0Lm1hdGNoKC9bMC05XVxcXFwuWzAtOV3liIYvKTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBpc0NoYXB0ZXIoaXQsIHByZSwgbmV4dCkge1xcbiAgICAgICAgaWYgKG5vdENoYXB0ZXIoaXQpKSB7XFxuICAgICAgICAgICAgLy/kvJjlhYjmjpLpmaRcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgICAvL+WIpOaWreaYr+S4jeaYr+eUteW9sVxcbiAgICAgICAgaWYgKGlzTW92aWUoaXQpKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gaXNDaGFwdGVyMChpdCwgcHJlKSB8fCBpc0NoYXB0ZXIwKGl0LCBuZXh0KTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBnZXRDaGFwdGVyTnVtKGl0KSB7XFxuICAgICAgICBpZiAoaXQgPT0gbnVsbCB8fCBpdC50ZXh0ID09IG51bGwpIHtcXG4gICAgICAgICAgICByZXR1cm4gLTE7XFxuICAgICAgICB9XFxuICAgICAgICBpdCA9IGl0LnRleHQgfHwgXFxcIlxcXCI7XFxuICAgICAgICBpZiAoaXQgPT0gXFxcIlxcXCIpIHtcXG4gICAgICAgICAgICByZXR1cm4gLTE7XFxuICAgICAgICB9XFxuICAgICAgICBpdCA9IGNsZWFyVGV4dChpdCk7XFxuICAgICAgICBsZXQgcmVnID0gL15bMC05XSokLztcXG4gICAgICAgIGlmICghcmVnLnRlc3QoaXQpKSB7XFxuICAgICAgICAgICAgcmV0dXJuIC0xO1xcbiAgICAgICAgfVxcbiAgICAgICAgaXQgPSBwYXJzZUludChpdCk7XFxuICAgICAgICBpZiAoaXNOYU4oaXQpKSB7XFxuICAgICAgICAgICAgcmV0dXJuIC0xO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGl0ID4gMTkwMCAmJiBpdCA8IDIxMDApIHtcXG4gICAgICAgICAgICByZXR1cm4gLTE7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gaXQ7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gaXNDaGFwdGVyMChpdCwgYnJvdGhlcikge1xcbiAgICAgICAgLyppZiAoZGVidWcpIHtcXG4gICAgICAgICAgICBsb2coe1xcbiAgICAgICAgICAgICAgICBpdDogaXQsXFxuICAgICAgICAgICAgICAgIGJyb3RoZXI6IGJyb3RoZXJcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0qL1xcbiAgICAgICAgaXQgPSBnZXRDaGFwdGVyTnVtKGl0KTtcXG4gICAgICAgIC8vaWYgKGRlYnVnKSBsb2coaXQpO1xcbiAgICAgICAgaWYgKGl0IDwgMCkge1xcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGJyb3RoZXIgPSBnZXRDaGFwdGVyTnVtKGJyb3RoZXIpO1xcbiAgICAgICAgLy9pZiAoZGVidWcpIGxvZyhicm90aGVyKTtcXG4gICAgICAgIGlmIChicm90aGVyIDwgMCkge1xcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBpdCAtIGJyb3RoZXIgPCAyICYmIGl0IC0gYnJvdGhlciA+IC0yO1xcbiAgICB9XFxuXFxuICAgIGxldCB0ZnB1c2ggPSBnZXRJdGVtKCd3ZWJwdXNoJywgJzAnKTtcXG5cXG4gICAgbGV0IF93ZWIgPSAkLnRvU3RyaW5nKCh0ZnB1c2gpID0+IHtcXG4gICAgICAgIGxldCB1cmxzID0gX2dldFVybHMoKTtcXG4gICAgICAgIGxldCByZWcgPSAvXFxcXC5odG1sfFxcXFwuY3NzfFxcXFwuanMvO1xcbiAgICAgICAgZm9yIChsZXQgayBpbiB1cmxzKSB7XFxuICAgICAgICAgICAgaWYgKCFyZWcudGVzdCh1cmxzW2tdKSAmJiB1cmxzW2tdLm1hdGNoKC9cXFxcLm1wNHxcXFxcLm0zdTgvKSkge1xcbiAgICAgICAgICAgICAgICBmeV9icmlkZ2VfYXBwLmxvZyh1cmxzW2tdKTtcXG4gICAgICAgICAgICAgICAgLy9yZXR1cm4gZnlfYnJpZGdlX2FwcC5nZXRIZWFkZXJVcmwodXJsc1trXS5yZXBsYWNlKC8uKj91cmw9LywgXFxcIlxcXCIpKSArIFxcXCIjaWdub3JlSW1nPXRydWUjXFxcIjtcXG4gICAgICAgICAgICAgICAgaWYgKHRmcHVzaCA9PSAnMCcpIHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmeV9icmlkZ2VfYXBwLmdldEhlYWRlclVybCh1cmxzW2tdLnJlcGxhY2UoLy4qP3VybD0vLCBcXFwiXFxcIikpICsgXFxcIiNpZ25vcmVJbWc9dHJ1ZSNcXFwiO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBsYXkgPSBmeV9icmlkZ2VfYXBwLmdldEhlYWRlclVybCh1cmxzW2tdLnJlcGxhY2UoLy4qP3VybD0vLCBcXFwiXFxcIikpO1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL3BhZ2UvcHVzaD9wdXNodXJsPScgKyBlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoe1xcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJuYW1lXFxcIjogZG9jdW1lbnQudGl0bGUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxcInVybFxcXCI6IHBsYXlcXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfSwgdGZwdXNoKTtcXG5cXG4gICAgZnVuY3Rpb24gX193ZWIobW9kZSkge1xcbiAgICAgICAgcmV0dXJuICQudG9TdHJpbmcoKHRmcHVzaCkgPT4ge1xcbiAgICAgICAgICAgIGxldCB1cmxzID0gX2dldFVybHMoKTtcXG4gICAgICAgICAgICBsZXQgcmVnID0gL1xcXFwuaHRtbHxcXFxcLmNzc3xcXFxcLmpzLztcXG4gICAgICAgICAgICBmb3IgKGxldCBrIGluIHVybHMpIHtcXG4gICAgICAgICAgICAgICAgaWYgKCFyZWcudGVzdCh1cmxzW2tdKSAmJiB1cmxzW2tdLm1hdGNoKC9cXFxcLm1wNHxcXFxcLm0zdTgvKSkge1xcbiAgICAgICAgICAgICAgICAgICAgZnlfYnJpZGdlX2FwcC5sb2codXJsc1trXSk7XFxuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiBmeV9icmlkZ2VfYXBwLmdldEhlYWRlclVybCh1cmxzW2tdLnJlcGxhY2UoLy4qP3VybD0vLCBcXFwiXFxcIikpICsgXFxcIiNpZ25vcmVJbWc9dHJ1ZSNcXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRmcHVzaCA9PSAnMCcpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnlfYnJpZGdlX2FwcC5nZXRIZWFkZXJVcmwodXJsc1trXS5yZXBsYWNlKC8uKj91cmw9LywgXFxcIlxcXCIpKSArIFxcXCIjaWdub3JlSW1nPXRydWUjXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBsYXkgPSBmeV9icmlkZ2VfYXBwLmdldEhlYWRlclVybCh1cmxzW2tdLnJlcGxhY2UoLy4qP3VybD0vLCBcXFwiXFxcIikpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9wYWdlL3B1c2g/cHVzaHVybD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcIm5hbWVcXFwiOiBkb2N1bWVudC50aXRsZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcInVybFxcXCI6IHBsYXlcXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LCBtb2RlKTtcXG4gICAgfVxcblxcbiAgICAkLmV4dGVuZCh7XFxuICAgICAgICBsd2ViOiBfX3dlYlxcbiAgICB9KVxcblxcbiAgICBsZXQgd2ViID0gZ2V0SXRlbSgnd2ViJywgJzAnKTtcXG4gICAgdmFyIHB1c2h0eXBlID0gWyfliJfooagnLCAn5Y2V6ZuGJ11cXG4gICAgdmFyIHBhcnNldHlwZSA9IFsnV2Vi5ZeF5o6iOjAnLCAn6KeG6aKR5ZeF5o6iOjEnLCAnZG3nm5LlrZA6MiddXFxuICAgIGxvZygn5o6o6YCB57G75Z6LOicgKyBwdXNodHlwZVtwYXJzZUludCh0ZnB1c2gpXSlcXG4gICAgbG9nKCfll4XmjqLnsbvlnos6JyArIHBhcnNldHlwZVtwYXJzZUludCh3ZWIpXS5zcGxpdCgnOicpWzBdKVxcblxcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgbGV0IGl0ID0gYXJyW2ldO1xcbiAgICAgICAgbGV0IHQgPSBpdC50ZXh0O1xcbiAgICAgICAgaWYgKCFpdC5ocmVmIHx8IGl0LmhyZWYgPT0gXFxcIlxcXCIpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGxldCBwcmUgPSBpID09IDAgPyBudWxsIDogYXJyW2kgLSAxXTtcXG4gICAgICAgIGxldCBuZXh0ID0gaSA9PSAoYXJyLmxlbmd0aCAtIDEpID8gbnVsbCA6IGFycltpICsgMV07XFxuICAgICAgICBpZiAoaXNDaGFwdGVyKGl0LCBwcmUsIG5leHQpKSB7XFxuICAgICAgICAgICAgaWYgKHRmcHVzaCA9PSAnMScpIHtcXG4gICAgICAgICAgICAgICAgLyp2YXIgdXJseCA9IFxcXCJ3ZWJSdWxlOi8vXFxcIiArIGl0LmhyZWYgKyBcXFwiQFxcXCIgKyBfd2ViO1xcbiAgICAgICAgICAgICAgICB2YXIgZXh0cmF4ID0ge1xcbiAgICAgICAgICAgICAgICAgICAganNMb2FkaW5nSW5qZWN0OiB0cnVlLFxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGl0LmhyZWYsXFxuICAgICAgICAgICAgICAgICAgICBjbHM6ICdwbGF5cycsXFxuICAgICAgICAgICAgICAgICAgICBibG9ja1J1bGVzOiBbJy5tNGEnLCAnLm1wMycsICcuZmx2JywgJy5hdmknLCAnLjNncCcsICcubXBlZycsICcud212JywgJy5tb3YnLCAnLnJtdmInLCAnLmdpZicsICcuanBlZycsICcucG5nJywgJy5pY28nLCAnLnN2ZyddXFxuICAgICAgICAgICAgICAgIH07Ki9cXG4gICAgICAgICAgICAgICAgdmFyIHVybHggPSAnaGlrZXI6Ly9wYWdlL3B1c2g/JnB1c2h1cmw9JyArIGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeSh7XFxuICAgICAgICAgICAgICAgICAgICBcXFwibmFtZVxcXCI6IGdldFBhZ2VUaXRsZSgpLFxcbiAgICAgICAgICAgICAgICAgICAgXFxcInVybFxcXCI6IGl0LnRleHQgKyAnJCcgKyBpdC5ocmVmLFxcbiAgICAgICAgICAgICAgICAgICAgXFxcImNvbnRlbnRcXFwiOiBNWV9VUkwudGl0bGUsXFxuICAgICAgICAgICAgICAgIH0pKTtcXG4gICAgICAgICAgICAgICAgdmFyIGV4dHJheCA9IHtcXG4gICAgICAgICAgICAgICAgICAgIGlkOiBpdC5ocmVmLFxcbiAgICAgICAgICAgICAgICAgICAgY2xzOiAncGxheXMnLFxcbiAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIGlmICh3ZWIgPT0gJzAnKSB7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgdXJseCA9IFxcXCJ3ZWJSdWxlOi8vXFxcIiArIGl0LmhyZWYgKyBcXFwiQFxcXCIgKyBfd2ViO1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4dHJheCA9IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBqc0xvYWRpbmdJbmplY3Q6IHRydWUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGl0LmhyZWYsXFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xzOiAncGxheXMnLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrUnVsZXM6IFsnLm00YScsICcubXAzJywgJy5mbHYnLCAnLmF2aScsICcuM2dwJywgJy5tcGVnJywgJy53bXYnLCAnLm1vdicsICcucm12YicsICcuZ2lmJywgJy5qcGVnJywgJy5wbmcnLCAnLmljbycsICcuc3ZnJ11cXG4gICAgICAgICAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAod2ViID09ICcxJykge1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVybHggPSBcXFwidmlkZW86Ly9cXFwiICsgaXQuaHJlZjtcXG4gICAgICAgICAgICAgICAgICAgIHZhciBleHRyYXggPSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGl0LmhyZWYsXFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xzOiAncGxheXMnLFxcbiAgICAgICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh3ZWIgPT0gJzInKSB7XFxuICAgICAgICAgICAgICAgICAgICBsYXp5ID0gJCgnJykubGF6eVJ1bGUoKCkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9sYXp5VG9YNT9ydWxlPWRt55uS5a2QJykudmlkZW9YNSgpO1xcbiAgICAgICAgICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICAgICAgICAgIHZhciB1cmx4ID0gaXQuaHJlZiArIGxhenlcXG4gICAgICAgICAgICAgICAgICAgIHZhciBleHRyYXggPSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGl0LmhyZWYsXFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xzOiAncGxheXMnLFxcbiAgICAgICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgICAgICB0aXRsZTogdCxcXG4gICAgICAgICAgICAgICAgdXJsOiB1cmx4LFxcbiAgICAgICAgICAgICAgICBwaDogdCArIFxcXCIkXFxcIiArIGl0LmhyZWYsXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF8zXFxcIixcXG4gICAgICAgICAgICAgICAgZXh0cmE6IGV4dHJheFxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIGlmIChkLmxlbmd0aCA9PSAwKSB7XFxuICAgICAgICAvL+WMuemFjeWksei0pVxcbiAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogXFxcIlxcXCIsXFxuICAgICAgICAgICAgdXJsOiB1cmwsXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ4NV93ZWJ2aWV3X3NpbmdsZVxcXCIsXFxuICAgICAgICAgICAgZGVzYzogXFxcImZsb2F0JiYxMDAlXFxcIixcXG4gICAgICAgICAgICBwaWNfdXJsOiBcXFwiXFxcIixcXG4gICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICBmbG9hdFZpZGVvOiB0cnVlLFxcbiAgICAgICAgICAgICAgICBjYW5CYWNrOiB0cnVlLFxcbiAgICAgICAgICAgICAgICBibG9ja1J1bGVzOiBbXFxcIi5naWZcXFwiLCBcXFwiL2FkL1xcXCIsIFxcXCJnb29nbGVcXFwiLCBcXFwiL3NoL3RvL1xcXCIsIFxcXCIuR0lGXFxcIl1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICAgIHRvYXN0KFxcXCJBSeWMuemFjeWksei0pe+8jOW3suS9v+eUqFg15Yqg6L29XFxcIik7XFxuICAgICAgICBsb2coXFxcIuW9k+WJjemhtemdouWcsOWdgDogXFxcIiArIHVybClcXG4gICAgICAgIHNldFJlc3VsdChkKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIC8v5Li657q/6Lev5Yqg5YiG5Ymy57q/XFxuICAgICAgICBsZXQgZDIgPSBbXTtcXG4gICAgICAgIGxldCBtdGFiID0gW107XFxuXFxuICAgICAgICBkID0gdW5pcXVlKGQpXFxuICAgICAgICAvL2xvZyhCaXRUUylcXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZC5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgIGQyLnB1c2goZFtpXSk7XFxuICAgICAgICAgICAgbXRhYi5wdXNoKGRbaV0ucGgpO1xcbiAgICAgICAgICAgIGlmIChpIDwgZC5sZW5ndGggLSAxKSB7XFxuICAgICAgICAgICAgICAgIGxldCBpdCA9IGRbaV07XFxuICAgICAgICAgICAgICAgIGxldCB0MSA9IHBhcnNlSW50KGNsZWFyVGV4dChpdC50aXRsZSkpO1xcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGRbaSArIDFdO1xcbiAgICAgICAgICAgICAgICBsZXQgdDIgPSBwYXJzZUludChjbGVhclRleHQobmV4dC50aXRsZSkpO1xcbiAgICAgICAgICAgICAgICBpZiAodDIgLSB0MSA+IDEgfHwgdDEgLSB0MiA+IDEpIHtcXG4gICAgICAgICAgICAgICAgICAgIG10YWIucHVzaCgnIycpO1xcbiAgICAgICAgICAgICAgICAgICAgZDIucHVzaCh7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJiaWdfYmxhbmtfYmxvY2tcXFwiXFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgICAgIGQyLnB1c2goe1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwibGluZV9ibGFua1xcXCJcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICAgICAgZDIucHVzaCh7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJiaWdfYmxhbmtfYmxvY2tcXFwiXFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGxldCBwbGF5bCA9IG10YWIuam9pbignIycpLnJlcGxhY2UoLyMjIy9nLCAnJCQkJCQkJyk7XFxuXFxuXFxuICAgICAgICBsZXQgZnJvbSA9IFtdO1xcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwbGF5bC5zcGxpdCgnJCQkJykubGVuZ3RoOyBqKyspIHtcXG4gICAgICAgICAgICBmcm9tLnB1c2goXFxcIuaSreaUvuWIl+ihqFxcXCIgKyBbaiArIDFdKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGxldCBwdXNoID0gSlNPTi5zdHJpbmdpZnkoe1xcbiAgICAgICAgICAgIFxcXCJuYW1lXFxcIjogZ2V0UGFnZVRpdGxlKCksXFxuICAgICAgICAgICAgXFxcImZyb21cXFwiOiBmcm9tLmpvaW4oJyQkJCcpLFxcbiAgICAgICAgICAgIFxcXCJ1cmxcXFwiOiBwbGF5bC5yZXBsYWNlKC9cXFxcJi9nLCAn77yG77yGJyksXFxuICAgICAgICAgICAgXFxcImNvbnRlbnRcXFwiOiBNWV9SVUxFLnRpdGxlXFxuICAgICAgICB9KTtcXG4gICAgICAgIC8vbG9nKHB1c2gpO1xcbiAgICAgICAgXFxuICAgICAgICB2YXIgdGNvbmZpZz17XFxuICAgICAgICAgICAgbmFtZTpnZXRQYWdlVGl0bGUoKSxcXG4gICAgICAgICAgICBjb250ZW50Ok1ZX1JVTEUudGl0bGVcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGQyLnVuc2hpZnQoe1xcbiAgICAgICAgICAgIHRpdGxlOiBcXFwi5o6o6YCB5pys6aG1PT5UVkJveFxcXCIsXFxuICAgICAgICAgICAgdXJsOiAkKHB1c2gpLmxhenlSdWxlKCh0Y29uZmlnKSA9PiB7XFxuICAgICAgICAgICAgICAgIHZhciBkbGlzdCA9IHN0b3JhZ2UwLmdldE15VmFyKFxcXCJkdW9zZWxlY3RcXFwiKTtcXG4gICAgICAgICAgICAgICAgaWYoZGxpc3QubGVuZ3RoPjApe1xcbiAgICAgICAgICAgICAgICB2YXIgcGxheXM9ZGxpc3QubWFwKHg9PngudGl0bGUrXFxcIiRcXFwiK3gudXJsKS5qb2luKFxcXCIjXFxcIik7XFxuICAgICAgICAgICAgICAgIHZhciBkcHVzaCA9IEpTT04uc3RyaW5naWZ5KHtcXG4gICAgICAgICAgICAgICAgICAgIFxcXCJuYW1lXFxcIjogdGNvbmZpZy5uYW1lLFxcbiAgICAgICAgICAgICAgICAgICAgXFxcImZyb21cXFwiOiBcXFwi5pKt5pS+5YiX6KGoXFxcIixcXG4gICAgICAgICAgICAgICAgICAgIFxcXCJ1cmxcXFwiOiBwbGF5cyxcXG4gICAgICAgICAgICAgICAgICAgIFxcXCJjb250ZW50XFxcIjogdGNvbmZpZy5jb250ZW50XFxuICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgIC8vbG9nKGRwdXNoKVxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vcGFnZS9wdXNoP3B1c2h1cmw9JyArIGVuY29kZVVSSUNvbXBvbmVudChkcHVzaCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9wYWdlL3B1c2g/cHVzaHVybD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGlucHV0KTtcXG4gICAgICAgICAgICB9LHRjb25maWcpLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwic2Nyb2xsX2J1dHRvblxcXCIsXFxuICAgICAgICAgICAgZXh0cmE6e1xcbiAgICAgICAgICAgICAgICBpZDoncHVzaHMnLFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgICAgXFxuICAgICAgICBcXG4gICAgICAgIGQyLnVuc2hpZnQoe1xcbiAgICB0aXRsZTogJ+mAieaOqCcsXFxuICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbicsXFxuICAgIHVybDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoKSA9PiB7XFxuICAgICAgICBzZXRJdGVtKCd3ZWJwdXNoJywnMCcpO1xcbiAgICAgICAgXFxuICAgICAgICB1cGRhdGVJdGVtKCdzcHVzaCcsIHtcXG4gICAgICAgICAgICB0aXRsZTogJ+WNleaOqCcsXFxuICAgICAgICB9KTtcXG4gICAgICAgIFxcbiAgICAgICAgaWYgKGZpbmRJdGVtKCdkc2VsZWN0JykuZXh0cmEubW9kZSA9PSAnb3BlbicpIHtcXG4gICAgICAgICAgICB0b2FzdCgn6YCJ5o6o5qih5byP5YWz6ZetJyk7XFxuICAgICAgICAgICAgc3RvcmFnZTAucHV0TXlWYXIoXFxcImR1b3NlbGVjdFxcXCIsIFtdKTtcXG4gICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcbiAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCI7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBsZXQgSWRzID0gKGZpbmRJdGVtc0J5Q2xzKCdwbGF5cycpKS5tYXAoaXQgPT4gaXQuZXh0cmEuaWQpO1xcbiAgICAgICAgSWRzLmZvckVhY2goeCA9PiB7XFxuICAgICAgICAgICAgdmFyIHRpdGxlID0gZmluZEl0ZW0oeCkudGl0bGU7XFxuXFxuICAgICAgICAgICAgdXBkYXRlSXRlbSh4LCB7XFxuICAgICAgICAgICAgICAgIHVybDogJC5tc20odGl0bGUsIHgpLFxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfSk7XFxuICAgICAgICB2YXIgdGl0bGUgPSBmaW5kSXRlbSgnZHNlbGVjdCcpLnRpdGxlO1xcbiAgICAgICAgdXBkYXRlSXRlbSgnZHNlbGVjdCcsIHtcXG4gICAgICAgICAgICB0aXRsZTogYOKAnOKAnOKAneKAnTxzcGFuIHN0eWxlPVxcXCJjb2xvcjojNDY4MkI0XFxcIj5gICsgdGl0bGUsXFxuICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgbW9kZTogJ29wZW4nXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgICBcXG4gICAgICAgIHVwZGF0ZUl0ZW0oJ3B1c2hzJywge1xcbiAgICAgICAgICAgIHRpdGxlOiAn5o6o6YCB6YCJ5LitPT5UVkJveCcsXFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIHRvYXN0KCfpgInmjqjmqKHlvI/lvIDlkK8nKVxcbiAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL2VtcHR5XFxcIjtcXG4gICAgICAgICAgICB9KSxcXG4gICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgaWQ6ICdkc2VsZWN0JyxcXG4gICAgICAgICdtb2RlJzogJ2Nsb3NlJ1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pXFxuXFxuXFxuICAgICAgICBkMi51bnNoaWZ0KHtcXG4gICAgICAgICAgICB0aXRsZTogKGdldEl0ZW0oJ3dlYnB1c2gnLCAnMCcpID09ICcxJyA/ICfigJzigJzigJ3igJ08Zm9udCBjb2xvcj1cXFwiIzAwRkYwMFxcXCI+5Y2V5o6oPC9mb250PicgOiAn5Y2V5o6oJyksXFxuICAgICAgICAgICAgdXJsOiBgaGlrZXI6Ly9lbXB0eUBsYXp5UnVsZT0uanM6Z2V0SXRlbSgnd2VicHVzaCcsJzAnKT09JzEnP3NldEl0ZW0oJ3dlYnB1c2gnLCcwJyk6c2V0SXRlbSgnd2VicHVzaCcsJzEnKTtyZWZyZXNoUGFnZSgpOyd0b2FzdDovL+WIh+aNouaIkOWKn++8gSdgLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbicsXFxuICAgICAgICAgICAgZXh0cmE6e1xcbiAgICAgICAgICAgICAgICBpZDonc3B1c2gnLFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcblxcbiAgICAgICAgZDIuc3BsaWNlKDMsIDAsIHtcXG4gICAgICAgICAgICB0aXRsZTogcGFyc2V0eXBlW3BhcnNlSW50KHdlYildLnNwbGl0KCc6JylbMF0sXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJyxcXG4gICAgICAgICAgICB1cmw6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKGluZikgPT4ge1xcbiAgICAgICAgICAgICAgICBpZiAoZ2V0SXRlbSgnd2VicHVzaCcsICcwJykgPT0gJzEnfHxmaW5kSXRlbSgnZHNlbGVjdCcpLmV4dHJhLm1vZGUgPT0gJ29wZW4nKSB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5Y2V5o6ofOmAieaOqOaooeW8j+W8gOWQr+aXoOazleS/ruaUuSdcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBsZXQgYWxsX2NvbHMgPSBpbmZcXG4gICAgICAgICAgICAgICAgbGV0IGNvbCA9IHN0b3JhZ2UwLmdldEl0ZW0oJ+WXheaOoicsICdXZWLll4XmjqInKTtcXG4gICAgICAgICAgICAgICAgbGV0IOWXheaOoiA9IGFsbF9jb2xzLm1hcCgoaXQpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdC5zcGxpdCgnOicpWzBdID09PSBjb2wgPyAn4p6h77iPJyArIGl0IDogaXQ7XFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICBsZXQgdGlwcyA9ICfor7fpgInmi6nll4XmjqLmqKHlvI8nO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gJCjll4XmjqIsIDEsIHRpcHMpLnNlbGVjdCgoKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL+Keoe+4jy9nLCAnJyk7XFxuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlMC5zZXRJdGVtKCfll4XmjqInLCBpbnB1dC5zcGxpdCgnOicpWzBdKTtcXG4gICAgICAgICAgICAgICAgICAgIHZhciBtb2RlID0gaW5wdXQuc3BsaXQoJzonKVsxXVxcbiAgICAgICAgICAgICAgICAgICAgc3RvcmFnZTAuc2V0SXRlbSgnd2ViJywgbW9kZSlcXG4gICAgICAgICAgICAgICAgICAgIGxldCBvbGRJZHMgPSAoZmluZEl0ZW1zQnlDbHMoJ3BsYXlzJykpLm1hcChpdCA9PiBpdC5leHRyYS5pZCk7XFxuICAgICAgICAgICAgICAgICAgICBvbGRJZHMuZm9yRWFjaCh4ID0+IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZSA9PSAnMCcpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlSXRlbSh4LCB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IFxcXCJ3ZWJSdWxlOi8vXFxcIiArIHggKyBcXFwiQFxcXCIgKyAkLmx3ZWIoJzAnKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNMb2FkaW5nSW5qZWN0OiB0cnVlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB4LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsczogJ3BsYXlzJyxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja1J1bGVzOiBbJy5tNGEnLCAnLm1wMycsICcuZmx2JywgJy5hdmknLCAnLjNncCcsICcubXBlZycsICcud212JywgJy5tb3YnLCAnLnJtdmInLCAnLmdpZicsICcuanBlZycsICcucG5nJywgJy5pY28nLCAnLnN2ZyddXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZSA9PSAnMScpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlSXRlbSh4LCB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IFxcXCJ2aWRlbzovL1xcXCIgKyB4LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogeCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbHM6ICdwbGF5cycsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZSA9PSAnMicpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlSXRlbSh4LCB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHggKyAkKCcnKS5sYXp5UnVsZSgoKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2xhenlUb1g1P3J1bGU9ZG3nm5LlrZAnKS52aWRlb1g1KCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHgsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xzOiAncGxheXMnLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlSXRlbSgncGFyc2UnLCB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHN0b3JhZ2UwLmdldEl0ZW0oJ+WXheaOoicsICdXZWLll4XmjqInKSxcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+W3suWIh+WXheaOouaWueW8j+S4ujonICsgaW5wdXQ7XFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgICAgICAgICAgfSwgcGFyc2V0eXBlKSxcXG4gICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICBpZDogJ3BhcnNlJyxcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIGQyLnVuc2hpZnQoe1xcbiAgICAgICAgICAgIHRpdGxlOiAn4oCc4oCc4oCd4oCdPHNtYWxsPuKaoe+4jycgKyBkdXJsICsgJzwvc21hbGw+JyxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ3RleHRfY2VudGVyXzEnLFxcbiAgICAgICAgICAgIHVybDogZHVybCxcXG4gICAgICAgIH0pO1xcbiAgICAgICAgXFxuICAgICAgICBcXG4gICAgICAgIGlmKE1ZX1BBUkFNUy53ZWI9PVxcXCLlk5Tmu7TlvbHop4ZcXFwiKXtcXG4gICAgICAgICAgICBkMi51bnNoaWZ0KHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6J+WTlOa7tOW9seinhicsXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMScsXFxuICAgICAgICAgICAgICAgIHVybDpcXFwiaGlrZXI6Ly9wYWdlL2RldGFpbHM/cnVsZT3lk5TlmIDlvbHop4YmdXJsPVxcXCIgKyBkdXJsKycjaW1tZXJzaXZlVGhlbWUjJyxcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgICAgIHZhciBqc3I9SlNPTi5wYXJzZShmZXRjaChcXFwiaGlrZXI6Ly9ob21lQOWTlOWYgOW9seinhlxcXCIpKS5wcmVSdWxlXFxuICAgICAgICAgICAgZXZhbChqc3IpXFxuICAgICAgICB9XFxuICAgICAgICBcXG4gICAgICAgIFxcbiAgICAgICAgXFxuICAgICAgICB2YXIgZDMgPSBbXTtcXG5pZiAoZ2V0SXRlbSgnYWknLCAnMCcpID09ICcxJykge1xcblxcbiAgICBkMy5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBnZXRQYWdlVGl0bGUoKSxcXG4gICAgICAgIGltZzogJ2h0dHBzOi8vcGljMy41OGNkbi5jb20uY24vbm93YXRlci93ZWJpbS9iaWcvbl92MjgxZDYwYmQxMjdlODRjZDI4ODA3ZDUxMTQzZWFhNjFmLmdpZicsXFxuICAgICAgICBjb2xfdHlwZTogJ21vdmllXzFfdmVydGljYWxfcGljX2JsdXInLFxcbiAgICAgICAgZXh0cmE6e1xcbiAgICAgICAgICAgIGlkOidkMycsXFxuICAgICAgICB9XFxuICAgIH0pXFxuICAgIHNldFJlc3VsdChkMylcXG59XFxuICAgICAgICBcXG4gICAgICAgIGlmKGZpbmRJdGVtKCdkMycpIT1udWxsKXtcXG4gICAgICAgICAgICBhZGRJdGVtQWZ0ZXIoJ2QzJywgZDIpO1xcbiAgICAgICAgfWVsc2V7XFxuICAgICAgICBzZXRSZXN1bHQoZDIpXFxuICAgICAgICB9XFxuICAgIH1cXG59XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLogZrlkIjmkJzntKJcIixcInBhdGhcIjpcInByb1wiLFwicnVsZVwiOlwidmFyIGQgPSBbXTtcXG5cXG52YXIgZ2V0UmFuZ2VDb2xvcnMgPSBmdW5jdGlvbigpIHvCoMKgwqDCoMKgwqDCoFxcbiAgICByZXR1cm4gJyMnICsgKCcwMDAwMCcgKyAoTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMCA8PCAwKS50b1N0cmluZygxNikpLnN1YnN0cigtNik7wqDCoMKgwqDCoFxcbn1cXG5cXG52YXIgaW1ncyA9IFsnaHR0cHM6Ly93d3cud2FuZG91LnByby9mYXZpY29uLmljbycsICdodHRwczovL2JqLmJjZWJvcy5jb20vYmFpZHUtcm1iLXZpZGVvLWNvdmVyLTEvNzRmMTNkMDYyMGY3MmIwMGE0ZTliNjdmM2RhYjk2ZDEucG5nJywgJ2h0dHBzOi8vYmouYmNlYm9zLmNvbS9iYWlkdS1ybWItdmlkZW8tY292ZXItMS83M2I4Y2Y2YWUwNzgzMDNhNTcyZTc2Yzc5ZGQ5M2U3YS5wbmcnLCAnaHR0cHM6Ly9tLnFtdHYuYXBwL2Zhdmljb24ucG5nJywgJ2h0dHBzOi8vd3d3LnRic2R5LmNvbS9yZXMvbXJzLzEvaW1nLzk4MzYzNS8yMDIyLzAxLzAxLzEwMS5qcGcnXVxcblxcbnZhciBuYW1lcz1bJ+ixjOixhicsICfojLbmna/ni5AnLCAn5pCc54mHJywgJ+mdkum6picsICflnJ/mi6jpvKAnXTtcXG5cXG5pZiAoTVlfUEFHRSA9PSAxKSB7XFxuICAgIG5hbWVzLm1hcCgoeCwgaSkgPT4ge1xcbiAgICAgICAgdmFyIGl4ID0gc3RvcmFnZTAuZ2V0TXlWYXIoJ3BhZ2VfaW5kZXgnLCAwKTtcXG4gICAgICAgIHZhciB0aXRsZSA9IGl4ID09IGkgPyBg4oCc4oCc4oCd4oCdPGZvbnQgY29sb3I9JHtnZXRSYW5nZUNvbG9ycygpfT5gICsgeCArICc8L2ZvbnQ+JyA6IHg7XFxuICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ2ljb25fNScsXFxuICAgICAgICAgICAgaW1nOiBpbWdzW2ldLFxcbiAgICAgICAgICAgIHVybDogJCgnJykubGF6eVJ1bGUoKGkpID0+IHtcXG4gICAgICAgICAgICAgICAgc3RvcmFnZTAucHV0TXlWYXIoJ3BhZ2VfaW5kZXgnLCBpKVxcbiAgICAgICAgICAgICAgICAvL2NsZWFyTXlWYXIoJ3NvdScpXFxuICAgICAgICAgICAgICAgIGNsZWFyTXlWYXIoJ3BhZ2UnKVxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpXFxuICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/liIfmjaLmiJDlip8nXFxuICAgICAgICAgICAgfSwgaSksXFxuICAgICAgICB9KVxcbiAgICB9KVxcblxcbiAgICB2YXIgd2ViID0gZ2V0SXRlbSgnd2ViJywgJzAnKVxcbiAgICAvL2xvZyh3ZWIpXFxuICAgIHZhciB0aXRsZSA9ICcnXFxuICAgIHN3aXRjaCAod2ViKSB7XFxuICAgICAgICBjYXNlICcwJzpcXG4gICAgICAgICAgICB0aXRsZSA9ICdXZWLll4XmjqInXFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICBjYXNlICcxJzpcXG4gICAgICAgICAgICB0aXRsZSA9ICfop4bpopHll4XmjqInXFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICBjYXNlICcyJzpcXG4gICAgICAgICAgICB0aXRsZSA9ICdkbeebkuWtkCdcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgfVxcbiAgICBzZXRJdGVtKCfll4XmjqInLCB0aXRsZSlcXG5cXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiAn5o6o6YCBJyxcXG4gICAgICAgIHVybDogXFxcImhpa2VyOi8vcGFnZS9zZXR0aW5nXFxcIixcXG4gICAgICAgIGNvbF90eXBlOiAnZmxleF9idXR0b24nXFxuICAgIH0sIHtcXG4gICAgICAgIHRpdGxlOiBcXFwi6aG16Z2i5Yqg6L29OlxcXCIgKyBnZXRJdGVtKCdob21lJywgJ+WFsycpLFxcbiAgICAgICAgdXJsOiAkKCcnKS5sYXp5UnVsZSgoKSA9PiB7XFxuICAgICAgICAgICAgaWYgKGdldEl0ZW0oJ2hvbWUnLCAn5YWzJykgPT0gJ+WFsycpIHtcXG4gICAgICAgICAgICAgICAgc2V0SXRlbSgnaG9tZScsICflvIAnKVxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHNldEl0ZW0oJ2hvbWUnLCAn5YWzJylcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKVxcbiAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXG4gICAgICAgIH0pLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJmbGV4X2J1dHRvblxcXCJcXG4gICAgfSwge1xcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxcbiAgICAgICAgdXJsOiAkKFxcXCIjbm9Mb2FkaW5nI1xcXCIpLmxhenlSdWxlKCgpID0+IHtcXG4gICAgICAgICAgICB2YXIgd2ViID0gZ2V0SXRlbSgnd2ViJywgJzAnKVxcbiAgICAgICAgICAgIHN3aXRjaCAod2ViKSB7XFxuICAgICAgICAgICAgICAgIGNhc2UgJzAnOlxcbiAgICAgICAgICAgICAgICAgICAgc2V0SXRlbSgnd2ViJywgJzEnKVxcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIGNhc2UgJzEnOlxcbiAgICAgICAgICAgICAgICAgICAgc2V0SXRlbSgnd2ViJywgJzInKVxcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIGNhc2UgJzInOlxcbiAgICAgICAgICAgICAgICAgICAgc2V0SXRlbSgnd2ViJywgJzAnKVxcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcbiAgICAgICAgfSksXFxuICAgICAgICBjb2xfdHlwZTogXFxcImZsZXhfYnV0dG9uXFxcIixcXG4gICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgaWQ6ICdwYXJzZXQnXFxuICAgICAgICB9XFxuICAgIH0sIHtcXG4gICAgICAgIHRpdGxlOiAn5qih5p2/OicgKyAoZ2V0SXRlbSgnYWknLCAnMCcpID09ICcwJyA/ICflhbPpl60nIDogJ+W8gOWQrycpLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJmbGV4X2J1dHRvblxcXCIsXFxuICAgICAgICB1cmw6ICQoJycpLmxhenlSdWxlKCgpID0+IHtcXG4gICAgICAgICAgICBpZiAoZ2V0SXRlbSgnYWknLCAnMCcpID09ICcwJykge1xcbiAgICAgICAgICAgICAgICBzZXRJdGVtKCdhaScsICcxJylcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBzZXRJdGVtKCdhaScsICcwJylcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxuICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcbiAgICAgICAgfSksXFxuICAgICAgICBjb2xfdHlwZTogJ2ZsZXhfYnV0dG9uJyxcXG4gICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgaWQ6ICdhaW1iJ1xcbiAgICAgICAgfVxcbiAgICB9KTtcXG59XFxuXFxuXFxuXFxuaWYgKE1ZX1BBR0UgPT0gMSkge1xcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6IFxcXCLmkJzntKJcXFwiLFxcbiAgICAgICAgdXJsOiAkLnRvU3RyaW5nKCgpID0+IHtcXG4gICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcbiAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCI7XFxuICAgICAgICB9KSxcXG4gICAgICAgIGNvbF90eXBlOiBcXFwiaW5wdXRcXFwiLFxcbiAgICAgICAgZGVzYzogXFxcIuivt+i+k+WFpeWFs+mUruivje+8jOWwvemHj+WwkeWtl+S4jeimgeWkmuWtl1xcXCIsXFxuICAgICAgICBwaWNfdXJsOiBcXFwiXFxcIixcXG4gICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBnZXRNeVZhcihcXFwic291XFxcIiwgXFxcIlxcXCIpLFxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiAkLnRvU3RyaW5nKCgpID0+IHtcXG4gICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcInNvdVxcXCIsIGlucHV0KTtcXG4gICAgICAgICAgICAgICAgY2xlYXJNeVZhcigncGFnZScpXFxuICAgICAgICAgICAgICAgIGNsZWFyTXlWYXIoXFxcImR1cmxcXFwiKVxcbiAgICAgICAgICAgIH0pXFxuICAgICAgICB9XFxuICAgIH0pO1xcbiAgICBhZGRMaXN0ZW5lcihcXFwib25DbG9zZVxcXCIsICQudG9TdHJpbmcoKCkgPT4ge1xcbiAgICAgICAgY2xlYXJNeVZhcihcXFwic291XFxcIik7XFxuICAgIH0pKTtcXG5cXG4gICAgYWRkTGlzdGVuZXIoXFxcIm9uUmVmcmVzaFxcXCIsICQudG9TdHJpbmcoKCkgPT4ge1xcbiAgICAgICAgY2xlYXJNeVZhcihcXFwic291XFxcIik7XFxuICAgICAgICBjbGVhck15VmFyKFxcXCJkdXJsXFxcIik7XFxuICAgIH0pKTtcXG59XFxuXFxubGV0IHMgPSBnZXRNeVZhcihcXFwic291XFxcIiwgXFxcIlxcXCIpO1xcbmxldCByID0gXFxcIlxcXCI7XFxuXFxudmFyIGluZGV4ID0gc3RvcmFnZTAuZ2V0TXlWYXIoJ3BhZ2VfaW5kZXgnLCAwKVxcblxcbnRyeSB7XFxuICAgIHN3aXRjaCAocGFyc2VJbnQoaW5kZXgpKSB7XFxuICAgICAgICBjYXNlIDA6XFxuICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS93YW5kb3UnKSkucnVsZSlcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgIGNhc2UgMTpcXG4gICAgICAgICAgICBldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL2N1cGZveCcpKS5ydWxlKVxcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgY2FzZSAyOlxcbiAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2Uvc291cGlhbicpKS5ydWxlKVxcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgY2FzZSAzOlxcbiAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvcWltYWl0dicpKS5ydWxlKVxcblxcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgY2FzZSA0OlxcbiAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvdGJzZHknKSkucnVsZSlcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgfVxcbn0gY2F0Y2goZSkge1xcbiAgICAvL3NldEl0ZW0oJ2hvbWUnLCAn5YWzJylcXG4gICAgbGV0IG5leHRpbmRleD0wO1xcbiAgICBpZihpbmRleD40KXtcXG4gICAgICAgIG5leHRpbmRleD0wO1xcbiAgICB9ZWxzZXtcXG4gICAgICAgIG5leHRpbmRleD1pbmRleCsxO1xcbiAgICB9XFxuICAgIHRvYXN0KG5hbWVzW2luZGV4XStg5Y+R55Sf6ZSZ6K+v77yM6ZSZ6K+v5L+h5oGvOiR7ZS5tZXNzYWdlfWApO1xcbiAgICBsb2cobmFtZXNbaW5kZXhdK2Dlj5HnlJ/plJnor6/vvIzplJnor6/kv6Hmga86JHtlLm1lc3NhZ2V9YCk7XFxuICAgIHN0b3JhZ2UwLnB1dE15VmFyKCdwYWdlX2luZGV4JywgbmV4dGluZGV4KTtcXG4gICAgcmVmcmVzaFBhZ2UoKTtcXG59XFxuXFxuXFxuc2V0UmVzdWx0KGQpO1wifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwi5bel5YW3XCIsXCJwYXRoXCI6XCJ0b29sXCIsXCJydWxlXCI6XCJmdW5jdGlvbiB3cmFwKHRleHQsIHMpIHtcXG4gICAgcmV0dXJuIHRleHQuaW5jbHVkZXMoXFxcIuKAnOKAnOKAneKAnVxcXCIpID8gdGV4dCA6IFxcXCLigJzigJzigJ3igJ1cXFwiICsgdGV4dC5yZXBsYWNlKG5ldyBSZWdFeHAoXFxcIjxlbT58PC9lbT5cXFwiLCBcXFwiZ1xcXCIpLCBcXFwiXFxcIikucmVwbGFjZShuZXcgUmVnRXhwKHMsIFxcXCJnXFxcIiksIFxcXCI8c3Ryb25nPjxzcGFuIHN0eWxlPVxcXFxcXFwiY29sb3I6ICMxRTkwRkZcXFxcXFxcIj5cXFwiICsgcyArIFxcXCI8L3NwYW4+PC9zdHJvbmc+XFxcIilcXG59XFxuXFxuZnVuY3Rpb24gd3JhcDEodGV4dCwgcykge1xcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKG5ldyBSZWdFeHAoXFxcIjxlbT58PC9lbT5cXFwiLCBcXFwiZ1xcXCIpLCBcXFwiXFxcIikucmVwbGFjZShuZXcgUmVnRXhwKHMsIFxcXCJnXFxcIiksIFxcXCI8c3Ryb25nPjxzcGFuIHN0eWxlPVxcXFxcXFwiY29sb3I6ICMxRTkwRkZcXFxcXFxcIj5cXFwiICsgcyArIFxcXCI8L3NwYW4+PC9zdHJvbmc+XFxcIilcXG59XFxuXFxuZnVuY3Rpb24gcmVtb3ZlaHRtbCh0ZXh0KSB7XFxuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoLzxbXjxdKz8+L2csICcnKVxcbn1cXG5cXG5mdW5jdGlvbiBtZXJnZSh0ZXh0LCBzLCBtKSB7XFxuICAgIGlmIChtID09IDApIHtcXG4gICAgICAgIHRleHQgPSAn4oCc4oCc4oCd4oCdJyArIHRleHQgKyAnLScgKyBcXFwiPHN0cm9uZz48c3BhbiBzdHlsZT1cXFxcXFxcImNvbG9yOiAjRkY1NzMzXFxcXFxcXCI+XFxcIiArIHMgKyBcXFwiPC9zcGFuPjwvc3Ryb25nPlxcXCJcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHRleHQgPSB0ZXh0ICsgJy0nICsgXFxcIjxzdHJvbmc+PHNwYW4gc3R5bGU9XFxcXFxcXCJjb2xvcjogI0ZGNTczM1xcXFxcXFwiPlxcXCIgKyBzICsgXFxcIjwvc3Bhbj48L3N0cm9uZz5cXFwiXFxuICAgIH1cXG4gICAgcmV0dXJuIHRleHRcXG59XFxuXFxuZnVuY3Rpb24gc2V0UGFnZUQoZCwgcGFnZSwgdGl0bGVzLCBjb2xvcikge1xcbiAgICB2YXIgcGFnZWQgPSBnZXRNeVZhcihcXFwicGFnZWRcXFwiLCBcXFwiMFxcXCIpO1xcbiAgICB0aXRsZXMubWFwKCh4LCBpKSA9PiB7XFxuICAgICAgICB2YXIgdGl0bGUgPSBOdW1iZXIocGFnZWQpID09IGkgPyBcXFwi4oCc4oCc4oCd4oCdPGI+PGZvbnQgY29sb3I9XFxcIiArIGNvbG9yICsgXFxcIj5cXFwiICsgeCArIFxcXCI8L2ZvbnQ+PC9iPlxcXCIgOiBgJHt4fWA7XFxuICAgICAgICBpZiAocGFnZSA9PSAxKSB7XFxuICAgICAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogJ3RleHRfMicsXFxuICAgICAgICAgICAgICAgIHVybDogaSArICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKCkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcInBhZ2VkXFxcIiwgaW5wdXQpO1xcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXG4gICAgICAgICAgICAgICAgfSksXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgIH1cXG4gICAgfSlcXG4gICAgcmV0dXJuIGdldE15VmFyKFxcXCJwYWdlZFxcXCIsIFxcXCIwXFxcIilcXG59XFxuXFxuXFxuJC5leHBvcnRzID0ge1xcbiAgICB3cmFwOiB3cmFwLFxcbiAgICB3cmFwMTogd3JhcDEsXFxuICAgIHJlaHRtbDogcmVtb3ZlaHRtbCxcXG4gICAgbWVyZ2U6IG1lcmdlLFxcbiAgICBzZXRwYWdlZDogc2V0UGFnZURcXG59XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLmkJzntKLpobXpnaJcIixcInBhdGhcIjpcInNvdXBcIixcInJ1bGVcIjpcImpzOlxcbnZhciBkID0gW107XFxuaWYgKE1ZX1BBUkFNUy5rZXkgJiYgZ2V0TXlWYXIoXFxcInVzZVxcXCIsIFxcXCJcXFwiKSA9PSBcXFwiXFxcIikge1xcbiAgICBwdXRNeVZhcihcXFwic291XFxcIiwgTVlfUEFSQU1TLmtleSk7XFxuICAgIHB1dE15VmFyKFxcXCJ1c2VcXFwiLCBcXFwiMVxcXCIpO1xcbiAgICBhZGRMaXN0ZW5lcihcXFwib25DbG9zZVxcXCIsICQudG9TdHJpbmcoKCkgPT4ge1xcbiAgICAgICAgY2xlYXJNeVZhcihcXFwidXNlXFxcIik7XFxuICAgIH0pKTtcXG59XFxuJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvcHJvJylcIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIng1XCIsXCJwYXRoXCI6XCJ4NVwiLFwicnVsZVwiOlwianM6XFxudmFyIGQgPSBbXTtcXG5sZXQgdXJsID0gYmFzZTY0RGVjb2RlKGdldFBhcmFtKFxcXCJ1XFxcIikpO1xcbmQucHVzaCh7XFxuICAgIHRpdGxlOiBcXFwiXFxcIixcXG4gICAgdXJsOiB1cmwsXFxuICAgIGNvbF90eXBlOiBcXFwieDVfd2Vidmlld19zaW5nbGVcXFwiLFxcbiAgICBkZXNjOiBcXFwiZmxvYXQmJjEwMCVcXFwiLFxcbiAgICBwaWNfdXJsOiBcXFwiXFxcIixcXG4gICAgZXh0cmE6IHtcXG4gICAgICAgIGZsb2F0VmlkZW86IHRydWUsXFxuICAgICAgICBjYW5CYWNrOiB0cnVlLFxcbiAgICAgICAgYmxvY2tSdWxlczogW1xcXCIuZ2lmXFxcIiwgXFxcIi9hZC9cXFwiLCBcXFwiZ29vZ2xlXFxcIiwgXFxcIi9zaC90by9cXFwiLCBcXFwiLkdJRlxcXCJdXFxuICAgIH1cXG59KTtcXG5zZXRSZXN1bHQoZCk7XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCIzLuaQnOeJh1wiLFwicGF0aFwiOlwic291cGlhblwiLFwicnVsZVwiOlwianM6XFxuaWYgKHMgIT0gXFxcIlxcXCIpIHtcXG4gICAgdmFyIGh0bWwgPSBmZXRjaChgaHR0cDovL3NvdXBpYW4uZGUvc2VhcmNoP2tleT0ke3N9YClcXG4gICAgdmFyIGxpc3QgPSBwZGZhKGh0bWwsICdib2R5JiYubGlzdC1yb3ctaW5mbycpXFxuICAgIGxldCB7XFxuICAgICAgICB3cmFwMVxcbiAgICB9ID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvdG9vbFxcXCIpO1xcbiAgICBmb3IgKGxldCBpdCBvZiBsaXN0KSB7XFxuICAgICAgICAvL2xvZyhpdClcXG4gICAgICAgIC8vbGV0IG5hbWUgPSBpdC5tb3ZpZV9uYW1lO1xcbiAgICAgICAgbGV0IG5hbWUgPSBwZGZoKGl0LCAnaDQmJlRleHQnKTtcXG4gICAgICAgIGxldCB3ZWIgPSBwZGZoKGl0LCAnYSYmdGl0bGUnKS5yZXBsYWNlKG5hbWUsJycpLnRyaW0oKTtcXG4gICAgICAgIFxcbiAgICAgICAgbGV0IGltZyA9IHBkZmgoaXQsICdpbWcmJnNyYycpO1xcbiAgICAgICAgbGV0IHVybCA9IHBkZmgoaXQsICdhJiZocmVmJyk7XFxuICAgICAgICB2YXIgdSA9IFxcXCJoaWtlcjovL3BhZ2UvcD9ydWxlPVxcXCIgKyBNWV9SVUxFLnRpdGxlICsgXFxcIiZ1PVxcXCIgKyBiYXNlNjRFbmNvZGUodXJsKVxcbiAgICAgICAgdSA9IGdldEl0ZW0oJ2FpJywgJzAnKSA9PSAnMCcgPyB1IDogdSArICcjaW1tZXJzaXZlVGhlbWUjJ1xcbiAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogd3JhcDEod2ViKyctJytuYW1lLCBzKSxcXG4gICAgICAgICAgICB1cmw6IHUsXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJhdmF0YXJcXFwiLFxcbiAgICAgICAgICAgIC8vZGVzYzogXFxcIuKAnOKAnOKAneKAnTxmb250IGNvbG9yPSNmMTNiNjZhPuaQnOeJhzwvZm9udD5cXFwiLFxcbiAgICAgICAgICAgIHBpY191cmw6IGltZyxcXG4gICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICBpZDogdXJsLFxcbiAgICAgICAgICAgICAgICBpbmhlcml0VGl0bGU6IGZhbHNlLFxcbiAgICAgICAgICAgICAgICBwYWdlVGl0bGU6bmFtZSxcXG4gICAgICAgICAgICAgICAgd2ViOndlYixcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgfVxcbiAgICBzZXRSZXN1bHQoZClcXG59IGVsc2Uge1xcblxcbn1cXG5cXG5pZiAoZ2V0SXRlbSgnaG9tZScsICflhbMnKSA9PSAn5byAJykge1xcbiAgICB2YXIgaHRtbCA9IHJlcXVlc3QoJ2h0dHA6Ly9zb3VwaWFuLmRlLycsIHt9KVxcblxcblxcbiAgICBmdW5jdGlvbiBzZXRMaXN0cyhpdGVtKSB7XFxuICAgICAgICB2YXIgdGl0bGUgPSBpdGVtLnNwbGl0KCctJylbMF1cXG4gICAgICAgIHZhciB0ID0gaXRlbS5zcGxpdCgnLScpWzFdXFxuICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ2F2YXRhcicsXFxuICAgICAgICAgICAgaW1nOiAnaHR0cHM6Ly9sYW5tZWlndW9qaWFuZy5jb20vdHViaWFvL21vcmUvMTAucG5nJ1xcbiAgICAgICAgfSlcXG5cXG4gICAgICAgIHZhciBsaXN0ID0gcGRmYShodG1sLCBgYm9keSYmLmxpc3QtaGVhZGVyOm1hdGNoZXMoJHt0fSkrKiYmYWApXFxuXFxuICAgICAgICBsaXN0Lm1hcCh4ID0+IHtcXG4gICAgICAgICAgICB2YXIgbmFtZSA9IHBkZmgoeCwgJy5wb3N0ZXItaXRlbS10aXRsZSYmVGV4dCcpXFxuICAgICAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IG5hbWUsXFxuICAgICAgICAgICAgICAgIGltZzogcGRmaCh4LCAnaW1nJiZzcmMnKSxcXG4gICAgICAgICAgICAgICAgdXJsOiAkKCcnKS5sYXp5UnVsZSgobikgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcInNvdVxcXCIsIG4pXFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgICAgICAgICAgICAgIH0sIG5hbWUpXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgIH0pXFxuICAgIH1cXG5cXG4gICAgWyfng63pl6jnlLXlvbEt55S15b2xJywgJ+eDremXqOeUteinhuWJpy3nlLXop4bliacnLCAn54Ot6Zeo57u86Im6Lee7vOiJuicsICfng63pl6jliqjmvKst5Yqo5ryrJ10ubWFwKHggPT4ge1xcbiAgICAgICAgc2V0TGlzdHMoeClcXG4gICAgfSlcXG5cXG59XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCIxLuixjOixhlwiLFwicGF0aFwiOlwid2FuZG91XCIsXCJydWxlXCI6XCJqczpcXG5sZXQgZHVybCA9IGdldE15VmFyKFxcXCJkdXJsXFxcIiwgXFxcIlxcXCIpO1xcbmlmIChkdXJsICE9ICcnKSB7XFxuXFxuICAgIGR1cmwgPSAnaHR0cHM6Ly93d3cud2FuZG91LnBybycgKyBkdXJsLnJlcGxhY2UoJy5odG1sJywgJycpXFxuICAgIGxldCB1cmwgPSBkdXJsO1xcbiAgICBsZXQgaWQgPSB1cmw7XFxuICAgIGxldCBodG1sID0gZmV0Y2godXJsKTtcXG4gICAgdmFyIHJ1bGUgPSBNWV9SVUxFLnRpdGxlXFxuICAgIHZhciBuYW1lID0gcGRmaChodG1sLCAnLm1vdmllLWNvbnRlbnQmJnAmJlRleHQnKTtcXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBuYW1lLFxcbiAgICAgICAgaW1nOiBwZGZoKGh0bWwsICcubW92aWUtaW1nJiZpbWcmJnNyYycpLFxcbiAgICAgICAgY29sX3R5cGU6ICdtb3ZpZV8xX3ZlcnRpY2FsX3BpYycsXFxuICAgICAgICBkZXNjOiBwZGZoKGh0bWwsICcuYm90dG9tJiZwJiZUZXh0JyksXFxuICAgICAgICB1cmw6ICdoaWtlcjovL3BhZ2UveDU/dT0nICsgYmFzZTY0RW5jb2RlKHVybCksXFxuICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgIGlkOiB1cmwsXFxuICAgICAgICAgICAgaW5oZXJpdFRpdGxlOiBmYWxzZVxcbiAgICAgICAgfVxcbiAgICB9KVxcbiAgICAvL3NldFJlc3VsdChkKTtcXG5cXG4gICAgbGV0IHRleHQgPSBwZGZoKGh0bWwsIFxcXCJib2R5JiYjX19ORVhUX0RBVEFfXyYmSHRtbFxcXCIpO1xcbiAgICAvL2xvZyh0ZXh0KTtcXG4gICAgbGV0IGVyamkgPSBKU09OLnBhcnNlKHRleHQpO1xcbiAgICAvLyBsb2coZXJqaSk7XFxuICAgIGxldCBsaXN0ID0gZXJqaS5wcm9wcy5wYWdlUHJvcHMuZGF0YS5wbGF5RGF0YTtcXG5cXG4gICAgaWYgKGxpc3QgJiYgbGlzdC5sZW5ndGggPiAwKSB7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIE1ZX1VSTCA9IFxcXCJcXFwiO1xcbiAgICAgICAgICAgIGxldCB7XFxuICAgICAgICAgICAgICAgIHdyYXBcXG4gICAgICAgICAgICB9ID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvdG9vbD9ydWxlPVxcXCIgKyBydWxlKTtcXG4gICAgICAgICAgICBsaXN0ID0gbGlzdC5tYXAoaXQgPT4ge1xcbiAgICAgICAgICAgICAgICBsZXQgdSA9IGl0LmRhdGFfdXJsO1xcbiAgICAgICAgICAgICAgICB1ID0gXFxcImhpa2VyOi8vcGFnZS9wP3J1bGU9XFxcIiArIHJ1bGUgKyBcXFwiJnU9XFxcIiArIGJhc2U2NEVuY29kZSh1KTtcXG4gICAgICAgICAgICAgICAgdSA9IGdldEl0ZW0oJ2FpJywgJzAnKSA9PSAnMCcgPyB1IDogdSArICcjaW1tZXJzaXZlVGhlbWUjJ1xcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGl0LnNpdGVfbmFtZSxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogdSxcXG4gICAgICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwiYXZhdGFyXFxcIixcXG4gICAgICAgICAgICAgICAgICAgIGltZzogaXQuc2l0ZV9pY29uLFxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmhlcml0VGl0bGU6IGZhbHNlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB1LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb206ICdob21lJyxcXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlVGl0bGU6IG5hbWUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgd2ViOiBpdC5zaXRlX25hbWUsXFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBpZiAoTVlfUEFHRSA9PSAxKSB7XFxuICAgICAgICAgICAgICAgIC8vYWRkSXRlbUFmdGVyKGlkLCBsaXN0KTtcXG4gICAgICAgICAgICAgICAgZCA9IGQuY29uY2F0KGxpc3QpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgICBsb2coZS50b1N0cmluZygpKTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBzZXRSZXN1bHQoZClcXG59XFxuXFxubGV0IHIgPSBcXFwiXFxcIjtcXG5pZiAocyAhPSBcXFwiXFxcIikge1xcblxcbiAgICBqc29uID0gXFxcImh0dHBzOi8vYXBpLnhpYW1tLmNjOjk4OTcvbW92aWUvZ2V0c2VhcmNobGlzdC9rZXl3b3Jkcy9cXFwiICsgcyArIFxcXCIvcGFnZS8xL3Jvd3MvMTYuanNvblxcXCI7XFxuICAgIGRhdGEgPSBKU09OLnBhcnNlKGZldGNoKGpzb24pKS5kYXRhO1xcbiAgICBsZXQge1xcbiAgICAgICAgd3JhcFxcbiAgICB9ID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvdG9vbFxcXCIpO1xcbiAgICBmb3IgKGxldCBpdCBvZiBkYXRhKSB7XFxuICAgICAgICBsZXQgbmFtZSA9IGl0Lm1vdmllX25hbWU7XFxuICAgICAgICAvL2xvZyhuYW1lKVxcbiAgICAgICAgbGV0IGltZyA9IGl0Lm1vdmllX2ltZ191cmw7XFxuICAgICAgICBsZXQgdXJsID0gXFxcImh0dHBzOi8vd3d3LndhbmRvdS5wcm9cXFwiICsgaXQubW92aWVfdXJsLnJlcGxhY2UoXFxcIi5odG1sXFxcIiwgXFxcIlxcXCIpO1xcbiAgICAgICAgLy9sb2codXJsKVxcbiAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogd3JhcChuYW1lLCBzKSxcXG4gICAgICAgICAgICB1cmw6ICQodXJsKS5sYXp5UnVsZSgocnVsZSwgaWQsIHMsIG5hbWUpID0+IHtcXG4gICAgICAgICAgICAgICAgdmFyIGNscyA9IGZpbmRJdGVtc0J5Q2xzKGlkKTtcXG4gICAgICAgICAgICAgICAgaWYgKCEhY2xzKSB7XFxuICAgICAgICAgICAgICAgICAgICBkZWxldGVJdGVtQnlDbHMoaWQpXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICBsZXQgdXJsID0gaW5wdXQ7XFxuICAgICAgICAgICAgICAgICAgICBsZXQgaWQgPSB1cmw7XFxuICAgICAgICAgICAgICAgICAgICBsZXQgaHRtbCA9IGZldGNoKHVybCk7XFxuICAgICAgICAgICAgICAgICAgICAvL2xvZyhodG1sKVxcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRleHQgPSBwZGZoKGh0bWwsIFxcXCJib2R5JiYjX19ORVhUX0RBVEFfXyYmSHRtbFxcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgLy9sb2codGV4dCk7XFxuICAgICAgICAgICAgICAgICAgICBsZXQgZXJqaSA9IEpTT04ucGFyc2UodGV4dCk7XFxuICAgICAgICAgICAgICAgICAgICAvL2xvZyhlcmppKTtcXG4gICAgICAgICAgICAgICAgICAgIGxldCBsaXN0ID0gZXJqaS5wcm9wcy5wYWdlUHJvcHMuZGF0YS5wbGF5RGF0YTtcXG5cXG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ICYmIGxpc3QubGVuZ3RoID4gMCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1ZX1VSTCA9IFxcXCJcXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JhcFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvdG9vbD9ydWxlPVxcXCIgKyBydWxlKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdCA9IGxpc3QubWFwKGl0ID0+IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB1ID0gaXQuZGF0YV91cmw7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ID0gXFxcImhpa2VyOi8vcGFnZS9wP3J1bGU9XFxcIiArIHJ1bGUgKyBcXFwiJnU9XFxcIiArIGJhc2U2NEVuY29kZSh1KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUgPSBnZXRJdGVtKCdhaScsICcwJykgPT0gJzAnID8gdSA6IHUgKyAnI2ltbWVyc2l2ZVRoZW1lIydcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGl0LnNpdGVfbmFtZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJhdmF0YXJcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltZzogaXQuc2l0ZV9pY29uLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaGVyaXRUaXRsZTogZmFsc2UsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsczogaWQsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb206ICdob21lJyxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVRpdGxlOiBuYW1lLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWI6IGl0LnNpdGVfbmFtZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRJdGVtQWZ0ZXIoaWQsIGxpc3QpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nKGUudG9TdHJpbmcoKSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCJcXG4gICAgICAgICAgICB9LCBNWV9SVUxFLnRpdGxlLCB1cmwsIHMsIG5hbWUpLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwibW92aWVfMV9sZWZ0X3BpY1xcXCIsXFxuICAgICAgICAgICAgZGVzYzogXFxcIuKAnOKAnOKAneKAnTxmb250IGNvbG9yPSNmMTNiNjZhPuixjOixhjwvZm9udD5cXFwiLFxcbiAgICAgICAgICAgIHBpY191cmw6IGltZyxcXG4gICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICBpZDogdXJsLFxcbiAgICAgICAgICAgICAgICBpbmhlcml0VGl0bGU6IGZhbHNlXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgIH1cXG4gICAgc2V0UmVzdWx0KGQpXFxufVxcblxcblxcbmlmIChnZXRJdGVtKCdob21lJywgJ+WFsycpID09ICflvIAnKSB7XFxuICAgIHZhciBwYWdlID0gTVlfUEFHRTtcXG4gICAgbGV0IHtcXG4gICAgICAgIHNldHBhZ2VkXFxuICAgIH0gPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS90b29sXFxcIik7XFxuXFxuICAgIHZhciBwaW5kZXggPSBzZXRwYWdlZChkLHBhZ2UsIFtcXFwi6aaW6aG1XFxcIiwgXFxcIuWIhuexu1xcXCJdLCBcXFwiIzQ2ODJCNFxcXCIpO1xcblxcblxcbiAgICAvL+mmlumhtVxcbiAgICBpZiAocGluZGV4ID09IFxcXCIwXFxcIikge1xcblxcbiAgICAgICAgdmFyIGh0bWwgPSBmZXRjaCgnaHR0cHM6Ly93d3cud2FuZG91LnByby8nKVxcbiAgICAgICAgbGV0IGpzb24gPSBKU09OLnBhcnNlKHBkZmgoaHRtbCwgXFxcImJvZHkmJiNfX05FWFRfREFUQV9fJiZIdG1sXFxcIikpO1xcblxcbiAgICAgICAgZnVuY3Rpb24gc2V0TGlzdHMoaXRlbSkge1xcbiAgICAgICAgICAgIHZhciB0aXRsZSA9IGl0ZW0uc3BsaXQoJyMnKVswXVxcbiAgICAgICAgICAgIHZhciBrZXkgPSBpdGVtLnNwbGl0KCcjJylbMV1cXG4gICAgICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGUsXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiAnYXZhdGFyJyxcXG4gICAgICAgICAgICAgICAgaW1nOiAnaHR0cHM6Ly9sYW5tZWlndW9qaWFuZy5jb20vdHViaWFvL21vcmUvMTAucG5nJ1xcbiAgICAgICAgICAgIH0pXFxuXFxuICAgICAgICAgICAgdmFyIGxpc3QgPSBqc29uLnByb3BzLnBhZ2VQcm9wcy5mYWxsYmFja1trZXldLmRhdGFcXG5cXG4gICAgICAgICAgICBsaXN0Lm1hcCh4ID0+IHtcXG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSB4LmhvdF9uYW1lXFxuICAgICAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogbmFtZSxcXG4gICAgICAgICAgICAgICAgICAgIGltZzogeC5ob3RfaW1nX3VybCxcXG4gICAgICAgICAgICAgICAgICAgIGRlc2M6IHguaG90X3JhdGUsXFxuICAgICAgICAgICAgICAgICAgICB1cmw6ICQoJycpLmxhenlSdWxlKChuLCB1KSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcInNvdVxcXCIsIG4pXFxuICAgICAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoJ2R1cmwnLCB1KVxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKClcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgICAgICAgICAgICAgICAgICB9LCBuYW1lLCB4LmhvdF91cmwpXFxuICAgICAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIFsn54Ot6Zeo55S15b2xI2luZGV4LWdldE1vdmllTGlzdC1tb3ZpZScsICfng63pl6jliafpm4YjaW5kZXgtZ2V0VHZMaXN0LXR2LTI4J10ubWFwKHggPT4ge1xcbiAgICAgICAgICAgIHNldExpc3RzKHgpXFxuICAgICAgICB9KVxcbiAgICB9XFxuICAgIGlmIChwaW5kZXggPT0gXFxcIjFcXFwiKSB7XFxuICAgICAgICBcXG4gICAgICAgIHZhciB0eXBlcyA9IHtcXG4gICAgICAgICAgICBcXFwidGFnXFxcIjogW1xcXCLnsbvlnos6MFxcXCIsIFxcXCLllpzliac6MVxcXCIsIFxcXCLniLHmg4U6MlxcXCIsIFxcXCLlpYflubs6NFxcXCIsIFxcXCLniq/nvao6NVxcXCIsIFxcXCLmgqznlpE6NlxcXCIsIFxcXCLljoblj7I6N1xcXCIsIFxcXCLmiJjkuok6OFxcXCIsIFxcXCLliqjkvZw6OVxcXCIsIFxcXCLnp5Hlubs6MTBcXFwiLCBcXFwi5Yqo55S7OjExXFxcIiwgXFxcIuWGkumZqToxMlxcXCIsIFxcXCLngb7pmr46MTVcXFwiLCBcXFwi5oOK5oKaOjE3XFxcIiwgXFxcIuaBkOaAljoxOFxcXCIsIFxcXCLmrYzoiJ46MjJcXFwiLCBcXFwi5q2m5L6gOjI0XFxcIiwgXFxcIumfs+S5kDoyN1xcXCJdLFxcbiAgICAgICAgICAgIFxcXCJjb3VudHJ5XFxcIjogW1xcXCLlnLDljLo6MFxcXCIsIFxcXCLkuK3lm706MVxcXCIsIFxcXCLpn6nlm706M1xcXCIsIFxcXCLml6XmnKw6NFxcXCIsIFxcXCLnvo7lm706NlxcXCIsIFxcXCLoi7Hlm706OVxcXCIsIFxcXCLms5Xlm706MTBcXFwiLCBcXFwi5b635Zu9OjExXFxcIiwgXFxcIuWFtuS7ljoxMlxcXCJdLFxcbiAgICAgICAgICAgIFxcXCJ5ZWFyXFxcIjogW1xcXCLml7bpl7Q6MFxcXCIsIFxcXCIyMDIyOjFcXFwiLCBcXFwiMjAyMjoyXFxcIiwgXFxcIjIwMjA6M1xcXCIsIFxcXCIyMDE5OjRcXFwiLCBcXFwiMjAxMOW5tOS7ozo1XFxcIiwgXFxcIjIwMDDlubTku6M6NlxcXCIsIFxcXCI5MOW5tOS7ozo3XFxcIiwgXFxcIjgw5bm05LujOjhcXFwiLCBcXFwiNzDlubTku6M6OVxcXCIsIFxcXCI2MOW5tOS7ozoxMFxcXCIsIFxcXCLmm7Tml6k6MTFcXFwiXSxcXG4gICAgICAgICAgICBcXFwic29ydFxcXCI6IFtcXFwi57u85ZCI5o6S5bqPOjFcXFwiLCBcXFwi6L+R5pyf54Ot5bqmOjJcXFwiLCBcXFwi6auY5YiG5LyY5YWIOjNcXFwiXVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyIG9qc29uID0gW3tcXG4gICAgICAgICAgICBuYW1lOiAn55S15b2xJyxcXG4gICAgICAgICAgICBpZDogJ21vdmllJyxcXG4gICAgICAgICAgICBjb250ZW50OiB0eXBlc1xcbiAgICAgICAgfSwge1xcbiAgICAgICAgICAgIG5hbWU6ICfnlLXop4bliacnLFxcbiAgICAgICAgICAgIGlkOiAndHYnLFxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHR5cGVzXFxuICAgICAgICB9LCB7XFxuICAgICAgICAgICAgbmFtZTogJ+WKqOa8qycsXFxuICAgICAgICAgICAgaWQ6ICdhbmltZScsXFxuICAgICAgICAgICAgY29udGVudDogdHlwZXNcXG4gICAgICAgIH0sIHtcXG4gICAgICAgICAgICBuYW1lOiAn57u86Im6JyxcXG4gICAgICAgICAgICBpZDogJ3ZhcmlldHknLFxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHR5cGVzXFxuICAgICAgICB9LCB7XFxuICAgICAgICAgICAgbmFtZTogJ+e6quW9leeJhycsXFxuICAgICAgICAgICAgaWQ6ICdkb2N1bWVudGFyeScsXFxuICAgICAgICAgICAgY29udGVudDogdHlwZXNcXG4gICAgICAgIH1dXFxuXFxuICAgICAgICB2YXIg5aSn57G7ID0gW107XFxuICAgICAgICBvanNvbi5tYXAoeCA9PiB7XFxuICAgICAgICAgICAg5aSn57G7LnB1c2goeC5uYW1lICsgXFxcIkBcXFwiICsgeC5pZCk7XFxuICAgICAgICB9KVxcbiAgICAgICAgdmFyIGluZGV4ID0gc3RvcmFnZTAuZ2V0TXlWYXIoXFxcImluZGV4XFxcIiwgJzAnKTtcXG4gICAgICAgIHZhciBqID0gb2pzb25baW5kZXhdO1xcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhqLmNvbnRlbnQpO1xcblxcbiAgICAgICAgdmFyIHRlbXAgPSB7fTtcXG4gICAgICAgIGtleXMuZm9yRWFjaCh4ID0+IHtcXG4gICAgICAgICAgICB2YXIgdHlwZSA9IHg7XFxuICAgICAgICAgICAgdmFyIGwgPSBqLmNvbnRlbnRbeF07XFxuICAgICAgICAgICAgaWYgKFsndmVyc2lvbiddLmluY2x1ZGVzKHgpKSB7XFxuICAgICAgICAgICAgICAgIHJldHVyblxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAobC5sZW5ndGggPiAwKSB7XFxuICAgICAgICAgICAgICAgIHZhciBucyA9IGwubWFwKChrKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGsuc3BsaXQoJzonKVswXTtcXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IGsuc3BsaXQoJzonKVsxXTtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBuYW1lLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1cmwnOiBpZCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAndHlwZSc6IHhcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICAgICAgdGVtcFt4XSA9IG5zO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pXFxuXFxuICAgICAgICB2YXIgdCA9IE9iamVjdC52YWx1ZXModGVtcCkubWFwKHggPT4geC5tYXAoeiA9PiBKU09OLnN0cmluZ2lmeSh6KSkuam9pbignIycpKVxcblxcbiAgICAgICAgdmFyIFRydWVKc29uID0ge1xcbiAgICAgICAgICAgIHR5cGU6IEFycmF5KOWkp+exuy5qb2luKCcjJykpLFxcbiAgICAgICAgICAgIGl0ZW06IHQgIT0gXFxcIlxcXCIgPyB0IDogW10sXFxuICAgICAgICB9XFxuICAgICAgICAvL2xvZyhUcnVlSnNvbilcXG5cXG4gICAgICAgIC8v6ZyA5qC55o2u5a6e6ZmF5L+u5pS5XFxuICAgICAgICBjb25zdCDliIbnsbvpopzoibIgPSBnZXRSYW5nZUNvbG9ycygpO1xcbiAgICAgICAgY29uc3QgSnNvbuWkp+exuyA9ICd0eXBlJztcXG4gICAgICAgIGNvbnN0IEpzb27mi7zmjqUgPSAnaXRlbSc7XFxuICAgICAgICBjb25zdCBKc29u5ouG5YiGID0gJyMnO1xcbiAgICAgICAgY29uc3QgSnNvbuWNlemhuSA9ICdAJztcXG4gICAgICAgIGNvbnN0IEpzb27liJfooaggPSBbXFxcInRhZ1xcXCIsIFxcXCJjb3VudHJ5XFxcIiwgXFxcInllYXJcXFwiLCBcXFwic29ydFxcXCJdOyAvL+WIh+aNoua4hemZpFxcbiAgICAgICAgY29uc3Qg5o6S6ZmkID0gJyc7XFxuICAgICAgICBjb25zdCDliIbnsbvlsZXlvIAgPSAn4oioJztcXG4gICAgICAgIGNvbnN0IOWIhuexu+aKmOWPoCA9ICfiiKcnO1xcblxcbiAgICAgICAgLy/liqjmgIHliIbnsbtcXG4gICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvamR0ZmwnKSkucnVsZSk7XFxuICAgICAgICB2YXIgdHlwZSA9IHN0b3JhZ2UwLmdldE15VmFyKFxcXCJteXR5cGVcXFwiLCBcXFwibW92aWVcXFwiKTtcXG4gICAgICAgIHZhciB0YWcgPSBzdG9yYWdlMC5nZXRNeVZhcihcXFwidGFnXFxcIiwgXFxcIjBcXFwiKTtcXG4gICAgICAgIHZhciBjb3VudHJ5ID0gc3RvcmFnZTAuZ2V0TXlWYXIoXFxcImNvdW50cnlcXFwiLCBcXFwiMFxcXCIpO1xcbiAgICAgICAgdmFyIHllYXIgPSBzdG9yYWdlMC5nZXRNeVZhcihcXFwieWVhclxcXCIsIFxcXCIwXFxcIik7XFxuICAgICAgICB2YXIgc29ydCA9IHN0b3JhZ2UwLmdldE15VmFyKFxcXCJzb3J0XFxcIiwgXFxcIjFcXFwiKTtcXG5cXG4gICAgICAgIC8vbG9nKGAke3R5cGV9OiR7dGFnfSske2NvdW50cnl9KyR7eWVhcn0rJHtzb3J0fWApXFxuICAgICAgICB2YXIganVybCA9IGBodHRwczovL2FwaS54aWFtbS5jYzo5ODk3L21vdmllL2dldCR7dHlwZX1saXN0L3RhZy8ke3RhZ30vY291bnRyeS8ke2NvdW50cnl9L3llYXIvJHt5ZWFyfS9zb3J0LyR7c29ydH0vcGFnZS8ke3BhZ2V9L3Jvd3MvMzAuanNvbmA7XFxuICAgICAgICB2YXIgcGxpc3QgPSBKU09OLnBhcnNlKGZldGNoKGp1cmwpKS5kYXRhXFxuICAgICAgICBwbGlzdC5tYXAoeCA9PiB7XFxuICAgICAgICAgICAgdmFyIG5hbWUgPSB4Lm1vdmllX25hbWU7XFxuICAgICAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IG5hbWUsXFxuICAgICAgICAgICAgICAgIGltZzogeC5tb3ZpZV9pbWdfdXJsICsgXFxcIkBSZWZlcmVyPVxcXCIsXFxuICAgICAgICAgICAgICAgIGRlc2M6IHgubW92aWVfcmF0ZSxcXG4gICAgICAgICAgICAgICAgdXJsOiAkKCcnKS5sYXp5UnVsZSgobiwgdSkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcInNvdVxcXCIsIG4pXFxuICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcignZHVybCcsIHUpXFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgICAgICAgICAgICAgIH0sIG5hbWUsIHgubW92aWVfdXJsKSxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6ICdtb3ZpZV8zX21hcnF1ZWUnXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgIH0pXFxuICAgIH1cXG59XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCIyLuiMtuadr+eLkFwiLFwicGF0aFwiOlwiY3VwZm94XCIsXCJydWxlXCI6XCJqczpcXG5cXG5ldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL3h0b29scycpKS5ydWxlKVxcblxcbmlmIChzICE9IFxcXCJcXFwiKSB7XFxuICAgIGxldCB7XFxuICAgICAgICB3cmFwMSxcXG4gICAgICAgIHJlaHRtbFxcbiAgICB9ID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvdG9vbFxcXCIpO1xcbiAgICB2YXIganNvbiA9IHNlYXJjaChzLCBzdG9yYWdlMC5nZXRNeVZhcigncGFnZScsIE1ZX1BBR0UpKVxcbiAgICBpZiAoSlNPTi5zdHJpbmdpZnkoanNvbikgIT0gXFxcInt9XFxcIikge1xcbiAgICAgICAgdmFyIGxpc3QgPSBqc29uLnJlc291cmNlcztcXG4gICAgICAgIGxpc3QubWFwKGl0ID0+IHtcXG4gICAgICAgICAgICAvL2xvZyhpdC53ZWJzaXRlKyctJytyZWh0bWwoaXQudGV4dCkpXFxuICAgICAgICAgICAgdmFyIHU9XFxcImhpa2VyOi8vcGFnZS9wP3U9XFxcIiArIGJhc2U2NEVuY29kZShpdC51cmwpXFxuICAgICAgICAgICAgdT1nZXRJdGVtKCdhaScsJzAnKT09JzAnP3U6dSsnI2ltbWVyc2l2ZVRoZW1lIydcXG4gICAgICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgICAgICB0aXRsZTogd3JhcDEoaXQud2Vic2l0ZSsnLScrcmVodG1sKGl0LnRleHQpLCBzKSxcXG4gICAgICAgICAgICAgICAgdXJsOiB1LFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcImF2YXRhclxcXCIsXFxuICAgICAgICAgICAgICAgIGltZzppdC5pY29uLFxcbiAgICAgICAgICAgICAgICBkZXNjOiBpdC53ZWJzaXRlLFxcbiAgICAgICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICAgICAgaW5oZXJpdFRpdGxlOiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VUaXRsZTogcmVodG1sKGl0LnRleHQpLFxcbiAgICAgICAgICAgICAgICAgICAgd2ViOml0LndlYnNpdGUsXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0pXFxuICAgIH1cXG4gICAgXFxuICAgIHNldFJlc3VsdChkKVxcbn0gZWxzZSB7XFxuICAgIFxcbn1cXG5cXG5pZihnZXRJdGVtKCdob21lJywn5YWzJyk9PSflvIAnKXtcXG5cXG52YXIgaHRtbCA9IGZldGNoUEMoJ2h0dHBzOi8vY3VwZm94LmFwcC8nLCB7fSlcXG5cXG5cXG5mdW5jdGlvbiBzZXRMaXN0cyhpdGVtKSB7XFxuICAgIHZhciB0aXRsZSA9IGl0ZW0uc3BsaXQoJy0nKVswXVxcbiAgICB2YXIgdCA9IGl0ZW0uc3BsaXQoJy0nKVsxXVxcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxcbiAgICAgICAgY29sX3R5cGU6ICdhdmF0YXInLFxcbiAgICAgICAgaW1nOiAnaHR0cHM6Ly9sYW5tZWlndW9qaWFuZy5jb20vdHViaWFvL21vcmUvMTAucG5nJ1xcbiAgICB9KVxcblxcbiAgICB2YXIgbGlzdCA9IHBkZmEoaHRtbCwgYGJvZHkmJiMke3R9JiYubW92aWUtbGlzdC1pdGVtYClcXG5cXG4gICAgbGlzdC5tYXAoeCA9PiB7XFxuICAgICAgICB2YXIgbmFtZSA9IHBkZmgoeCwgJy5tb3ZpZS10aXRsZSYmVGV4dCcpXFxuICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiBuYW1lLFxcbiAgICAgICAgICAgIGltZzogcGRmaCh4LCAnaW1nJiZzcmMnKSxcXG4gICAgICAgICAgICBkZXNjOnBkZmgoeCwnLm1vdmllLXJhdGluZyYmVGV4dCcpLFxcbiAgICAgICAgICAgIHVybDogJCgnJykubGF6eVJ1bGUoKG4pID0+IHtcXG4gICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcInNvdVxcXCIsIG4pXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKClcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcbiAgICAgICAgICAgIH0sIG5hbWUpXFxuICAgICAgICB9KVxcbiAgICB9KVxcbn1cXG5cXG5bJ+eDreaSreaWsOWJpy10dicsICfng63pl6jnlLXlvbEtbW92aWUnLCAn54Ot5pKt5Yqo5ryrLWFuaW1lJywgJ+eDreaSree7vOiJui1zaG93JywgJ+eDreaSree6quW9leeJhy1kb2N1bWVudGFyeSddLm1hcCh4ID0+IHtcXG4gICAgc2V0TGlzdHMoeClcXG59KVxcblxcbn1cXG5cIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuWHveaVsFwiLFwicGF0aFwiOlwieHRvb2xzXCIsXCJydWxlXCI6XCJqczpcXG5mdW5jdGlvbiBlbmNvZGVVVEY4KHMpIHtcXG52YXIgaSwgciA9IFtdLCBjLCB4O1xcbmZvciAoaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKVxcbmlmICgoYyA9IHMuY2hhckNvZGVBdChpKSkgPCAweDgwKSByLnB1c2goYyk7XFxuZWxzZSBpZiAoYyA8IDB4ODAwKSByLnB1c2goMHhDMCArIChjID4+IDYgJiAweDFGKSwgMHg4MCArIChjICYgMHgzRikpO1xcbmVsc2Uge1xcbmlmICgoeCA9IGMgXiAweEQ4MDApID4+IDEwID09IDApIC8v5a+55Zub5a2X6IqCVVRGLTE26L2s5o2i5Li6VW5pY29kZVxcbmMgPSAoeCA8PCAxMCkgKyAocy5jaGFyQ29kZUF0KCsraSkgXiAweERDMDApICsgMHgxMDAwMCxcXG5yLnB1c2goMHhGMCArIChjID4+IDE4ICYgMHg3KSwgMHg4MCArIChjID4+IDEyICYgMHgzRikpO1xcbmVsc2Ugci5wdXNoKDB4RTAgKyAoYyA+PiAxMiAmIDB4RikpO1xcbnIucHVzaCgweDgwICsgKGMgPj4gNiAmIDB4M0YpLCAweDgwICsgKGMgJiAweDNGKSk7XFxufTtcXG5yZXR1cm4gcjtcXG59XFxuXFxuZnVuY3Rpb24gc2hhMShzKSB7XFxudmFyIGRhdGEgPSBuZXcgVWludDhBcnJheShlbmNvZGVVVEY4KHMpKVxcbnZhciBpLCBqLCB0O1xcbnZhciBsID0gKChkYXRhLmxlbmd0aCArIDgpID4+PiA2IDw8IDQpICsgMTYsIHMgPSBuZXcgVWludDhBcnJheShsIDw8IDIpO1xcbnMuc2V0KG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyKSksIHMgPSBuZXcgVWludDMyQXJyYXkocy5idWZmZXIpO1xcbmZvciAodCA9IG5ldyBEYXRhVmlldyhzLmJ1ZmZlciksIGkgPSAwOyBpIDwgbDsgaSsrKXNbaV0gPSB0LmdldFVpbnQzMihpIDw8IDIpO1xcbnNbZGF0YS5sZW5ndGggPj4gMl0gfD0gMHg4MCA8PCAoMjQgLSAoZGF0YS5sZW5ndGggJiAzKSAqIDgpO1xcbnNbbCAtIDFdID0gZGF0YS5sZW5ndGggPDwgMztcXG52YXIgdyA9IFtdLCBmID0gW1xcbmZ1bmN0aW9uICgpIHsgcmV0dXJuIG1bMV0gJiBtWzJdIHwgfm1bMV0gJiBtWzNdOyB9LFxcbmZ1bmN0aW9uICgpIHsgcmV0dXJuIG1bMV0gXiBtWzJdIF4gbVszXTsgfSxcXG5mdW5jdGlvbiAoKSB7IHJldHVybiBtWzFdICYgbVsyXSB8IG1bMV0gJiBtWzNdIHwgbVsyXSAmIG1bM107IH0sXFxuZnVuY3Rpb24gKCkgeyByZXR1cm4gbVsxXSBeIG1bMl0gXiBtWzNdOyB9XFxuXSwgcm9sID0gZnVuY3Rpb24gKG4sIGMpIHsgcmV0dXJuIG4gPDwgYyB8IG4gPj4+ICgzMiAtIGMpOyB9LFxcbmsgPSBbMTUxODUwMDI0OSwgMTg1OTc3NTM5MywgLTE4OTQwMDc1ODgsIC04OTk0OTc1MTRdLFxcbm0gPSBbMTczMjU4NDE5MywgLTI3MTczMzg3OSwgbnVsbCwgbnVsbCwgLTEwMDk1ODk3NzZdO1xcbm1bMl0gPSB+bVswXSwgbVszXSA9IH5tWzFdO1xcbmZvciAoaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSArPSAxNikge1xcbnZhciBvID0gbS5zbGljZSgwKTtcXG5mb3IgKGogPSAwOyBqIDwgODA7IGorKylcXG53W2pdID0gaiA8IDE2ID8gc1tpICsgal0gOiByb2wod1tqIC0gM10gXiB3W2ogLSA4XSBeIHdbaiAtIDE0XSBeIHdbaiAtIDE2XSwgMSksXFxudCA9IHJvbChtWzBdLCA1KSArIGZbaiAvIDIwIHwgMF0oKSArIG1bNF0gKyB3W2pdICsga1tqIC8gMjAgfCAwXSB8IDAsXFxubVsxXSA9IHJvbChtWzFdLCAzMCksIG0ucG9wKCksIG0udW5zaGlmdCh0KTtcXG5mb3IgKGogPSAwOyBqIDwgNTsgaisrKW1bal0gPSBtW2pdICsgb1tqXSB8IDA7XFxufTtcXG50ID0gbmV3IERhdGFWaWV3KG5ldyBVaW50MzJBcnJheShtKS5idWZmZXIpO1xcbmZvciAodmFyIGkgPSAwOyBpIDwgNTsgaSsrKW1baV0gPSB0LmdldFVpbnQzMihpIDw8IDIpO1xcblxcbnZhciBoZXggPSBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwobmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KG0pLmJ1ZmZlciksIGZ1bmN0aW9uIChlKSB7XFxucmV0dXJuIChlIDwgMTYgPyBcXFwiMFxcXCIgOiBcXFwiXFxcIikgKyBlLnRvU3RyaW5nKDE2KTtcXG59KS5qb2luKFxcXCJcXFwiKTtcXG5yZXR1cm4gaGV4O1xcbn1cXG5cXG5cXG5mdW5jdGlvbiBzZWFyY2gocywgcGFnZSkge1xcbiAgICBldmFsKGdldENyeXB0b0pTKCkpXFxuICAgIGlmIChwYWdlID09IDEpIHtcXG4gICAgICAgIHAgPSAwXFxuICAgIH0gZWxzZSBpZiAocGFnZSA9PSAyKSB7XFxuICAgICAgICBwID0gMTlcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHAgPSBwYXJzZUludChwYWdlKSArIDIwXFxuICAgIH1cXG4gICAgc3RvcmFnZTAucHV0TXlWYXIoJ3BhZ2UnLCBwKVxcbiAgICBzcyA9IHMgKyAnVVJCQlJHUk9VTidcXG4gICAgdGsgPSBDcnlwdG9KUy5TSEExKHNzKS50b1N0cmluZygpO1xcbiAgICB2YXIgaiA9IGZldGNoKGBodHRwczovL2FwaS5jdXBmb3guYXBwL2FwaS92Mi9zZWFyY2gvP3RleHQ9JHtzfSZ0eXBlPTAmZnJvbT0ke3B9JnNpemU9MjAmZG91YmFuX2lkPTAmdG9rZW49JHt0a31gKVxcbiAgICB0cnkge1xcbiAgICAgICAgdmFyIGpzb24gPSBKU09OLnBhcnNlKGopXFxuICAgIH0gY2F0Y2gge1xcbiAgICAgICAgdmFyIGpzb24gPSB7fVxcbiAgICB9XFxuICAgIHJldHVybiBqc29uXFxufVxcblwifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwiNC7pnZLpuqZcIixcInBhdGhcIjpcInFpbWFpdHZcIixcInJ1bGVcIjpcImpzOlxcbmlmIChzICE9IFxcXCJcXFwiKSB7XFxuICAgIHZhciB1cmw9XFxcImh0dHA6Ly9tLnFtdHYuYXBwL3Byb2QtYXBpL2FwcC9tb3ZpZS9pbmRleC9zZWFyY2hNb3ZpZUJ5TmFtZVxcXCI7XFxuICAgIFxcbiAgICBsZXQgaHRtbCA9IGZldGNoKHVybCwge1xcbiAgICAgICAgaGVhZGVyczoge1xcbiAgICAgICAgICAgIFxcXCJYLVJlcXVlc3RlZC1XaXRoXFxcIjogXFxcIlhNTEh0dHBSZXF1ZXN0XFxcIlxcbiAgICAgICAgfSxcXG4gICAgICAgIGJvZHk6XFxuICAgICAgICAgICAge1xcbiAgXFxcImNvbmRpdGlvblxcXCI6IHMsXFxuICBcXFwicGFnZVNpemVcXFwiOiAyNSxcXG4gIFxcXCJwYWdlTnVtXFxcIjogMVxcbiAgICAgICAgfVxcbiAgICB9KTtcXG4gICAgXFxuICAgIHZhciBpbmZvID0gJydcXG4gICAgdHJ5IHtcXG4gICAgICAgIGluZm8gPSBKU09OLnBhcnNlKGh0bWwpLmRhdGEucmVjb3JkcztcXG4gICAgfSBjYXRjaCB7XFxuXFxuICAgIH1cXG4gICAgaWYgKGluZm8gIT0gbnVsbCkge1xcbiAgICAgICAgdmFyIGRhdGEgPSBpbmZvO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgZGF0YSA9IFtdXFxuICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiAn4oCc4oCc4oCd4oCdPHNtYWxsPuaXoOe7k+aenDwvc2FtbGw+JyxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ3RleHRfY2VudGVyXzEnXFxuICAgICAgICB9KVxcbiAgICAgICAgc2V0UmVzdWx0KGQpXFxuICAgIH1cXG5cXG4gICAgbGV0IHtcXG4gICAgICAgIHdyYXAxXFxuICAgIH0gPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS90b29sXFxcIik7XFxuICAgIGZvciAobGV0IGl0IG9mIGRhdGEpIHtcXG4gICAgICAgIC8vbG9nKGl0KVxcbiAgICAgICAgbGV0IHQgPSBpdC5uYW1lO1xcbiAgICAgICAgbGV0IHdlYiA9IGl0LndlYnNpdGVOYW1lO1xcbiAgICAgICAgbGV0IGltZyA9IGl0LndlYnNpdGVJY29uO1xcbiAgICAgICAgbGV0IHVybD1pdC51cmk7XFxuICAgICAgICBcXG4gICAgICAgIGlmICghdCkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIHUgPSBcXFwiaGlrZXI6Ly9wYWdlL3A/dT1cXFwiICsgYmFzZTY0RW5jb2RlKHVybClcXG4gICAgICAgIHUgPSBnZXRJdGVtKCdhaScsICcwJykgPT0gJzAnID8gdSA6IHUgKyAnI2ltbWVyc2l2ZVRoZW1lIydcXG4gICAgICAgIFxcbiAgICAgICAgXFxuICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiBcXFwi4oCc4oCc4oCd4oCdXFxcIit3cmFwMSh3ZWIgKyAnLScgKyB0LCBzKSxcXG4gICAgICAgICAgICB1cmw6IHUsXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJtb3ZpZV8xX2xlZnRfcGljXFxcIixcXG4gICAgICAgICAgICBpbWc6aXQuY292ZXIsXFxuICAgICAgICAgICAgLy9kZXNjOiAnJyxcXG4gICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICBpZDogaXQudXJpLFxcbiAgICAgICAgICAgICAgICBpbmhlcml0VGl0bGU6IGZhbHNlLFxcbiAgICAgICAgICAgICAgICBwYWdlVGl0bGU6IHQsXFxuICAgICAgICAgICAgICAgIHdlYjp3ZWIsXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgIH1cXG4gICAgc2V0UmVzdWx0KGQpXFxufSBlbHNlIHtcXG5cXG59XFxuXFxuaWYgKGdldEl0ZW0oJ2hvbWUnLCAn5YWzJykgPT0gJ+W8gCcpIHtcXG4gICAgZnVuY3Rpb24gc2V0TGlzdHMoaXRlbSkge1xcbiAgICAgICAgdmFyIHRpdGxlID0gaXRlbS5zcGxpdCgnLScpWzBdXFxuICAgICAgICB2YXIgdCA9IGl0ZW0uc3BsaXQoJy0nKVsxXVxcbiAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogdGl0bGUsXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdhdmF0YXInLFxcbiAgICAgICAgICAgIGltZzogJ2h0dHBzOi8vbGFubWVpZ3VvamlhbmcuY29tL3R1Ymlhby9tb3JlLzEwLnBuZydcXG4gICAgICAgIH0pXFxuXFxuICAgICAgICB2YXIganNvbiA9IEpTT04ucGFyc2UoZmV0Y2hQQyhgaHR0cHM6Ly93d3cucW10di5hcHAvcHJvZC1hcGkvYXBwL21vdmllL2luZGV4L3NlYXJjaEFsbE1vdmllYCkpXFxuICAgICAgIFxcblxcbiAgICAgICAgdmFyIGxpc3QgPSBqc29uLmRhdGFbdF0ucmVjb3JkcztcXG5cXG4gICAgICAgIGxpc3QubWFwKHggPT4ge1xcbiAgICAgICAgICAgIHZhciBuYW1lID0geC50aXRsZTtcXG4gICAgICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgICAgICB0aXRsZTogbmFtZSxcXG4gICAgICAgICAgICAgICAgaW1nOiB4LmNvdmVyLFxcbiAgICAgICAgICAgICAgICBkZXNjOiB4LnJhdGUsXFxuICAgICAgICAgICAgICAgIHVybDogJCgnJykubGF6eVJ1bGUoKG4pID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXCJzb3VcXFwiLCBuKVxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKVxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcbiAgICAgICAgICAgICAgICB9LCBuYW1lKVxcbiAgICAgICAgICAgIH0pXFxuICAgICAgICB9KVxcbiAgICB9XFxuXFxuICAgIFsn54Ot5pKt55S15b2xLWxpc3RIb3RNb3ZpZScsICfng63mkq3nlLXop4bliactbGlzdEhvdFR2JywgJ+eDreaSreWKqOa8qy1saXN0SG90Q29taWMnLCAn54Ot5pKt57u86Im6LWxpc3RIb3RWYXJpZXR5J10ubWFwKHggPT4ge1xcbiAgICAgICAgc2V0TGlzdHMoeClcXG4gICAgfSlcXG59XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLlh73mlbAyXCIsXCJwYXRoXCI6XCJ6dG9vbHNcIixcInJ1bGVcIjpcImpzOlxcbi8vdXJs6Kej5p6QXFxuZnVuY3Rpb24gdXJsUGFyc2UodSkge1xcbiAgICB2YXIgZGljdCA9IHt9XFxuICAgIGRpY3QuU291cmNlID0gdTtcXG4gICAgbGV0IHBhcmFtcyA9ICh1cmwpID0+IHtcXG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xcbiAgICAgICAgbGV0IHJlZyA9IC8oW14/PSZdKyk9KFtePz0mXSspL2c7XFxuICAgICAgICB1cmwucmVwbGFjZShyZWcsIGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zW2FyZ3VtZW50c1sxXV0gPSBhcmd1bWVudHNbMl07XFxuICAgICAgICB9KVxcbiAgICAgICAgcmV0dXJuIHF1ZXJ5UGFyYW1zXFxuICAgIH1cXG4gICAgdmFyIGphdmFVcmwgPSBKYXZhSW1wb3J0ZXIoamF2YS5uZXQuVVJMKTtcXG4gICAgd2l0aChqYXZhVXJsKSB7XFxuICAgICAgICB2YXIgdXJsID0gbmV3IFVSTCh1KTtcXG4gICAgICAgIGRpY3QuUHJvdG9jb2wgPSB1cmwuZ2V0UHJvdG9jb2woKTtcXG4gICAgICAgIGRpY3QuSG9zdCA9IHVybC5nZXRIb3N0KCk7XFxuICAgICAgICBkaWN0LlBvcnQgPSB1cmwuZ2V0UG9ydCgpO1xcbiAgICAgICAgZGljdC5GaWxlID0gdXJsLmdldEZpbGUoKTtcXG4gICAgICAgIGRpY3QuUGF0aCA9IHVybC5nZXRQYXRoKCk7XFxuICAgICAgICBkaWN0LlJlZiA9IHVybC5nZXRSZWYoKTtcXG4gICAgICAgIGRpY3QuSG9zdHMgPSBgJHt1cmwuZ2V0UHJvdG9jb2woKX06Ly8ke3VybC5nZXRIb3N0KCl9YFxcbiAgICB9XFxuICAgIGRpY3QuUGFyYW1zID0gcGFyYW1zKHUpO1xcbiAgICByZXR1cm4gZGljdDtcXG59XFxuXFxuZnVuY3Rpb24gc3RyaW5nSW5BcnJheShzdHIsIGFycikge1xcbiAgICByZXR1cm4gYXJyLnNvbWUoaXRlbSA9PiBzdHIuaW5jbHVkZXMoaXRlbSkpO1xcbn1cXG5cXG5cXG4vL+aOkumZpOayoei3r+W+hFxcbmZ1bmN0aW9uIG5vZmlsZSh1KSB7XFxuICAgIHVybCA9IHUuaHJlZlxcbiAgICBpZiAoc3RyaW5nSW5BcnJheSh1cmwsIFsnbWFnbmV0JywgJ2VkMmsnXSkpIHtcXG4gICAgICAgIEJpdFRTLnB1c2godSk7XFxuICAgICAgICByZXR1cm4gdHJ1ZVxcbiAgICB9XFxuICAgIHZhciB1ID0gdXJsUGFyc2UodXJsKVxcbiAgICBpZiAodS5GaWxlID09ICcnIHx8IHUuRmlsZSA9PSAnLycgfHwgdS5SZWYgIT0gbnVsbCkge1xcbiAgICAgICAgcmV0dXJuIHRydWVcXG4gICAgfVxcbn1cXG4vL+WOu+mHjVxcbmZ1bmN0aW9uIHVuaXF1ZShhcnIpIHtcXG4gICAgY29uc3QgcmVzID0gbmV3IE1hcCgpXFxuICAgIHJldHVybiBhcnIuZmlsdGVyKChhKSA9PiAhcmVzLmhhcyhhLnVybCkgJiYgcmVzLnNldChhLnVybCwgMSkpXFxufVxcblxcbi8v6YeN5a6a5ZCR5Y+v55So6ZO+5o6lXFxuZnVuY3Rpb24gZ2V0VHVybCh1KSB7XFxuICAgIC8vbG9nKHUpXFxuICAgIHRyeSB7XFxuICAgICAgICB2YXIgdXJsID0gYmFzZTY0RGVjb2RlKHUpO1xcbiAgICB9IGNhdGNoIHtcXG4gICAgICAgIHZhciB1cmwgPSB1XFxuICAgIH1cXG4gICAgaWYgKCF1cmwuaW5jbHVkZXMoJ2h0dHAnKSB8fCB1cmwgPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICB1cmwgPSB1XFxuICAgIH1cXG4gICAgdXJsID0gdXJsLmluY2x1ZGVzKCc/JykgPyB1cmwuc3BsaXQoJz8nKVswXSA6IHVybFxcbiAgICBsb2coJ3VybDonICsgdXJsKVxcbiAgICB2YXIgZmlsZSA9IHVybFBhcnNlKHVybCkuRmlsZVxcbiAgICB2YXIgdHVybCA9ICcnXFxuICAgIGxldCBoZWFkID0gSlNPTi5wYXJzZShyZXF1ZXN0KHVybCwge1xcbiAgICAgICAgb25seUhlYWRlcnM6IHRydWVcXG4gICAgfSkpO1xcbiAgICAvL2xvZyhoZWFkKVxcbiAgICBpZiAoaGVhZC51cmwgIT0gdW5kZWZpbmVkIHx8IGhlYWQudXJsICE9ICcnKSB7XFxuICAgICAgICB2YXIganVybHAgPSB1cmxQYXJzZShoZWFkLnVybClcXG4gICAgICAgIGlmIChqdXJscC5GaWxlID09ICcvJyB8fCBqdXJscC5GaWxlID09ICcnKSB7XFxuICAgICAgICAgICAgdHVybCA9IGp1cmxwLkhvc3RzICsgZmlsZVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB0dXJsID0gaGVhZC51cmxcXG4gICAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHR1cmwgPSB1cmxcXG4gICAgfVxcbiAgICAvL2xvZygndHVybDonK3R1cmwpXFxuICAgIHR1cmwgPSB0dXJsLnJlcGxhY2UoL1xcXFw/ZnJvbS4rJC9nbSwgJycpO1xcblxcbiAgICB0dXJsID0gdmlkZW9SZWZEZXRhaWwodHVybClcXG4gICAgLy9sb2codHVybClcXG4gICAgcmV0dXJuIHR1cmxcXG59XFxuXFxuXFxuZnVuY3Rpb24gdmlkZW9SZWZEZXRhaWwodXJsKSB7XFxuICAgIGlmIChzdHJpbmdJbkFycmF5KHVybCwgW1xcXCI2MDgwXFxcIl0pKSB7XFxuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShcXFwidnBsYXlcXFwiLCBcXFwidmlkZW9cXFwiKTtcXG4gICAgfSBlbHNlIGlmIChzdHJpbmdJbkFycmF5KHVybCwgW1xcXCJ6aHVpanVcXFwiXSkpIHtcXG4gICAgICAgIHVybCA9IHVybC5yZXBsYWNlKFxcXCJ2b2RwbGF5XFxcIiwgXFxcInZvZGRldGFpbFxcXCIpO1xcbiAgICB9IGVsc2UgaWYgKHN0cmluZ0luQXJyYXkodXJsLCBbXFxcInJyZXRzXFxcIl0pKSB7XFxuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShcXFwicGxheVxcXCIsIFxcXCJwcm9qZWN0XFxcIilcXG4gICAgfVxcbiAgICByZXR1cm4gdXJsO1xcbn1cXG5cXG5cXG4vL+WkmumAieaooeWdl1xcbmZ1bmN0aW9uIE11bHRpU2VsZWN0TW9kZShuYW1lLCBpZCkge1xcbiAgICByZXR1cm4gJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoZGF0YXRpdGxlLCBkYXRhdXJsKSA9PiB7XFxuICAgICAgICBmdW5jdGlvbiB1bmlxdWUoYXJyKSB7XFxuICAgICAgICBjb25zdCByZXMgPSBuZXcgTWFwKClcXG4gICAgICAgIHJldHVybiBhcnIuZmlsdGVyKChhKSA9PiAhcmVzLmhhcyhhLnVybCkgJiYgcmVzLnNldChhLnVybCwgMSkpXFxuICAgICAgICB9XFxuICAgICAgICBsZXQgZHVvc2VsZWN0ID0gc3RvcmFnZTAuZ2V0TXlWYXIoXFxcImR1b3NlbGVjdFxcXCIpID8gc3RvcmFnZTAuZ2V0TXlWYXIoXFxcImR1b3NlbGVjdFxcXCIpIDogW107XFxuICAgICAgICBpZiAoZHVvc2VsZWN0LmZpbmRJbmRleCh4ID0+IHgudXJsID09PSBkYXRhdXJsKSA9PSAtMSkge1xcbiAgICAgICAgICAgIGR1b3NlbGVjdC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IGRhdGF0aXRsZSxcXG4gICAgICAgICAgICAgICAgdXJsOiBkYXRhdXJsXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICBkdW9zZWxlY3QgPSB1bmlxdWUoZHVvc2VsZWN0KVxcbiAgICAgICAgICAgIHVwZGF0ZUl0ZW0oZGF0YXVybCwge1xcbiAgICAgICAgICAgICAgICB0aXRsZTogYOKAnOKAnOKAneKAnTxzcGFuIHN0eWxlPVxcXCJjb2xvcjojRkY1NzMzXFxcIj5gICsgZGF0YXRpdGxlXFxuICAgICAgICAgICAgICAgIC8vdGl0bGU6YOKAmOKAmGArZGF0YXRpdGxlK2DigJnigJlgXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlbW92ZUJ5VmFsdWUoYXJyLCB2YWwpIHtcXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcnJbaV1bJ3VybCddID09IHZhbCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyci5zcGxpY2UoaSwgMSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmVtb3ZlQnlWYWx1ZShkdW9zZWxlY3QsIGRhdGF1cmwpXFxuICAgICAgICAgICAgdXBkYXRlSXRlbShkYXRhdXJsLCB7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiBkYXRhdGl0bGVcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICAgIHN0b3JhZ2UwLnB1dE15VmFyKFxcXCJkdW9zZWxlY3RcXFwiLCBkdW9zZWxlY3QpO1xcbiAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL2VtcHR5XFxcIlxcbiAgICB9LCBuYW1lLCBpZClcXG59XFxuXFxuJC5leHRlbmQoe1xcbiAgICBtc206IE11bHRpU2VsZWN0TW9kZSxcXG59KVwifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwi5o6o6YCBXCIsXCJwYXRoXCI6XCJwdXNoXCIsXCJydWxlXCI6XCJqczpcXG5sZXQgaXRlbXMgPSBbXTtcXG5sZXQgcHVzaGluID0gZGVjb2RlVVJJQ29tcG9uZW50KGdldFBhcmFtKFxcXCJwdXNodXJsXFxcIikpO1xcbmxldCB0dmlwID0gZ2V0SXRlbSgnaGlrZXJ0dmJveHNldCcsICcnKTtcXG5cXG5pdGVtcy5wdXNoKHtcXG4gICAgdGl0bGU6ICflvZPliY1JUO+8micgKyB0dmlwLFxcbiAgICB1cmw6IFxcXCJpbnB1dDovL1xcXCIgKyBnZXRJdGVtKCdoaWtlcnR2Ym94c2V0JywgJ2h0dHA6Ly8nICsgZ2V0SVAoKSArICc6OTk3OCcpICsgXFxcIi8vLy/or7fovpPlhaVUVkJveOerr+eahElQ5Zyw5Z2A77yM5aaCaHR0cDovL1xcXCIgKyBnZXRJUCgpICsgXFxcIjo5OTc4LmpzOnNldEl0ZW0oJ2hpa2VydHZib3hzZXQnLGlucHV0KTtyZWZyZXNoUGFnZSgpXFxcIixcXG4gICAgY29sX3R5cGU6ICdmbGV4X2J1dHRvbidcXG59KTtcXG52YXIgcHVybCA9IHB1c2hpbjtcXG5cXG5pZiAocHVzaGluLmluY2x1ZGVzKCdcXFxcbicpICYmICFwdXNoaW4uc3RhcnRzV2l0aCgneycpKSB7XFxuICAgIHB1cmwgPSBwdXNoaW4ucmVwbGFjZShcXFwiXFxcXG5cXFwiLCAnJCcpO1xcbn1cXG5pZiAocHVzaGluLnN0YXJ0c1dpdGgoJ2h0dHAnKSAmJiBwdXNoaW4uaW5jbHVkZXMoJzt7JykpIHtcXG4gICAgcHVybCA9IEpTT04uc3RyaW5naWZ5KHtcXG4gICAgICAgIFxcXCJuYW1lXFxcIjogXFxcIua1t+mYlOebtOmTvuaOqOmAgVxcXCIsXFxuICAgICAgICBcXFwidXJsXFxcIjogcHVzaGluXFxuICAgIH0pXFxufVxcbmlmIChwdXNoaW4uc3RhcnRzV2l0aCgnaHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tL3MvJykpIHtcXG4gICAgbGV0IHJlZnRva2VuID0gSlNPTi5wYXJzZShmZXRjaCgnaGlrZXI6Ly9maWxlcy9ydWxlcy9pY3kvaWN5LWFsaS10b2tlbi5qc29uJywge30pKVswXS5yZWZyZXNoX3Rva2VuO1xcbiAgICBwdXJsID0gSlNPTi5zdHJpbmdpZnkoe1xcbiAgICAgICAgXFxcInVybFxcXCI6IHB1c2hpbixcXG4gICAgICAgIFxcXCJyZWZyZXNoX3Rva2VuXFxcIjogcmVmdG9rZW5cXG4gICAgfSlcXG59XFxuaWYgKHB1c2hpbi5pbmNsdWRlcygnOjUyMDIwJykpIHtcXG4gICAgaWYgKHB1c2hpbi5pbmNsdWRlcygncmVkaXJlY3RQbGF5VXJsJykpIHtcXG4gICAgICAgIHB1cmwgPSBKU09OLnN0cmluZ2lmeSh7XFxuICAgICAgICAgICAgXFxcIm5hbWVcXFwiOiBcXFwi5rW36ZiU5oqV5bGP55u06ZO+XFxcIixcXG4gICAgICAgICAgICBcXFwidXJsXFxcIjogcHVzaGluXFxuICAgICAgICB9KVxcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgcHVybCA9IEpTT04uc3RyaW5naWZ5KHtcXG4gICAgICAgICAgICBcXFwibmFtZVxcXCI6IFxcXCLmtbfpmJTnvZHpobXmipXlsY9cXFwiLFxcbiAgICAgICAgICAgIFxcXCJ1cmxcXFwiOiBwdXNoaW5cXG4gICAgICAgIH0pXFxuICAgIH1cXG59XFxuXFxuLy9sb2coJ+aOqOmAgScrcHVybCk7XFxudmFyIHN0YXRlID0gcmVxdWVzdCh0dmlwICsgJy9hY3Rpb24nLCB7XFxuICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcXG4gICAgICAgIC8vJ1gtUmVxdWVzdGVkLVdpdGgnOiAnWE1MSHR0cFJlcXVlc3QnLFxcbiAgICAgICAgJ1JlZmVyZXInOiB0dmlwXFxuICAgIH0sXFxuICAgIHRpbWVvdXQ6IDIwMDAsXFxuICAgIGJvZHk6ICdkbz1wdXNoJnVybD0nICsgcHVybC5yZXBsYWNlKC9cXFxcJi9nLCAn77yG77yGJyksXFxuICAgIG1ldGhvZDogJ1BPU1QnXFxufSk7XFxuLy9sb2coc3RhdGUpO1xcbmlmIChzdGF0ZSA9PSAnb2snKSB7XFxuICAgIC8vbG9nKHN0YXRlKTtcXG4gICAgaXRlbXMucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIuKchVxcXCIgKyBzdGF0ZSxcXG4gICAgICAgIHVybDogJCgnJykubGF6eVJ1bGUoKCkgPT4ge1xcbiAgICAgICAgICAgIGJhY2soZmFsc2UpO1xcbiAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXG4gICAgICAgIH0pLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0X2NlbnRlcl8xXFxcIlxcbiAgICB9KTtcXG59IGVsc2Uge1xcbiAgICAvL2xvZyhzdGF0ZSk7XFxuICAgIGl0ZW1zLnB1c2goe1xcbiAgICAgICAgdGl0bGU6IFxcXCLinY5cXFwiICsgc3RhdGUsXFxuICAgICAgICB1cmw6IFxcXCJoaWtlcjovL2VtcHR5XFxcIixcXG4gICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF9jZW50ZXJfMVxcXCJcXG4gICAgfSk7XFxuXFxufVxcbnNldFJlc3VsdChpdGVtcyk7XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLorr7nva5cIixcInBhdGhcIjpcInNldHRpbmdcIixcInJ1bGVcIjpcImpzOlxcbnZhciBkPVtdXFxuaWYgKE1ZX1BBR0UgPT0gMSkge1xcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6ICforr7nva5JUOWcsOWdgCcsXFxuICAgICAgICB1cmw6IFxcXCJpbnB1dDovL1xcXCIgKyBnZXRJdGVtKCdoaWtlcnR2Ym94c2V0JywgJ2h0dHA6Ly8nICsgZ2V0SVAoKSArICc6OTk3OCcpICsgXFxcIi8vLy/or7fovpPlhaV0dmJveOaOqOmAgUlQ5Zyw5Z2A77yM5aaCaHR0cDovL1xcXCIgKyBnZXRJUCgpICsgXFxcIjo5OTc4LmpzOnNldEl0ZW0oJ2hpa2VydHZib3hzZXQnLGlucHV0KTtyZWZyZXNoUGFnZSgpXFxcIixcXG4gICAgICAgIGNvbF90eXBlOiAnZmxleF9idXR0b24nXFxuICAgIH0pO1xcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6IGdldEl0ZW0oJ2hpa2VydHZib3hzZXQnLCAnJyksXFxuICAgICAgICB1cmw6ICdoaWtlcjovL2VtcHR5JyxcXG4gICAgICAgIGNvbF90eXBlOiAnZmxleF9idXR0b24nXFxuICAgIH0pO1xcbn1cXG5cXG5zZXRSZXN1bHQoZClcIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIng1YWlcIixcInBhdGhcIjpcIng1YWlcIixcInJ1bGVcIjpcIiQuZXhwb3J0cyA9IGZ1bmN0aW9uKHJ1bGUsIGFuY2hvcklkKSB7XFxuICAgIHJldHVybiAkLnRvU3RyaW5nKChydWxlLCBhbmNob3JJZCwgbW9iYW4pID0+IHtcXG4gICAgICAgIGlmICh3aW5kb3cuY2hlY2swID09IG51bGwpIHtcXG4gICAgICAgICAgICBmdW5jdGlvbiBjaGVjazAoKSB7XFxuICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICBsZXQgaHRtbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXFxcImh0bWxcXFwiKS5pbm5lckhUTUw7XFxuICAgICAgICAgICAgICAgICAgICBmYmEucHV0VmFyKFxcXCJodG1sMFxcXCIsIGh0bWwpO1xcbiAgICAgICAgICAgICAgICAgICAgZmJhLnBhcnNlTGF6eVJ1bGVBc3luYygkJCQoKS5sYXp5UnVsZSgocnVsZSwgdXJsLCBhbmNob3JJZCwgbW9iYW4pID0+IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGh0bWwgPSBnZXRWYXIoXFxcImh0bWwwXFxcIiwgXFxcIlxcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXVybCA9ICcnO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclZhcihcXFwiaHRtbDBcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9sb2coJ3VybDonICsgdXJsKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXJsLnN0YXJ0c1dpdGgoJ2h0dHBzOi8vY3VwZm94LmFwcC9wYWdlP3VybD0nKSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2V1cmwgPSB1cmwucmVwbGFjZSgvLit1cmw9KC4qPykmLisvZ20sICckMScpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdXJsID0gYmFzZTY0RGVjb2RlKGJhc2V1cmwpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXRWYXIoJ2lmcmFtZScsIGl1cmwpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2coJ2l1cmw6JyArIGl1cmwpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl1cmwubGVuZ3RoID4gMCA/IFxcXCIxXFxcIiA6IFxcXCIwXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZyhlLnRvU3RyaW5nKCkpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH0sIHJ1bGUsIGxvY2F0aW9uLmhyZWYsIGFuY2hvcklkLCBtb2JhbiksICQkJC50b1N0cmluZygocnVsZSxtb2JhbikgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZmJhLmxvZyhpbnB1dClcXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2ZiYS5sb2cocnVsZSlcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXFxcIjBcXFwiID09IGlucHV0KSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jaGVja2MgPSB3aW5kb3cuY2hlY2tjICsgMTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyppZiAod2luZG93LmNoZWNrYyA+IDEyMCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmJhLmxvZyhcXFwi5omn6KGM6LaF6L+HMzDnp5LvvIzml6Dms5Xop6PmnpBcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsqL1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHdpbmRvdy5jaGVjazAsIDI1MCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfVxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cmwgPSBmYmEuZ2V0VmFyKCdpZnJhbWUnKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmJhLmxvZygnbW9iYW4nK21vYmFuKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihtb2Jhbj09JzEnKXtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybD11cmwrJyNpbW1lcnNpdmVUaGVtZSMnXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmJhLmxvZyh1cmwpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZiYS5vcGVuKEpTT04uc3RyaW5naWZ5KHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IHJ1bGUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ+W9seeJh+ivpuaDhScsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cDogXFxcIlxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVSdWxlOiBcXFwiXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VzOiBcXFwiXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJ2hpa2VyOi8vcGFnZS9wP3J1bGU9JyArIHJ1bGUgKyAnJnU9JyArIHVybCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmRSdWxlOiBcXFwiXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jaGVja3VybCA9IGxvY2F0aW9uLmhyZWY7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNoZWNrdTAoKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2luZG93LmNoZWNrdXJsICE9IGxvY2F0aW9uLmhyZWYpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2hhc2jlj5HnlJ/kuoblj5jljJZcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY2hlY2tjID0gMDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2swKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMjAwMCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY2hlY2t1MCwgMjUwKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja3UwKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgfSxydWxlLG1vYmFuKSk7XFxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgICAgICAgICAgIGZiYS5sb2coZS50b1N0cmluZygpKTtcXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQod2luZG93LmNoZWNrMCwgMjUwKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB3aW5kb3cuY2hlY2tjID0gMDtcXG4gICAgICAgICAgICB3aW5kb3cuY2hlY2swID0gY2hlY2swO1xcbiAgICAgICAgICAgIGNoZWNrMCgpO1xcbiAgICAgICAgfVxcbiAgICB9LCBydWxlLCBhbmNob3JJZCwgZ2V0SXRlbSgnYWknLCcwJykpO1xcbn1cIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIjUu6Iy25p2v6JmOXCIsXCJwYXRoXCI6XCJhaW9iYlwiLFwicnVsZVwiOlwianM6XFxubGV0IGR1cmwgPSBnZXRNeVZhcihcXFwiZHVybFxcXCIsIFxcXCJcXFwiKTtcXG5pZiAoZHVybCAhPSAnJykge1xcbiAgICBNWV9VUkwgPSBkdXJsXFxuICAgIGxvZyhkdXJsKVxcblxcbiAgICBsZXQgdXJsID0gZHVybDtcXG4gICAgbGV0IGlkID0gdXJsO1xcbiAgICB0cnkge1xcbiAgICAgICAgdmFyIGh0bWwgPSBmZXRjaCh1cmwpO1xcbiAgICB9IGNhdGNoIHtcXG4gICAgICAgIHZhciBodG1sID0gJydcXG4gICAgfVxcbiAgICB2YXIgcnVsZSA9IE1ZX1JVTEUudGl0bGVcXG4gICAgaWYgKGh0bWwgPT0gdW5kZWZpbmVkIHx8IGh0bWwgPT0gJycpIHtcXG4gICAgICAgIHRvYXN0KCfml6DmlbDmja4nKVxcbiAgICAgICAgY2xlYXJNeVZhcihcXFwic291XFxcIik7XFxuICAgICAgICBjbGVhck15VmFyKFxcXCJkdXJsXFxcIik7XFxuICAgICAgICByZWZyZXNoUGFnZSgpXFxuICAgIH0gZWxzZSB7XFxuXFxuICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiBwZGZoKGh0bWwsICdoNCYmVGV4dCcpLFxcbiAgICAgICAgICAgIGltZzogcGQoaHRtbCwgJ2ltZyYmc3JjJyksXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdtb3ZpZV8xX3ZlcnRpY2FsX3BpYycsXFxuICAgICAgICAgICAgZGVzYzogcGRmaChodG1sLCAnYm9keSYmLnB1YlRpbWUmJlRleHQnKSxcXG4gICAgICAgICAgICB1cmw6IHVybCxcXG4gICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICBpZDogdXJsLFxcbiAgICAgICAgICAgICAgICBpbmhlcml0VGl0bGU6IGZhbHNlXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSlcXG5cXG5cXG4gICAgICAgIHZhciBsaXN0ID0gcGRmYShodG1sLCAnLm1vdmllWnkmJmEnKVxcbiAgICAgICAgaWYgKGxpc3QgJiYgbGlzdC5sZW5ndGggPiAwKSB7XFxuICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgTVlfVVJMID0gXFxcIlxcXCI7XFxuICAgICAgICAgICAgICAgIGxldCB7XFxuICAgICAgICAgICAgICAgICAgICBtZXJnZVxcbiAgICAgICAgICAgICAgICB9ID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvdG9vbD9ydWxlPVxcXCIgKyBydWxlKTtcXG4gICAgICAgICAgICAgICAgbGlzdCA9IGxpc3QubWFwKGl0ID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gcGRmaChpdCwgJ2EmJmhyZWYnKTtcXG4gICAgICAgICAgICAgICAgICAgIGxldCB0ID0gcGRmaChpdCwgJ3VsJiZUZXh0Jyk7XFxuICAgICAgICAgICAgICAgICAgICB1ID0gXFxcImhpa2VyOi8vcGFnZS9wP3J1bGU9XFxcIiArIHJ1bGUgKyBcXFwiJnU9XFxcIiArIGJhc2U2NEVuY29kZSh1KTtcXG4gICAgICAgICAgICAgICAgICAgIHUgPSBnZXRJdGVtKCdhaScsICcwJykgPT0gJzAnID8gdSA6IHUgKyAnI2ltbWVyc2l2ZVRoZW1lIydcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IG1lcmdlKHQsICfor6bmg4UnLCAxKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWc6ICdodHRwczovL3d3dy43MjU5OTguY29tL3N0YXRpYy9zZWFyY2gvaW1hZ2VzL29uTGluZS5wbmcnLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwiYXZhdGFyXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5oZXJpdFRpdGxlOiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xzOiB1cmwsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb206ICdob21lJyxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICBkID0gZC5jb25jYXQobGlzdClcXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICAgICAgICAgIGxvZyhlLnRvU3RyaW5nKCkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6ICfml6DotYTmupAnLFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogJ3RleHRfY2VudGVyXzEnLFxcbiAgICAgICAgICAgIH0pXFxuICAgICAgICB9XFxuICAgICAgICBzZXRSZXN1bHQoZClcXG4gICAgfVxcblxcbn1cXG5zID0gZ2V0TXlWYXIoXFxcInNvdVxcXCIsIFxcXCJcXFwiKTtcXG5cXG5sZXQgciA9IFxcXCJcXFwiO1xcbmlmIChzICE9IFxcXCJcXFwiKSB7XFxuXFxuICAgIHZhciB1cmwgPSBwb3N0KGBodHRwczovL3d3dy43MjU5OTguY29tL2tleXdvcmRzLmh0bWxgLCB7XFxuICAgICAgICBib2R5OiB7XFxuICAgICAgICAgICAga2V5d29yZHM6IHMsXFxuICAgICAgICAgICAgdHlwZTogJ21vdmllJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIG9ubHlIZWFkZXJzOiB0cnVlXFxuICAgIH0pXFxuICAgIHZhciBqc29uID0gSlNPTi5wYXJzZSh1cmwpXFxuICAgIHZhciB0dXJsID0ganNvbi51cmwucmVwbGFjZSgvLVxcXFxkKy5odG1sJC8sICctJyArIE1ZX1BBR0UgKyAnLmh0bWwnKVxcbiAgICBNWV9VUkwgPSB0dXJsXFxuICAgIHZhciBodG1sID0gZmV0Y2godHVybClcXG5cXG4gICAgdmFyIGxpc3QgPSBwZGZhKGh0bWwsICdib2R5JiYuZWFjaCcpXFxuICAgIC8vbG9nKGxpc3QpXFxuXFxuICAgIGxldCB7XFxuICAgICAgICB3cmFwXFxuICAgIH0gPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS90b29sXFxcIik7XFxuXFxuICAgIGZvciAobGV0IGl0IG9mIGxpc3QpIHtcXG4gICAgICAgIGxldCBuYW1lID0gcGRmaChpdCwgJ2EmJnRpdGxlJyk7XFxuICAgICAgICBsZXQgaW1nID0gcGQoaXQsICdpbWcmJnNyYycpO1xcbiAgICAgICAgaWYgKGltZyA9PSBcXFwiXFxcIikge1xcbiAgICAgICAgICAgIGltZyA9IFxcXCJodHRwczovL3d3dy43MjU5OTguY29tL3N0YXRpYy9zZWFyY2gvaW1hZ2VzL3ByZWxvYWRJbWcucG5nXFxcIjtcXG4gICAgICAgIH1cXG4gICAgICAgIGxldCB1cmwgPSBwZChpdCwgJ2EmJmhyZWYnKTtcXG4gICAgICAgIGxldCBkZXNjID0gcGRmYShpdCwgJ2JvZHkmJi5pbmZvJiZhJykubWFwKHggPT4gcGRmaCh4LCAnYSYmVGV4dCcpKS5qb2luKCcgJyk7XFxuICAgICAgICBsZXQgc2NvcmUgPSBwZGZoKGl0LCAnLm5vU2NvcmUmJlRleHQnKTtcXG4gICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6IHdyYXAobmFtZSwgcyksXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdtb3ZpZV8xX3ZlcnRpY2FsX3BpYycsXFxuICAgICAgICAgICAgaW1nOiBpbWcsXFxuICAgICAgICAgICAgZGVzYzogJ+ivhOWIhjonICsgc2NvcmUgKyAnXFxcXG4nICsgZGVzYyxcXG4gICAgICAgICAgICB1cmw6ICQodXJsKS5sYXp5UnVsZSgocnVsZSwgdXJsLCBzKSA9PiB7XFxuICAgICAgICAgICAgICAgIHZhciBjbHMgPSBmaW5kSXRlbXNCeUNscyh1cmwpO1xcbiAgICAgICAgICAgICAgICBpZiAoISFjbHMpIHtcXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZUl0ZW1CeUNscyh1cmwpXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICBsZXQgdXJsID0gaW5wdXQ7XFxuICAgICAgICAgICAgICAgICAgICBsZXQgaWQgPSB1cmw7XFxuICAgICAgICAgICAgICAgICAgICBsZXQgaHRtbCA9IGZldGNoKHVybCk7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgbGlzdCA9IHBkZmEoaHRtbCwgJy5tb3ZpZVp5JiZhJylcXG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ICYmIGxpc3QubGVuZ3RoID4gMCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1ZX1VSTCA9IFxcXCJcXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL3Rvb2w/cnVsZT1cXFwiICsgcnVsZSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QgPSBsaXN0Lm1hcChpdCA9PiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IHBkZmgoaXQsICdhJiZocmVmJyk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdCA9IHBkZmgoaXQsICd1bCYmVGV4dCcpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdSA9IFxcXCJoaWtlcjovL3BhZ2UvcD9ydWxlPVxcXCIgKyBydWxlICsgXFxcIiZ1PVxcXCIgKyBiYXNlNjRFbmNvZGUodSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ID0gZ2V0SXRlbSgnYWknLCAnMCcpID09ICcwJyA/IHUgOiB1ICsgJyNpbW1lcnNpdmVUaGVtZSMnXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBtZXJnZSh0LCAn6K+m5oOFJywgMSksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1nOiAnaHR0cHM6Ly93d3cuNzI1OTk4LmNvbS9zdGF0aWMvc2VhcmNoL2ltYWdlcy9vbkxpbmUucG5nJyxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcImF2YXRhclxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaGVyaXRUaXRsZTogZmFsc2UsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsczogdXJsLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiAnaG9tZScsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkSXRlbUFmdGVyKGlkLCBsaXN0KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZyhlLnRvU3RyaW5nKCkpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkSXRlbUFmdGVyKGlkLCB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiAn5peg6LWE5rqQJyxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJyxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsczogdXJsLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiXFxuICAgICAgICAgICAgfSwgTVlfUlVMRS50aXRsZSwgdXJsLCBzKSxcXG4gICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICBpZDogdXJsLFxcbiAgICAgICAgICAgICAgICBpbmhlcml0VGl0bGU6IGZhbHNlXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSlcXG4gICAgfVxcblxcbiAgICBzZXRSZXN1bHQoZClcXG59IGVsc2Uge1xcblxcbn1cXG5cXG5pZiAoZ2V0SXRlbSgnaG9tZScsICflhbMnKSA9PSAn5byAJykge1xcbiAgICBmdW5jdGlvbiBzZXRMaXN0cyhpdGVtKSB7XFxuICAgICAgICBNWV9VUkwgPSAnaHR0cHM6Ly93d3cuNzI1OTk4LmNvbS8nO1xcbiAgICAgICAgdmFyIHRpdGxlID0gaXRlbS5zcGxpdCgnIycpWzBdXFxuICAgICAgICB2YXIga2V5ID0gaXRlbS5zcGxpdCgnIycpWzFdXFxuICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ2F2YXRhcicsXFxuICAgICAgICAgICAgaW1nOiAnaHR0cHM6Ly9sYW5tZWlndW9qaWFuZy5jb20vdHViaWFvL21vcmUvMTAucG5nJ1xcbiAgICAgICAgfSlcXG5cXG4gICAgICAgIHZhciBodG1sID0gZmV0Y2goYGh0dHBzOi8vd3d3LjcyNTk5OC5jb20veWluZ2t1LWxpc3QvJHtrZXl9LTAtMC0wLTAtMC0wLmh0bWxgKVxcbiAgICAgICAgdmFyIGxpc3QgPSBwZGZhKGh0bWwsICdib2R5JiYuZWFjaCcpXFxuXFxuICAgICAgICBsaXN0Lm1hcCh4ID0+IHtcXG4gICAgICAgICAgICB2YXIgbmFtZSA9IHBkZmgoeCwgJ2EmJnRpdGxlJylcXG4gICAgICAgICAgICBsZXQgaW1nID0gcGQoeCwgJ2ltZyYmc3JjJyk7XFxuICAgICAgICAgICAgaWYgKGltZyA9PSBcXFwiXFxcIikge1xcbiAgICAgICAgICAgICAgICBpbWcgPSBcXFwiaHR0cHM6Ly93d3cuNzI1OTk4LmNvbS9zdGF0aWMvc2VhcmNoL2ltYWdlcy9wcmVsb2FkSW1nLnBuZ1xcXCI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGxldCB1cmwgPSBwZCh4LCAnYSYmaHJlZicpO1xcbiAgICAgICAgICAgIGxldCBzY29yZSA9IHBkZmgoeCwgJy5ub1Njb3JlJiZUZXh0Jyk7XFxuICAgICAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IG5hbWUsXFxuICAgICAgICAgICAgICAgIGltZzogaW1nLFxcbiAgICAgICAgICAgICAgICBkZXNjOiBzY29yZSxcXG4gICAgICAgICAgICAgICAgdXJsOiAkKCcnKS5sYXp5UnVsZSgobiwgdSkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcInNvdVxcXCIsIG4pXFxuICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcignZHVybCcsIHUpXFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgICAgICAgICAgICAgIH0sIG5hbWUsIHVybClcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgfSlcXG4gICAgfVxcblxcbiAgICBbJ+eUteW9sSMxJywgJ+eUteinhuWJpyMyJywgJ+WKqOa8qyMzJywgJ+e6quW9leeJhyM0J10ubWFwKHggPT4ge1xcblxcbiAgICAgICAgc2V0TGlzdHMoeClcXG4gICAgfSlcXG59XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCI2LueUteW9seeLl1wiLFwicGF0aFwiOlwiZHlkb2dcIixcInJ1bGVcIjpcImpzOlxcbk1ZX1VSTD0naHR0cHM6Ly93d3cuZGlhbnlpbmdnb3UuY29tL3NvTW9yZS9hbGwtYWxsLWFsbC1hbGwtJztcXG5sZXQgZHVybCA9IGdldE15VmFyKFxcXCJkdXJsXFxcIiwgXFxcIlxcXCIpO1xcbmlmIChkdXJsICE9ICcnKSB7XFxuICAgIC8vbG9nKGR1cmwpXFxuXFxuICAgIGxldCB1cmwgPSBkdXJsO1xcbiAgICBsZXQgaWQgPSB1cmw7XFxuICAgIGxldCBuYW1lID0gcztcXG4gICAgdHJ5IHtcXG4gICAgICAgIHZhciBodG1sID0gZmV0Y2godXJsKTtcXG4gICAgfSBjYXRjaCB7XFxuICAgICAgICB2YXIgaHRtbCA9ICcnXFxuICAgIH1cXG4gICAgdmFyIHJ1bGUgPSBNWV9SVUxFLnRpdGxlXFxuXFxuICAgIGQucHVzaCh7XFxuICAgICAgICB0aXRsZTogcGRmaChodG1sLCAnaDQmJlRleHQnKSxcXG4gICAgICAgIGltZzogcGRmaChodG1sLCAnaW1nJiZkYXRhLXVybCcpLFxcbiAgICAgICAgY29sX3R5cGU6ICdtb3ZpZV8xX3ZlcnRpY2FsX3BpYycsXFxuICAgICAgICBkZXNjOiBwZGZoKGh0bWwsICdib2R5JiYucHViVGltZSYmVGV4dCcpLFxcbiAgICAgICAgdXJsOiB1cmwsXFxuICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgIGlkOiB1cmwsXFxuICAgICAgICAgICAgaW5oZXJpdFRpdGxlOiBmYWxzZVxcbiAgICAgICAgfVxcbiAgICB9KVxcblxcbiAgICBsZXQgaHRtbCA9IGZldGNoKGBodHRwczovL3d3dy5kaWFueWluZ2dvdS5jb20vU3BpZGVyTW92aWUvenkvJHtuYW1lfWAsIHtcXG4gICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAneC1yZXF1ZXN0ZWQtd2l0aCc6ICdYTUxIdHRwUmVxdWVzdCdcXG4gICAgICAgIH1cXG4gICAgfSk7XFxuXFxuICAgIHZhciBsaXN0ID0gcGRmYShodG1sLCAnLm1vdmllWnkmJmEnKVxcbiAgICBpZiAobGlzdCAmJiBsaXN0Lmxlbmd0aCA+IDApIHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgTVlfVVJMID0gXFxcIlxcXCI7XFxuICAgICAgICAgICAgbGV0IHtcXG4gICAgICAgICAgICAgICAgd3JhcDFcXG4gICAgICAgICAgICB9ID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvdG9vbD9ydWxlPVxcXCIgKyBydWxlKTtcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICBsaXN0ID0gbGlzdC5tYXAoaXQgPT4ge1xcbiAgICAgICAgICAgICAgICBsZXQgdSA9IHBkZmgoaXQsICdhJiZocmVmJyk7XFxuICAgICAgICAgICAgICAgIGxldCB0ID0gcGRmaChpdCwgJ2xpLDAmJlRleHQnKTtcXG4gICAgICAgICAgICAgICAgbGV0IHdlYj1wZGZoKGl0LCAnbGksMSYmVGV4dCcpO1xcbiAgICAgICAgICAgICAgICB1ID0gXFxcImhpa2VyOi8vcGFnZS9wP3J1bGU9XFxcIiArIHJ1bGUgKyBcXFwiJnU9XFxcIiArIGJhc2U2NEVuY29kZSh1KTtcXG4gICAgICAgICAgICAgICAgdSA9IGdldEl0ZW0oJ2FpJywgJzAnKSA9PSAnMCcgPyB1IDogdSArICcjaW1tZXJzaXZlVGhlbWUjJ1xcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHdyYXAxKHdlYisnLScrdCwgcyksXFxuICAgICAgICAgICAgICAgICAgICBpbWc6ICdodHRwczovL3d3dy43MjU5OTguY29tL3N0YXRpYy9zZWFyY2gvaW1hZ2VzL29uTGluZS5wbmcnLFxcbiAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJhdmF0YXJcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB1LFxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmhlcml0VGl0bGU6IGZhbHNlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsczogdXJsLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VUaXRsZTp0LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlYjp3ZWIsXFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBkID0gZC5jb25jYXQobGlzdClcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgICBsb2coZS50b1N0cmluZygpKTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBzZXRSZXN1bHQoZClcXG59XFxucyA9IGdldE15VmFyKFxcXCJzb3VcXFwiLCBcXFwiXFxcIik7XFxubGV0IHIgPSBcXFwiXFxcIjtcXG5pZiAocyAhPSBcXFwiXFxcIikge1xcbiAgICB2YXIgcGFnZSA9IE1ZX1BBR0U7XFxuICAgIHZhciB1cmwgPSBgaHR0cHM6Ly93d3cuZGlhbnlpbmdnb3UuY29tL3NvLyR7c30vcGFnZV8ke3BhZ2V9Lmh0bWxgO1xcbiAgICAvL2xvZyh1cmwpXFxuICAgIHZhciBodG1sID0gZmV0Y2godXJsKVxcblxcbiAgICB2YXIgbGlzdCA9IHBkZmEoaHRtbCwgJ2JvZHkmJi5lYWNoJylcXG4gICAgLy9sb2cobGlzdClcXG5cXG4gICAgbGV0IHtcXG4gICAgICAgIHdyYXBcXG4gICAgfSA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL3Rvb2xcXFwiKTtcXG5cXG4gICAgZm9yIChsZXQgaXQgb2YgbGlzdCkge1xcbiAgICAgICAgbGV0IG5hbWUgPSBwZGZoKGl0LCAnYSYmdGl0bGUnKTtcXG4gICAgICAgIGxldCBpbWcgPSBwZChpdCwgJ2ltZyYmZGF0YS11cmwnKTtcXG4gICAgICAgIGlmIChpbWcgPT0gXFxcIlxcXCIpIHtcXG4gICAgICAgICAgICBpbWcgPSBcXFwiaHR0cHM6Ly93d3cuZGlhbnlpbmdnb3UuY29tL1ZpZXcvaW1hZ2VzL2JsYW5rX2JnLnBuZ1xcXCI7XFxuICAgICAgICB9XFxuICAgICAgICBsZXQgdXJsID0gcGQoaXQsICdhJiZocmVmJyk7XFxuICAgICAgICBsZXQgZGVzYyA9IHBkZmEoaXQsICdib2R5JiYuaW5mbyYmYScpLm1hcCh4ID0+IHBkZmgoeCwgJ2EmJlRleHQnKSkuam9pbignICcpO1xcbiAgICAgICAgbGV0IHNjb3JlID0gcGRmaChpdCwgJy5ub1Njb3JlJiZUZXh0Jyk7XFxuICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiB3cmFwKG5hbWUsIHMpLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiAnbW92aWVfMV92ZXJ0aWNhbF9waWMnLFxcbiAgICAgICAgICAgIGltZzogaW1nLFxcbiAgICAgICAgICAgIGRlc2M6ICfor4TliIY6JyArIHNjb3JlICsgJ1xcXFxuJyArIGRlc2MsXFxuICAgICAgICAgICAgdXJsOiAkKHVybCkubGF6eVJ1bGUoKHJ1bGUsIHVybCwgcywgbmFtZSkgPT4ge1xcbiAgICAgICAgICAgICAgICB2YXIgY2xzID0gZmluZEl0ZW1zQnlDbHModXJsKTtcXG4gICAgICAgICAgICAgICAgaWYgKCEhY2xzKSB7XFxuICAgICAgICAgICAgICAgICAgICBkZWxldGVJdGVtQnlDbHModXJsKVxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgbGV0IHVybCA9IGlucHV0O1xcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlkID0gdXJsO1xcbiAgICAgICAgICAgICAgICAgICAgbGV0IGh0bWwgPSBmZXRjaChgaHR0cHM6Ly93d3cuZGlhbnlpbmdnb3UuY29tL1NwaWRlck1vdmllL3p5LyR7bmFtZX1gLCB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAneC1yZXF1ZXN0ZWQtd2l0aCc6ICdYTUxIdHRwUmVxdWVzdCdcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgICAgIHZhciBsaXN0ID0gcGRmYShodG1sLCAnLm1vdmllWnkmJmEnKVxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3QgJiYgbGlzdC5sZW5ndGggPiAwKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTVlfVVJMID0gXFxcIlxcXCI7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cmFwMVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvdG9vbD9ydWxlPVxcXCIgKyBydWxlKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdCA9IGxpc3QubWFwKGl0ID0+IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB1ID0gcGRmaChpdCwgJ2EmJmhyZWYnKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ID0gcGRmaChpdCwgJ2xpLDAmJlRleHQnKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB3ZWI9cGRmaChpdCwgJ2xpLDEmJlRleHQnKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUgPSBcXFwiaGlrZXI6Ly9wYWdlL3A/cnVsZT1cXFwiICsgcnVsZSArIFxcXCImdT1cXFwiICsgYmFzZTY0RW5jb2RlKHUpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdSA9IGdldEl0ZW0oJ2FpJywgJzAnKSA9PSAnMCcgPyB1IDogdSArICcjaW1tZXJzaXZlVGhlbWUjJ1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogd3JhcDEod2ViKyctJyt0LCBzKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWc6ICdodHRwczovL3d3dy43MjU5OTguY29tL3N0YXRpYy9zZWFyY2gvaW1hZ2VzL29uTGluZS5wbmcnLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwiYXZhdGFyXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5oZXJpdFRpdGxlOiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xzOiB1cmwsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VUaXRsZTp0LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWI6d2ViLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZEl0ZW1BZnRlcihpZCwgbGlzdCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2coZS50b1N0cmluZygpKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL2VtcHR5XFxcIlxcbiAgICAgICAgICAgIH0sIE1ZX1JVTEUudGl0bGUsIHVybCwgcywgbmFtZSksXFxuICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgaWQ6IHVybCxcXG4gICAgICAgICAgICAgICAgaW5oZXJpdFRpdGxlOiBmYWxzZVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pXFxuICAgIH1cXG5cXG4gICAgc2V0UmVzdWx0KGQpXFxufSBlbHNlIHtcXG5cXG59XFxuXFxuaWYgKGdldEl0ZW0oJ2hvbWUnLCAn5YWzJykgPT0gJ+W8gCcpIHtcXG4gICAgZnVuY3Rpb24gc2V0TGlzdHMoaXRlbSkge1xcbiAgICAgICAgTVlfVVJMID0gJ2h0dHBzOi8vd3d3LmRpYW55aW5nZ291LmNvbS8nO1xcbiAgICAgICAgdmFyIHRpdGxlID0gaXRlbS5zcGxpdCgnIycpWzBdXFxuICAgICAgICB2YXIga2V5ID0gaXRlbS5zcGxpdCgnIycpWzFdXFxuICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ2F2YXRhcicsXFxuICAgICAgICAgICAgaW1nOiAnaHR0cHM6Ly9sYW5tZWlndW9qaWFuZy5jb20vdHViaWFvL21vcmUvMTAucG5nJ1xcbiAgICAgICAgfSlcXG5cXG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoKTtcXG4gICAgICAgIHZhciB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xcbiAgICAgICAgLy92YXIgaHRtbCA9IGZldGNoKGBodHRwczovL3d3dy5kaWFueWluZ2dvdS5jb20vbVJlY29tbWQvJHtrZXl9YCk7XFxuICAgICAgICB2YXIgaHRtbCA9IGZldGNoKGBodHRwczovL3d3dy5kaWFueWluZ2dvdS5jb20vc29Nb3JlLyR7a2V5fS1hbGwtYWxsLSR7eWVhcn0tYCk7XFxuXFxuICAgICAgICB2YXIgbGlzdCA9IHBkZmEoaHRtbCwgJ2JvZHkmJi5lYWNoJylcXG5cXG4gICAgICAgIGxpc3QubWFwKHggPT4ge1xcbiAgICAgICAgICAgIHZhciBuYW1lID0gcGRmaCh4LCAnYSYmdGl0bGUnKVxcbiAgICAgICAgICAgIGxldCBpbWcgPSBwZCh4LCAnaW1nJiZkYXRhLXVybCcpO1xcbiAgICAgICAgICAgIGlmIChpbWcgPT0gXFxcIlxcXCIpIHtcXG4gICAgICAgICAgICAgICAgaW1nID0gXFxcImh0dHBzOi8vd3d3LmRpYW55aW5nZ291LmNvbS9WaWV3L2ltYWdlcy9ibGFua19iZy5wbmdcXFwiO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBsZXQgdXJsID0gcGQoeCwgJ2EmJmhyZWYnKTtcXG4gICAgICAgICAgICBsZXQgc2NvcmUgPSBwZGZoKHgsICcubm9TY29yZSYmVGV4dCcpO1xcbiAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiBuYW1lLFxcbiAgICAgICAgICAgICAgICBpbWc6IGltZyxcXG4gICAgICAgICAgICAgICAgZGVzYzogc2NvcmUsXFxuICAgICAgICAgICAgICAgIHVybDogJCgnJykubGF6eVJ1bGUoKG4sIHUpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXCJzb3VcXFwiLCBuKVxcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoJ2R1cmwnLCB1KVxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKVxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcbiAgICAgICAgICAgICAgICB9LCBuYW1lLCB1cmwpXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgIH0pXFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gaG9tZSgpIHtcXG4gICAgICAgIFsn55S15b2xI21vdmllJywgJ+eUteinhuWJpyN0dicsICfnuqrlvZXniYcjZG9jJywgJ+WKqOa8qyNjb21pYyddLm1hcCh4ID0+IHtcXG5cXG4gICAgICAgICAgICBzZXRMaXN0cyh4KVxcbiAgICAgICAgfSlcXG4gICAgfVxcbiAgICBcXG4gICAgdmFyIHBhZ2U9TVlfUEFHRTtcXG4gICAgbGV0IHRydWVfdXJsID0gZ2V0TXlWYXIoTVlfUlVMRS51cmwsIE1ZX1VSTCk7XFxuICAgIGlmKHBhZ2U+MSl7XFxuICAgICAgICAvL2xvZyh0cnVlX3VybClcXG4gICAgICAgIHRydWVfdXJsPXRydWVfdXJsK2AvcGFnZV8ke3BhZ2V9Lmh0bWxgXFxuICAgICAgICAvL2xvZyh0cnVlX3VybClcXG4gICAgfVxcbiAgICB2YXIgaHRtbCA9ZmV0Y2godHJ1ZV91cmwpLnJlcGxhY2UoJyUnLCcnKTtcXG4gICAgLy9sb2coaHRtbClcXG4gICAgXFxuICAgIFxcbiAgICBjb25zdCDliIbnsbvpopzoibIgPSBnZXRSYW5nZUNvbG9ycygpO1xcbiAgICBjb25zdCDlpKfnsbvlrprkvY0gPSAnLndfMTAwJztcXG4gICAgY29uc3Qg5ou85o6l5YiG57G7ID0gJ2JvZHkmJi55X2ZpbHRlck1lbnU6bnRoLWNoaWxkKG4rMik+ZGl2PmRpdic7XFxuICAgIGNvbnN0IOWwj+exu+WumuS9jSA9ICdib2R5JiZhOm5vdCg6bWF0Y2hlcyjliIbnsbspKSc7XFxuICAgIGNvbnN0IOWIhuexu+agh+mimCA9ICdhJiZUZXh0JztcXG4gICAgY29uc3Qg5YiG57G76ZO+5o6lID0gJ2EmJmhyZWYnO1xcblxcbiAgICAvL+WKqOaAgeWIhuexu1xcbiAgICBldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL2R0ZmwnKSkucnVsZSk7XFxuICAgIFxcbiAgICB2YXIgbGlzdCA9IHBkZmEoaHRtbCwgJ2JvZHkmJi5lYWNoJylcXG5cXG4gICAgbGlzdC5tYXAoeCA9PiB7XFxuICAgICAgICB2YXIgbmFtZSA9IHBkZmgoeCwgJ2EmJnRpdGxlJylcXG4gICAgICAgIGxldCBpbWcgPSBwZCh4LCAnaW1nJiZzcmN8fGltZyYmZGF0YS11cmwnKTtcXG4gICAgICAgIGlmIChpbWcgPT0gXFxcIlxcXCIpIHtcXG4gICAgICAgICAgICBpbWcgPSBcXFwiaHR0cHM6Ly93d3cuZGlhbnlpbmdnb3UuY29tL1ZpZXcvaW1hZ2VzL2JsYW5rX2JnLnBuZ1xcXCI7XFxuICAgICAgICB9XFxuICAgICAgICBsZXQgdXJsID0gcGQoeCwgJ2EmJmhyZWYnKTtcXG4gICAgICAgIGxldCBzY29yZSA9IHBkZmgoeCwgJy5ub1Njb3JlJiZUZXh0Jyk7XFxuICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiBuYW1lLFxcbiAgICAgICAgICAgIGltZzogaW1nLFxcbiAgICAgICAgICAgIGRlc2M6IHNjb3JlLFxcbiAgICAgICAgICAgIHVybDogJCgnJykubGF6eVJ1bGUoKG4sIHUpID0+IHtcXG4gICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcInNvdVxcXCIsIG4pXFxuICAgICAgICAgICAgICAgIHB1dE15VmFyKCdkdXJsJywgdSlcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKVxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgICAgICAgICAgfSwgbmFtZSwgdXJsKVxcbiAgICAgICAgfSlcXG4gICAgfSlcXG59XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLliqjmgIHliIbnsbtcIixcInBhdGhcIjpcImR0ZmxcIixcInJ1bGVcIjpcImpzOlxcbmNvbnN0wqBlbXB0ecKgPcKgXFxcImhpa2VyOi8vZW1wdHlcXFwiXFxuXFxuaWbCoCh0eXBlb2Yo5ou85o6l5YiG57G7KcKgIT3CoCd1bmRlZmluZWQnwqAmJsKg5ou85o6l5YiG57G7wqAhPcKgJycpwqB7XFxuwqDCoMKgwqB2YXLCoGNhdGVnb3JpZXPCoD3CoHBkZmEoaHRtbCzCoOWkp+exu+WumuS9jSkuY29uY2F0KHBkZmEoaHRtbCzCoOaLvOaOpeWIhuexuykpXFxufcKgZWxzZcKge1xcbsKgwqDCoMKgdmFywqBjYXRlZ29yaWVzwqA9wqBwZGZhKGh0bWwswqDlpKfnsbvlrprkvY0pXFxufVxcblxcbmxldMKgaW5pdF9jYXRlwqA9wqBbXVxcblxcbmZvciAobGV0IGkgPSAwOyBpIDwgMjA7IGkrKykge1xcbiAgICBpbml0X2NhdGUucHVzaChcXFwiMFxcXCIpXFxufVxcblxcbmNvbnN0wqBmb2xkwqA9wqBnZXRNeVZhcihNWV9SVUxFLmdyb3VwLMKgXFxcIjBcXFwiKVxcbmNvbnN0wqBjYXRlX3RlbXBfanNvbsKgPcKgZ2V0TXlWYXIoTVlfUlVMRS50aXRsZSzCoEpTT04uc3RyaW5naWZ5KGluaXRfY2F0ZSkpXFxuY29uc3TCoGNhdGVfdGVtcMKgPcKgSlNPTi5wYXJzZShjYXRlX3RlbXBfanNvbilcXG5cXG5cXG5cXG5pZsKgKHBhcnNlSW50KHBhZ2UpwqA9PT3CoDEpwqB7XFxuICAgIGQucHVzaCh7XFxuICAgIGNvbF90eXBlOidiaWdfYmxhbmtfYmxvY2snXFxuICAgIH0pXFxuICAgIGQucHVzaCh7XFxuICAgIGNvbF90eXBlOidiaWdfYmxhbmtfYmxvY2snXFxuICAgIH0pXFxuICAgIFxcbsKgwqDCoMKgZC5wdXNoKHtcXG7CoMKgwqDCoMKgwqDCoMKgdGl0bGU6wqBmb2xkwqA9PT3CoCcxJ8KgP8KgJ+KAnOKAnOKAneKAnTxiPifCoCvCoCdXJy5mb250Y29sb3IoXFxcIiNGRjAwMDBcXFwiKcKgK8KgJzwvYj4nwqA6wqAn4oCc4oCc4oCd4oCdPGI+J8KgK8KgJ00nLmZvbnRjb2xvcihcXFwiIzFhYWQxOVxcXCIpwqArwqAnPC9iPicsXFxuwqDCoMKgwqDCoMKgwqDCoHVybDrCoCQoKS5sYXp5UnVsZSgoZm9sZCnCoD0+wqB7XFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgcHV0TXlWYXIoTVlfUlVMRS5ncm91cCzCoGZvbGTCoD09PcKgJzEnwqA/wqAnMCfCoDrCoCcxJyk7XFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoHJldHVybsKgXFxcImhpa2VyOi8vZW1wdHlcXFwiXFxuwqDCoMKgwqDCoMKgwqDCoH0swqBmb2xkKSxcXG7CoMKgwqDCoMKgwqDCoMKgY29sX3R5cGU6wqAnc2Nyb2xsX2J1dHRvbicsXFxuwqDCoMKgwqB9KVxcbsKgwqDCoMKgY2F0ZWdvcmllcy5mb3JFYWNoKChjYXRlZ29yeSzCoGluZGV4KcKgPT7CoHtcXG7CoMKgwqDCoMKgwqDCoMKgbGV0wqBzdWJfY2F0ZWdvcmllc8KgPcKgcGRmYShjYXRlZ29yeSzCoOWwj+exu+WumuS9jSk7XFxuwqDCoMKgwqDCoMKgwqDCoGlmwqAoaW5kZXjCoD09PcKgMCnCoHtcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBzdWJfY2F0ZWdvcmllcy5mb3JFYWNoKChpdGVtLMKga2V5KcKgPT7CoHtcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGxldMKgdGl0bGXCoD3CoHBkZmgoaXRlbSzCoOWIhuexu+agh+mimClcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGlmwqAodHlwZW9mKOaOkumZpCnCoCE9wqAndW5kZWZpbmVkJ8KgJibCoOaOkumZpMKgIT3CoCcnKcKge1xcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB0aXRsZcKgPcKgdGl0bGUucmVwbGFjZShuZXfCoFJlZ0V4cCjmjpLpmaQswqBcXFwiZ1xcXCIpLMKgXFxcIlxcXCIpXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB9XFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBkLnB1c2goe1xcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB0aXRsZTrCoGtleS50b1N0cmluZygpwqA9PT3CoGNhdGVfdGVtcFtpbmRleF3CoD/CoFxcXCLigJzigJzigJ3igJ1cXFwiwqArwqB0aXRsZS5mb250Y29sb3Io5YiG57G76aKc6ImyKcKgOsKgdGl0bGUsXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoHVybDrCoCQocGQoaXRlbSzCoOWIhuexu+mTvuaOpSnCoCvCoCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChwYXJhbXMpwqA9PsKge1xcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGxldMKgbmV3X2NhdGXCoD3CoFtdXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgcGFyYW1zLmNhdGVfdGVtcC5mb3JFYWNoKChjYXRlLMKgaW5kZXgpwqA9PsKge1xcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgbmV3X2NhdGUucHVzaChpbmRleMKgPT09wqAwwqA/wqBwYXJhbXMua2V5LnRvU3RyaW5nKCnCoDrCoFxcXCIwXFxcIilcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB9KVxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoHB1dE15VmFyKE1ZX1JVTEUudGl0bGUswqBKU09OLnN0cmluZ2lmeShuZXdfY2F0ZSkpXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgcHV0TXlWYXIoTVlfUlVMRS51cmwswqBpbnB1dClcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqByZWZyZXNoUGFnZSh0cnVlKVxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoHJldHVybsKgXFxcImhpa2VyOi8vZW1wdHlcXFwiXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoH0swqB7XFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgY2F0ZV90ZW1wOsKgY2F0ZV90ZW1wLFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGtleTrCoGtleSxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBwYWdlOsKgcGFnZSxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgfSksXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGNvbF90eXBlOsKgJ3Njcm9sbF9idXR0b24nLFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgfSlcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB9KVxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGQucHVzaCh7XFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBjb2xfdHlwZTrCoFxcXCJibGFua19ibG9ja1xcXCJcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB9KTtcXG7CoMKgwqDCoMKgwqDCoMKgfcKgZWxzZcKgaWbCoChmb2xkwqA9PT3CoCcxJynCoHtcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBzdWJfY2F0ZWdvcmllcy5mb3JFYWNoKChpdGVtLMKga2V5KcKgPT7CoHtcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGxldMKgdGl0bGXCoD3CoHBkZmgoaXRlbSzCoOWIhuexu+agh+mimClcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGlmwqAodHlwZW9mKOaOkumZpCnCoCE9wqAndW5kZWZpbmVkJ8KgJibCoOaOkumZpMKgIT3CoCcnKcKge1xcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB0aXRsZcKgPcKgdGl0bGUucmVwbGFjZShuZXfCoFJlZ0V4cCjmjpLpmaQswqBcXFwiZ1xcXCIpLMKgXFxcIlxcXCIpXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB9XFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBkLnB1c2goe1xcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB0aXRsZTrCoGtleS50b1N0cmluZygpwqA9PT3CoGNhdGVfdGVtcFtpbmRleF3CoD/CoFxcXCLigJzigJzigJ3igJ1cXFwiwqArwqB0aXRsZS5mb250Y29sb3Io5YiG57G76aKc6ImyKcKgOsKgdGl0bGUsXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoHVybDrCoCQocGQoaXRlbSzCoOWIhuexu+mTvuaOpSnCoCvCoCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChwYXJhbXMpwqA9PsKge1xcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoHBhcmFtcy5jYXRlX3RlbXBbcGFyYW1zLmluZGV4XcKgPcKgcGFyYW1zLmtleS50b1N0cmluZygpXFxuXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgcHV0TXlWYXIoTVlfUlVMRS50aXRsZSzCoEpTT04uc3RyaW5naWZ5KHBhcmFtcy5jYXRlX3RlbXApKVxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoHB1dE15VmFyKE1ZX1JVTEUudXJsLMKgaW5wdXQpXFxuXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgcmVmcmVzaFBhZ2UodHJ1ZSlcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqByZXR1cm7CoFxcXCJoaWtlcjovL2VtcHR5XFxcIlxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB9LMKge1xcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGNhdGVfdGVtcDrCoGNhdGVfdGVtcCxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBpbmRleDrCoGluZGV4LFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGtleTrCoGtleSxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBwYWdlOsKgcGFnZSxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgfSksXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGNvbF90eXBlOsKgJ3Njcm9sbF9idXR0b24nLFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgfSlcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB9KVxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGQucHVzaCh7XFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBjb2xfdHlwZTrCoFxcXCJibGFua19ibG9ja1xcXCJcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB9KTtcXG7CoMKgwqDCoMKgwqDCoMKgfVxcbsKgwqDCoMKgfSlcXG59XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCI3LuWcn+aLqOm8oFwiLFwicGF0aFwiOlwidGJzZHlcIixcInJ1bGVcIjpcImpzOlxcbmxldCBkdXJsID0gZ2V0TXlWYXIoXFxcImR1cmxcXFwiLCBcXFwiXFxcIik7XFxuaWYgKGR1cmwgIT0gJycpIHtcXG4gICAgTVlfVVJMID0gZHVybDtcXG4gICAgLy9sb2coZHVybClcXG5cXG4gICAgbGV0IHVybCA9IGR1cmw7XFxuICAgIGxldCBpZCA9IHVybDtcXG4gICAgbGV0IG5hbWUgPSBzO1xcbiAgICB0cnkge1xcbiAgICAgICAgdmFyIGh0bWwgPSBmZXRjaCh1cmwsIHtcXG4gICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgIFxcXCJVc2VyLUFnZW50XFxcIjogUENfVUFcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgfSBjYXRjaCB7XFxuICAgICAgICB2YXIgaHRtbCA9ICcnXFxuICAgIH1cXG5cXG4gICAgdmFyIHJ1bGUgPSBNWV9SVUxFLnRpdGxlXFxuICAgIGxldCBkZXNjID0gcGRmaChodG1sLCAnLnZpZGVvX3Bsb3RfaW5mb19jb250ZW50JiZUZXh0Jyk7XFxuICAgIGxldCBzY29yZSA9IHBkZmgoaHRtbCwgJy52aWRlb19wb2ludCYmVGV4dCcpO1xcblxcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6IHBkZmgoaHRtbCwgJy52aWRlb19pbmZvX3RpdGxlX3RleHQmJlRleHQnKSxcXG4gICAgICAgIGltZzogcGRmaChodG1sLCAnLnZpZGVvX2NvdmVyX2ltZ19ib3gmJmltZyYmZGF0YS11cmwnKSxcXG4gICAgICAgIGNvbF90eXBlOiAnbW92aWVfMV92ZXJ0aWNhbF9waWMnLFxcbiAgICAgICAgZGVzYzogJ+ivhOWIhjonICsgc2NvcmUgKyAnXFxcXG7kuLvmvJQ6JyArIGRlc2MsXFxuICAgICAgICB1cmw6IHVybCxcXG4gICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgaWQ6IHVybCxcXG4gICAgICAgICAgICBpbmhlcml0VGl0bGU6IGZhbHNlLFxcbiAgICAgICAgfVxcbiAgICB9KVxcblxcblxcbiAgICB2YXIgbGlzdCA9IHBkZmEoaHRtbCwgJ2JvZHkmJi52aWRlb19kb3dubG9hZF9saW5rX2l0ZW0nKVxcbiAgICBpZiAobGlzdCAmJiBsaXN0Lmxlbmd0aCA+IDApIHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgbGV0IHtcXG4gICAgICAgICAgICAgICAgd3JhcDFcXG4gICAgICAgICAgICB9ID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvdG9vbD9ydWxlPVxcXCIgKyBydWxlKTtcXG5cXG4gICAgICAgICAgICBsaXN0ID0gbGlzdC5tYXAoaXQgPT4ge1xcbiAgICAgICAgICAgICAgICBsZXQgdSA9IHBkZmgoaXQsICdhJiZocmVmJyk7XFxuICAgICAgICAgICAgICAgIGxldCB0ID0gcGRmaChpdCwgJy52aWRlb19kb3dubG9hZF9saW5rX25hbWVfdGV4dCYmVGV4dCcpO1xcbiAgICAgICAgICAgICAgICBsZXQgd2ViID0gcGRmaChpdCwgJy5yZXNvdXJjZV93ZWJzaXRlX25hbWUmJlRleHQnKTtcXG4gICAgICAgICAgICAgICAgbGV0IGltZyA9IHBkKGl0LCAnLnZpZGVvX2xhYmVscyYmaW1nJiZzcmMnKTtcXG5cXG4gICAgICAgICAgICAgICAgdSA9IFxcXCJoaWtlcjovL3BhZ2UvcD9ydWxlPVxcXCIgKyBydWxlICsgXFxcIiZ1PVxcXCIgKyBiYXNlNjRFbmNvZGUodSk7XFxuICAgICAgICAgICAgICAgIHUgPSBnZXRJdGVtKCdhaScsICcwJykgPT0gJzAnID8gdSA6IHUgKyAnI2ltbWVyc2l2ZVRoZW1lIydcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB3cmFwMSh3ZWIgKyAnLScgKyB0LCBzKSxcXG4gICAgICAgICAgICAgICAgICAgIGltZzogaW1nLFxcbiAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJhdmF0YXJcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB1LFxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmhlcml0VGl0bGU6IGZhbHNlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsczogdXJsLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VUaXRsZTogdCxcXG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWI6IHdlYixcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIGQgPSBkLmNvbmNhdChsaXN0KVxcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgIGxvZyhlLnRvU3RyaW5nKCkpO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIHNldFJlc3VsdChkKVxcbn1cXG5zID0gZ2V0TXlWYXIoXFxcInNvdVxcXCIsIFxcXCJcXFwiKTtcXG5sZXQgciA9IFxcXCJcXFwiO1xcbmlmIChzICE9IFxcXCJcXFwiKSB7XFxuICAgIHZhciBwYWdlID0gTVlfUEFHRTtcXG4gICAgTVlfVVJMID0gYGh0dHBzOi8vd3d3LnRic2R5LmNvbS9zZWFyY2guaHRtbD9rZXl3b3JkPSR7c30mcGFnZWQ9JHtwYWdlfSZjYXRlZ29yeT1gO1xcbiAgICAvL2xvZyhNWV9VUkwpXFxuICAgIGxldCBodG1sID0gZmV0Y2goTVlfVVJMLCB7XFxuICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgXFxcIlVzZXItQWdlbnRcXFwiOiBQQ19VQVxcbiAgICAgICAgfVxcbiAgICB9KTtcXG5cXG4gICAgdmFyIGxpc3QgPSBwZGZhKGh0bWwsICdib2R5JiYuc2VhcmNoX3Jlc3VsdF9pdGVtJylcXG5cXG4gICAgbGV0IHtcXG4gICAgICAgIHdyYXBcXG4gICAgfSA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL3Rvb2xcXFwiKTtcXG5cXG4gICAgZm9yIChsZXQgaXQgb2YgbGlzdCkge1xcbiAgICAgICAgbGV0IG5hbWUgPSBwZGZoKGl0LCAnLnNlYXJjaF9yZXN1bHRfdGl0bGUmJlRleHQnKTtcXG4gICAgICAgIGxldCBpbWcgPSBwZChpdCwgJ2ltZyYmc3JjJyk7XFxuICAgICAgICBpZiAoaW1nID09IFxcXCJcXFwiKSB7XFxuICAgICAgICAgICAgaW1nID0gXFxcIlxcXCI7XFxuICAgICAgICB9XFxuICAgICAgICBsZXQgdXJsID0gcGQoaXQsICdhJiZocmVmJyk7XFxuICAgICAgICBsZXQgZGVzYyA9IHBkZmEoaXQsICdib2R5JiYuc2VhcmNoX3Jlc3VsdF9pdGVtJiYuc2VhcmNoX3Jlc3VsdF9zdWJfaW5mb19saW5lJiYudmlkZW9fYWN0b3InKS5tYXAoeCA9PiBwZGZoKHgsICdzcGFuJiZUZXh0JykpLmpvaW4oJyAnKTtcXG4gICAgICAgIGxldCBzY29yZSA9IHBkZmgoaXQsICcuc2VhcmNoX3ZpZGVvX2ltZ19wb2ludCYmVGV4dCcpO1xcbiAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogd3JhcChuYW1lLCBzKSxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ21vdmllXzFfdmVydGljYWxfcGljJyxcXG4gICAgICAgICAgICBpbWc6IGltZyxcXG4gICAgICAgICAgICBkZXNjOiAn6K+E5YiGOicgKyBzY29yZSArICdcXFxcbuS4u+a8lDonICsgZGVzYyxcXG4gICAgICAgICAgICB1cmw6ICQodXJsKS5sYXp5UnVsZSgocnVsZSwgdXJsLCBzLCBuYW1lKSA9PiB7XFxuXFxuICAgICAgICAgICAgICAgIHZhciBjbHMgPSBmaW5kSXRlbXNCeUNscyh1cmwpO1xcbiAgICAgICAgICAgICAgICBpZiAoISFjbHMpIHtcXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZUl0ZW1CeUNscyh1cmwpXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICBsZXQgdXJsID0gaW5wdXQ7XFxuICAgICAgICAgICAgICAgICAgICBsZXQgaWQgPSB1cmw7XFxuICAgICAgICAgICAgICAgICAgICBsZXQgaHRtbCA9IGZldGNoKHVybCwge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcIlVzZXItQWdlbnRcXFwiOiBQQ19VQVxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpc3QgPSBwZGZhKGh0bWwsICdib2R5JiYudmlkZW9fZG93bmxvYWRfbGlua19pdGVtJylcXG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ICYmIGxpc3QubGVuZ3RoID4gMCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1ZX1VSTCA9IHVybDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyYXAxXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS90b29sP3J1bGU9XFxcIiArIHJ1bGUpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ID0gbGlzdC5tYXAoaXQgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBwZGZoKGl0LCAnYSYmaHJlZicpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHQgPSBwZGZoKGl0LCAnLnZpZGVvX2Rvd25sb2FkX2xpbmtfbmFtZV90ZXh0JiZUZXh0Jyk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgd2ViID0gcGRmaChpdCwgJy5yZXNvdXJjZV93ZWJzaXRlX25hbWUmJlRleHQnKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbWcgPSBwZChpdCwgJy52aWRlb19sYWJlbHMmJmltZyYmc3JjJyk7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ID0gXFxcImhpa2VyOi8vcGFnZS9wP3J1bGU9XFxcIiArIHJ1bGUgKyBcXFwiJnU9XFxcIiArIGJhc2U2NEVuY29kZSh1KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUgPSBnZXRJdGVtKCdhaScsICcwJykgPT0gJzAnID8gdSA6IHUgKyAnI2ltbWVyc2l2ZVRoZW1lIydcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHdyYXAxKHdlYiArICctJyArIHQsIHMpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltZzogaW1nLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwiYXZhdGFyXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5oZXJpdFRpdGxlOiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xzOiB1cmwsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VUaXRsZTogdCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2ViOiB3ZWIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkSXRlbUFmdGVyKGlkLCBsaXN0KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZyhlLnRvU3RyaW5nKCkpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiXFxuICAgICAgICAgICAgfSwgTVlfUlVMRS50aXRsZSwgdXJsLCBzLCBuYW1lKSxcXG4gICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICBpZDogdXJsLFxcbiAgICAgICAgICAgICAgICBpbmhlcml0VGl0bGU6IGZhbHNlXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSlcXG4gICAgfVxcblxcbiAgICBzZXRSZXN1bHQoZClcXG59IGVsc2Uge1xcblxcbn1cXG5cXG5pZiAoZ2V0SXRlbSgnaG9tZScsICflhbMnKSA9PSAn5byAJykge1xcbiAgICBsZXQgaHRtbCA9IGZldGNoKCdodHRwczovL3d3dy50YnNkeS5jb20vJywge1xcbiAgICAgICAgaGVhZGVyczoge1xcbiAgICAgICAgICAgIFxcXCJVc2VyLUFnZW50XFxcIjogUENfVUFcXG4gICAgICAgIH1cXG4gICAgfSk7XFxuXFxuICAgIGZ1bmN0aW9uIHNldExpc3RzKGl0ZW0pIHtcXG4gICAgICAgIE1ZX1VSTCA9ICdodHRwczovL3d3dy50YnNkeS5jb20vJztcXG4gICAgICAgIHZhciB0aXRsZSA9IGl0ZW0ubmFtZTtcXG4gICAgICAgIHZhciBrZXkgPSBpdGVtLnNlbGVjdDtcXG4gICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiAnYXZhdGFyJyxcXG4gICAgICAgICAgICBpbWc6IGl0ZW0uaW1nLFxcbiAgICAgICAgfSlcXG5cXG4gICAgICAgIHZhciBsaXN0ID0gcGRmYShodG1sLCBgYm9keSYmLmNvbnRhaW5lcl9tYWluX2hvdF8ke2tleX0mJi5ob3RfcmVzb3VyY2Vfb25lYClcXG5cXG4gICAgICAgIGxpc3QubWFwKHggPT4ge1xcbiAgICAgICAgICAgIHZhciBuYW1lID0gcGRmaCh4LCAnLnJlc291cmNlX25hbWUmJlRleHQnKVxcbiAgICAgICAgICAgIGxldCBpbWcgPSBwZCh4LCAnLnJlc291cmNlX3Bvc3RlcnMmJmRhdGEtdXJsJyk7XFxuICAgICAgICAgICAgaWYgKGltZyA9PSBcXFwiXFxcIikge1xcbiAgICAgICAgICAgICAgICBpbWcgPSBcXFwiXFxcIjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgbGV0IHVybCA9IHBkKHgsICdhJiZocmVmJyk7XFxuXFxuICAgICAgICAgICAgbGV0IHNjb3JlID0gcGRmaCh4LCAnLnVwZGF0ZV90aXB8fC5yZXNvdXJjZV9zY29yZXx8aW1nJiZUZXh0Jyk7XFxuXFxuICAgICAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IG5hbWUsXFxuICAgICAgICAgICAgICAgIGltZzogaW1nLFxcbiAgICAgICAgICAgICAgICBkZXNjOiBzY29yZSxcXG4gICAgICAgICAgICAgICAgdXJsOiAkKCcnKS5sYXp5UnVsZSgobiwgdSkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcInNvdVxcXCIsIG4pXFxuICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcignZHVybCcsIHUpXFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgICAgICAgICAgICAgIH0sIG5hbWUsIHVybClcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgfSlcXG4gICAgfVxcblxcbiAgICBbe1xcbiAgICAgICAgbmFtZTogJ+eDremXqOeUteinhuWJpycsXFxuICAgICAgICBzZWxlY3Q6ICd0dnMnLFxcbiAgICAgICAgaW1nOiAnaHR0cHM6Ly93d3cudGJzZHkuY29tL2ltZy9tcnN3L3dlYi9pbmRleC9pbmRleF90di5zdmcnLFxcbiAgICB9LCB7XFxuICAgICAgICBuYW1lOiAn54Ot6Zeo55S15b2xJyxcXG4gICAgICAgIHNlbGVjdDogJ21vdmllcycsXFxuICAgICAgICBpbWc6ICdodHRwczovL3d3dy50YnNkeS5jb20vaW1nL21yc3cvd2ViL2luZGV4L2luZGV4X212LnN2ZydcXG4gICAgfSwge1xcbiAgICAgICAgbmFtZTogJ+eDremXqOWKqOa8qycsXFxuICAgICAgICBzZWxlY3Q6ICdhbmltZXMnLFxcbiAgICAgICAgaW1nOiAnaHR0cHM6Ly93d3cudGJzZHkuY29tL2ltZy9tcnN3L3dlYi9pbmRleC9pbmRleF9zaG93LnN2ZydcXG4gICAgfSwge1xcbiAgICAgICAgbmFtZTogJ+eDremXqOe7vOiJuicsXFxuICAgICAgICBzZWxlY3Q6ICd2YXJpZXR5cycsXFxuICAgICAgICBpbWc6ICdodHRwczovL3d3dy50YnNkeS5jb20vaW1nL21yc3cvd2ViL2luZGV4L2luZGV4X3JlY29yZHMuc3ZnJ1xcbiAgICB9LCB7XFxuICAgICAgICBuYW1lOiAn54Ot6Zeo57qq5b2V54mHJyxcXG4gICAgICAgIHNlbGVjdDogJ2RvY3VtZW50YXJ5cycsXFxuICAgICAgICBpbWc6ICdodHRwczovL3d3dy50YnNkeS5jb20vaW1nL21yc3cvd2ViL2luZGV4L2luZGV4X3JlY29yZHMuc3ZnJyxcXG4gICAgfV0ubWFwKHggPT4ge1xcblxcbiAgICAgICAgc2V0TGlzdHMoeClcXG4gICAgfSlcXG59XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLliqjmgIHliIbnsbtKc29uXCIsXCJwYXRoXCI6XCJqZHRmbFwiLFwicnVsZVwiOlwianM6XFxuY29uc3TCoGVtcHR5wqA9wqBcXFwiaGlrZXI6Ly9lbXB0eVxcXCI7XFxuXFxuaWbCoCh0eXBlb2YoSnNvbuaLvOaOpSnCoCE9wqAndW5kZWZpbmVkJ8KgJibCoEpzb27mi7zmjqXCoCE9wqAnJynCoHtcXG4gICAgXFxuICAgIHZhciBjYXRlZ29yaWVzanNvbj1UcnVlSnNvbltKc29u5aSn57G7XTtcXG4gICAgXFxuICAgIGlmKFRydWVKc29uW0pzb27mi7zmjqVdLmNvbnN0cnVjdG9yICA9PSBPYmplY3Qpe1xcbiAgICB2YXIgaXRlbWpzb249T2JqZWN0LmtleXMoVHJ1ZUpzb25bSnNvbuaLvOaOpV0pLm1hcCh4PT5PYmplY3QudmFsdWVzKFRydWVKc29uW0pzb27mi7zmjqVdW3hdKS5tYXAoej0+SlNPTi5zdHJpbmdpZnkoeikpLmpvaW4oSnNvbuaLhuWIhikpXFxuICAgIH1lbHNlIGlmKFRydWVKc29uW0pzb27mi7zmjqVdLmNvbnN0cnVjdG9yICA9PSBBcnJheSl7XFxuICAgICB2YXIgaXRlbWpzb249VHJ1ZUpzb25bSnNvbuaLvOaOpV1cXG4gICAgfVxcbiAgIFxcbiAgICBjYXRlZ29yaWVzanNvbj1jYXRlZ29yaWVzanNvbi5jb25jYXQoaXRlbWpzb24pO1xcbiAgICBcXG59wqBlbHNlwqB7XFxuwqDCoMKgwqB2YXLCoGNhdGVnb3JpZXNqc29uPVRydWVKc29uW0pzb27lpKfnsbtdO1xcbn1cXG5cXG4vL2xvZyhjYXRlZ29yaWVzanNvbilcXG5cXG5sZXTCoGluaXRfY2F0ZcKgPcKgW107XFxuXFxuZm9yIChsZXQgaSA9IDA7IGkgPCAyMDsgaSsrKSB7XFxuICAgIGluaXRfY2F0ZS5wdXNoKFxcXCIwXFxcIik7XFxufVxcblxcbmNvbnN0wqBmb2xkwqA9wqBnZXRWYXIoTVlfUlVMRS5ncm91cCzCoFxcXCIwXFxcIik7XFxuY29uc3TCoGNhdGVfdGVtcF9qc29uwqA9wqBnZXRWYXIoTVlfUlVMRS50aXRsZSzCoEpTT04uc3RyaW5naWZ5KGluaXRfY2F0ZSkpO1xcbmNvbnN0wqBjYXRlX3RlbXDCoD3CoEpTT04ucGFyc2UoY2F0ZV90ZW1wX2pzb24pO1xcblxcbmlmwqAocGFyc2VJbnQocGFnZSnCoD09PcKgMSnCoHtcXG7CoMKgwqDCoGQucHVzaCh7XFxuwqDCoMKgwqDCoMKgwqDCoHRpdGxlOsKgZm9sZMKgPT09wqAnMSfCoD/CoCfigJzigJzigJ3igJ0nwqArwqDliIbnsbvlsZXlvIAuZm9udGNvbG9yKFxcXCIjRkYwMDAwXFxcIinCoCvCoCcnwqA6wqAn4oCc4oCc4oCd4oCdJ8KgK8Kg5YiG57G75oqY5Y+gLmZvbnRjb2xvcihcXFwiIzFhYWQxOVxcXCIpwqArwqAnJyxcXG7CoMKgwqDCoMKgwqDCoMKgdXJsOsKgJCgpLmxhenlSdWxlKChmb2xkKcKgPT7CoHtcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBwdXRWYXIoTVlfUlVMRS5ncm91cCzCoGZvbGTCoD09PcKgJzEnwqA/wqAnMCfCoDrCoCcxJyk7XFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoHJldHVybsKgXFxcImhpa2VyOi8vZW1wdHlcXFwiXFxuwqDCoMKgwqDCoMKgwqDCoH0swqBmb2xkKSxcXG7CoMKgwqDCoMKgwqDCoMKgY29sX3R5cGU6wqAnc2Nyb2xsX2J1dHRvbicsXFxuwqDCoMKgwqB9KTtcXG7CoMKgwqDCoGNhdGVnb3JpZXNqc29uLmZvckVhY2goKGNhdGVnb3J5LMKgaW5kZXgpwqA9PsKge1xcbsKgwqDCoMKgwqDCoMKgwqBsZXTCoHN1Yl9jYXRlZ29yaWVzwqA9wqBjYXRlZ29yeS5zcGxpdChKc29u5ouG5YiGKTtcXG7CoMKgwqDCoMKgwqDCoMKgaWbCoChpbmRleMKgPT09wqAwKcKge1xcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoHN1Yl9jYXRlZ29yaWVzLmZvckVhY2goKGl0ZW0swqBrZXkpwqA9PsKge1xcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgbGV0wqB0aXRsZcKgPcKgaXRlbS5zcGxpdChKc29u5Y2V6aG5KVswXTtcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGlmwqAodHlwZW9mKOaOkumZpCnCoCE9wqAndW5kZWZpbmVkJ8KgJibCoOaOkumZpMKgIT3CoCcnKcKge1xcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB0aXRsZcKgPcKgdGl0bGUucmVwbGFjZShuZXfCoFJlZ0V4cCjmjpLpmaQswqBcXFwiZ1xcXCIpLMKgXFxcIlxcXCIpO1xcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgfVxcbiAgICAgICAgICAgICAgICBpZih0aXRsZT09Jycpe1xcbiAgICAgICAgICAgICAgICAgIHJldHVyblxcbiAgICAgICAgICAgICAgICB9XFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBkLnB1c2goe1xcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB0aXRsZTrCoGtleS50b1N0cmluZygpwqA9PT3CoGNhdGVfdGVtcFtpbmRleF3CoD/CoFxcXCLigJzigJzigJ3igJ1cXFwiwqArwqB0aXRsZS5mb250Y29sb3Io5YiG57G76aKc6ImyKcKgOsKgdGl0bGUsXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoHVybDrCoGl0ZW0uc3BsaXQoSnNvbuWNlemhuSlbMV3CoCvCoCQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKHBhcmFtcyxsaXN0KcKgPT7CoHtcXG4gICAgXFxuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlMC5wdXRNeVZhcignaW5kZXgnLHBhcmFtcy5rZXkpXFxuXFxuICAgICAgICAgICAgICAgICAgICBsaXN0Lm1hcChrZXk9PntcXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhck15VmFyKGtleSk7XFxuICAgICAgICAgICAgICAgICAgICB9KVxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGxldMKgbmV3X2NhdGXCoD3CoFtdXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgcGFyYW1zLmNhdGVfdGVtcC5mb3JFYWNoKChjYXRlLMKgaW5kZXgpwqA9PsKge1xcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgbmV3X2NhdGUucHVzaChpbmRleMKgPT09wqAwwqA/wqBwYXJhbXMua2V5LnRvU3RyaW5nKCnCoDrCoFxcXCIwXFxcIilcXG4gICAgIFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoH0pXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgcHV0VmFyKE1ZX1JVTEUudGl0bGUswqBKU09OLnN0cmluZ2lmeShuZXdfY2F0ZSkpXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgcHV0VmFyKE1ZX1JVTEUudXJsLMKgaW5wdXQpXFxuICAgICAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcIm15dHlwZVxcXCIsaW5wdXQpXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgcmVmcmVzaFBhZ2UodHJ1ZSlcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqByZXR1cm7CoFxcXCJoaWtlcjovL2VtcHR5XFxcIlxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB9LMKge1xcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGNhdGVfdGVtcDrCoGNhdGVfdGVtcCxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBrZXk6wqBrZXksXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgcGFnZTrCoHBhZ2UsXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoH0sSnNvbuWIl+ihqCksXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGNvbF90eXBlOsKgJ3Njcm9sbF9idXR0b24nLFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgfSlcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB9KVxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGQucHVzaCh7XFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBjb2xfdHlwZTrCoFxcXCJibGFua19ibG9ja1xcXCJcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB9KTtcXG7CoMKgwqDCoMKgwqDCoMKgfcKgZWxzZcKgaWbCoChmb2xkwqA9PT3CoCcxJynCoHtcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBzdWJfY2F0ZWdvcmllcy5mb3JFYWNoKChpdGVtLMKga2V5KcKgPT7CoHtcXG4gICAgICAgICAgICAgICAgdmFyIG9iaj1KU09OLnBhcnNlKGl0ZW0pXFxuICAgIFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgbGV0wqB0aXRsZcKgPSBvYmpbJ25hbWUnXVxcbiAgICAgICAgICAgICAgICBcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGlmwqAodHlwZW9mKOaOkumZpCnCoCE9wqAndW5kZWZpbmVkJ8KgJibCoOaOkumZpMKgIT3CoCcnKcKge1xcbiAgICBcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgdGl0bGXCoD3CoHRpdGxlLnJlcGxhY2UobmV3wqBSZWdFeHAo5o6S6ZmkLMKgXFxcImdcXFwiKSzCoFxcXCJcXFwiKVxcbiAgICAgICAgICAgXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB9XFxuICAgICAgICAgICAgICAgICAgIGlmKHRpdGxlPT0nJyl7XFxuICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxcbiAgICAgICAgICAgICAgICAgICAgfVxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgZC5wdXNoKHtcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgdGl0bGU6wqBrZXkudG9TdHJpbmcoKcKgPT09wqBjYXRlX3RlbXBbaW5kZXhdwqA/wqBcXFwi4oCc4oCc4oCd4oCdXFxcIsKgK8KgdGl0bGUuZm9udGNvbG9yKOWIhuexu+minOiJsinCoDrCoHRpdGxlLFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB1cmw6wqAkKGl0ZW0rJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKHBhcmFtcynCoD0+wqB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9iaj1KU09OLnBhcnNlKGlucHV0KVxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cmw9b2JqWyd1cmwnXVxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlPW9ialsndHlwZSddXFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgcGFyYW1zLmNhdGVfdGVtcFtwYXJhbXMuaW5kZXhdwqA9wqBwYXJhbXMua2V5LnRvU3RyaW5nKClcXG5cXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBwdXRWYXIoTVlfUlVMRS50aXRsZSzCoEpTT04uc3RyaW5naWZ5KHBhcmFtcy5jYXRlX3RlbXApKVxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoHB1dFZhcihNWV9SVUxFLnVybCzCoHVybClcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0eXBlIT0nJz90cnVlOmZhbHNlKXtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleT10eXBlXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZT11cmxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmFnZTAucHV0TXlWYXIoa2V5LHZhbHVlKVxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqByZWZyZXNoUGFnZSh0cnVlKVxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoHJldHVybsKgXFxcImhpa2VyOi8vZW1wdHlcXFwiXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoH0swqB7XFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgY2F0ZV90ZW1wOsKgY2F0ZV90ZW1wLFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGluZGV4OsKgaW5kZXgsXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKga2V5OsKga2V5LFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoHBhZ2U6wqBwYWdlLFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB9KSxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgY29sX3R5cGU6wqAnc2Nyb2xsX2J1dHRvbicsXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB9KVxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoH0pXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgZC5wdXNoKHtcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGNvbF90eXBlOsKgXFxcImJsYW5rX2Jsb2NrXFxcIlxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoH0pO1xcbsKgwqDCoMKgwqDCoMKgwqB9XFxuwqDCoMKgwqB9KVxcbn1cIn1dLFwicGFyYW1zXCI6XCJ7XFxcImNsc1xcXCI6XFxcInBsYXlzXFxcIixcXFwiaWRcXFwiOlxcXCJodHRwczovL3d3dy4zMzN5cy50di92b2RwbGF5LzI3ODAtMS0xLmh0bWxcXFwifVwiLFwic2F2ZWRcIjpmYWxzZSxcInRpdGxlXCI6XCJBSeiBmumbhlwiLFwidmVyc2lvblwiOjAsXCJ1cmxcIjpcImhpa2VyOi8vcGFnZS9wdXNoPyZwdXNodXJsPSU3QiUyMm5hbWUlMjIlM0ElMjIlRTYlQjUlODElRTYlQjUlQUElRTUlOUMlQjAlRTclOTAlODMlMjIlMkMlMjJ1cmwlMjIlM0ElMjJIRCVFOSVBQiU5OCVFNiVCOCU4NSUyNGh0dHBzJTNBJTJGJTJGd3d3LjMzM3lzLnR2JTJGdm9kcGxheSUyRjI3ODAtMS0xLmh0bWwlMjIlN0RcIixcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJmaW5kX3J1bGVcIjpcImpzOlxcbmxldCBpdGVtcyA9IFtdO1xcbmxldCBwdXNoaW4gPSBkZWNvZGVVUklDb21wb25lbnQoZ2V0UGFyYW0oXFxcInB1c2h1cmxcXFwiKSk7XFxubGV0IHR2aXAgPSBnZXRJdGVtKCdoaWtlcnR2Ym94c2V0JywgJycpO1xcblxcbml0ZW1zLnB1c2goe1xcbiAgICB0aXRsZTogJ+W9k+WJjUlQ77yaJyArIHR2aXAsXFxuICAgIHVybDogXFxcImlucHV0Oi8vXFxcIiArIGdldEl0ZW0oJ2hpa2VydHZib3hzZXQnLCAnaHR0cDovLycgKyBnZXRJUCgpICsgJzo5OTc4JykgKyBcXFwiLy8vL+ivt+i+k+WFpVRWQm9456uv55qESVDlnLDlnYDvvIzlpoJodHRwOi8vXFxcIiArIGdldElQKCkgKyBcXFwiOjk5NzguanM6c2V0SXRlbSgnaGlrZXJ0dmJveHNldCcsaW5wdXQpO3JlZnJlc2hQYWdlKClcXFwiLFxcbiAgICBjb2xfdHlwZTogJ2ZsZXhfYnV0dG9uJ1xcbn0pO1xcbnZhciBwdXJsID0gcHVzaGluO1xcblxcbmlmIChwdXNoaW4uaW5jbHVkZXMoJ1xcXFxuJykgJiYgIXB1c2hpbi5zdGFydHNXaXRoKCd7JykpIHtcXG4gICAgcHVybCA9IHB1c2hpbi5yZXBsYWNlKFxcXCJcXFxcblxcXCIsICckJyk7XFxufVxcbmlmIChwdXNoaW4uc3RhcnRzV2l0aCgnaHR0cCcpICYmIHB1c2hpbi5pbmNsdWRlcygnO3snKSkge1xcbiAgICBwdXJsID0gSlNPTi5zdHJpbmdpZnkoe1xcbiAgICAgICAgXFxcIm5hbWVcXFwiOiBcXFwi5rW36ZiU55u06ZO+5o6o6YCBXFxcIixcXG4gICAgICAgIFxcXCJ1cmxcXFwiOiBwdXNoaW5cXG4gICAgfSlcXG59XFxuaWYgKHB1c2hpbi5zdGFydHNXaXRoKCdodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vcy8nKSkge1xcbiAgICBsZXQgcmVmdG9rZW4gPSBKU09OLnBhcnNlKGZldGNoKCdoaWtlcjovL2ZpbGVzL3J1bGVzL2ljeS9pY3ktYWxpLXRva2VuLmpzb24nLCB7fSkpWzBdLnJlZnJlc2hfdG9rZW47XFxuICAgIHB1cmwgPSBKU09OLnN0cmluZ2lmeSh7XFxuICAgICAgICBcXFwidXJsXFxcIjogcHVzaGluLFxcbiAgICAgICAgXFxcInJlZnJlc2hfdG9rZW5cXFwiOiByZWZ0b2tlblxcbiAgICB9KVxcbn1cXG5pZiAocHVzaGluLmluY2x1ZGVzKCc6NTIwMjAnKSkge1xcbiAgICBpZiAocHVzaGluLmluY2x1ZGVzKCdyZWRpcmVjdFBsYXlVcmwnKSkge1xcbiAgICAgICAgcHVybCA9IEpTT04uc3RyaW5naWZ5KHtcXG4gICAgICAgICAgICBcXFwibmFtZVxcXCI6IFxcXCLmtbfpmJTmipXlsY/nm7Tpk75cXFwiLFxcbiAgICAgICAgICAgIFxcXCJ1cmxcXFwiOiBwdXNoaW5cXG4gICAgICAgIH0pXFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBwdXJsID0gSlNPTi5zdHJpbmdpZnkoe1xcbiAgICAgICAgICAgIFxcXCJuYW1lXFxcIjogXFxcIua1t+mYlOe9kemhteaKleWxj1xcXCIsXFxuICAgICAgICAgICAgXFxcInVybFxcXCI6IHB1c2hpblxcbiAgICAgICAgfSlcXG4gICAgfVxcbn1cXG5cXG4vL2xvZygn5o6o6YCBJytwdXJsKTtcXG52YXIgc3RhdGUgPSByZXF1ZXN0KHR2aXAgKyAnL2FjdGlvbicsIHtcXG4gICAgaGVhZGVyczoge1xcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxcbiAgICAgICAgLy8nWC1SZXF1ZXN0ZWQtV2l0aCc6ICdYTUxIdHRwUmVxdWVzdCcsXFxuICAgICAgICAnUmVmZXJlcic6IHR2aXBcXG4gICAgfSxcXG4gICAgdGltZW91dDogMjAwMCxcXG4gICAgYm9keTogJ2RvPXB1c2gmdXJsPScgKyBwdXJsLnJlcGxhY2UoL1xcXFwmL2csICfvvIbvvIYnKSxcXG4gICAgbWV0aG9kOiAnUE9TVCdcXG59KTtcXG4vL2xvZyhzdGF0ZSk7XFxuaWYgKHN0YXRlID09ICdvaycpIHtcXG4gICAgLy9sb2coc3RhdGUpO1xcbiAgICBpdGVtcy5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBcXFwi4pyFXFxcIiArIHN0YXRlLFxcbiAgICAgICAgdXJsOiAkKCcnKS5sYXp5UnVsZSgoKSA9PiB7XFxuICAgICAgICAgICAgYmFjayhmYWxzZSk7XFxuICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcbiAgICAgICAgfSksXFxuICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfY2VudGVyXzFcXFwiXFxuICAgIH0pO1xcbn0gZWxzZSB7XFxuICAgIC8vbG9nKHN0YXRlKTtcXG4gICAgaXRlbXMucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIuKdjlxcXCIgKyBzdGF0ZSxcXG4gICAgICAgIHVybDogXFxcImhpa2VyOi8vZW1wdHlcXFwiLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0X2NlbnRlcl8xXFxcIlxcbiAgICB9KTtcXG5cXG59XFxuc2V0UmVzdWx0KGl0ZW1zKTtcIixcImdyb3VwXCI6XCIz4oOjQUlcIixcInVhXCI6XCJtb2JpbGVcIixcInByZVJ1bGVcIjpcInZhciB1YT0nJztcXG5yZXF1aXJlKCdodHRwczovL2dpdGNvZGUubmV0L3FxXzMyMzk0MzUxL2RyLy0vcmF3L21hc3Rlci9qcy/pooTlpITnkIYuanMnKTtcIixcInBhZ2VzXCI6XCJbe1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5LqM57qn6Kej5p6QXFxcIixcXFwicGF0aFxcXCI6XFxcInBcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5hZGRMaXN0ZW5lcihcXFxcXFxcIm9uQ2xvc2VcXFxcXFxcIiwgJC50b1N0cmluZygoKSA9PiB7XFxcXG4gICAgdXBkYXRlSXRlbSgncGFyc2V0Jywge1xcXFxuICAgICAgICB0aXRsZTogZ2V0SXRlbSgn5ZeF5o6iJywgJ+inhumikeWXheaOoicpLCAgICAgICAgXFxcXG4gICAgfSk7XFxcXG4gICAgY2xlYXJNeVZhcignd2VidXJsJyk7XFxcXG4gICAgcHV0TXlWYXIoJ2JtJywgJzAnKTtcXFxcbiAgICBzdG9yYWdlMC5wdXRNeVZhcihcXFxcXFxcImR1b3NlbGVjdFxcXFxcXFwiLFtdKTtcXFxcbiAgICAvL2JhY2soZmFsc2UpXFxcXG59KSk7XFxcXG5cXFxcbnZhciBCaXRUUyA9IFtdO1xcXFxuXFxcXG4vL3B1dE15VmFyKFxcXFxcXFwibXViYW5cXFxcXFxcIiwge+WQjeensDon5p6B5a6i5b2x6KeGJ30pXFxcXG5cXFxcbmV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvenRvb2xzJykpLnJ1bGUpXFxcXG5cXFxcbnZhciB1cmwgPSAnJztcXFxcbnZhciBodG1sID0gJyc7XFxcXG5cXFxcbnZhciBrZXlzID0gTVlfUEFSQU1TO1xcXFxudmFyIGZyb20gPSBrZXlzLmZyb20gIT0gdW5kZWZpbmVkID8ga2V5cy5mcm9tIDogJyc7XFxcXG52YXIgZHRpdGxlID0ga2V5cy5wYWdlVGl0bGUgIT0gdW5kZWZpbmVkID8ga2V5cy5wYWdlVGl0bGUgOiAnJztcXFxcblxcXFxuXFxcXG5pZiAoZ2V0TXlWYXIoJ3dlYnVybCcsICcnKSA9PSAnJykge1xcXFxuICAgIC8vTVlfVVJMID0gTVlfVVJMLnJlcGxhY2UoJyNpbW1lcnNpdmVUaGVtZSMnLCAnJyk7XFxcXG4gICAgTVlfVVJMID0gTVlfVVJMLmluY2x1ZGVzKCcjJykgPyBNWV9VUkwuc3BsaXQoJyMnKVswXSA6IE1ZX1VSTDtcXFxcbiAgICB2YXIgdSA9IGdldFBhcmFtKFxcXFxcXFwidVxcXFxcXFwiKVxcXFxuICAgIGlmICh1ID09IHVuZGVmaW5lZCkge1xcXFxuICAgICAgICB1ID0gTVlfVVJMXFxcXG4gICAgfVxcXFxuICAgIGxvZygndTonICsgdSk7XFxcXG4gICAgdXJsID0gZ2V0VHVybCh1KTtcXFxcbiAgICAvL+mihOivu1xcXFxuICAgIC8vbG9nKCd1cmw6Jyt1cmwpO1xcXFxuICAgIHZhciB0ZW1wID0gZmV0Y2godXJsKTtcXFxcbiAgICB2YXIgYWwgPSBwZGZhKHRlbXAsIFxcXFxcXFwiYm9keSYmYVxcXFxcXFwiKTtcXFxcbiAgICBpZiAodGVtcC5zZWFyY2goL3dpbmRvdy5sb2NhdGlvbi5ocmVmLykgIT0gLTEgJiYgYWwubGVuZ3RoID09IDApIHtcXFxcbiAgICAgICAgTVlfVVJMID0gdXJsO1xcXFxuICAgICAgICB2YXIgdGUgPSB0ZW1wLnJlcGxhY2UoLy4raHJlZj1cXFxcXFxcIiguKj8pXFxcXFxcXCIuKy9nLCAnPGEgaHJlZj1cXFxcXFxcIiQxXFxcXFxcXCI+PC9hPicpO1xcXFxuICAgICAgICB1cmwgPSBwZCh0ZSwgXFxcXFxcXCJhJiZocmVmXFxcXFxcXCIpO1xcXFxuICAgICAgICBsb2coJ2pz6YeN5a6a5ZCROicgKyB1cmwpO1xcXFxuICAgIH0gZWxzZSB7XFxcXG4gICAgICAgIGh0bWwgPSB0ZW1wO1xcXFxuICAgIH1cXFxcblxcXFxuICAgIHB1dE15VmFyKCd3ZWJ1cmwnLCB1cmwpO1xcXFxuXFxcXG59IGVsc2Uge1xcXFxuICAgIHVybCA9IGdldE15VmFyKCd3ZWJ1cmwnKTtcXFxcbn1cXFxcbnZhciBkdXJsID0gdXJsO1xcXFxubG9nKCfkuoznuqfpobXpnaI6JyArIGR1cmwpO1xcXFxuXFxcXG5pZiAoZ2V0SXRlbSgnYWknLCAnMCcpID09ICcxJykge1xcXFxuICAgIHZhciBsYXp5ID0gJCgnJykubGF6eVJ1bGUoKCkgPT4ge1xcXFxuICAgICAgICB0cnkge1xcXFxuICAgICAgICAgICAgdmFyIGh0bWwgPSBKU09OLnBhcnNlKHJlcXVlc3QoaW5wdXQpLm1hdGNoKC9yIHBsYXllcl8uKj89KC4qPyk8LylbMV0pXFxcXG4gICAgICAgICAgICB2YXIgdXJsID0gaHRtbC51cmxcXFxcbiAgICAgICAgICAgIGlmIChodG1sLmVuY3J5cHQgPT0gJzEnKSB7XFxcXG4gICAgICAgICAgICAgICAgdXJsID0gdW5lc2NhcGUodXJsKTtcXFxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaHRtbC5lbmNyeXB0ID09ICcyJykge1xcXFxuICAgICAgICAgICAgICAgIHVybCA9IHVuZXNjYXBlKGJhc2U2NERlY29kZSh1cmwpKTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIGlmICgvbTN1OHxtcDQvLnRlc3QodXJsKSkge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiB1cmxcXFxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuICd2aWRlbzovLycgKyBpbnB1dFxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9IGNhdGNoIChlKSB7XFxcXG4gICAgICAgICAgICByZXR1cm4gJ3ZpZGVvOi8vJyArIGlucHV0XFxcXG4gICAgICAgIH1cXFxcbiAgICB9KVxcXFxuXFxcXG4gICAgdHJ5IHtcXFxcbiAgICAgICAgbG9nKHVybClcXFxcbiAgICAgICAgTVlfVVJMID0gJ2hpa2VyOi8vZW1wdHkjIycgKyB1cmxcXFxcbiAgICAgICAgcmVxdWlyZShjb25maWcu6Ieq5Yqo5Yy56YWNKTtcXFxcbiAgICAgICAg6Ieq5Yqo5LqM57qnKGxhenkpO1xcXFxuICAgICAgICBwdXRNeVZhcignYm0nLCAnMScpXFxcXG4gICAgfSBjYXRjaCB7XFxcXG4gICAgICAgIHB1dE15VmFyKCdibScsICcwJylcXFxcbiAgICB9XFxcXG59XFxcXG5cXFxcblxcXFxubG9nKCfmqKHmnb86JyArIGdldE15VmFyKCdibScsICcwJykpXFxcXG5cXFxcbmlmIChnZXRNeVZhcignYm0nLCAnMCcpID09ICcwJykge1xcXFxuXFxcXG4gICAgdmFyIGQgPSBbXTtcXFxcbiAgICBNWV9VUkwgPSB1cmxcXFxcblxcXFxuICAgIGZ1bmN0aW9uIGdldFRpdGxlKGh0bWwsIHMpIHtcXFxcbiAgICAgICAgdmFyIHRpdGxlID0gJyc7XFxcXG4gICAgICAgIHZhciB0aXRsZXMgPSBwZGZhKGh0bWwsIHMpO1xcXFxuICAgICAgICAvL2xvZyh0aXRsZXMpO1xcXFxuICAgICAgICBpZiAodGl0bGVzLmxlbmd0aCA9PSAwKSB7XFxcXG4gICAgICAgICAgICByZXR1cm4gdGl0bGVcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBmb3IgKGxldCB4IG9mIHRpdGxlcykge1xcXFxuICAgICAgICAgICAgaWYgKHguaW5jbHVkZXMoJzxmb250JykpIHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZSA9IHBkZmgoeCwgJ2gxLS1mb250JiZUZXh0Jyk7XFxcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHguaW5jbHVkZXMoJzxzcGFuJykpIHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZSA9IHBkZmgoeCwgJ2gxLS1zcGFuJiZUZXh0Jyk7XFxcXG4gICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgIHRpdGxlID0gcGRmaCh4LCAnVGV4dCcpO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgaWYgKHRpdGxlICE9ICcnKSB7XFxcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxcXG4gICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHJldHVybiB0aXRsZVxcXFxuICAgIH1cXFxcblxcXFxuICAgIGlmIChodG1sID09IFxcXFxcXFwiXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgaHRtbCA9IGZldGNoUEModXJsKVxcXFxuICAgIH1cXFxcblxcXFxuICAgIGxldCBhbGlzdCA9IHBkZmEoaHRtbCwgXFxcXFxcXCJib2R5JiZhXFxcXFxcXCIpO1xcXFxuICAgIC8qaWYoaHRtbC5zZWFyY2goL3dpbmRvdy5sb2NhdGlvbi5ocmVmLykhPS0xJiZhbGlzdC5sZW5ndGg9PTApe1xcXFxuICAgICAgICBNWV9VUkw9dXJsO1xcXFxuICAgIHZhciB0ZW1wPWh0bWwucmVwbGFjZSgvLitocmVmPVxcXFxcXFwiKC4qPylcXFxcXFxcIi4rL2csJzxhIGhyZWY9XFxcXFxcXCIkMVxcXFxcXFwiPjwvYT4nKTtcXFxcbiAgICB1cmw9cGQodGVtcCxcXFxcXFxcImEmJmhyZWZcXFxcXFxcIik7XFxcXG4gICAgbG9nKCdqc+mHjeWumuWQkTonK3VybCk7XFxcXG4gICAgcHV0TXlWYXIoJ3dlYnVybCcsIHVybCk7XFxcXG4gICAgaHRtbCA9IGZldGNoUEModXJsKTtcXFxcbiAgICBhbGlzdCA9IHBkZmEoaHRtbCwgXFxcXFxcXCJib2R5JiZhXFxcXFxcXCIpO1xcXFxuICAgIH0qL1xcXFxuXFxcXG4gICAgbGV0IGFyciA9IGFsaXN0Lm1hcChpdCA9PiB7XFxcXG4gICAgICAgIHJldHVybiB7XFxcXG4gICAgICAgICAgICAvL2h0bWw6IGl0LFxcXFxuICAgICAgICAgICAgdGV4dDogcGRmaChpdCwgXFxcXFxcXCJhJiZUZXh0XFxcXFxcXCIpLFxcXFxuICAgICAgICAgICAgdGl0bGU6IHBkZmgoaXQsIFxcXFxcXFwiYSYmdGl0bGVcXFxcXFxcIiksXFxcXG4gICAgICAgICAgICBocmVmOiBwZChpdCwgXFxcXFxcXCJhJiZocmVmXFxcXFxcXCIsIHVybClcXFxcbiAgICAgICAgfVxcXFxuICAgIH0pO1xcXFxuXFxcXG5cXFxcbiAgICB2YXIgdGl0bGUgPSBnZXRUaXRsZShodG1sLCAnYm9keSYmaDEnKTtcXFxcbiAgICBpZiAodGl0bGUgPT0gJycpIHtcXFxcbiAgICAgICAgdGl0bGUgPSBnZXRUaXRsZShodG1sLCBcXFxcXFxcImJvZHkmJmgzW2NsYXNzKj0ndGl0bGUnXVxcXFxcXFwiKTtcXFxcbiAgICB9XFxcXG4gICAgaWYgKHRpdGxlID09ICcnKSB7XFxcXG4gICAgICAgIHRpdGxlID0gZ2V0VGl0bGUoaHRtbCwgXFxcXFxcXCJoZWFkJiZ0aXRsZVxcXFxcXFwiKTtcXFxcbiAgICB9XFxcXG4gICAgaWYgKGR0aXRsZSAhPSBcXFxcXFxcIlxcXFxcXFwiKSB7XFxcXG4gICAgICAgIHNldFBhZ2VUaXRsZShkdGl0bGUpO1xcXFxuICAgIH0gZWxzZSBpZiAoZ2V0UGFnZVRpdGxlKCkuaW5jbHVkZXMoJ+ivpuaDhScpKSB7XFxcXG4gICAgICAgIGlmICh0aXRsZSAhPSAnJykge1xcXFxuICAgICAgICAgICAgaWYgKHRpdGxlLmluY2x1ZGVzKCctJykpIHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZSA9IHRpdGxlLnNwbGl0KCctJylbMF0udHJpbSgpXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICBzZXRQYWdlVGl0bGUodGl0bGUpXFxcXG4gICAgICAgIH1cXFxcbiAgICB9XFxcXG5cXFxcblxcXFxuICAgIC8vbG9nKGFycik7XFxcXG4gICAgbGV0IGRlYnVnID0gZmFsc2U7XFxcXG5cXFxcbiAgICBmdW5jdGlvbiBjbGVhclRleHQoaXQpIHtcXFxcbiAgICAgICAgcmV0dXJuIGl0LnJlcGxhY2UoL+esrHzpm4Z856ugL2csIFxcXFxcXFwiXFxcXFxcXCIpO1xcXFxuICAgIH1cXFxcblxcXFxuICAgIGZ1bmN0aW9uIGlzTW92aWUoaXQpIHtcXFxcbiAgICAgICAgaWYgKGl0ID09IG51bGwgfHwgaXQudGV4dCA9PSBudWxsKSB7XFxcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgaWYgKG5vZmlsZShpdCkpIHtcXFxcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBsZXQgdGl0ID0gaXQudGl0bGUgfHwgXFxcXFxcXCJcXFxcXFxcIjtcXFxcbiAgICAgICAgaXQgPSBpdC50ZXh0IHx8IFxcXFxcXFwiXFxcXFxcXCI7XFxcXG4gICAgICAgIGlmIChpdCA9PSBcXFxcXFxcIlxcXFxcXFwiIHx8IGl0Lmxlbmd0aCA+IDgpIHtcXFxcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICAvL+aOkumZpFxcXFxuICAgICAgICBsZXQgcmVnID0gL1xcXFxcXFxcLnzpq5jmuIXnm7Tmkq185YaZ55yf5o6o6I2QfOW9semZonzlvbHop4Z86JOd5YWJ55S15b2xfOmrmOa4heeUteW9sXznrKzkuIDlraN856ys5LqM5a2jfOesrOS4ieWto3znrKzlm5vlraN856ys5LqU5a2jLztcXFxcbiAgICAgICAgaWYgKHRpdCAhPSBcXFxcXFxcIlxcXFxcXFwiICYmICF0aXQuaW5jbHVkZXMoaXQpIHx8IHJlZy50ZXN0KGl0KSkge1xcXFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHJldHVybiBpdC5tYXRjaCgv5Y6f55S7fOWkh+eUqHzok53lhYl86LaF5riFfOmrmOa4hXzmraPniYd86Z+p54mIfDRLfDRrfDEwODBQfDcyMFB8VEN8SER8QkR85Lit5a2XLylcXFxcbiAgICB9XFxcXG5cXFxcbiAgICBmdW5jdGlvbiBub3RDaGFwdGVyKGl0KSB7XFxcXG4gICAgICAgIGlmIChpdCA9PSBudWxsIHx8IGl0LnRleHQgPT0gbnVsbCkge1xcXFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcmV0dXJuIGl0LnRleHQubWF0Y2goL1swLTldXFxcXFxcXFwuWzAtOV3liIYvKTtcXFxcbiAgICB9XFxcXG5cXFxcbiAgICBmdW5jdGlvbiBpc0NoYXB0ZXIoaXQsIHByZSwgbmV4dCkge1xcXFxuICAgICAgICBpZiAobm90Q2hhcHRlcihpdCkpIHtcXFxcbiAgICAgICAgICAgIC8v5LyY5YWI5o6S6ZmkXFxcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgLy/liKTmlq3mmK/kuI3mmK/nlLXlvbFcXFxcbiAgICAgICAgaWYgKGlzTW92aWUoaXQpKSB7XFxcXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICByZXR1cm4gaXNDaGFwdGVyMChpdCwgcHJlKSB8fCBpc0NoYXB0ZXIwKGl0LCBuZXh0KTtcXFxcbiAgICB9XFxcXG5cXFxcbiAgICBmdW5jdGlvbiBnZXRDaGFwdGVyTnVtKGl0KSB7XFxcXG4gICAgICAgIGlmIChpdCA9PSBudWxsIHx8IGl0LnRleHQgPT0gbnVsbCkge1xcXFxuICAgICAgICAgICAgcmV0dXJuIC0xO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGl0ID0gaXQudGV4dCB8fCBcXFxcXFxcIlxcXFxcXFwiO1xcXFxuICAgICAgICBpZiAoaXQgPT0gXFxcXFxcXCJcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgcmV0dXJuIC0xO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGl0ID0gY2xlYXJUZXh0KGl0KTtcXFxcbiAgICAgICAgbGV0IHJlZyA9IC9eWzAtOV0qJC87XFxcXG4gICAgICAgIGlmICghcmVnLnRlc3QoaXQpKSB7XFxcXG4gICAgICAgICAgICByZXR1cm4gLTE7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgaXQgPSBwYXJzZUludChpdCk7XFxcXG4gICAgICAgIGlmIChpc05hTihpdCkpIHtcXFxcbiAgICAgICAgICAgIHJldHVybiAtMTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBpZiAoaXQgPiAxOTAwICYmIGl0IDwgMjEwMCkge1xcXFxuICAgICAgICAgICAgcmV0dXJuIC0xO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHJldHVybiBpdDtcXFxcbiAgICB9XFxcXG5cXFxcbiAgICBmdW5jdGlvbiBpc0NoYXB0ZXIwKGl0LCBicm90aGVyKSB7XFxcXG4gICAgICAgIC8qaWYgKGRlYnVnKSB7XFxcXG4gICAgICAgICAgICBsb2coe1xcXFxuICAgICAgICAgICAgICAgIGl0OiBpdCxcXFxcbiAgICAgICAgICAgICAgICBicm90aGVyOiBicm90aGVyXFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgfSovXFxcXG4gICAgICAgIGl0ID0gZ2V0Q2hhcHRlck51bShpdCk7XFxcXG4gICAgICAgIC8vaWYgKGRlYnVnKSBsb2coaXQpO1xcXFxuICAgICAgICBpZiAoaXQgPCAwKSB7XFxcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgYnJvdGhlciA9IGdldENoYXB0ZXJOdW0oYnJvdGhlcik7XFxcXG4gICAgICAgIC8vaWYgKGRlYnVnKSBsb2coYnJvdGhlcik7XFxcXG4gICAgICAgIGlmIChicm90aGVyIDwgMCkge1xcXFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHJldHVybiBpdCAtIGJyb3RoZXIgPCAyICYmIGl0IC0gYnJvdGhlciA+IC0yO1xcXFxuICAgIH1cXFxcblxcXFxuICAgIGxldCB0ZnB1c2ggPSBnZXRJdGVtKCd3ZWJwdXNoJywgJzAnKTtcXFxcblxcXFxuICAgIGxldCBfd2ViID0gJC50b1N0cmluZygodGZwdXNoKSA9PiB7XFxcXG4gICAgICAgIGxldCB1cmxzID0gX2dldFVybHMoKTtcXFxcbiAgICAgICAgbGV0IHJlZyA9IC9cXFxcXFxcXC5odG1sfFxcXFxcXFxcLmNzc3xcXFxcXFxcXC5qcy87XFxcXG4gICAgICAgIGZvciAobGV0IGsgaW4gdXJscykge1xcXFxuICAgICAgICAgICAgaWYgKCFyZWcudGVzdCh1cmxzW2tdKSAmJiB1cmxzW2tdLm1hdGNoKC9cXFxcXFxcXC5tcDR8XFxcXFxcXFwubTN1OC8pKSB7XFxcXG4gICAgICAgICAgICAgICAgZnlfYnJpZGdlX2FwcC5sb2codXJsc1trXSk7XFxcXG4gICAgICAgICAgICAgICAgLy9yZXR1cm4gZnlfYnJpZGdlX2FwcC5nZXRIZWFkZXJVcmwodXJsc1trXS5yZXBsYWNlKC8uKj91cmw9LywgXFxcXFxcXCJcXFxcXFxcIikpICsgXFxcXFxcXCIjaWdub3JlSW1nPXRydWUjXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICAgICAgaWYgKHRmcHVzaCA9PSAnMCcpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ5X2JyaWRnZV9hcHAuZ2V0SGVhZGVyVXJsKHVybHNba10ucmVwbGFjZSgvLio/dXJsPS8sIFxcXFxcXFwiXFxcXFxcXCIpKSArIFxcXFxcXFwiI2lnbm9yZUltZz10cnVlI1xcXFxcXFwiO1xcXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGxldCBwbGF5ID0gZnlfYnJpZGdlX2FwcC5nZXRIZWFkZXJVcmwodXJsc1trXS5yZXBsYWNlKC8uKj91cmw9LywgXFxcXFxcXCJcXFxcXFxcIikpO1xcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vcGFnZS9wdXNoP3B1c2h1cmw9JyArIGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeSh7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXFxcXFxcIm5hbWVcXFxcXFxcIjogZG9jdW1lbnQudGl0bGUsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXFxcXFxcInVybFxcXFxcXFwiOiBwbGF5XFxcXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH1cXFxcbiAgICB9LCB0ZnB1c2gpO1xcXFxuXFxcXG4gICAgZnVuY3Rpb24gX193ZWIobW9kZSkge1xcXFxuICAgICAgICByZXR1cm4gJC50b1N0cmluZygodGZwdXNoKSA9PiB7XFxcXG4gICAgICAgICAgICBsZXQgdXJscyA9IF9nZXRVcmxzKCk7XFxcXG4gICAgICAgICAgICBsZXQgcmVnID0gL1xcXFxcXFxcLmh0bWx8XFxcXFxcXFwuY3NzfFxcXFxcXFxcLmpzLztcXFxcbiAgICAgICAgICAgIGZvciAobGV0IGsgaW4gdXJscykge1xcXFxuICAgICAgICAgICAgICAgIGlmICghcmVnLnRlc3QodXJsc1trXSkgJiYgdXJsc1trXS5tYXRjaCgvXFxcXFxcXFwubXA0fFxcXFxcXFxcLm0zdTgvKSkge1xcXFxuICAgICAgICAgICAgICAgICAgICBmeV9icmlkZ2VfYXBwLmxvZyh1cmxzW2tdKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gZnlfYnJpZGdlX2FwcC5nZXRIZWFkZXJVcmwodXJsc1trXS5yZXBsYWNlKC8uKj91cmw9LywgXFxcXFxcXCJcXFxcXFxcIikpICsgXFxcXFxcXCIjaWdub3JlSW1nPXRydWUjXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZnB1c2ggPT0gJzAnKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnlfYnJpZGdlX2FwcC5nZXRIZWFkZXJVcmwodXJsc1trXS5yZXBsYWNlKC8uKj91cmw9LywgXFxcXFxcXCJcXFxcXFxcIikpICsgXFxcXFxcXCIjaWdub3JlSW1nPXRydWUjXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcGxheSA9IGZ5X2JyaWRnZV9hcHAuZ2V0SGVhZGVyVXJsKHVybHNba10ucmVwbGFjZSgvLio/dXJsPS8sIFxcXFxcXFwiXFxcXFxcXCIpKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9wYWdlL3B1c2g/cHVzaHVybD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxcXFxcIm5hbWVcXFxcXFxcIjogZG9jdW1lbnQudGl0bGUsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJ1cmxcXFxcXFxcIjogcGxheVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xcXFxuICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9LCBtb2RlKTtcXFxcbiAgICB9XFxcXG5cXFxcbiAgICAkLmV4dGVuZCh7XFxcXG4gICAgICAgIGx3ZWI6IF9fd2ViXFxcXG4gICAgfSlcXFxcblxcXFxuICAgIGxldCB3ZWIgPSBnZXRJdGVtKCd3ZWInLCAnMCcpO1xcXFxuICAgIHZhciBwdXNodHlwZSA9IFsn5YiX6KGoJywgJ+WNlembhiddXFxcXG4gICAgdmFyIHBhcnNldHlwZSA9IFsnV2Vi5ZeF5o6iOjAnLCAn6KeG6aKR5ZeF5o6iOjEnLCAnZG3nm5LlrZA6MiddXFxcXG4gICAgbG9nKCfmjqjpgIHnsbvlnos6JyArIHB1c2h0eXBlW3BhcnNlSW50KHRmcHVzaCldKVxcXFxuICAgIGxvZygn5ZeF5o6i57G75Z6LOicgKyBwYXJzZXR5cGVbcGFyc2VJbnQod2ViKV0uc3BsaXQoJzonKVswXSlcXFxcblxcXFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XFxcXG4gICAgICAgIGxldCBpdCA9IGFycltpXTtcXFxcbiAgICAgICAgbGV0IHQgPSBpdC50ZXh0O1xcXFxuICAgICAgICBpZiAoIWl0LmhyZWYgfHwgaXQuaHJlZiA9PSBcXFxcXFxcIlxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICBjb250aW51ZTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBsZXQgcHJlID0gaSA9PSAwID8gbnVsbCA6IGFycltpIC0gMV07XFxcXG4gICAgICAgIGxldCBuZXh0ID0gaSA9PSAoYXJyLmxlbmd0aCAtIDEpID8gbnVsbCA6IGFycltpICsgMV07XFxcXG4gICAgICAgIGlmIChpc0NoYXB0ZXIoaXQsIHByZSwgbmV4dCkpIHtcXFxcbiAgICAgICAgICAgIGlmICh0ZnB1c2ggPT0gJzEnKSB7XFxcXG4gICAgICAgICAgICAgICAgLyp2YXIgdXJseCA9IFxcXFxcXFwid2ViUnVsZTovL1xcXFxcXFwiICsgaXQuaHJlZiArIFxcXFxcXFwiQFxcXFxcXFwiICsgX3dlYjtcXFxcbiAgICAgICAgICAgICAgICB2YXIgZXh0cmF4ID0ge1xcXFxuICAgICAgICAgICAgICAgICAgICBqc0xvYWRpbmdJbmplY3Q6IHRydWUsXFxcXG4gICAgICAgICAgICAgICAgICAgIGlkOiBpdC5ocmVmLFxcXFxuICAgICAgICAgICAgICAgICAgICBjbHM6ICdwbGF5cycsXFxcXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrUnVsZXM6IFsnLm00YScsICcubXAzJywgJy5mbHYnLCAnLmF2aScsICcuM2dwJywgJy5tcGVnJywgJy53bXYnLCAnLm1vdicsICcucm12YicsICcuZ2lmJywgJy5qcGVnJywgJy5wbmcnLCAnLmljbycsICcuc3ZnJ11cXFxcbiAgICAgICAgICAgICAgICB9OyovXFxcXG4gICAgICAgICAgICAgICAgdmFyIHVybHggPSAnaGlrZXI6Ly9wYWdlL3B1c2g/JnB1c2h1cmw9JyArIGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeSh7XFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwibmFtZVxcXFxcXFwiOiBnZXRQYWdlVGl0bGUoKSxcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJ1cmxcXFxcXFxcIjogaXQudGV4dCArICckJyArIGl0LmhyZWYsXFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiY29udGVudFxcXFxcXFwiOiBNWV9VUkwudGl0bGUsXFxcXG4gICAgICAgICAgICAgICAgfSkpO1xcXFxuICAgICAgICAgICAgICAgIHZhciBleHRyYXggPSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGlkOiBpdC5ocmVmLFxcXFxuICAgICAgICAgICAgICAgICAgICBjbHM6ICdwbGF5cycsXFxcXG4gICAgICAgICAgICAgICAgfTtcXFxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgaWYgKHdlYiA9PSAnMCcpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVybHggPSBcXFxcXFxcIndlYlJ1bGU6Ly9cXFxcXFxcIiArIGl0LmhyZWYgKyBcXFxcXFxcIkBcXFxcXFxcIiArIF93ZWI7XFxcXG4gICAgICAgICAgICAgICAgICAgIHZhciBleHRyYXggPSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBqc0xvYWRpbmdJbmplY3Q6IHRydWUsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaXQuaHJlZixcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsczogJ3BsYXlzJyxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrUnVsZXM6IFsnLm00YScsICcubXAzJywgJy5mbHYnLCAnLmF2aScsICcuM2dwJywgJy5tcGVnJywgJy53bXYnLCAnLm1vdicsICcucm12YicsICcuZ2lmJywgJy5qcGVnJywgJy5wbmcnLCAnLmljbycsICcuc3ZnJ11cXFxcbiAgICAgICAgICAgICAgICAgICAgfTtcXFxcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHdlYiA9PSAnMScpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVybHggPSBcXFxcXFxcInZpZGVvOi8vXFxcXFxcXCIgKyBpdC5ocmVmO1xcXFxuICAgICAgICAgICAgICAgICAgICB2YXIgZXh0cmF4ID0ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGl0LmhyZWYsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBjbHM6ICdwbGF5cycsXFxcXG4gICAgICAgICAgICAgICAgICAgIH07XFxcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh3ZWIgPT0gJzInKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGxhenkgPSAkKCcnKS5sYXp5UnVsZSgoKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvbGF6eVRvWDU/cnVsZT1kbeebkuWtkCcpLnZpZGVvWDUoKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVybHggPSBpdC5ocmVmICsgbGF6eVxcXFxuICAgICAgICAgICAgICAgICAgICB2YXIgZXh0cmF4ID0ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGl0LmhyZWYsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBjbHM6ICdwbGF5cycsXFxcXG4gICAgICAgICAgICAgICAgICAgIH07XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogdCxcXFxcbiAgICAgICAgICAgICAgICB1cmw6IHVybHgsXFxcXG4gICAgICAgICAgICAgICAgcGg6IHQgKyBcXFxcXFxcIiRcXFxcXFxcIiArIGl0LmhyZWYsXFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF8zXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgZXh0cmE6IGV4dHJheFxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9XFxcXG4gICAgaWYgKGQubGVuZ3RoID09IDApIHtcXFxcbiAgICAgICAgLy/ljLnphY3lpLHotKVcXFxcbiAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIlxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgdXJsOiB1cmwsXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJ4NV93ZWJ2aWV3X3NpbmdsZVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgZGVzYzogXFxcXFxcXCJmbG9hdCYmMTAwJVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgcGljX3VybDogXFxcXFxcXCJcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgZmxvYXRWaWRlbzogdHJ1ZSxcXFxcbiAgICAgICAgICAgICAgICBjYW5CYWNrOiB0cnVlLFxcXFxuICAgICAgICAgICAgICAgIGJsb2NrUnVsZXM6IFtcXFxcXFxcIi5naWZcXFxcXFxcIiwgXFxcXFxcXCIvYWQvXFxcXFxcXCIsIFxcXFxcXFwiZ29vZ2xlXFxcXFxcXCIsIFxcXFxcXFwiL3NoL3RvL1xcXFxcXFwiLCBcXFxcXFxcIi5HSUZcXFxcXFxcIl1cXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSk7XFxcXG4gICAgICAgIHRvYXN0KFxcXFxcXFwiQUnljLnphY3lpLHotKXvvIzlt7Lkvb/nlKhYNeWKoOi9vVxcXFxcXFwiKTtcXFxcbiAgICAgICAgbG9nKFxcXFxcXFwi5b2T5YmN6aG16Z2i5Zyw5Z2AOiBcXFxcXFxcIiArIHVybClcXFxcbiAgICAgICAgc2V0UmVzdWx0KGQpO1xcXFxuICAgIH0gZWxzZSB7XFxcXG4gICAgICAgIC8v5Li657q/6Lev5Yqg5YiG5Ymy57q/XFxcXG4gICAgICAgIGxldCBkMiA9IFtdO1xcXFxuICAgICAgICBsZXQgbXRhYiA9IFtdO1xcXFxuXFxcXG4gICAgICAgIGQgPSB1bmlxdWUoZClcXFxcbiAgICAgICAgLy9sb2coQml0VFMpXFxcXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZC5sZW5ndGg7IGkrKykge1xcXFxuICAgICAgICAgICAgZDIucHVzaChkW2ldKTtcXFxcbiAgICAgICAgICAgIG10YWIucHVzaChkW2ldLnBoKTtcXFxcbiAgICAgICAgICAgIGlmIChpIDwgZC5sZW5ndGggLSAxKSB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IGl0ID0gZFtpXTtcXFxcbiAgICAgICAgICAgICAgICBsZXQgdDEgPSBwYXJzZUludChjbGVhclRleHQoaXQudGl0bGUpKTtcXFxcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGRbaSArIDFdO1xcXFxuICAgICAgICAgICAgICAgIGxldCB0MiA9IHBhcnNlSW50KGNsZWFyVGV4dChuZXh0LnRpdGxlKSk7XFxcXG4gICAgICAgICAgICAgICAgaWYgKHQyIC0gdDEgPiAxIHx8IHQxIC0gdDIgPiAxKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIG10YWIucHVzaCgnIycpO1xcXFxuICAgICAgICAgICAgICAgICAgICBkMi5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImJpZ19ibGFua19ibG9ja1xcXFxcXFwiXFxcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgICAgICBkMi5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImxpbmVfYmxhbmtcXFxcXFxcIlxcXFxuICAgICAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgICAgICAgICAgZDIucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJiaWdfYmxhbmtfYmxvY2tcXFxcXFxcIlxcXFxuICAgICAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH1cXFxcblxcXFxuICAgICAgICBsZXQgcGxheWwgPSBtdGFiLmpvaW4oJyMnKS5yZXBsYWNlKC8jIyMvZywgJyQkJCQkJCcpO1xcXFxuXFxcXG5cXFxcbiAgICAgICAgbGV0IGZyb20gPSBbXTtcXFxcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwbGF5bC5zcGxpdCgnJCQkJykubGVuZ3RoOyBqKyspIHtcXFxcbiAgICAgICAgICAgIGZyb20ucHVzaChcXFxcXFxcIuaSreaUvuWIl+ihqFxcXFxcXFwiICsgW2ogKyAxXSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgbGV0IHB1c2ggPSBKU09OLnN0cmluZ2lmeSh7XFxcXG4gICAgICAgICAgICBcXFxcXFxcIm5hbWVcXFxcXFxcIjogZ2V0UGFnZVRpdGxlKCksXFxcXG4gICAgICAgICAgICBcXFxcXFxcImZyb21cXFxcXFxcIjogZnJvbS5qb2luKCckJCQnKSxcXFxcbiAgICAgICAgICAgIFxcXFxcXFwidXJsXFxcXFxcXCI6IHBsYXlsLnJlcGxhY2UoL1xcXFxcXFxcJi9nLCAn77yG77yGJyksXFxcXG4gICAgICAgICAgICBcXFxcXFxcImNvbnRlbnRcXFxcXFxcIjogTVlfUlVMRS50aXRsZVxcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgLy9sb2cocHVzaCk7XFxcXG4gICAgICAgIFxcXFxuICAgICAgICB2YXIgdGNvbmZpZz17XFxcXG4gICAgICAgICAgICBuYW1lOmdldFBhZ2VUaXRsZSgpLFxcXFxuICAgICAgICAgICAgY29udGVudDpNWV9SVUxFLnRpdGxlXFxcXG4gICAgICAgIH1cXFxcblxcXFxuICAgICAgICBkMi51bnNoaWZ0KHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuaOqOmAgeacrOmhtT0+VFZCb3hcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIHVybDogJChwdXNoKS5sYXp5UnVsZSgodGNvbmZpZykgPT4ge1xcXFxuICAgICAgICAgICAgICAgIHZhciBkbGlzdCA9IHN0b3JhZ2UwLmdldE15VmFyKFxcXFxcXFwiZHVvc2VsZWN0XFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgIGlmKGRsaXN0Lmxlbmd0aD4wKXtcXFxcbiAgICAgICAgICAgICAgICB2YXIgcGxheXM9ZGxpc3QubWFwKHg9PngudGl0bGUrXFxcXFxcXCIkXFxcXFxcXCIreC51cmwpLmpvaW4oXFxcXFxcXCIjXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgIHZhciBkcHVzaCA9IEpTT04uc3RyaW5naWZ5KHtcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJuYW1lXFxcXFxcXCI6IHRjb25maWcubmFtZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJmcm9tXFxcXFxcXCI6IFxcXFxcXFwi5pKt5pS+5YiX6KGoXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwidXJsXFxcXFxcXCI6IHBsYXlzLFxcXFxuICAgICAgICAgICAgICAgICAgICBcXFxcXFxcImNvbnRlbnRcXFxcXFxcIjogdGNvbmZpZy5jb250ZW50XFxcXG4gICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgICAvL2xvZyhkcHVzaClcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vcGFnZS9wdXNoP3B1c2h1cmw9JyArIGVuY29kZVVSSUNvbXBvbmVudChkcHVzaCk7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIFxcXFxuICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9wYWdlL3B1c2g/cHVzaHVybD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGlucHV0KTtcXFxcbiAgICAgICAgICAgIH0sdGNvbmZpZyksXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJzY3JvbGxfYnV0dG9uXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBleHRyYTp7XFxcXG4gICAgICAgICAgICAgICAgaWQ6J3B1c2hzJyxcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSk7XFxcXG4gICAgICAgIFxcXFxuICAgICAgICBcXFxcbiAgICAgICAgZDIudW5zaGlmdCh7XFxcXG4gICAgdGl0bGU6ICfpgInmjqgnLFxcXFxuICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbicsXFxcXG4gICAgdXJsOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKCgpID0+IHtcXFxcbiAgICAgICAgc2V0SXRlbSgnd2VicHVzaCcsJzAnKTtcXFxcbiAgICAgICAgXFxcXG4gICAgICAgIHVwZGF0ZUl0ZW0oJ3NwdXNoJywge1xcXFxuICAgICAgICAgICAgdGl0bGU6ICfljZXmjqgnLFxcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgXFxcXG4gICAgICAgIGlmIChmaW5kSXRlbSgnZHNlbGVjdCcpLmV4dHJhLm1vZGUgPT0gJ29wZW4nKSB7XFxcXG4gICAgICAgICAgICB0b2FzdCgn6YCJ5o6o5qih5byP5YWz6ZetJyk7XFxcXG4gICAgICAgICAgICBzdG9yYWdlMC5wdXRNeVZhcihcXFxcXFxcImR1b3NlbGVjdFxcXFxcXFwiLCBbXSk7XFxcXG4gICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiO1xcXFxuICAgICAgICB9XFxcXG5cXFxcbiAgICAgICAgbGV0IElkcyA9IChmaW5kSXRlbXNCeUNscygncGxheXMnKSkubWFwKGl0ID0+IGl0LmV4dHJhLmlkKTtcXFxcbiAgICAgICAgSWRzLmZvckVhY2goeCA9PiB7XFxcXG4gICAgICAgICAgICB2YXIgdGl0bGUgPSBmaW5kSXRlbSh4KS50aXRsZTtcXFxcblxcXFxuICAgICAgICAgICAgdXBkYXRlSXRlbSh4LCB7XFxcXG4gICAgICAgICAgICAgICAgdXJsOiAkLm1zbSh0aXRsZSwgeCksXFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgICAgIHZhciB0aXRsZSA9IGZpbmRJdGVtKCdkc2VsZWN0JykudGl0bGU7XFxcXG4gICAgICAgIHVwZGF0ZUl0ZW0oJ2RzZWxlY3QnLCB7XFxcXG4gICAgICAgICAgICB0aXRsZTogYOKAnOKAnOKAneKAnTxzcGFuIHN0eWxlPVxcXFxcXFwiY29sb3I6IzQ2ODJCNFxcXFxcXFwiPmAgKyB0aXRsZSxcXFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgbW9kZTogJ29wZW4nXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgICBcXFxcbiAgICAgICAgdXBkYXRlSXRlbSgncHVzaHMnLCB7XFxcXG4gICAgICAgICAgICB0aXRsZTogJ+aOqOmAgemAieS4rT0+VFZCb3gnLFxcXFxuICAgICAgICB9KTtcXFxcblxcXFxuICAgICAgICB0b2FzdCgn6YCJ5o6o5qih5byP5byA5ZCvJylcXFxcbiAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgfSksXFxcXG4gICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICBpZDogJ2RzZWxlY3QnLFxcXFxuICAgICAgICAnbW9kZSc6ICdjbG9zZSdcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSlcXFxcblxcXFxuXFxcXG4gICAgICAgIGQyLnVuc2hpZnQoe1xcXFxuICAgICAgICAgICAgdGl0bGU6IChnZXRJdGVtKCd3ZWJwdXNoJywgJzAnKSA9PSAnMScgPyAn4oCc4oCc4oCd4oCdPGZvbnQgY29sb3I9XFxcXFxcXCIjMDBGRjAwXFxcXFxcXCI+5Y2V5o6oPC9mb250PicgOiAn5Y2V5o6oJyksXFxcXG4gICAgICAgICAgICB1cmw6IGBoaWtlcjovL2VtcHR5QGxhenlSdWxlPS5qczpnZXRJdGVtKCd3ZWJwdXNoJywnMCcpPT0nMSc/c2V0SXRlbSgnd2VicHVzaCcsJzAnKTpzZXRJdGVtKCd3ZWJwdXNoJywnMScpO3JlZnJlc2hQYWdlKCk7J3RvYXN0Oi8v5YiH5o2i5oiQ5Yqf77yBJ2AsXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nLFxcXFxuICAgICAgICAgICAgZXh0cmE6e1xcXFxuICAgICAgICAgICAgICAgIGlkOidzcHVzaCcsXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0pO1xcXFxuXFxcXG4gICAgICAgIGQyLnNwbGljZSgzLCAwLCB7XFxcXG4gICAgICAgICAgICB0aXRsZTogcGFyc2V0eXBlW3BhcnNlSW50KHdlYildLnNwbGl0KCc6JylbMF0sXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nLFxcXFxuICAgICAgICAgICAgdXJsOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChpbmYpID0+IHtcXFxcbiAgICAgICAgICAgICAgICBpZiAoZ2V0SXRlbSgnd2VicHVzaCcsICcwJykgPT0gJzEnfHxmaW5kSXRlbSgnZHNlbGVjdCcpLmV4dHJhLm1vZGUgPT0gJ29wZW4nKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/ljZXmjqh86YCJ5o6o5qih5byP5byA5ZCv5peg5rOV5L+u5pS5J1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICBsZXQgYWxsX2NvbHMgPSBpbmZcXFxcbiAgICAgICAgICAgICAgICBsZXQgY29sID0gc3RvcmFnZTAuZ2V0SXRlbSgn5ZeF5o6iJywgJ1dlYuWXheaOoicpO1xcXFxuICAgICAgICAgICAgICAgIGxldCDll4XmjqIgPSBhbGxfY29scy5tYXAoKGl0KSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdC5zcGxpdCgnOicpWzBdID09PSBjb2wgPyAn4p6h77iPJyArIGl0IDogaXQ7XFxcXG4gICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHRpcHMgPSAn6K+36YCJ5oup5ZeF5o6i5qih5byPJztcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJCjll4XmjqIsIDEsIHRpcHMpLnNlbGVjdCgoKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgv4p6h77iPL2csICcnKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgc3RvcmFnZTAuc2V0SXRlbSgn5ZeF5o6iJywgaW5wdXQuc3BsaXQoJzonKVswXSk7XFxcXG4gICAgICAgICAgICAgICAgICAgIHZhciBtb2RlID0gaW5wdXQuc3BsaXQoJzonKVsxXVxcXFxuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlMC5zZXRJdGVtKCd3ZWInLCBtb2RlKVxcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgb2xkSWRzID0gKGZpbmRJdGVtc0J5Q2xzKCdwbGF5cycpKS5tYXAoaXQgPT4gaXQuZXh0cmEuaWQpO1xcXFxuICAgICAgICAgICAgICAgICAgICBvbGRJZHMuZm9yRWFjaCh4ID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlID09ICcwJykge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0oeCwge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IFxcXFxcXFwid2ViUnVsZTovL1xcXFxcXFwiICsgeCArIFxcXFxcXFwiQFxcXFxcXFwiICsgJC5sd2ViKCcwJyksXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc0xvYWRpbmdJbmplY3Q6IHRydWUsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogeCxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsczogJ3BsYXlzJyxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrUnVsZXM6IFsnLm00YScsICcubXAzJywgJy5mbHYnLCAnLmF2aScsICcuM2dwJywgJy5tcGVnJywgJy53bXYnLCAnLm1vdicsICcucm12YicsICcuZ2lmJywgJy5qcGVnJywgJy5wbmcnLCAnLmljbycsICcuc3ZnJ11cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGUgPT0gJzEnKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlSXRlbSh4LCB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogXFxcXFxcXCJ2aWRlbzovL1xcXFxcXFwiICsgeCxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB4LFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xzOiAncGxheXMnLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZSA9PSAnMicpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVJdGVtKHgsIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB4ICsgJCgnJykubGF6eVJ1bGUoKCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2xhenlUb1g1P3J1bGU9ZG3nm5LlrZAnKS52aWRlb1g1KCk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHgsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbHM6ICdwbGF5cycsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlSXRlbSgncGFyc2UnLCB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogc3RvcmFnZTAuZ2V0SXRlbSgn5ZeF5o6iJywgJ1dlYuWXheaOoicpLFxcXFxuICAgICAgICAgICAgICAgICAgICB9KTtcXFxcblxcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5bey5YiH5ZeF5o6i5pa55byP5Li6OicgKyBpbnB1dDtcXFxcbiAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXG4gICAgICAgICAgICB9LCBwYXJzZXR5cGUpLFxcXFxuICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICBpZDogJ3BhcnNlJyxcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSk7XFxcXG5cXFxcbiAgICAgICAgZDIudW5zaGlmdCh7XFxcXG4gICAgICAgICAgICB0aXRsZTogJ+KAnOKAnOKAneKAnTxzbWFsbD7imqHvuI8nICsgZHVybCArICc8L3NtYWxsPicsXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ3RleHRfY2VudGVyXzEnLFxcXFxuICAgICAgICAgICAgdXJsOiBkdXJsLFxcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgXFxcXG4gICAgICAgIFxcXFxuICAgICAgICBpZihNWV9QQVJBTVMud2ViPT1cXFxcXFxcIuWTlOa7tOW9seinhlxcXFxcXFwiKXtcXFxcbiAgICAgICAgICAgIGQyLnVuc2hpZnQoe1xcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiflk5Tmu7TlvbHop4YnLFxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMScsXFxcXG4gICAgICAgICAgICAgICAgdXJsOlxcXFxcXFwiaGlrZXI6Ly9wYWdlL2RldGFpbHM/cnVsZT3lk5TlmIDlvbHop4YmdXJsPVxcXFxcXFwiICsgZHVybCsnI2ltbWVyc2l2ZVRoZW1lIycsXFxcXG4gICAgICAgICAgICB9KVxcXFxuICAgICAgICAgICAgdmFyIGpzcj1KU09OLnBhcnNlKGZldGNoKFxcXFxcXFwiaGlrZXI6Ly9ob21lQOWTlOWYgOW9seinhlxcXFxcXFwiKSkucHJlUnVsZVxcXFxuICAgICAgICAgICAgZXZhbChqc3IpXFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgXFxcXG4gICAgICAgIFxcXFxuICAgICAgICBcXFxcbiAgICAgICAgdmFyIGQzID0gW107XFxcXG5pZiAoZ2V0SXRlbSgnYWknLCAnMCcpID09ICcxJykge1xcXFxuXFxcXG4gICAgZDMucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiBnZXRQYWdlVGl0bGUoKSxcXFxcbiAgICAgICAgaW1nOiAnaHR0cHM6Ly9waWMzLjU4Y2RuLmNvbS5jbi9ub3dhdGVyL3dlYmltL2JpZy9uX3YyODFkNjBiZDEyN2U4NGNkMjg4MDdkNTExNDNlYWE2MWYuZ2lmJyxcXFxcbiAgICAgICAgY29sX3R5cGU6ICdtb3ZpZV8xX3ZlcnRpY2FsX3BpY19ibHVyJyxcXFxcbiAgICAgICAgZXh0cmE6e1xcXFxuICAgICAgICAgICAgaWQ6J2QzJyxcXFxcbiAgICAgICAgfVxcXFxuICAgIH0pXFxcXG4gICAgc2V0UmVzdWx0KGQzKVxcXFxufVxcXFxuICAgICAgICBcXFxcbiAgICAgICAgaWYoZmluZEl0ZW0oJ2QzJykhPW51bGwpe1xcXFxuICAgICAgICAgICAgYWRkSXRlbUFmdGVyKCdkMycsIGQyKTtcXFxcbiAgICAgICAgfWVsc2V7XFxcXG4gICAgICAgIHNldFJlc3VsdChkMilcXFxcbiAgICAgICAgfVxcXFxuICAgIH1cXFxcbn1cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLogZrlkIjmkJzntKJcXFwiLFxcXCJwYXRoXFxcIjpcXFwicHJvXFxcIixcXFwicnVsZVxcXCI6XFxcInZhciBkID0gW107XFxcXG5cXFxcbnZhciBnZXRSYW5nZUNvbG9ycyA9IGZ1bmN0aW9uKCkge8KgwqDCoMKgwqDCoMKgXFxcXG4gICAgcmV0dXJuICcjJyArICgnMDAwMDAnICsgKE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAgPDwgMCkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTYpO8KgwqDCoMKgwqBcXFxcbn1cXFxcblxcXFxudmFyIGltZ3MgPSBbJ2h0dHBzOi8vd3d3LndhbmRvdS5wcm8vZmF2aWNvbi5pY28nLCAnaHR0cHM6Ly9iai5iY2Vib3MuY29tL2JhaWR1LXJtYi12aWRlby1jb3Zlci0xLzc0ZjEzZDA2MjBmNzJiMDBhNGU5YjY3ZjNkYWI5NmQxLnBuZycsICdodHRwczovL2JqLmJjZWJvcy5jb20vYmFpZHUtcm1iLXZpZGVvLWNvdmVyLTEvNzNiOGNmNmFlMDc4MzAzYTU3MmU3NmM3OWRkOTNlN2EucG5nJywgJ2h0dHBzOi8vbS5xbXR2LmFwcC9mYXZpY29uLnBuZycsICdodHRwczovL3d3dy50YnNkeS5jb20vcmVzL21ycy8xL2ltZy85ODM2MzUvMjAyMi8wMS8wMS8xMDEuanBnJ11cXFxcblxcXFxudmFyIG5hbWVzPVsn6LGM6LGGJywgJ+iMtuadr+eLkCcsICfmkJzniYcnLCAn6Z2S6bqmJywgJ+Wcn+aLqOm8oCddO1xcXFxuXFxcXG5pZiAoTVlfUEFHRSA9PSAxKSB7XFxcXG4gICAgbmFtZXMubWFwKCh4LCBpKSA9PiB7XFxcXG4gICAgICAgIHZhciBpeCA9IHN0b3JhZ2UwLmdldE15VmFyKCdwYWdlX2luZGV4JywgMCk7XFxcXG4gICAgICAgIHZhciB0aXRsZSA9IGl4ID09IGkgPyBg4oCc4oCc4oCd4oCdPGZvbnQgY29sb3I9JHtnZXRSYW5nZUNvbG9ycygpfT5gICsgeCArICc8L2ZvbnQ+JyA6IHg7XFxcXG4gICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZTogdGl0bGUsXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ2ljb25fNScsXFxcXG4gICAgICAgICAgICBpbWc6IGltZ3NbaV0sXFxcXG4gICAgICAgICAgICB1cmw6ICQoJycpLmxhenlSdWxlKChpKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgc3RvcmFnZTAucHV0TXlWYXIoJ3BhZ2VfaW5kZXgnLCBpKVxcXFxuICAgICAgICAgICAgICAgIC8vY2xlYXJNeVZhcignc291JylcXFxcbiAgICAgICAgICAgICAgICBjbGVhck15VmFyKCdwYWdlJylcXFxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpXFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+WIh+aNouaIkOWKnydcXFxcbiAgICAgICAgICAgIH0sIGkpLFxcXFxuICAgICAgICB9KVxcXFxuICAgIH0pXFxcXG5cXFxcbiAgICB2YXIgd2ViID0gZ2V0SXRlbSgnd2ViJywgJzAnKVxcXFxuICAgIC8vbG9nKHdlYilcXFxcbiAgICB2YXIgdGl0bGUgPSAnJ1xcXFxuICAgIHN3aXRjaCAod2ViKSB7XFxcXG4gICAgICAgIGNhc2UgJzAnOlxcXFxuICAgICAgICAgICAgdGl0bGUgPSAnV2Vi5ZeF5o6iJ1xcXFxuICAgICAgICAgICAgYnJlYWs7XFxcXG4gICAgICAgIGNhc2UgJzEnOlxcXFxuICAgICAgICAgICAgdGl0bGUgPSAn6KeG6aKR5ZeF5o6iJ1xcXFxuICAgICAgICAgICAgYnJlYWs7XFxcXG4gICAgICAgIGNhc2UgJzInOlxcXFxuICAgICAgICAgICAgdGl0bGUgPSAnZG3nm5LlrZAnXFxcXG4gICAgICAgICAgICBicmVhaztcXFxcbiAgICB9XFxcXG4gICAgc2V0SXRlbSgn5ZeF5o6iJywgdGl0bGUpXFxcXG5cXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogJ+aOqOmAgScsXFxcXG4gICAgICAgIHVybDogXFxcXFxcXCJoaWtlcjovL3BhZ2Uvc2V0dGluZ1xcXFxcXFwiLFxcXFxuICAgICAgICBjb2xfdHlwZTogJ2ZsZXhfYnV0dG9uJ1xcXFxuICAgIH0sIHtcXFxcbiAgICAgICAgdGl0bGU6IFxcXFxcXFwi6aG16Z2i5Yqg6L29OlxcXFxcXFwiICsgZ2V0SXRlbSgnaG9tZScsICflhbMnKSxcXFxcbiAgICAgICAgdXJsOiAkKCcnKS5sYXp5UnVsZSgoKSA9PiB7XFxcXG4gICAgICAgICAgICBpZiAoZ2V0SXRlbSgnaG9tZScsICflhbMnKSA9PSAn5YWzJykge1xcXFxuICAgICAgICAgICAgICAgIHNldEl0ZW0oJ2hvbWUnLCAn5byAJylcXFxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgc2V0SXRlbSgnaG9tZScsICflhbMnKVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKVxcXFxuICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcXFxuICAgICAgICB9KSxcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiZmxleF9idXR0b25cXFxcXFxcIlxcXFxuICAgIH0sIHtcXFxcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxcXFxuICAgICAgICB1cmw6ICQoXFxcXFxcXCIjbm9Mb2FkaW5nI1xcXFxcXFwiKS5sYXp5UnVsZSgoKSA9PiB7XFxcXG4gICAgICAgICAgICB2YXIgd2ViID0gZ2V0SXRlbSgnd2ViJywgJzAnKVxcXFxuICAgICAgICAgICAgc3dpdGNoICh3ZWIpIHtcXFxcbiAgICAgICAgICAgICAgICBjYXNlICcwJzpcXFxcbiAgICAgICAgICAgICAgICAgICAgc2V0SXRlbSgnd2ViJywgJzEnKVxcXFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXFxcbiAgICAgICAgICAgICAgICBjYXNlICcxJzpcXFxcbiAgICAgICAgICAgICAgICAgICAgc2V0SXRlbSgnd2ViJywgJzInKVxcXFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXFxcbiAgICAgICAgICAgICAgICBjYXNlICcyJzpcXFxcbiAgICAgICAgICAgICAgICAgICAgc2V0SXRlbSgnd2ViJywgJzAnKVxcXFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXG4gICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXG4gICAgICAgIH0pLFxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJmbGV4X2J1dHRvblxcXFxcXFwiLFxcXFxuICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgaWQ6ICdwYXJzZXQnXFxcXG4gICAgICAgIH1cXFxcbiAgICB9LCB7XFxcXG4gICAgICAgIHRpdGxlOiAn5qih5p2/OicgKyAoZ2V0SXRlbSgnYWknLCAnMCcpID09ICcwJyA/ICflhbPpl60nIDogJ+W8gOWQrycpLFxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJmbGV4X2J1dHRvblxcXFxcXFwiLFxcXFxuICAgICAgICB1cmw6ICQoJycpLmxhenlSdWxlKCgpID0+IHtcXFxcbiAgICAgICAgICAgIGlmIChnZXRJdGVtKCdhaScsICcwJykgPT0gJzAnKSB7XFxcXG4gICAgICAgICAgICAgICAgc2V0SXRlbSgnYWknLCAnMScpXFxcXG4gICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgIHNldEl0ZW0oJ2FpJywgJzAnKVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxcXG4gICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXG4gICAgICAgIH0pLFxcXFxuICAgICAgICBjb2xfdHlwZTogJ2ZsZXhfYnV0dG9uJyxcXFxcbiAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgIGlkOiAnYWltYidcXFxcbiAgICAgICAgfVxcXFxuICAgIH0pO1xcXFxufVxcXFxuXFxcXG5cXFxcblxcXFxuaWYgKE1ZX1BBR0UgPT0gMSkge1xcXFxuICAgIGQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiBcXFxcXFxcIuaQnOe0olxcXFxcXFwiLFxcXFxuICAgICAgICB1cmw6ICQudG9TdHJpbmcoKCkgPT4ge1xcXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIjtcXFxcbiAgICAgICAgfSksXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImlucHV0XFxcXFxcXCIsXFxcXG4gICAgICAgIGRlc2M6IFxcXFxcXFwi6K+36L6T5YWl5YWz6ZSu6K+N77yM5bC96YeP5bCR5a2X5LiN6KaB5aSa5a2XXFxcXFxcXCIsXFxcXG4gICAgICAgIHBpY191cmw6IFxcXFxcXFwiXFxcXFxcXCIsXFxcXG4gICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IGdldE15VmFyKFxcXFxcXFwic291XFxcXFxcXCIsIFxcXFxcXFwiXFxcXFxcXCIpLFxcXFxuICAgICAgICAgICAgb25DaGFuZ2U6ICQudG9TdHJpbmcoKCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwic291XFxcXFxcXCIsIGlucHV0KTtcXFxcbiAgICAgICAgICAgICAgICBjbGVhck15VmFyKCdwYWdlJylcXFxcbiAgICAgICAgICAgICAgICBjbGVhck15VmFyKFxcXFxcXFwiZHVybFxcXFxcXFwiKVxcXFxuICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgfVxcXFxuICAgIH0pO1xcXFxuICAgIGFkZExpc3RlbmVyKFxcXFxcXFwib25DbG9zZVxcXFxcXFwiLCAkLnRvU3RyaW5nKCgpID0+IHtcXFxcbiAgICAgICAgY2xlYXJNeVZhcihcXFxcXFxcInNvdVxcXFxcXFwiKTtcXFxcbiAgICB9KSk7XFxcXG5cXFxcbiAgICBhZGRMaXN0ZW5lcihcXFxcXFxcIm9uUmVmcmVzaFxcXFxcXFwiLCAkLnRvU3RyaW5nKCgpID0+IHtcXFxcbiAgICAgICAgY2xlYXJNeVZhcihcXFxcXFxcInNvdVxcXFxcXFwiKTtcXFxcbiAgICAgICAgY2xlYXJNeVZhcihcXFxcXFxcImR1cmxcXFxcXFxcIik7XFxcXG4gICAgfSkpO1xcXFxufVxcXFxuXFxcXG5sZXQgcyA9IGdldE15VmFyKFxcXFxcXFwic291XFxcXFxcXCIsIFxcXFxcXFwiXFxcXFxcXCIpO1xcXFxubGV0IHIgPSBcXFxcXFxcIlxcXFxcXFwiO1xcXFxuXFxcXG52YXIgaW5kZXggPSBzdG9yYWdlMC5nZXRNeVZhcigncGFnZV9pbmRleCcsIDApXFxcXG5cXFxcbnRyeSB7XFxcXG4gICAgc3dpdGNoIChwYXJzZUludChpbmRleCkpIHtcXFxcbiAgICAgICAgY2FzZSAwOlxcXFxuICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS93YW5kb3UnKSkucnVsZSlcXFxcbiAgICAgICAgICAgIGJyZWFrO1xcXFxuICAgICAgICBjYXNlIDE6XFxcXG4gICAgICAgICAgICBldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL2N1cGZveCcpKS5ydWxlKVxcXFxuICAgICAgICAgICAgYnJlYWs7XFxcXG4gICAgICAgIGNhc2UgMjpcXFxcbiAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2Uvc291cGlhbicpKS5ydWxlKVxcXFxuICAgICAgICAgICAgYnJlYWs7XFxcXG4gICAgICAgIGNhc2UgMzpcXFxcbiAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvcWltYWl0dicpKS5ydWxlKVxcXFxuXFxcXG4gICAgICAgICAgICBicmVhaztcXFxcbiAgICAgICAgY2FzZSA0OlxcXFxuICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS90YnNkeScpKS5ydWxlKVxcXFxuICAgICAgICAgICAgYnJlYWs7XFxcXG4gICAgfVxcXFxufSBjYXRjaChlKSB7XFxcXG4gICAgLy9zZXRJdGVtKCdob21lJywgJ+WFsycpXFxcXG4gICAgbGV0IG5leHRpbmRleD0wO1xcXFxuICAgIGlmKGluZGV4PjQpe1xcXFxuICAgICAgICBuZXh0aW5kZXg9MDtcXFxcbiAgICB9ZWxzZXtcXFxcbiAgICAgICAgbmV4dGluZGV4PWluZGV4KzE7XFxcXG4gICAgfVxcXFxuICAgIHRvYXN0KG5hbWVzW2luZGV4XStg5Y+R55Sf6ZSZ6K+v77yM6ZSZ6K+v5L+h5oGvOiR7ZS5tZXNzYWdlfWApO1xcXFxuICAgIGxvZyhuYW1lc1tpbmRleF0rYOWPkeeUn+mUmeivr++8jOmUmeivr+S/oeaBrzoke2UubWVzc2FnZX1gKTtcXFxcbiAgICBzdG9yYWdlMC5wdXRNeVZhcigncGFnZV9pbmRleCcsIG5leHRpbmRleCk7XFxcXG4gICAgcmVmcmVzaFBhZ2UoKTtcXFxcbn1cXFxcblxcXFxuXFxcXG5zZXRSZXN1bHQoZCk7XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5bel5YW3XFxcIixcXFwicGF0aFxcXCI6XFxcInRvb2xcXFwiLFxcXCJydWxlXFxcIjpcXFwiZnVuY3Rpb24gd3JhcCh0ZXh0LCBzKSB7XFxcXG4gICAgcmV0dXJuIHRleHQuaW5jbHVkZXMoXFxcXFxcXCLigJzigJzigJ3igJ1cXFxcXFxcIikgPyB0ZXh0IDogXFxcXFxcXCLigJzigJzigJ3igJ1cXFxcXFxcIiArIHRleHQucmVwbGFjZShuZXcgUmVnRXhwKFxcXFxcXFwiPGVtPnw8L2VtPlxcXFxcXFwiLCBcXFxcXFxcImdcXFxcXFxcIiksIFxcXFxcXFwiXFxcXFxcXCIpLnJlcGxhY2UobmV3IFJlZ0V4cChzLCBcXFxcXFxcImdcXFxcXFxcIiksIFxcXFxcXFwiPHN0cm9uZz48c3BhbiBzdHlsZT1cXFxcXFxcXFxcXFxcXFwiY29sb3I6ICMxRTkwRkZcXFxcXFxcXFxcXFxcXFwiPlxcXFxcXFwiICsgcyArIFxcXFxcXFwiPC9zcGFuPjwvc3Ryb25nPlxcXFxcXFwiKVxcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiB3cmFwMSh0ZXh0LCBzKSB7XFxcXG4gICAgcmV0dXJuIHRleHQucmVwbGFjZShuZXcgUmVnRXhwKFxcXFxcXFwiPGVtPnw8L2VtPlxcXFxcXFwiLCBcXFxcXFxcImdcXFxcXFxcIiksIFxcXFxcXFwiXFxcXFxcXCIpLnJlcGxhY2UobmV3IFJlZ0V4cChzLCBcXFxcXFxcImdcXFxcXFxcIiksIFxcXFxcXFwiPHN0cm9uZz48c3BhbiBzdHlsZT1cXFxcXFxcXFxcXFxcXFwiY29sb3I6ICMxRTkwRkZcXFxcXFxcXFxcXFxcXFwiPlxcXFxcXFwiICsgcyArIFxcXFxcXFwiPC9zcGFuPjwvc3Ryb25nPlxcXFxcXFwiKVxcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiByZW1vdmVodG1sKHRleHQpIHtcXFxcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC88W148XSs/Pi9nLCAnJylcXFxcbn1cXFxcblxcXFxuZnVuY3Rpb24gbWVyZ2UodGV4dCwgcywgbSkge1xcXFxuICAgIGlmIChtID09IDApIHtcXFxcbiAgICAgICAgdGV4dCA9ICfigJzigJzigJ3igJ0nICsgdGV4dCArICctJyArIFxcXFxcXFwiPHN0cm9uZz48c3BhbiBzdHlsZT1cXFxcXFxcXFxcXFxcXFwiY29sb3I6ICNGRjU3MzNcXFxcXFxcXFxcXFxcXFwiPlxcXFxcXFwiICsgcyArIFxcXFxcXFwiPC9zcGFuPjwvc3Ryb25nPlxcXFxcXFwiXFxcXG4gICAgfSBlbHNlIHtcXFxcbiAgICAgICAgdGV4dCA9IHRleHQgKyAnLScgKyBcXFxcXFxcIjxzdHJvbmc+PHNwYW4gc3R5bGU9XFxcXFxcXFxcXFxcXFxcImNvbG9yOiAjRkY1NzMzXFxcXFxcXFxcXFxcXFxcIj5cXFxcXFxcIiArIHMgKyBcXFxcXFxcIjwvc3Bhbj48L3N0cm9uZz5cXFxcXFxcIlxcXFxuICAgIH1cXFxcbiAgICByZXR1cm4gdGV4dFxcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiBzZXRQYWdlRChkLCBwYWdlLCB0aXRsZXMsIGNvbG9yKSB7XFxcXG4gICAgdmFyIHBhZ2VkID0gZ2V0TXlWYXIoXFxcXFxcXCJwYWdlZFxcXFxcXFwiLCBcXFxcXFxcIjBcXFxcXFxcIik7XFxcXG4gICAgdGl0bGVzLm1hcCgoeCwgaSkgPT4ge1xcXFxuICAgICAgICB2YXIgdGl0bGUgPSBOdW1iZXIocGFnZWQpID09IGkgPyBcXFxcXFxcIuKAnOKAnOKAneKAnTxiPjxmb250IGNvbG9yPVxcXFxcXFwiICsgY29sb3IgKyBcXFxcXFxcIj5cXFxcXFxcIiArIHggKyBcXFxcXFxcIjwvZm9udD48L2I+XFxcXFxcXCIgOiBgJHt4fWA7XFxcXG4gICAgICAgIGlmIChwYWdlID09IDEpIHtcXFxcbiAgICAgICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiAndGV4dF8yJyxcXFxcbiAgICAgICAgICAgICAgICB1cmw6IGkgKyAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKCgpID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCJwYWdlZFxcXFxcXFwiLCBpbnB1dCk7XFxcXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXFxcbiAgICAgICAgICAgICAgICB9KSxcXFxcbiAgICAgICAgICAgIH0pXFxcXG4gICAgICAgIH1cXFxcbiAgICB9KVxcXFxuICAgIHJldHVybiBnZXRNeVZhcihcXFxcXFxcInBhZ2VkXFxcXFxcXCIsIFxcXFxcXFwiMFxcXFxcXFwiKVxcXFxufVxcXFxuXFxcXG5cXFxcbiQuZXhwb3J0cyA9IHtcXFxcbiAgICB3cmFwOiB3cmFwLFxcXFxuICAgIHdyYXAxOiB3cmFwMSxcXFxcbiAgICByZWh0bWw6IHJlbW92ZWh0bWwsXFxcXG4gICAgbWVyZ2U6IG1lcmdlLFxcXFxuICAgIHNldHBhZ2VkOiBzZXRQYWdlRFxcXFxufVxcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIuaQnOe0oumhtemdolxcXCIsXFxcInBhdGhcXFwiOlxcXCJzb3VwXFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxudmFyIGQgPSBbXTtcXFxcbmlmIChNWV9QQVJBTVMua2V5ICYmIGdldE15VmFyKFxcXFxcXFwidXNlXFxcXFxcXCIsIFxcXFxcXFwiXFxcXFxcXCIpID09IFxcXFxcXFwiXFxcXFxcXCIpIHtcXFxcbiAgICBwdXRNeVZhcihcXFxcXFxcInNvdVxcXFxcXFwiLCBNWV9QQVJBTVMua2V5KTtcXFxcbiAgICBwdXRNeVZhcihcXFxcXFxcInVzZVxcXFxcXFwiLCBcXFxcXFxcIjFcXFxcXFxcIik7XFxcXG4gICAgYWRkTGlzdGVuZXIoXFxcXFxcXCJvbkNsb3NlXFxcXFxcXCIsICQudG9TdHJpbmcoKCkgPT4ge1xcXFxuICAgICAgICBjbGVhck15VmFyKFxcXFxcXFwidXNlXFxcXFxcXCIpO1xcXFxuICAgIH0pKTtcXFxcbn1cXFxcbiQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL3BybycpXFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwieDVcXFwiLFxcXCJwYXRoXFxcIjpcXFwieDVcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG52YXIgZCA9IFtdO1xcXFxubGV0IHVybCA9IGJhc2U2NERlY29kZShnZXRQYXJhbShcXFxcXFxcInVcXFxcXFxcIikpO1xcXFxuZC5wdXNoKHtcXFxcbiAgICB0aXRsZTogXFxcXFxcXCJcXFxcXFxcIixcXFxcbiAgICB1cmw6IHVybCxcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJ4NV93ZWJ2aWV3X3NpbmdsZVxcXFxcXFwiLFxcXFxuICAgIGRlc2M6IFxcXFxcXFwiZmxvYXQmJjEwMCVcXFxcXFxcIixcXFxcbiAgICBwaWNfdXJsOiBcXFxcXFxcIlxcXFxcXFwiLFxcXFxuICAgIGV4dHJhOiB7XFxcXG4gICAgICAgIGZsb2F0VmlkZW86IHRydWUsXFxcXG4gICAgICAgIGNhbkJhY2s6IHRydWUsXFxcXG4gICAgICAgIGJsb2NrUnVsZXM6IFtcXFxcXFxcIi5naWZcXFxcXFxcIiwgXFxcXFxcXCIvYWQvXFxcXFxcXCIsIFxcXFxcXFwiZ29vZ2xlXFxcXFxcXCIsIFxcXFxcXFwiL3NoL3RvL1xcXFxcXFwiLCBcXFxcXFxcIi5HSUZcXFxcXFxcIl1cXFxcbiAgICB9XFxcXG59KTtcXFxcbnNldFJlc3VsdChkKTtcXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCIzLuaQnOeJh1xcXCIsXFxcInBhdGhcXFwiOlxcXCJzb3VwaWFuXFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxuaWYgKHMgIT0gXFxcXFxcXCJcXFxcXFxcIikge1xcXFxuICAgIHZhciBodG1sID0gZmV0Y2goYGh0dHA6Ly9zb3VwaWFuLmRlL3NlYXJjaD9rZXk9JHtzfWApXFxcXG4gICAgdmFyIGxpc3QgPSBwZGZhKGh0bWwsICdib2R5JiYubGlzdC1yb3ctaW5mbycpXFxcXG4gICAgbGV0IHtcXFxcbiAgICAgICAgd3JhcDFcXFxcbiAgICB9ID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3Rvb2xcXFxcXFxcIik7XFxcXG4gICAgZm9yIChsZXQgaXQgb2YgbGlzdCkge1xcXFxuICAgICAgICAvL2xvZyhpdClcXFxcbiAgICAgICAgLy9sZXQgbmFtZSA9IGl0Lm1vdmllX25hbWU7XFxcXG4gICAgICAgIGxldCBuYW1lID0gcGRmaChpdCwgJ2g0JiZUZXh0Jyk7XFxcXG4gICAgICAgIGxldCB3ZWIgPSBwZGZoKGl0LCAnYSYmdGl0bGUnKS5yZXBsYWNlKG5hbWUsJycpLnRyaW0oKTtcXFxcbiAgICAgICAgXFxcXG4gICAgICAgIGxldCBpbWcgPSBwZGZoKGl0LCAnaW1nJiZzcmMnKTtcXFxcbiAgICAgICAgbGV0IHVybCA9IHBkZmgoaXQsICdhJiZocmVmJyk7XFxcXG4gICAgICAgIHZhciB1ID0gXFxcXFxcXCJoaWtlcjovL3BhZ2UvcD9ydWxlPVxcXFxcXFwiICsgTVlfUlVMRS50aXRsZSArIFxcXFxcXFwiJnU9XFxcXFxcXCIgKyBiYXNlNjRFbmNvZGUodXJsKVxcXFxuICAgICAgICB1ID0gZ2V0SXRlbSgnYWknLCAnMCcpID09ICcwJyA/IHUgOiB1ICsgJyNpbW1lcnNpdmVUaGVtZSMnXFxcXG4gICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZTogd3JhcDEod2ViKyctJytuYW1lLCBzKSxcXFxcbiAgICAgICAgICAgIHVybDogdSxcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImF2YXRhclxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgLy9kZXNjOiBcXFxcXFxcIuKAnOKAnOKAneKAnTxmb250IGNvbG9yPSNmMTNiNjZhPuaQnOeJhzwvZm9udD5cXFxcXFxcIixcXFxcbiAgICAgICAgICAgIHBpY191cmw6IGltZyxcXFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgaWQ6IHVybCxcXFxcbiAgICAgICAgICAgICAgICBpbmhlcml0VGl0bGU6IGZhbHNlLFxcXFxuICAgICAgICAgICAgICAgIHBhZ2VUaXRsZTpuYW1lLFxcXFxuICAgICAgICAgICAgICAgIHdlYjp3ZWIsXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0pO1xcXFxuICAgIH1cXFxcbiAgICBzZXRSZXN1bHQoZClcXFxcbn0gZWxzZSB7XFxcXG5cXFxcbn1cXFxcblxcXFxuaWYgKGdldEl0ZW0oJ2hvbWUnLCAn5YWzJykgPT0gJ+W8gCcpIHtcXFxcbiAgICB2YXIgaHRtbCA9IHJlcXVlc3QoJ2h0dHA6Ly9zb3VwaWFuLmRlLycsIHt9KVxcXFxuXFxcXG5cXFxcbiAgICBmdW5jdGlvbiBzZXRMaXN0cyhpdGVtKSB7XFxcXG4gICAgICAgIHZhciB0aXRsZSA9IGl0ZW0uc3BsaXQoJy0nKVswXVxcXFxuICAgICAgICB2YXIgdCA9IGl0ZW0uc3BsaXQoJy0nKVsxXVxcXFxuICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxcXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdhdmF0YXInLFxcXFxuICAgICAgICAgICAgaW1nOiAnaHR0cHM6Ly9sYW5tZWlndW9qaWFuZy5jb20vdHViaWFvL21vcmUvMTAucG5nJ1xcXFxuICAgICAgICB9KVxcXFxuXFxcXG4gICAgICAgIHZhciBsaXN0ID0gcGRmYShodG1sLCBgYm9keSYmLmxpc3QtaGVhZGVyOm1hdGNoZXMoJHt0fSkrKiYmYWApXFxcXG5cXFxcbiAgICAgICAgbGlzdC5tYXAoeCA9PiB7XFxcXG4gICAgICAgICAgICB2YXIgbmFtZSA9IHBkZmgoeCwgJy5wb3N0ZXItaXRlbS10aXRsZSYmVGV4dCcpXFxcXG4gICAgICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiBuYW1lLFxcXFxuICAgICAgICAgICAgICAgIGltZzogcGRmaCh4LCAnaW1nJiZzcmMnKSxcXFxcbiAgICAgICAgICAgICAgICB1cmw6ICQoJycpLmxhenlSdWxlKChuKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwic291XFxcXFxcXCIsIG4pXFxcXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKClcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcXFxuICAgICAgICAgICAgICAgIH0sIG5hbWUpXFxcXG4gICAgICAgICAgICB9KVxcXFxuICAgICAgICB9KVxcXFxuICAgIH1cXFxcblxcXFxuICAgIFsn54Ot6Zeo55S15b2xLeeUteW9sScsICfng63pl6jnlLXop4bliact55S16KeG5YmnJywgJ+eDremXqOe7vOiJui3nu7zoibonLCAn54Ot6Zeo5Yqo5ryrLeWKqOa8qyddLm1hcCh4ID0+IHtcXFxcbiAgICAgICAgc2V0TGlzdHMoeClcXFxcbiAgICB9KVxcXFxuXFxcXG59XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwiMS7osYzosYZcXFwiLFxcXCJwYXRoXFxcIjpcXFwid2FuZG91XFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxubGV0IGR1cmwgPSBnZXRNeVZhcihcXFxcXFxcImR1cmxcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIik7XFxcXG5pZiAoZHVybCAhPSAnJykge1xcXFxuXFxcXG4gICAgZHVybCA9ICdodHRwczovL3d3dy53YW5kb3UucHJvJyArIGR1cmwucmVwbGFjZSgnLmh0bWwnLCAnJylcXFxcbiAgICBsZXQgdXJsID0gZHVybDtcXFxcbiAgICBsZXQgaWQgPSB1cmw7XFxcXG4gICAgbGV0IGh0bWwgPSBmZXRjaCh1cmwpO1xcXFxuICAgIHZhciBydWxlID0gTVlfUlVMRS50aXRsZVxcXFxuICAgIHZhciBuYW1lID0gcGRmaChodG1sLCAnLm1vdmllLWNvbnRlbnQmJnAmJlRleHQnKTtcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogbmFtZSxcXFxcbiAgICAgICAgaW1nOiBwZGZoKGh0bWwsICcubW92aWUtaW1nJiZpbWcmJnNyYycpLFxcXFxuICAgICAgICBjb2xfdHlwZTogJ21vdmllXzFfdmVydGljYWxfcGljJyxcXFxcbiAgICAgICAgZGVzYzogcGRmaChodG1sLCAnLmJvdHRvbSYmcCYmVGV4dCcpLFxcXFxuICAgICAgICB1cmw6ICdoaWtlcjovL3BhZ2UveDU/dT0nICsgYmFzZTY0RW5jb2RlKHVybCksXFxcXG4gICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICBpZDogdXJsLFxcXFxuICAgICAgICAgICAgaW5oZXJpdFRpdGxlOiBmYWxzZVxcXFxuICAgICAgICB9XFxcXG4gICAgfSlcXFxcbiAgICAvL3NldFJlc3VsdChkKTtcXFxcblxcXFxuICAgIGxldCB0ZXh0ID0gcGRmaChodG1sLCBcXFxcXFxcImJvZHkmJiNfX05FWFRfREFUQV9fJiZIdG1sXFxcXFxcXCIpO1xcXFxuICAgIC8vbG9nKHRleHQpO1xcXFxuICAgIGxldCBlcmppID0gSlNPTi5wYXJzZSh0ZXh0KTtcXFxcbiAgICAvLyBsb2coZXJqaSk7XFxcXG4gICAgbGV0IGxpc3QgPSBlcmppLnByb3BzLnBhZ2VQcm9wcy5kYXRhLnBsYXlEYXRhO1xcXFxuXFxcXG4gICAgaWYgKGxpc3QgJiYgbGlzdC5sZW5ndGggPiAwKSB7XFxcXG4gICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICBNWV9VUkwgPSBcXFxcXFxcIlxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgbGV0IHtcXFxcbiAgICAgICAgICAgICAgICB3cmFwXFxcXG4gICAgICAgICAgICB9ID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3Rvb2w/cnVsZT1cXFxcXFxcIiArIHJ1bGUpO1xcXFxuICAgICAgICAgICAgbGlzdCA9IGxpc3QubWFwKGl0ID0+IHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgdSA9IGl0LmRhdGFfdXJsO1xcXFxuICAgICAgICAgICAgICAgIHUgPSBcXFxcXFxcImhpa2VyOi8vcGFnZS9wP3J1bGU9XFxcXFxcXCIgKyBydWxlICsgXFxcXFxcXCImdT1cXFxcXFxcIiArIGJhc2U2NEVuY29kZSh1KTtcXFxcbiAgICAgICAgICAgICAgICB1ID0gZ2V0SXRlbSgnYWknLCAnMCcpID09ICcwJyA/IHUgOiB1ICsgJyNpbW1lcnNpdmVUaGVtZSMnXFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGl0LnNpdGVfbmFtZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB1LFxcXFxuICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJhdmF0YXJcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgaW1nOiBpdC5zaXRlX2ljb24sXFxcXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmhlcml0VGl0bGU6IGZhbHNlLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHUsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiAnaG9tZScsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlVGl0bGU6IG5hbWUsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWI6IGl0LnNpdGVfbmFtZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgaWYgKE1ZX1BBR0UgPT0gMSkge1xcXFxuICAgICAgICAgICAgICAgIC8vYWRkSXRlbUFmdGVyKGlkLCBsaXN0KTtcXFxcbiAgICAgICAgICAgICAgICBkID0gZC5jb25jYXQobGlzdCk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICAgIGxvZyhlLnRvU3RyaW5nKCkpO1xcXFxuICAgICAgICB9XFxcXG4gICAgfVxcXFxuICAgIHNldFJlc3VsdChkKVxcXFxufVxcXFxuXFxcXG5sZXQgciA9IFxcXFxcXFwiXFxcXFxcXCI7XFxcXG5pZiAocyAhPSBcXFxcXFxcIlxcXFxcXFwiKSB7XFxcXG5cXFxcbiAgICBqc29uID0gXFxcXFxcXCJodHRwczovL2FwaS54aWFtbS5jYzo5ODk3L21vdmllL2dldHNlYXJjaGxpc3Qva2V5d29yZHMvXFxcXFxcXCIgKyBzICsgXFxcXFxcXCIvcGFnZS8xL3Jvd3MvMTYuanNvblxcXFxcXFwiO1xcXFxuICAgIGRhdGEgPSBKU09OLnBhcnNlKGZldGNoKGpzb24pKS5kYXRhO1xcXFxuICAgIGxldCB7XFxcXG4gICAgICAgIHdyYXBcXFxcbiAgICB9ID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3Rvb2xcXFxcXFxcIik7XFxcXG4gICAgZm9yIChsZXQgaXQgb2YgZGF0YSkge1xcXFxuICAgICAgICBsZXQgbmFtZSA9IGl0Lm1vdmllX25hbWU7XFxcXG4gICAgICAgIC8vbG9nKG5hbWUpXFxcXG4gICAgICAgIGxldCBpbWcgPSBpdC5tb3ZpZV9pbWdfdXJsO1xcXFxuICAgICAgICBsZXQgdXJsID0gXFxcXFxcXCJodHRwczovL3d3dy53YW5kb3UucHJvXFxcXFxcXCIgKyBpdC5tb3ZpZV91cmwucmVwbGFjZShcXFxcXFxcIi5odG1sXFxcXFxcXCIsIFxcXFxcXFwiXFxcXFxcXCIpO1xcXFxuICAgICAgICAvL2xvZyh1cmwpXFxcXG4gICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZTogd3JhcChuYW1lLCBzKSxcXFxcbiAgICAgICAgICAgIHVybDogJCh1cmwpLmxhenlSdWxlKChydWxlLCBpZCwgcywgbmFtZSkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIHZhciBjbHMgPSBmaW5kSXRlbXNCeUNscyhpZCk7XFxcXG4gICAgICAgICAgICAgICAgaWYgKCEhY2xzKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZUl0ZW1CeUNscyhpZClcXFxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgdXJsID0gaW5wdXQ7XFxcXG4gICAgICAgICAgICAgICAgICAgIGxldCBpZCA9IHVybDtcXFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGh0bWwgPSBmZXRjaCh1cmwpO1xcXFxuICAgICAgICAgICAgICAgICAgICAvL2xvZyhodG1sKVxcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgdGV4dCA9IHBkZmgoaHRtbCwgXFxcXFxcXCJib2R5JiYjX19ORVhUX0RBVEFfXyYmSHRtbFxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgLy9sb2codGV4dCk7XFxcXG4gICAgICAgICAgICAgICAgICAgIGxldCBlcmppID0gSlNPTi5wYXJzZSh0ZXh0KTtcXFxcbiAgICAgICAgICAgICAgICAgICAgLy9sb2coZXJqaSk7XFxcXG4gICAgICAgICAgICAgICAgICAgIGxldCBsaXN0ID0gZXJqaS5wcm9wcy5wYWdlUHJvcHMuZGF0YS5wbGF5RGF0YTtcXFxcblxcXFxuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdCAmJiBsaXN0Lmxlbmd0aCA+IDApIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTVlfVVJMID0gXFxcXFxcXCJcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cmFwXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS90b29sP3J1bGU9XFxcXFxcXCIgKyBydWxlKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ID0gbGlzdC5tYXAoaXQgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IGl0LmRhdGFfdXJsO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ID0gXFxcXFxcXCJoaWtlcjovL3BhZ2UvcD9ydWxlPVxcXFxcXFwiICsgcnVsZSArIFxcXFxcXFwiJnU9XFxcXFxcXCIgKyBiYXNlNjRFbmNvZGUodSk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUgPSBnZXRJdGVtKCdhaScsICcwJykgPT0gJzAnID8gdSA6IHUgKyAnI2ltbWVyc2l2ZVRoZW1lIydcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBpdC5zaXRlX25hbWUsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHUsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJhdmF0YXJcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltZzogaXQuc2l0ZV9pY29uLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmhlcml0VGl0bGU6IGZhbHNlLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsczogaWQsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogJ2hvbWUnLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VUaXRsZTogbmFtZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWI6IGl0LnNpdGVfbmFtZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZEl0ZW1BZnRlcihpZCwgbGlzdCk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nKGUudG9TdHJpbmcoKSk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiXFxcXG4gICAgICAgICAgICB9LCBNWV9SVUxFLnRpdGxlLCB1cmwsIHMsIG5hbWUpLFxcXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwibW92aWVfMV9sZWZ0X3BpY1xcXFxcXFwiLFxcXFxuICAgICAgICAgICAgZGVzYzogXFxcXFxcXCLigJzigJzigJ3igJ08Zm9udCBjb2xvcj0jZjEzYjY2YT7osYzosYY8L2ZvbnQ+XFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBwaWNfdXJsOiBpbWcsXFxcXG4gICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgIGlkOiB1cmwsXFxcXG4gICAgICAgICAgICAgICAgaW5oZXJpdFRpdGxlOiBmYWxzZVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9KTtcXFxcbiAgICB9XFxcXG4gICAgc2V0UmVzdWx0KGQpXFxcXG59XFxcXG5cXFxcblxcXFxuaWYgKGdldEl0ZW0oJ2hvbWUnLCAn5YWzJykgPT0gJ+W8gCcpIHtcXFxcbiAgICB2YXIgcGFnZSA9IE1ZX1BBR0U7XFxcXG4gICAgbGV0IHtcXFxcbiAgICAgICAgc2V0cGFnZWRcXFxcbiAgICB9ID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3Rvb2xcXFxcXFxcIik7XFxcXG5cXFxcbiAgICB2YXIgcGluZGV4ID0gc2V0cGFnZWQoZCxwYWdlLCBbXFxcXFxcXCLpppbpobVcXFxcXFxcIiwgXFxcXFxcXCLliIbnsbtcXFxcXFxcIl0sIFxcXFxcXFwiIzQ2ODJCNFxcXFxcXFwiKTtcXFxcblxcXFxuXFxcXG4gICAgLy/pppbpobVcXFxcbiAgICBpZiAocGluZGV4ID09IFxcXFxcXFwiMFxcXFxcXFwiKSB7XFxcXG5cXFxcbiAgICAgICAgdmFyIGh0bWwgPSBmZXRjaCgnaHR0cHM6Ly93d3cud2FuZG91LnByby8nKVxcXFxuICAgICAgICBsZXQganNvbiA9IEpTT04ucGFyc2UocGRmaChodG1sLCBcXFxcXFxcImJvZHkmJiNfX05FWFRfREFUQV9fJiZIdG1sXFxcXFxcXCIpKTtcXFxcblxcXFxuICAgICAgICBmdW5jdGlvbiBzZXRMaXN0cyhpdGVtKSB7XFxcXG4gICAgICAgICAgICB2YXIgdGl0bGUgPSBpdGVtLnNwbGl0KCcjJylbMF1cXFxcbiAgICAgICAgICAgIHZhciBrZXkgPSBpdGVtLnNwbGl0KCcjJylbMV1cXFxcbiAgICAgICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiAnYXZhdGFyJyxcXFxcbiAgICAgICAgICAgICAgICBpbWc6ICdodHRwczovL2xhbm1laWd1b2ppYW5nLmNvbS90dWJpYW8vbW9yZS8xMC5wbmcnXFxcXG4gICAgICAgICAgICB9KVxcXFxuXFxcXG4gICAgICAgICAgICB2YXIgbGlzdCA9IGpzb24ucHJvcHMucGFnZVByb3BzLmZhbGxiYWNrW2tleV0uZGF0YVxcXFxuXFxcXG4gICAgICAgICAgICBsaXN0Lm1hcCh4ID0+IHtcXFxcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHguaG90X25hbWVcXFxcbiAgICAgICAgICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogbmFtZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgaW1nOiB4LmhvdF9pbWdfdXJsLFxcXFxuICAgICAgICAgICAgICAgICAgICBkZXNjOiB4LmhvdF9yYXRlLFxcXFxuICAgICAgICAgICAgICAgICAgICB1cmw6ICQoJycpLmxhenlSdWxlKChuLCB1KSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFxcXFxcInNvdVxcXFxcXFwiLCBuKVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoJ2R1cmwnLCB1KVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcXFxuICAgICAgICAgICAgICAgICAgICB9LCBuYW1lLCB4LmhvdF91cmwpXFxcXG4gICAgICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgICAgIH0pXFxcXG4gICAgICAgIH1cXFxcblxcXFxuICAgICAgICBbJ+eDremXqOeUteW9sSNpbmRleC1nZXRNb3ZpZUxpc3QtbW92aWUnLCAn54Ot6Zeo5Ymn6ZuGI2luZGV4LWdldFR2TGlzdC10di0yOCddLm1hcCh4ID0+IHtcXFxcbiAgICAgICAgICAgIHNldExpc3RzKHgpXFxcXG4gICAgICAgIH0pXFxcXG4gICAgfVxcXFxuICAgIGlmIChwaW5kZXggPT0gXFxcXFxcXCIxXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgXFxcXG4gICAgICAgIHZhciB0eXBlcyA9IHtcXFxcbiAgICAgICAgICAgIFxcXFxcXFwidGFnXFxcXFxcXCI6IFtcXFxcXFxcIuexu+WeizowXFxcXFxcXCIsIFxcXFxcXFwi5Zac5YmnOjFcXFxcXFxcIiwgXFxcXFxcXCLniLHmg4U6MlxcXFxcXFwiLCBcXFxcXFxcIuWlh+W5uzo0XFxcXFxcXCIsIFxcXFxcXFwi54qv572qOjVcXFxcXFxcIiwgXFxcXFxcXCLmgqznlpE6NlxcXFxcXFwiLCBcXFxcXFxcIuWOhuWPsjo3XFxcXFxcXCIsIFxcXFxcXFwi5oiY5LqJOjhcXFxcXFxcIiwgXFxcXFxcXCLliqjkvZw6OVxcXFxcXFwiLCBcXFxcXFxcIuenkeW5uzoxMFxcXFxcXFwiLCBcXFxcXFxcIuWKqOeUuzoxMVxcXFxcXFwiLCBcXFxcXFxcIuWGkumZqToxMlxcXFxcXFwiLCBcXFxcXFxcIueBvumavjoxNVxcXFxcXFwiLCBcXFxcXFxcIuaDiuaCmjoxN1xcXFxcXFwiLCBcXFxcXFxcIuaBkOaAljoxOFxcXFxcXFwiLCBcXFxcXFxcIuatjOiInjoyMlxcXFxcXFwiLCBcXFxcXFxcIuatpuS+oDoyNFxcXFxcXFwiLCBcXFxcXFxcIumfs+S5kDoyN1xcXFxcXFwiXSxcXFxcbiAgICAgICAgICAgIFxcXFxcXFwiY291bnRyeVxcXFxcXFwiOiBbXFxcXFxcXCLlnLDljLo6MFxcXFxcXFwiLCBcXFxcXFxcIuS4reWbvToxXFxcXFxcXCIsIFxcXFxcXFwi6Z+p5Zu9OjNcXFxcXFxcIiwgXFxcXFxcXCLml6XmnKw6NFxcXFxcXFwiLCBcXFxcXFxcIue+juWbvTo2XFxcXFxcXCIsIFxcXFxcXFwi6Iux5Zu9OjlcXFxcXFxcIiwgXFxcXFxcXCLms5Xlm706MTBcXFxcXFxcIiwgXFxcXFxcXCLlvrflm706MTFcXFxcXFxcIiwgXFxcXFxcXCLlhbbku5Y6MTJcXFxcXFxcIl0sXFxcXG4gICAgICAgICAgICBcXFxcXFxcInllYXJcXFxcXFxcIjogW1xcXFxcXFwi5pe26Ze0OjBcXFxcXFxcIiwgXFxcXFxcXCIyMDIyOjFcXFxcXFxcIiwgXFxcXFxcXCIyMDIyOjJcXFxcXFxcIiwgXFxcXFxcXCIyMDIwOjNcXFxcXFxcIiwgXFxcXFxcXCIyMDE5OjRcXFxcXFxcIiwgXFxcXFxcXCIyMDEw5bm05LujOjVcXFxcXFxcIiwgXFxcXFxcXCIyMDAw5bm05LujOjZcXFxcXFxcIiwgXFxcXFxcXCI5MOW5tOS7ozo3XFxcXFxcXCIsIFxcXFxcXFwiODDlubTku6M6OFxcXFxcXFwiLCBcXFxcXFxcIjcw5bm05LujOjlcXFxcXFxcIiwgXFxcXFxcXCI2MOW5tOS7ozoxMFxcXFxcXFwiLCBcXFxcXFxcIuabtOaXqToxMVxcXFxcXFwiXSxcXFxcbiAgICAgICAgICAgIFxcXFxcXFwic29ydFxcXFxcXFwiOiBbXFxcXFxcXCLnu7zlkIjmjpLluo86MVxcXFxcXFwiLCBcXFxcXFxcIui/keacn+eDreW6pjoyXFxcXFxcXCIsIFxcXFxcXFwi6auY5YiG5LyY5YWIOjNcXFxcXFxcIl1cXFxcbiAgICAgICAgfVxcXFxuXFxcXG4gICAgICAgIHZhciBvanNvbiA9IFt7XFxcXG4gICAgICAgICAgICBuYW1lOiAn55S15b2xJyxcXFxcbiAgICAgICAgICAgIGlkOiAnbW92aWUnLFxcXFxuICAgICAgICAgICAgY29udGVudDogdHlwZXNcXFxcbiAgICAgICAgfSwge1xcXFxuICAgICAgICAgICAgbmFtZTogJ+eUteinhuWJpycsXFxcXG4gICAgICAgICAgICBpZDogJ3R2JyxcXFxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHR5cGVzXFxcXG4gICAgICAgIH0sIHtcXFxcbiAgICAgICAgICAgIG5hbWU6ICfliqjmvKsnLFxcXFxuICAgICAgICAgICAgaWQ6ICdhbmltZScsXFxcXG4gICAgICAgICAgICBjb250ZW50OiB0eXBlc1xcXFxuICAgICAgICB9LCB7XFxcXG4gICAgICAgICAgICBuYW1lOiAn57u86Im6JyxcXFxcbiAgICAgICAgICAgIGlkOiAndmFyaWV0eScsXFxcXG4gICAgICAgICAgICBjb250ZW50OiB0eXBlc1xcXFxuICAgICAgICB9LCB7XFxcXG4gICAgICAgICAgICBuYW1lOiAn57qq5b2V54mHJyxcXFxcbiAgICAgICAgICAgIGlkOiAnZG9jdW1lbnRhcnknLFxcXFxuICAgICAgICAgICAgY29udGVudDogdHlwZXNcXFxcbiAgICAgICAgfV1cXFxcblxcXFxuICAgICAgICB2YXIg5aSn57G7ID0gW107XFxcXG4gICAgICAgIG9qc29uLm1hcCh4ID0+IHtcXFxcbiAgICAgICAgICAgIOWkp+exuy5wdXNoKHgubmFtZSArIFxcXFxcXFwiQFxcXFxcXFwiICsgeC5pZCk7XFxcXG4gICAgICAgIH0pXFxcXG4gICAgICAgIHZhciBpbmRleCA9IHN0b3JhZ2UwLmdldE15VmFyKFxcXFxcXFwiaW5kZXhcXFxcXFxcIiwgJzAnKTtcXFxcbiAgICAgICAgdmFyIGogPSBvanNvbltpbmRleF07XFxcXG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoai5jb250ZW50KTtcXFxcblxcXFxuICAgICAgICB2YXIgdGVtcCA9IHt9O1xcXFxuICAgICAgICBrZXlzLmZvckVhY2goeCA9PiB7XFxcXG4gICAgICAgICAgICB2YXIgdHlwZSA9IHg7XFxcXG4gICAgICAgICAgICB2YXIgbCA9IGouY29udGVudFt4XTtcXFxcbiAgICAgICAgICAgIGlmIChbJ3ZlcnNpb24nXS5pbmNsdWRlcyh4KSkge1xcXFxuICAgICAgICAgICAgICAgIHJldHVyblxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgaWYgKGwubGVuZ3RoID4gMCkge1xcXFxuICAgICAgICAgICAgICAgIHZhciBucyA9IGwubWFwKChrKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gay5zcGxpdCgnOicpWzBdO1xcXFxuICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSBrLnNwbGl0KCc6JylbMV07XFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IG5hbWUsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAndXJsJzogaWQsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAndHlwZSc6IHhcXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIH0pXFxcXG4gICAgICAgICAgICAgICAgdGVtcFt4XSA9IG5zO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9KVxcXFxuXFxcXG4gICAgICAgIHZhciB0ID0gT2JqZWN0LnZhbHVlcyh0ZW1wKS5tYXAoeCA9PiB4Lm1hcCh6ID0+IEpTT04uc3RyaW5naWZ5KHopKS5qb2luKCcjJykpXFxcXG5cXFxcbiAgICAgICAgdmFyIFRydWVKc29uID0ge1xcXFxuICAgICAgICAgICAgdHlwZTogQXJyYXko5aSn57G7LmpvaW4oJyMnKSksXFxcXG4gICAgICAgICAgICBpdGVtOiB0ICE9IFxcXFxcXFwiXFxcXFxcXCIgPyB0IDogW10sXFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgLy9sb2coVHJ1ZUpzb24pXFxcXG5cXFxcbiAgICAgICAgLy/pnIDmoLnmja7lrp7pmYXkv67mlLlcXFxcbiAgICAgICAgY29uc3Qg5YiG57G76aKc6ImyID0gZ2V0UmFuZ2VDb2xvcnMoKTtcXFxcbiAgICAgICAgY29uc3QgSnNvbuWkp+exuyA9ICd0eXBlJztcXFxcbiAgICAgICAgY29uc3QgSnNvbuaLvOaOpSA9ICdpdGVtJztcXFxcbiAgICAgICAgY29uc3QgSnNvbuaLhuWIhiA9ICcjJztcXFxcbiAgICAgICAgY29uc3QgSnNvbuWNlemhuSA9ICdAJztcXFxcbiAgICAgICAgY29uc3QgSnNvbuWIl+ihqCA9IFtcXFxcXFxcInRhZ1xcXFxcXFwiLCBcXFxcXFxcImNvdW50cnlcXFxcXFxcIiwgXFxcXFxcXCJ5ZWFyXFxcXFxcXCIsIFxcXFxcXFwic29ydFxcXFxcXFwiXTsgLy/liIfmjaLmuIXpmaRcXFxcbiAgICAgICAgY29uc3Qg5o6S6ZmkID0gJyc7XFxcXG4gICAgICAgIGNvbnN0IOWIhuexu+WxleW8gCA9ICfiiKgnO1xcXFxuICAgICAgICBjb25zdCDliIbnsbvmipjlj6AgPSAn4oinJztcXFxcblxcXFxuICAgICAgICAvL+WKqOaAgeWIhuexu1xcXFxuICAgICAgICBldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL2pkdGZsJykpLnJ1bGUpO1xcXFxuICAgICAgICB2YXIgdHlwZSA9IHN0b3JhZ2UwLmdldE15VmFyKFxcXFxcXFwibXl0eXBlXFxcXFxcXCIsIFxcXFxcXFwibW92aWVcXFxcXFxcIik7XFxcXG4gICAgICAgIHZhciB0YWcgPSBzdG9yYWdlMC5nZXRNeVZhcihcXFxcXFxcInRhZ1xcXFxcXFwiLCBcXFxcXFxcIjBcXFxcXFxcIik7XFxcXG4gICAgICAgIHZhciBjb3VudHJ5ID0gc3RvcmFnZTAuZ2V0TXlWYXIoXFxcXFxcXCJjb3VudHJ5XFxcXFxcXCIsIFxcXFxcXFwiMFxcXFxcXFwiKTtcXFxcbiAgICAgICAgdmFyIHllYXIgPSBzdG9yYWdlMC5nZXRNeVZhcihcXFxcXFxcInllYXJcXFxcXFxcIiwgXFxcXFxcXCIwXFxcXFxcXCIpO1xcXFxuICAgICAgICB2YXIgc29ydCA9IHN0b3JhZ2UwLmdldE15VmFyKFxcXFxcXFwic29ydFxcXFxcXFwiLCBcXFxcXFxcIjFcXFxcXFxcIik7XFxcXG5cXFxcbiAgICAgICAgLy9sb2coYCR7dHlwZX06JHt0YWd9KyR7Y291bnRyeX0rJHt5ZWFyfSske3NvcnR9YClcXFxcbiAgICAgICAgdmFyIGp1cmwgPSBgaHR0cHM6Ly9hcGkueGlhbW0uY2M6OTg5Ny9tb3ZpZS9nZXQke3R5cGV9bGlzdC90YWcvJHt0YWd9L2NvdW50cnkvJHtjb3VudHJ5fS95ZWFyLyR7eWVhcn0vc29ydC8ke3NvcnR9L3BhZ2UvJHtwYWdlfS9yb3dzLzMwLmpzb25gO1xcXFxuICAgICAgICB2YXIgcGxpc3QgPSBKU09OLnBhcnNlKGZldGNoKGp1cmwpKS5kYXRhXFxcXG4gICAgICAgIHBsaXN0Lm1hcCh4ID0+IHtcXFxcbiAgICAgICAgICAgIHZhciBuYW1lID0geC5tb3ZpZV9uYW1lO1xcXFxuICAgICAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogbmFtZSxcXFxcbiAgICAgICAgICAgICAgICBpbWc6IHgubW92aWVfaW1nX3VybCArIFxcXFxcXFwiQFJlZmVyZXI9XFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgZGVzYzogeC5tb3ZpZV9yYXRlLFxcXFxuICAgICAgICAgICAgICAgIHVybDogJCgnJykubGF6eVJ1bGUoKG4sIHUpID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCJzb3VcXFxcXFxcIiwgbilcXFxcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoJ2R1cmwnLCB1KVxcXFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpXFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXFxcbiAgICAgICAgICAgICAgICB9LCBuYW1lLCB4Lm1vdmllX3VybCksXFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6ICdtb3ZpZV8zX21hcnF1ZWUnXFxcXG4gICAgICAgICAgICB9KVxcXFxuICAgICAgICB9KVxcXFxuICAgIH1cXFxcbn1cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCIyLuiMtuadr+eLkFxcXCIsXFxcInBhdGhcXFwiOlxcXCJjdXBmb3hcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5cXFxcbmV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UveHRvb2xzJykpLnJ1bGUpXFxcXG5cXFxcbmlmIChzICE9IFxcXFxcXFwiXFxcXFxcXCIpIHtcXFxcbiAgICBsZXQge1xcXFxuICAgICAgICB3cmFwMSxcXFxcbiAgICAgICAgcmVodG1sXFxcXG4gICAgfSA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS90b29sXFxcXFxcXCIpO1xcXFxuICAgIHZhciBqc29uID0gc2VhcmNoKHMsIHN0b3JhZ2UwLmdldE15VmFyKCdwYWdlJywgTVlfUEFHRSkpXFxcXG4gICAgaWYgKEpTT04uc3RyaW5naWZ5KGpzb24pICE9IFxcXFxcXFwie31cXFxcXFxcIikge1xcXFxuICAgICAgICB2YXIgbGlzdCA9IGpzb24ucmVzb3VyY2VzO1xcXFxuICAgICAgICBsaXN0Lm1hcChpdCA9PiB7XFxcXG4gICAgICAgICAgICAvL2xvZyhpdC53ZWJzaXRlKyctJytyZWh0bWwoaXQudGV4dCkpXFxcXG4gICAgICAgICAgICB2YXIgdT1cXFxcXFxcImhpa2VyOi8vcGFnZS9wP3U9XFxcXFxcXCIgKyBiYXNlNjRFbmNvZGUoaXQudXJsKVxcXFxuICAgICAgICAgICAgdT1nZXRJdGVtKCdhaScsJzAnKT09JzAnP3U6dSsnI2ltbWVyc2l2ZVRoZW1lIydcXFxcbiAgICAgICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IHdyYXAxKGl0LndlYnNpdGUrJy0nK3JlaHRtbChpdC50ZXh0KSwgcyksXFxcXG4gICAgICAgICAgICAgICAgdXJsOiB1LFxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImF2YXRhclxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIGltZzppdC5pY29uLFxcXFxuICAgICAgICAgICAgICAgIGRlc2M6IGl0LndlYnNpdGUsXFxcXG4gICAgICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgaW5oZXJpdFRpdGxlOiBmYWxzZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgcGFnZVRpdGxlOiByZWh0bWwoaXQudGV4dCksXFxcXG4gICAgICAgICAgICAgICAgICAgIHdlYjppdC53ZWJzaXRlLFxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICB9KVxcXFxuICAgIH1cXFxcbiAgICBcXFxcbiAgICBzZXRSZXN1bHQoZClcXFxcbn0gZWxzZSB7XFxcXG4gICAgXFxcXG59XFxcXG5cXFxcbmlmKGdldEl0ZW0oJ2hvbWUnLCflhbMnKT09J+W8gCcpe1xcXFxuXFxcXG52YXIgaHRtbCA9IGZldGNoUEMoJ2h0dHBzOi8vY3VwZm94LmFwcC8nLCB7fSlcXFxcblxcXFxuXFxcXG5mdW5jdGlvbiBzZXRMaXN0cyhpdGVtKSB7XFxcXG4gICAgdmFyIHRpdGxlID0gaXRlbS5zcGxpdCgnLScpWzBdXFxcXG4gICAgdmFyIHQgPSBpdGVtLnNwbGl0KCctJylbMV1cXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogdGl0bGUsXFxcXG4gICAgICAgIGNvbF90eXBlOiAnYXZhdGFyJyxcXFxcbiAgICAgICAgaW1nOiAnaHR0cHM6Ly9sYW5tZWlndW9qaWFuZy5jb20vdHViaWFvL21vcmUvMTAucG5nJ1xcXFxuICAgIH0pXFxcXG5cXFxcbiAgICB2YXIgbGlzdCA9IHBkZmEoaHRtbCwgYGJvZHkmJiMke3R9JiYubW92aWUtbGlzdC1pdGVtYClcXFxcblxcXFxuICAgIGxpc3QubWFwKHggPT4ge1xcXFxuICAgICAgICB2YXIgbmFtZSA9IHBkZmgoeCwgJy5tb3ZpZS10aXRsZSYmVGV4dCcpXFxcXG4gICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZTogbmFtZSxcXFxcbiAgICAgICAgICAgIGltZzogcGRmaCh4LCAnaW1nJiZzcmMnKSxcXFxcbiAgICAgICAgICAgIGRlc2M6cGRmaCh4LCcubW92aWUtcmF0aW5nJiZUZXh0JyksXFxcXG4gICAgICAgICAgICB1cmw6ICQoJycpLmxhenlSdWxlKChuKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCJzb3VcXFxcXFxcIiwgbilcXFxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpXFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcXFxuICAgICAgICAgICAgfSwgbmFtZSlcXFxcbiAgICAgICAgfSlcXFxcbiAgICB9KVxcXFxufVxcXFxuXFxcXG5bJ+eDreaSreaWsOWJpy10dicsICfng63pl6jnlLXlvbEtbW92aWUnLCAn54Ot5pKt5Yqo5ryrLWFuaW1lJywgJ+eDreaSree7vOiJui1zaG93JywgJ+eDreaSree6quW9leeJhy1kb2N1bWVudGFyeSddLm1hcCh4ID0+IHtcXFxcbiAgICBzZXRMaXN0cyh4KVxcXFxufSlcXFxcblxcXFxufVxcXFxuXFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5Ye95pWwXFxcIixcXFwicGF0aFxcXCI6XFxcInh0b29sc1xcXCIsXFxcInJ1bGVcXFwiOlxcXCJqczpcXFxcbmZ1bmN0aW9uIGVuY29kZVVURjgocykge1xcXFxudmFyIGksIHIgPSBbXSwgYywgeDtcXFxcbmZvciAoaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKVxcXFxuaWYgKChjID0gcy5jaGFyQ29kZUF0KGkpKSA8IDB4ODApIHIucHVzaChjKTtcXFxcbmVsc2UgaWYgKGMgPCAweDgwMCkgci5wdXNoKDB4QzAgKyAoYyA+PiA2ICYgMHgxRiksIDB4ODAgKyAoYyAmIDB4M0YpKTtcXFxcbmVsc2Uge1xcXFxuaWYgKCh4ID0gYyBeIDB4RDgwMCkgPj4gMTAgPT0gMCkgLy/lr7nlm5vlrZfoioJVVEYtMTbovazmjaLkuLpVbmljb2RlXFxcXG5jID0gKHggPDwgMTApICsgKHMuY2hhckNvZGVBdCgrK2kpIF4gMHhEQzAwKSArIDB4MTAwMDAsXFxcXG5yLnB1c2goMHhGMCArIChjID4+IDE4ICYgMHg3KSwgMHg4MCArIChjID4+IDEyICYgMHgzRikpO1xcXFxuZWxzZSByLnB1c2goMHhFMCArIChjID4+IDEyICYgMHhGKSk7XFxcXG5yLnB1c2goMHg4MCArIChjID4+IDYgJiAweDNGKSwgMHg4MCArIChjICYgMHgzRikpO1xcXFxufTtcXFxcbnJldHVybiByO1xcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiBzaGExKHMpIHtcXFxcbnZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlVVRGOChzKSlcXFxcbnZhciBpLCBqLCB0O1xcXFxudmFyIGwgPSAoKGRhdGEubGVuZ3RoICsgOCkgPj4+IDYgPDwgNCkgKyAxNiwgcyA9IG5ldyBVaW50OEFycmF5KGwgPDwgMik7XFxcXG5zLnNldChuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlcikpLCBzID0gbmV3IFVpbnQzMkFycmF5KHMuYnVmZmVyKTtcXFxcbmZvciAodCA9IG5ldyBEYXRhVmlldyhzLmJ1ZmZlciksIGkgPSAwOyBpIDwgbDsgaSsrKXNbaV0gPSB0LmdldFVpbnQzMihpIDw8IDIpO1xcXFxuc1tkYXRhLmxlbmd0aCA+PiAyXSB8PSAweDgwIDw8ICgyNCAtIChkYXRhLmxlbmd0aCAmIDMpICogOCk7XFxcXG5zW2wgLSAxXSA9IGRhdGEubGVuZ3RoIDw8IDM7XFxcXG52YXIgdyA9IFtdLCBmID0gW1xcXFxuZnVuY3Rpb24gKCkgeyByZXR1cm4gbVsxXSAmIG1bMl0gfCB+bVsxXSAmIG1bM107IH0sXFxcXG5mdW5jdGlvbiAoKSB7IHJldHVybiBtWzFdIF4gbVsyXSBeIG1bM107IH0sXFxcXG5mdW5jdGlvbiAoKSB7IHJldHVybiBtWzFdICYgbVsyXSB8IG1bMV0gJiBtWzNdIHwgbVsyXSAmIG1bM107IH0sXFxcXG5mdW5jdGlvbiAoKSB7IHJldHVybiBtWzFdIF4gbVsyXSBeIG1bM107IH1cXFxcbl0sIHJvbCA9IGZ1bmN0aW9uIChuLCBjKSB7IHJldHVybiBuIDw8IGMgfCBuID4+PiAoMzIgLSBjKTsgfSxcXFxcbmsgPSBbMTUxODUwMDI0OSwgMTg1OTc3NTM5MywgLTE4OTQwMDc1ODgsIC04OTk0OTc1MTRdLFxcXFxubSA9IFsxNzMyNTg0MTkzLCAtMjcxNzMzODc5LCBudWxsLCBudWxsLCAtMTAwOTU4OTc3Nl07XFxcXG5tWzJdID0gfm1bMF0sIG1bM10gPSB+bVsxXTtcXFxcbmZvciAoaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSArPSAxNikge1xcXFxudmFyIG8gPSBtLnNsaWNlKDApO1xcXFxuZm9yIChqID0gMDsgaiA8IDgwOyBqKyspXFxcXG53W2pdID0gaiA8IDE2ID8gc1tpICsgal0gOiByb2wod1tqIC0gM10gXiB3W2ogLSA4XSBeIHdbaiAtIDE0XSBeIHdbaiAtIDE2XSwgMSksXFxcXG50ID0gcm9sKG1bMF0sIDUpICsgZltqIC8gMjAgfCAwXSgpICsgbVs0XSArIHdbal0gKyBrW2ogLyAyMCB8IDBdIHwgMCxcXFxcbm1bMV0gPSByb2wobVsxXSwgMzApLCBtLnBvcCgpLCBtLnVuc2hpZnQodCk7XFxcXG5mb3IgKGogPSAwOyBqIDwgNTsgaisrKW1bal0gPSBtW2pdICsgb1tqXSB8IDA7XFxcXG59O1xcXFxudCA9IG5ldyBEYXRhVmlldyhuZXcgVWludDMyQXJyYXkobSkuYnVmZmVyKTtcXFxcbmZvciAodmFyIGkgPSAwOyBpIDwgNTsgaSsrKW1baV0gPSB0LmdldFVpbnQzMihpIDw8IDIpO1xcXFxuXFxcXG52YXIgaGV4ID0gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShtKS5idWZmZXIpLCBmdW5jdGlvbiAoZSkge1xcXFxucmV0dXJuIChlIDwgMTYgPyBcXFxcXFxcIjBcXFxcXFxcIiA6IFxcXFxcXFwiXFxcXFxcXCIpICsgZS50b1N0cmluZygxNik7XFxcXG59KS5qb2luKFxcXFxcXFwiXFxcXFxcXCIpO1xcXFxucmV0dXJuIGhleDtcXFxcbn1cXFxcblxcXFxuXFxcXG5mdW5jdGlvbiBzZWFyY2gocywgcGFnZSkge1xcXFxuICAgIGV2YWwoZ2V0Q3J5cHRvSlMoKSlcXFxcbiAgICBpZiAocGFnZSA9PSAxKSB7XFxcXG4gICAgICAgIHAgPSAwXFxcXG4gICAgfSBlbHNlIGlmIChwYWdlID09IDIpIHtcXFxcbiAgICAgICAgcCA9IDE5XFxcXG4gICAgfSBlbHNlIHtcXFxcbiAgICAgICAgcCA9IHBhcnNlSW50KHBhZ2UpICsgMjBcXFxcbiAgICB9XFxcXG4gICAgc3RvcmFnZTAucHV0TXlWYXIoJ3BhZ2UnLCBwKVxcXFxuICAgIHNzID0gcyArICdVUkJCUkdST1VOJ1xcXFxuICAgIHRrID0gQ3J5cHRvSlMuU0hBMShzcykudG9TdHJpbmcoKTtcXFxcbiAgICB2YXIgaiA9IGZldGNoKGBodHRwczovL2FwaS5jdXBmb3guYXBwL2FwaS92Mi9zZWFyY2gvP3RleHQ9JHtzfSZ0eXBlPTAmZnJvbT0ke3B9JnNpemU9MjAmZG91YmFuX2lkPTAmdG9rZW49JHt0a31gKVxcXFxuICAgIHRyeSB7XFxcXG4gICAgICAgIHZhciBqc29uID0gSlNPTi5wYXJzZShqKVxcXFxuICAgIH0gY2F0Y2gge1xcXFxuICAgICAgICB2YXIganNvbiA9IHt9XFxcXG4gICAgfVxcXFxuICAgIHJldHVybiBqc29uXFxcXG59XFxcXG5cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCI0Lumdkum6plxcXCIsXFxcInBhdGhcXFwiOlxcXCJxaW1haXR2XFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxuaWYgKHMgIT0gXFxcXFxcXCJcXFxcXFxcIikge1xcXFxuICAgIHZhciB1cmw9XFxcXFxcXCJodHRwOi8vbS5xbXR2LmFwcC9wcm9kLWFwaS9hcHAvbW92aWUvaW5kZXgvc2VhcmNoTW92aWVCeU5hbWVcXFxcXFxcIjtcXFxcbiAgICBcXFxcbiAgICBsZXQgaHRtbCA9IGZldGNoKHVybCwge1xcXFxuICAgICAgICBoZWFkZXJzOiB7XFxcXG4gICAgICAgICAgICBcXFxcXFxcIlgtUmVxdWVzdGVkLVdpdGhcXFxcXFxcIjogXFxcXFxcXCJYTUxIdHRwUmVxdWVzdFxcXFxcXFwiXFxcXG4gICAgICAgIH0sXFxcXG4gICAgICAgIGJvZHk6XFxcXG4gICAgICAgICAgICB7XFxcXG4gIFxcXFxcXFwiY29uZGl0aW9uXFxcXFxcXCI6IHMsXFxcXG4gIFxcXFxcXFwicGFnZVNpemVcXFxcXFxcIjogMjUsXFxcXG4gIFxcXFxcXFwicGFnZU51bVxcXFxcXFwiOiAxXFxcXG4gICAgICAgIH1cXFxcbiAgICB9KTtcXFxcbiAgICBcXFxcbiAgICB2YXIgaW5mbyA9ICcnXFxcXG4gICAgdHJ5IHtcXFxcbiAgICAgICAgaW5mbyA9IEpTT04ucGFyc2UoaHRtbCkuZGF0YS5yZWNvcmRzO1xcXFxuICAgIH0gY2F0Y2gge1xcXFxuXFxcXG4gICAgfVxcXFxuICAgIGlmIChpbmZvICE9IG51bGwpIHtcXFxcbiAgICAgICAgdmFyIGRhdGEgPSBpbmZvO1xcXFxuICAgIH0gZWxzZSB7XFxcXG4gICAgICAgIGRhdGEgPSBbXVxcXFxuICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgdGl0bGU6ICfigJzigJzigJ3igJ08c21hbGw+5peg57uT5p6cPC9zYW1sbD4nLFxcXFxuICAgICAgICAgICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJ1xcXFxuICAgICAgICB9KVxcXFxuICAgICAgICBzZXRSZXN1bHQoZClcXFxcbiAgICB9XFxcXG5cXFxcbiAgICBsZXQge1xcXFxuICAgICAgICB3cmFwMVxcXFxuICAgIH0gPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvdG9vbFxcXFxcXFwiKTtcXFxcbiAgICBmb3IgKGxldCBpdCBvZiBkYXRhKSB7XFxcXG4gICAgICAgIC8vbG9nKGl0KVxcXFxuICAgICAgICBsZXQgdCA9IGl0Lm5hbWU7XFxcXG4gICAgICAgIGxldCB3ZWIgPSBpdC53ZWJzaXRlTmFtZTtcXFxcbiAgICAgICAgbGV0IGltZyA9IGl0LndlYnNpdGVJY29uO1xcXFxuICAgICAgICBsZXQgdXJsPWl0LnVyaTtcXFxcbiAgICAgICAgXFxcXG4gICAgICAgIGlmICghdCkge1xcXFxuICAgICAgICAgICAgY29udGludWU7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgdmFyIHUgPSBcXFxcXFxcImhpa2VyOi8vcGFnZS9wP3U9XFxcXFxcXCIgKyBiYXNlNjRFbmNvZGUodXJsKVxcXFxuICAgICAgICB1ID0gZ2V0SXRlbSgnYWknLCAnMCcpID09ICcwJyA/IHUgOiB1ICsgJyNpbW1lcnNpdmVUaGVtZSMnXFxcXG4gICAgICAgIFxcXFxuICAgICAgICBcXFxcbiAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuKAnOKAnOKAneKAnVxcXFxcXFwiK3dyYXAxKHdlYiArICctJyArIHQsIHMpLFxcXFxuICAgICAgICAgICAgdXJsOiB1LFxcXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwibW92aWVfMV9sZWZ0X3BpY1xcXFxcXFwiLFxcXFxuICAgICAgICAgICAgaW1nOml0LmNvdmVyLFxcXFxuICAgICAgICAgICAgLy9kZXNjOiAnJyxcXFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgaWQ6IGl0LnVyaSxcXFxcbiAgICAgICAgICAgICAgICBpbmhlcml0VGl0bGU6IGZhbHNlLFxcXFxuICAgICAgICAgICAgICAgIHBhZ2VUaXRsZTogdCxcXFxcbiAgICAgICAgICAgICAgICB3ZWI6d2ViLFxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9KTtcXFxcbiAgICB9XFxcXG4gICAgc2V0UmVzdWx0KGQpXFxcXG59IGVsc2Uge1xcXFxuXFxcXG59XFxcXG5cXFxcbmlmIChnZXRJdGVtKCdob21lJywgJ+WFsycpID09ICflvIAnKSB7XFxcXG4gICAgZnVuY3Rpb24gc2V0TGlzdHMoaXRlbSkge1xcXFxuICAgICAgICB2YXIgdGl0bGUgPSBpdGVtLnNwbGl0KCctJylbMF1cXFxcbiAgICAgICAgdmFyIHQgPSBpdGVtLnNwbGl0KCctJylbMV1cXFxcbiAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiAnYXZhdGFyJyxcXFxcbiAgICAgICAgICAgIGltZzogJ2h0dHBzOi8vbGFubWVpZ3VvamlhbmcuY29tL3R1Ymlhby9tb3JlLzEwLnBuZydcXFxcbiAgICAgICAgfSlcXFxcblxcXFxuICAgICAgICB2YXIganNvbiA9IEpTT04ucGFyc2UoZmV0Y2hQQyhgaHR0cHM6Ly93d3cucW10di5hcHAvcHJvZC1hcGkvYXBwL21vdmllL2luZGV4L3NlYXJjaEFsbE1vdmllYCkpXFxcXG4gICAgICAgXFxcXG5cXFxcbiAgICAgICAgdmFyIGxpc3QgPSBqc29uLmRhdGFbdF0ucmVjb3JkcztcXFxcblxcXFxuICAgICAgICBsaXN0Lm1hcCh4ID0+IHtcXFxcbiAgICAgICAgICAgIHZhciBuYW1lID0geC50aXRsZTtcXFxcbiAgICAgICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IG5hbWUsXFxcXG4gICAgICAgICAgICAgICAgaW1nOiB4LmNvdmVyLFxcXFxuICAgICAgICAgICAgICAgIGRlc2M6IHgucmF0ZSxcXFxcbiAgICAgICAgICAgICAgICB1cmw6ICQoJycpLmxhenlSdWxlKChuKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwic291XFxcXFxcXCIsIG4pXFxcXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKClcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcXFxuICAgICAgICAgICAgICAgIH0sIG5hbWUpXFxcXG4gICAgICAgICAgICB9KVxcXFxuICAgICAgICB9KVxcXFxuICAgIH1cXFxcblxcXFxuICAgIFsn54Ot5pKt55S15b2xLWxpc3RIb3RNb3ZpZScsICfng63mkq3nlLXop4bliactbGlzdEhvdFR2JywgJ+eDreaSreWKqOa8qy1saXN0SG90Q29taWMnLCAn54Ot5pKt57u86Im6LWxpc3RIb3RWYXJpZXR5J10ubWFwKHggPT4ge1xcXFxuICAgICAgICBzZXRMaXN0cyh4KVxcXFxuICAgIH0pXFxcXG59XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5Ye95pWwMlxcXCIsXFxcInBhdGhcXFwiOlxcXCJ6dG9vbHNcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG4vL3VybOino+aekFxcXFxuZnVuY3Rpb24gdXJsUGFyc2UodSkge1xcXFxuICAgIHZhciBkaWN0ID0ge31cXFxcbiAgICBkaWN0LlNvdXJjZSA9IHU7XFxcXG4gICAgbGV0IHBhcmFtcyA9ICh1cmwpID0+IHtcXFxcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XFxcXG4gICAgICAgIGxldCByZWcgPSAvKFtePz0mXSspPShbXj89Jl0rKS9nO1xcXFxuICAgICAgICB1cmwucmVwbGFjZShyZWcsIGZ1bmN0aW9uKCkge1xcXFxuICAgICAgICAgICAgcXVlcnlQYXJhbXNbYXJndW1lbnRzWzFdXSA9IGFyZ3VtZW50c1syXTtcXFxcbiAgICAgICAgfSlcXFxcbiAgICAgICAgcmV0dXJuIHF1ZXJ5UGFyYW1zXFxcXG4gICAgfVxcXFxuICAgIHZhciBqYXZhVXJsID0gSmF2YUltcG9ydGVyKGphdmEubmV0LlVSTCk7XFxcXG4gICAgd2l0aChqYXZhVXJsKSB7XFxcXG4gICAgICAgIHZhciB1cmwgPSBuZXcgVVJMKHUpO1xcXFxuICAgICAgICBkaWN0LlByb3RvY29sID0gdXJsLmdldFByb3RvY29sKCk7XFxcXG4gICAgICAgIGRpY3QuSG9zdCA9IHVybC5nZXRIb3N0KCk7XFxcXG4gICAgICAgIGRpY3QuUG9ydCA9IHVybC5nZXRQb3J0KCk7XFxcXG4gICAgICAgIGRpY3QuRmlsZSA9IHVybC5nZXRGaWxlKCk7XFxcXG4gICAgICAgIGRpY3QuUGF0aCA9IHVybC5nZXRQYXRoKCk7XFxcXG4gICAgICAgIGRpY3QuUmVmID0gdXJsLmdldFJlZigpO1xcXFxuICAgICAgICBkaWN0Lkhvc3RzID0gYCR7dXJsLmdldFByb3RvY29sKCl9Oi8vJHt1cmwuZ2V0SG9zdCgpfWBcXFxcbiAgICB9XFxcXG4gICAgZGljdC5QYXJhbXMgPSBwYXJhbXModSk7XFxcXG4gICAgcmV0dXJuIGRpY3Q7XFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIHN0cmluZ0luQXJyYXkoc3RyLCBhcnIpIHtcXFxcbiAgICByZXR1cm4gYXJyLnNvbWUoaXRlbSA9PiBzdHIuaW5jbHVkZXMoaXRlbSkpO1xcXFxufVxcXFxuXFxcXG5cXFxcbi8v5o6S6Zmk5rKh6Lev5b6EXFxcXG5mdW5jdGlvbiBub2ZpbGUodSkge1xcXFxuICAgIHVybCA9IHUuaHJlZlxcXFxuICAgIGlmIChzdHJpbmdJbkFycmF5KHVybCwgWydtYWduZXQnLCAnZWQyayddKSkge1xcXFxuICAgICAgICBCaXRUUy5wdXNoKHUpO1xcXFxuICAgICAgICByZXR1cm4gdHJ1ZVxcXFxuICAgIH1cXFxcbiAgICB2YXIgdSA9IHVybFBhcnNlKHVybClcXFxcbiAgICBpZiAodS5GaWxlID09ICcnIHx8IHUuRmlsZSA9PSAnLycgfHwgdS5SZWYgIT0gbnVsbCkge1xcXFxuICAgICAgICByZXR1cm4gdHJ1ZVxcXFxuICAgIH1cXFxcbn1cXFxcbi8v5Y676YeNXFxcXG5mdW5jdGlvbiB1bmlxdWUoYXJyKSB7XFxcXG4gICAgY29uc3QgcmVzID0gbmV3IE1hcCgpXFxcXG4gICAgcmV0dXJuIGFyci5maWx0ZXIoKGEpID0+ICFyZXMuaGFzKGEudXJsKSAmJiByZXMuc2V0KGEudXJsLCAxKSlcXFxcbn1cXFxcblxcXFxuLy/ph43lrprlkJHlj6/nlKjpk77mjqVcXFxcbmZ1bmN0aW9uIGdldFR1cmwodSkge1xcXFxuICAgIC8vbG9nKHUpXFxcXG4gICAgdHJ5IHtcXFxcbiAgICAgICAgdmFyIHVybCA9IGJhc2U2NERlY29kZSh1KTtcXFxcbiAgICB9IGNhdGNoIHtcXFxcbiAgICAgICAgdmFyIHVybCA9IHVcXFxcbiAgICB9XFxcXG4gICAgaWYgKCF1cmwuaW5jbHVkZXMoJ2h0dHAnKSB8fCB1cmwgPT0gdW5kZWZpbmVkKSB7XFxcXG4gICAgICAgIHVybCA9IHVcXFxcbiAgICB9XFxcXG4gICAgdXJsID0gdXJsLmluY2x1ZGVzKCc/JykgPyB1cmwuc3BsaXQoJz8nKVswXSA6IHVybFxcXFxuICAgIGxvZygndXJsOicgKyB1cmwpXFxcXG4gICAgdmFyIGZpbGUgPSB1cmxQYXJzZSh1cmwpLkZpbGVcXFxcbiAgICB2YXIgdHVybCA9ICcnXFxcXG4gICAgbGV0IGhlYWQgPSBKU09OLnBhcnNlKHJlcXVlc3QodXJsLCB7XFxcXG4gICAgICAgIG9ubHlIZWFkZXJzOiB0cnVlXFxcXG4gICAgfSkpO1xcXFxuICAgIC8vbG9nKGhlYWQpXFxcXG4gICAgaWYgKGhlYWQudXJsICE9IHVuZGVmaW5lZCB8fCBoZWFkLnVybCAhPSAnJykge1xcXFxuICAgICAgICB2YXIganVybHAgPSB1cmxQYXJzZShoZWFkLnVybClcXFxcbiAgICAgICAgaWYgKGp1cmxwLkZpbGUgPT0gJy8nIHx8IGp1cmxwLkZpbGUgPT0gJycpIHtcXFxcbiAgICAgICAgICAgIHR1cmwgPSBqdXJscC5Ib3N0cyArIGZpbGVcXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIHR1cmwgPSBoZWFkLnVybFxcXFxuICAgICAgICB9XFxcXG4gICAgfSBlbHNlIHtcXFxcbiAgICAgICAgdHVybCA9IHVybFxcXFxuICAgIH1cXFxcbiAgICAvL2xvZygndHVybDonK3R1cmwpXFxcXG4gICAgdHVybCA9IHR1cmwucmVwbGFjZSgvXFxcXFxcXFw/ZnJvbS4rJC9nbSwgJycpO1xcXFxuXFxcXG4gICAgdHVybCA9IHZpZGVvUmVmRGV0YWlsKHR1cmwpXFxcXG4gICAgLy9sb2codHVybClcXFxcbiAgICByZXR1cm4gdHVybFxcXFxufVxcXFxuXFxcXG5cXFxcbmZ1bmN0aW9uIHZpZGVvUmVmRGV0YWlsKHVybCkge1xcXFxuICAgIGlmIChzdHJpbmdJbkFycmF5KHVybCwgW1xcXFxcXFwiNjA4MFxcXFxcXFwiXSkpIHtcXFxcbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoXFxcXFxcXCJ2cGxheVxcXFxcXFwiLCBcXFxcXFxcInZpZGVvXFxcXFxcXCIpO1xcXFxuICAgIH0gZWxzZSBpZiAoc3RyaW5nSW5BcnJheSh1cmwsIFtcXFxcXFxcInpodWlqdVxcXFxcXFwiXSkpIHtcXFxcbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoXFxcXFxcXCJ2b2RwbGF5XFxcXFxcXCIsIFxcXFxcXFwidm9kZGV0YWlsXFxcXFxcXCIpO1xcXFxuICAgIH0gZWxzZSBpZiAoc3RyaW5nSW5BcnJheSh1cmwsIFtcXFxcXFxcInJyZXRzXFxcXFxcXCJdKSkge1xcXFxuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShcXFxcXFxcInBsYXlcXFxcXFxcIiwgXFxcXFxcXCJwcm9qZWN0XFxcXFxcXCIpXFxcXG4gICAgfVxcXFxuICAgIHJldHVybiB1cmw7XFxcXG59XFxcXG5cXFxcblxcXFxuLy/lpJrpgInmqKHlnZdcXFxcbmZ1bmN0aW9uIE11bHRpU2VsZWN0TW9kZShuYW1lLCBpZCkge1xcXFxuICAgIHJldHVybiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChkYXRhdGl0bGUsIGRhdGF1cmwpID0+IHtcXFxcbiAgICAgICAgZnVuY3Rpb24gdW5pcXVlKGFycikge1xcXFxuICAgICAgICBjb25zdCByZXMgPSBuZXcgTWFwKClcXFxcbiAgICAgICAgcmV0dXJuIGFyci5maWx0ZXIoKGEpID0+ICFyZXMuaGFzKGEudXJsKSAmJiByZXMuc2V0KGEudXJsLCAxKSlcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBsZXQgZHVvc2VsZWN0ID0gc3RvcmFnZTAuZ2V0TXlWYXIoXFxcXFxcXCJkdW9zZWxlY3RcXFxcXFxcIikgPyBzdG9yYWdlMC5nZXRNeVZhcihcXFxcXFxcImR1b3NlbGVjdFxcXFxcXFwiKSA6IFtdO1xcXFxuICAgICAgICBpZiAoZHVvc2VsZWN0LmZpbmRJbmRleCh4ID0+IHgudXJsID09PSBkYXRhdXJsKSA9PSAtMSkge1xcXFxuICAgICAgICAgICAgZHVvc2VsZWN0LnB1c2goe1xcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiBkYXRhdGl0bGUsXFxcXG4gICAgICAgICAgICAgICAgdXJsOiBkYXRhdXJsXFxcXG4gICAgICAgICAgICB9KVxcXFxuICAgICAgICAgICAgZHVvc2VsZWN0ID0gdW5pcXVlKGR1b3NlbGVjdClcXFxcbiAgICAgICAgICAgIHVwZGF0ZUl0ZW0oZGF0YXVybCwge1xcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiBg4oCc4oCc4oCd4oCdPHNwYW4gc3R5bGU9XFxcXFxcXCJjb2xvcjojRkY1NzMzXFxcXFxcXCI+YCArIGRhdGF0aXRsZVxcXFxuICAgICAgICAgICAgICAgIC8vdGl0bGU6YOKAmOKAmGArZGF0YXRpdGxlK2DigJnigJlgXFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlbW92ZUJ5VmFsdWUoYXJyLCB2YWwpIHtcXFxcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xcXFxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJyW2ldWyd1cmwnXSA9PSB2YWwpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyci5zcGxpY2UoaSwgMSk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIHJlbW92ZUJ5VmFsdWUoZHVvc2VsZWN0LCBkYXRhdXJsKVxcXFxuICAgICAgICAgICAgdXBkYXRlSXRlbShkYXRhdXJsLCB7XFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IGRhdGF0aXRsZVxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgc3RvcmFnZTAucHV0TXlWYXIoXFxcXFxcXCJkdW9zZWxlY3RcXFxcXFxcIiwgZHVvc2VsZWN0KTtcXFxcbiAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiXFxcXG4gICAgfSwgbmFtZSwgaWQpXFxcXG59XFxcXG5cXFxcbiQuZXh0ZW5kKHtcXFxcbiAgICBtc206IE11bHRpU2VsZWN0TW9kZSxcXFxcbn0pXFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5o6o6YCBXFxcIixcXFwicGF0aFxcXCI6XFxcInB1c2hcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5sZXQgaXRlbXMgPSBbXTtcXFxcbmxldCBwdXNoaW4gPSBkZWNvZGVVUklDb21wb25lbnQoZ2V0UGFyYW0oXFxcXFxcXCJwdXNodXJsXFxcXFxcXCIpKTtcXFxcbmxldCB0dmlwID0gZ2V0SXRlbSgnaGlrZXJ0dmJveHNldCcsICcnKTtcXFxcblxcXFxuaXRlbXMucHVzaCh7XFxcXG4gICAgdGl0bGU6ICflvZPliY1JUO+8micgKyB0dmlwLFxcXFxuICAgIHVybDogXFxcXFxcXCJpbnB1dDovL1xcXFxcXFwiICsgZ2V0SXRlbSgnaGlrZXJ0dmJveHNldCcsICdodHRwOi8vJyArIGdldElQKCkgKyAnOjk5NzgnKSArIFxcXFxcXFwiLy8vL+ivt+i+k+WFpVRWQm9456uv55qESVDlnLDlnYDvvIzlpoJodHRwOi8vXFxcXFxcXCIgKyBnZXRJUCgpICsgXFxcXFxcXCI6OTk3OC5qczpzZXRJdGVtKCdoaWtlcnR2Ym94c2V0JyxpbnB1dCk7cmVmcmVzaFBhZ2UoKVxcXFxcXFwiLFxcXFxuICAgIGNvbF90eXBlOiAnZmxleF9idXR0b24nXFxcXG59KTtcXFxcbnZhciBwdXJsID0gcHVzaGluO1xcXFxuXFxcXG5pZiAocHVzaGluLmluY2x1ZGVzKCdcXFxcXFxcXG4nKSAmJiAhcHVzaGluLnN0YXJ0c1dpdGgoJ3snKSkge1xcXFxuICAgIHB1cmwgPSBwdXNoaW4ucmVwbGFjZShcXFxcXFxcIlxcXFxcXFxcblxcXFxcXFwiLCAnJCcpO1xcXFxufVxcXFxuaWYgKHB1c2hpbi5zdGFydHNXaXRoKCdodHRwJykgJiYgcHVzaGluLmluY2x1ZGVzKCc7eycpKSB7XFxcXG4gICAgcHVybCA9IEpTT04uc3RyaW5naWZ5KHtcXFxcbiAgICAgICAgXFxcXFxcXCJuYW1lXFxcXFxcXCI6IFxcXFxcXFwi5rW36ZiU55u06ZO+5o6o6YCBXFxcXFxcXCIsXFxcXG4gICAgICAgIFxcXFxcXFwidXJsXFxcXFxcXCI6IHB1c2hpblxcXFxuICAgIH0pXFxcXG59XFxcXG5pZiAocHVzaGluLnN0YXJ0c1dpdGgoJ2h0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS9zLycpKSB7XFxcXG4gICAgbGV0IHJlZnRva2VuID0gSlNPTi5wYXJzZShmZXRjaCgnaGlrZXI6Ly9maWxlcy9ydWxlcy9pY3kvaWN5LWFsaS10b2tlbi5qc29uJywge30pKVswXS5yZWZyZXNoX3Rva2VuO1xcXFxuICAgIHB1cmwgPSBKU09OLnN0cmluZ2lmeSh7XFxcXG4gICAgICAgIFxcXFxcXFwidXJsXFxcXFxcXCI6IHB1c2hpbixcXFxcbiAgICAgICAgXFxcXFxcXCJyZWZyZXNoX3Rva2VuXFxcXFxcXCI6IHJlZnRva2VuXFxcXG4gICAgfSlcXFxcbn1cXFxcbmlmIChwdXNoaW4uaW5jbHVkZXMoJzo1MjAyMCcpKSB7XFxcXG4gICAgaWYgKHB1c2hpbi5pbmNsdWRlcygncmVkaXJlY3RQbGF5VXJsJykpIHtcXFxcbiAgICAgICAgcHVybCA9IEpTT04uc3RyaW5naWZ5KHtcXFxcbiAgICAgICAgICAgIFxcXFxcXFwibmFtZVxcXFxcXFwiOiBcXFxcXFxcIua1t+mYlOaKleWxj+ebtOmTvlxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgXFxcXFxcXCJ1cmxcXFxcXFxcIjogcHVzaGluXFxcXG4gICAgICAgIH0pXFxcXG4gICAgfSBlbHNlIHtcXFxcbiAgICAgICAgcHVybCA9IEpTT04uc3RyaW5naWZ5KHtcXFxcbiAgICAgICAgICAgIFxcXFxcXFwibmFtZVxcXFxcXFwiOiBcXFxcXFxcIua1t+mYlOe9kemhteaKleWxj1xcXFxcXFwiLFxcXFxuICAgICAgICAgICAgXFxcXFxcXCJ1cmxcXFxcXFxcIjogcHVzaGluXFxcXG4gICAgICAgIH0pXFxcXG4gICAgfVxcXFxufVxcXFxuXFxcXG4vL2xvZygn5o6o6YCBJytwdXJsKTtcXFxcbnZhciBzdGF0ZSA9IHJlcXVlc3QodHZpcCArICcvYWN0aW9uJywge1xcXFxuICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxcXFxuICAgICAgICAvLydYLVJlcXVlc3RlZC1XaXRoJzogJ1hNTEh0dHBSZXF1ZXN0JyxcXFxcbiAgICAgICAgJ1JlZmVyZXInOiB0dmlwXFxcXG4gICAgfSxcXFxcbiAgICB0aW1lb3V0OiAyMDAwLFxcXFxuICAgIGJvZHk6ICdkbz1wdXNoJnVybD0nICsgcHVybC5yZXBsYWNlKC9cXFxcXFxcXCYvZywgJ++8hu+8hicpLFxcXFxuICAgIG1ldGhvZDogJ1BPU1QnXFxcXG59KTtcXFxcbi8vbG9nKHN0YXRlKTtcXFxcbmlmIChzdGF0ZSA9PSAnb2snKSB7XFxcXG4gICAgLy9sb2coc3RhdGUpO1xcXFxuICAgIGl0ZW1zLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogXFxcXFxcXCLinIVcXFxcXFxcIiArIHN0YXRlLFxcXFxuICAgICAgICB1cmw6ICQoJycpLmxhenlSdWxlKCgpID0+IHtcXFxcbiAgICAgICAgICAgIGJhY2soZmFsc2UpO1xcXFxuICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcXFxuICAgICAgICB9KSxcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF9jZW50ZXJfMVxcXFxcXFwiXFxcXG4gICAgfSk7XFxcXG59IGVsc2Uge1xcXFxuICAgIC8vbG9nKHN0YXRlKTtcXFxcbiAgICBpdGVtcy5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IFxcXFxcXFwi4p2OXFxcXFxcXCIgKyBzdGF0ZSxcXFxcbiAgICAgICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIixcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF9jZW50ZXJfMVxcXFxcXFwiXFxcXG4gICAgfSk7XFxcXG5cXFxcbn1cXFxcbnNldFJlc3VsdChpdGVtcyk7XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi6K6+572uXFxcIixcXFwicGF0aFxcXCI6XFxcInNldHRpbmdcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG52YXIgZD1bXVxcXFxuaWYgKE1ZX1BBR0UgPT0gMSkge1xcXFxuICAgIGQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiAn6K6+572uSVDlnLDlnYAnLFxcXFxuICAgICAgICB1cmw6IFxcXFxcXFwiaW5wdXQ6Ly9cXFxcXFxcIiArIGdldEl0ZW0oJ2hpa2VydHZib3hzZXQnLCAnaHR0cDovLycgKyBnZXRJUCgpICsgJzo5OTc4JykgKyBcXFxcXFxcIi8vLy/or7fovpPlhaV0dmJveOaOqOmAgUlQ5Zyw5Z2A77yM5aaCaHR0cDovL1xcXFxcXFwiICsgZ2V0SVAoKSArIFxcXFxcXFwiOjk5NzguanM6c2V0SXRlbSgnaGlrZXJ0dmJveHNldCcsaW5wdXQpO3JlZnJlc2hQYWdlKClcXFxcXFxcIixcXFxcbiAgICAgICAgY29sX3R5cGU6ICdmbGV4X2J1dHRvbidcXFxcbiAgICB9KTtcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogZ2V0SXRlbSgnaGlrZXJ0dmJveHNldCcsICcnKSxcXFxcbiAgICAgICAgdXJsOiAnaGlrZXI6Ly9lbXB0eScsXFxcXG4gICAgICAgIGNvbF90eXBlOiAnZmxleF9idXR0b24nXFxcXG4gICAgfSk7XFxcXG59XFxcXG5cXFxcbnNldFJlc3VsdChkKVxcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIng1YWlcXFwiLFxcXCJwYXRoXFxcIjpcXFwieDVhaVxcXCIsXFxcInJ1bGVcXFwiOlxcXCIkLmV4cG9ydHMgPSBmdW5jdGlvbihydWxlLCBhbmNob3JJZCkge1xcXFxuICAgIHJldHVybiAkLnRvU3RyaW5nKChydWxlLCBhbmNob3JJZCwgbW9iYW4pID0+IHtcXFxcbiAgICAgICAgaWYgKHdpbmRvdy5jaGVjazAgPT0gbnVsbCkge1xcXFxuICAgICAgICAgICAgZnVuY3Rpb24gY2hlY2swKCkge1xcXFxuICAgICAgICAgICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGxldCBodG1sID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcXFxcXFxcImh0bWxcXFxcXFxcIikuaW5uZXJIVE1MO1xcXFxuICAgICAgICAgICAgICAgICAgICBmYmEucHV0VmFyKFxcXFxcXFwiaHRtbDBcXFxcXFxcIiwgaHRtbCk7XFxcXG4gICAgICAgICAgICAgICAgICAgIGZiYS5wYXJzZUxhenlSdWxlQXN5bmMoJCQkKCkubGF6eVJ1bGUoKHJ1bGUsIHVybCwgYW5jaG9ySWQsIG1vYmFuKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBodG1sID0gZ2V0VmFyKFxcXFxcXFwiaHRtbDBcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGl1cmwgPSAnJztcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclZhcihcXFxcXFxcImh0bWwwXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbG9nKCd1cmw6JyArIHVybClcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXJsLnN0YXJ0c1dpdGgoJ2h0dHBzOi8vY3VwZm94LmFwcC9wYWdlP3VybD0nKSkge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZXVybCA9IHVybC5yZXBsYWNlKC8uK3VybD0oLio/KSYuKy9nbSwgJyQxJylcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXVybCA9IGJhc2U2NERlY29kZShiYXNldXJsKVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXRWYXIoJ2lmcmFtZScsIGl1cmwpXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZygnaXVybDonICsgaXVybClcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl1cmwubGVuZ3RoID4gMCA/IFxcXFxcXFwiMVxcXFxcXFwiIDogXFxcXFxcXCIwXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nKGUudG9TdHJpbmcoKSk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgICAgIH0sIHJ1bGUsIGxvY2F0aW9uLmhyZWYsIGFuY2hvcklkLCBtb2JhbiksICQkJC50b1N0cmluZygocnVsZSxtb2JhbikgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9mYmEubG9nKGlucHV0KVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9mYmEubG9nKHJ1bGUpXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXFxcXFxcXCIwXFxcXFxcXCIgPT0gaW5wdXQpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY2hlY2tjID0gd2luZG93LmNoZWNrYyArIDE7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyppZiAod2luZG93LmNoZWNrYyA+IDEyMCkge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYmEubG9nKFxcXFxcXFwi5omn6KGM6LaF6L+HMzDnp5LvvIzml6Dms5Xop6PmnpBcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsqL1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQod2luZG93LmNoZWNrMCwgMjUwKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL31cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVybCA9IGZiYS5nZXRWYXIoJ2lmcmFtZScpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZiYS5sb2coJ21vYmFuJyttb2JhbilcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihtb2Jhbj09JzEnKXtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsPXVybCsnI2ltbWVyc2l2ZVRoZW1lIydcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ICAgICAgXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmJhLmxvZyh1cmwpXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmJhLm9wZW4oSlNPTi5zdHJpbmdpZnkoe1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlOiBydWxlLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ+W9seeJh+ivpuaDhScsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwOiBcXFxcXFxcIlxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVSdWxlOiBcXFxcXFxcIlxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlczogXFxcXFxcXCJcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAnaGlrZXI6Ly9wYWdlL3A/cnVsZT0nICsgcnVsZSArICcmdT0nICsgdXJsLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5kUnVsZTogXFxcXFxcXCJcXFxcXFxcIlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY2hlY2t1cmwgPSBsb2NhdGlvbi5ocmVmO1xcXFxuXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gY2hlY2t1MCgpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5jaGVja3VybCAhPSBsb2NhdGlvbi5ocmVmKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2hhc2jlj5HnlJ/kuoblj5jljJZcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmNoZWNrYyA9IDA7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2swKCk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAyMDAwKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY2hlY2t1MCwgMjUwKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja3UwKCk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgICAgIH0scnVsZSxtb2JhbikpO1xcXFxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgZmJhLmxvZyhlLnRvU3RyaW5nKCkpO1xcXFxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHdpbmRvdy5jaGVjazAsIDI1MCk7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgd2luZG93LmNoZWNrYyA9IDA7XFxcXG4gICAgICAgICAgICB3aW5kb3cuY2hlY2swID0gY2hlY2swO1xcXFxuICAgICAgICAgICAgY2hlY2swKCk7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9LCBydWxlLCBhbmNob3JJZCwgZ2V0SXRlbSgnYWknLCcwJykpO1xcXFxufVxcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIjUu6Iy25p2v6JmOXFxcIixcXFwicGF0aFxcXCI6XFxcImFpb2JiXFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxubGV0IGR1cmwgPSBnZXRNeVZhcihcXFxcXFxcImR1cmxcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIik7XFxcXG5pZiAoZHVybCAhPSAnJykge1xcXFxuICAgIE1ZX1VSTCA9IGR1cmxcXFxcbiAgICBsb2coZHVybClcXFxcblxcXFxuICAgIGxldCB1cmwgPSBkdXJsO1xcXFxuICAgIGxldCBpZCA9IHVybDtcXFxcbiAgICB0cnkge1xcXFxuICAgICAgICB2YXIgaHRtbCA9IGZldGNoKHVybCk7XFxcXG4gICAgfSBjYXRjaCB7XFxcXG4gICAgICAgIHZhciBodG1sID0gJydcXFxcbiAgICB9XFxcXG4gICAgdmFyIHJ1bGUgPSBNWV9SVUxFLnRpdGxlXFxcXG4gICAgaWYgKGh0bWwgPT0gdW5kZWZpbmVkIHx8IGh0bWwgPT0gJycpIHtcXFxcbiAgICAgICAgdG9hc3QoJ+aXoOaVsOaNricpXFxcXG4gICAgICAgIGNsZWFyTXlWYXIoXFxcXFxcXCJzb3VcXFxcXFxcIik7XFxcXG4gICAgICAgIGNsZWFyTXlWYXIoXFxcXFxcXCJkdXJsXFxcXFxcXCIpO1xcXFxuICAgICAgICByZWZyZXNoUGFnZSgpXFxcXG4gICAgfSBlbHNlIHtcXFxcblxcXFxuICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgdGl0bGU6IHBkZmgoaHRtbCwgJ2g0JiZUZXh0JyksXFxcXG4gICAgICAgICAgICBpbWc6IHBkKGh0bWwsICdpbWcmJnNyYycpLFxcXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdtb3ZpZV8xX3ZlcnRpY2FsX3BpYycsXFxcXG4gICAgICAgICAgICBkZXNjOiBwZGZoKGh0bWwsICdib2R5JiYucHViVGltZSYmVGV4dCcpLFxcXFxuICAgICAgICAgICAgdXJsOiB1cmwsXFxcXG4gICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgIGlkOiB1cmwsXFxcXG4gICAgICAgICAgICAgICAgaW5oZXJpdFRpdGxlOiBmYWxzZVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9KVxcXFxuXFxcXG5cXFxcbiAgICAgICAgdmFyIGxpc3QgPSBwZGZhKGh0bWwsICcubW92aWVaeSYmYScpXFxcXG4gICAgICAgIGlmIChsaXN0ICYmIGxpc3QubGVuZ3RoID4gMCkge1xcXFxuICAgICAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICAgICAgICBNWV9VUkwgPSBcXFxcXFxcIlxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgICAgIGxldCB7XFxcXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlXFxcXG4gICAgICAgICAgICAgICAgfSA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS90b29sP3J1bGU9XFxcXFxcXCIgKyBydWxlKTtcXFxcbiAgICAgICAgICAgICAgICBsaXN0ID0gbGlzdC5tYXAoaXQgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IHBkZmgoaXQsICdhJiZocmVmJyk7XFxcXG4gICAgICAgICAgICAgICAgICAgIGxldCB0ID0gcGRmaChpdCwgJ3VsJiZUZXh0Jyk7XFxcXG4gICAgICAgICAgICAgICAgICAgIHUgPSBcXFxcXFxcImhpa2VyOi8vcGFnZS9wP3J1bGU9XFxcXFxcXCIgKyBydWxlICsgXFxcXFxcXCImdT1cXFxcXFxcIiArIGJhc2U2NEVuY29kZSh1KTtcXFxcbiAgICAgICAgICAgICAgICAgICAgdSA9IGdldEl0ZW0oJ2FpJywgJzAnKSA9PSAnMCcgPyB1IDogdSArICcjaW1tZXJzaXZlVGhlbWUjJ1xcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IG1lcmdlKHQsICfor6bmg4UnLCAxKSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZzogJ2h0dHBzOi8vd3d3LjcyNTk5OC5jb20vc3RhdGljL3NlYXJjaC9pbWFnZXMvb25MaW5lLnBuZycsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJhdmF0YXJcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5oZXJpdFRpdGxlOiBmYWxzZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbHM6IHVybCxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiAnaG9tZScsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgICAgICBkID0gZC5jb25jYXQobGlzdClcXFxcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICAgICAgICBsb2coZS50b1N0cmluZygpKTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6ICfml6DotYTmupAnLFxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMScsXFxcXG4gICAgICAgICAgICB9KVxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHNldFJlc3VsdChkKVxcXFxuICAgIH1cXFxcblxcXFxufVxcXFxucyA9IGdldE15VmFyKFxcXFxcXFwic291XFxcXFxcXCIsIFxcXFxcXFwiXFxcXFxcXCIpO1xcXFxuXFxcXG5sZXQgciA9IFxcXFxcXFwiXFxcXFxcXCI7XFxcXG5pZiAocyAhPSBcXFxcXFxcIlxcXFxcXFwiKSB7XFxcXG5cXFxcbiAgICB2YXIgdXJsID0gcG9zdChgaHR0cHM6Ly93d3cuNzI1OTk4LmNvbS9rZXl3b3Jkcy5odG1sYCwge1xcXFxuICAgICAgICBib2R5OiB7XFxcXG4gICAgICAgICAgICBrZXl3b3JkczogcyxcXFxcbiAgICAgICAgICAgIHR5cGU6ICdtb3ZpZSdcXFxcbiAgICAgICAgfSxcXFxcbiAgICAgICAgb25seUhlYWRlcnM6IHRydWVcXFxcbiAgICB9KVxcXFxuICAgIHZhciBqc29uID0gSlNPTi5wYXJzZSh1cmwpXFxcXG4gICAgdmFyIHR1cmwgPSBqc29uLnVybC5yZXBsYWNlKC8tXFxcXFxcXFxkKy5odG1sJC8sICctJyArIE1ZX1BBR0UgKyAnLmh0bWwnKVxcXFxuICAgIE1ZX1VSTCA9IHR1cmxcXFxcbiAgICB2YXIgaHRtbCA9IGZldGNoKHR1cmwpXFxcXG5cXFxcbiAgICB2YXIgbGlzdCA9IHBkZmEoaHRtbCwgJ2JvZHkmJi5lYWNoJylcXFxcbiAgICAvL2xvZyhsaXN0KVxcXFxuXFxcXG4gICAgbGV0IHtcXFxcbiAgICAgICAgd3JhcFxcXFxuICAgIH0gPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvdG9vbFxcXFxcXFwiKTtcXFxcblxcXFxuICAgIGZvciAobGV0IGl0IG9mIGxpc3QpIHtcXFxcbiAgICAgICAgbGV0IG5hbWUgPSBwZGZoKGl0LCAnYSYmdGl0bGUnKTtcXFxcbiAgICAgICAgbGV0IGltZyA9IHBkKGl0LCAnaW1nJiZzcmMnKTtcXFxcbiAgICAgICAgaWYgKGltZyA9PSBcXFxcXFxcIlxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICBpbWcgPSBcXFxcXFxcImh0dHBzOi8vd3d3LjcyNTk5OC5jb20vc3RhdGljL3NlYXJjaC9pbWFnZXMvcHJlbG9hZEltZy5wbmdcXFxcXFxcIjtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBsZXQgdXJsID0gcGQoaXQsICdhJiZocmVmJyk7XFxcXG4gICAgICAgIGxldCBkZXNjID0gcGRmYShpdCwgJ2JvZHkmJi5pbmZvJiZhJykubWFwKHggPT4gcGRmaCh4LCAnYSYmVGV4dCcpKS5qb2luKCcgJyk7XFxcXG4gICAgICAgIGxldCBzY29yZSA9IHBkZmgoaXQsICcubm9TY29yZSYmVGV4dCcpO1xcXFxuICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgdGl0bGU6IHdyYXAobmFtZSwgcyksXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ21vdmllXzFfdmVydGljYWxfcGljJyxcXFxcbiAgICAgICAgICAgIGltZzogaW1nLFxcXFxuICAgICAgICAgICAgZGVzYzogJ+ivhOWIhjonICsgc2NvcmUgKyAnXFxcXFxcXFxuJyArIGRlc2MsXFxcXG4gICAgICAgICAgICB1cmw6ICQodXJsKS5sYXp5UnVsZSgocnVsZSwgdXJsLCBzKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgdmFyIGNscyA9IGZpbmRJdGVtc0J5Q2xzKHVybCk7XFxcXG4gICAgICAgICAgICAgICAgaWYgKCEhY2xzKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZUl0ZW1CeUNscyh1cmwpXFxcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IHVybCA9IGlucHV0O1xcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgaWQgPSB1cmw7XFxcXG4gICAgICAgICAgICAgICAgICAgIGxldCBodG1sID0gZmV0Y2godXJsKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpc3QgPSBwZGZhKGh0bWwsICcubW92aWVaeSYmYScpXFxcXG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ICYmIGxpc3QubGVuZ3RoID4gMCkge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNWV9VUkwgPSBcXFxcXFxcIlxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS90b29sP3J1bGU9XFxcXFxcXCIgKyBydWxlKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ID0gbGlzdC5tYXAoaXQgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IHBkZmgoaXQsICdhJiZocmVmJyk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ID0gcGRmaChpdCwgJ3VsJiZUZXh0Jyk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUgPSBcXFxcXFxcImhpa2VyOi8vcGFnZS9wP3J1bGU9XFxcXFxcXCIgKyBydWxlICsgXFxcXFxcXCImdT1cXFxcXFxcIiArIGJhc2U2NEVuY29kZSh1KTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdSA9IGdldEl0ZW0oJ2FpJywgJzAnKSA9PSAnMCcgPyB1IDogdSArICcjaW1tZXJzaXZlVGhlbWUjJ1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IG1lcmdlKHQsICfor6bmg4UnLCAxKSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltZzogJ2h0dHBzOi8vd3d3LjcyNTk5OC5jb20vc3RhdGljL3NlYXJjaC9pbWFnZXMvb25MaW5lLnBuZycsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJhdmF0YXJcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5oZXJpdFRpdGxlOiBmYWxzZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbHM6IHVybCxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiAnaG9tZScsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRJdGVtQWZ0ZXIoaWQsIGxpc3QpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZyhlLnRvU3RyaW5nKCkpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkSXRlbUFmdGVyKGlkLCB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICfml6DotYTmupAnLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMScsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xzOiB1cmwsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCJcXFxcbiAgICAgICAgICAgIH0sIE1ZX1JVTEUudGl0bGUsIHVybCwgcyksXFxcXG4gICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgIGlkOiB1cmwsXFxcXG4gICAgICAgICAgICAgICAgaW5oZXJpdFRpdGxlOiBmYWxzZVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9KVxcXFxuICAgIH1cXFxcblxcXFxuICAgIHNldFJlc3VsdChkKVxcXFxufSBlbHNlIHtcXFxcblxcXFxufVxcXFxuXFxcXG5pZiAoZ2V0SXRlbSgnaG9tZScsICflhbMnKSA9PSAn5byAJykge1xcXFxuICAgIGZ1bmN0aW9uIHNldExpc3RzKGl0ZW0pIHtcXFxcbiAgICAgICAgTVlfVVJMID0gJ2h0dHBzOi8vd3d3LjcyNTk5OC5jb20vJztcXFxcbiAgICAgICAgdmFyIHRpdGxlID0gaXRlbS5zcGxpdCgnIycpWzBdXFxcXG4gICAgICAgIHZhciBrZXkgPSBpdGVtLnNwbGl0KCcjJylbMV1cXFxcbiAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiAnYXZhdGFyJyxcXFxcbiAgICAgICAgICAgIGltZzogJ2h0dHBzOi8vbGFubWVpZ3VvamlhbmcuY29tL3R1Ymlhby9tb3JlLzEwLnBuZydcXFxcbiAgICAgICAgfSlcXFxcblxcXFxuICAgICAgICB2YXIgaHRtbCA9IGZldGNoKGBodHRwczovL3d3dy43MjU5OTguY29tL3lpbmdrdS1saXN0LyR7a2V5fS0wLTAtMC0wLTAtMC5odG1sYClcXFxcbiAgICAgICAgdmFyIGxpc3QgPSBwZGZhKGh0bWwsICdib2R5JiYuZWFjaCcpXFxcXG5cXFxcbiAgICAgICAgbGlzdC5tYXAoeCA9PiB7XFxcXG4gICAgICAgICAgICB2YXIgbmFtZSA9IHBkZmgoeCwgJ2EmJnRpdGxlJylcXFxcbiAgICAgICAgICAgIGxldCBpbWcgPSBwZCh4LCAnaW1nJiZzcmMnKTtcXFxcbiAgICAgICAgICAgIGlmIChpbWcgPT0gXFxcXFxcXCJcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgICAgIGltZyA9IFxcXFxcXFwiaHR0cHM6Ly93d3cuNzI1OTk4LmNvbS9zdGF0aWMvc2VhcmNoL2ltYWdlcy9wcmVsb2FkSW1nLnBuZ1xcXFxcXFwiO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgbGV0IHVybCA9IHBkKHgsICdhJiZocmVmJyk7XFxcXG4gICAgICAgICAgICBsZXQgc2NvcmUgPSBwZGZoKHgsICcubm9TY29yZSYmVGV4dCcpO1xcXFxuICAgICAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogbmFtZSxcXFxcbiAgICAgICAgICAgICAgICBpbWc6IGltZyxcXFxcbiAgICAgICAgICAgICAgICBkZXNjOiBzY29yZSxcXFxcbiAgICAgICAgICAgICAgICB1cmw6ICQoJycpLmxhenlSdWxlKChuLCB1KSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwic291XFxcXFxcXCIsIG4pXFxcXG4gICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKCdkdXJsJywgdSlcXFxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKVxcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXG4gICAgICAgICAgICAgICAgfSwgbmFtZSwgdXJsKVxcXFxuICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgfSlcXFxcbiAgICB9XFxcXG5cXFxcbiAgICBbJ+eUteW9sSMxJywgJ+eUteinhuWJpyMyJywgJ+WKqOa8qyMzJywgJ+e6quW9leeJhyM0J10ubWFwKHggPT4ge1xcXFxuXFxcXG4gICAgICAgIHNldExpc3RzKHgpXFxcXG4gICAgfSlcXFxcbn1cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCI2LueUteW9seeLl1xcXCIsXFxcInBhdGhcXFwiOlxcXCJkeWRvZ1xcXCIsXFxcInJ1bGVcXFwiOlxcXCJqczpcXFxcbk1ZX1VSTD0naHR0cHM6Ly93d3cuZGlhbnlpbmdnb3UuY29tL3NvTW9yZS9hbGwtYWxsLWFsbC1hbGwtJztcXFxcbmxldCBkdXJsID0gZ2V0TXlWYXIoXFxcXFxcXCJkdXJsXFxcXFxcXCIsIFxcXFxcXFwiXFxcXFxcXCIpO1xcXFxuaWYgKGR1cmwgIT0gJycpIHtcXFxcbiAgICAvL2xvZyhkdXJsKVxcXFxuXFxcXG4gICAgbGV0IHVybCA9IGR1cmw7XFxcXG4gICAgbGV0IGlkID0gdXJsO1xcXFxuICAgIGxldCBuYW1lID0gcztcXFxcbiAgICB0cnkge1xcXFxuICAgICAgICB2YXIgaHRtbCA9IGZldGNoKHVybCk7XFxcXG4gICAgfSBjYXRjaCB7XFxcXG4gICAgICAgIHZhciBodG1sID0gJydcXFxcbiAgICB9XFxcXG4gICAgdmFyIHJ1bGUgPSBNWV9SVUxFLnRpdGxlXFxcXG5cXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogcGRmaChodG1sLCAnaDQmJlRleHQnKSxcXFxcbiAgICAgICAgaW1nOiBwZGZoKGh0bWwsICdpbWcmJmRhdGEtdXJsJyksXFxcXG4gICAgICAgIGNvbF90eXBlOiAnbW92aWVfMV92ZXJ0aWNhbF9waWMnLFxcXFxuICAgICAgICBkZXNjOiBwZGZoKGh0bWwsICdib2R5JiYucHViVGltZSYmVGV4dCcpLFxcXFxuICAgICAgICB1cmw6IHVybCxcXFxcbiAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgIGlkOiB1cmwsXFxcXG4gICAgICAgICAgICBpbmhlcml0VGl0bGU6IGZhbHNlXFxcXG4gICAgICAgIH1cXFxcbiAgICB9KVxcXFxuXFxcXG4gICAgbGV0IGh0bWwgPSBmZXRjaChgaHR0cHM6Ly93d3cuZGlhbnlpbmdnb3UuY29tL1NwaWRlck1vdmllL3p5LyR7bmFtZX1gLCB7XFxcXG4gICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICd4LXJlcXVlc3RlZC13aXRoJzogJ1hNTEh0dHBSZXF1ZXN0J1xcXFxuICAgICAgICB9XFxcXG4gICAgfSk7XFxcXG5cXFxcbiAgICB2YXIgbGlzdCA9IHBkZmEoaHRtbCwgJy5tb3ZpZVp5JiZhJylcXFxcbiAgICBpZiAobGlzdCAmJiBsaXN0Lmxlbmd0aCA+IDApIHtcXFxcbiAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICAgIE1ZX1VSTCA9IFxcXFxcXFwiXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICBsZXQge1xcXFxuICAgICAgICAgICAgICAgIHdyYXAxXFxcXG4gICAgICAgICAgICB9ID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3Rvb2w/cnVsZT1cXFxcXFxcIiArIHJ1bGUpO1xcXFxuICAgICAgICAgICAgXFxcXG4gICAgICAgICAgICBsaXN0ID0gbGlzdC5tYXAoaXQgPT4ge1xcXFxuICAgICAgICAgICAgICAgIGxldCB1ID0gcGRmaChpdCwgJ2EmJmhyZWYnKTtcXFxcbiAgICAgICAgICAgICAgICBsZXQgdCA9IHBkZmgoaXQsICdsaSwwJiZUZXh0Jyk7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHdlYj1wZGZoKGl0LCAnbGksMSYmVGV4dCcpO1xcXFxuICAgICAgICAgICAgICAgIHUgPSBcXFxcXFxcImhpa2VyOi8vcGFnZS9wP3J1bGU9XFxcXFxcXCIgKyBydWxlICsgXFxcXFxcXCImdT1cXFxcXFxcIiArIGJhc2U2NEVuY29kZSh1KTtcXFxcbiAgICAgICAgICAgICAgICB1ID0gZ2V0SXRlbSgnYWknLCAnMCcpID09ICcwJyA/IHUgOiB1ICsgJyNpbW1lcnNpdmVUaGVtZSMnXFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHdyYXAxKHdlYisnLScrdCwgcyksXFxcXG4gICAgICAgICAgICAgICAgICAgIGltZzogJ2h0dHBzOi8vd3d3LjcyNTk5OC5jb20vc3RhdGljL3NlYXJjaC9pbWFnZXMvb25MaW5lLnBuZycsXFxcXG4gICAgICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImF2YXRhclxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHUsXFxcXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmhlcml0VGl0bGU6IGZhbHNlLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xzOiB1cmwsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlVGl0bGU6dCxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlYjp3ZWIsXFxcXG4gICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgIGQgPSBkLmNvbmNhdChsaXN0KVxcXFxuICAgICAgICB9IGNhdGNoIChlKSB7XFxcXG4gICAgICAgICAgICBsb2coZS50b1N0cmluZygpKTtcXFxcbiAgICAgICAgfVxcXFxuICAgIH1cXFxcbiAgICBzZXRSZXN1bHQoZClcXFxcbn1cXFxcbnMgPSBnZXRNeVZhcihcXFxcXFxcInNvdVxcXFxcXFwiLCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbmxldCByID0gXFxcXFxcXCJcXFxcXFxcIjtcXFxcbmlmIChzICE9IFxcXFxcXFwiXFxcXFxcXCIpIHtcXFxcbiAgICB2YXIgcGFnZSA9IE1ZX1BBR0U7XFxcXG4gICAgdmFyIHVybCA9IGBodHRwczovL3d3dy5kaWFueWluZ2dvdS5jb20vc28vJHtzfS9wYWdlXyR7cGFnZX0uaHRtbGA7XFxcXG4gICAgLy9sb2codXJsKVxcXFxuICAgIHZhciBodG1sID0gZmV0Y2godXJsKVxcXFxuXFxcXG4gICAgdmFyIGxpc3QgPSBwZGZhKGh0bWwsICdib2R5JiYuZWFjaCcpXFxcXG4gICAgLy9sb2cobGlzdClcXFxcblxcXFxuICAgIGxldCB7XFxcXG4gICAgICAgIHdyYXBcXFxcbiAgICB9ID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3Rvb2xcXFxcXFxcIik7XFxcXG5cXFxcbiAgICBmb3IgKGxldCBpdCBvZiBsaXN0KSB7XFxcXG4gICAgICAgIGxldCBuYW1lID0gcGRmaChpdCwgJ2EmJnRpdGxlJyk7XFxcXG4gICAgICAgIGxldCBpbWcgPSBwZChpdCwgJ2ltZyYmZGF0YS11cmwnKTtcXFxcbiAgICAgICAgaWYgKGltZyA9PSBcXFxcXFxcIlxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICBpbWcgPSBcXFxcXFxcImh0dHBzOi8vd3d3LmRpYW55aW5nZ291LmNvbS9WaWV3L2ltYWdlcy9ibGFua19iZy5wbmdcXFxcXFxcIjtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBsZXQgdXJsID0gcGQoaXQsICdhJiZocmVmJyk7XFxcXG4gICAgICAgIGxldCBkZXNjID0gcGRmYShpdCwgJ2JvZHkmJi5pbmZvJiZhJykubWFwKHggPT4gcGRmaCh4LCAnYSYmVGV4dCcpKS5qb2luKCcgJyk7XFxcXG4gICAgICAgIGxldCBzY29yZSA9IHBkZmgoaXQsICcubm9TY29yZSYmVGV4dCcpO1xcXFxuICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgdGl0bGU6IHdyYXAobmFtZSwgcyksXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ21vdmllXzFfdmVydGljYWxfcGljJyxcXFxcbiAgICAgICAgICAgIGltZzogaW1nLFxcXFxuICAgICAgICAgICAgZGVzYzogJ+ivhOWIhjonICsgc2NvcmUgKyAnXFxcXFxcXFxuJyArIGRlc2MsXFxcXG4gICAgICAgICAgICB1cmw6ICQodXJsKS5sYXp5UnVsZSgocnVsZSwgdXJsLCBzLCBuYW1lKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgdmFyIGNscyA9IGZpbmRJdGVtc0J5Q2xzKHVybCk7XFxcXG4gICAgICAgICAgICAgICAgaWYgKCEhY2xzKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZUl0ZW1CeUNscyh1cmwpXFxcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IHVybCA9IGlucHV0O1xcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgaWQgPSB1cmw7XFxcXG4gICAgICAgICAgICAgICAgICAgIGxldCBodG1sID0gZmV0Y2goYGh0dHBzOi8vd3d3LmRpYW55aW5nZ291LmNvbS9TcGlkZXJNb3ZpZS96eS8ke25hbWV9YCwge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd4LXJlcXVlc3RlZC13aXRoJzogJ1hNTEh0dHBSZXF1ZXN0J1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpc3QgPSBwZGZhKGh0bWwsICcubW92aWVaeSYmYScpXFxcXG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ICYmIGxpc3QubGVuZ3RoID4gMCkge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNWV9VUkwgPSBcXFxcXFxcIlxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyYXAxXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS90b29sP3J1bGU9XFxcXFxcXCIgKyBydWxlKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ID0gbGlzdC5tYXAoaXQgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IHBkZmgoaXQsICdhJiZocmVmJyk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ID0gcGRmaChpdCwgJ2xpLDAmJlRleHQnKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHdlYj1wZGZoKGl0LCAnbGksMSYmVGV4dCcpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ID0gXFxcXFxcXCJoaWtlcjovL3BhZ2UvcD9ydWxlPVxcXFxcXFwiICsgcnVsZSArIFxcXFxcXFwiJnU9XFxcXFxcXCIgKyBiYXNlNjRFbmNvZGUodSk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUgPSBnZXRJdGVtKCdhaScsICcwJykgPT0gJzAnID8gdSA6IHUgKyAnI2ltbWVyc2l2ZVRoZW1lIydcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiB3cmFwMSh3ZWIrJy0nK3QsIHMpLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1nOiAnaHR0cHM6Ly93d3cuNzI1OTk4LmNvbS9zdGF0aWMvc2VhcmNoL2ltYWdlcy9vbkxpbmUucG5nJyxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImF2YXRhclxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1LFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmhlcml0VGl0bGU6IGZhbHNlLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsczogdXJsLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VUaXRsZTp0LFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlYjp3ZWIsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRJdGVtQWZ0ZXIoaWQsIGxpc3QpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZyhlLnRvU3RyaW5nKCkpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIlxcXFxuICAgICAgICAgICAgfSwgTVlfUlVMRS50aXRsZSwgdXJsLCBzLCBuYW1lKSxcXFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgaWQ6IHVybCxcXFxcbiAgICAgICAgICAgICAgICBpbmhlcml0VGl0bGU6IGZhbHNlXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0pXFxcXG4gICAgfVxcXFxuXFxcXG4gICAgc2V0UmVzdWx0KGQpXFxcXG59IGVsc2Uge1xcXFxuXFxcXG59XFxcXG5cXFxcbmlmIChnZXRJdGVtKCdob21lJywgJ+WFsycpID09ICflvIAnKSB7XFxcXG4gICAgZnVuY3Rpb24gc2V0TGlzdHMoaXRlbSkge1xcXFxuICAgICAgICBNWV9VUkwgPSAnaHR0cHM6Ly93d3cuZGlhbnlpbmdnb3UuY29tLyc7XFxcXG4gICAgICAgIHZhciB0aXRsZSA9IGl0ZW0uc3BsaXQoJyMnKVswXVxcXFxuICAgICAgICB2YXIga2V5ID0gaXRlbS5zcGxpdCgnIycpWzFdXFxcXG4gICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZTogdGl0bGUsXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ2F2YXRhcicsXFxcXG4gICAgICAgICAgICBpbWc6ICdodHRwczovL2xhbm1laWd1b2ppYW5nLmNvbS90dWJpYW8vbW9yZS8xMC5wbmcnXFxcXG4gICAgICAgIH0pXFxcXG5cXFxcbiAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xcXFxuICAgICAgICB2YXIgeWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcXFxcbiAgICAgICAgLy92YXIgaHRtbCA9IGZldGNoKGBodHRwczovL3d3dy5kaWFueWluZ2dvdS5jb20vbVJlY29tbWQvJHtrZXl9YCk7XFxcXG4gICAgICAgIHZhciBodG1sID0gZmV0Y2goYGh0dHBzOi8vd3d3LmRpYW55aW5nZ291LmNvbS9zb01vcmUvJHtrZXl9LWFsbC1hbGwtJHt5ZWFyfS1gKTtcXFxcblxcXFxuICAgICAgICB2YXIgbGlzdCA9IHBkZmEoaHRtbCwgJ2JvZHkmJi5lYWNoJylcXFxcblxcXFxuICAgICAgICBsaXN0Lm1hcCh4ID0+IHtcXFxcbiAgICAgICAgICAgIHZhciBuYW1lID0gcGRmaCh4LCAnYSYmdGl0bGUnKVxcXFxuICAgICAgICAgICAgbGV0IGltZyA9IHBkKHgsICdpbWcmJmRhdGEtdXJsJyk7XFxcXG4gICAgICAgICAgICBpZiAoaW1nID09IFxcXFxcXFwiXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgICAgICBpbWcgPSBcXFxcXFxcImh0dHBzOi8vd3d3LmRpYW55aW5nZ291LmNvbS9WaWV3L2ltYWdlcy9ibGFua19iZy5wbmdcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIGxldCB1cmwgPSBwZCh4LCAnYSYmaHJlZicpO1xcXFxuICAgICAgICAgICAgbGV0IHNjb3JlID0gcGRmaCh4LCAnLm5vU2NvcmUmJlRleHQnKTtcXFxcbiAgICAgICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IG5hbWUsXFxcXG4gICAgICAgICAgICAgICAgaW1nOiBpbWcsXFxcXG4gICAgICAgICAgICAgICAgZGVzYzogc2NvcmUsXFxcXG4gICAgICAgICAgICAgICAgdXJsOiAkKCcnKS5sYXp5UnVsZSgobiwgdSkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFxcXFxcInNvdVxcXFxcXFwiLCBuKVxcXFxuICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcignZHVybCcsIHUpXFxcXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKClcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcXFxuICAgICAgICAgICAgICAgIH0sIG5hbWUsIHVybClcXFxcbiAgICAgICAgICAgIH0pXFxcXG4gICAgICAgIH0pXFxcXG4gICAgfVxcXFxuXFxcXG4gICAgZnVuY3Rpb24gaG9tZSgpIHtcXFxcbiAgICAgICAgWyfnlLXlvbEjbW92aWUnLCAn55S16KeG5YmnI3R2JywgJ+e6quW9leeJhyNkb2MnLCAn5Yqo5ryrI2NvbWljJ10ubWFwKHggPT4ge1xcXFxuXFxcXG4gICAgICAgICAgICBzZXRMaXN0cyh4KVxcXFxuICAgICAgICB9KVxcXFxuICAgIH1cXFxcbiAgICBcXFxcbiAgICB2YXIgcGFnZT1NWV9QQUdFO1xcXFxuICAgIGxldCB0cnVlX3VybCA9IGdldE15VmFyKE1ZX1JVTEUudXJsLCBNWV9VUkwpO1xcXFxuICAgIGlmKHBhZ2U+MSl7XFxcXG4gICAgICAgIC8vbG9nKHRydWVfdXJsKVxcXFxuICAgICAgICB0cnVlX3VybD10cnVlX3VybCtgL3BhZ2VfJHtwYWdlfS5odG1sYFxcXFxuICAgICAgICAvL2xvZyh0cnVlX3VybClcXFxcbiAgICB9XFxcXG4gICAgdmFyIGh0bWwgPWZldGNoKHRydWVfdXJsKS5yZXBsYWNlKCclJywnJyk7XFxcXG4gICAgLy9sb2coaHRtbClcXFxcbiAgICBcXFxcbiAgICBcXFxcbiAgICBjb25zdCDliIbnsbvpopzoibIgPSBnZXRSYW5nZUNvbG9ycygpO1xcXFxuICAgIGNvbnN0IOWkp+exu+WumuS9jSA9ICcud18xMDAnO1xcXFxuICAgIGNvbnN0IOaLvOaOpeWIhuexuyA9ICdib2R5JiYueV9maWx0ZXJNZW51Om50aC1jaGlsZChuKzIpPmRpdj5kaXYnO1xcXFxuICAgIGNvbnN0IOWwj+exu+WumuS9jSA9ICdib2R5JiZhOm5vdCg6bWF0Y2hlcyjliIbnsbspKSc7XFxcXG4gICAgY29uc3Qg5YiG57G75qCH6aKYID0gJ2EmJlRleHQnO1xcXFxuICAgIGNvbnN0IOWIhuexu+mTvuaOpSA9ICdhJiZocmVmJztcXFxcblxcXFxuICAgIC8v5Yqo5oCB5YiG57G7XFxcXG4gICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9kdGZsJykpLnJ1bGUpO1xcXFxuICAgIFxcXFxuICAgIHZhciBsaXN0ID0gcGRmYShodG1sLCAnYm9keSYmLmVhY2gnKVxcXFxuXFxcXG4gICAgbGlzdC5tYXAoeCA9PiB7XFxcXG4gICAgICAgIHZhciBuYW1lID0gcGRmaCh4LCAnYSYmdGl0bGUnKVxcXFxuICAgICAgICBsZXQgaW1nID0gcGQoeCwgJ2ltZyYmc3JjfHxpbWcmJmRhdGEtdXJsJyk7XFxcXG4gICAgICAgIGlmIChpbWcgPT0gXFxcXFxcXCJcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgaW1nID0gXFxcXFxcXCJodHRwczovL3d3dy5kaWFueWluZ2dvdS5jb20vVmlldy9pbWFnZXMvYmxhbmtfYmcucG5nXFxcXFxcXCI7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgbGV0IHVybCA9IHBkKHgsICdhJiZocmVmJyk7XFxcXG4gICAgICAgIGxldCBzY29yZSA9IHBkZmgoeCwgJy5ub1Njb3JlJiZUZXh0Jyk7XFxcXG4gICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZTogbmFtZSxcXFxcbiAgICAgICAgICAgIGltZzogaW1nLFxcXFxuICAgICAgICAgICAgZGVzYzogc2NvcmUsXFxcXG4gICAgICAgICAgICB1cmw6ICQoJycpLmxhenlSdWxlKChuLCB1KSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCJzb3VcXFxcXFxcIiwgbilcXFxcbiAgICAgICAgICAgICAgICBwdXRNeVZhcignZHVybCcsIHUpXFxcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKVxcXFxuICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXFxcbiAgICAgICAgICAgIH0sIG5hbWUsIHVybClcXFxcbiAgICAgICAgfSlcXFxcbiAgICB9KVxcXFxufVxcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIuWKqOaAgeWIhuexu1xcXCIsXFxcInBhdGhcXFwiOlxcXCJkdGZsXFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxuY29uc3TCoGVtcHR5wqA9wqBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIlxcXFxuXFxcXG5pZsKgKHR5cGVvZijmi7zmjqXliIbnsbspwqAhPcKgJ3VuZGVmaW5lZCfCoCYmwqDmi7zmjqXliIbnsbvCoCE9wqAnJynCoHtcXFxcbsKgwqDCoMKgdmFywqBjYXRlZ29yaWVzwqA9wqBwZGZhKGh0bWwswqDlpKfnsbvlrprkvY0pLmNvbmNhdChwZGZhKGh0bWwswqDmi7zmjqXliIbnsbspKVxcXFxufcKgZWxzZcKge1xcXFxuwqDCoMKgwqB2YXLCoGNhdGVnb3JpZXPCoD3CoHBkZmEoaHRtbCzCoOWkp+exu+WumuS9jSlcXFxcbn1cXFxcblxcXFxubGV0wqBpbml0X2NhdGXCoD3CoFtdXFxcXG5cXFxcbmZvciAobGV0IGkgPSAwOyBpIDwgMjA7IGkrKykge1xcXFxuICAgIGluaXRfY2F0ZS5wdXNoKFxcXFxcXFwiMFxcXFxcXFwiKVxcXFxufVxcXFxuXFxcXG5jb25zdMKgZm9sZMKgPcKgZ2V0TXlWYXIoTVlfUlVMRS5ncm91cCzCoFxcXFxcXFwiMFxcXFxcXFwiKVxcXFxuY29uc3TCoGNhdGVfdGVtcF9qc29uwqA9wqBnZXRNeVZhcihNWV9SVUxFLnRpdGxlLMKgSlNPTi5zdHJpbmdpZnkoaW5pdF9jYXRlKSlcXFxcbmNvbnN0wqBjYXRlX3RlbXDCoD3CoEpTT04ucGFyc2UoY2F0ZV90ZW1wX2pzb24pXFxcXG5cXFxcblxcXFxuXFxcXG5pZsKgKHBhcnNlSW50KHBhZ2UpwqA9PT3CoDEpwqB7XFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICBjb2xfdHlwZTonYmlnX2JsYW5rX2Jsb2NrJ1xcXFxuICAgIH0pXFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICBjb2xfdHlwZTonYmlnX2JsYW5rX2Jsb2NrJ1xcXFxuICAgIH0pXFxcXG4gICAgXFxcXG7CoMKgwqDCoGQucHVzaCh7XFxcXG7CoMKgwqDCoMKgwqDCoMKgdGl0bGU6wqBmb2xkwqA9PT3CoCcxJ8KgP8KgJ+KAnOKAnOKAneKAnTxiPifCoCvCoCdXJy5mb250Y29sb3IoXFxcXFxcXCIjRkYwMDAwXFxcXFxcXCIpwqArwqAnPC9iPifCoDrCoCfigJzigJzigJ3igJ08Yj4nwqArwqAnTScuZm9udGNvbG9yKFxcXFxcXFwiIzFhYWQxOVxcXFxcXFwiKcKgK8KgJzwvYj4nLFxcXFxuwqDCoMKgwqDCoMKgwqDCoHVybDrCoCQoKS5sYXp5UnVsZSgoZm9sZCnCoD0+wqB7XFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBwdXRNeVZhcihNWV9SVUxFLmdyb3VwLMKgZm9sZMKgPT09wqAnMSfCoD/CoCcwJ8KgOsKgJzEnKTtcXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoHJlZnJlc2hQYWdlKGZhbHNlKTtcXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoHJldHVybsKgXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCJcXFxcbsKgwqDCoMKgwqDCoMKgwqB9LMKgZm9sZCksXFxcXG7CoMKgwqDCoMKgwqDCoMKgY29sX3R5cGU6wqAnc2Nyb2xsX2J1dHRvbicsXFxcXG7CoMKgwqDCoH0pXFxcXG7CoMKgwqDCoGNhdGVnb3JpZXMuZm9yRWFjaCgoY2F0ZWdvcnkswqBpbmRleCnCoD0+wqB7XFxcXG7CoMKgwqDCoMKgwqDCoMKgbGV0wqBzdWJfY2F0ZWdvcmllc8KgPcKgcGRmYShjYXRlZ29yeSzCoOWwj+exu+WumuS9jSk7XFxcXG7CoMKgwqDCoMKgwqDCoMKgaWbCoChpbmRleMKgPT09wqAwKcKge1xcXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgc3ViX2NhdGVnb3JpZXMuZm9yRWFjaCgoaXRlbSzCoGtleSnCoD0+wqB7XFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGxldMKgdGl0bGXCoD3CoHBkZmgoaXRlbSzCoOWIhuexu+agh+mimClcXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgaWbCoCh0eXBlb2Yo5o6S6ZmkKcKgIT3CoCd1bmRlZmluZWQnwqAmJsKg5o6S6ZmkwqAhPcKgJycpwqB7XFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgdGl0bGXCoD3CoHRpdGxlLnJlcGxhY2UobmV3wqBSZWdFeHAo5o6S6ZmkLMKgXFxcXFxcXCJnXFxcXFxcXCIpLMKgXFxcXFxcXCJcXFxcXFxcIilcXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgfVxcXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBkLnB1c2goe1xcXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoHRpdGxlOsKga2V5LnRvU3RyaW5nKCnCoD09PcKgY2F0ZV90ZW1wW2luZGV4XcKgP8KgXFxcXFxcXCLigJzigJzigJ3igJ1cXFxcXFxcIsKgK8KgdGl0bGUuZm9udGNvbG9yKOWIhuexu+minOiJsinCoDrCoHRpdGxlLFxcXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoHVybDrCoCQocGQoaXRlbSzCoOWIhuexu+mTvuaOpSnCoCvCoCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChwYXJhbXMpwqA9PsKge1xcXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgbGV0wqBuZXdfY2F0ZcKgPcKgW11cXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoHBhcmFtcy5jYXRlX3RlbXAuZm9yRWFjaCgoY2F0ZSzCoGluZGV4KcKgPT7CoHtcXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgbmV3X2NhdGUucHVzaChpbmRleMKgPT09wqAwwqA/wqBwYXJhbXMua2V5LnRvU3RyaW5nKCnCoDrCoFxcXFxcXFwiMFxcXFxcXFwiKVxcXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgfSlcXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoHB1dE15VmFyKE1ZX1JVTEUudGl0bGUswqBKU09OLnN0cmluZ2lmeShuZXdfY2F0ZSkpXFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBwdXRNeVZhcihNWV9SVUxFLnVybCzCoGlucHV0KVxcXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgcmVmcmVzaFBhZ2UodHJ1ZSlcXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoHJldHVybsKgXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCJcXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB9LMKge1xcXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgY2F0ZV90ZW1wOsKgY2F0ZV90ZW1wLFxcXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKga2V5OsKga2V5LFxcXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgcGFnZTrCoHBhZ2UsXFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgfSksXFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgY29sX3R5cGU6wqAnc2Nyb2xsX2J1dHRvbicsXFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoH0pXFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB9KVxcXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgZC5wdXNoKHtcXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgY29sX3R5cGU6wqBcXFxcXFxcImJsYW5rX2Jsb2NrXFxcXFxcXCJcXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoH0pO1xcXFxuwqDCoMKgwqDCoMKgwqDCoH3CoGVsc2XCoGlmwqAoZm9sZMKgPT09wqAnMScpwqB7XFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBzdWJfY2F0ZWdvcmllcy5mb3JFYWNoKChpdGVtLMKga2V5KcKgPT7CoHtcXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgbGV0wqB0aXRsZcKgPcKgcGRmaChpdGVtLMKg5YiG57G75qCH6aKYKVxcXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBpZsKgKHR5cGVvZijmjpLpmaQpwqAhPcKgJ3VuZGVmaW5lZCfCoCYmwqDmjpLpmaTCoCE9wqAnJynCoHtcXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB0aXRsZcKgPcKgdGl0bGUucmVwbGFjZShuZXfCoFJlZ0V4cCjmjpLpmaQswqBcXFxcXFxcImdcXFxcXFxcIikswqBcXFxcXFxcIlxcXFxcXFwiKVxcXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB9XFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGQucHVzaCh7XFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgdGl0bGU6wqBrZXkudG9TdHJpbmcoKcKgPT09wqBjYXRlX3RlbXBbaW5kZXhdwqA/wqBcXFxcXFxcIuKAnOKAnOKAneKAnVxcXFxcXFwiwqArwqB0aXRsZS5mb250Y29sb3Io5YiG57G76aKc6ImyKcKgOsKgdGl0bGUsXFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgdXJsOsKgJChwZChpdGVtLMKg5YiG57G76ZO+5o6lKcKgK8KgJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKHBhcmFtcynCoD0+wqB7XFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBwYXJhbXMuY2F0ZV90ZW1wW3BhcmFtcy5pbmRleF3CoD3CoHBhcmFtcy5rZXkudG9TdHJpbmcoKVxcXFxuXFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBwdXRNeVZhcihNWV9SVUxFLnRpdGxlLMKgSlNPTi5zdHJpbmdpZnkocGFyYW1zLmNhdGVfdGVtcCkpXFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBwdXRNeVZhcihNWV9SVUxFLnVybCzCoGlucHV0KVxcXFxuXFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqByZWZyZXNoUGFnZSh0cnVlKVxcXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgcmV0dXJuwqBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIlxcXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoH0swqB7XFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBjYXRlX3RlbXA6wqBjYXRlX3RlbXAsXFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBpbmRleDrCoGluZGV4LFxcXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKga2V5OsKga2V5LFxcXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgcGFnZTrCoHBhZ2UsXFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgfSksXFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgY29sX3R5cGU6wqAnc2Nyb2xsX2J1dHRvbicsXFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoH0pXFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB9KVxcXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgZC5wdXNoKHtcXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgY29sX3R5cGU6wqBcXFxcXFxcImJsYW5rX2Jsb2NrXFxcXFxcXCJcXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoH0pO1xcXFxuwqDCoMKgwqDCoMKgwqDCoH1cXFxcbsKgwqDCoMKgfSlcXFxcbn1cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCI3LuWcn+aLqOm8oFxcXCIsXFxcInBhdGhcXFwiOlxcXCJ0YnNkeVxcXCIsXFxcInJ1bGVcXFwiOlxcXCJqczpcXFxcbmxldCBkdXJsID0gZ2V0TXlWYXIoXFxcXFxcXCJkdXJsXFxcXFxcXCIsIFxcXFxcXFwiXFxcXFxcXCIpO1xcXFxuaWYgKGR1cmwgIT0gJycpIHtcXFxcbiAgICBNWV9VUkwgPSBkdXJsO1xcXFxuICAgIC8vbG9nKGR1cmwpXFxcXG5cXFxcbiAgICBsZXQgdXJsID0gZHVybDtcXFxcbiAgICBsZXQgaWQgPSB1cmw7XFxcXG4gICAgbGV0IG5hbWUgPSBzO1xcXFxuICAgIHRyeSB7XFxcXG4gICAgICAgIHZhciBodG1sID0gZmV0Y2godXJsLCB7XFxcXG4gICAgICAgICAgICBoZWFkZXJzOiB7XFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJVc2VyLUFnZW50XFxcXFxcXCI6IFBDX1VBXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0pO1xcXFxuICAgIH0gY2F0Y2gge1xcXFxuICAgICAgICB2YXIgaHRtbCA9ICcnXFxcXG4gICAgfVxcXFxuXFxcXG4gICAgdmFyIHJ1bGUgPSBNWV9SVUxFLnRpdGxlXFxcXG4gICAgbGV0IGRlc2MgPSBwZGZoKGh0bWwsICcudmlkZW9fcGxvdF9pbmZvX2NvbnRlbnQmJlRleHQnKTtcXFxcbiAgICBsZXQgc2NvcmUgPSBwZGZoKGh0bWwsICcudmlkZW9fcG9pbnQmJlRleHQnKTtcXFxcblxcXFxuICAgIGQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiBwZGZoKGh0bWwsICcudmlkZW9faW5mb190aXRsZV90ZXh0JiZUZXh0JyksXFxcXG4gICAgICAgIGltZzogcGRmaChodG1sLCAnLnZpZGVvX2NvdmVyX2ltZ19ib3gmJmltZyYmZGF0YS11cmwnKSxcXFxcbiAgICAgICAgY29sX3R5cGU6ICdtb3ZpZV8xX3ZlcnRpY2FsX3BpYycsXFxcXG4gICAgICAgIGRlc2M6ICfor4TliIY6JyArIHNjb3JlICsgJ1xcXFxcXFxcbuS4u+a8lDonICsgZGVzYyxcXFxcbiAgICAgICAgdXJsOiB1cmwsXFxcXG4gICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICBpZDogdXJsLFxcXFxuICAgICAgICAgICAgaW5oZXJpdFRpdGxlOiBmYWxzZSxcXFxcbiAgICAgICAgfVxcXFxuICAgIH0pXFxcXG5cXFxcblxcXFxuICAgIHZhciBsaXN0ID0gcGRmYShodG1sLCAnYm9keSYmLnZpZGVvX2Rvd25sb2FkX2xpbmtfaXRlbScpXFxcXG4gICAgaWYgKGxpc3QgJiYgbGlzdC5sZW5ndGggPiAwKSB7XFxcXG4gICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICBsZXQge1xcXFxuICAgICAgICAgICAgICAgIHdyYXAxXFxcXG4gICAgICAgICAgICB9ID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3Rvb2w/cnVsZT1cXFxcXFxcIiArIHJ1bGUpO1xcXFxuXFxcXG4gICAgICAgICAgICBsaXN0ID0gbGlzdC5tYXAoaXQgPT4ge1xcXFxuICAgICAgICAgICAgICAgIGxldCB1ID0gcGRmaChpdCwgJ2EmJmhyZWYnKTtcXFxcbiAgICAgICAgICAgICAgICBsZXQgdCA9IHBkZmgoaXQsICcudmlkZW9fZG93bmxvYWRfbGlua19uYW1lX3RleHQmJlRleHQnKTtcXFxcbiAgICAgICAgICAgICAgICBsZXQgd2ViID0gcGRmaChpdCwgJy5yZXNvdXJjZV93ZWJzaXRlX25hbWUmJlRleHQnKTtcXFxcbiAgICAgICAgICAgICAgICBsZXQgaW1nID0gcGQoaXQsICcudmlkZW9fbGFiZWxzJiZpbWcmJnNyYycpO1xcXFxuXFxcXG4gICAgICAgICAgICAgICAgdSA9IFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3A/cnVsZT1cXFxcXFxcIiArIHJ1bGUgKyBcXFxcXFxcIiZ1PVxcXFxcXFwiICsgYmFzZTY0RW5jb2RlKHUpO1xcXFxuICAgICAgICAgICAgICAgIHUgPSBnZXRJdGVtKCdhaScsICcwJykgPT0gJzAnID8gdSA6IHUgKyAnI2ltbWVyc2l2ZVRoZW1lIydcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogd3JhcDEod2ViICsgJy0nICsgdCwgcyksXFxcXG4gICAgICAgICAgICAgICAgICAgIGltZzogaW1nLFxcXFxuICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJhdmF0YXJcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB1LFxcXFxuICAgICAgICAgICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5oZXJpdFRpdGxlOiBmYWxzZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsczogdXJsLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVRpdGxlOiB0LFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgd2ViOiB3ZWIsXFxcXG4gICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgIGQgPSBkLmNvbmNhdChsaXN0KVxcXFxuICAgICAgICB9IGNhdGNoIChlKSB7XFxcXG4gICAgICAgICAgICBsb2coZS50b1N0cmluZygpKTtcXFxcbiAgICAgICAgfVxcXFxuICAgIH1cXFxcbiAgICBzZXRSZXN1bHQoZClcXFxcbn1cXFxcbnMgPSBnZXRNeVZhcihcXFxcXFxcInNvdVxcXFxcXFwiLCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbmxldCByID0gXFxcXFxcXCJcXFxcXFxcIjtcXFxcbmlmIChzICE9IFxcXFxcXFwiXFxcXFxcXCIpIHtcXFxcbiAgICB2YXIgcGFnZSA9IE1ZX1BBR0U7XFxcXG4gICAgTVlfVVJMID0gYGh0dHBzOi8vd3d3LnRic2R5LmNvbS9zZWFyY2guaHRtbD9rZXl3b3JkPSR7c30mcGFnZWQ9JHtwYWdlfSZjYXRlZ29yeT1gO1xcXFxuICAgIC8vbG9nKE1ZX1VSTClcXFxcbiAgICBsZXQgaHRtbCA9IGZldGNoKE1ZX1VSTCwge1xcXFxuICAgICAgICBoZWFkZXJzOiB7XFxcXG4gICAgICAgICAgICBcXFxcXFxcIlVzZXItQWdlbnRcXFxcXFxcIjogUENfVUFcXFxcbiAgICAgICAgfVxcXFxuICAgIH0pO1xcXFxuXFxcXG4gICAgdmFyIGxpc3QgPSBwZGZhKGh0bWwsICdib2R5JiYuc2VhcmNoX3Jlc3VsdF9pdGVtJylcXFxcblxcXFxuICAgIGxldCB7XFxcXG4gICAgICAgIHdyYXBcXFxcbiAgICB9ID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3Rvb2xcXFxcXFxcIik7XFxcXG5cXFxcbiAgICBmb3IgKGxldCBpdCBvZiBsaXN0KSB7XFxcXG4gICAgICAgIGxldCBuYW1lID0gcGRmaChpdCwgJy5zZWFyY2hfcmVzdWx0X3RpdGxlJiZUZXh0Jyk7XFxcXG4gICAgICAgIGxldCBpbWcgPSBwZChpdCwgJ2ltZyYmc3JjJyk7XFxcXG4gICAgICAgIGlmIChpbWcgPT0gXFxcXFxcXCJcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgaW1nID0gXFxcXFxcXCJcXFxcXFxcIjtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBsZXQgdXJsID0gcGQoaXQsICdhJiZocmVmJyk7XFxcXG4gICAgICAgIGxldCBkZXNjID0gcGRmYShpdCwgJ2JvZHkmJi5zZWFyY2hfcmVzdWx0X2l0ZW0mJi5zZWFyY2hfcmVzdWx0X3N1Yl9pbmZvX2xpbmUmJi52aWRlb19hY3RvcicpLm1hcCh4ID0+IHBkZmgoeCwgJ3NwYW4mJlRleHQnKSkuam9pbignICcpO1xcXFxuICAgICAgICBsZXQgc2NvcmUgPSBwZGZoKGl0LCAnLnNlYXJjaF92aWRlb19pbWdfcG9pbnQmJlRleHQnKTtcXFxcbiAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiB3cmFwKG5hbWUsIHMpLFxcXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdtb3ZpZV8xX3ZlcnRpY2FsX3BpYycsXFxcXG4gICAgICAgICAgICBpbWc6IGltZyxcXFxcbiAgICAgICAgICAgIGRlc2M6ICfor4TliIY6JyArIHNjb3JlICsgJ1xcXFxcXFxcbuS4u+a8lDonICsgZGVzYyxcXFxcbiAgICAgICAgICAgIHVybDogJCh1cmwpLmxhenlSdWxlKChydWxlLCB1cmwsIHMsIG5hbWUpID0+IHtcXFxcblxcXFxuICAgICAgICAgICAgICAgIHZhciBjbHMgPSBmaW5kSXRlbXNCeUNscyh1cmwpO1xcXFxuICAgICAgICAgICAgICAgIGlmICghIWNscykge1xcXFxuICAgICAgICAgICAgICAgICAgICBkZWxldGVJdGVtQnlDbHModXJsKVxcXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGxldCB1cmwgPSBpbnB1dDtcXFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlkID0gdXJsO1xcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgaHRtbCA9IGZldGNoKHVybCwge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiVXNlci1BZ2VudFxcXFxcXFwiOiBQQ19VQVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICB9KTtcXFxcblxcXFxuICAgICAgICAgICAgICAgICAgICB2YXIgbGlzdCA9IHBkZmEoaHRtbCwgJ2JvZHkmJi52aWRlb19kb3dubG9hZF9saW5rX2l0ZW0nKVxcXFxuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdCAmJiBsaXN0Lmxlbmd0aCA+IDApIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTVlfVVJMID0gdXJsO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyYXAxXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS90b29sP3J1bGU9XFxcXFxcXCIgKyBydWxlKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ID0gbGlzdC5tYXAoaXQgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IHBkZmgoaXQsICdhJiZocmVmJyk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ID0gcGRmaChpdCwgJy52aWRlb19kb3dubG9hZF9saW5rX25hbWVfdGV4dCYmVGV4dCcpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgd2ViID0gcGRmaChpdCwgJy5yZXNvdXJjZV93ZWJzaXRlX25hbWUmJlRleHQnKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGltZyA9IHBkKGl0LCAnLnZpZGVvX2xhYmVscyYmaW1nJiZzcmMnKTtcXFxcblxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ID0gXFxcXFxcXCJoaWtlcjovL3BhZ2UvcD9ydWxlPVxcXFxcXFwiICsgcnVsZSArIFxcXFxcXFwiJnU9XFxcXFxcXCIgKyBiYXNlNjRFbmNvZGUodSk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUgPSBnZXRJdGVtKCdhaScsICcwJykgPT0gJzAnID8gdSA6IHUgKyAnI2ltbWVyc2l2ZVRoZW1lIydcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiB3cmFwMSh3ZWIgKyAnLScgKyB0LCBzKSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltZzogaW1nLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiYXZhdGFyXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHUsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaGVyaXRUaXRsZTogZmFsc2UsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xzOiB1cmwsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVRpdGxlOiB0LFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlYjogd2ViLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkSXRlbUFmdGVyKGlkLCBsaXN0KTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2coZS50b1N0cmluZygpKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCJcXFxcbiAgICAgICAgICAgIH0sIE1ZX1JVTEUudGl0bGUsIHVybCwgcywgbmFtZSksXFxcXG4gICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgIGlkOiB1cmwsXFxcXG4gICAgICAgICAgICAgICAgaW5oZXJpdFRpdGxlOiBmYWxzZVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9KVxcXFxuICAgIH1cXFxcblxcXFxuICAgIHNldFJlc3VsdChkKVxcXFxufSBlbHNlIHtcXFxcblxcXFxufVxcXFxuXFxcXG5pZiAoZ2V0SXRlbSgnaG9tZScsICflhbMnKSA9PSAn5byAJykge1xcXFxuICAgIGxldCBodG1sID0gZmV0Y2goJ2h0dHBzOi8vd3d3LnRic2R5LmNvbS8nLCB7XFxcXG4gICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgIFxcXFxcXFwiVXNlci1BZ2VudFxcXFxcXFwiOiBQQ19VQVxcXFxuICAgICAgICB9XFxcXG4gICAgfSk7XFxcXG5cXFxcbiAgICBmdW5jdGlvbiBzZXRMaXN0cyhpdGVtKSB7XFxcXG4gICAgICAgIE1ZX1VSTCA9ICdodHRwczovL3d3dy50YnNkeS5jb20vJztcXFxcbiAgICAgICAgdmFyIHRpdGxlID0gaXRlbS5uYW1lO1xcXFxuICAgICAgICB2YXIga2V5ID0gaXRlbS5zZWxlY3Q7XFxcXG4gICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZTogdGl0bGUsXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ2F2YXRhcicsXFxcXG4gICAgICAgICAgICBpbWc6IGl0ZW0uaW1nLFxcXFxuICAgICAgICB9KVxcXFxuXFxcXG4gICAgICAgIHZhciBsaXN0ID0gcGRmYShodG1sLCBgYm9keSYmLmNvbnRhaW5lcl9tYWluX2hvdF8ke2tleX0mJi5ob3RfcmVzb3VyY2Vfb25lYClcXFxcblxcXFxuICAgICAgICBsaXN0Lm1hcCh4ID0+IHtcXFxcbiAgICAgICAgICAgIHZhciBuYW1lID0gcGRmaCh4LCAnLnJlc291cmNlX25hbWUmJlRleHQnKVxcXFxuICAgICAgICAgICAgbGV0IGltZyA9IHBkKHgsICcucmVzb3VyY2VfcG9zdGVycyYmZGF0YS11cmwnKTtcXFxcbiAgICAgICAgICAgIGlmIChpbWcgPT0gXFxcXFxcXCJcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgICAgIGltZyA9IFxcXFxcXFwiXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICBsZXQgdXJsID0gcGQoeCwgJ2EmJmhyZWYnKTtcXFxcblxcXFxuICAgICAgICAgICAgbGV0IHNjb3JlID0gcGRmaCh4LCAnLnVwZGF0ZV90aXB8fC5yZXNvdXJjZV9zY29yZXx8aW1nJiZUZXh0Jyk7XFxcXG5cXFxcbiAgICAgICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IG5hbWUsXFxcXG4gICAgICAgICAgICAgICAgaW1nOiBpbWcsXFxcXG4gICAgICAgICAgICAgICAgZGVzYzogc2NvcmUsXFxcXG4gICAgICAgICAgICAgICAgdXJsOiAkKCcnKS5sYXp5UnVsZSgobiwgdSkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFxcXFxcInNvdVxcXFxcXFwiLCBuKVxcXFxuICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcignZHVybCcsIHUpXFxcXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKClcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcXFxuICAgICAgICAgICAgICAgIH0sIG5hbWUsIHVybClcXFxcbiAgICAgICAgICAgIH0pXFxcXG4gICAgICAgIH0pXFxcXG4gICAgfVxcXFxuXFxcXG4gICAgW3tcXFxcbiAgICAgICAgbmFtZTogJ+eDremXqOeUteinhuWJpycsXFxcXG4gICAgICAgIHNlbGVjdDogJ3R2cycsXFxcXG4gICAgICAgIGltZzogJ2h0dHBzOi8vd3d3LnRic2R5LmNvbS9pbWcvbXJzdy93ZWIvaW5kZXgvaW5kZXhfdHYuc3ZnJyxcXFxcbiAgICB9LCB7XFxcXG4gICAgICAgIG5hbWU6ICfng63pl6jnlLXlvbEnLFxcXFxuICAgICAgICBzZWxlY3Q6ICdtb3ZpZXMnLFxcXFxuICAgICAgICBpbWc6ICdodHRwczovL3d3dy50YnNkeS5jb20vaW1nL21yc3cvd2ViL2luZGV4L2luZGV4X212LnN2ZydcXFxcbiAgICB9LCB7XFxcXG4gICAgICAgIG5hbWU6ICfng63pl6jliqjmvKsnLFxcXFxuICAgICAgICBzZWxlY3Q6ICdhbmltZXMnLFxcXFxuICAgICAgICBpbWc6ICdodHRwczovL3d3dy50YnNkeS5jb20vaW1nL21yc3cvd2ViL2luZGV4L2luZGV4X3Nob3cuc3ZnJ1xcXFxuICAgIH0sIHtcXFxcbiAgICAgICAgbmFtZTogJ+eDremXqOe7vOiJuicsXFxcXG4gICAgICAgIHNlbGVjdDogJ3ZhcmlldHlzJyxcXFxcbiAgICAgICAgaW1nOiAnaHR0cHM6Ly93d3cudGJzZHkuY29tL2ltZy9tcnN3L3dlYi9pbmRleC9pbmRleF9yZWNvcmRzLnN2ZydcXFxcbiAgICB9LCB7XFxcXG4gICAgICAgIG5hbWU6ICfng63pl6jnuqrlvZXniYcnLFxcXFxuICAgICAgICBzZWxlY3Q6ICdkb2N1bWVudGFyeXMnLFxcXFxuICAgICAgICBpbWc6ICdodHRwczovL3d3dy50YnNkeS5jb20vaW1nL21yc3cvd2ViL2luZGV4L2luZGV4X3JlY29yZHMuc3ZnJyxcXFxcbiAgICB9XS5tYXAoeCA9PiB7XFxcXG5cXFxcbiAgICAgICAgc2V0TGlzdHMoeClcXFxcbiAgICB9KVxcXFxufVxcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIuWKqOaAgeWIhuexu0pzb25cXFwiLFxcXCJwYXRoXFxcIjpcXFwiamR0ZmxcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5jb25zdMKgZW1wdHnCoD3CoFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiO1xcXFxuXFxcXG5pZsKgKHR5cGVvZihKc29u5ou85o6lKcKgIT3CoCd1bmRlZmluZWQnwqAmJsKgSnNvbuaLvOaOpcKgIT3CoCcnKcKge1xcXFxuICAgIFxcXFxuICAgIHZhciBjYXRlZ29yaWVzanNvbj1UcnVlSnNvbltKc29u5aSn57G7XTtcXFxcbiAgICBcXFxcbiAgICBpZihUcnVlSnNvbltKc29u5ou85o6lXS5jb25zdHJ1Y3RvciAgPT0gT2JqZWN0KXtcXFxcbiAgICB2YXIgaXRlbWpzb249T2JqZWN0LmtleXMoVHJ1ZUpzb25bSnNvbuaLvOaOpV0pLm1hcCh4PT5PYmplY3QudmFsdWVzKFRydWVKc29uW0pzb27mi7zmjqVdW3hdKS5tYXAoej0+SlNPTi5zdHJpbmdpZnkoeikpLmpvaW4oSnNvbuaLhuWIhikpXFxcXG4gICAgfWVsc2UgaWYoVHJ1ZUpzb25bSnNvbuaLvOaOpV0uY29uc3RydWN0b3IgID09IEFycmF5KXtcXFxcbiAgICAgdmFyIGl0ZW1qc29uPVRydWVKc29uW0pzb27mi7zmjqVdXFxcXG4gICAgfVxcXFxuICAgXFxcXG4gICAgY2F0ZWdvcmllc2pzb249Y2F0ZWdvcmllc2pzb24uY29uY2F0KGl0ZW1qc29uKTtcXFxcbiAgICBcXFxcbn3CoGVsc2XCoHtcXFxcbsKgwqDCoMKgdmFywqBjYXRlZ29yaWVzanNvbj1UcnVlSnNvbltKc29u5aSn57G7XTtcXFxcbn1cXFxcblxcXFxuLy9sb2coY2F0ZWdvcmllc2pzb24pXFxcXG5cXFxcbmxldMKgaW5pdF9jYXRlwqA9wqBbXTtcXFxcblxcXFxuZm9yIChsZXQgaSA9IDA7IGkgPCAyMDsgaSsrKSB7XFxcXG4gICAgaW5pdF9jYXRlLnB1c2goXFxcXFxcXCIwXFxcXFxcXCIpO1xcXFxufVxcXFxuXFxcXG5jb25zdMKgZm9sZMKgPcKgZ2V0VmFyKE1ZX1JVTEUuZ3JvdXAswqBcXFxcXFxcIjBcXFxcXFxcIik7XFxcXG5jb25zdMKgY2F0ZV90ZW1wX2pzb27CoD3CoGdldFZhcihNWV9SVUxFLnRpdGxlLMKgSlNPTi5zdHJpbmdpZnkoaW5pdF9jYXRlKSk7XFxcXG5jb25zdMKgY2F0ZV90ZW1wwqA9wqBKU09OLnBhcnNlKGNhdGVfdGVtcF9qc29uKTtcXFxcblxcXFxuaWbCoChwYXJzZUludChwYWdlKcKgPT09wqAxKcKge1xcXFxuwqDCoMKgwqBkLnB1c2goe1xcXFxuwqDCoMKgwqDCoMKgwqDCoHRpdGxlOsKgZm9sZMKgPT09wqAnMSfCoD/CoCfigJzigJzigJ3igJ0nwqArwqDliIbnsbvlsZXlvIAuZm9udGNvbG9yKFxcXFxcXFwiI0ZGMDAwMFxcXFxcXFwiKcKgK8KgJyfCoDrCoCfigJzigJzigJ3igJ0nwqArwqDliIbnsbvmipjlj6AuZm9udGNvbG9yKFxcXFxcXFwiIzFhYWQxOVxcXFxcXFwiKcKgK8KgJycsXFxcXG7CoMKgwqDCoMKgwqDCoMKgdXJsOsKgJCgpLmxhenlSdWxlKChmb2xkKcKgPT7CoHtcXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoHB1dFZhcihNWV9SVUxFLmdyb3VwLMKgZm9sZMKgPT09wqAnMSfCoD/CoCcwJ8KgOsKgJzEnKTtcXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoHJlZnJlc2hQYWdlKGZhbHNlKTtcXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoHJldHVybsKgXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCJcXFxcbsKgwqDCoMKgwqDCoMKgwqB9LMKgZm9sZCksXFxcXG7CoMKgwqDCoMKgwqDCoMKgY29sX3R5cGU6wqAnc2Nyb2xsX2J1dHRvbicsXFxcXG7CoMKgwqDCoH0pO1xcXFxuwqDCoMKgwqBjYXRlZ29yaWVzanNvbi5mb3JFYWNoKChjYXRlZ29yeSzCoGluZGV4KcKgPT7CoHtcXFxcbsKgwqDCoMKgwqDCoMKgwqBsZXTCoHN1Yl9jYXRlZ29yaWVzwqA9wqBjYXRlZ29yeS5zcGxpdChKc29u5ouG5YiGKTtcXFxcbsKgwqDCoMKgwqDCoMKgwqBpZsKgKGluZGV4wqA9PT3CoDApwqB7XFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBzdWJfY2F0ZWdvcmllcy5mb3JFYWNoKChpdGVtLMKga2V5KcKgPT7CoHtcXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgbGV0wqB0aXRsZcKgPcKgaXRlbS5zcGxpdChKc29u5Y2V6aG5KVswXTtcXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgaWbCoCh0eXBlb2Yo5o6S6ZmkKcKgIT3CoCd1bmRlZmluZWQnwqAmJsKg5o6S6ZmkwqAhPcKgJycpwqB7XFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgdGl0bGXCoD3CoHRpdGxlLnJlcGxhY2UobmV3wqBSZWdFeHAo5o6S6ZmkLMKgXFxcXFxcXCJnXFxcXFxcXCIpLMKgXFxcXFxcXCJcXFxcXFxcIik7XFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoH1cXFxcbiAgICAgICAgICAgICAgICBpZih0aXRsZT09Jycpe1xcXFxuICAgICAgICAgICAgICAgICAgcmV0dXJuXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBkLnB1c2goe1xcXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoHRpdGxlOsKga2V5LnRvU3RyaW5nKCnCoD09PcKgY2F0ZV90ZW1wW2luZGV4XcKgP8KgXFxcXFxcXCLigJzigJzigJ3igJ1cXFxcXFxcIsKgK8KgdGl0bGUuZm9udGNvbG9yKOWIhuexu+minOiJsinCoDrCoHRpdGxlLFxcXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoHVybDrCoGl0ZW0uc3BsaXQoSnNvbuWNlemhuSlbMV3CoCvCoCQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKHBhcmFtcyxsaXN0KcKgPT7CoHtcXFxcbiAgICBcXFxcbiAgICAgICAgICAgICAgICAgICAgc3RvcmFnZTAucHV0TXlWYXIoJ2luZGV4JyxwYXJhbXMua2V5KVxcXFxuXFxcXG4gICAgICAgICAgICAgICAgICAgIGxpc3QubWFwKGtleT0+e1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJNeVZhcihrZXkpO1xcXFxuICAgICAgICAgICAgICAgICAgICB9KVxcXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgbGV0wqBuZXdfY2F0ZcKgPcKgW11cXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoHBhcmFtcy5jYXRlX3RlbXAuZm9yRWFjaCgoY2F0ZSzCoGluZGV4KcKgPT7CoHtcXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgbmV3X2NhdGUucHVzaChpbmRleMKgPT09wqAwwqA/wqBwYXJhbXMua2V5LnRvU3RyaW5nKCnCoDrCoFxcXFxcXFwiMFxcXFxcXFwiKVxcXFxuICAgICBcXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoH0pXFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBwdXRWYXIoTVlfUlVMRS50aXRsZSzCoEpTT04uc3RyaW5naWZ5KG5ld19jYXRlKSlcXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoHB1dFZhcihNWV9SVUxFLnVybCzCoGlucHV0KVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCJteXR5cGVcXFxcXFxcIixpbnB1dClcXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoHJlZnJlc2hQYWdlKHRydWUpXFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqByZXR1cm7CoFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiXFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgfSzCoHtcXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGNhdGVfdGVtcDrCoGNhdGVfdGVtcCxcXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGtleTrCoGtleSxcXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoHBhZ2U6wqBwYWdlLFxcXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoH0sSnNvbuWIl+ihqCksXFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgY29sX3R5cGU6wqAnc2Nyb2xsX2J1dHRvbicsXFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoH0pXFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB9KVxcXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgZC5wdXNoKHtcXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgY29sX3R5cGU6wqBcXFxcXFxcImJsYW5rX2Jsb2NrXFxcXFxcXCJcXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoH0pO1xcXFxuwqDCoMKgwqDCoMKgwqDCoH3CoGVsc2XCoGlmwqAoZm9sZMKgPT09wqAnMScpwqB7XFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBzdWJfY2F0ZWdvcmllcy5mb3JFYWNoKChpdGVtLMKga2V5KcKgPT7CoHtcXFxcbiAgICAgICAgICAgICAgICB2YXIgb2JqPUpTT04ucGFyc2UoaXRlbSlcXFxcbiAgICBcXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgbGV0wqB0aXRsZcKgPSBvYmpbJ25hbWUnXVxcXFxuICAgICAgICAgICAgICAgIFxcXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBpZsKgKHR5cGVvZijmjpLpmaQpwqAhPcKgJ3VuZGVmaW5lZCfCoCYmwqDmjpLpmaTCoCE9wqAnJynCoHtcXFxcbiAgICBcXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB0aXRsZcKgPcKgdGl0bGUucmVwbGFjZShuZXfCoFJlZ0V4cCjmjpLpmaQswqBcXFxcXFxcImdcXFxcXFxcIikswqBcXFxcXFxcIlxcXFxcXFwiKVxcXFxuICAgICAgICAgICBcXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgfVxcXFxuICAgICAgICAgICAgICAgICAgIGlmKHRpdGxlPT0nJyl7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXFxcXG4gICAgICAgICAgICAgICAgICAgIH1cXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgZC5wdXNoKHtcXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB0aXRsZTrCoGtleS50b1N0cmluZygpwqA9PT3CoGNhdGVfdGVtcFtpbmRleF3CoD/CoFxcXFxcXFwi4oCc4oCc4oCd4oCdXFxcXFxcXCLCoCvCoHRpdGxlLmZvbnRjb2xvcijliIbnsbvpopzoibIpwqA6wqB0aXRsZSxcXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB1cmw6wqAkKGl0ZW0rJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKHBhcmFtcynCoD0+wqB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqPUpTT04ucGFyc2UoaW5wdXQpXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXJsPW9ialsndXJsJ11cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlPW9ialsndHlwZSddXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoHBhcmFtcy5jYXRlX3RlbXBbcGFyYW1zLmluZGV4XcKgPcKgcGFyYW1zLmtleS50b1N0cmluZygpXFxcXG5cXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoHB1dFZhcihNWV9SVUxFLnRpdGxlLMKgSlNPTi5zdHJpbmdpZnkocGFyYW1zLmNhdGVfdGVtcCkpXFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBwdXRWYXIoTVlfUlVMRS51cmwswqB1cmwpXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHR5cGUhPScnP3RydWU6ZmFsc2Upe1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXk9dHlwZVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZT11cmxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yYWdlMC5wdXRNeVZhcihrZXksdmFsdWUpXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqByZWZyZXNoUGFnZSh0cnVlKVxcXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgcmV0dXJuwqBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIlxcXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoH0swqB7XFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBjYXRlX3RlbXA6wqBjYXRlX3RlbXAsXFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBpbmRleDrCoGluZGV4LFxcXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKga2V5OsKga2V5LFxcXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgcGFnZTrCoHBhZ2UsXFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgfSksXFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgY29sX3R5cGU6wqAnc2Nyb2xsX2J1dHRvbicsXFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoH0pXFxcXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB9KVxcXFxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgZC5wdXNoKHtcXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgY29sX3R5cGU6wqBcXFxcXFxcImJsYW5rX2Jsb2NrXFxcXFxcXCJcXFxcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoH0pO1xcXFxuwqDCoMKgwqDCoMKgwqDCoH1cXFxcbsKgwqDCoMKgfSlcXFxcbn1cXFwifV1cIixcInByb3h5XCI6XCJcIn0iLCJ0aXRsZSI6Iua1gea1quWcsOeQgy1IROmrmOa4hSJ9
2DYVpv1f,Stand Upright,IIRyoII,Lua,Saturday 3rd of June 2023 09:04:57 AM CDT,"local Library = loadstring(game:HttpGet(('https://pastebin.com/raw/0KeEA6du'),true))()
local Window = Library.CreateLib(""                                          PORNHUB"", (""Synapse""))
local Tab = Window:NewTab(""Lair"")
local yes = Tab:NewSection(""Lair Farm"")

local Workspace = game.Workspace


local SelectedLairNPC
local SelectedLairNPCText = ""None""
yes:NewButton(""Select Lair NPC"", ""Lair Farm"", function()
    for i, v in pairs(Workspace.Map.NPCs:GetChildren()) do
        if v:FindFirstChild(""HumanoidRootPart"") then
            if (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - v.HumanoidRootPart.Position).Magnitude < 15 then
                SelectedLairNPC = v
                SelectedLairNPCText = v.Head:FindFirstChild(""Main"").Text.Text
            end
        end
    end
end)

function TriggerLair()
    local Done
    for i, v in pairs(SelectedLairNPC:GetChildren()) do
        if v.Name == ""Done"" then
            Done = v
        end
    end
    
    if Done then
        Done:FireServer()
    else
        CreateNotification(""Arctic"", ""Error Grabbing Remote 2"", {})
    end
end

local StartLairFarming = false
yes:NewToggle(""Begin Lair Farm"", ""Lair Farm"", function()
    StartLairFarming = not StartLairFarming
    
    if StartLairFarming then
        if SelectedLairNPC then
            while StartLairFarming and task.wait() do
                pcall(function()
                    TriggerLair()
                    game:GetService(""Workspace"").Living:WaitForChild(""Boss"")
                    
                    repeat
                        task.wait()
                        pcall(function()
                            for i, v in pairs(game:GetService(""Players"").LocalPlayer.PlayerGui.CDgui.fortnite:GetChildren()) do
                                if v:IsA(""Frame"") and v.Textt.Text == ""Punch"" then
                                    -- Polar Was Here!
                                else
                                    game:GetService(""Players"").LocalPlayer.Character.StandEvents.M1:FireServer()
                                end
                            end
                            if game:GetService(""Players"").LocalPlayer.Character:FindFirstChild(""Aura"").Value == false then
                                game:GetService(""Players"").LocalPlayer.Character.StandEvents.Summon:FireServer()
                            end
                            if game:GetService(""Players"").LocalPlayer.Character:FindFirstChild(""Stand"") then
                                game:GetService(""Players"").LocalPlayer.Character.Stand:WaitForChild(""HumanoidRootPart"").CFrame = game:GetService(""Players"").LocalPlayer.Character.HumanoidRootPart.CFrame
                            end
                            
                            game:GetService(""Players"").LocalPlayer.Character.HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
                            Workspace.Living:FindFirstChild(""Boss"").Humanoid.Health = 0
                            game:GetService(""Players"").LocalPlayer.Character.HumanoidRootPart.CFrame = game:GetService(""Workspace"").Living:FindFirstChild(""Boss""):WaitForChild(""HumanoidRootPart"").CFrame * CFrame.new(0, -6, 4, 1, 0, 0, 1)
                        end)
                    until not Workspace.Living:FindFirstChild(""Boss"") or game:GetService(""Players"").LocalPlayer.Character:FindFirstChild(""Humanoid"").Health == 0 or StartLairFarming == false
                    game:GetService(""Players"").LocalPlayer.CharacterAdded:Wait()
                end)
            end
        else
            CreateNotification(""Arctic"", ""You Are Missing A Step! Please Check Tutorial Then Re-Enable!"")
        end
    end
end)

local Tab = Window:NewTab(""Quests"")
local yes = Tab:NewSection(""Quest Farm"")

local SelectedQuestNPC
local SelectedQuestNPCText = ""None""
local SelectedNPC = ""None""

yes:NewButton(""Select Quest NPC"", ""Quest Farm"", function()
    for i, v in pairs(Workspace.Map.NPCs:GetChildren()) do
        if v:FindFirstChild(""HumanoidRootPart"") then
            if (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - v.HumanoidRootPart.Position).Magnitude < 15 then
                SelectedQuestNPC = v
                SelectedQuestNPCText = v.Head:FindFirstChild(""Main"").Text.Text
            end
        end
    end
end)

yes:NewButton(""Select NPC"", ""Quest Farm"", function()
    for i, v in pairs(Workspace.Living:GetChildren()) do
        if v:FindFirstChild(""HumanoidRootPart"") and v:FindFirstChild(""AI"") then
            if (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - v.HumanoidRootPart.Position).Magnitude < 15 then
                SelectedNPC = v.Name
            end
        end
    end
end)

local function TriggerQuest()
    local QuestDone
    local Done
    for i, v in pairs(SelectedQuestNPC:GetChildren()) do
        if v.Name == ""QuestDone"" then
            QuestDone = v
        elseif v.Name == ""Done"" then
            Done = v
        end
    end
    
    if QuestDone then
        QuestDone:FireServer()
    else
        CreateNotification(""Arctic"", ""Error Grabbing Remote 1"", {})
    end
    
    if Done then
        Done:FireServer()
    else
        CreateNotification(""Arctic"", ""Error Grabbing Remote 2"", {})
    end
end

local StartQuestFarming = false
yes:NewToggle(""Begin Quest Farm"", ""Quest Farm"", function()
    StartQuestFarming = not StartQuestFarming
    
    if StartQuestFarming then
        if SelectedQuestNPC and SelectedNPC ~= ""None"" then
            while StartQuestFarming and task.wait() do
                pcall(function()
                    for i, v in pairs(Workspace.Living:GetChildren()) do
                        if v.Name == SelectedNPC and v.Humanoid.Health ~= 0 then
                            TriggerQuest()
                            repeat
                                task.wait()
                                for i, v in pairs(game:GetService(""Players"").LocalPlayer.PlayerGui.CDgui.fortnite:GetChildren()) do
                                    if v:IsA(""Frame"") and v.Textt.Text == ""Punch"" then
                                        -- Polar Was Here!
                                    else
                                        game:GetService(""Players"").LocalPlayer.Character.StandEvents.M1:FireServer()
                                    end
                                end
                                
                                if game:GetService(""Players"").LocalPlayer.Character:FindFirstChild(""Stand"") then
                                    game:GetService(""Players"").LocalPlayer.Character.Stand:WaitForChild(""HumanoidRootPart"").CFrame = game:GetService(""Players"").LocalPlayer.Character.HumanoidRootPart.CFrame
                                end
                                
                                game:GetService(""Players"").LocalPlayer.Character:WaitForChild(""HumanoidRootPart"").CFrame = v:FindFirstChild(""HumanoidRootPart"").CFrame * CFrame.new(0, -6, 4, 1, 0, 0, 1)
                                game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
                                if game:GetService(""Players"").LocalPlayer.Character:FindFirstChild(""Aura"").Value == false then
                                    game:GetService(""Players"").LocalPlayer.Character.StandEvents.Summon:FireServer()
                                end
                            until v.Humanoid.Health == 0 or StartQuestFarming == false
                            
                            TriggerQuest()
                            game:GetService(""Players"").LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(game:GetService(""Players"").LocalPlayer.Character.HumanoidRootPart.Position + Vector3.new(0, 0, 1000))
                            game:GetService(""Players"").LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(game:GetService(""Players"").LocalPlayer.Character.HumanoidRootPart.Position + Vector3.new(0, 10, 0))
                        end
                    end
                end)
            end
        else
            CreateNotification(""Arctic"", ""You Are Missing A Step! Please Check Tutorial Then Re-Enable!"")
        end
    end
end)"
2fF9KQrJ,Binary Search Recursive,MuzammiL5,Java,Saturday 3rd of June 2023 08:59:14 AM CDT,"int binarysearch(int arr[], int n, int k) {
        return search(arr, 0, n-1, k);
    }
    
    int search(int arr[], int lo, int hi, int k) {
        if (lo > hi)
            return -1;
        
        int mid = lo + (hi-lo) / 2;
        
        if (arr[mid] == k)
            return mid;
        else if (k < arr[mid])
            return search(arr, lo, mid-1, k);
        else
            return search(arr, mid+1, hi, k);
    }"
wp1nv0Um,Flask handle request,RupeshAcharya60,Python,Saturday 3rd of June 2023 08:49:40 AM CDT,"from flask import Flask,request
import numpy as np
import tensorflow as tf

app = Flask(__name__)



def get_coordinate():
    image = load_img(path) #pil object
    image = np.array(image,dtype=np.uint8) #8 bit array(0,255)
    image1 = load_img(path,target_size=(224,224))
    #data_preprocessing
    image_arr_224 = img_to_array(image1)/255.0 #convert into array and get normalized array
    h,w,d = image.shape
    test_arr = image_arr_224.reshape(1,224,224,3)
    #make prediction
    coords = model.predict(test_arr)
    #denormalize the value
    denorm = np.array([w,w,h,h])
    coords = coords * denorm
    coords = coords.astype(np.int32)
    #drawing bounding box on top of the image
    xmin, xmax,ymin,ymax = coords[0]
    pt1 = (xmin,ymin)
    pt2 = (xmax,ymax)
    print(pt1, pt2)
    cv2.rectangle(image,pt1,pt2,(0,255,0),3)
    return coords 



@app.route(""/sendimage"",methods=[""POST""])
def hello_world():   
    data = request.files[""image""]
    cods = get_coordinate(data)
    img = np.array(load_img(data))
    xmin,xmax,ymin,ymax = cods[0]
    roi = img[ymin:ymax,xmin:xmax]
    text = pt.image_to_string(roi)
    text = ""image""
    return {""data"":""data""}


"
Bbrzn6VR,邀您一起看：77影视大全,xiaomianao666,JavaScript,Saturday 3rd of June 2023 08:36:05 AM CDT,海阔视界规则分享，当前分享的是：二级页面详情￥page_detail￥77影视大全@@eyJkYXRhIjoie1wiYXNzb2NpYXRlZE1vZGVsc01hcEZvckpvaW5UYWJsZVwiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhGS1wiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhvdXRGS1wiOnt9LFwiZmllbGRzVG9TZXRUb0RlZmF1bHRcIjpbXSxcImdtdE1vZGlmaWVkXCI6MCxcImlkXCI6MCxcImxhc3RfY2hhcHRlcl9ydWxlXCI6XCJqczpcXG5ldmFsKGZldGNoKCdoaWtlcjovL2ZpbGVzL3J1bGVzL3h5cS9oaWtlcm1vdmllLmpzJykpO2hpa2NoYXB0ZXIoKTtcIixcImxpc3RUb0NsZWFyQXNzb2NpYXRlZEZLXCI6W10sXCJsaXN0VG9DbGVhclNlbGZGS1wiOltdLFwicGFnZUxpc3RcIjpbXSxcInNhdmVkXCI6ZmFsc2UsXCJ0aXRsZVwiOlwi6aaZ5oOF5b2x6KeGXCIsXCJ2ZXJzaW9uXCI6MCxcInVybFwiOlwiaGlrZXI6Ly9lbXB0eSQkaHR0cDovL2FwaS50eXVuNzcuY24vYXBpLnBocC9wcm92aWRlJCRmeXBhZ2UkJOeUteW9sSbnlLXop4bliacm57u86Im6JuWKqOa8qyQkMSYyJjMmNCQkO2dldDtVVEYtODt7VXNlci1BZ2VudEBNb3ppbGxhLzUuMCAoTGludXjvvJvvvJsgQW5kcm9pZCAxMe+8m++8myBNaSAxMCBQcm8pIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS84OC4wLjQzMjQuMTUyIE1vYmlsZSBTYWZhcmkvNTM3LjM2fVwiLFwiY29sX3R5cGVcIjpcIm1vdmllXzFcIixcImZpbmRfcnVsZVwiOlwianM6XFxuZXZhbChmZXRjaCgnaGlrZXI6Ly9maWxlcy9ydWxlcy94eXEvaGlrZXJtb3ZpZS5qcycpKTtoaWtobWVyaigpO1wiLFwiZ3JvdXBcIjpcIuKRoeW9seaQnFwiLFwidWFcIjpcIm1vYmlsZVwiLFwicHJlUnVsZVwiOlwiLy/orr7nva7mm7TmlrDpl7TpmpTml7bpl7Qs5Y2V5L2N5Li65pW05pWw5aSp44CCXFxudmFyIHVwdGltZSA9IDI7XFxuXFxuZnVuY3Rpb24gdXBydWxlZmlsZSgpIHtcXG4gICAgdmFyIHJ1bGVqcyA9IGZldGNoKCdodHRwczovL2NvZGUuYWxpeXVuLmNvbS9semsyMzU1OS9DbG91ZFJ1bGUvcmF3L21hc3Rlci9oaWtlcm1vdmllLmpzJywge30pO1xcbiAgICBpZiAocnVsZWpzLnNlYXJjaCgvbGF6eVJ1bGUvKSA9PSAtMSkge1xcbiAgICAgICAgcnVsZWpzID0gZmV0Y2goJ2h0dHBzOi8vY29kZWJlcmcub3JnL2x6azIzNTU5L2Nsb3VkcnVsZS9yYXcvYnJhbmNoL21hc3Rlci9oaWtlcm1vdmllLmpzJywge30pO1xcbiAgICB9XFxuICAgIGlmIChydWxlanMuc2VhcmNoKC9sYXp5UnVsZS8pICE9IC0xKSB7XFxuICAgICAgICB3cml0ZUZpbGUoXFxcImhpa2VyOi8vZmlsZXMvcnVsZXMveHlxL2hpa2VybW92aWUuanNcXFwiLCBydWxlanMpO1xcbiAgICB9XFxuICAgIHZhciBydWxlanNvbiA9IGZldGNoKCdodHRwczovL2NvZGUuYWxpeXVuLmNvbS9semsyMzU1OS9DbG91ZFJ1bGUvcmF3L21hc3Rlci9oaWtlcm1vdmllLmpzb24nLCB7fSk7XFxuICAgIGlmIChydWxlanNvbi5zZWFyY2goL1xcXFxcXFwidm9kaHJlZlxcXFxcXFwiLykgPT0gLTEpIHtcXG4gICAgICAgIHJ1bGVqc29uID0gZmV0Y2goJ2h0dHBzOi8vY29kZWJlcmcub3JnL2x6azIzNTU5L2Nsb3VkcnVsZS9yYXcvYnJhbmNoL21hc3Rlci9oaWtlcm1vdmllLmpzb24nLCB7fSk7XFxuICAgIH1cXG4gICAgaWYgKHJ1bGVqc29uLnNlYXJjaCgvXFxcXFxcXCJ2b2RocmVmXFxcXFxcXCIvKSAhPSAtMSkge1xcbiAgICAgICAgd3JpdGVGaWxlKFxcXCJoaWtlcjovL2ZpbGVzL3J1bGVzL3h5cS9oaWtlcm1vdmllLmpzb25cXFwiLCBydWxlanNvbik7XFxuICAgIH1cXG4gICAgaWYgKHJ1bGVqcy5zZWFyY2goL2xhenlSdWxlLykgIT0gLTEgJiYgcnVsZWpzb24uc2VhcmNoKC9cXFxcXFxcInZvZGhyZWZcXFxcXFxcIi8pICE9IC0xKSB7XFxuICAgICAgICB3cml0ZUZpbGUoXFxcImhpa2VyOi8vZmlsZXMvcnVsZXMveHlxL2hpa2VydXBkYXRlLnR4dFxcXCIsIG5ldyBEYXRlKCkgKyAnJyk7XFxuICAgICAgICBjb25maXJtKHt0aXRsZTon5o+Q56S6JywgY29udGVudDon6Ieq5Yqo5pu05paw5a6M5oiQJ30pO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgY29uZmlybSh7dGl0bGU6J+aPkOekuicsIGNvbnRlbnQ6J+iHquWKqOabtOaWsOWksei0pSd9KTtcXG4gICAgfVxcbn1cXG5cXG5cXG5cXG4vL+ajgOa1i+aYr+WQpuacieWGmeWFpeaXtumXtOS4juinhOWImeeahGpz5o+S5Lu25paH5Lu2XFxuaWYgKGZpbGVFeGlzdChcXFwiaGlrZXI6Ly9maWxlcy9ydWxlcy94eXEvaGlrZXJ1cGRhdGUudHh0XFxcIikgJiYgZmlsZUV4aXN0KFxcXCJoaWtlcjovL2ZpbGVzL3J1bGVzL3h5cS9oaWtlcm1vdmllLmpzXFxcIikgJiYgZmlsZUV4aXN0KFxcXCJoaWtlcjovL2ZpbGVzL3J1bGVzL3h5cS9oaWtlcm1vdmllLmpzb25cXFwiKSkge1xcbiAgICAvL+iuoeeul+aXtumXtOmXtOmalFxcbiAgICB2YXIgc3RhcnQgPSBuZXcgRGF0ZShmZXRjaChcXFwiaGlrZXI6Ly9maWxlcy9ydWxlcy94eXEvaGlrZXJ1cGRhdGUudHh0XFxcIiwge30pKTtcXG4gICAgdmFyIG5vd3QgPSBuZXcgRGF0ZSgpO1xcbiAgICB2YXIgRF9UID0gbm93dC5nZXRUaW1lKCkgLSBzdGFydC5nZXRUaW1lKCk7XFxuICAgIHZhciBEX0QgPSBEX1QgLyAoMTAwMCAqIDM2MDAgKiAyNCk7XFxuICAgIHZhciB0ZGlmID0gcGFyc2VJbnQoRF9EKSArICcnO1xcbiAgICAvL2xvZyh0ZGlmKTtcXG4gICAgLy/pu5jorqTpl7TpmpTotoXov4forr7nva7lpKnmlbDlsLHlj5bkuIDmrKHkupHnq6/mlofku7ZcXG4gICAgaWYgKHRkaWYgPj0gdXB0aW1lIHx8IHRkaWYgPCAwKSB7XFxuICAgICAgICB1cHJ1bGVmaWxlKCk7XFxuICAgIH1cXG59IGVsc2Uge1xcbiAgICAvL+WmguaenOWwkeS4gOS4quaWh+S7tuWwseiHquWKqOWPluS6keerr+aWh+S7tlxcbiAgICB1cHJ1bGVmaWxlKCk7XFxufVxcblxcblxcblxcbi8v5omn6KGM6ZyA6KaB6aKE5aSE55CG55qE56uZ54K5XFxudmFyIGxhYyA9IGZldGNoKCdoaWtlcjovL2ZpbGVzL3J1bGVzL3h5cS9oaWtlcm1vdmllLmpzJyk7XFxuLy9sb2cobGFjLmxlbmd0aCk7XFxuaWYgKGxhYy5zZWFyY2goL2xhenlSdWxlLykgIT0gLTEpIHtcXG4gICAgZXZhbChsYWMpO1xcbiAgICBoaWtlcnByZSgpO1xcbn0gZWxzZSB7XFxuICAgIC8v5aaC5p6c5pys5Zyw5paH5Lu25LiN5a+55bCG5bCd6K+V6Ieq5L+u5aSNXFxuICAgIHVwcnVsZWZpbGUoKTtcXG4gICAgc2V0RXJyb3IoJ+inhOWImeS/ruWkjeWujOaIkO+8jOWmguaciemXrumimOivt+WPjemmiOOAgicpXFxufVwiLFwicGFnZXNcIjpcIltdXCJ9IiwicGljVXJsIjoiaHR0cHM6Ly90aHVtYjIuamZjZG5zLmNvbS90aHVtYi9uMTMxcDMxczEyazJhLzE2ZjVlMjQwOTdlZDM0MjhfMTAwXzEwMC5wbmdAUmVmZXJlcj0iLCJ0aXRsZSI6Ijc35b2x6KeG5aSn5YWoIn0=
W8FGSWvA,邀您一起看：厂长资源,xiaomianao666,JavaScript,Saturday 3rd of June 2023 08:20:51 AM CDT,海阔视界规则分享，当前分享的是：二级页面详情￥page_detail￥厂长资源@@eyJkYXRhIjoie1wiYXNzb2NpYXRlZE1vZGVsc01hcEZvckpvaW5UYWJsZVwiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhGS1wiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhvdXRGS1wiOnt9LFwiZmllbGRzVG9TZXRUb0RlZmF1bHRcIjpbXSxcImdtdE1vZGlmaWVkXCI6MCxcImlkXCI6MCxcImxhc3RfY2hhcHRlcl9ydWxlXCI6XCJqczpcXG5ldmFsKGZldGNoKCdoaWtlcjovL2ZpbGVzL3J1bGVzL3h5cS9oaWtlcm1vdmllLmpzJykpO2hpa2NoYXB0ZXIoKTtcIixcImxpc3RUb0NsZWFyQXNzb2NpYXRlZEZLXCI6W10sXCJsaXN0VG9DbGVhclNlbGZGS1wiOltdLFwicGFnZUxpc3RcIjpbXSxcInNhdmVkXCI6ZmFsc2UsXCJ0aXRsZVwiOlwi6aaZ5oOF5b2x6KeGXCIsXCJ2ZXJzaW9uXCI6MCxcInVybFwiOlwiaGlrZXI6Ly9lbXB0eSQkaHR0cHM6Ly9jenp5LnBybyQkZnlwYWdlJCTlhajpg6gm6auY5YiG5b2x6KeGJuacgOaWsOeUteW9sSbnlLXop4bliacm5Zu95Lqn5YmnJue+juWJpybpn6nliacm55Wq5YmnJuWKqOa8qybkvJrlkZjkuJPljLom5L+E572X5pav55S15b2xJuWKoOaLv+Wkp+eUteW9sSbliqjnlLsm5Y2O6K+t55S15b2xJuWNsOW6pueUteW9sSblm73kuqfliacm5pel5YmnJuaXpeacrOeUteW9sSbmrKfnvo7nlLXlvbEm5rOV5Zu955S15b2xJua1t+WkluWJp++8iOWFtuS7lu+8iSbnlLXlvbEm55S16KeG5YmnJuermemVv+aOqOiNkCbnvo7liacm6Iux5Zu955S15b2xJumfqeWJpybpn6nlm73nlLXlvbEkJG1vdmllX2J0Jnp1aXhpbmRpYW55aW5nL2dhb2ZlbnlpbmdzaGkmenVpeGluZGlhbnlpbmcmZHNqJmdjaiZtZWlqdXR0Jmhhbmp1dHYmZmFuanUmZG0mbW92aWVfYnRfc2VyaWVzL2h1aXl1YW56aHVhbnF1Jm1vdmllX2J0X3Nlcmllcy9lbHVvc2lkaWFueWluZyZtb3ZpZV9idF9zZXJpZXMvamlhbmFkYWRpYW55aW5nJm1vdmllX2J0X3Nlcmllcy9kb2h1YSZtb3ZpZV9idF9zZXJpZXMvaHVheXVkaWFueWluZyZtb3ZpZV9idF9zZXJpZXMveWluZHVkaWFueWluZyZtb3ZpZV9idF9zZXJpZXMvZ3VvY2hhbmp1Jm1vdmllX2J0X3Nlcmllcy9yaiZtb3ZpZV9idF9zZXJpZXMvcmliZW5kaWFueWluZyZtb3ZpZV9idF9zZXJpZXMvbWVpZ3VvZGlhbnlpbmcmbW92aWVfYnRfc2VyaWVzL2ZhZ3VvZGlhbnlpbmcmbW92aWVfYnRfc2VyaWVzL2h3aiZtb3ZpZV9idF9zZXJpZXMvZHl5Jm1vdmllX2J0X3Nlcmllcy9kaWFuc2hpanUmbW92aWVfYnRfc2VyaWVzL3poYW5jaGFuZ3R1aWppYW4mbW92aWVfYnRfc2VyaWVzL21qJm1vdmllX2J0X3Nlcmllcy95aW5nZ3VvZGlhbnlpbmcmbW92aWVfYnRfc2VyaWVzL2hqJm1vdmllX2J0X3Nlcmllcy9oYW5ndW9kaWFueWluZyQkO2dldDtVVEYtODt7VXNlci1BZ2VudEBNb3ppbGxhLzUuMCAoTGludXjvvJvvvJsgQW5kcm9pZCAxMe+8m++8myBNaSAxMCBQcm8pIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS84OC4wLjQzMjQuMTUyIE1vYmlsZSBTYWZhcmkvNTM3LjM2fVwiLFwiY29sX3R5cGVcIjpcIm1vdmllXzFcIixcImZpbmRfcnVsZVwiOlwianM6XFxuZXZhbChmZXRjaCgnaGlrZXI6Ly9maWxlcy9ydWxlcy94eXEvaGlrZXJtb3ZpZS5qcycpKTtoaWtobWVyaigpO1wiLFwiZ3JvdXBcIjpcIuKRoeW9seaQnFwiLFwidWFcIjpcIm1vYmlsZVwiLFwicHJlUnVsZVwiOlwiLy/orr7nva7mm7TmlrDpl7TpmpTml7bpl7Qs5Y2V5L2N5Li65pW05pWw5aSp44CCXFxudmFyIHVwdGltZSA9IDI7XFxuXFxuZnVuY3Rpb24gdXBydWxlZmlsZSgpIHtcXG4gICAgdmFyIHJ1bGVqcyA9IGZldGNoKCdodHRwczovL2NvZGUuYWxpeXVuLmNvbS9semsyMzU1OS9DbG91ZFJ1bGUvcmF3L21hc3Rlci9oaWtlcm1vdmllLmpzJywge30pO1xcbiAgICBpZiAocnVsZWpzLnNlYXJjaCgvbGF6eVJ1bGUvKSA9PSAtMSkge1xcbiAgICAgICAgcnVsZWpzID0gZmV0Y2goJ2h0dHBzOi8vY29kZWJlcmcub3JnL2x6azIzNTU5L2Nsb3VkcnVsZS9yYXcvYnJhbmNoL21hc3Rlci9oaWtlcm1vdmllLmpzJywge30pO1xcbiAgICB9XFxuICAgIGlmIChydWxlanMuc2VhcmNoKC9sYXp5UnVsZS8pICE9IC0xKSB7XFxuICAgICAgICB3cml0ZUZpbGUoXFxcImhpa2VyOi8vZmlsZXMvcnVsZXMveHlxL2hpa2VybW92aWUuanNcXFwiLCBydWxlanMpO1xcbiAgICB9XFxuICAgIHZhciBydWxlanNvbiA9IGZldGNoKCdodHRwczovL2NvZGUuYWxpeXVuLmNvbS9semsyMzU1OS9DbG91ZFJ1bGUvcmF3L21hc3Rlci9oaWtlcm1vdmllLmpzb24nLCB7fSk7XFxuICAgIGlmIChydWxlanNvbi5zZWFyY2goL1xcXFxcXFwidm9kaHJlZlxcXFxcXFwiLykgPT0gLTEpIHtcXG4gICAgICAgIHJ1bGVqc29uID0gZmV0Y2goJ2h0dHBzOi8vY29kZWJlcmcub3JnL2x6azIzNTU5L2Nsb3VkcnVsZS9yYXcvYnJhbmNoL21hc3Rlci9oaWtlcm1vdmllLmpzb24nLCB7fSk7XFxuICAgIH1cXG4gICAgaWYgKHJ1bGVqc29uLnNlYXJjaCgvXFxcXFxcXCJ2b2RocmVmXFxcXFxcXCIvKSAhPSAtMSkge1xcbiAgICAgICAgd3JpdGVGaWxlKFxcXCJoaWtlcjovL2ZpbGVzL3J1bGVzL3h5cS9oaWtlcm1vdmllLmpzb25cXFwiLCBydWxlanNvbik7XFxuICAgIH1cXG4gICAgaWYgKHJ1bGVqcy5zZWFyY2goL2xhenlSdWxlLykgIT0gLTEgJiYgcnVsZWpzb24uc2VhcmNoKC9cXFxcXFxcInZvZGhyZWZcXFxcXFxcIi8pICE9IC0xKSB7XFxuICAgICAgICB3cml0ZUZpbGUoXFxcImhpa2VyOi8vZmlsZXMvcnVsZXMveHlxL2hpa2VydXBkYXRlLnR4dFxcXCIsIG5ldyBEYXRlKCkgKyAnJyk7XFxuICAgICAgICBjb25maXJtKHt0aXRsZTon5o+Q56S6JywgY29udGVudDon6Ieq5Yqo5pu05paw5a6M5oiQJ30pO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgY29uZmlybSh7dGl0bGU6J+aPkOekuicsIGNvbnRlbnQ6J+iHquWKqOabtOaWsOWksei0pSd9KTtcXG4gICAgfVxcbn1cXG5cXG5cXG5cXG4vL+ajgOa1i+aYr+WQpuacieWGmeWFpeaXtumXtOS4juinhOWImeeahGpz5o+S5Lu25paH5Lu2XFxuaWYgKGZpbGVFeGlzdChcXFwiaGlrZXI6Ly9maWxlcy9ydWxlcy94eXEvaGlrZXJ1cGRhdGUudHh0XFxcIikgJiYgZmlsZUV4aXN0KFxcXCJoaWtlcjovL2ZpbGVzL3J1bGVzL3h5cS9oaWtlcm1vdmllLmpzXFxcIikgJiYgZmlsZUV4aXN0KFxcXCJoaWtlcjovL2ZpbGVzL3J1bGVzL3h5cS9oaWtlcm1vdmllLmpzb25cXFwiKSkge1xcbiAgICAvL+iuoeeul+aXtumXtOmXtOmalFxcbiAgICB2YXIgc3RhcnQgPSBuZXcgRGF0ZShmZXRjaChcXFwiaGlrZXI6Ly9maWxlcy9ydWxlcy94eXEvaGlrZXJ1cGRhdGUudHh0XFxcIiwge30pKTtcXG4gICAgdmFyIG5vd3QgPSBuZXcgRGF0ZSgpO1xcbiAgICB2YXIgRF9UID0gbm93dC5nZXRUaW1lKCkgLSBzdGFydC5nZXRUaW1lKCk7XFxuICAgIHZhciBEX0QgPSBEX1QgLyAoMTAwMCAqIDM2MDAgKiAyNCk7XFxuICAgIHZhciB0ZGlmID0gcGFyc2VJbnQoRF9EKSArICcnO1xcbiAgICAvL2xvZyh0ZGlmKTtcXG4gICAgLy/pu5jorqTpl7TpmpTotoXov4forr7nva7lpKnmlbDlsLHlj5bkuIDmrKHkupHnq6/mlofku7ZcXG4gICAgaWYgKHRkaWYgPj0gdXB0aW1lIHx8IHRkaWYgPCAwKSB7XFxuICAgICAgICB1cHJ1bGVmaWxlKCk7XFxuICAgIH1cXG59IGVsc2Uge1xcbiAgICAvL+WmguaenOWwkeS4gOS4quaWh+S7tuWwseiHquWKqOWPluS6keerr+aWh+S7tlxcbiAgICB1cHJ1bGVmaWxlKCk7XFxufVxcblxcblxcblxcbi8v5omn6KGM6ZyA6KaB6aKE5aSE55CG55qE56uZ54K5XFxudmFyIGxhYyA9IGZldGNoKCdoaWtlcjovL2ZpbGVzL3J1bGVzL3h5cS9oaWtlcm1vdmllLmpzJyk7XFxuLy9sb2cobGFjLmxlbmd0aCk7XFxuaWYgKGxhYy5zZWFyY2goL2xhenlSdWxlLykgIT0gLTEpIHtcXG4gICAgZXZhbChsYWMpO1xcbiAgICBoaWtlcnByZSgpO1xcbn0gZWxzZSB7XFxuICAgIC8v5aaC5p6c5pys5Zyw5paH5Lu25LiN5a+55bCG5bCd6K+V6Ieq5L+u5aSNXFxuICAgIHVwcnVsZWZpbGUoKTtcXG4gICAgc2V0RXJyb3IoJ+inhOWImeS/ruWkjeWujOaIkO+8jOWmguaciemXrumimOivt+WPjemmiOOAgicpXFxufVwiLFwicGFnZXNcIjpcIltdXCJ9IiwicGljVXJsIjoiaHR0cHM6Ly9pbWcucHkxMDgwcC5jb20vMjAyMC8wNS9jcm9wcGVkLTkwYjA3ZmU1N2Q2MTQyLTE5MngxOTIucG5nQFJlZmVyZXI9IiwidGl0bGUiOiLljoLplb/otYTmupAifQ==
fSZYUbyy,Untitled,MeehoweCK,C++,Saturday 3rd of June 2023 07:57:43 AM CDT,"#include <iostream>

using namespace std;

int main()
{
	int tablica_liczb[10];
	tablica_liczb[4] = 100;

	// wypisanie całej tablicy na ekran konsoli:
	for (int i = 0; i < 10; ++i)
		cout << tablica_liczb[i] << endl;
	return 0;
}"
0x6bcaq6,邀您一起看：更多-英雄联盟,xiaomianao666,JavaScript,Saturday 3rd of June 2023 07:55:20 AM CDT,海阔视界规则分享，当前分享的是：二级页面详情￥page_detail￥更多-英雄联盟@@eyJkYXRhIjoie1wiYXNzb2NpYXRlZE1vZGVsc01hcEZvckpvaW5UYWJsZVwiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhGS1wiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhvdXRGS1wiOnt9LFwiZmllbGRzVG9TZXRUb0RlZmF1bHRcIjpbXSxcImdtdE1vZGlmaWVkXCI6MCxcImlkXCI6MCxcImxhc3RfY2hhcHRlcl9ydWxlXCI6XCJcIixcImxpc3RUb0NsZWFyQXNzb2NpYXRlZEZLXCI6W10sXCJsaXN0VG9DbGVhclNlbGZGS1wiOltdLFwicGFnZUxpc3RcIjpbe1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuS6jOe6p1wiLFwicGF0aFwiOlwiZGV0YWlsXCIsXCJydWxlXCI6XCJqczpcXG52YXIgZCA9IFtdO1xcbnZhciByZXMgPSBKU09OLnBhcnNlKHJlcXVlc3QoXFxcImh0dHA6Ly9saXZlLnlqMTIxMS53b3JrL2FwaS9saXZlL2dldFJvb21JbmZvP3VpZD1cXFwiICsgZ2V0SXRlbShcXFwidWlkXFxcIikgKyBcXFwiJnBsYXRmb3JtPVxcXCIgKyBnZXRQYXJhbShcXFwicGxhdGZvcm1cXFwiKSArIFxcXCImcm9vbUlkPVxcXCIgKyBnZXRQYXJhbShcXFwicm9vbWlkXFxcIikpKVxcbi8v6L+Z5Lik5Liq6ZO+5o6l5LiN5ZCMXFxudmFyIHBsYXl1cmwgPSBKU09OLnBhcnNlKHJlcXVlc3QoXFxcImh0dHA6Ly9saXZlLnlqMTIxMS53b3JrL2FwaS9saXZlL2dldFJlYWxVcmw/cGxhdGZvcm09XFxcIiArIGdldFBhcmFtKFxcXCJwbGF0Zm9ybVxcXCIpICsgXFxcIiZyb29tSWQ9XFxcIiArIGdldFBhcmFtKFxcXCJyb29taWRcXFwiKSkpLmRhdGFcXG52YXIgdWlkID0gZ2V0SXRlbShcXFwidWlkXFxcIilcXG52YXIgZm9sbG93ID0gcmVzLmRhdGEuaXNGb2xsb3dlZFxcbnZhciByb29taWQgPSByZXMuZGF0YS5yb29tSWRcXG52YXIgcGxhdGZvcm0gPSBnZXRQYXJhbShcXFwicGxhdGZvcm1cXFwiKVxcbnN3aXRjaCAocGxhdGZvcm0pIHtcXG4gICAgY2FzZSBcXFwiZG91eXVcXFwiOlxcbiAgICAgICAgdmFyIHVybCA9IFxcXCJodHRwczovL20uZG91eXUuY29tL1xcXCIgKyByb29taWRcXG4gICAgICAgIGJyZWFrXFxuICAgIGNhc2UgXFxcImJpbGliaWxpXFxcIjpcXG4gICAgICAgIHZhciB1cmwgPSBcXFwiaHR0cHM6Ly9saXZlLmJpbGliaWxpLmNvbS9oNS9cXFwiICsgcm9vbWlkXFxuICAgICAgICBicmVha1xcbiAgICBjYXNlIFxcXCJodXlhXFxcIjpcXG4gICAgICAgIHZhciB1cmwgPSBcXFwiaHR0cHM6Ly9tLmh1eWEuY29tL1xcXCIgKyByb29taWRcXG4gICAgICAgIGJyZWFrXFxuICAgIGNhc2UgXFxcImNjXFxcIjpcXG4gICAgICAgIHZhciB1cmwgPSBcXFwiaHR0cHM6Ly9oNS5jYy4xNjMuY29tL2NjL1xcXCIgKyByb29taWRcXG4gICAgICAgIGJyZWFrXFxufVxcbmQucHVzaCh7XFxuICAgIHRpdGxlOiByZXMuZGF0YS5yb29tTmFtZSxcXG4gICAgaW1nOiByZXMuZGF0YS5yb29tUGljICsgXFxcIkBSZWZlcmVyPVxcXCIsXFxuICAgIGRlc2M6IFxcXCLliIbljLrvvJpcXFwiICsgcmVzLmRhdGEucGxhdEZvcm0ucmVwbGFjZSgnaHV5YScsICfomY7niZknKS5yZXBsYWNlKCdkb3V5dScsICfmlpfpsbwnKS5yZXBsYWNlKCdjYycsICfnvZHmmJNDQycpLnJlcGxhY2UoXFxcImJpbGliaWxpXFxcIiwgXFxcIuWTlOWTqeWTlOWTqVxcXCIpICsgJ8K3JyArIHJlcy5kYXRhLmNhdGVnb3J5TmFtZSArIChyZXMuZGF0YS5pc0xpdmUgPT0gMSA/IFxcXCJcXFxcbueKtuaAge+8muato+WcqOebtOaSrVxcXCIgOiBcXFwiXFxcXG7nirbmgIHvvJrmnKrlvIDmkq1cXFwiKSArIFxcXCJcXFxcbueCueWHu+S4i+aWueS4u+aSreWktOWDj+i/m+WFpeWumOe9kVxcXCIsXFxuICAgIHVybDogcmVzLmRhdGEucm9vbVBpYyxcXG4gICAgY29sX3R5cGU6ICdtb3ZpZV8xX3ZlcnRpY2FsX3BpY19ibHVyJyxcXG4gICAgZXh0cmE6IHtcXG4gICAgICAgIGdyYWRpZW50OiB0cnVlXFxuICAgIH1cXG59KVxcbmQucHVzaCh7XFxuICAgIHRpdGxlOiByZXMuZGF0YS5vd25lck5hbWUsXFxuICAgIGltZzogcmVzLmRhdGEub3duZXJIZWFkUGljICsgXFxcIkBSZWZlcmVyPVxcXCIsXFxuICAgIHVybDogdXJsLFxcbiAgICBjb2xfdHlwZTogXFxcImljb25fMl9yb3VuZFxcXCJcXG59KVxcbmQucHVzaCh7XFxuICAgIHRpdGxlOiByZXMuZGF0YS5pc0ZvbGxvd2VkID09IDEgPyBcXFwi5bey5YWz5rOoXFxcIiA6IFxcXCLmnKrlhbPms6hcXFwiLFxcbiAgICB1cmw6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKHVpZCwgcm9vbWlkLCBwbGF0Zm9ybSwgZm9sbG93KSA9PiB7XFxuICAgICAgICBpZiAoZm9sbG93ID09IDApIHtcXG4gICAgICAgICAgICB2YXIgcmVzID0gSlNPTi5wYXJzZShyZXF1ZXN0KFxcXCJodHRwOi8vMTI0LjIyMi41LjEzMTo4MDEzL2FwaS9saXZlL2ZvbGxvdz9wbGF0Zm9ybT1cXFwiICsgcGxhdGZvcm0gKyBcXFwiJnJvb21JZD1cXFwiICsgcm9vbWlkICsgXFxcIiZ1aWQ9XFxcIiArIHVpZCkpXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKVxcbiAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly9cXFwiICsgcmVzLmRhdGFcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgdmFyIHJlcyA9IEpTT04ucGFyc2UocmVxdWVzdChcXFwiaHR0cDovLzEyNC4yMjIuNS4xMzE6ODAxMy9hcGkvbGl2ZS91bkZvbGxvdz9wbGF0Zm9ybT1cXFwiICsgcGxhdGZvcm0gKyBcXFwiJnJvb21JZD1cXFwiICsgcm9vbWlkICsgXFxcIiZ1aWQ9XFxcIiArIHVpZCkpXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKVxcbiAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly9cXFwiICsgcmVzLmRhdGFcXG4gICAgICAgIH1cXG4gICAgfSwgdWlkLCByb29taWQsIHBsYXRmb3JtLCBmb2xsb3cpLFxcbiAgICBjb2xfdHlwZTogXFxcInRleHRfMlxcXCJcXG59KVxcbnZhciBuYW1lID0ge1xcbiAgICBcXFwiT0RcXFwiOiBcXFwi5Y6f55S7XFxcIixcXG4gICAgXFxcIkZEXFxcIjogXFxcIua1geeVhVxcXCIsXFxuICAgIFxcXCJMRFxcXCI6IFxcXCLmoIfmuIVcXFwiLFxcbiAgICBcXFwiU0RcXFwiOiBcXFwi6auY5riFXFxcIixcXG4gICAgXFxcIkhEXFxcIjogXFxcIui2hea4hVxcXCIsXFxuICAgIFxcXCIyS1xcXCI6IFxcXCIyS1xcXCIsXFxuICAgIFxcXCI0S1xcXCI6IFxcXCI0S1xcXCIsXFxuICAgIFxcXCJGSERcXFwiOiBcXFwi5YWo6auY5riFXFxcIixcXG4gICAgXFxcIlhMRFxcXCI6IFxcXCLmnoHpgJ9cXFwiLFxcbiAgICBcXFwiU1FcXFwiOiBcXFwi5pmu6YCa6Z+z6LSoXFxcIixcXG4gICAgXFxcIkhRXFxcIjogXFxcIumrmOmfs+i0qFxcXCJcXG59XFxudmFyIHVybHMgPSBbXVxcbnZhciBuYW1lcyA9IFtdXFxuZm9yICh2YXIga2V5IGluIHBsYXl1cmwpIHtcXG4gICAgaWYgKCEvYXl5dWlkfHRvLy50ZXN0KGtleSkpIHtcXG4gICAgICAgIHVybHMucHVzaChwbGF5dXJsW2tleV0pXFxuICAgICAgICBuYW1lcy5wdXNoKG5hbWVba2V5XSlcXG4gICAgfVxcbn1cXG5kLnB1c2goe1xcbiAgICBjb2xfdHlwZTogXFxcImxpbmVfYmxhbmtcXFwiXFxufSlcXG5kLnB1c2goe1xcbiAgICB0aXRsZTogXFxcIumAieaLqeeUu+i0qFxcXCIsXFxuICAgIHVybDogXFxcImhpa2VyOi8vZW1wdHlcXFwiLFxcbiAgICBjb2xfdHlwZTogXFxcInRleHRfY2VudGVyXzFcXFwiXFxufSlcXG5mb3IgKHZhciBpIGluIG5hbWVzKSB7XFxuICAgIGQucHVzaCh7XFxuICAgICAgICB0aXRsZTogbmFtZXNbaV0sXFxuICAgICAgICB1cmw6IHBsYXRmb3JtID09IFxcXCJkb3V5dVxcXCIgPyBKU09OLnN0cmluZ2lmeSh7XFxuICAgICAgICAgICAgdXJsczogW3VybHNbaV1dLFxcbiAgICAgICAgICAgIGRhbm11OiAnd2ViOi8vaHR0cDovL2RvdXl1X2Rhbm11LmRldi50eXJhbnRnLmNvbS8/cmlkPScgKyByb29taWQgKyAnJnZlcj0xJ1xcbiAgICAgICAgfSkgOiB1cmxzW2ldLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzJcXFwiXFxuICAgIH0pXFxufVxcbnNldFJlc3VsdChkKTtcIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzJcIixcIm5hbWVcIjpcIuWFs+azqOWIl+ihqFwiLFwicGF0aFwiOlwiaGlzdG9yeVwiLFwicnVsZVwiOlwianM6XFxudmFyIGQgPSBbXTtcXG5zZXRQYWdlVGl0bGUoXFxcIuWFs+azqFxcXCIpXFxuZC5wdXNoKHtcXG4gICAgdGl0bGU6IGdldEl0ZW0oXFxcIm5pY2tuYW1lXFxcIiksXFxuICAgIHVybDogJChcXFwi5piv5ZCm5rOo6ZSA77yfXFxcIikuY29uZmlybSgoKSA9PiB7XFxuICAgICAgICBzZXRJdGVtKFxcXCJ1aWRcXFwiLCBcXFwiXFxcIilcXG4gICAgICAgIHNldEl0ZW0oXFxcIm5pY2tuYW1lXFxcIiwgXFxcIuacqueZu+mZhlxcXCIpXFxuICAgICAgICBiYWNrKHRydWUpXFxuICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5rOo6ZSA5oiQ5YqfXFxcIlxcbiAgICB9KSxcXG4gICAgaW1nOiBcXFwiaHR0cHM6Ly9sYW5tZWlndW9qaWFuZy5jb20vdHViaWFvL2tlLzczLnBuZ1xcXCIsXFxuICAgIGNvbF90eXBlOiBcXFwiYXZhdGFyXFxcIlxcbn0pXFxuaWYgKGdldEl0ZW0oXFxcInVpZFxcXCIsIFxcXCJcXFwiKSA9PSBcXFwiXFxcIikge1xcbiAgICBkLnB1c2goe1xcbiAgICAgICAgZGVzYzogXFxcIui0puWPt1xcXCIsXFxuICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgIG9uQ2hhbmdlOiBcXFwic2V0SXRlbSgnYWNjb3VudCcsaW5wdXQpXFxcIixcXG4gICAgICAgICAgICB0aXRsZVZpc2libGU6IGZhbHNlXFxuICAgICAgICB9LFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJpbnB1dFxcXCJcXG4gICAgfSlcXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIGRlc2M6IFxcXCLlr4bnoIFcXFwiLFxcbiAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICBvbkNoYW5nZTogXFxcInNldEl0ZW0oJ3Bhc3N3b3JkJyxpbnB1dClcXFwiLFxcbiAgICAgICAgICAgIHRpdGxlVmlzaWJsZTogZmFsc2VcXG4gICAgICAgIH0sXFxuICAgICAgICBjb2xfdHlwZTogXFxcImlucHV0XFxcIlxcbiAgICB9KVxcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6IFxcXCLnoa7lrppcXFwiLFxcbiAgICAgICAgdXJsOiAkKCkubGF6eVJ1bGUoKCkgPT4ge1xcbiAgICAgICAgICAgIGJhY2soKVxcbiAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/ov5Tlm57oh6rliqjnmbvpmYZcXFwiXFxuICAgICAgICB9KSxcXG4gICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF9jZW50ZXJfMVxcXCJcXG4gICAgfSlcXG59XFxudmFyIHJlcyA9IEpTT04ucGFyc2UocmVxdWVzdChcXFwiaHR0cDovL2xpdmUueWoxMjExLndvcmsvYXBpL2xpdmUvZ2V0Um9vbXNPbj91aWQ9XFxcIiArIGdldEl0ZW0oXFxcInVpZFxcXCIpKSlcXG52YXIgcmVzID0gcmVzLmRhdGFcXG4vL2xvZyhyZXMpXFxudmFyIHNUeXBlID0gZ2V0TXlWYXIoXFxcInNUeXBlXFxcIikgPyBnZXRNeVZhcihcXFwic1R5cGVcXFwiKSA6IFxcXCJsaXZpbmdcXFwiXFxuZC5wdXNoKHtcXG4gICAgdGl0bGU6IHNUeXBlID09IFxcXCJsaXZpbmdcXFwiID8gJ+KAmOKAmOKAmeKAmTxzdHJvbmc+PGZvbnQgY29sb3I9XFxcIiNGQTcyOThcXFwiPuato+WcqOebtOaSrTwvZnJvbnQ+PC9zdHJvbmc+JyA6IFxcXCLmraPlnKjnm7Tmkq1cXFwiLFxcbiAgICB1cmw6ICQoKS5sYXp5UnVsZSgoc1R5cGUpID0+IHtcXG4gICAgICAgIHB1dE15VmFyKFxcXCJzVHlwZVxcXCIsIHNUeXBlID09ICdsaXZpbmcnID8gJ291dGxpbmUnIDogJ2xpdmluZycpO1xcbiAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXG4gICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCJcXG4gICAgfSwgc1R5cGUpLFxcbiAgICBjb2xfdHlwZTogXFxcInRleHRfMlxcXCJcXG59KVxcbmQucHVzaCh7XFxuICAgIHRpdGxlOiBzVHlwZSA9PSBcXFwib3V0bGluZVxcXCIgPyAn4oCY4oCY4oCZ4oCZPHN0cm9uZz48Zm9udCBjb2xvcj1cXFwiI0ZBNzI5OFxcXCI+5pyq55u05pKtPC9mcm9udD48L3N0cm9uZz4nIDogXFxcIuacquebtOaSrVxcXCIsXFxuICAgIHVybDogJCgpLmxhenlSdWxlKChzVHlwZSkgPT4ge1xcbiAgICAgICAgcHV0TXlWYXIoXFxcInNUeXBlXFxcIiwgc1R5cGUgPT0gJ291dGxpbmUnID8gJ2xpdmluZycgOiAnb3V0bGluZScpO1xcbiAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXG4gICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCJcXG4gICAgfSwgc1R5cGUpLFxcbiAgICBjb2xfdHlwZTogXFxcInRleHRfMlxcXCJcXG59KVxcbmlmIChzVHlwZSA9PSBcXFwibGl2aW5nXFxcIikge1xcbiAgICBmb3IgKHZhciBpIGluIHJlcykge1xcbiAgICAgICAgdmFyIHRlbXAgPSByZXNbaV1cXG4gICAgICAgIGlmICh0ZW1wLmlzTGl2ZSA9PSAxKSB7XFxuICAgICAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRlbXAuY2F0ZWdvcnlOYW1lICsgJ8K3JyArIHRlbXAucm9vbU5hbWUsXFxuICAgICAgICAgICAgICAgIGRlc2M6IHRlbXAucGxhdEZvcm0ucmVwbGFjZSgnaHV5YScsICfomY7niZknKS5yZXBsYWNlKCdkb3V5dScsICfmlpfpsbwnKS5yZXBsYWNlKCdjYycsICfnvZHmmJNDQycpLnJlcGxhY2UoXFxcImJpbGliaWxpXFxcIiwgXFxcIuWTlOWTqeWTlOWTqVxcXCIpICsgJ8K3JyArIHRlbXAub3duZXJOYW1lLFxcbiAgICAgICAgICAgICAgICBpbWc6IHRlbXAucm9vbVBpYyArIFxcXCJAUmVmZXJlcj1cXFwiLFxcbiAgICAgICAgICAgICAgICB1cmw6IFxcXCJoaWtlcjovL3BhZ2UvZGV0YWlsPyNpbW1lcnNpdmVUaGVtZSMmcm9vbWlkPVxcXCIgKyB0ZW1wLnJvb21JZCArIFxcXCImcGxhdGZvcm09XFxcIiArIHRlbXAucGxhdEZvcm1cXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgfVxcbiAgICB9XFxufSBlbHNlIHtcXG4gICAgZm9yICh2YXIgaSBpbiByZXMpIHtcXG4gICAgICAgIHZhciB0ZW1wID0gcmVzW2ldXFxuICAgICAgICBpZiAodGVtcC5pc0xpdmUgPT0gMCkge1xcbiAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiB0ZW1wLm93bmVyTmFtZSxcXG4gICAgICAgICAgICAgICAgaW1nOiB0ZW1wLm93bmVySGVhZFBpYyArIFxcXCJAUmVmZXJlcj1cXFwiLFxcbiAgICAgICAgICAgICAgICB1cmw6IFxcXCJoaWtlcjovL3BhZ2UvZGV0YWlsPyNpbW1lcnNpdmVUaGVtZSMmcm9vbWlkPVxcXCIgKyB0ZW1wLnJvb21JZCArIFxcXCImcGxhdGZvcm09XFxcIiArIHRlbXAucGxhdEZvcm1cXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgfVxcbiAgICB9XFxufVxcbnNldFJlc3VsdChkKTtcIn0se1wiY29sX3R5cGVcIjpcInRleHRfM1wiLFwibmFtZVwiOlwi5YWo6YOo5YiG57G7XCIsXCJwYXRoXCI6XCJuZXdDbGFzc1wiLFwicnVsZVwiOlwianM6XFxudmFyIGQgPSBbXTtcXG5hZGRMaXN0ZW5lcignb25DbG9zZScsICQudG9TdHJpbmcoKCkgPT4ge1xcbiAgICBjbGVhck15VmFyKCdNeWZsJylcXG4gICAgY2xlYXJNeVZhcignTXlwdCcpXFxufSkpXFxuZC5wdXNoKHtcXG4gICAgdGl0bGU6IGdldE15VmFyKFxcXCJNeWZsXFxcIiwgXFxcIuadv+Wdl1xcXCIpID09IFxcXCLmnb/lnZdcXFwiID8gXFxcIvCflLTniYjlnZfliIbnsbtcXFwiIDogXFxcIuKaqu+4j+adv+Wdl+WIhuexu1xcXCIsXFxuICAgIHVybDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoKSA9PiB7XFxuICAgICAgICByZWZyZXNoUGFnZSgpO1xcbiAgICAgICAgcHV0TXlWYXIoXFxcIk15ZmxcXFwiLCAn5p2/5Z2XJylcXG4gICAgICAgIGNsZWFyTXlWYXIoJ015ZmwnKVxcbiAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL2VtcHR5XFxcIlxcbiAgICB9KSxcXG4gICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzJcXFwiXFxufSlcXG5kLnB1c2goe1xcbiAgICB0aXRsZTogZ2V0TXlWYXIoXFxcIk15ZmxcXFwiKSA9PSBcXFwi5bmz5Y+wXFxcIiA/IFxcXCLwn5S05bmz5Y+w5YiG57G7XFxcIiA6IFxcXCLimqrvuI/lubPlj7DliIbnsbtcXFwiLFxcbiAgICB1cmw6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKCkgPT4ge1xcbiAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXG4gICAgICAgIHB1dE15VmFyKFxcXCJNeWZsXFxcIiwgJ+W5s+WPsCcpXFxuICAgICAgICBjbGVhck15VmFyKCdNeXB0JylcXG4gICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCJcXG4gICAgfSksXFxuICAgIGNvbF90eXBlOiBcXFwidGV4dF8yXFxcIlxcbn0pXFxuXFxuLy/lubPlj7DliIbnsbtcXG5pZiAoZ2V0TXlWYXIoXFxcIk15ZmxcXFwiKSkge1xcbiAgICBsZXQgdGl0bGUgPSBnZXRNeVZhcihcXFwiTXlwdFxcXCIpLnJlcGxhY2UoJ2RvdXl1JywgJ+aWl+mxvCcpLnJlcGxhY2UoJ2h1eWEnLCAn6JmO54mZJykucmVwbGFjZSgnYmlsaWJpbGknLCAn5ZOU5ZOpJykucmVwbGFjZSgnY2MnLCAn572R5piTJylcXG4gICAgbGV0IGltZyA9IGdldE15VmFyKFxcXCJNeXB0XFxcIikucmVwbGFjZSgnZG91eXUnLCAnaHR0cHM6Ly9iLmJkc3RhdGljLmNvbS9zZWFyY2hib3gvbWFwcGNvbnNvbGUvaW1hZ2UvMjAxODA4MDgvMTUzMzY5ODA0NTEwNTI3Ni5wbmdAUmVmZXJlcj0nKS5yZXBsYWNlKCdodXlhJywgJ2h0dHBzOi8vbWJzMS5iZHN0YXRpYy5jb20vc2VhcmNoYm94L21hcHBjb25zb2xlL2ltYWdlLzIwMjAwOTE1LzU4ZDNlMzgwLTgxOGItNDkxYS1hOTczLTFlZjQ3YWE1ZTg3Zi5qcGdAUmVmZXJlcj0nKS5yZXBsYWNlKCdiaWxpYmlsaScsICdodHRwczovL2IuYmRzdGF0aWMuY29tL3NlYXJjaGJveC9tYXBwY29uc29sZS9pbWFnZS8yMDE4MTAzMC8xNTQwODg5MDM4MTU5ODYyLnBuZ0BSZWZlcmVyPScpLnJlcGxhY2UoJ2NjJywgJ2h0dHBzOi8vY2MuZnAucHMubmV0ZWFzZS5jb20vZmlsZS82MGEzMWQzZTdmOWQyYTM5MTIwYmVhMDE2THA3WkVlMTAzQFJlZmVyZXI9JylcXG5cXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBcXFwi5paX6bG8XFxcIixcXG4gICAgICAgIHVybDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoKSA9PiB7XFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXG4gICAgICAgICAgICBwdXRNeVZhcihcXFwiTXlwdFxcXCIsICdkb3V5dScpXFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL2VtcHR5XFxcIlxcbiAgICAgICAgfSksXFxuICAgICAgICBpbWc6IFxcXCJodHRwczovL2IuYmRzdGF0aWMuY29tL3NlYXJjaGJveC9tYXBwY29uc29sZS9pbWFnZS8yMDE4MDgwOC8xNTMzNjk4MDQ1MTA1Mjc2LnBuZ0BSZWZlcmVyPVxcXCIsXFxuICAgICAgICBjb2xfdHlwZTogXFxcImljb25fcm91bmRfc21hbGxfNFxcXCJcXG4gICAgfSlcXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiAn6JmO54mZJyxcXG4gICAgICAgIHVybDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoKSA9PiB7XFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXG4gICAgICAgICAgICBwdXRNeVZhcihcXFwiTXlwdFxcXCIsICdodXlhJylcXG4gICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiXFxuICAgICAgICB9KSxcXG4gICAgICAgIGltZzogXFxcImh0dHBzOi8vbWJzMS5iZHN0YXRpYy5jb20vc2VhcmNoYm94L21hcHBjb25zb2xlL2ltYWdlLzIwMjAwOTE1LzU4ZDNlMzgwLTgxOGItNDkxYS1hOTczLTFlZjQ3YWE1ZTg3Zi5qcGdAUmVmZXJlcj1cXFwiLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJpY29uX3JvdW5kX3NtYWxsXzRcXFwiXFxuICAgIH0pXFxuICAgIGQucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIuWTlOWTqVxcXCIsXFxuICAgICAgICB1cmw6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKCkgPT4ge1xcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICAgICAgcHV0TXlWYXIoXFxcIk15cHRcXFwiLCAnYmlsaWJpbGknKVxcbiAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCJcXG4gICAgICAgIH0pLFxcbiAgICAgICAgaW1nOiBcXFwiaHR0cHM6Ly9iLmJkc3RhdGljLmNvbS9zZWFyY2hib3gvbWFwcGNvbnNvbGUvaW1hZ2UvMjAxODEwMzAvMTU0MDg4OTAzODE1OTg2Mi5wbmdAUmVmZXJlcj1cXFwiLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJpY29uX3JvdW5kX3NtYWxsXzRcXFwiXFxuICAgIH0pXFxuICAgIGQucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIue9keaYk1xcXCIsXFxuICAgICAgICB1cmw6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKCkgPT4ge1xcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICAgICAgcHV0TXlWYXIoXFxcIk15cHRcXFwiLCAnY2MnKVxcbiAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCJcXG4gICAgICAgIH0pLFxcbiAgICAgICAgaW1nOiBcXFwiaHR0cHM6Ly9jYy5mcC5wcy5uZXRlYXNlLmNvbS9maWxlLzYwYTMxZDNlN2Y5ZDJhMzkxMjBiZWEwMTZMcDdaRWUxMDNAUmVmZXJlcj1cXFwiLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJpY29uX3JvdW5kX3NtYWxsXzRcXFwiXFxuICAgIH0pXFxuICAgIGQucHVzaCh7XFxuICAgICAgICBjb2xfdHlwZTogXFxcImJpZ19ibGFua19ibG9ja1xcXCJcXG4gICAgfSlcXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIGNvbF90eXBlOiBcXFwiYmlnX2JsYW5rX2Jsb2NrXFxcIlxcbiAgICB9KVxcbiAgICBkLnB1c2goe1xcbiAgICAgICAgY29sX3R5cGU6IFxcXCJsaW5lXFxcIlxcbiAgICB9KVxcbiAgICBkLnB1c2goe1xcbiAgICAgICAgY29sX3R5cGU6IFxcXCJiaWdfYmxhbmtfYmxvY2tcXFwiXFxuICAgIH0pXFxuICAgIGQucHVzaCh7XFxuICAgICAgICBjb2xfdHlwZTogXFxcImJpZ19ibGFua19ibG9ja1xcXCJcXG4gICAgfSlcXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBnZXRNeVZhcihcXFwiTXlwdFxcXCIpID8gdGl0bGUgKyBcXFwi5YiG57G7XFxcIiA6IFxcXCLomY7niZnliIbnsbtcXFwiLFxcbiAgICAgICAgdXJsOiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCIsXFxuICAgICAgICBpbWc6IGdldE15VmFyKFxcXCJNeXB0XFxcIikgPyBpbWcgOiBcXFwiaHR0cHM6Ly9tYnMxLmJkc3RhdGljLmNvbS9zZWFyY2hib3gvbWFwcGNvbnNvbGUvaW1hZ2UvMjAyMDA5MTUvNThkM2UzODAtODE4Yi00OTFhLWE5NzMtMWVmNDdhYTVlODdmLmpwZ0BSZWZlcmVyPVxcXCIsXFxuICAgICAgICBjb2xfdHlwZTogXFxcImF2YXRhclxcXCJcXG4gICAgfSlcXG4gICAgaWYgKGdldE15VmFyKFxcXCJNeXB0XFxcIikpIHtcXG4gICAgICAgIHZhciBwdF91cmwgPSBcXFwiaHR0cDovL2xpdmUueWoxMjExLndvcmsvYXBpL2xpdmUvZ2V0QXJlYXM/cGxhdGZvcm09XFxcIiArIGdldE15VmFyKFxcXCJNeXB0XFxcIilcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHZhciBwdF91cmwgPSBcXFwiaHR0cDovL2xpdmUueWoxMjExLndvcmsvYXBpL2xpdmUvZ2V0QXJlYXM/cGxhdGZvcm09aHV5YVxcXCJcXG4gICAgfVxcblxcbiAgICB2YXIgcmVzID0gSlNPTi5wYXJzZShyZXF1ZXN0KHB0X3VybCkpLmRhdGE7XFxuICAgIC8vbG9nKHJlcylcXG4gICAgZm9yIChsZXQgaiBpbiByZXMpIHtcXG4gICAgICAgIHZhciB0ZW1wID0gcmVzW2pdXFxuICAgICAgICBmb3IgKGRhdGEgb2YgdGVtcClcXG4gICAgICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgICAgICB0aXRsZTogZGF0YS5hcmVhTmFtZSxcXG4gICAgICAgICAgICAgICAgaW1nOiBkYXRhLmFyZWFQaWMgKyBcXFwiQFJlZmVyZXI9XFxcIixcXG4gICAgICAgICAgICAgICAgdXJsOiBcXFwiaGlrZXI6Ly9wYWdlL25ld0NsYXNzTGlzdD9wYWdlPWZ5cGFnZSZwbGF0Zm9ybT1cXFwiICsgZGF0YS5wbGF0Zm9ybSArIFxcXCImYXJlYT1cXFwiICsgZGF0YS5hcmVhTmFtZSxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJpY29uX3JvdW5kXzRcXFwiXFxuICAgICAgICAgICAgfSlcXG4gICAgfVxcbn0gZWxzZSB7XFxuICAgIGQucHVzaCh7XFxuICAgICAgICBjb2xfdHlwZTogXFxcImJpZ19ibGFua19ibG9ja1xcXCJcXG4gICAgfSlcXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIGNvbF90eXBlOiBcXFwiYmlnX2JsYW5rX2Jsb2NrXFxcIlxcbiAgICB9KVxcbiAgICBkLnB1c2goe1xcbiAgICAgICAgY29sX3R5cGU6IFxcXCJsaW5lXFxcIlxcbiAgICB9KVxcbiAgICBkLnB1c2goe1xcbiAgICAgICAgY29sX3R5cGU6IFxcXCJiaWdfYmxhbmtfYmxvY2tcXFwiXFxuICAgIH0pXFxuICAgIGQucHVzaCh7XFxuICAgICAgICBjb2xfdHlwZTogXFxcImJpZ19ibGFua19ibG9ja1xcXCJcXG4gICAgfSlcXG5cXG4gICAgLy/niYjlnZfliIbnsbtcXG4gICAgdmFyIHVybCA9ICdodHRwOi8vbGl2ZS55ajEyMTEud29yay9hcGkvbGl2ZS9nZXRBbGxBcmVhcyc7XFxuICAgIHZhciByZXMgPSBKU09OLnBhcnNlKHJlcXVlc3QodXJsKSkuZGF0YTtcXG4gICAgLy9sb2cocmVzKVxcblxcbiAgICB2YXIgdHlwZU5hbWVzID0gW107XFxuICAgIHZhciBiaWdMaXN0ID0gW107XFxuICAgIHZhciBzbWFsbExpc3QgPSBbXTtcXG4gICAgcHV0TXlWYXIoXFxcInR5cGVOYW1lVmFyXFxcIiwgIWdldE15VmFyKCd0eXBlTmFtZVZhcicpID8gJ+WFqOmDqCcgOiBnZXRNeVZhcigndHlwZU5hbWVWYXInKSk7XFxuICAgIHB1dE15VmFyKCdhcmVhJywgJ2FyZWFOYW1lJylcXG4gICAgZm9yIChsZXQgciBvZiByZXMpIHtcXG4gICAgICAgIGZvciAobGV0IHggb2Ygcikge1xcbiAgICAgICAgICAgIGlmICghdHlwZU5hbWVzLmluY2x1ZGVzKHgudHlwZU5hbWUpKSB7XFxuICAgICAgICAgICAgICAgIHR5cGVOYW1lcy5wdXNoKHgudHlwZU5hbWUpO1xcbiAgICAgICAgICAgICAgICBiaWdMaXN0LnB1c2goe1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGdldE15VmFyKFxcXCJ0eXBlTmFtZVZhclxcXCIpID09IHgudHlwZU5hbWUgPyAn4oCY4oCY4oCZ4oCZPHN0cm9uZz48Zm9udCBjb2xvcj1cXFwiI0ZBNzI5OFxcXCI+JyArIHgudHlwZU5hbWUgKyAnPC9mcm9udD48L3N0cm9uZz4nIDogeC50eXBlTmFtZSxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgodHlwZU5hbWVWYXIpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFwidHlwZU5hbWVWYXJcXFwiLCB0eXBlTmFtZVZhcik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiXFxuICAgICAgICAgICAgICAgICAgICB9LCB4LnR5cGVOYW1lKSxcXG4gICAgICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwic2Nyb2xsX2J1dHRvblxcXCJcXG4gICAgICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgc21hbGxMaXN0LnB1c2goe1xcbiAgICAgICAgICAgICAgICB0aXRsZTogeC5hcmVhTmFtZSxcXG4gICAgICAgICAgICAgICAgdXJsOiAnaGlrZXI6Ly9wYWdlL25ld0NsYXNzTGlzdD90eXBlTmFtZT0nICsgeC50eXBlTmFtZSArICcmYXJlYU5hbWU9JyArIHguYXJlYU5hbWUgKyBcXFwiJnBhZ2U9ZnlwYWdlXFxcIixcXG4gICAgICAgICAgICAgICAgaW1nOiB4LmFyZWFQaWMgKyBcXFwiQFJlZmVyZXI9XFxcIixcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJpY29uX3JvdW5kXzRcXFwiLFxcbiAgICAgICAgICAgICAgICB0eXBlTmFtZTogeC50eXBlTmFtZVxcbiAgICAgICAgICAgIH0pXFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgYmlnTGlzdC51bnNoaWZ0KHtcXG4gICAgICAgIHRpdGxlOiBnZXRNeVZhcihcXFwidHlwZU5hbWVWYXJcXFwiKSA9PSAn5YWo6YOoJyA/ICfigJjigJjigJnigJk8c3Ryb25nPjxmb250IGNvbG9yPVxcXCIjRkE3Mjk4XFxcIj7lhajpg6g8L2Zyb250Pjwvc3Ryb25nPicgOiAn5YWo6YOoJyxcXG4gICAgICAgIHVybDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgodHlwZU5hbWVWYXIpID0+IHtcXG4gICAgICAgICAgICBwdXRNeVZhcihcXFwidHlwZU5hbWVWYXJcXFwiLCB0eXBlTmFtZVZhcik7XFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXG4gICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiXFxuICAgICAgICB9LCAn5YWo6YOoJyksXFxuICAgICAgICBjb2xfdHlwZTogXFxcInNjcm9sbF9idXR0b25cXFwiXFxuICAgIH0pXFxuICAgIGQgPSBkLmNvbmNhdChiaWdMaXN0KTtcXG5cXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIGNvbF90eXBlOiBcXFwiYmlnX2JsYW5rX2Jsb2NrXFxcIlxcbiAgICB9KVxcblxcbiAgICAvL2xvZyhnZXRNeVZhcigndHlwZU5hbWVWYXInKSlcXG4gICAgaWYgKGdldE15VmFyKCd0eXBlTmFtZVZhcicpID09ICflhajpg6gnKSB7XFxuICAgICAgICBkID0gZC5jb25jYXQoc21hbGxMaXN0KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGQgPSBkLmNvbmNhdChzbWFsbExpc3QuZmlsdGVyKHMgPT4gcy50eXBlTmFtZSA9PSBnZXRNeVZhcigndHlwZU5hbWVWYXInKSkpO1xcbiAgICB9XFxufVxcbnNldFJlc3VsdChkKTtcIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzJcIixcIm5hbWVcIjpcIuaAu+WIl+ihqFwiLFwicGF0aFwiOlwibmV3Q2xhc3NMaXN0XCIsXCJydWxlXCI6XCJqczpcXG52YXIgZCA9IFtdO1xcbmFkZExpc3RlbmVyKCdvbkNsb3NlJywgJC50b1N0cmluZygoKSA9PiB7XFxuICAgIGNsZWFyTXlWYXIoJ015ZnJvJylcXG59KSlcXG5pZiAoTVlfUEFHRSA9PSAxKSB7XFxuICAgIGxldCB0aXRsZSA9IGdldE15VmFyKFxcXCJNeWZyb1xcXCIpLnJlcGxhY2UoJ2RvdXl1JywgJ+aWl+mxvCcpLnJlcGxhY2UoJ2h1eWEnLCAn6JmO54mZJykucmVwbGFjZSgnYmlsaWJpbGknLCAn5ZOU5ZOpJykucmVwbGFjZSgnY2MnLCAn572R5piTJylcXG4gICAgbGV0IGltZyA9IGdldE15VmFyKFxcXCJNeWZyb1xcXCIpLnJlcGxhY2UoJ2RvdXl1JywgJ2h0dHBzOi8vYi5iZHN0YXRpYy5jb20vc2VhcmNoYm94L21hcHBjb25zb2xlL2ltYWdlLzIwMTgwODA4LzE1MzM2OTgwNDUxMDUyNzYucG5nQFJlZmVyZXI9JykucmVwbGFjZSgnaHV5YScsICdodHRwczovL21iczEuYmRzdGF0aWMuY29tL3NlYXJjaGJveC9tYXBwY29uc29sZS9pbWFnZS8yMDIwMDkxNS81OGQzZTM4MC04MThiLTQ5MWEtYTk3My0xZWY0N2FhNWU4N2YuanBnQFJlZmVyZXI9JykucmVwbGFjZSgnYmlsaWJpbGknLCAnaHR0cHM6Ly9iLmJkc3RhdGljLmNvbS9zZWFyY2hib3gvbWFwcGNvbnNvbGUvaW1hZ2UvMjAxODEwMzAvMTU0MDg4OTAzODE1OTg2Mi5wbmdAUmVmZXJlcj0nKS5yZXBsYWNlKCdjYycsICdodHRwczovL2NjLmZwLnBzLm5ldGVhc2UuY29tL2ZpbGUvNjBhMzFkM2U3ZjlkMmEzOTEyMGJlYTAxNkxwN1pFZTEwM0BSZWZlcmVyPScpXFxuICAgIGQucHVzaCh7XFxuICAgICAgICB0aXRsZTogZ2V0TXlWYXIoXFxcIk15ZnJvXFxcIikgPT0gJycgPyAn5YiH5o2i5bmz5Y+wJyA6IHRpdGxlICsgJ+W5s+WPsCcsXFxuICAgICAgICB1cmw6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKCkgPT4ge1xcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICAgICAgY2xlYXJNeVZhcihcXFwiTXlmcm9cXFwiKVxcbiAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCJcXG4gICAgICAgIH0pLFxcbiAgICAgICAgaW1nOiBnZXRNeVZhcihcXFwiTXlmcm9cXFwiKSA9PSAnJyA/ICdodHRwczovL2xhbm1laWd1b2ppYW5nLmNvbS90dWJpYW8vbWVzc3kvNS5zdmdAUmVmZXJlcj0nIDogaW1nLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJhdmF0YXJcXFwiXFxuICAgIH0pXFxuXFxuICAgIGQucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIuaWl+mxvFxcXCIsXFxuICAgICAgICBpbWc6IFxcXCJodHRwczovL2IuYmRzdGF0aWMuY29tL3NlYXJjaGJveC9tYXBwY29uc29sZS9pbWFnZS8yMDE4MDgwOC8xNTMzNjk4MDQ1MTA1Mjc2LnBuZ0BSZWZlcmVyPVxcXCIsXFxuICAgICAgICB1cmw6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKCkgPT4ge1xcbiAgICAgICAgICAgIHB1dE15VmFyKFxcXCJNeWZyb1xcXCIsICdkb3V5dScpO1xcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL2VtcHR5XFxcIlxcbiAgICAgICAgfSksXFxuICAgICAgICDCoGNvbF90eXBlOiBcXFwiaWNvbl9yb3VuZF9zbWFsbF80XFxcIixcXG4gICAgfSlcXG5cXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBcXFwi6JmO54mZXFxcIixcXG4gICAgICAgIGltZzogXFxcImh0dHBzOi8vbWJzMS5iZHN0YXRpYy5jb20vc2VhcmNoYm94L21hcHBjb25zb2xlL2ltYWdlLzIwMjAwOTE1LzU4ZDNlMzgwLTgxOGItNDkxYS1hOTczLTFlZjQ3YWE1ZTg3Zi5qcGdAUmVmZXJlcj1cXFwiLFxcbiAgICAgICAgdXJsOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKCgpID0+IHtcXG4gICAgICAgICAgICBwdXRNeVZhcihcXFwiTXlmcm9cXFwiLCAnaHV5YScpO1xcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL2VtcHR5XFxcIlxcbiAgICAgICAgfSksXFxuICAgICAgICDCoGNvbF90eXBlOiBcXFwiaWNvbl9yb3VuZF9zbWFsbF80XFxcIixcXG4gICAgfSlcXG5cXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBcXFwi5ZOU5ZOpXFxcIixcXG4gICAgICAgIGltZzogXFxcImh0dHBzOi8vYi5iZHN0YXRpYy5jb20vc2VhcmNoYm94L21hcHBjb25zb2xlL2ltYWdlLzIwMTgxMDMwLzE1NDA4ODkwMzgxNTk4NjIucG5nQFJlZmVyZXI9XFxcIixcXG4gICAgICAgIHVybDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoKSA9PiB7XFxuICAgICAgICAgICAgcHV0TXlWYXIoXFxcIk15ZnJvXFxcIiwgJ2JpbGliaWxpJyk7XFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXG4gICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiXFxuICAgICAgICB9KSxcXG4gICAgICAgIMKgY29sX3R5cGU6IFxcXCJpY29uX3JvdW5kX3NtYWxsXzRcXFwiLFxcbiAgICB9KVxcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6IFxcXCLnvZHmmJNcXFwiLFxcbiAgICAgICAgaW1nOiBcXFwiaHR0cHM6Ly9jYy5mcC5wcy5uZXRlYXNlLmNvbS9maWxlLzYwYTMxZDNlN2Y5ZDJhMzkxMjBiZWEwMTZMcDdaRWUxMDNAUmVmZXJlcj1cXFwiLFxcbiAgICAgICAgdXJsOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKCgpID0+IHtcXG4gICAgICAgICAgICBwdXRNeVZhcihcXFwiTXlmcm9cXFwiLCAnY2MnKTtcXG4gICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcbiAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCJcXG4gICAgICAgIH0pLFxcbiAgICAgICAgwqBjb2xfdHlwZTogXFxcImljb25fcm91bmRfc21hbGxfNFxcXCIsXFxuICAgIH0pXFxufVxcbmQucHVzaCh7XFxuICAgIGNvbF90eXBlOiBcXFwibGluZVxcXCJcXG59KVxcbmQucHVzaCh7XFxuICAgIGNvbF90eXBlOiBcXFwiYmlnX2JsYW5rX2Jsb2NrXFxcIlxcbn0pXFxuZC5wdXNoKHtcXG4gICAgY29sX3R5cGU6IFxcXCJiaWdfYmxhbmtfYmxvY2tcXFwiXFxufSlcXG5cXG5sZXQgem9uZyA9ICdodHRwOi8vbGl2ZS55ajEyMTEud29yay9hcGkvbGl2ZS9nZXRSZWNvbW1lbmRCeUFyZWFBbGw/YXJlYVR5cGU9JyArIGdldFBhcmFtKFxcXCJ0eXBlTmFtZVxcXCIpICsgJyZhcmVhPScgKyBnZXRQYXJhbShcXFwiYXJlYU5hbWVcXFwiKSArICcmcGFnZT0nICsgZ2V0UGFyYW0oXFxcInBhZ2VcXFwiKVxcblxcbmxldCB6ZiA9IFxcXCJodHRwOi8vbGl2ZS55ajEyMTEud29yay9hcGkvbGl2ZS9nZXRSZWNvbW1lbmRCeVBsYXRmb3JtQXJlYT9wbGF0Zm9ybT1cXFwiICsgZ2V0TXlWYXIoXFxcIk15ZnJvXFxcIikgKyBcXFwiJmFyZWE9XFxcIiArIGdldFBhcmFtKFxcXCJhcmVhTmFtZVxcXCIpICsgXFxcIiZwYWdlPVxcXCIgKyBnZXRQYXJhbShcXFwicGFnZVxcXCIpICsgXFxcIiZzaXplPTIwXFxcIlxcblxcbmxldCBwaW4gPSBcXFwiaHR0cDovL2xpdmUueWoxMjExLndvcmsvYXBpL2xpdmUvZ2V0UmVjb21tZW5kQnlQbGF0Zm9ybUFyZWFcXFwiICsgTVlfVVJMLnJlcGxhY2UoXFxcImhpa2VyOi8vcGFnZS9uZXdDbGFzc0xpc3RcXFwiLCBcXFwiXFxcIikgKyBcXFwiJnBhZ2U9XFxcIiArIGdldFBhcmFtKFxcXCJwYWdlXFxcIikgKyBcXFwiJnNpemU9MjBcXFwiXFxuLy9sb2cocGluKVxcblxcbmxldCBwZiA9IFxcXCJodHRwOi8vbGl2ZS55ajEyMTEud29yay9hcGkvbGl2ZS9nZXRSZWNvbW1lbmRCeVBsYXRmb3JtQXJlYT9wbGF0Zm9ybT1cXFwiICsgZ2V0TXlWYXIoXFxcIk15ZnJvXFxcIikgKyBcXFwiJmFyZWE9XFxcIiArIGdldE15VmFyKFxcXCJhcmVhXFxcIikgKyBcXFwiJnBhZ2U9XFxcIiArIGdldFBhcmFtKFxcXCJwYWdlXFxcIikgKyBcXFwiJnNpemU9MjBcXFwiXFxuXFxudHJ5IHtcXG4gICAgbGV0IGFyZWEgPSBwaW4ubWF0Y2goL2FyZWE9KC4qPykmLylbMV1cXG4gICAgLy9sb2coYXJlYSlcXG4gICAgcHV0TXlWYXIoXFxcImFyZWFcXFwiLCBhcmVhKVxcbn0gY2F0Y2ggKGUpIHtcXG4gICAgdmFyIGFyZWEgPSAnJ1xcbn1cXG5pZiAoYXJlYSA9PSAnJykge1xcbiAgICBpZiAoZ2V0TXlWYXIoXFxcIk15ZnJvXFxcIikpIHtcXG4gICAgICAgIHZhciB1cmwgPSB6ZlxcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgdmFyIHVybCA9IHpvbmdcXG4gICAgfVxcbn0gZWxzZSB7XFxuICAgIGlmIChnZXRNeVZhcihcXFwiTXlmcm9cXFwiKSkge1xcbiAgICAgICAgdmFyIHVybCA9IHBmXFxuICAgIH0gZWxzZSB7XFxuICAgICAgICB2YXIgdXJsID0gcGluXFxuICAgIH1cXG59XFxuXFxudHJ5IHtcXG4gICAgdmFyIHJlcyA9IEpTT04ucGFyc2UocmVxdWVzdCh1cmwpKS5kYXRhXFxuICAgIGlmIChyZXMgPT0gJycpIHtcXG4gICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6ICc8YnI+JyxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ3JpY2hfdGV4dCdcXG4gICAgICAgIH0pXFxuICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiAnPGJyPicsXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdyaWNoX3RleHQnXFxuICAgICAgICB9KVxcbiAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICBkZXNjOiAn5pqC5peg5oi/6Ze0XFxcXG5cXFxcbuivt+WIh+aNouW5s+WPsOingueciycsXFxuICAgICAgICAgICAgdXJsOiAnaGlrZXI6Ly9lbXB0eScsXFxuICAgICAgICAgICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJ1xcbiAgICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgZm9yIChkYXRhIG9mIHJlcykge1xcbiAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogZGF0YS5jYXRlZ29yeU5hbWUgKyAnwrcnICsgZGF0YS5yb29tTmFtZSxcXG4gICAgICAgICAgICBkZXNjOiBkYXRhLnBsYXRGb3JtLnJlcGxhY2UoJ2h1eWEnLCAn6JmO54mZJykucmVwbGFjZSgnZG91eXUnLCAn5paX6bG8JykucmVwbGFjZSgnY2MnLCAn572R5piTQ0MnKS5yZXBsYWNlKFxcXCJiaWxpYmlsaVxcXCIsIFxcXCLlk5Tlk6nlk5Tlk6lcXFwiKSArICfCtycgKyBkYXRhLm93bmVyTmFtZSxcXG4gICAgICAgICAgICBpbWc6IChkYXRhLnJvb21QaWMuc3RhcnRzV2l0aCgnLycpID8gJ2h0dHBzOicgKyBkYXRhLnJvb21QaWMgOiBkYXRhLnJvb21QaWMpICsgJ0BSZWZlcmVyPScsXFxuICAgICAgICAgICAgdXJsOiBcXFwiaGlrZXI6Ly9wYWdlL2RldGFpbD8jaW1tZXJzaXZlVGhlbWUjJnJvb21pZD1cXFwiICsgZGF0YS5yb29tSWQgKyBcXFwiJnBsYXRmb3JtPVxcXCIgKyBkYXRhLnBsYXRGb3JtXFxuICAgICAgICB9KVxcbiAgICB9XFxufSBjYXRjaCAoZSkge1xcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6ICc8YnI+JyxcXG4gICAgICAgIGNvbF90eXBlOiAncmljaF90ZXh0J1xcbiAgICB9KVxcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6ICc8YnI+JyxcXG4gICAgICAgIGNvbF90eXBlOiAncmljaF90ZXh0J1xcbiAgICB9KTtcXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIGRlc2M6ICfmmoLml6DmiL/pl7RcXFxcblxcXFxu6K+35YiH5o2i5bmz5Y+w6KeC55yLJyxcXG4gICAgICAgIHVybDogJ2hpa2VyOi8vZW1wdHknLFxcbiAgICAgICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJ1xcbiAgICB9KTtcXG59XFxuc2V0UmVzdWx0KGQpO1wifV0sXCJzYXZlZFwiOmZhbHNlLFwidGl0bGVcIjpcIkp1c3RMaXZl55u05pKtXCIsXCJ2ZXJzaW9uXCI6MCxcInVybFwiOlwiaGlrZXI6Ly9wYWdlL25ld0NsYXNzTGlzdD90eXBlTmFtZT3nvZHmuLjnq57mioAmYXJlYU5hbWU96Iux6ZuE6IGU55ufJnBhZ2U9ZnlwYWdlXCIsXCJjb2xfdHlwZVwiOlwibW92aWVfMlwiLFwiZmluZF9ydWxlXCI6XCJqczpcXG52YXIgZCA9IFtdO1xcbmFkZExpc3RlbmVyKCdvbkNsb3NlJywgJC50b1N0cmluZygoKSA9PiB7XFxuICAgIGNsZWFyTXlWYXIoJ015ZnJvJylcXG59KSlcXG5pZiAoTVlfUEFHRSA9PSAxKSB7XFxuICAgIGxldCB0aXRsZSA9IGdldE15VmFyKFxcXCJNeWZyb1xcXCIpLnJlcGxhY2UoJ2RvdXl1JywgJ+aWl+mxvCcpLnJlcGxhY2UoJ2h1eWEnLCAn6JmO54mZJykucmVwbGFjZSgnYmlsaWJpbGknLCAn5ZOU5ZOpJykucmVwbGFjZSgnY2MnLCAn572R5piTJylcXG4gICAgbGV0IGltZyA9IGdldE15VmFyKFxcXCJNeWZyb1xcXCIpLnJlcGxhY2UoJ2RvdXl1JywgJ2h0dHBzOi8vYi5iZHN0YXRpYy5jb20vc2VhcmNoYm94L21hcHBjb25zb2xlL2ltYWdlLzIwMTgwODA4LzE1MzM2OTgwNDUxMDUyNzYucG5nQFJlZmVyZXI9JykucmVwbGFjZSgnaHV5YScsICdodHRwczovL21iczEuYmRzdGF0aWMuY29tL3NlYXJjaGJveC9tYXBwY29uc29sZS9pbWFnZS8yMDIwMDkxNS81OGQzZTM4MC04MThiLTQ5MWEtYTk3My0xZWY0N2FhNWU4N2YuanBnQFJlZmVyZXI9JykucmVwbGFjZSgnYmlsaWJpbGknLCAnaHR0cHM6Ly9iLmJkc3RhdGljLmNvbS9zZWFyY2hib3gvbWFwcGNvbnNvbGUvaW1hZ2UvMjAxODEwMzAvMTU0MDg4OTAzODE1OTg2Mi5wbmdAUmVmZXJlcj0nKS5yZXBsYWNlKCdjYycsICdodHRwczovL2NjLmZwLnBzLm5ldGVhc2UuY29tL2ZpbGUvNjBhMzFkM2U3ZjlkMmEzOTEyMGJlYTAxNkxwN1pFZTEwM0BSZWZlcmVyPScpXFxuICAgIGQucHVzaCh7XFxuICAgICAgICB0aXRsZTogZ2V0TXlWYXIoXFxcIk15ZnJvXFxcIikgPT0gJycgPyAn5YiH5o2i5bmz5Y+wJyA6IHRpdGxlICsgJ+W5s+WPsCcsXFxuICAgICAgICB1cmw6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKCkgPT4ge1xcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICAgICAgY2xlYXJNeVZhcihcXFwiTXlmcm9cXFwiKVxcbiAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCJcXG4gICAgICAgIH0pLFxcbiAgICAgICAgaW1nOiBnZXRNeVZhcihcXFwiTXlmcm9cXFwiKSA9PSAnJyA/ICdodHRwczovL2xhbm1laWd1b2ppYW5nLmNvbS90dWJpYW8vbWVzc3kvNS5zdmdAUmVmZXJlcj0nIDogaW1nLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJhdmF0YXJcXFwiXFxuICAgIH0pXFxuXFxuICAgIGQucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIuaWl+mxvFxcXCIsXFxuICAgICAgICBpbWc6IFxcXCJodHRwczovL2IuYmRzdGF0aWMuY29tL3NlYXJjaGJveC9tYXBwY29uc29sZS9pbWFnZS8yMDE4MDgwOC8xNTMzNjk4MDQ1MTA1Mjc2LnBuZ0BSZWZlcmVyPVxcXCIsXFxuICAgICAgICB1cmw6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKCkgPT4ge1xcbiAgICAgICAgICAgIHB1dE15VmFyKFxcXCJNeWZyb1xcXCIsICdkb3V5dScpO1xcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL2VtcHR5XFxcIlxcbiAgICAgICAgfSksXFxuICAgICAgICDCoGNvbF90eXBlOiBcXFwiaWNvbl9yb3VuZF9zbWFsbF80XFxcIixcXG4gICAgfSlcXG5cXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBcXFwi6JmO54mZXFxcIixcXG4gICAgICAgIGltZzogXFxcImh0dHBzOi8vbWJzMS5iZHN0YXRpYy5jb20vc2VhcmNoYm94L21hcHBjb25zb2xlL2ltYWdlLzIwMjAwOTE1LzU4ZDNlMzgwLTgxOGItNDkxYS1hOTczLTFlZjQ3YWE1ZTg3Zi5qcGdAUmVmZXJlcj1cXFwiLFxcbiAgICAgICAgdXJsOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKCgpID0+IHtcXG4gICAgICAgICAgICBwdXRNeVZhcihcXFwiTXlmcm9cXFwiLCAnaHV5YScpO1xcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL2VtcHR5XFxcIlxcbiAgICAgICAgfSksXFxuICAgICAgICDCoGNvbF90eXBlOiBcXFwiaWNvbl9yb3VuZF9zbWFsbF80XFxcIixcXG4gICAgfSlcXG5cXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBcXFwi5ZOU5ZOpXFxcIixcXG4gICAgICAgIGltZzogXFxcImh0dHBzOi8vYi5iZHN0YXRpYy5jb20vc2VhcmNoYm94L21hcHBjb25zb2xlL2ltYWdlLzIwMTgxMDMwLzE1NDA4ODkwMzgxNTk4NjIucG5nQFJlZmVyZXI9XFxcIixcXG4gICAgICAgIHVybDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoKSA9PiB7XFxuICAgICAgICAgICAgcHV0TXlWYXIoXFxcIk15ZnJvXFxcIiwgJ2JpbGliaWxpJyk7XFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXG4gICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiXFxuICAgICAgICB9KSxcXG4gICAgICAgIMKgY29sX3R5cGU6IFxcXCJpY29uX3JvdW5kX3NtYWxsXzRcXFwiLFxcbiAgICB9KVxcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6IFxcXCLnvZHmmJNcXFwiLFxcbiAgICAgICAgaW1nOiBcXFwiaHR0cHM6Ly9jYy5mcC5wcy5uZXRlYXNlLmNvbS9maWxlLzYwYTMxZDNlN2Y5ZDJhMzkxMjBiZWEwMTZMcDdaRWUxMDNAUmVmZXJlcj1cXFwiLFxcbiAgICAgICAgdXJsOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKCgpID0+IHtcXG4gICAgICAgICAgICBwdXRNeVZhcihcXFwiTXlmcm9cXFwiLCAnY2MnKTtcXG4gICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcbiAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCJcXG4gICAgICAgIH0pLFxcbiAgICAgICAgwqBjb2xfdHlwZTogXFxcImljb25fcm91bmRfc21hbGxfNFxcXCIsXFxuICAgIH0pXFxufVxcbmQucHVzaCh7XFxuICAgIGNvbF90eXBlOiBcXFwibGluZVxcXCJcXG59KVxcbmQucHVzaCh7XFxuICAgIGNvbF90eXBlOiBcXFwiYmlnX2JsYW5rX2Jsb2NrXFxcIlxcbn0pXFxuZC5wdXNoKHtcXG4gICAgY29sX3R5cGU6IFxcXCJiaWdfYmxhbmtfYmxvY2tcXFwiXFxufSlcXG5cXG5sZXQgem9uZyA9ICdodHRwOi8vbGl2ZS55ajEyMTEud29yay9hcGkvbGl2ZS9nZXRSZWNvbW1lbmRCeUFyZWFBbGw/YXJlYVR5cGU9JyArIGdldFBhcmFtKFxcXCJ0eXBlTmFtZVxcXCIpICsgJyZhcmVhPScgKyBnZXRQYXJhbShcXFwiYXJlYU5hbWVcXFwiKSArICcmcGFnZT0nICsgZ2V0UGFyYW0oXFxcInBhZ2VcXFwiKVxcblxcbmxldCB6ZiA9IFxcXCJodHRwOi8vbGl2ZS55ajEyMTEud29yay9hcGkvbGl2ZS9nZXRSZWNvbW1lbmRCeVBsYXRmb3JtQXJlYT9wbGF0Zm9ybT1cXFwiICsgZ2V0TXlWYXIoXFxcIk15ZnJvXFxcIikgKyBcXFwiJmFyZWE9XFxcIiArIGdldFBhcmFtKFxcXCJhcmVhTmFtZVxcXCIpICsgXFxcIiZwYWdlPVxcXCIgKyBnZXRQYXJhbShcXFwicGFnZVxcXCIpICsgXFxcIiZzaXplPTIwXFxcIlxcblxcbmxldCBwaW4gPSBcXFwiaHR0cDovL2xpdmUueWoxMjExLndvcmsvYXBpL2xpdmUvZ2V0UmVjb21tZW5kQnlQbGF0Zm9ybUFyZWFcXFwiICsgTVlfVVJMLnJlcGxhY2UoXFxcImhpa2VyOi8vcGFnZS9uZXdDbGFzc0xpc3RcXFwiLCBcXFwiXFxcIikgKyBcXFwiJnBhZ2U9XFxcIiArIGdldFBhcmFtKFxcXCJwYWdlXFxcIikgKyBcXFwiJnNpemU9MjBcXFwiXFxuLy9sb2cocGluKVxcblxcbmxldCBwZiA9IFxcXCJodHRwOi8vbGl2ZS55ajEyMTEud29yay9hcGkvbGl2ZS9nZXRSZWNvbW1lbmRCeVBsYXRmb3JtQXJlYT9wbGF0Zm9ybT1cXFwiICsgZ2V0TXlWYXIoXFxcIk15ZnJvXFxcIikgKyBcXFwiJmFyZWE9XFxcIiArIGdldE15VmFyKFxcXCJhcmVhXFxcIikgKyBcXFwiJnBhZ2U9XFxcIiArIGdldFBhcmFtKFxcXCJwYWdlXFxcIikgKyBcXFwiJnNpemU9MjBcXFwiXFxuXFxudHJ5IHtcXG4gICAgbGV0IGFyZWEgPSBwaW4ubWF0Y2goL2FyZWE9KC4qPykmLylbMV1cXG4gICAgLy9sb2coYXJlYSlcXG4gICAgcHV0TXlWYXIoXFxcImFyZWFcXFwiLCBhcmVhKVxcbn0gY2F0Y2ggKGUpIHtcXG4gICAgdmFyIGFyZWEgPSAnJ1xcbn1cXG5pZiAoYXJlYSA9PSAnJykge1xcbiAgICBpZiAoZ2V0TXlWYXIoXFxcIk15ZnJvXFxcIikpIHtcXG4gICAgICAgIHZhciB1cmwgPSB6ZlxcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgdmFyIHVybCA9IHpvbmdcXG4gICAgfVxcbn0gZWxzZSB7XFxuICAgIGlmIChnZXRNeVZhcihcXFwiTXlmcm9cXFwiKSkge1xcbiAgICAgICAgdmFyIHVybCA9IHBmXFxuICAgIH0gZWxzZSB7XFxuICAgICAgICB2YXIgdXJsID0gcGluXFxuICAgIH1cXG59XFxuXFxudHJ5IHtcXG4gICAgdmFyIHJlcyA9IEpTT04ucGFyc2UocmVxdWVzdCh1cmwpKS5kYXRhXFxuICAgIGlmIChyZXMgPT0gJycpIHtcXG4gICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6ICc8YnI+JyxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ3JpY2hfdGV4dCdcXG4gICAgICAgIH0pXFxuICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiAnPGJyPicsXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdyaWNoX3RleHQnXFxuICAgICAgICB9KVxcbiAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICBkZXNjOiAn5pqC5peg5oi/6Ze0XFxcXG5cXFxcbuivt+WIh+aNouW5s+WPsOingueciycsXFxuICAgICAgICAgICAgdXJsOiAnaGlrZXI6Ly9lbXB0eScsXFxuICAgICAgICAgICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJ1xcbiAgICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgZm9yIChkYXRhIG9mIHJlcykge1xcbiAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogZGF0YS5jYXRlZ29yeU5hbWUgKyAnwrcnICsgZGF0YS5yb29tTmFtZSxcXG4gICAgICAgICAgICBkZXNjOiBkYXRhLnBsYXRGb3JtLnJlcGxhY2UoJ2h1eWEnLCAn6JmO54mZJykucmVwbGFjZSgnZG91eXUnLCAn5paX6bG8JykucmVwbGFjZSgnY2MnLCAn572R5piTQ0MnKS5yZXBsYWNlKFxcXCJiaWxpYmlsaVxcXCIsIFxcXCLlk5Tlk6nlk5Tlk6lcXFwiKSArICfCtycgKyBkYXRhLm93bmVyTmFtZSxcXG4gICAgICAgICAgICBpbWc6IChkYXRhLnJvb21QaWMuc3RhcnRzV2l0aCgnLycpID8gJ2h0dHBzOicgKyBkYXRhLnJvb21QaWMgOiBkYXRhLnJvb21QaWMpICsgJ0BSZWZlcmVyPScsXFxuICAgICAgICAgICAgdXJsOiBcXFwiaGlrZXI6Ly9wYWdlL2RldGFpbD8jaW1tZXJzaXZlVGhlbWUjJnJvb21pZD1cXFwiICsgZGF0YS5yb29tSWQgKyBcXFwiJnBsYXRmb3JtPVxcXCIgKyBkYXRhLnBsYXRGb3JtXFxuICAgICAgICB9KVxcbiAgICB9XFxufSBjYXRjaCAoZSkge1xcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6ICc8YnI+JyxcXG4gICAgICAgIGNvbF90eXBlOiAncmljaF90ZXh0J1xcbiAgICB9KVxcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6ICc8YnI+JyxcXG4gICAgICAgIGNvbF90eXBlOiAncmljaF90ZXh0J1xcbiAgICB9KTtcXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIGRlc2M6ICfmmoLml6DmiL/pl7RcXFxcblxcXFxu6K+35YiH5o2i5bmz5Y+w6KeC55yLJyxcXG4gICAgICAgIHVybDogJ2hpa2VyOi8vZW1wdHknLFxcbiAgICAgICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJ1xcbiAgICB9KTtcXG59XFxuc2V0UmVzdWx0KGQpO1wiLFwiZ3JvdXBcIjpcIjFcIixcInVhXCI6XCJtb2JpbGVcIixcInByZVJ1bGVcIjpcInZhciBhY2NvdW50ID0gZ2V0SXRlbShcXFwiYWNjb3VudFxcXCIsIFxcXCJcXFwiKVxcbnZhciBwYXNzd29yZCA9IGdldEl0ZW0oXFxcInBhc3N3b3JkXFxcIilcXG5pZiAoYWNjb3VudCAhPSBcXFwiXFxcIiAmJiBnZXRJdGVtKFxcXCJ1aWRcXFwiLCBcXFwiXFxcIikgPT0gXFxcIlxcXCIpIHtcXG4gICAgdmFyIGNvb2tpZXMgPSBKU09OLnBhcnNlKHJlcXVlc3QoJ2h0dHA6Ly9saXZlLnlqMTIxMS53b3JrL2FwaS9sb2dpbicsIHtcXG4gICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAnVXNlci1BZ2VudCc6IFBDX1VBXFxuICAgICAgICB9LFxcbiAgICAgICAgYm9keTogXFxcInVzZXJuYW1lPVxcXCIgKyBhY2NvdW50ICsgXFxcIiZwYXNzd29yZD1cXFwiICsgbWQ1KHBhc3N3b3JkKSxcXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnXFxuICAgIH0pKVxcbiAgICAvL2xvZyhjb29raWVzKVxcbiAgICBpZiAoY29va2llcy5jb2RlID09IDIwMCkge1xcbiAgICAgICAgdG9hc3QoXFxcIueZu+mZhuaIkOWKn1xcXCIpXFxuICAgICAgICBzZXRJdGVtKFxcXCJ1aWRcXFwiLCBjb29raWVzLmRhdGEudWlkKVxcbiAgICAgICAgc2V0SXRlbShcXFwibmlja25hbWVcXFwiLCBjb29raWVzLmRhdGEudXNlck5hbWUpXFxuICAgIH0gZWxzZSB7XFxuICAgICAgICB0b2FzdChcXFwi55m76ZmG5aSx6LSl77yM5Y+v6IO95piv55So5oi35ZCN5oiW5a+G56CB5pyJ6K+vXFxcIilcXG4gICAgICAgIHNldEl0ZW0oXFxcIm5pY2tuYW1lXFxcIiwgXFxcIuacqueZu+mZhlxcXCIpXFxuICAgICAgICBzZXRJdGVtKFxcXCJ1aWRcXFwiLCBcXFwiXFxcIilcXG4gICAgfVxcbn1cIixcInBhZ2VzXCI6XCJbe1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5LqM57qnXFxcIixcXFwicGF0aFxcXCI6XFxcImRldGFpbFxcXCIsXFxcInJ1bGVcXFwiOlxcXCJqczpcXFxcbnZhciBkID0gW107XFxcXG52YXIgcmVzID0gSlNPTi5wYXJzZShyZXF1ZXN0KFxcXFxcXFwiaHR0cDovL2xpdmUueWoxMjExLndvcmsvYXBpL2xpdmUvZ2V0Um9vbUluZm8/dWlkPVxcXFxcXFwiICsgZ2V0SXRlbShcXFxcXFxcInVpZFxcXFxcXFwiKSArIFxcXFxcXFwiJnBsYXRmb3JtPVxcXFxcXFwiICsgZ2V0UGFyYW0oXFxcXFxcXCJwbGF0Zm9ybVxcXFxcXFwiKSArIFxcXFxcXFwiJnJvb21JZD1cXFxcXFxcIiArIGdldFBhcmFtKFxcXFxcXFwicm9vbWlkXFxcXFxcXCIpKSlcXFxcbi8v6L+Z5Lik5Liq6ZO+5o6l5LiN5ZCMXFxcXG52YXIgcGxheXVybCA9IEpTT04ucGFyc2UocmVxdWVzdChcXFxcXFxcImh0dHA6Ly9saXZlLnlqMTIxMS53b3JrL2FwaS9saXZlL2dldFJlYWxVcmw/cGxhdGZvcm09XFxcXFxcXCIgKyBnZXRQYXJhbShcXFxcXFxcInBsYXRmb3JtXFxcXFxcXCIpICsgXFxcXFxcXCImcm9vbUlkPVxcXFxcXFwiICsgZ2V0UGFyYW0oXFxcXFxcXCJyb29taWRcXFxcXFxcIikpKS5kYXRhXFxcXG52YXIgdWlkID0gZ2V0SXRlbShcXFxcXFxcInVpZFxcXFxcXFwiKVxcXFxudmFyIGZvbGxvdyA9IHJlcy5kYXRhLmlzRm9sbG93ZWRcXFxcbnZhciByb29taWQgPSByZXMuZGF0YS5yb29tSWRcXFxcbnZhciBwbGF0Zm9ybSA9IGdldFBhcmFtKFxcXFxcXFwicGxhdGZvcm1cXFxcXFxcIilcXFxcbnN3aXRjaCAocGxhdGZvcm0pIHtcXFxcbiAgICBjYXNlIFxcXFxcXFwiZG91eXVcXFxcXFxcIjpcXFxcbiAgICAgICAgdmFyIHVybCA9IFxcXFxcXFwiaHR0cHM6Ly9tLmRvdXl1LmNvbS9cXFxcXFxcIiArIHJvb21pZFxcXFxuICAgICAgICBicmVha1xcXFxuICAgIGNhc2UgXFxcXFxcXCJiaWxpYmlsaVxcXFxcXFwiOlxcXFxuICAgICAgICB2YXIgdXJsID0gXFxcXFxcXCJodHRwczovL2xpdmUuYmlsaWJpbGkuY29tL2g1L1xcXFxcXFwiICsgcm9vbWlkXFxcXG4gICAgICAgIGJyZWFrXFxcXG4gICAgY2FzZSBcXFxcXFxcImh1eWFcXFxcXFxcIjpcXFxcbiAgICAgICAgdmFyIHVybCA9IFxcXFxcXFwiaHR0cHM6Ly9tLmh1eWEuY29tL1xcXFxcXFwiICsgcm9vbWlkXFxcXG4gICAgICAgIGJyZWFrXFxcXG4gICAgY2FzZSBcXFxcXFxcImNjXFxcXFxcXCI6XFxcXG4gICAgICAgIHZhciB1cmwgPSBcXFxcXFxcImh0dHBzOi8vaDUuY2MuMTYzLmNvbS9jYy9cXFxcXFxcIiArIHJvb21pZFxcXFxuICAgICAgICBicmVha1xcXFxufVxcXFxuZC5wdXNoKHtcXFxcbiAgICB0aXRsZTogcmVzLmRhdGEucm9vbU5hbWUsXFxcXG4gICAgaW1nOiByZXMuZGF0YS5yb29tUGljICsgXFxcXFxcXCJAUmVmZXJlcj1cXFxcXFxcIixcXFxcbiAgICBkZXNjOiBcXFxcXFxcIuWIhuWMuu+8mlxcXFxcXFwiICsgcmVzLmRhdGEucGxhdEZvcm0ucmVwbGFjZSgnaHV5YScsICfomY7niZknKS5yZXBsYWNlKCdkb3V5dScsICfmlpfpsbwnKS5yZXBsYWNlKCdjYycsICfnvZHmmJNDQycpLnJlcGxhY2UoXFxcXFxcXCJiaWxpYmlsaVxcXFxcXFwiLCBcXFxcXFxcIuWTlOWTqeWTlOWTqVxcXFxcXFwiKSArICfCtycgKyByZXMuZGF0YS5jYXRlZ29yeU5hbWUgKyAocmVzLmRhdGEuaXNMaXZlID09IDEgPyBcXFxcXFxcIlxcXFxcXFxcbueKtuaAge+8muato+WcqOebtOaSrVxcXFxcXFwiIDogXFxcXFxcXCJcXFxcXFxcXG7nirbmgIHvvJrmnKrlvIDmkq1cXFxcXFxcIikgKyBcXFxcXFxcIlxcXFxcXFxcbueCueWHu+S4i+aWueS4u+aSreWktOWDj+i/m+WFpeWumOe9kVxcXFxcXFwiLFxcXFxuICAgIHVybDogcmVzLmRhdGEucm9vbVBpYyxcXFxcbiAgICBjb2xfdHlwZTogJ21vdmllXzFfdmVydGljYWxfcGljX2JsdXInLFxcXFxuICAgIGV4dHJhOiB7XFxcXG4gICAgICAgIGdyYWRpZW50OiB0cnVlXFxcXG4gICAgfVxcXFxufSlcXFxcbmQucHVzaCh7XFxcXG4gICAgdGl0bGU6IHJlcy5kYXRhLm93bmVyTmFtZSxcXFxcbiAgICBpbWc6IHJlcy5kYXRhLm93bmVySGVhZFBpYyArIFxcXFxcXFwiQFJlZmVyZXI9XFxcXFxcXCIsXFxcXG4gICAgdXJsOiB1cmwsXFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwiaWNvbl8yX3JvdW5kXFxcXFxcXCJcXFxcbn0pXFxcXG5kLnB1c2goe1xcXFxuICAgIHRpdGxlOiByZXMuZGF0YS5pc0ZvbGxvd2VkID09IDEgPyBcXFxcXFxcIuW3suWFs+azqFxcXFxcXFwiIDogXFxcXFxcXCLmnKrlhbPms6hcXFxcXFxcIixcXFxcbiAgICB1cmw6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKHVpZCwgcm9vbWlkLCBwbGF0Zm9ybSwgZm9sbG93KSA9PiB7XFxcXG4gICAgICAgIGlmIChmb2xsb3cgPT0gMCkge1xcXFxuICAgICAgICAgICAgdmFyIHJlcyA9IEpTT04ucGFyc2UocmVxdWVzdChcXFxcXFxcImh0dHA6Ly8xMjQuMjIyLjUuMTMxOjgwMTMvYXBpL2xpdmUvZm9sbG93P3BsYXRmb3JtPVxcXFxcXFwiICsgcGxhdGZvcm0gKyBcXFxcXFxcIiZyb29tSWQ9XFxcXFxcXCIgKyByb29taWQgKyBcXFxcXFxcIiZ1aWQ9XFxcXFxcXCIgKyB1aWQpKVxcXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKVxcXFxuICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly9cXFxcXFxcIiArIHJlcy5kYXRhXFxcXG4gICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICB2YXIgcmVzID0gSlNPTi5wYXJzZShyZXF1ZXN0KFxcXFxcXFwiaHR0cDovLzEyNC4yMjIuNS4xMzE6ODAxMy9hcGkvbGl2ZS91bkZvbGxvdz9wbGF0Zm9ybT1cXFxcXFxcIiArIHBsYXRmb3JtICsgXFxcXFxcXCImcm9vbUlkPVxcXFxcXFwiICsgcm9vbWlkICsgXFxcXFxcXCImdWlkPVxcXFxcXFwiICsgdWlkKSlcXFxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKClcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8vXFxcXFxcXCIgKyByZXMuZGF0YVxcXFxuICAgICAgICB9XFxcXG4gICAgfSwgdWlkLCByb29taWQsIHBsYXRmb3JtLCBmb2xsb3cpLFxcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMlxcXFxcXFwiXFxcXG59KVxcXFxudmFyIG5hbWUgPSB7XFxcXG4gICAgXFxcXFxcXCJPRFxcXFxcXFwiOiBcXFxcXFxcIuWOn+eUu1xcXFxcXFwiLFxcXFxuICAgIFxcXFxcXFwiRkRcXFxcXFxcIjogXFxcXFxcXCLmtYHnlYVcXFxcXFxcIixcXFxcbiAgICBcXFxcXFxcIkxEXFxcXFxcXCI6IFxcXFxcXFwi5qCH5riFXFxcXFxcXCIsXFxcXG4gICAgXFxcXFxcXCJTRFxcXFxcXFwiOiBcXFxcXFxcIumrmOa4hVxcXFxcXFwiLFxcXFxuICAgIFxcXFxcXFwiSERcXFxcXFxcIjogXFxcXFxcXCLotoXmuIVcXFxcXFxcIixcXFxcbiAgICBcXFxcXFxcIjJLXFxcXFxcXCI6IFxcXFxcXFwiMktcXFxcXFxcIixcXFxcbiAgICBcXFxcXFxcIjRLXFxcXFxcXCI6IFxcXFxcXFwiNEtcXFxcXFxcIixcXFxcbiAgICBcXFxcXFxcIkZIRFxcXFxcXFwiOiBcXFxcXFxcIuWFqOmrmOa4hVxcXFxcXFwiLFxcXFxuICAgIFxcXFxcXFwiWExEXFxcXFxcXCI6IFxcXFxcXFwi5p6B6YCfXFxcXFxcXCIsXFxcXG4gICAgXFxcXFxcXCJTUVxcXFxcXFwiOiBcXFxcXFxcIuaZrumAmumfs+i0qFxcXFxcXFwiLFxcXFxuICAgIFxcXFxcXFwiSFFcXFxcXFxcIjogXFxcXFxcXCLpq5jpn7PotKhcXFxcXFxcIlxcXFxufVxcXFxudmFyIHVybHMgPSBbXVxcXFxudmFyIG5hbWVzID0gW11cXFxcbmZvciAodmFyIGtleSBpbiBwbGF5dXJsKSB7XFxcXG4gICAgaWYgKCEvYXl5dWlkfHRvLy50ZXN0KGtleSkpIHtcXFxcbiAgICAgICAgdXJscy5wdXNoKHBsYXl1cmxba2V5XSlcXFxcbiAgICAgICAgbmFtZXMucHVzaChuYW1lW2tleV0pXFxcXG4gICAgfVxcXFxufVxcXFxuZC5wdXNoKHtcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJsaW5lX2JsYW5rXFxcXFxcXCJcXFxcbn0pXFxcXG5kLnB1c2goe1xcXFxuICAgIHRpdGxlOiBcXFxcXFxcIumAieaLqeeUu+i0qFxcXFxcXFwiLFxcXFxuICAgIHVybDogXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCIsXFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF9jZW50ZXJfMVxcXFxcXFwiXFxcXG59KVxcXFxuZm9yICh2YXIgaSBpbiBuYW1lcykge1xcXFxuICAgIGQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiBuYW1lc1tpXSxcXFxcbiAgICAgICAgdXJsOiBwbGF0Zm9ybSA9PSBcXFxcXFxcImRvdXl1XFxcXFxcXCIgPyBKU09OLnN0cmluZ2lmeSh7XFxcXG4gICAgICAgICAgICB1cmxzOiBbdXJsc1tpXV0sXFxcXG4gICAgICAgICAgICBkYW5tdTogJ3dlYjovL2h0dHA6Ly9kb3V5dV9kYW5tdS5kZXYudHlyYW50Zy5jb20vP3JpZD0nICsgcm9vbWlkICsgJyZ2ZXI9MSdcXFxcbiAgICAgICAgfSkgOiB1cmxzW2ldLFxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0XzJcXFxcXFxcIlxcXFxuICAgIH0pXFxcXG59XFxcXG5zZXRSZXN1bHQoZCk7XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzJcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5YWz5rOo5YiX6KGoXFxcIixcXFwicGF0aFxcXCI6XFxcImhpc3RvcnlcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG52YXIgZCA9IFtdO1xcXFxuc2V0UGFnZVRpdGxlKFxcXFxcXFwi5YWz5rOoXFxcXFxcXCIpXFxcXG5kLnB1c2goe1xcXFxuICAgIHRpdGxlOiBnZXRJdGVtKFxcXFxcXFwibmlja25hbWVcXFxcXFxcIiksXFxcXG4gICAgdXJsOiAkKFxcXFxcXFwi5piv5ZCm5rOo6ZSA77yfXFxcXFxcXCIpLmNvbmZpcm0oKCkgPT4ge1xcXFxuICAgICAgICBzZXRJdGVtKFxcXFxcXFwidWlkXFxcXFxcXCIsIFxcXFxcXFwiXFxcXFxcXCIpXFxcXG4gICAgICAgIHNldEl0ZW0oXFxcXFxcXCJuaWNrbmFtZVxcXFxcXFwiLCBcXFxcXFxcIuacqueZu+mZhlxcXFxcXFwiKVxcXFxuICAgICAgICBiYWNrKHRydWUpXFxcXG4gICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5rOo6ZSA5oiQ5YqfXFxcXFxcXCJcXFxcbiAgICB9KSxcXFxcbiAgICBpbWc6IFxcXFxcXFwiaHR0cHM6Ly9sYW5tZWlndW9qaWFuZy5jb20vdHViaWFvL2tlLzczLnBuZ1xcXFxcXFwiLFxcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcImF2YXRhclxcXFxcXFwiXFxcXG59KVxcXFxuaWYgKGdldEl0ZW0oXFxcXFxcXCJ1aWRcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIikgPT0gXFxcXFxcXCJcXFxcXFxcIikge1xcXFxuICAgIGQucHVzaCh7XFxcXG4gICAgICAgIGRlc2M6IFxcXFxcXFwi6LSm5Y+3XFxcXFxcXCIsXFxcXG4gICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICBvbkNoYW5nZTogXFxcXFxcXCJzZXRJdGVtKCdhY2NvdW50JyxpbnB1dClcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIHRpdGxlVmlzaWJsZTogZmFsc2VcXFxcbiAgICAgICAgfSxcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiaW5wdXRcXFxcXFxcIlxcXFxuICAgIH0pXFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgZGVzYzogXFxcXFxcXCLlr4bnoIFcXFxcXFxcIixcXFxcbiAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiBcXFxcXFxcInNldEl0ZW0oJ3Bhc3N3b3JkJyxpbnB1dClcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIHRpdGxlVmlzaWJsZTogZmFsc2VcXFxcbiAgICAgICAgfSxcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiaW5wdXRcXFxcXFxcIlxcXFxuICAgIH0pXFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IFxcXFxcXFwi56Gu5a6aXFxcXFxcXCIsXFxcXG4gICAgICAgIHVybDogJCgpLmxhenlSdWxlKCgpID0+IHtcXFxcbiAgICAgICAgICAgIGJhY2soKVxcXFxuICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/ov5Tlm57oh6rliqjnmbvpmYZcXFxcXFxcIlxcXFxuICAgICAgICB9KSxcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF9jZW50ZXJfMVxcXFxcXFwiXFxcXG4gICAgfSlcXFxcbn1cXFxcbnZhciByZXMgPSBKU09OLnBhcnNlKHJlcXVlc3QoXFxcXFxcXCJodHRwOi8vbGl2ZS55ajEyMTEud29yay9hcGkvbGl2ZS9nZXRSb29tc09uP3VpZD1cXFxcXFxcIiArIGdldEl0ZW0oXFxcXFxcXCJ1aWRcXFxcXFxcIikpKVxcXFxudmFyIHJlcyA9IHJlcy5kYXRhXFxcXG4vL2xvZyhyZXMpXFxcXG52YXIgc1R5cGUgPSBnZXRNeVZhcihcXFxcXFxcInNUeXBlXFxcXFxcXCIpID8gZ2V0TXlWYXIoXFxcXFxcXCJzVHlwZVxcXFxcXFwiKSA6IFxcXFxcXFwibGl2aW5nXFxcXFxcXCJcXFxcbmQucHVzaCh7XFxcXG4gICAgdGl0bGU6IHNUeXBlID09IFxcXFxcXFwibGl2aW5nXFxcXFxcXCIgPyAn4oCY4oCY4oCZ4oCZPHN0cm9uZz48Zm9udCBjb2xvcj1cXFxcXFxcIiNGQTcyOThcXFxcXFxcIj7mraPlnKjnm7Tmkq08L2Zyb250Pjwvc3Ryb25nPicgOiBcXFxcXFxcIuato+WcqOebtOaSrVxcXFxcXFwiLFxcXFxuICAgIHVybDogJCgpLmxhenlSdWxlKChzVHlwZSkgPT4ge1xcXFxuICAgICAgICBwdXRNeVZhcihcXFxcXFxcInNUeXBlXFxcXFxcXCIsIHNUeXBlID09ICdsaXZpbmcnID8gJ291dGxpbmUnIDogJ2xpdmluZycpO1xcXFxuICAgICAgICByZWZyZXNoUGFnZSgpO1xcXFxuICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCJcXFxcbiAgICB9LCBzVHlwZSksXFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF8yXFxcXFxcXCJcXFxcbn0pXFxcXG5kLnB1c2goe1xcXFxuICAgIHRpdGxlOiBzVHlwZSA9PSBcXFxcXFxcIm91dGxpbmVcXFxcXFxcIiA/ICfigJjigJjigJnigJk8c3Ryb25nPjxmb250IGNvbG9yPVxcXFxcXFwiI0ZBNzI5OFxcXFxcXFwiPuacquebtOaSrTwvZnJvbnQ+PC9zdHJvbmc+JyA6IFxcXFxcXFwi5pyq55u05pKtXFxcXFxcXCIsXFxcXG4gICAgdXJsOiAkKCkubGF6eVJ1bGUoKHNUeXBlKSA9PiB7XFxcXG4gICAgICAgIHB1dE15VmFyKFxcXFxcXFwic1R5cGVcXFxcXFxcIiwgc1R5cGUgPT0gJ291dGxpbmUnID8gJ2xpdmluZycgOiAnb3V0bGluZScpO1xcXFxuICAgICAgICByZWZyZXNoUGFnZSgpO1xcXFxuICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCJcXFxcbiAgICB9LCBzVHlwZSksXFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF8yXFxcXFxcXCJcXFxcbn0pXFxcXG5pZiAoc1R5cGUgPT0gXFxcXFxcXCJsaXZpbmdcXFxcXFxcIikge1xcXFxuICAgIGZvciAodmFyIGkgaW4gcmVzKSB7XFxcXG4gICAgICAgIHZhciB0ZW1wID0gcmVzW2ldXFxcXG4gICAgICAgIGlmICh0ZW1wLmlzTGl2ZSA9PSAxKSB7XFxcXG4gICAgICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiB0ZW1wLmNhdGVnb3J5TmFtZSArICfCtycgKyB0ZW1wLnJvb21OYW1lLFxcXFxuICAgICAgICAgICAgICAgIGRlc2M6IHRlbXAucGxhdEZvcm0ucmVwbGFjZSgnaHV5YScsICfomY7niZknKS5yZXBsYWNlKCdkb3V5dScsICfmlpfpsbwnKS5yZXBsYWNlKCdjYycsICfnvZHmmJNDQycpLnJlcGxhY2UoXFxcXFxcXCJiaWxpYmlsaVxcXFxcXFwiLCBcXFxcXFxcIuWTlOWTqeWTlOWTqVxcXFxcXFwiKSArICfCtycgKyB0ZW1wLm93bmVyTmFtZSxcXFxcbiAgICAgICAgICAgICAgICBpbWc6IHRlbXAucm9vbVBpYyArIFxcXFxcXFwiQFJlZmVyZXI9XFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vcGFnZS9kZXRhaWw/I2ltbWVyc2l2ZVRoZW1lIyZyb29taWQ9XFxcXFxcXCIgKyB0ZW1wLnJvb21JZCArIFxcXFxcXFwiJnBsYXRmb3JtPVxcXFxcXFwiICsgdGVtcC5wbGF0Rm9ybVxcXFxuICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgfVxcXFxuICAgIH1cXFxcbn0gZWxzZSB7XFxcXG4gICAgZm9yICh2YXIgaSBpbiByZXMpIHtcXFxcbiAgICAgICAgdmFyIHRlbXAgPSByZXNbaV1cXFxcbiAgICAgICAgaWYgKHRlbXAuaXNMaXZlID09IDApIHtcXFxcbiAgICAgICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRlbXAub3duZXJOYW1lLFxcXFxuICAgICAgICAgICAgICAgIGltZzogdGVtcC5vd25lckhlYWRQaWMgKyBcXFxcXFxcIkBSZWZlcmVyPVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIHVybDogXFxcXFxcXCJoaWtlcjovL3BhZ2UvZGV0YWlsPyNpbW1lcnNpdmVUaGVtZSMmcm9vbWlkPVxcXFxcXFwiICsgdGVtcC5yb29tSWQgKyBcXFxcXFxcIiZwbGF0Zm9ybT1cXFxcXFxcIiArIHRlbXAucGxhdEZvcm1cXFxcbiAgICAgICAgICAgIH0pXFxcXG4gICAgICAgIH1cXFxcbiAgICB9XFxcXG59XFxcXG5zZXRSZXN1bHQoZCk7XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcInRleHRfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLlhajpg6jliIbnsbtcXFwiLFxcXCJwYXRoXFxcIjpcXFwibmV3Q2xhc3NcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG52YXIgZCA9IFtdO1xcXFxuYWRkTGlzdGVuZXIoJ29uQ2xvc2UnLCAkLnRvU3RyaW5nKCgpID0+IHtcXFxcbiAgICBjbGVhck15VmFyKCdNeWZsJylcXFxcbiAgICBjbGVhck15VmFyKCdNeXB0JylcXFxcbn0pKVxcXFxuZC5wdXNoKHtcXFxcbiAgICB0aXRsZTogZ2V0TXlWYXIoXFxcXFxcXCJNeWZsXFxcXFxcXCIsIFxcXFxcXFwi5p2/5Z2XXFxcXFxcXCIpID09IFxcXFxcXFwi5p2/5Z2XXFxcXFxcXCIgPyBcXFxcXFxcIvCflLTniYjlnZfliIbnsbtcXFxcXFxcIiA6IFxcXFxcXFwi4pqq77iP5p2/5Z2X5YiG57G7XFxcXFxcXCIsXFxcXG4gICAgdXJsOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKCgpID0+IHtcXFxcbiAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcbiAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCJNeWZsXFxcXFxcXCIsICfmnb/lnZcnKVxcXFxuICAgICAgICBjbGVhck15VmFyKCdNeWZsJylcXFxcbiAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiXFxcXG4gICAgfSksXFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF8yXFxcXFxcXCJcXFxcbn0pXFxcXG5kLnB1c2goe1xcXFxuICAgIHRpdGxlOiBnZXRNeVZhcihcXFxcXFxcIk15ZmxcXFxcXFxcIikgPT0gXFxcXFxcXCLlubPlj7BcXFxcXFxcIiA/IFxcXFxcXFwi8J+UtOW5s+WPsOWIhuexu1xcXFxcXFwiIDogXFxcXFxcXCLimqrvuI/lubPlj7DliIbnsbtcXFxcXFxcIixcXFxcbiAgICB1cmw6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKCkgPT4ge1xcXFxuICAgICAgICByZWZyZXNoUGFnZSgpO1xcXFxuICAgICAgICBwdXRNeVZhcihcXFxcXFxcIk15ZmxcXFxcXFxcIiwgJ+W5s+WPsCcpXFxcXG4gICAgICAgIGNsZWFyTXlWYXIoJ015cHQnKVxcXFxuICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCJcXFxcbiAgICB9KSxcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0XzJcXFxcXFxcIlxcXFxufSlcXFxcblxcXFxuLy/lubPlj7DliIbnsbtcXFxcbmlmIChnZXRNeVZhcihcXFxcXFxcIk15ZmxcXFxcXFxcIikpIHtcXFxcbiAgICBsZXQgdGl0bGUgPSBnZXRNeVZhcihcXFxcXFxcIk15cHRcXFxcXFxcIikucmVwbGFjZSgnZG91eXUnLCAn5paX6bG8JykucmVwbGFjZSgnaHV5YScsICfomY7niZknKS5yZXBsYWNlKCdiaWxpYmlsaScsICflk5Tlk6knKS5yZXBsYWNlKCdjYycsICfnvZHmmJMnKVxcXFxuICAgIGxldCBpbWcgPSBnZXRNeVZhcihcXFxcXFxcIk15cHRcXFxcXFxcIikucmVwbGFjZSgnZG91eXUnLCAnaHR0cHM6Ly9iLmJkc3RhdGljLmNvbS9zZWFyY2hib3gvbWFwcGNvbnNvbGUvaW1hZ2UvMjAxODA4MDgvMTUzMzY5ODA0NTEwNTI3Ni5wbmdAUmVmZXJlcj0nKS5yZXBsYWNlKCdodXlhJywgJ2h0dHBzOi8vbWJzMS5iZHN0YXRpYy5jb20vc2VhcmNoYm94L21hcHBjb25zb2xlL2ltYWdlLzIwMjAwOTE1LzU4ZDNlMzgwLTgxOGItNDkxYS1hOTczLTFlZjQ3YWE1ZTg3Zi5qcGdAUmVmZXJlcj0nKS5yZXBsYWNlKCdiaWxpYmlsaScsICdodHRwczovL2IuYmRzdGF0aWMuY29tL3NlYXJjaGJveC9tYXBwY29uc29sZS9pbWFnZS8yMDE4MTAzMC8xNTQwODg5MDM4MTU5ODYyLnBuZ0BSZWZlcmVyPScpLnJlcGxhY2UoJ2NjJywgJ2h0dHBzOi8vY2MuZnAucHMubmV0ZWFzZS5jb20vZmlsZS82MGEzMWQzZTdmOWQyYTM5MTIwYmVhMDE2THA3WkVlMTAzQFJlZmVyZXI9JylcXFxcblxcXFxuICAgIGQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiBcXFxcXFxcIuaWl+mxvFxcXFxcXFwiLFxcXFxuICAgICAgICB1cmw6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKCkgPT4ge1xcXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcbiAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwiTXlwdFxcXFxcXFwiLCAnZG91eXUnKVxcXFxuICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiXFxcXG4gICAgICAgIH0pLFxcXFxuICAgICAgICBpbWc6IFxcXFxcXFwiaHR0cHM6Ly9iLmJkc3RhdGljLmNvbS9zZWFyY2hib3gvbWFwcGNvbnNvbGUvaW1hZ2UvMjAxODA4MDgvMTUzMzY5ODA0NTEwNTI3Ni5wbmdAUmVmZXJlcj1cXFxcXFxcIixcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiaWNvbl9yb3VuZF9zbWFsbF80XFxcXFxcXCJcXFxcbiAgICB9KVxcXFxuICAgIGQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiAn6JmO54mZJyxcXFxcbiAgICAgICAgdXJsOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKCgpID0+IHtcXFxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXG4gICAgICAgICAgICBwdXRNeVZhcihcXFxcXFxcIk15cHRcXFxcXFxcIiwgJ2h1eWEnKVxcXFxuICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiXFxcXG4gICAgICAgIH0pLFxcXFxuICAgICAgICBpbWc6IFxcXFxcXFwiaHR0cHM6Ly9tYnMxLmJkc3RhdGljLmNvbS9zZWFyY2hib3gvbWFwcGNvbnNvbGUvaW1hZ2UvMjAyMDA5MTUvNThkM2UzODAtODE4Yi00OTFhLWE5NzMtMWVmNDdhYTVlODdmLmpwZ0BSZWZlcmVyPVxcXFxcXFwiLFxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJpY29uX3JvdW5kX3NtYWxsXzRcXFxcXFxcIlxcXFxuICAgIH0pXFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IFxcXFxcXFwi5ZOU5ZOpXFxcXFxcXCIsXFxcXG4gICAgICAgIHVybDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoKSA9PiB7XFxcXG4gICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcXFxuICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCJNeXB0XFxcXFxcXCIsICdiaWxpYmlsaScpXFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCJcXFxcbiAgICAgICAgfSksXFxcXG4gICAgICAgIGltZzogXFxcXFxcXCJodHRwczovL2IuYmRzdGF0aWMuY29tL3NlYXJjaGJveC9tYXBwY29uc29sZS9pbWFnZS8yMDE4MTAzMC8xNTQwODg5MDM4MTU5ODYyLnBuZ0BSZWZlcmVyPVxcXFxcXFwiLFxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJpY29uX3JvdW5kX3NtYWxsXzRcXFxcXFxcIlxcXFxuICAgIH0pXFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IFxcXFxcXFwi572R5piTXFxcXFxcXCIsXFxcXG4gICAgICAgIHVybDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoKSA9PiB7XFxcXG4gICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcXFxuICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCJNeXB0XFxcXFxcXCIsICdjYycpXFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCJcXFxcbiAgICAgICAgfSksXFxcXG4gICAgICAgIGltZzogXFxcXFxcXCJodHRwczovL2NjLmZwLnBzLm5ldGVhc2UuY29tL2ZpbGUvNjBhMzFkM2U3ZjlkMmEzOTEyMGJlYTAxNkxwN1pFZTEwM0BSZWZlcmVyPVxcXFxcXFwiLFxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJpY29uX3JvdW5kX3NtYWxsXzRcXFxcXFxcIlxcXFxuICAgIH0pXFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiYmlnX2JsYW5rX2Jsb2NrXFxcXFxcXCJcXFxcbiAgICB9KVxcXFxuICAgIGQucHVzaCh7XFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImJpZ19ibGFua19ibG9ja1xcXFxcXFwiXFxcXG4gICAgfSlcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJsaW5lXFxcXFxcXCJcXFxcbiAgICB9KVxcXFxuICAgIGQucHVzaCh7XFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImJpZ19ibGFua19ibG9ja1xcXFxcXFwiXFxcXG4gICAgfSlcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJiaWdfYmxhbmtfYmxvY2tcXFxcXFxcIlxcXFxuICAgIH0pXFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IGdldE15VmFyKFxcXFxcXFwiTXlwdFxcXFxcXFwiKSA/IHRpdGxlICsgXFxcXFxcXCLliIbnsbtcXFxcXFxcIiA6IFxcXFxcXFwi6JmO54mZ5YiG57G7XFxcXFxcXCIsXFxcXG4gICAgICAgIHVybDogXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCIsXFxcXG4gICAgICAgIGltZzogZ2V0TXlWYXIoXFxcXFxcXCJNeXB0XFxcXFxcXCIpID8gaW1nIDogXFxcXFxcXCJodHRwczovL21iczEuYmRzdGF0aWMuY29tL3NlYXJjaGJveC9tYXBwY29uc29sZS9pbWFnZS8yMDIwMDkxNS81OGQzZTM4MC04MThiLTQ5MWEtYTk3My0xZWY0N2FhNWU4N2YuanBnQFJlZmVyZXI9XFxcXFxcXCIsXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImF2YXRhclxcXFxcXFwiXFxcXG4gICAgfSlcXFxcbiAgICBpZiAoZ2V0TXlWYXIoXFxcXFxcXCJNeXB0XFxcXFxcXCIpKSB7XFxcXG4gICAgICAgIHZhciBwdF91cmwgPSBcXFxcXFxcImh0dHA6Ly9saXZlLnlqMTIxMS53b3JrL2FwaS9saXZlL2dldEFyZWFzP3BsYXRmb3JtPVxcXFxcXFwiICsgZ2V0TXlWYXIoXFxcXFxcXCJNeXB0XFxcXFxcXCIpXFxcXG4gICAgfSBlbHNlIHtcXFxcbiAgICAgICAgdmFyIHB0X3VybCA9IFxcXFxcXFwiaHR0cDovL2xpdmUueWoxMjExLndvcmsvYXBpL2xpdmUvZ2V0QXJlYXM/cGxhdGZvcm09aHV5YVxcXFxcXFwiXFxcXG4gICAgfVxcXFxuXFxcXG4gICAgdmFyIHJlcyA9IEpTT04ucGFyc2UocmVxdWVzdChwdF91cmwpKS5kYXRhO1xcXFxuICAgIC8vbG9nKHJlcylcXFxcbiAgICBmb3IgKGxldCBqIGluIHJlcykge1xcXFxuICAgICAgICB2YXIgdGVtcCA9IHJlc1tqXVxcXFxuICAgICAgICBmb3IgKGRhdGEgb2YgdGVtcClcXFxcbiAgICAgICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IGRhdGEuYXJlYU5hbWUsXFxcXG4gICAgICAgICAgICAgICAgaW1nOiBkYXRhLmFyZWFQaWMgKyBcXFxcXFxcIkBSZWZlcmVyPVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIHVybDogXFxcXFxcXCJoaWtlcjovL3BhZ2UvbmV3Q2xhc3NMaXN0P3BhZ2U9ZnlwYWdlJnBsYXRmb3JtPVxcXFxcXFwiICsgZGF0YS5wbGF0Zm9ybSArIFxcXFxcXFwiJmFyZWE9XFxcXFxcXCIgKyBkYXRhLmFyZWFOYW1lLFxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImljb25fcm91bmRfNFxcXFxcXFwiXFxcXG4gICAgICAgICAgICB9KVxcXFxuICAgIH1cXFxcbn0gZWxzZSB7XFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiYmlnX2JsYW5rX2Jsb2NrXFxcXFxcXCJcXFxcbiAgICB9KVxcXFxuICAgIGQucHVzaCh7XFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImJpZ19ibGFua19ibG9ja1xcXFxcXFwiXFxcXG4gICAgfSlcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJsaW5lXFxcXFxcXCJcXFxcbiAgICB9KVxcXFxuICAgIGQucHVzaCh7XFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImJpZ19ibGFua19ibG9ja1xcXFxcXFwiXFxcXG4gICAgfSlcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJiaWdfYmxhbmtfYmxvY2tcXFxcXFxcIlxcXFxuICAgIH0pXFxcXG5cXFxcbiAgICAvL+eJiOWdl+WIhuexu1xcXFxuICAgIHZhciB1cmwgPSAnaHR0cDovL2xpdmUueWoxMjExLndvcmsvYXBpL2xpdmUvZ2V0QWxsQXJlYXMnO1xcXFxuICAgIHZhciByZXMgPSBKU09OLnBhcnNlKHJlcXVlc3QodXJsKSkuZGF0YTtcXFxcbiAgICAvL2xvZyhyZXMpXFxcXG5cXFxcbiAgICB2YXIgdHlwZU5hbWVzID0gW107XFxcXG4gICAgdmFyIGJpZ0xpc3QgPSBbXTtcXFxcbiAgICB2YXIgc21hbGxMaXN0ID0gW107XFxcXG4gICAgcHV0TXlWYXIoXFxcXFxcXCJ0eXBlTmFtZVZhclxcXFxcXFwiLCAhZ2V0TXlWYXIoJ3R5cGVOYW1lVmFyJykgPyAn5YWo6YOoJyA6IGdldE15VmFyKCd0eXBlTmFtZVZhcicpKTtcXFxcbiAgICBwdXRNeVZhcignYXJlYScsICdhcmVhTmFtZScpXFxcXG4gICAgZm9yIChsZXQgciBvZiByZXMpIHtcXFxcbiAgICAgICAgZm9yIChsZXQgeCBvZiByKSB7XFxcXG4gICAgICAgICAgICBpZiAoIXR5cGVOYW1lcy5pbmNsdWRlcyh4LnR5cGVOYW1lKSkge1xcXFxuICAgICAgICAgICAgICAgIHR5cGVOYW1lcy5wdXNoKHgudHlwZU5hbWUpO1xcXFxuICAgICAgICAgICAgICAgIGJpZ0xpc3QucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBnZXRNeVZhcihcXFxcXFxcInR5cGVOYW1lVmFyXFxcXFxcXCIpID09IHgudHlwZU5hbWUgPyAn4oCY4oCY4oCZ4oCZPHN0cm9uZz48Zm9udCBjb2xvcj1cXFxcXFxcIiNGQTcyOThcXFxcXFxcIj4nICsgeC50eXBlTmFtZSArICc8L2Zyb250Pjwvc3Ryb25nPicgOiB4LnR5cGVOYW1lLFxcXFxuICAgICAgICAgICAgICAgICAgICB1cmw6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKHR5cGVOYW1lVmFyKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFxcXFxcInR5cGVOYW1lVmFyXFxcXFxcXCIsIHR5cGVOYW1lVmFyKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCJcXFxcbiAgICAgICAgICAgICAgICAgICAgfSwgeC50eXBlTmFtZSksXFxcXG4gICAgICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInNjcm9sbF9idXR0b25cXFxcXFxcIlxcXFxuICAgICAgICAgICAgICAgIH0pXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICBzbWFsbExpc3QucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IHguYXJlYU5hbWUsXFxcXG4gICAgICAgICAgICAgICAgdXJsOiAnaGlrZXI6Ly9wYWdlL25ld0NsYXNzTGlzdD90eXBlTmFtZT0nICsgeC50eXBlTmFtZSArICcmYXJlYU5hbWU9JyArIHguYXJlYU5hbWUgKyBcXFxcXFxcIiZwYWdlPWZ5cGFnZVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIGltZzogeC5hcmVhUGljICsgXFxcXFxcXCJAUmVmZXJlcj1cXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJpY29uX3JvdW5kXzRcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICB0eXBlTmFtZTogeC50eXBlTmFtZVxcXFxuICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgfVxcXFxuICAgIH1cXFxcblxcXFxuICAgIGJpZ0xpc3QudW5zaGlmdCh7XFxcXG4gICAgICAgIHRpdGxlOiBnZXRNeVZhcihcXFxcXFxcInR5cGVOYW1lVmFyXFxcXFxcXCIpID09ICflhajpg6gnID8gJ+KAmOKAmOKAmeKAmTxzdHJvbmc+PGZvbnQgY29sb3I9XFxcXFxcXCIjRkE3Mjk4XFxcXFxcXCI+5YWo6YOoPC9mcm9udD48L3N0cm9uZz4nIDogJ+WFqOmDqCcsXFxcXG4gICAgICAgIHVybDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgodHlwZU5hbWVWYXIpID0+IHtcXFxcbiAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwidHlwZU5hbWVWYXJcXFxcXFxcIiwgdHlwZU5hbWVWYXIpO1xcXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIlxcXFxuICAgICAgICB9LCAn5YWo6YOoJyksXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInNjcm9sbF9idXR0b25cXFxcXFxcIlxcXFxuICAgIH0pXFxcXG4gICAgZCA9IGQuY29uY2F0KGJpZ0xpc3QpO1xcXFxuXFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiYmlnX2JsYW5rX2Jsb2NrXFxcXFxcXCJcXFxcbiAgICB9KVxcXFxuXFxcXG4gICAgLy9sb2coZ2V0TXlWYXIoJ3R5cGVOYW1lVmFyJykpXFxcXG4gICAgaWYgKGdldE15VmFyKCd0eXBlTmFtZVZhcicpID09ICflhajpg6gnKSB7XFxcXG4gICAgICAgIGQgPSBkLmNvbmNhdChzbWFsbExpc3QpO1xcXFxuICAgIH0gZWxzZSB7XFxcXG4gICAgICAgIGQgPSBkLmNvbmNhdChzbWFsbExpc3QuZmlsdGVyKHMgPT4gcy50eXBlTmFtZSA9PSBnZXRNeVZhcigndHlwZU5hbWVWYXInKSkpO1xcXFxuICAgIH1cXFxcbn1cXFxcbnNldFJlc3VsdChkKTtcXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfMlxcXCIsXFxcIm5hbWVcXFwiOlxcXCLmgLvliJfooahcXFwiLFxcXCJwYXRoXFxcIjpcXFwibmV3Q2xhc3NMaXN0XFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxudmFyIGQgPSBbXTtcXFxcbmFkZExpc3RlbmVyKCdvbkNsb3NlJywgJC50b1N0cmluZygoKSA9PiB7XFxcXG4gICAgY2xlYXJNeVZhcignTXlmcm8nKVxcXFxufSkpXFxcXG5pZiAoTVlfUEFHRSA9PSAxKSB7XFxcXG4gICAgbGV0IHRpdGxlID0gZ2V0TXlWYXIoXFxcXFxcXCJNeWZyb1xcXFxcXFwiKS5yZXBsYWNlKCdkb3V5dScsICfmlpfpsbwnKS5yZXBsYWNlKCdodXlhJywgJ+iZjueJmScpLnJlcGxhY2UoJ2JpbGliaWxpJywgJ+WTlOWTqScpLnJlcGxhY2UoJ2NjJywgJ+e9keaYkycpXFxcXG4gICAgbGV0IGltZyA9IGdldE15VmFyKFxcXFxcXFwiTXlmcm9cXFxcXFxcIikucmVwbGFjZSgnZG91eXUnLCAnaHR0cHM6Ly9iLmJkc3RhdGljLmNvbS9zZWFyY2hib3gvbWFwcGNvbnNvbGUvaW1hZ2UvMjAxODA4MDgvMTUzMzY5ODA0NTEwNTI3Ni5wbmdAUmVmZXJlcj0nKS5yZXBsYWNlKCdodXlhJywgJ2h0dHBzOi8vbWJzMS5iZHN0YXRpYy5jb20vc2VhcmNoYm94L21hcHBjb25zb2xlL2ltYWdlLzIwMjAwOTE1LzU4ZDNlMzgwLTgxOGItNDkxYS1hOTczLTFlZjQ3YWE1ZTg3Zi5qcGdAUmVmZXJlcj0nKS5yZXBsYWNlKCdiaWxpYmlsaScsICdodHRwczovL2IuYmRzdGF0aWMuY29tL3NlYXJjaGJveC9tYXBwY29uc29sZS9pbWFnZS8yMDE4MTAzMC8xNTQwODg5MDM4MTU5ODYyLnBuZ0BSZWZlcmVyPScpLnJlcGxhY2UoJ2NjJywgJ2h0dHBzOi8vY2MuZnAucHMubmV0ZWFzZS5jb20vZmlsZS82MGEzMWQzZTdmOWQyYTM5MTIwYmVhMDE2THA3WkVlMTAzQFJlZmVyZXI9JylcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogZ2V0TXlWYXIoXFxcXFxcXCJNeWZyb1xcXFxcXFwiKSA9PSAnJyA/ICfliIfmjaLlubPlj7AnIDogdGl0bGUgKyAn5bmz5Y+wJyxcXFxcbiAgICAgICAgdXJsOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKCgpID0+IHtcXFxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXG4gICAgICAgICAgICBjbGVhck15VmFyKFxcXFxcXFwiTXlmcm9cXFxcXFxcIilcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIlxcXFxuICAgICAgICB9KSxcXFxcbiAgICAgICAgaW1nOiBnZXRNeVZhcihcXFxcXFxcIk15ZnJvXFxcXFxcXCIpID09ICcnID8gJ2h0dHBzOi8vbGFubWVpZ3VvamlhbmcuY29tL3R1Ymlhby9tZXNzeS81LnN2Z0BSZWZlcmVyPScgOiBpbWcsXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImF2YXRhclxcXFxcXFwiXFxcXG4gICAgfSlcXFxcblxcXFxuICAgIGQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiBcXFxcXFxcIuaWl+mxvFxcXFxcXFwiLFxcXFxuICAgICAgICBpbWc6IFxcXFxcXFwiaHR0cHM6Ly9iLmJkc3RhdGljLmNvbS9zZWFyY2hib3gvbWFwcGNvbnNvbGUvaW1hZ2UvMjAxODA4MDgvMTUzMzY5ODA0NTEwNTI3Ni5wbmdAUmVmZXJlcj1cXFxcXFxcIixcXFxcbiAgICAgICAgdXJsOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKCgpID0+IHtcXFxcbiAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwiTXlmcm9cXFxcXFxcIiwgJ2RvdXl1Jyk7XFxcXG4gICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiXFxcXG4gICAgICAgIH0pLFxcXFxuICAgICAgICDCoGNvbF90eXBlOiBcXFxcXFxcImljb25fcm91bmRfc21hbGxfNFxcXFxcXFwiLFxcXFxuICAgIH0pXFxcXG5cXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogXFxcXFxcXCLomY7niZlcXFxcXFxcIixcXFxcbiAgICAgICAgaW1nOiBcXFxcXFxcImh0dHBzOi8vbWJzMS5iZHN0YXRpYy5jb20vc2VhcmNoYm94L21hcHBjb25zb2xlL2ltYWdlLzIwMjAwOTE1LzU4ZDNlMzgwLTgxOGItNDkxYS1hOTczLTFlZjQ3YWE1ZTg3Zi5qcGdAUmVmZXJlcj1cXFxcXFxcIixcXFxcbiAgICAgICAgdXJsOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKCgpID0+IHtcXFxcbiAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwiTXlmcm9cXFxcXFxcIiwgJ2h1eWEnKTtcXFxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCJcXFxcbiAgICAgICAgfSksXFxcXG4gICAgICAgIMKgY29sX3R5cGU6IFxcXFxcXFwiaWNvbl9yb3VuZF9zbWFsbF80XFxcXFxcXCIsXFxcXG4gICAgfSlcXFxcblxcXFxuICAgIGQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiBcXFxcXFxcIuWTlOWTqVxcXFxcXFwiLFxcXFxuICAgICAgICBpbWc6IFxcXFxcXFwiaHR0cHM6Ly9iLmJkc3RhdGljLmNvbS9zZWFyY2hib3gvbWFwcGNvbnNvbGUvaW1hZ2UvMjAxODEwMzAvMTU0MDg4OTAzODE1OTg2Mi5wbmdAUmVmZXJlcj1cXFxcXFxcIixcXFxcbiAgICAgICAgdXJsOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKCgpID0+IHtcXFxcbiAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwiTXlmcm9cXFxcXFxcIiwgJ2JpbGliaWxpJyk7XFxcXG4gICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiXFxcXG4gICAgICAgIH0pLFxcXFxuICAgICAgICDCoGNvbF90eXBlOiBcXFxcXFxcImljb25fcm91bmRfc21hbGxfNFxcXFxcXFwiLFxcXFxuICAgIH0pXFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IFxcXFxcXFwi572R5piTXFxcXFxcXCIsXFxcXG4gICAgICAgIGltZzogXFxcXFxcXCJodHRwczovL2NjLmZwLnBzLm5ldGVhc2UuY29tL2ZpbGUvNjBhMzFkM2U3ZjlkMmEzOTEyMGJlYTAxNkxwN1pFZTEwM0BSZWZlcmVyPVxcXFxcXFwiLFxcXFxuICAgICAgICB1cmw6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKCkgPT4ge1xcXFxuICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCJNeWZyb1xcXFxcXFwiLCAnY2MnKTtcXFxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCJcXFxcbiAgICAgICAgfSksXFxcXG4gICAgICAgIMKgY29sX3R5cGU6IFxcXFxcXFwiaWNvbl9yb3VuZF9zbWFsbF80XFxcXFxcXCIsXFxcXG4gICAgfSlcXFxcbn1cXFxcbmQucHVzaCh7XFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwibGluZVxcXFxcXFwiXFxcXG59KVxcXFxuZC5wdXNoKHtcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJiaWdfYmxhbmtfYmxvY2tcXFxcXFxcIlxcXFxufSlcXFxcbmQucHVzaCh7XFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwiYmlnX2JsYW5rX2Jsb2NrXFxcXFxcXCJcXFxcbn0pXFxcXG5cXFxcbmxldCB6b25nID0gJ2h0dHA6Ly9saXZlLnlqMTIxMS53b3JrL2FwaS9saXZlL2dldFJlY29tbWVuZEJ5QXJlYUFsbD9hcmVhVHlwZT0nICsgZ2V0UGFyYW0oXFxcXFxcXCJ0eXBlTmFtZVxcXFxcXFwiKSArICcmYXJlYT0nICsgZ2V0UGFyYW0oXFxcXFxcXCJhcmVhTmFtZVxcXFxcXFwiKSArICcmcGFnZT0nICsgZ2V0UGFyYW0oXFxcXFxcXCJwYWdlXFxcXFxcXCIpXFxcXG5cXFxcbmxldCB6ZiA9IFxcXFxcXFwiaHR0cDovL2xpdmUueWoxMjExLndvcmsvYXBpL2xpdmUvZ2V0UmVjb21tZW5kQnlQbGF0Zm9ybUFyZWE/cGxhdGZvcm09XFxcXFxcXCIgKyBnZXRNeVZhcihcXFxcXFxcIk15ZnJvXFxcXFxcXCIpICsgXFxcXFxcXCImYXJlYT1cXFxcXFxcIiArIGdldFBhcmFtKFxcXFxcXFwiYXJlYU5hbWVcXFxcXFxcIikgKyBcXFxcXFxcIiZwYWdlPVxcXFxcXFwiICsgZ2V0UGFyYW0oXFxcXFxcXCJwYWdlXFxcXFxcXCIpICsgXFxcXFxcXCImc2l6ZT0yMFxcXFxcXFwiXFxcXG5cXFxcbmxldCBwaW4gPSBcXFxcXFxcImh0dHA6Ly9saXZlLnlqMTIxMS53b3JrL2FwaS9saXZlL2dldFJlY29tbWVuZEJ5UGxhdGZvcm1BcmVhXFxcXFxcXCIgKyBNWV9VUkwucmVwbGFjZShcXFxcXFxcImhpa2VyOi8vcGFnZS9uZXdDbGFzc0xpc3RcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIikgKyBcXFxcXFxcIiZwYWdlPVxcXFxcXFwiICsgZ2V0UGFyYW0oXFxcXFxcXCJwYWdlXFxcXFxcXCIpICsgXFxcXFxcXCImc2l6ZT0yMFxcXFxcXFwiXFxcXG4vL2xvZyhwaW4pXFxcXG5cXFxcbmxldCBwZiA9IFxcXFxcXFwiaHR0cDovL2xpdmUueWoxMjExLndvcmsvYXBpL2xpdmUvZ2V0UmVjb21tZW5kQnlQbGF0Zm9ybUFyZWE/cGxhdGZvcm09XFxcXFxcXCIgKyBnZXRNeVZhcihcXFxcXFxcIk15ZnJvXFxcXFxcXCIpICsgXFxcXFxcXCImYXJlYT1cXFxcXFxcIiArIGdldE15VmFyKFxcXFxcXFwiYXJlYVxcXFxcXFwiKSArIFxcXFxcXFwiJnBhZ2U9XFxcXFxcXCIgKyBnZXRQYXJhbShcXFxcXFxcInBhZ2VcXFxcXFxcIikgKyBcXFxcXFxcIiZzaXplPTIwXFxcXFxcXCJcXFxcblxcXFxudHJ5IHtcXFxcbiAgICBsZXQgYXJlYSA9IHBpbi5tYXRjaCgvYXJlYT0oLio/KSYvKVsxXVxcXFxuICAgIC8vbG9nKGFyZWEpXFxcXG4gICAgcHV0TXlWYXIoXFxcXFxcXCJhcmVhXFxcXFxcXCIsIGFyZWEpXFxcXG59IGNhdGNoIChlKSB7XFxcXG4gICAgdmFyIGFyZWEgPSAnJ1xcXFxufVxcXFxuaWYgKGFyZWEgPT0gJycpIHtcXFxcbiAgICBpZiAoZ2V0TXlWYXIoXFxcXFxcXCJNeWZyb1xcXFxcXFwiKSkge1xcXFxuICAgICAgICB2YXIgdXJsID0gemZcXFxcbiAgICB9IGVsc2Uge1xcXFxuICAgICAgICB2YXIgdXJsID0gem9uZ1xcXFxuICAgIH1cXFxcbn0gZWxzZSB7XFxcXG4gICAgaWYgKGdldE15VmFyKFxcXFxcXFwiTXlmcm9cXFxcXFxcIikpIHtcXFxcbiAgICAgICAgdmFyIHVybCA9IHBmXFxcXG4gICAgfSBlbHNlIHtcXFxcbiAgICAgICAgdmFyIHVybCA9IHBpblxcXFxuICAgIH1cXFxcbn1cXFxcblxcXFxudHJ5IHtcXFxcbiAgICB2YXIgcmVzID0gSlNPTi5wYXJzZShyZXF1ZXN0KHVybCkpLmRhdGFcXFxcbiAgICBpZiAocmVzID09ICcnKSB7XFxcXG4gICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZTogJzxicj4nLFxcXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdyaWNoX3RleHQnXFxcXG4gICAgICAgIH0pXFxcXG4gICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZTogJzxicj4nLFxcXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdyaWNoX3RleHQnXFxcXG4gICAgICAgIH0pXFxcXG4gICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICBkZXNjOiAn5pqC5peg5oi/6Ze0XFxcXFxcXFxuXFxcXFxcXFxu6K+35YiH5o2i5bmz5Y+w6KeC55yLJyxcXFxcbiAgICAgICAgICAgIHVybDogJ2hpa2VyOi8vZW1wdHknLFxcXFxuICAgICAgICAgICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJ1xcXFxuICAgICAgICB9KTtcXFxcbiAgICB9XFxcXG5cXFxcbiAgICBmb3IgKGRhdGEgb2YgcmVzKSB7XFxcXG4gICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZTogZGF0YS5jYXRlZ29yeU5hbWUgKyAnwrcnICsgZGF0YS5yb29tTmFtZSxcXFxcbiAgICAgICAgICAgIGRlc2M6IGRhdGEucGxhdEZvcm0ucmVwbGFjZSgnaHV5YScsICfomY7niZknKS5yZXBsYWNlKCdkb3V5dScsICfmlpfpsbwnKS5yZXBsYWNlKCdjYycsICfnvZHmmJNDQycpLnJlcGxhY2UoXFxcXFxcXCJiaWxpYmlsaVxcXFxcXFwiLCBcXFxcXFxcIuWTlOWTqeWTlOWTqVxcXFxcXFwiKSArICfCtycgKyBkYXRhLm93bmVyTmFtZSxcXFxcbiAgICAgICAgICAgIGltZzogKGRhdGEucm9vbVBpYy5zdGFydHNXaXRoKCcvJykgPyAnaHR0cHM6JyArIGRhdGEucm9vbVBpYyA6IGRhdGEucm9vbVBpYykgKyAnQFJlZmVyZXI9JyxcXFxcbiAgICAgICAgICAgIHVybDogXFxcXFxcXCJoaWtlcjovL3BhZ2UvZGV0YWlsPyNpbW1lcnNpdmVUaGVtZSMmcm9vbWlkPVxcXFxcXFwiICsgZGF0YS5yb29tSWQgKyBcXFxcXFxcIiZwbGF0Zm9ybT1cXFxcXFxcIiArIGRhdGEucGxhdEZvcm1cXFxcbiAgICAgICAgfSlcXFxcbiAgICB9XFxcXG59IGNhdGNoIChlKSB7XFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6ICc8YnI+JyxcXFxcbiAgICAgICAgY29sX3R5cGU6ICdyaWNoX3RleHQnXFxcXG4gICAgfSlcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogJzxicj4nLFxcXFxuICAgICAgICBjb2xfdHlwZTogJ3JpY2hfdGV4dCdcXFxcbiAgICB9KTtcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICBkZXNjOiAn5pqC5peg5oi/6Ze0XFxcXFxcXFxuXFxcXFxcXFxu6K+35YiH5o2i5bmz5Y+w6KeC55yLJyxcXFxcbiAgICAgICAgdXJsOiAnaGlrZXI6Ly9lbXB0eScsXFxcXG4gICAgICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMSdcXFxcbiAgICB9KTtcXFxcbn1cXFxcbnNldFJlc3VsdChkKTtcXFwifV1cIixcInByb3h5XCI6XCJcIn0iLCJwaWNVcmwiOiJodHRwczovL3N0YS1vcC5kb3V5dWNkbi5jbi9keWNhdHIvZjcyZWJjNGZlYmU1MjI4MGVmNDYwNDk0ZTMwMjY0NTkucG5nQFJlZmVyZXI9IiwidGl0bGUiOiLmm7TlpJot6Iux6ZuE6IGU55ufIn0=
DZ33AnhD,Магазин,voldmaks,C#,Saturday 3rd of June 2023 07:47:52 AM CDT,"using System;
using System.Collections.Generic;

namespace Магазин
{
    internal class Program
    {
        static void Main(string[] args)
        {
            Launch launch = new Launch();
            launch.LaunchProgram();
        }
    }

    class Launch
    {
        private Buyer _buyer = new Buyer();
        private Seller _seller = new Seller();

        public void LaunchProgram()
        {
            const string CommandShowSellerProducts = ""1"";
            const string CommandShowBuyerProducts = ""2"";
            const string CommandBuyProduct = ""3"";
            const string CommandCloseProgram = ""4"";
            bool isWork = true;

            while (isWork)
            {
                Console.WriteLine($""{CommandShowSellerProducts} - Показать список товаров продавца\n{CommandShowBuyerProducts} - Показать список товаров покупателя\n{CommandBuyProduct} - Купить товар\n{CommandCloseProgram} - Закрыть программу"");

                switch (Console.ReadLine())
                {
                    case CommandShowSellerProducts:
                        _seller.ShowInfo();
                        break;

                    case CommandShowBuyerProducts:
                        _buyer.ShowInfo();
                        break;

                    case CommandBuyProduct:
                        _buyer.BuyProduct(_seller.GiveProduct());
                        break;

                    case CommandCloseProgram:
                        isWork = false;
                        break;

                    default:
                        Console.WriteLine(""Нет такой команды"");
                        break;
                }

                Console.ReadKey();
                Console.Clear();
            }
        }
    }

    class Buyer
    {
        private List<Product> _products = new List<Product>();

        public void BuyProduct(Product product)
        {
            if (product != null)
            {
                _products.Add(product);
            }
            else
            {
                Console.WriteLine(""Продукт не приобретён"");
            }
        }

        public void ShowInfo()
        {
            if (_products.Count != 0)
            {
                for (int i = 0; i < _products.Count; i++)
                {
                    Console.Write($""{i} - "");
                    _products[i].ShowInfo();
                }
            }
            else
            {
                Console.WriteLine(""У вас нет купленного товара"");
            }
        }
    }

    class Seller
    {
        private List<Product> _products = new List<Product>();

        public Seller()
        {
            _products.AddRange(new[]
            {
                new Product(""Беляш""),
                new Product(""Чебурек""),
                new Product(""Самса""),
                new Product(""Хачапури""),
                new Product(""Ханума""),
                new Product(""Перемячи"")
            });
        }

        public Product GiveProduct()
        {
            Console.WriteLine(""Введите номер продукта, который желаете получить"");
            int enteredValue = CheckEnteredValue();

            if (enteredValue > 0 && enteredValue <= _products.Count)
            {
                Product product = _products[enteredValue];
                _products.Remove(_products[enteredValue]);

                return product;
            }
            else
            {
                return null;
            }
        }

        public void ShowInfo()
        {
            for (int i = 0; i < _products.Count; i++)
            {
                Console.Write($""{i} - "");
                _products[i].ShowInfo();
            }
        }

        private int CheckEnteredValue()
        {
            if (int.TryParse(Console.ReadLine(), out int parsingValue))
            {
                return parsingValue;
            }
            else
            {
                return -1;
            }
        }
    }

    class Product
    {
        private string _name;

        public Product(string name)
        {
            _name = name;
        }

        public void ShowInfo()
        {
            Console.WriteLine(_name);
        }
    }
}"
qKfjv72a,C,SY573M_404,Python,Saturday 3rd of June 2023 07:06:22 AM CDT,"import itertools
 
def main():
    in_file = open(""choose.in"", ""r"")
    n, k = map(int, in_file.readline().split("" ""))
    in_file.close()
 
    out_file = open(""choose.out"", ""w"")
    out_file.writelines(
        map(
            lambda permutation: "" "".join(map(str, permutation)) + ""\n"",
            itertools.combinations(range(1, n + 1), k),
        ),
    )
    out_file.close()
 
main()"
