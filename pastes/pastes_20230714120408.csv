id,title,username,language,date,content
6QjzjSaj,Libreswan_xfrm_refcount_ip_test_failure,bradyallenjohnson,Bash,Friday 14th of July 2023 06:52:30 AM CDT,"$ ./testing/utils/namespace-runner.py -j 1 basic-pluto-01
running queue of 1
testlist: basic-pluto-01
START: basic-pluto-01
   FAILED: basic-pluto-01



-----------------------
total  tests: 1
passed tests: 0
failed tests: 1
runtime: 00:00:12
-----------------------
passed tests: 
-----------------------
failed tests: basic-pluto-01


$ cd testing/pluto/basic-pluto-01/OUTPUT

$ more east.console.diff
--- east.console.txt	2023-07-14 11:36:25.268642730 +0000
+++ OUTPUT/east.console.txt	2023-07-14 11:43:58.027788010 +0000
@@ -136,7 +136,6 @@
 	replay-window 0 flag af-unspec
 	auth-trunc hmac(sha1) 0xHASHKEY 96
 	enc cbc(aes) 0xENCKEY
-	lastused YYYY-MM-DD HH:MM:SS
 	anti-replay esn context:
 	 seq-hi 0x0, seq 0xXX, oseq-hi 0x0, oseq 0xXX
 	 replay_window 128, bitmap-length 4
@@ -146,7 +145,6 @@
 	replay-window 0 flag af-unspec
 	auth-trunc hmac(sha1) 0xHASHKEY 96
 	enc cbc(aes) 0xENCKEY
-	lastused YYYY-MM-DD HH:MM:SS
 	anti-replay esn context:
 	 seq-hi 0x0, seq 0xXX, oseq-hi 0x0, oseq 0xXX
 	 replay_window 128, bitmap-length 4


$ grep lastused *
east.console.diff:-	lastused YYYY-MM-DD HH:MM:SS
east.console.diff:-	lastused YYYY-MM-DD HH:MM:SS
east.pluto.log:| kernel: get_ipsec_traffic() bytes=0 add_time=1689335035 lastused=0
east.pluto.log:| kernel: get_ipsec_traffic() bytes=0 add_time=1689335035 lastused=0
east.pluto.log:| kernel: get_ipsec_traffic() bytes=0 add_time=1689335035 lastused=0
east.pluto.log:| kernel: get_ipsec_traffic() bytes=0 add_time=1689335035 lastused=0
east.pluto.log:| kernel: get_ipsec_traffic() bytes=0 add_time=1689335035 lastused=0
east.pluto.log:| kernel: get_ipsec_traffic() bytes=0 add_time=1689335035 lastused=0
east.pluto.log:| kernel: get_ipsec_traffic() bytes=84 add_time=1689335035 lastused=0
east.pluto.log:| kernel: get_ipsec_traffic() bytes=84 add_time=1689335035 lastused=0
east.pluto.log:| kernel: get_ipsec_traffic() bytes=84 add_time=1689335035 lastused=0
east.pluto.log:| kernel: get_ipsec_traffic() bytes=84 add_time=1689335035 lastused=0
west.console.diff:-	lastused YYYY-MM-DD HH:MM:SS
west.console.diff:-	lastused YYYY-MM-DD HH:MM:SS
west.pluto.log:| kernel: get_ipsec_traffic() bytes=0 add_time=1689335035 lastused=0
west.pluto.log:| kernel: get_ipsec_traffic() bytes=0 add_time=1689335035 lastused=0
west.pluto.log:| kernel: get_ipsec_traffic() bytes=0 add_time=1689335035 lastused=0
west.pluto.log:| kernel: get_ipsec_traffic() bytes=0 add_time=1689335035 lastused=0
west.pluto.log:| kernel: get_ipsec_traffic() bytes=0 add_time=1689335035 lastused=0
west.pluto.log:| kernel: get_ipsec_traffic() bytes=0 add_time=1689335035 lastused=0
west.pluto.log:| kernel: get_ipsec_traffic() bytes=84 add_time=1689335035 lastused=0
west.pluto.log:| kernel: get_ipsec_traffic() bytes=84 add_time=1689335035 lastused=0
west.pluto.log:| kernel: get_ipsec_traffic() bytes=84 add_time=1689335035 lastused=0
west.pluto.log:| kernel: get_ipsec_traffic() bytes=84 add_time=1689335035 lastused=0
west.pluto.log:| kernel: get_ipsec_traffic() bytes=84 add_time=1689335035 lastused=0
west.pluto.log:| kernel: get_ipsec_traffic() bytes=84 add_time=1689335035 lastused=0
"
w0njVKDR,Untitled,Darwinwaswrong,C++,Friday 14th of July 2023 06:40:56 AM CDT," #include<Wire.h>                //I2C Wire Library
    #include<Servo.h>               //Servo Motor Library
    ​
    Servo servo_1;
    Servo servo_2;
    Servo servo_3;
    Servo servo_4;
    ​
    const int MPU_addr=0x68;        //MPU6050 I2C Address
    ​
    int16_t axis_X, axis_Y, axis_Z;
    int minVal=265;
    int maxVal=402;
    ​
    double x;
    double y;
    double z;
    ​
    void setup()
    {
      Serial.begin(9600);
    ​
      Wire.begin();                      //Initilize I2C Communication
      Wire.beginTransmission(MPU_addr);  //Start communication with MPU6050
      Wire.write(0x6B);                  //Writes to Register 6B
      Wire.write(0);                     //Writes 0 into 6B Register to Reset
      Wire.endTransmission(true);        //Ends I2C transmission
    ​
      servo_1.attach(2);   // Forward/Reverse_Motor
      servo_2.attach(3);   // Up/Down_Motor
      servo_3.attach(4);    // Forward/Reverse_Motor
      servo_4.attach(5);   // Left/Right_Motor
    }
    ​
    void loop()
    {
      Wire.beginTransmission(MPU_addr);
      Wire.write(0x3B);                  //Start with regsiter 0x3B
      Wire.endTransmission(false);
      Wire.requestFrom(MPU_addr,14,true);  //Read 14 Registers
    ​
      axis_X=Wire.read()<<8|Wire.read();                //Reads the MPU6050 X,Y,Z AXIS Value
      axis_Y=Wire.read()<<8|Wire.read();
      axis_Z=Wire.read()<<8|Wire.read();
    ​
      int xAng = map(axis_X,minVal,maxVal,-90,90);     // Maps axis values in terms of -90 to +90
      int yAng = map(axis_Y,minVal,maxVal,-90,90);
      int zAng = map(axis_Z,minVal,maxVal,-90,90);
    ​
      x= RAD_TO_DEG * (atan2(-yAng, -zAng)+PI);       //Formula to convert into degree
      y= RAD_TO_DEG * (atan2(-xAng, -zAng)+PI);
      z= RAD_TO_DEG * (atan2(-yAng, -xAng)+PI);
    ​
      // forward backward using 2 mid servo(m1 m3)-ROLL
      if (x >=0 && x <= 60)
      {
         int mov1 = map(x,0,60,0,90);
         Serial.print(""Movement in up/down = "");
         Serial.print(mov1);
         Serial.println((char)176);
         servo_1.write(mov1),servo_3.write(mov1);
      }
      else if (x >=300 && x <= 360)
      {
         int mov1 = map(x,360,250,0,180);
         Serial.print(""Movement in Up/Down = "");
         Serial.print(mov1);
         Serial.println((char)176);
         servo_1.write(mov1),servo_3.write(mov1);
      }
    ​
      // up and down using m2-PITCH
      if (y >=0 && y <= 60)
      {
         int mov2 = map(y,0,60,0,90);
         Serial.print(""Movement in F/R = "");
         Serial.print(mov2);
         Serial.println((char)176);
         servo_4.write(mov2);
      }
      else if(y >=300 && y <= 360)
      {
         int mov2 = map(y,360,250,0,180);
         Serial.print(""Movement in F/R = "");
         Serial.print(mov2);
         Serial.println((char)176);
         servo_4.write(mov2);
      }
    ​
      // left right using bottom servo(m4)-YAW
      if(z >=0 && z <= 60)
      {
         int mov3 = map(z,0,60,90,180);
         Serial.print(""Movement in Left = "");
         Serial.print(mov3);
         Serial.println((char)176);
         servo_2.write(mov3);
      }
      else if (z >=300 && z <= 360)
      {
         int mov3 = map(z,360,300,90,0);
         Serial.print(""Movement in Right = "");
         Serial.print(mov3);
         Serial.println((char)176);
         servo_2.write(mov3);
      }
    }

"
2NV103DT,Untitled,LazerBloxx,Lua,Friday 14th of July 2023 06:39:29 AM CDT,"local OrionLib = loadstring(game:HttpGet(('https://raw.githubusercontent.com/shlexware/Orion/main/source')))()
local Player = game.Players.LocalPlayer
local Window = OrionLib:MakeWindow({Name = ""Lynch Syndicate"", HidePremium = false, SaveConfig = false})

OrionLib:MakeNotification({
	Name = ""Logged in!"",
	Content = ""You are logged in as ""..Player.Name..""."",
	Image = ""rbxassetid://12738913447"",
	Time = 5
})

local key = ""yuh""

function CorrectKeyNotification()
  OrionLib:MakeNotification({
	Name = ""Correct Key!"",
	Content = ""You have entered the correct key"",
	Image = ""rbxassetid://12738913447"",
	Time = 5
})
end

function IncorrectKeyNotification()
  OrionLib:MakeNotification({
	Name = ""Incorrect Key!"",
	Content = ""You have entered the incorrect key"",
	Image = ""rbxassetid://12738913447"",
	Time = 5
})
end

function MakeScriptHub()
  loadstring(game:HttpGet(""https://raw.githubusercontent.com/advxzivhsjjdhxhsidifvsh/mobkeyboard/main/main.txt"", true))()
end

function DestroyUI()
  OrionLib:Destroy()
end

local Tab = Window:MakeTab({
	Name = ""Key"",
	Icon = ""rbxassetid://11330899276"",
	PremiumOnly = false
})

Tab:AddTextbox({
	Name = ""Enter Key"",
	Default = ""Enter Key"",
	TextDisappear = false,
	Callback = function(Value)
	  local key = Value
	end	  
})

Tab:AddButton({
	Name = ""Check Key!"",
	Callback = function()
      	if tostring(key) == ""yuh""
      	print(""random sht has executed"")
      	else
      	  print(""wrong key bozo ass kid"")
      	  end
  	end    
})

OrionLib:Init()"
fSz6ZT9N,Untitled,FladeX,HTML,Friday 14th of July 2023 06:16:30 AM CDT,"<!-- Yandex.Metrika counter -->
<script type=""text/javascript"" >
   (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
   m[i].l=1*new Date();
   for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
   k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
   (window, document, ""script"", ""https://mc.yandex.ru/metrika/tag.js"", ""ym"");

   ym(94306699, ""init"", {
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true,
        webvisor:true
   });
</script>
<noscript><div><img src=""https://mc.yandex.ru/watch/94306699"" style=""position:absolute; left:-9999px;"" alt="""" /></div></noscript>
<!-- /Yandex.Metrika counter -->"
HcQcjMGi,BTC Wallet Credentials have been reset,steedaerod_88,GetText,Friday 14th of July 2023 06:14:53 AM CDT,"Dear User
We have received a request to reset the login information for your Bitcoin wallet. If you did not make this request, please disregard this message.
Your new login credentials are 2lajozgj:jZc4GT on 45.9.148.244
You can connect via SSH.
Regards"
P0sLYzEf,Untitled,FladeX,HTML,Friday 14th of July 2023 06:08:28 AM CDT,"<!-- Yandex.Metrika counter -->
<script type=""text/javascript"" >
   (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
   m[i].l=1*new Date();
   for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
   k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
   (window, document, ""script"", ""https://mc.yandex.ru/metrika/tag.js"", ""ym"");

   ym(94306638, ""init"", {
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true,
        webvisor:true
   });
</script>
<noscript><div><img src=""https://mc.yandex.ru/watch/94306638"" style=""position:absolute; left:-9999px;"" alt="""" /></div></noscript>
<!-- /Yandex.Metrika counter -->"
899ddGdr,Untitled,35657,C++,Friday 14th of July 2023 06:01:43 AM CDT,"
#include <string>
#include <iostream>

using namespace std;

//млекопитающее
class Mammal {
public:
    void SetGender(string gender) {
        gender_ = gender;
    }

    void SetAge(int age) {
        age_ = age;
    }

    int GetAge() const {
        return age_;
    }
    string GetGender() const {
        return gender_;
    }

    void SetWeight(int weight) {
        weight_ = weight;
    }

    int GetWeight() {
        return weight_;
    }

    void SetHeight(int height) {
        height_ = height;
    }

    int GetHeight() {
        return height_;
    }

private:
    string gender_;
    int age_;
    int weight_;
    int height_;
};


// Человек
class Person : public virtual Mammal {

public:

    void SetName(string name) {
        name_ = name;
    }

    string GetName() const {
        return name_;
    }

    virtual void Speak() {
        cout << ""Привет!"" << endl;
    }

private:
    string name_;
};


class Wolf : public virtual Mammal {

public:

    void SetColour(string colour) {
        colour_ = colour;
    }

    string GetColour() {
        return colour_;
    }

private:
    string colour_;
};


class Warewolf : public Person, public Wolf {
public:
    void Speak() override {
        cout << ""У-у-у-у-у-у!"" << endl;
    }
};


int main() {
    setlocale(LC_ALL, ""ru"");

    Warewolf wf;

    wf.SetName(""John"");
    wf.SetColour(""Gray"");
    wf.SetAge(10);
    cout << wf.GetName() << "" "" << wf.GetColour() << "" "" << wf.GetAge() << endl;
    wf.Speak();
}"
W7fcvQRP,data633,TestGuy1,JSON,Friday 14th of July 2023 06:00:05 AM CDT,"{
  status: 'Success',
  method: 'server',
  maindata: '8d1dadd3571b303b920427436ff3e52610b7f2717adca08dd06e8b178585331d125a7800391f7a010c602776162e3716883e953720b7445135fd3280da6787ff5cacffa523262d8701d89465fbf9defa44b6af367cb054061de18d0865b65ba6f9cec313151fcd00df6cc90f7048b14f0271ff3cbab6a4566ede69ed255dbced',
  otherdata: [
    'e6bb7c53721abfffcf339fb05799f958',
    'b4af463456cf4c1a4692be29412873c8',
    '713f26da10b2825a55353e664299557b',
    'e1ac985bb88ba2b4d21f156dd5536dfe',
    'fbb726339d4671c4c3611b5386a3ca9a',
    '4312c01d825e4e02ce80940387b606bb',
    '67d8596e965609498d380bbfbfc967fc',
    '229f787867eb2b0bec3b7ec9f1bd270b'
  ]
}"
RFzrzvXF,Untitled,35657,C++,Friday 14th of July 2023 05:59:52 AM CDT,"
#include <string>
#include <iostream>

using namespace std;


// Человек
class Person {
public:

    void SetName(string name) {
        name_ = name;
    }

    void SetGender(string gender) {
        gender_ = gender;
    }

    void SetAge(int age) {
        age_ = age;
    }

    string GetName() const {
        return name_;
    }
    int GetAge() const {
        return age_;
    }
    string GetGender() const {
        return gender_;
    }

    virtual void Speak() {
        cout << ""Привет!"" << endl;
    }

    string name_;
    string gender_;
    int age_;
};


class Wolf {

public:
    void SetWeight(int weight) {
        weight_ = weight;
    }

    int GetWeight() {
        return weight_;
    }

    void SetHeight(int height) {
        height_ = height;
    }

    int GetHeight() {
        return height_;
    }

    void SetColour(string colour) {
        colour_ = colour;
    }

    string GetColour() {
        return colour_;
    }

private:
    int weight_;
    int height_;
    string colour_;
};


class Warewolf : public Person, public Wolf {
public:
    void Speak() override {
        cout << ""У-у-у-у-у-у!"" << endl;
    }
};


int main() {
    setlocale(LC_ALL, ""ru"");

    Warewolf wf;

    wf.SetName(""John"");
    wf.SetColour(""Gray"");
    cout << wf.GetName() << "" "" << wf.GetColour() << endl;
    wf.Speak();
}"
Q6K41xuL,Untitled,orie404,PHP,Friday 14th of July 2023 05:45:54 AM CDT,"<?php

namespace App\Http\Controllers\Payment;

use App\Http\Traits\PaymentTrait;
use App\Http\Controllers\Controller;
use App\Models\Earning;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Log;
use Midtrans\Transaction;

class MidtransController extends Controller
{
    use PaymentTrait;

    public function success(Request $request)
    {

        $job_payment_type = session('job_payment_type') ?? 'package_job';
        $payload = $request->all();

        Log::info('incoming-midtrans', [
            'payload'   => $payload
        ]);

        $orderId = $payload['ordeer_id'];
        $statusCode = $payload['status_code'];
        $grossAmount = $payload['gross_amount'];

        $reqSignature = $payload['signature_key'];

        $signature = hash('sha512', $orderId . $statusCode . $grossAmount . config('midtrans.key'));

        if ($signature != $reqSignature) {
            return response()->json([
                'message' => 'invalid signature'
            ], 401);
        }

        $order = Transaction::find($orderId);
        $transactionStatus = $payload['transaction_status'];

        if (!$order) {
            return response()->json([
                ""message"" => ""invalid order""
            ], 400);
        }

        if ($transactionStatus == 'settlement') {
            $order->status = 'PAID';
            $order->save();
        } elseif ($transactionStatus == 'expire') {
            $order->status = 'expire';
            $order->save();
        }
        $usd_amount = currencyConversion($payload['gross_amount']);

        Earning::create([
            'order_id' => $payload['order_id'],
            'transaction_id' => $payload['transaction_id'],
            'payment_provider' => $payload['payment_type'],
            'plan_id' => $payload['gross_amount'],
            'company_id' => auth('user')->user()->company->id,
            'amount' => $payload['gross_amount'],
            'currency_symbol' => config('jobpilot.currency_symbol'),
            'usd_amount' => $usd_amount,
            'payment_type' => $job_payment_type == 'per_job' ? 'per_job_based' : 'subscription_based',
        ]);

        // plan data store
        $this->orderPlacing(false);

        // forget midtrans session
        session()->forget('payment_details');
        session()->flash('success', 'Payment Successfully');

        // redirect url pass
        return response()->json([
            'redirect_url' => route('company.plan'),
        ]);
    }
}
"
YzmbCJ4f,Review Milton Prime,fxvnpro,PHP,Friday 14th of July 2023 05:45:24 AM CDT,https://www.fxvnpro.com/review-milton-prime/
sLByMMW7,Untitled,35657,C++,Friday 14th of July 2023 05:36:11 AM CDT,"
#include <string>
#include <iostream>

using namespace std;


// Человек
class Person {
public:

    void SetName(string name) {
        name_ = name;
    }

    void SetGender(string gender) {
        gender_ = gender;
    }

    void SetAge(int age) {
        age_ = age;
    }

    string GetName() const {
        return name_;
    }
    int GetAge() const {
        return age_;
    }
    string GetGender() const {
        return gender_;
    }

    string name_;
    string gender_;
    int age_;
};

// Рабочий
class Worker : public virtual Person {
public:

    void SetSpeciality(string speciality) {
        speciality_ = speciality;
    }
    string GetSpeciality() const {
        return speciality_;
    }

    void Speak() {
        cout << ""Привет, я рабочий"" << endl;
    }

private:
    string speciality_;
};


// Студент
class Student : public virtual Person {
public:

    void SetFaculty(string faculty) {
        faculty_ = faculty;
    }
    string GetFaculty() const {
        return faculty_;
    }

    void Speak() {
        cout << ""Привет, я студент"" << endl;
    }

private:
    string faculty_;
};


// 
class ExternalStudent : public Worker, public Student  {

};


int main() {
    setlocale(LC_ALL, ""ru"");

    ExternalStudent ex;

    ex.SetSpeciality(""Builder"");
    ex.SetFaculty(""Programming"");

    cout << ex.GetSpeciality() << "" "" << ex.GetFaculty() << endl;

    ex.SetName(""Иван""); // теперь это работает
    cout << ex.GetName() << endl; 
}"
WJ5hsZHB,Sentences Game,AhmadXploit,Dart,Friday 14th of July 2023 05:09:27 AM CDT,"[
  {
    ""sentence"": ""The cat is sleeping on the mat"",
    ""correctOrder"": ""The cat is on sleeping the mat""
  },
  {
    ""sentence"": ""I love eating pizza with my friends"",
    ""correctOrder"": ""I love eating pizza with friends my""
  },
  {
    ""sentence"": ""She plays the guitar beautifully"",
    ""correctOrder"": ""She plays the beautifully guitar""
  }
]"
aAjX595b,Untitled,LazerBloxx,Lua,Friday 14th of July 2023 05:04:22 AM CDT,"local OrionLib = loadstring(game:HttpGet(('https://raw.githubusercontent.com/shlexware/Orion/main/source')))()
local Player = game.Players.LocalPlayer
local Window = OrionLib:MakeWindow({Name = ""Void Hub"", HidePremium = false, SaveConfig = false})

local Tab = Window:MakeTab({
	Name = ""Introduction"",
	Icon = ""rbxassetid://14041391134"",
	PremiumOnly = false
})

Tab:AddParagraph(""Thankyou for using my Hub! ""..Player.Name..""."")

Tab:AddButton({
	Name = ""Discord Invite"",
	Callback = function()
      		setclipboard(""https://discord.gg/r7s8Sg9Zqz"")
  	end    
})

local Section = Tab:AddSection({
	Name = ""BloxFruit""
})

Tab:AddButton({
	Name = ""Yujin"",
	Callback = function()
      		loadstring(game:HttpGet(""https://raw.githubusercontent.com/BestScriptEverr/Main-/main/Yujin""))()
  	end    
})

Tab:AddButton({
	Name = ""MeMayBeo"",
	Callback = function()
      		loadstring(game:HttpGet('https://raw.githubusercontent.com/ZPSXHUB/Hub/main/MeMayBeo-BloxFruit'))()
  	end    
})

Tab:AddButton({
	Name = ""ChestFarmOp"",
	Callback = function()
      		loadstring(game:HttpGet(""https://raw.githubusercontent.com/NickelHUBB/SonicTuru/main/ChestFarmOp""))()
  	end    
})

Tab:AddButton({
	Name = ""relzhub"",
	Callback = function()
      		loadstring(Game:HttpGet""https://relzhub.xcodehoster.com/loader.lua"")()
  	end    
})

Tab:AddButton({
	Name = ""QuyHub"",
	Callback = function()
      		loadstring(game:HttpGet(""https://raw.githubusercontent.com/tngaming123/YTB-TNGaming/main/QuyHub.lua""))()
  	end    
})

Tab:AddButton({
	Name = ""TAWAN_HUB"",
	Callback = function()
      		loadstring(game:HttpGet('https://raw.githubusercontent.com/kill55547/TAWAN_HUB/main/TAWANxHUB_V2.lua.txt', true))()
  	end    
})

Tab:AddButton({
	Name = ""TNGHub"",
	Callback = function()
      		loadstring(game:HttpGet(""https://raw.githubusercontent.com/tngaming123/TNGHub/main/AutoRaceV4.lua""))()
  	end    
})

Tab:AddButton({
	Name = ""NickelHUBB"",
	Callback = function()
      		loadstring(game:HttpGet(""https://raw.githubusercontent.com/NickelHUBB/SonicTuru/main/RaidGuiBloxFruitOP""))()
  	end    
})

Tab:AddButton({
	Name = ""PartLoader"",
	Callback = function()
      		loadstring(game:HttpGet(""https://raw.githubusercontent.com/Fiend1sh/FiendMain/main/PartLoader""))()
  	end    
})

Tab:AddButton({
	Name = ""ZenHub"",
	Callback = function()
      		loadstring(game:HttpGet(""https://raw.githubusercontent.com/Kaizenofficiall/ZenHub/main/Loader"", true))()
  	end    
})

Tab:AddButton({
	Name = ""Winnablez"",
	Callback = function()
      		loadstring(game:HttpGet(""https://raw.githubusercontent.com/Winnablez/Winnable/main/Loader""))()
  	end    
})

local Tab = Window:MakeTab({
	Name = ""Bed Wars"",
	Icon = ""rbxassetid://14041391134"",
	PremiumOnly = false
})

Tab:AddButton({
	Name = ""Inferno-X"",
	Callback = function()
      	loadstring(game:HttpGet(""https://raw.githubusercontent.com/OWJBWKQLAISH/Inferno-X/main/Inferno%20X%20Script""))()
  	end    
})

Tab:AddButton({
	Name = ""Vape V4"",
	Callback = function()
      	loadstring(game:HttpGet(""https://raw.githubusercontent.com/7GrandDadPGN/VapeV4ForRoblox/main/NewMainScript.lua"", true))()
  	end    
})

Tab:AddButton({
	Name = ""Ape"",
	Callback = function()
      	loadstring(game:HttpGet(""https://raw.githubusercontent.com/lightHubDev/Ape/main/ApeMain""))()
  	end    
})"
piA6YRU7,Clight_37_MergeCollection,TwinFrame,C#,Friday 14th of July 2023 04:44:39 AM CDT,"class Program
{
	static void Main()
	{
		int[] firstNumbers;
		int[] secondNumbers;
		int arrayLength = 5;
		int minNumber = 1;
		int maxNumber = 9;

		List<int> numbers = new List<int>();

		firstNumbers = GetRandomArray(arrayLength, minNumber, maxNumber);
		ShowNumbers(firstNumbers, ""Первый массив:"");

		secondNumbers = GetRandomArray(arrayLength, minNumber, maxNumber);
		ShowNumbers(secondNumbers, ""Второй массив:"");

		AddUniqueElements(numbers, firstNumbers);
		AddUniqueElements(numbers, secondNumbers);
		ShowNumbers(numbers, ""итоговая коллекция:"");
	}

	static void AddUniqueElements(List<int> numbers, int[] array)
	{
		foreach (int number in array)
		{
			if (numbers.Contains(number) == false)
			{
				numbers.Add(number);
			}
		}
	}

	static int[] GetRandomArray(int length, int minValue, int maxValue)
	{
		Random random = new Random();

		int[] array = new int[length];

		for (int i = 0; i < array.Length; i++)
		{
			array[i] = random.Next(minValue, maxValue + 1);
		}

		return array;
	}

	static void ShowNumbers(int[] array, string descriprion)
	{
		Console.WriteLine(descriprion);

		for (int i = 0; i < array.Length; i++)
		{
			Console.Write($""{array[i]} "");
		}

		Console.WriteLine();
	}

	static void ShowNumbers(List<int> numbers, string descriprion)
	{
		Console.WriteLine(descriprion);

		for (int i = 0; i < numbers.Count; i++)
		{
			Console.Write($""{numbers[i]} "");
		}
	}
}"
XgWyxmBV,Untitled,35657,C++,Friday 14th of July 2023 04:30:43 AM CDT,"
#include <string>
#include <iostream>

using namespace std;




// Рабочий
class Worker {
public:

    Worker() {
        cout << ""Конструктор рабочего"" << endl;
    }

    void SetSpeciality(string speciality) {
        speciality_ = speciality;
    }
    string GetSpeciality() const {
        return speciality_;
    }

private:
    string speciality_;
};


// Студент
class Student {
public:

    Student() {
        cout << ""Конструктор студента"" << endl;
    }

    void SetFaculty(string faculty) {
        faculty_ = faculty;
    }
    string GetFaculty() const {
        return faculty_;
    }

private:
    string faculty_;
};


// 
class ExternalStudent : public Worker, public Student  {

public:
    ExternalStudent() { // фактически компилятор допишет перед фигурными скобками Worker(), Builder()
        cout << ""Конструктор заочника"" << endl;
    }
};


int main() {
    setlocale(LC_ALL, ""ru"");

    ExternalStudent ex;

    ex.SetSpeciality(""Builder"");
    ex.SetFaculty(""Programming"");

    cout << ex.GetSpeciality() << "" "" << ex.GetFaculty() << endl;

}"
eC03NYGQ,program-p1-dyamicConnection,CR7CR7,C#,Friday 14th of July 2023 04:24:49 AM CDT,"using System;
using System.Reflection; // Импортираме пространството от имена за работа с рефлексия

namespace p1
{
    // Клас за представяне на програмата
    class Program
    {
        // Метод за стартиране на програмата
        static void Main(string[] args)
        {
            // Зареждаме динамичната библиотека d1.dll от текущата директория
            Assembly assembly = Assembly.LoadFile(Environment.CurrentDirectory + ""\\d1.dll"");

            // Тестваме функцията за сортиране на масив по метода на мехурчето
            TestBubbleSort(assembly);

            // Тестваме функцията за намиране на факториел от дадено число рекурсивно
            TestFactorial(assembly);

            // Тестваме функциите за работа със стек
            TestStack(assembly);

            // Тестваме функциите за работа с опашка
            TestQueue(assembly);

            // Тестваме функциите за работа със списък
            TestList(assembly);

            // Тестваме функциите за работа с дърво
            TestTree(assembly);

            // Тестваме функциите за работа с речник
            TestDictionary(assembly);
        }

        // Метод за тестване на функцията за сортиране на масив по метода на мехурчето
        static void TestBubbleSort(Assembly assembly)
        {
            Console.WriteLine(""Тестване на функцията за сортиране на масив по метода на мехурчето:"");

            int[] array = { 5, 3, 7, 1, 9, 4, 2, 6, 8 }; // Създаваме масив с произволни числа

            Console.WriteLine(""Масивът преди сортирането:"");
            PrintArray(array); // Извеждаме масивът преди сортирането

            // Намираме класа Algorithm в динамичната библиотека
            Type algorithmType = assembly.GetType(""d1.Algorithm"");

            // Намираме статичния метод BubbleSort в класа Algorithm
            MethodInfo bubbleSortMethod = algorithmType.GetMethod(""BubbleSort"");

            // Извикваме метода BubbleSort с параметър масивът, който искаме да сортираме
            bubbleSortMethod.Invoke(null, new object[] { array });

            Console.WriteLine(""Масивът след сортирането:"");
            PrintArray(array); // Извеждаме масивът след сортирането

            Console.WriteLine();
        }

        // Метод за извеждане на елементите на масив
        static void PrintArray(int[] array)
        {
            foreach (int element in array) // Обхождаме всички елементи на масива
            {
                Console.Write(element + "" ""); // Извеждаме текущия елемент, разделен с интервал
            }
            Console.WriteLine(); // Превъртаме нов ред
        }

        // Метод за тестване на функцията за намиране на факториел от дадено число рекурсивно
        static void TestFactorial(Assembly assembly)
        {
  Console.WriteLine(""Тестване на функцията за намиране на факториел от дадено число рекурсивно:"");

            int n = 5; // Задаваме произволно число

            Console.WriteLine(""Числото е: "" + n); // Извеждаме числото

            // Намираме класа Algorithm в динамичната библиотека
            Type algorithmType = assembly.GetType(""d1.Algorithm"");

            // Намираме статичния метод Factorial в класа Algorithm
            MethodInfo factorialMethod = algorithmType.GetMethod(""Factorial"");

            // Извикваме метода Factorial с параметър числото, от което искаме да намерим факториела
            int result = (int)factorialMethod.Invoke(null, new object[] { n });

            Console.WriteLine(""Факториелът от числото е: "" + result); // Извеждаме резултата

            Console.WriteLine();
        }
 // Метод за тестване на функциите за работа със стек
        static void TestStack(Assembly assembly)
        {
            Console.WriteLine(""Тестване на функциите за работа със стек:"");

            // Намираме класа Stack в динамичната библиотека
            Type stackType = assembly.GetType(""d1.Stack`1"");

            // Създаваме нов стек с капацитет 10 и тип int
            object stack = Activator.CreateInstance(stackType.MakeGenericType(typeof(int)), new object[] { 10 });

            // Намираме методите Push, Pop, Peek и IsEmpty в класа Stack
            MethodInfo pushMethod = stackType.GetMethod(""Push"");
            MethodInfo popMethod = stackType.GetMethod(""Pop"");
            MethodInfo peekMethod = stackType.GetMethod(""Peek"");
            MethodInfo isEmptyMethod = stackType.GetMethod(""IsEmpty"");

            Console.WriteLine(""Добавяме елементи в стека:"");
            for (int i = 1; i <= 5; i++) // Добавяме пет елемента в стека
            {
                Console.WriteLine(""Добавяме "" + i);
                pushMethod.Invoke(stack, new object[] { i }); // Извикваме метода Push с параметър i
            }

            Console.WriteLine(""Взимаме елемента на върха на стека без да го премахваме:"");
            Console.WriteLine(""Елементът е: "" + peekMethod.Invoke(stack, null)); // Извикваме метода Peek без параметри

            Console.WriteLine(""Премахваме елементи от стека:"");
            while (!(bool)isEmptyMethod.Invoke(stack, null)) // Докато стекът не е празен
            {
                Console.WriteLine(""Премахваме "" + popMethod.Invoke(stack, null)); // Извикваме метода Pop без параметри и извеждаме резултата
            }

            Console.WriteLine();
        }

        // Метод за тестване на функциите за работа с опашка
        static void TestQueue(Assembly assembly)
        {
            Console.WriteLine(""Тестване на функциите за работа с опашка:"");

            // Намираме класа Queue в динамичната библиотека
            Type queueType = assembly.GetType(""d1.Queue`1"");

            // Създаваме нова опашка с капацитет 10 и тип int
            object queue = Activator.CreateInstance(queueType.MakeGenericType(typeof(int)), new object[] { 10 });

            // Намираме методите Enqueue, Dequeue, Peek и IsEmpty в класа Queue
            MethodInfo enqueueMethod = queueType.GetMethod(""Enqueue"");
            MethodInfo dequeueMethod = queueType.GetMethod(""Dequeue"");
            MethodInfo peekMethod = queueType.GetMethod(""Peek"");
            MethodInfo isEmptyMethod = queueType.GetMethod(""IsEmpty"");

            Console.WriteLine(""Добавяме елементи в опашката:"");
            for (int i = 1; i <= 5; i++) // Добавяме пет елемента в опашката
            {
                Console.WriteLine(""Добавяме "" + i);
                enqueueMethod.Invoke(queue, new object[] { i }); // Извикваме метода Enqueue с параметър i
            }

            Console.WriteLine(""Взимаме елемента в началото на опашката без да го премахваме:"");
            Console.WriteLine(""Елементът е: "" + peekMethod.Invoke(queue, null)); // Извикваме метода Peek без параметри

            Console.WriteLine(""Премахваме елементи от опашката:"");
            while (!(bool)isEmptyMethod.Invoke(queue, null)) // Докато опашката не е празна
            {
                Console.WriteLine(""Премахваме "" + dequeueMethod.Invoke(queue, null)); // Извикваме метода Dequeue без параметри и извеждаме резултата
            }

            Console.WriteLine();
        }

        // Метод за тестване на функциите за работа със списък
        static void TestList(Assembly assembly)
        {
            Console.WriteLine(""Тестване на функциите за работа със списък:"");

            // Намираме класа List в динамичната библиотека
            Type listType = assembly.GetType(""d1.List`1"");

            // Създаваме нов списък с тип int
            object list = Activator.CreateInstance(listType.MakeGenericType(typeof(int)));

            // Намираме методите AddFirst, AddLast, RemoveFirst, RemoveLast, GetFirst, GetLast и IsEmpty в класа List
            MethodInfo addFirstMethod = listType.GetMethod(""AddFirst"");
            MethodInfo addLastMethod = listType.GetMethod(""AddLast"");
            MethodInfo removeFirstMethod = listType.GetMethod(""RemoveFirst"");
            MethodInfo removeLastMethod = listType.GetMethod(""RemoveLast"");
            MethodInfo getFirstMethod = listType.GetMethod(""GetFirst"");
            MethodInfo getLastMethod = listType.GetMethod(""GetLast"");
            MethodInfo isEmptyMethod = listType.GetMethod(""IsEmpty"");

            Console.WriteLine(""Добавяме елементи в началото и в края на списъка:"");
            for (int i = 1; i <= 5; i++) // Добавяме пет елемента в началото и в края на списъка
            {
                Console.WriteLine(""Добавяме "" + i + "" в началото"");
                addFirstMethod.Invoke(list, new object[] { i }); // Извикваме метода AddFirst с параметър i

                Console.WriteLine(""Добавяме "" + (i + 5) + "" в края"");
                addLastMethod.Invoke(list, new object[] { i + 5 }); // Извикваме метода AddLast с параметър i + 5
            }

            Console.WriteLine(""Взимаме елементите в началото и в края на списъка без да ги премахваме:"");
            Console.WriteLine(""Елементът в началото е: "" + getFirstMethod.Invoke(list, null)); // Извикваме метода GetFirst без параметри
            Console.WriteLine(""Елементът в края е: "" + getLastMethod.Invoke(list, null)); // Извикваме метода GetLast без параметри

            Console.WriteLine(""Премахваме елементи от началото и от края на списъка:"");
            while (!(bool)isEmptyMethod.Invoke(list, null)) // Докато списъкът не е празен
            {
                Console.WriteLine(""Премахваме "" + removeFirstMethod.Invoke(list, null) + "" от началото""); // Извикваме метода RemoveFirst без параметри и извеждаме резултата
                if (!(bool)isEmptyMethod.Invoke(list, null)) // Ако списъкът не е празен
                {
                    Console.WriteLine(""Премахваме "" + removeLastMethod.Invoke(list, null) + "" от края""); // Извикваме метода RemoveLast без параметри и извеждаме резултата
                }
            }

            Console.WriteLine();
        }

        // Метод за тестване на функциите за работа с дърво
        static void TestTree(Assembly assembly)
        {
 Console.WriteLine(""Тестване на функциите за работа с дърво:"");

            // Намираме класа Tree в динамичната библиотека
            Type treeType = assembly.GetType(""d1.Tree`1"");

            // Създаваме ново дърво с тип int
            object tree = Activator.CreateInstance(treeType.MakeGenericType(typeof(int)));

            // Намираме класа Node в динамичната библиотека
            Type nodeType = assembly.GetType(""d1.Node`1"");

            // Намираме методите AddRoot, AddChild, RemoveRoot, RemoveChild, GetRoot, GetChild и IsEmpty в класа Tree
            MethodInfo addRootMethod = treeType.GetMethod(""AddRoot"");
            MethodInfo addChildMethod = treeType.GetMethod(""AddChild"");
            MethodInfo removeRootMethod = treeType.GetMethod(""RemoveRoot"");
            MethodInfo removeChildMethod = treeType.GetMethod(""RemoveChild"");
            MethodInfo getRootMethod = treeType.GetMethod(""GetRoot"");
            MethodInfo getChildMethod = treeType.GetMethod(""GetChild"");
            MethodInfo isEmptyMethod = treeType.GetMethod(""IsEmpty"");

            // Намираме свойството Value в класа Node
            PropertyInfo valueProperty = nodeType.GetProperty(""Value"");

            Console.WriteLine(""Добавяме корен на дървото:"");
            Console.WriteLine(""Добавяме 1"");
            addRootMethod.Invoke(tree, new object[] { 1 }); // Добавяме корен със стойност 1

            Console.WriteLine(""Добавяме деца към корена на дървото:"");
            Console.WriteLine(""Добавяме 2"");
            addChildMethod.Invoke(tree, new object[] { getRootMethod.Invoke(tree, null), 2 }); // Добавяме дете със стойност 2 към корена

            Console.WriteLine(""Добавяме 3"");
            addChildMethod.Invoke(tree, new object[] { getRootMethod.Invoke(tree, null), 3 }); // Добавяме дете със стойност 3 към корена

            Console.WriteLine(""Добавяме 4"");
            addChildMethod.Invoke(tree, new object[] { getRootMethod.Invoke(tree, null), 4 }); // Добавяме дете със стойност 4 към корена

            Console.WriteLine(""Добавяме деца към първото дете на корена:"");
            Console.WriteLine(""Добавяме 5"");
            addChildMethod.Invoke(tree, new object[] { getChildMethod.Invoke(tree, new object[] { getRootMethod.Invoke(tree, null), 0 }), 5 }); // Добавяме дете със стойност 5 към първото дете на корена

            Console.WriteLine(""Добавяме 6"");
            addChildMethod.Invoke(tree, new object[] { getChildMethod.Invoke(tree, new object[] { getRootMethod.Invoke(tree, null), 0 }), 6 }); // Добавяме дете със стойност 6 към първото дете на корена

            Console.WriteLine(""Взимаме второто дете на първото дете на корена без да го премахваме:"");
            Console.WriteLine(""Елементът е: "" + valueProperty.GetValue(getChildMethod.Invoke(tree, new object[] { getChildMethod.Invoke(tree, new object[] { getRootMethod.Invoke(tree, null), 0 }), 1 }))); // Извикваме метода GetChild два пъти и извеждаме стойността на елемента

            Console.WriteLine(""Премахваме второто дете на първото дете на корена:"");
            Console.WriteLine(""Премахваме "" + removeChildMethod.Invoke(tree, new object[] { getChildMethod.Invoke(tree, new object[] { getRootMethod.Invoke(tree, null), 0 }), 1 })); // Извикваме метода RemoveChild и извеждаме резултата

            Console.WriteLine(""Премахваме корена на дървото:"");
            Console.WriteLine(""Премахваме "" + removeRootMethod.Invoke(tree, null)); // Извикваме метода RemoveRoot и извеждаме резултата

            Console.WriteLine();
        }
    }
}
"
cZuaiKfs,Untitled,onilink_,C++,Friday 14th of July 2023 04:24:21 AM CDT,"    std::vector<uint8_t> buffer(wid * hei * 4);
    for(unsigned y=0; y<hei; ++y) {
        char* imptr = reinterpret_cast<char*>(&buffer[y * 4 * wid]);
        file.read(imptr, wid*4);
    }"
RYNexJ8v,Quiz,AhmadXploit,Dart,Friday 14th of July 2023 04:22:33 AM CDT,"{
  ""questions"": [
    {
      ""question"": ""Which programming language is used for building Flutter apps?"",
      ""options"": [
        ""A) Dart"",
        ""B) Java"",
        ""C) Swift"",
        ""D) Python""
      ],
      ""correctAnswer"": 0
    },
    {
      ""question"": ""What does the hot reload feature in Flutter do?"",
      ""options"": [
        ""A) Allows instant code changes without restarting the app"",
        ""B) Optimizes app performance"",
        ""C) Generates automatic backups"",
        ""D) Updates app dependencies""
      ],
      ""correctAnswer"": 0
    },
	{
      ""question"": ""What name of developer ?"",
      ""options"": [
        ""A) Rayyan"",
        ""B) Lol"",
        ""C) Gs"",
        ""D) chou""
      ],
      ""correctAnswer"": 0
    },
    {
      ""question"": ""What is a widget in Flutter?"",
      ""options"": [
        ""A) A building block for UI elements"",
        ""B) A programming language"",
        ""C) A database"",
        ""D) A server""
      ],
      ""correctAnswer"": 0
    }
  ]
}"
mrnY4Cwz,testovaPrograma-t1,CR7CR7,C#,Friday 14th of July 2023 04:03:28 AM CDT,"using System;
using d1; // Импортираме пространството от имена на динамичната библиотека

namespace t1
{
    // Клас за представяне на тестовата програма
    class Program
    {
        // Метод за стартиране на програмата
        static void Main(string[] args)
        {
            // Тестваме функцията за сортиране на масив по метода на мехурчето
            TestBubbleSort();

            // Тестваме функцията за намиране на факториел от дадено число рекурсивно
            TestFactorial();

            // Тестваме функциите за работа със стек
            TestStack();

            // Тестваме функциите за работа с опашка
            TestQueue();

            // Тестваме функциите за работа със списък
            TestList();

            // Тестваме функциите за работа с дърво
            TestTree();

            // Тестваме функциите за работа с речник
            TestDictionary();
        }

        // Метод за тестване на функцията за сортиране на масив по метода на мехурчето
        static void TestBubbleSort()
        {
            Console.WriteLine(""Тестване на функцията за сортиране на масив по метода на мехурчето:"");

            int[] array = { 5, 3, 7, 1, 9, 4, 2, 6, 8 }; // Създаваме масив с произволни числа

            Console.WriteLine(""Масивът преди сортирането:"");
            PrintArray(array); // Извеждаме масивът преди сортирането

            Algorithm.BubbleSort(array); // Сортираме масивът по метода на мехурчето

            Console.WriteLine(""Масивът след сортирането:"");
            PrintArray(array); // Извеждаме масивът след сортирането

            Console.WriteLine();
        }

        // Метод за извеждане на елементите на масив
        static void PrintArray(int[] array)
        {
            foreach (int element in array) // Обхождаме всички елементи на масива
            {
                Console.Write(element + "" ""); // Извеждаме текущия елемент, разделен с интервал
            }
            Console.WriteLine(); // Превъртаме нов ред
        }

        // Метод за тестване на функцията за намиране на факториел от дадено число рекурсивно
        static void TestFactorial()
        {
            Console.WriteLine(""Тестване на функцията за намиране на факториел от дадено число рекурсивно:"");

            int n = 5; // Задаваме произволно число

            Console.WriteLine(""Числото е: "" + n); // Извеждаме числото

            int result = Algorithm.Factorial(n); // Намираме факториела от числото

            Console.WriteLine(""Факториелът от числото е: "" + result); // Извеждаме резултата

            Console.WriteLine();
        }

        // Метод за тестване на функциите за работа със стек
        static void TestStack()
        {
            Console.WriteLine(""Тестване на функциите за работа със стек:"");

            Stack<int> stack = new Stack<int>(10); // Създаваме нов стек с капацитет 10

            Console.WriteLine(""Добавяме елементи в стека:"");
            for (int i = 1; i <= 5; i++) // Добавяме пет елемента в стека
            {
                Console.WriteLine(""Добавяме "" + i);
                stack.Push(i);
            }

            Console.WriteLine(""Взимаме елемента на върха на стека без да го премахваме:"");
            Console.WriteLine(""Елементът е: "" + stack.Peek());

            Console.WriteLine(""Премахваме елементи от стека:"");
            while (!stack.IsEmpty()) // Докато стекът не е празен
            {
                Console.WriteLine(""Премахваме "" + stack.Pop()); // Премахваме елемент от стека и го извеждаме
            }

            Console.WriteLine();
        }

        // Метод за тестване на функциите за работа с опашка
        static void TestQueue()
        {
            Console.WriteLine(""Тестване на функциите за работа с опашка:"");

            Queue<int> queue = new Queue<int>(10); // Създаваме нова опашка с капацитет 10

            Console.WriteLine(""Добавяме елементи в опашката:"");
            for (int i = 1; i <= 5; i++) // Добавяме пет елемента в опашката
            {
                Console.WriteLine(""Добавяме "" + i);
                queue.Enqueue(i);
            }

            Console.WriteLine(""Взимаме елемента в началото на опашката без да го премахваме:"");
            Console.WriteLine(""Елементът е: "" + queue.Peek());

            Console.WriteLine(""Премахваме елементи от опашката:"");
            while (!queue.IsEmpty()) // Докато опашката не е празна
            {
                Console.WriteLine(""Премахваме "" + queue.Dequeue()); // Премахваме елемент от опашката и го извеждаме
            }

            Console.WriteLine();
        }

        // Метод за тестване на функциите за работа със списък
        static void TestList()
        {
            Console.WriteLine(""Тестване на функциите за работа със списък:"");

            List<int> list = new List<int>(); // Създаваме нов списък

            Console.WriteLine(""Добавяме елементи в началото и в края на списъка:"");
            for (int i = 1; i <= 5; i++) // Добавяме пет елемента в началото и в края на списъка
            {
                Console.WriteLine(""Добавяме "" + i + "" в началото"");
                list.AddFirst(i);

                Console.WriteLine(""Добавяме "" + (i + 5) + "" в края"");
                list.AddLast(i + 5);
            }

            Console.WriteLine(""Взимаме елементите в началото и в края на списъка без да ги премахваме:"");
            Console.WriteLine(""Елементът в началото е: "" + list.GetFirst());
            Console.WriteLine(""Елементът в края е: "" + list.GetLast());

            Console.WriteLine(""Премахваме елементи от началото и от края на списъка:"");
            while (!list.IsEmpty()) // Докато списъкът не е празен
            {
                Console.WriteLine(""Премахваме "" + list.RemoveFirst() + "" от началото""); // Премахваме елемент от началото и го извеждаме
                if (!list.IsEmpty()) // Ако списъкът не е празен
                {
                    Console.WriteLine(""Премахваме "" + list.RemoveLast() + "" от края""); // Премахваме елемент от края и го извеждаме
                }
            }

            Console.WriteLine();
        }

        // Метод за тестване на функциите за работа с дърво
        static void TestTree()
        {
            Console.WriteLine(""Тестване на функциите за работа с дърво:"");

            Tree<int> tree
// Създаваме ново дърво
            Tree<int> tree = new Tree<int>();

            Console.WriteLine(""Добавяме корен на дървото:"");
            Console.WriteLine(""Добавяме 1"");
            tree.AddRoot(1); // Добавяме корен със стойност 1

            Console.WriteLine(""Добавяме деца към корена на дървото:"");
            Console.WriteLine(""Добавяме 2"");
            tree.AddChild(tree.GetRoot(), 2); // Добавяме дете със стойност 2 към корена

            Console.WriteLine(""Добавяме 3"");
            tree.AddChild(tree.GetRoot(), 3); // Добавяме дете със стойност 3 към корена

            Console.WriteLine(""Добавяме 4"");
            tree.AddChild(tree.GetRoot(), 4); // Добавяме дете със стойност 4 към корена

            Console.WriteLine(""Добавяме деца към първото дете на корена:"");
            Console.WriteLine(""Добавяме 5"");
            tree.AddChild(tree.GetChild(tree.GetRoot(), 0), 5); // Добавяме дете със стойност 5 към първото дете на корена

            Console.WriteLine(""Добавяме 6"");
            tree.AddChild(tree.GetChild(tree.GetRoot(), 0), 6); // Добавяме дете със стойност 6 към първото дете на корена

            Console.WriteLine(""Взимаме второто дете на първото дете на корена без да го премахваме:"");
            Console.WriteLine(""Елементът е: "" + tree.GetChild(tree.GetChild(tree.GetRoot(), 0), 1).Value);

            Console.WriteLine(""Премахваме второто дете на първото дете на корена:"");
            Console.WriteLine(""Премахваме "" + tree.RemoveChild(tree.GetChild(tree.GetRoot(), 0), 1));

            Console.WriteLine(""Премахваме корена на дървото:"");
            Console.WriteLine(""Премахваме "" + tree.RemoveRoot());

            Console.WriteLine();
        }

        // Метод за тестване на функциите за работа с речник
        static void TestDictionary()
        {
            Console.WriteLine(""Тестване на функциите за работа с речник:"");

            Dictionary<string, int> dictionary = new Dictionary<string, int>(10); // Създаваме нов речник с капацитет 10

            Console.WriteLine(""Добавяме двойки ключ-стойност в речника:"");
            dictionary.Add(""one"", 1); // Добавяме двойка с ключ ""one"" и стойност 1
            dictionary.Add(""two"", 2); // Добавяме двойка с ключ ""two"" и стойност 2
            dictionary.Add(""three"", 3); // Добавяме двойка с ключ ""three"" и стойност 3
            dictionary.Add(""four"", 4); // Добавяме двойка с ключ ""four"" и стойност 4
            dictionary.Add(""five"", 5); // Добавяме двойка с ключ ""five"" и стойност 5

            Console.WriteLine(""Взимаме стойностите по зададени ключове от речника без да ги премахваме:"");
            Console.WriteLine(""Стойността за ключа \""one\"" е: "" + dictionary.Get(""one""));
            Console.WriteLine(""Стойността за ключа \""three\"" е: "" + dictionary.Get(""three""));
            Console.WriteLine(""Стойността за ключа \""five\"" е: "" + dictionary.Get(""five""));

            Console.WriteLine(""Премахваме двойки ключ-стойност от речника по зададени ключове:"");
            Console.WriteLine(""Премахваме двойката с ключ \""two\"" и стойност "" + dictionary.Remove(""two""));
            Console.WriteLine(""Премахваме двойката с ключ \""four\"" и стойност "" + dictionary.Remove(""four""));

            Console.WriteLine();
        }
    }
}


"
4WMDF2bZ,combine audio and audioCOM,Kitomas,Batch,Friday 14th of July 2023 03:48:43 AM CDT,"@echo off
rem (this is to be run solely via a codeblocks post-build step)
echo --combining kit_w32_audio .a(s)--
cd kit_w32

mkdir tmp
cp lib_kit_w32_audioCOM.a tmp
cp libkit_w32_audio.a tmp
cd tmp

ar -x lib_kit_w32_audioCOM.a
ar -x libkit_w32_audio.a
del *.a

ar -rv libkit_w32_audio.a *.o
cp libkit_w32_audio.a ..
del /q *.*
cd ..

rmdir tmp
echo --final size of ""libkit_w32_audio.a""--
dir libkit_w32_audio.a
@echo on"
PnXX9kWf,Convert all html pages into PDF,nicuf,Python,Friday 14th of July 2023 03:47:55 AM CDT,"import os
import pdfkit

# Calea către directorul cu fișierele HTML
dir_path = 'j:/DE SCANAT/GATA - doar de scanat in txt/1/Forascu, Narcisa/Dificultati Gramaticale Ale Limbii Romane'

# Numele fișierului PDF de ieșire
output_pdf = 'output.pdf'

# Găsește toate fișierele HTML din director
html_files = [os.path.join(dir_path, f) for f in os.listdir(dir_path) if f.endswith(('.htm', '.html'))]

# Calea către executabilul .EXE wkhtmltopdf  INSTALL HERE:  https://wkhtmltopdf.org/downloads.html
wkhtmltopdf_path = '/calea/catre/wkhtmltopdf'

# Creează o configurație cu calea către wkhtmltopdf
config = pdfkit.configuration(wkhtmltopdf=wkhtmltopdf_path)

# Converteste fiecare fișier HTML în PDF și le unește
pdfkit.from_file(html_files, output_pdf, configuration=config)
"
DwrL3ykB,kit_w32_audio.h (scrapped),Kitomas,C,Friday 14th of July 2023 03:45:51 AM CDT,"//compile with kernel32, and ole32
/**
 * \file kit_w32_audio.h
 * \brief Header file for KIT Win32's audio module
 */
#ifndef _KIT_W32_AUDIO_H
#define _KIT_W32_AUDIO_H
#  ifndef _KIT_AUDIO
#  define _KIT_AUDIO



#include <wchar.h> //might be redundant, but this for sure includes wchar_t
#include <stdint.h>
#include <string.h> //used for memcpy

#include <synchapi.h> //used for CRITICAL_SECTION
#include <processthreadsapi.h> //used to create and manage threads
#include <combaseapi.h>
#  define _kit_audioMalloc(_type,_len) CoTaskMemAlloc(sizeof(_type)*(_len))
#  define _kit_audioFree(_ptr) CoTaskMemFree(_ptr)
#  define _kit_audioRealloc(_ptr,_type,_len) CoTaskMemRealloc(_ptr,sizeof(_type)*(_len))
#ifndef COM_NO_WINDOWS_H
# define COM_NO_WINDOWS_H
#  include <windef.h> //includes winnt.h
#  include <initguid.h>
#  include <audioclient.h>
#  include <mmdeviceapi.h>
# undef COM_NO_WINDOWS_H
#else
#  include <windef.h>
#  include <initguid.h>
#  include <audioclient.h>
#  include <mmdeviceapi.h>
#endif
#include <dsound.h>



/* GENERAL */

/**
 * \name Audio Format Constants
 */
/** @{ */
#define KIT_AUDIO_FMT_I8  (0x8007) ///< \brief   signed  8-bit samples
#define KIT_AUDIO_FMT_U8  (0x0007) ///< \brief unsigned  8-bit samples

#define KIT_AUDIO_FMT_I16LSB (0x800F) ///< \brief   signed 16-bit samples (little endian)
#define KIT_AUDIO_FMT_U16LSB (0x000F) ///< \brief unsigned 16-bit samples (little endian)
#define KIT_AUDIO_FMT_I24LSB (0x8017) ///< \brief   signed 24-bit samples (little endian)
#define KIT_AUDIO_FMT_U24LSB (0x0017) ///< \brief unsigned 24-bit samples (little endian)
#define KIT_AUDIO_FMT_I32LSB (0x801F) ///< \brief   signed 32-bit samples (little endian)
#define KIT_AUDIO_FMT_U32LSB (0x001F) ///< \brief unsigned 32-bit samples (little endian)
#define KIT_AUDIO_FMT_F32LSB (0x811F) ///< \brief 32-bit float samples (little endian)
#define KIT_AUDIO_FMT_F64LSB (0x813F) ///< \brief 64-bit float samples (little endian)
//x86 is little endian
//#define KIT_AUDIO_FMT_I16MSB (0x900F) ///< \brief   signed 16-bit samples (big endian)
//#define KIT_AUDIO_FMT_U16MSB (0x100F) ///< \brief unsigned 16-bit samples (big endian)
//#define KIT_AUDIO_FMT_I24MSB (0x9017) ///< \brief   signed 24-bit samples (big endian)
//#define KIT_AUDIO_FMT_U24MSB (0x1017) ///< \brief unsigned 24-bit samples (big endian)
//#define KIT_AUDIO_FMT_I32MSB (0x901F) ///< \brief   signed 32-bit samples (big endian)
//#define KIT_AUDIO_FMT_U32MSB (0x101F) ///< \brief unsigned 32-bit samples (big endian)
//#define KIT_AUDIO_FMT_F32MSB (0x911F) ///< \brief 32-bit float samples (big endian)
//#define KIT_AUDIO_FMT_F64MSB (0x913F) ///< \brief 64-bit float samples (big endian)

#define KIT_AUDIO_FMT_I16 KIT_AUDIO_FMT_I16LSB
#define KIT_AUDIO_FMT_U16 KIT_AUDIO_FMT_U16LSB
#define KIT_AUDIO_FMT_I24 KIT_AUDIO_FMT_I24LSB
#define KIT_AUDIO_FMT_U24 KIT_AUDIO_FMT_U24LSB
#define KIT_AUDIO_FMT_I32 KIT_AUDIO_FMT_I32LSB
#define KIT_AUDIO_FMT_U32 KIT_AUDIO_FMT_U32LSB
#define KIT_AUDIO_FMT_F32 KIT_AUDIO_FMT_F32LSB
#define KIT_AUDIO_FMT_F64 KIT_AUDIO_FMT_F64LSB
#define KIT_AUDIO_FMT_INVALID (0x7FFF)
/** @} */


/**
 * \name Audio Format Bitmasks & Macros
 */
/** @{ */ /* (the ""M"" in FMT_M means (bit)mask) */
#define KIT_AUDIO_FMT_MBITSIZE (0x00FF) ///< \brief format bitsize mask
#define KIT_AUDIO_FMT_MFLOAT   (0x0100) ///< \brief format float mask
#define KIT_AUDIO_FMT_MENDIAN  (0X1000) ///< \brief format endianness mask
#define KIT_AUDIO_FMT_MSIGNED  (0x8000) ///< \brief format signedness mask
#define KIT_AUDIO_FMT_BITSIZE(x)        ((x) & KIT_AUDIO_FMT_MBITSIZE)
#define KIT_AUDIO_FMT_ISFLOAT(x)        ((x) & KIT_AUDIO_FMT_MFLOAT)
#define KIT_AUDIO_FMT_ISBIGENDIAN(x)    ((x) & KIT_AUDIO_FMT_MENDIAN)
#define KIT_AUDIO_FMT_ISSIGNED(x)       ((x) & KIT_AUDIO_FMT_MSIGNED)
#define KIT_AUDIO_FMT_ISINT(x)          (!KIT_AUDIO_FMT_ISFLOAT(x))
#define KIT_AUDIO_FMT_ISLITTLEENDIAN(x) (!KIT_AUDIO_FMT_ISBIGENDIAN(x))
#define KIT_AUDIO_FMT_ISUNSIGNED(x)     (!KIT_AUDIO_FMT_ISSIGNED(x))
/** @} */


/**
 * \name Audio Device Type Constants
 */
/** @{ */
#define _KIT_AUDIO_DEVTYPE_BASE                               0
#define  KIT_AUDIO_DEVTYPE_WASAPIIN  (_KIT_AUDIO_DEVTYPE_BASE+1)
#define  KIT_AUDIO_DEVTYPE_WASAPIOUT (_KIT_AUDIO_DEVTYPE_BASE+2)
/** @} */


/**
 * \name Audio Device Type Macros
 */
/** @{ */
#define KIT_AUDIO_IFNOTDEVICE(_device)\
  if(_device               == NULL                  || \
     _device->_magic.num   != 0x007665446F69647561     \
  )
#define KIT_AUDIO_IFDEVICEINVALID(_device,_type)\
  if(_device               == NULL                  || \
     _device->_magic.num   != 0x007665446F69647561  || \
     _device->_device_type != _type                    \
  )
#define KIT_AUDIO_AUDITANDLOCK(_device,_type,_errorvalue)\
  if(!kit_audioLockDevice(_device)  || \
     _device->device_type != _type    \
  ) return _errorvalue;
#define KIT_AUDIO_LOCK(_device) \
  EnterCriticalSection(&_device->_mutex);
//assumes audit already happened
#define KIT_AUDIO_UNLOCK(_device) \
  LeaveCriticalSection(&_device->_mutex);
/** @} */


/**
 * Audio Format (FMT)
 * \verbatim
   Bit Layout is as follows:

   +----------------------sample is signed if set
   |
   |        +----------sample is bigendian if set
   |        |
   |        |           +--sample is float if set
   |        |           |
   |        |           |  +-sample bit size (-1)+
   |        |           |  |                     |
   15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
   \endverbatim
 */
typedef uint16_t kit_audioFormat;


/**
 * PCM Audio Callback
 * This type of function is called when an opened (and unpaused)
 * audio device's audio buffer needs more PCM data.
 * The given audio buffer must be completely filled before returning
 * \param userdata A user-defined pointer passed to the callback, which
 *                 is stored in the same kit_audioSpec as the callback itself
 * \param stream   A pointer to the audio data buffer
 * \param len      The length of that buffer in samples (number of sample frames is len/<# of channels>)
 */
typedef void (*kit_audioCallback) (void* userdata,  void* stream, unsigned int len);


/**
 * \brief This enum is used to indicate the play status of an audio device
 */
typedef enum {
  ADPStateInvalid = 0,
  ADPStateStopped = 1,
  ADPStatePlaying = 2,
  ADPStatePaused  = 3
} kit_audioDevicePState;


/**
 * \brief This enum is used to indicate an audio device's state
 */
typedef enum { //there might be a better way to name these...
  ADStatusInvalid    = (0),
  ADStatusActive     = (DEVICE_STATE_ACTIVE),
  ADStatusDisabled   = (DEVICE_STATE_DISABLED),
  ADStatusNotPresent = (DEVICE_STATE_NOTPRESENT),
  ADStatusUnplugged  = (DEVICE_STATE_UNPLUGGED),
  ADStatusAll        = (DEVICE_STATE_ACTIVE|DEVICE_STATE_DISABLED|DEVICE_STATE_NOTPRESENT|DEVICE_STATE_UNPLUGGED)
} kit_audioDeviceStatus;


/* *
 * \brief This struct contains info about audio format conversion
 * /
typedef struct {
} kit_audioCVT; */


/**
 * \brief This is the struct for an audio specification (something like a config but for a kit_audioDevice)
 * \verbatim
   For multi-channel audio, the current channel mapping is:
   2:  FL  FR                          (stereo)
   3:  FL  FR LFE                      (2.1 surround)
   4:  FL  FR  BL  BR                  (quad)
   5:  FL  FR LFE  BL  BR              (4.1 surround)
   6:  FL  FR  FC LFE  BL  BR          (5.1 surround)
   7:  FL  FR  FC LFE  BC  SL  SR      (6.1 surround)
   8:  FL  FR  FC LFE  BL  BR  SL  SR  (7.1 surround)
   \endverbatim
 */
typedef struct {
  kit_audioCallback    callback; ///< \brief Called when the audio buffer needs to be refilled
  void*                userdata; ///< \brief User-defined pointer passed to callback
  uint32_t            frequency; ///< \brief Sample rate of audio in Hz
  uint32_t          buffer_size; ///< \brief Audio buffer length in bytes (automatically calculated)
  uint32_t           buffer_len; ///< \brief Audio buffer length in samples (must a be power of 2)
  uint16_t             channels; ///< \brief Number of audio channels (1=mono, 2=stereo, etc.)
  kit_audioFormat        format; ///< \brief Audio data format information
} kit_audioSpec;


/**
 * \brief This is the struct used for both WASAPI in/out devices. \n
 * Something of note is that most members of this struct have the ""_"" prefix,
 * which states that they are private and most likely should not be interacted
 * with or modified unless through kit_audio's interface.
 *
 * (While this struct uses an ID in the form of _magic, this type of ID
 * is not present in every kind of 'kit_moduleName' struct.)
 */
typedef struct {
  union {
    char                str[8]; ///< \brief String portion of ID (""audioDev\x00"")
    uint64_t               num; ///< \brief Number portion of ID (0x007665446F69647561)
  } /* --------------- */ _magic; ///< \brief Struct ID number; union of uint64_t and char[8]
  CRITICAL_SECTION        _mutex; ///< \brief Used to stop callback from triggering if kit_audioLockDevice is called
  //CRITICAL_SECTION _callback_mutex; ///< \brief Used to lock access to _callback_thread specifically
  kit_audioSpec              src; ///< \brief Audio format of input stream buffer
  //kit_audioCVT               cvt; ///< \brief Contains format conversion info
  kit_audioSpec              cvt; ///< \brief Audio format of ConVerTed (output) stream
  HANDLE                  _event; ///< \brief Event handle used in callback handling
  union {
    HANDLE             _handle; ///< \brief Pointer handle of the device
    IAudioClient*      _client;
  };
  //HANDLE        _callback_thread; ///< \brief System callback thread, which kit_audioDeviceReset locks until completion for
  void*                  _stream; ///< \brief Points to the input stream data that is passed to _src.callback
  void*               _buffer[2]; ///< \brief Output streams (while 0 is playing, 1 is being filled, and vice versa)
  float*                  volume; ///< \brief Volume multiplier for each audio channel (0.0 -> 1.0)
  kit_audioDevicePState _playing; ///< \brief play state of device (stopped, playing, paused)
  kit_audioDeviceStatus  _status; ///< \brief current device status (active, disabled, etc.)
  uint32_t      callback_timeout; ///< \brief Timeout for callback thread, in milliseconds (default of 10000)
  uint8_t            _cvt_needed; ///< \brief A boolean of 'is format conversion needed?'
  uint8_t            device_type; ///< \brief 1, 2  =  WASAPI capture, WASAPI render
  uint8_t                 _which; ///< \brief Which output stream to fill with more audio data
  uint8_t          _apply_volume; ///< \brief A boolean of whether to apply volume settings
} kit_audioDevice;



/* INLINES */

/**
 * \brief Lock the audio callback of a given device from being called
 *        (useful for manipulating the device struct)
 *
 * \param device A pointer to the device
 * \return A boolean of if the given pointer is an actual audio device
 *
 * \remark This activates a CRITICAL_SECTION mutex, so unlock as soon as possible
 */
static inline int kit_audioLockDevice(kit_audioDevice* device){
  KIT_AUDIO_IFNOTDEVICE(device) return 0;
  else { EnterCriticalSection(&device->_mutex); return 1; }
}


/**
 * \brief Unlock the audio callback of a given device
 *
 * \param device A pointer to the device
 * \return A boolean of if the given pointer is an actual audio device
 */
static inline int kit_audioUnlockDevice(kit_audioDevice* device){
  KIT_AUDIO_IFNOTDEVICE(device) return 0;
  else { LeaveCriticalSection(&device->_mutex); return 1; }
}


/* *
 * \brief Get the current playing state of a given device
 *
 * \param device A pointer to the device
 * \return A boolean value of whether the device is currently unpaused or not
 * /
static inline int kit_audioIsPlaying(kit_audioDevice* device){
  if(!kit_audioLockDevice(device)) return 0;
  int isPlaying=device->_playing;
  KIT_AUDIO_UNLOCK(device);
  return isPlaying;
}*/


/**
 * \brief Set a device channel's volume multiplier (values should be 0.0 -> 1.0)
 *
 * \param device A pointer to the device
 * \param volume New volume multiplier for selected channel
 * \param channel Channel to assign new multiplier to
 */
static inline void kit_audioSetVolume(kit_audioDevice* device, float volume,uint32_t channel){
  if(!kit_audioLockDevice(device)) return;
  if(channel>=device->cvt.channels) return;
  device->volume[channel]=volume;
  KIT_AUDIO_UNLOCK(device);
}


/**
 * \brief Set Stereo volume multiplier for device (values should be 0.0 -> 1.0)
 *
 * \param device A pointer to the device
 * \param volL New volume multiplier for left channel (or just channel 0 if channels is equal to 1)
 * \param volR New volume multiplier for right channel (ignored if channels is <2)
 */
static inline void kit_audioSetVolumeLR(kit_audioDevice* device, float volL,float volR){
  if(!kit_audioLockDevice(device)) return;
  device->volume[0]=volL;
  if(device->cvt.channels>1) device->volume[1]=volR;
  KIT_AUDIO_UNLOCK(device);
}



/* COM-RELATED FUNCTIONS */

//extern kit_audioSpec _kit_audioWaveFormatToSpec(void* format);


//extern WAVEFORMATEXTENSIBLE _kit_audioSpecToWaveFormat(kit_audioSpec* spec, int* returnStatus_p);


//extern int _kit_audioQueryDevice(unsigned int index, int isCapture); //assumes globals are already locked


//extern int _kit_audioQueryDeviceProps(unsigned int index, int isCapture); //assumes globals are already locked


/**
 * \brief Query and update render/capture audio device list, given a device status
 *
 * \param isCapture A boolean of whether to update the render or capture device list
 * \param status A kit_audioDeviceStatus enum value used to filter
 *        which devices are included in the new list
 * \return A return status code
 * \verbatim Possible return status codes:

   \endverbatim
 */
extern int kit_audioQueryDevices(int isCapture, kit_audioDeviceStatus status);


/**
 * \brief Get number of devices in current device list
 *
 * \param isCapture A boolean of whether to reference the render or capture device list
 * \return The current number of audio endpoint devices
 *
 * \remark This device list can be updated with a call to kit_audioQueryDevices
 * \sa kit_audioQueryDevices
 */
extern unsigned int kit_audioGetNumDevices(int isCapture);


/**
 * \brief Get the 'friendly name' of a given audio device
 *
 * \param index The index of an audio device in the current device list
 * \param isCapture A boolean of whether to reference the render or capture audio device list
 * \param mode Which name property to pull from; 0 -> 2
 *        (PKEY_Device_FriendlyName, PKEY_Device_DeviceDesc, PKEY_DeviceInterface_FriendlyName)
 * \param returnStatus_p A pointer to an int to be filled with the return status code (can be NULL)
 * \verbatim Possible return status codes:

   \endverbatim
 * \return A wide string pointer to the device name, or NULL on error
 *
 * \remark Do not attempt to free the returned pointer yourself. This string is managed internally
 */
extern wchar_t* kit_audioGetDeviceName(unsigned int index, int isCapture,
                                       int mode, int* returnStatus_p);


/**
 * \brief Get the device ID of a given device, as a wide string
 *
 * \param index The index of an audio device in the current device list
 * \param isCapture A boolean of whether to reference the render or capture audio device list
 * \param returnStatus_p A pointer to an int to be filled with the return status code (can be NULL)
 * \verbatim Possible return status codes

   \endverbatim
 * \return A wide string pointer to the device ID, or NULL on error
 *
 * \remark Do not attempt to free the returned pointer yourself. This string is managed internally
 */
extern wchar_t* kit_audioGetDeviceID(unsigned int index, int isCapture, int* returnStatus_p);


/**
 * \brief Get current connection status of an audio device
 *
 * \param index The index of an audio device in the current device list
 * \param isCapture A boolean of whether to reference the render or capture audio device list
 * \return A kit_audioDeviceStatus enum value (ADStateInvalid if index is out of range)
 */
extern kit_audioDeviceStatus kit_audioGetDeviceStatus(unsigned int index, int isCapture, int* returnStatus_p);


/**
 * \brief Get the audio format specification of a given audio device
 *
 * \param index The index of an audio device in the current device list
 * \param isCapture A boolean of whether to reference the render or capture audio device list
 * \param spec A pointer to a kit_audioSpec struct to be filled in with the device's specification
 * \return A return status code
 * \verbatim Possible return status codes:

   \endverbatim
 */
extern int kit_audioGetDeviceSpec(unsigned int index, int isCapture, kit_audioSpec* spec);


extern int kit_audioIsSpecSupported(unsigned int index, int isCapture,
                                    kit_audioSpec* spec, kit_audioSpec* closestMatch);


extern unsigned int kit_audioGetDeviceIndexFromID(wchar_t* deviceID, int isCapture, int* returnStatus_p);



/* kit_audioDevice-RELATED FUNCTIONS */

//TBD
extern int kit_audioDevicePlay(kit_audioDevice* device, kit_audioDevicePState playState);


/**
 * \brief Get the current play state of a given device
 *
 * \param device A pointer to the device
 * \return A kit_audioDevicePState enum value of the device's play state
 */
extern kit_audioDevicePState kit_audioGetDevicePlayState(kit_audioDevice* device);



/* (UN)INIT FUNCTIONS */

/**
 * \brief Initialize kit_w32_audio, while optionally initializing COM, too. \n
 * This function should ideally be called only once, and in the process's main thread. \n
 * (Bad things will happen if kit_audio functions are called before initializing.)
 *
 * \param initCOM A boolean of whether to initialize COM within the function
 * \return A return status code
 * \verbatim Possible return status codes:
   0: Success; no error
   1: Init has already been called (this check is prone to race conditions, and is therefore unreliable)
   2: Failed to create device enumerator object
   3: Failed to enumerate input (capture) audio endpoints
   4: Failed to enumerate output (render) audio endpoints
   \endverbatim
 *
 * \remark If initCOM=0, ""CoInitialize(NULL,COINIT_MULTITHREADED)""
 *         must be called prior to calling kit_audioInit.
 * \sa kit_audioQuit
 */
extern int kit_audioInit(int initCOM);


/**
 * \brief Uninitialize kit_w32_audio, freeing and releasing remaining interfaces in the process. \n
 * It is recommended to call kit_audioQuit only once, and in the same thread as the prior call to kit_audioInit.
 *
 * \param uninitCOM A boolean of whether to uninitialize COM after freeing/releasing everything
 * \return 0 on success, and 1 if kit_w32_audio is already uninitialized
 *
 * \remark Due to chronic and unexplainable problems with CoUninitialize, setting uninitCOM to 0 is recommended
 * \sa kit_audioInit
 */
extern int kit_audioQuit(int uninitCOM);


//TBD
extern kit_audioDevice* kit_audioDeviceOpen(kit_audioSpec* spec, unsigned int index,
                                            int isCapture, int* returnStatus_p);


//TBD
extern int kit_audioDeviceClose(kit_audioDevice** device_p);



#  endif //_KIT_AUDIO
#endif //_KIT_W32_AUDIO_H

//move this back to kit_w32_audio.c once i'm done testing with it
typedef struct {
  union {
    WAVEFORMATEX         device_format;
    WAVEFORMATEXTENSIBLE device_format_ext;
  };
  IMMDeviceCollection* devices;
  IMMDevice*            device;
  IPropertyStore*        props;
  IAudioClient*         client;
  LPWSTR             device_id; //aka wide char* (wchar_t*)!
  LPWSTR          device_iname;
  LPWSTR           device_name;
  LPWSTR           device_desc;
  size_t      device_iname_len;
  size_t       device_name_len;
  size_t       device_desc_len;
  UINT            device_index;
  EDataFlow          data_flow; //read-only; set by init
  int                data_type; //1,2,3 = pcm&format, float&format_ext, pcm&format_ext
  int     event_driven_support; //might not be used
} _kit_audioGlobalsDevInfo;
struct _kit_audioGlobals_s {
  CRITICAL_SECTION           lock;
  IMMDeviceEnumerator* enumerator;
  kit_audioDevice**   kit_devices;
  UINT            kit_devices_len;
  _kit_audioGlobalsDevInfo      i;
  _kit_audioGlobalsDevInfo      o;
  int                        init;
};
"
3g6HsQLi,_kit_w32_audioCOM.h (scrapped),Kitomas,C++,Friday 14th of July 2023 03:44:57 AM CDT,"//used internally by kit_w32_audio to wrap c++ com interfaces for use in c
//(i'm making the api intentionally verbose here)
//interfaces implemented:
//IMMDeviceEnumerator
//IMMDeviceCollection
//IMMDevice
//IAudioClient
//IAudioRenderClient
//IPropertyStore
#ifndef _KIT_W32_AUDIOCOM_H
#define _KIT_W32_AUDIOCOM_H



#ifndef COM_NO_WINDOWS_H
# define COM_NO_WINDOWS_H
#  include <windef.h>
#  include <winnt.h>
//#  include <initguid.h>
#  include <audioclient.h>
#  include <mmdeviceapi.h>
# undef COM_NO_WINDOWS_H
#else
#  include <windef.h>
#  include <winnt.h>
//#  include <initguid.h>
#  include <audioclient.h>
#  include <mmdeviceapi.h>
#endif

#ifdef __cplusplus
extern ""C"" {
#endif



//IMMDeviceEnumerator

extern HRESULT _kit_audioCOM_IMMDeviceEnumerator_EnumAudioEndpoints(IMMDeviceEnumerator* enumerator,
  EDataFlow dataFlow_i, DWORD stateMask_i, IMMDeviceCollection** devices_o);


extern HRESULT _kit_audioCOM_IMMDeviceEnumerator_GetDefaultAudioEndpoint(IMMDeviceEnumerator* enumerator,
  EDataFlow dataFlow_i, ERole role_i, IMMDevice** endpoint_o);


extern HRESULT _kit_audioCOM_IMMDeviceEnumerator_GetDevice(IMMDeviceEnumerator* enumerator,
  LPCWSTR strID_i, IMMDevice** device_o);


extern HRESULT _kit_audioCOM_IMMDeviceEnumerator_RegisterEndpointNotificationCallback(IMMDeviceEnumerator* enumerator,
  IMMNotificationClient* client_i);


extern HRESULT _kit_audioCOM_IMMDeviceEnumerator_UnregisterEndpointNotificationCallback(IMMDeviceEnumerator* enumerator,
  IMMNotificationClient* client_i);


extern HRESULT _kit_audioCOM_IMMDeviceEnumerator_QueryInterface(IMMDeviceEnumerator* enumerator,
  IMMDeviceEnumerator** enumerator_o);


extern ULONG _kit_audioCOM_IMMDeviceEnumerator_AddRef(IMMDeviceEnumerator* enumerator);


extern ULONG _kit_audioCOM_IMMDeviceEnumerator_Release(IMMDeviceEnumerator* enumerator);



//IMMDeviceCollection

extern HRESULT _kit_audioCOM_IMMDeviceCollection_GetCount(IMMDeviceCollection* deviceCollection,
  UINT* devices_o);


extern HRESULT _kit_audioCOM_IMMDeviceCollection_Item(IMMDeviceCollection* deviceCollection,
  UINT deviceNum_i, IMMDevice** device_o);


extern HRESULT _kit_audioCOM_IMMDeviceCollection_QueryInterface(IMMDeviceCollection* deviceCollection,
  IMMDeviceCollection** deviceCollection_o);


extern ULONG _kit_audioCOM_IMMDeviceCollection_AddRef(IMMDeviceCollection* deviceCollection);


extern ULONG _kit_audioCOM_IMMDeviceCollection_Release(IMMDeviceCollection* deviceCollection);



//IMMDevice

extern HRESULT _kit_audioCOM_IMMDevice_Activate(IMMDevice* device,
  REFIID iid_i, DWORD clsCtx_i, PROPVARIANT* activationParams_i, void** interface_o);


extern HRESULT _kit_audioCOM_IMMDevice_GetId(IMMDevice* device,
  LPWSTR* strID_o);


extern HRESULT _kit_audioCOM_IMMDevice_GetState(IMMDevice* device,
  DWORD* state_o);


extern HRESULT _kit_audioCOM_IMMDevice_OpenPropertyStore(IMMDevice* device,
  DWORD access_i, IPropertyStore** properties_o);


extern HRESULT _kit_audioCOM_IMMDevice_QueryInterface(IMMDevice* device,
  IMMDevice** device_o);


extern ULONG _kit_audioCOM_IMMDevice_AddRef(IMMDevice* device);


extern ULONG _kit_audioCOM_IMMDevice_Release(IMMDevice* device);



//IAudioClient

extern HRESULT _kit_audioCOM_IAudioClient_GetBufferSize(IAudioClient* audioClient,
  UINT32* numBufferFrames_o);


extern HRESULT _kit_audioCOM_IAudioClient_GetCurrentPadding(IAudioClient* audioClient,
  UINT32* numPaddingFrames_o);


extern HRESULT _kit_audioCOM_IAudioClient_GetDevicePeriod(IAudioClient* audioClient,
  REFERENCE_TIME* defaultDevicePeriod_o, REFERENCE_TIME* minimumDevicePeriod_o);


extern HRESULT _kit_audioCOM_IAudioClient_GetMixFormat(IAudioClient* audioClient,
  WAVEFORMATEX** deviceFormat_o);


extern HRESULT _kit_audioCOM_IAudioClient_GetService(IAudioClient* audioClient,
  REFIID riid_i, void** ppv_o);


extern HRESULT _kit_audioCOM_IAudioClient_GetStreamLatency(IAudioClient* audioClient,
  REFERENCE_TIME* latency_o);


extern HRESULT _kit_audioCOM_IAudioClient_Initialize(IAudioClient* audioClient,
  AUDCLNT_SHAREMODE shareMode_i, DWORD streamFlags_i, REFERENCE_TIME bufferDuration_i,
  REFERENCE_TIME periodicity_i, const WAVEFORMATEX* format_i, LPCGUID audioSessionGUID_i);


extern HRESULT _kit_audioCOM_IAudioClient_IsFormatSupported(IAudioClient* audioClient,
  AUDCLNT_SHAREMODE shareMode_i, const WAVEFORMATEX* format_i, WAVEFORMATEX** closestMatch_o);


extern HRESULT _kit_audioCOM_IAudioClient_Reset(IAudioClient* audioClient);


extern HRESULT _kit_audioCOM_IAudioClient_SetEventHandle(IAudioClient* audioClient,
  HANDLE eventHandle_i);


extern HRESULT _kit_audioCOM_IAudioClient_Start(IAudioClient* audioClient);


extern HRESULT _kit_audioCOM_IAudioClient_Stop(IAudioClient* audioClient);


extern HRESULT _kit_audioCOM_IAudioClient_QueryInterface(IAudioClient* audioClient,
  IAudioClient** audioClient_o);


extern ULONG _kit_audioCOM_IAudioClient_AddRef(IAudioClient* audioClient);


extern ULONG _kit_audioCOM_IAudioClient_Release(IAudioClient* audioClient);



//IAudioRenderClient

extern HRESULT _kit_audioCOM_IAudioRenderClient_GetBuffer(IAudioRenderClient* audioRenderClient,
  UINT32 numFramesRequested_i, BYTE** data);


extern HRESULT _kit_audioCOM_IAudioRenderClient_ReleaseBuffer(IAudioRenderClient* audioRenderClient,
  UINT32 numFramesWritten_i, DWORD flags_i);


extern HRESULT _kit_audioCOM_IAudioRenderClient_QueryInterface(IAudioRenderClient* audioRenderClient,
  IAudioRenderClient** audioRenderClient_o);


extern ULONG _kit_audioCOM_IAudioRenderClient_AddRef(IAudioRenderClient* audioRenderClient);


extern ULONG _kit_audioCOM_IAudioRenderClient_Release(IAudioRenderClient* audioRenderClient);



//IPropertyStore

extern HRESULT _kit_audioCOM_IPropertyStore_Commit(IPropertyStore* properties);


extern HRESULT _kit_audioCOM_IPropertyStore_GetAt(IPropertyStore* properties,
  DWORD propertyKeyIndex_i, PROPERTYKEY* propertyKey_o);


extern HRESULT _kit_audioCOM_IPropertyStore_GetCount(IPropertyStore* properties,
  DWORD* numProperties_o);


extern HRESULT _kit_audioCOM_IPropertyStore_GetValue(IPropertyStore* properties,
  REFPROPERTYKEY key_i, PROPVARIANT* propertyVariant_o);


extern HRESULT _kit_audioCOM_IPropertyStore_SetValue(IPropertyStore* properties,
  REFPROPERTYKEY key_i, REFPROPVARIANT propertyVariant_i);


extern HRESULT _kit_audioCOM_IPropertyStore_QueryInterface(IPropertyStore* properties,
  IPropertyStore** properties_o);


extern ULONG _kit_audioCOM_IPropertyStore_AddRef(IPropertyStore* properties);


extern ULONG _kit_audioCOM_IPropertyStore_Release(IPropertyStore* properties);



#ifdef __cplusplus
}
#endif



#endif //_KIT_W32_AUDIOCOM_H"
72efQWzZ,_kit_w32_audioPropKeyDef.h (scrapped),Kitomas,C,Friday 14th of July 2023 03:44:02 AM CDT,"#ifndef _KIT_W32_AUDIOPROPKEYDEF_H
#define _KIT_W32_AUDIOPROPKEYDEF_H

#include <propkeydef.h>

//these are of type LPWSTR (wchar_t*)
DEFINE_PROPERTYKEY(PKEY_Device_FriendlyName,           0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 14);
DEFINE_PROPERTYKEY(PKEY_Device_DeviceDesc,             0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 2);
DEFINE_PROPERTYKEY(PKEY_DeviceInterface_FriendlyName,  0x026e516e, 0xb814, 0x414b, 0x83, 0xcd, 0x85, 0x6d, 0x6f, 0xef, 0x48, 0x22, 2);

DEFINE_PROPERTYKEY(PKEY_Device_InstanceId,             0x78c34fc8, 0x104a, 0x4aca, 0x9e, 0xa4, 0x52, 0x4d, 0x52, 0x99, 0x6e, 0x57, 256);

#endif /* _KIT_W32_AUDIOPROPKEYDEF_H */"
fSsdvF5E,kit_w32_audio.c (scrapped),Kitomas,C,Friday 14th of July 2023 03:41:50 AM CDT,"//compile with kernel32, and ole32
 /**
  * \file kit_w32_audio.c
  * \brief Header file for KIT Win32's audio module
  */

#include <kit_w32_audio.h>
#include <_kit_w32_audioCOM.h>
#include <_kit_w32_audioPropKeyDef.h> //#include <Functiondiscoverykeys_devpkey.h>


#define _KIT_AUDIO_MMONO   (SPEAKER_FRONT_LEFT)
#define _KIT_AUDIO_MSTEREO (_KIT_AUDIO_MMONO  |SPEAKER_FRONT_RIGHT  )
#define _KIT_AUDIO_M2_1S   (_KIT_AUDIO_MSTEREO|SPEAKER_LOW_FREQUENCY)
#define _KIT_AUDIO_MQUAD   (_KIT_AUDIO_MSTEREO|SPEAKER_BACK_LEFT    |SPEAKER_BACK_RIGHT)
#define _KIT_AUDIO_M4_1S   (_KIT_AUDIO_MQUAD  |SPEAKER_LOW_FREQUENCY)
#define _KIT_AUDIO_M5_1S   (_KIT_AUDIO_M4_1S  |SPEAKER_FRONT_CENTER )
#define _KIT_AUDIO_M6_1S   (_KIT_AUDIO_M2_1S  |SPEAKER_FRONT_CENTER |SPEAKER_SIDE_LEFT |SPEAKER_SIDE_RIGHT)
#define _KIT_AUDIO_M7_1S   (_KIT_AUDIO_M5_1S  |SPEAKER_SIDE_LEFT    |SPEAKER_SIDE_RIGHT)


#define _KIT_AUDIO_LOCKCALLBACKTHREAD(_device) \
  EnterCriticalSection(&_device->_callback_mutex);
#define _KIT_AUDIO_UNLOCKCALLBACKTHREAD(_device) \
  LeaveCriticalSection(&_device->_callback_mutex);


#define _IS_ERROR(_value,_before_goto) \
  { returnStatus=_value; _before_goto; goto _error_; }
#define _IF_ERROR(_condition,_value,_before_goto) \
  if(_condition){ _IS_ERROR(_value,_before_goto); }

#define _KIT_AUDIO_FREE(_action,_pointer) \
  if(_pointer != NULL){ _action(_pointer); }
#define _KIT_AUDIO_RELEASE(_action,_pointer) \
  if(_pointer != NULL){ while(numRefs){ \
    numRefs=_action(_pointer); \
  }} \
  numRefs=1;


#define _LOCK_GLOBALS_AUDIO EnterCriticalSection(&_kit_audioGlobals.lock);
#define _UNLOCK_GLOBALS_AUDIO LeaveCriticalSection(&_kit_audioGlobals.lock);
/*
typedef struct {
  union {
    WAVEFORMATEX         device_format;
    WAVEFORMATEXTENSIBLE device_format_ext;
  };
  IMMDeviceCollection* devices;
  IMMDevice*            device;
  IPropertyStore*        props;
  IAudioClient*         client;
  LPWSTR             device_id; //aka wide char* (wchar_t*)!
  LPWSTR          device_iname;
  LPWSTR           device_name;
  LPWSTR           device_desc;
  size_t      device_iname_len;
  size_t       device_name_len;
  size_t       device_desc_len;
  UINT            device_index;
  EDataFlow          data_flow; //read-only; set by init
  int                data_type; //1,2,3 = pcm&format, float&format_ext, pcm&format_ext
  int     event_driven_support; //might not be used
} _kit_audioGlobalsDevInfo;
struct _kit_audioGlobals_s {
  CRITICAL_SECTION           lock;
  IMMDeviceEnumerator* enumerator;
  kit_audioDevice**   kit_devices;
  UINT            kit_devices_len;
  _kit_audioGlobalsDevInfo      i;
  _kit_audioGlobalsDevInfo      o;
  int                        init;
};
*/
//(todo: eventually make this struct opaque and anonymous)
struct _kit_audioGlobals_s _kit_audioGlobals={0};
//KSDATAFORMAT_SUBTYPE_IEEE_FLOAT=""00000003-0000-0010-8000-00aa00389b71""
const GUID    _SUBTYPE_IEEE_FLOAT={.Data1=0x00000003,.Data2=0x0000,.Data3=0x0010,.Data4={0x80,0x00, 0x00,0xaa,0x00,0x38,0x9b,0x71}};
//KSDATAFORMAT_SUBTYPE_PCM       =""00000001-0000-0010-8000-00aa00389b71""
const GUID    _SUBTYPE_PCM       ={.Data1=0x00000001,.Data2=0x0000,.Data3=0x0010,.Data4={0x80,0x00, 0x00,0xaa,0x00,0x38,0x9b,0x71}};



/* (private) INLINES */

static inline int _kit_audioCountBits(long long unsigned int bitState){
  int bitCount=0;
  while(bitState){ bitCount+=bitState&1; bitState>>=1; }
  return bitCount;
}



/* CALLBACK-RELATED FUNCTIONS */



/* COM-RELATED FUNCTIONS */

kit_audioSpec _kit_audioWaveFormatToSpec(WAVEFORMATEX* format_ex, int* returnStatus_p){ /*0 -> 5*/
  int returnStatus=0; kit_audioSpec spec; //memset(&spec,0xff,sizeof(kit_audioSpec));
  WAVEFORMATEXTENSIBLE* format_ext=(void*)format_ex;

  _IF_ERROR(format_ex==NULL,1,;);
  WORD format_tag=format_ex->wFormatTag;

  kit_audioFormat format=0;
  if(format_tag==WAVE_FORMAT_EXTENSIBLE){
    _IF_ERROR(format_ext->Samples.wValidBitsPerSample>256,3,;);
    format|=format_ext->Samples.wValidBitsPerSample-1;
    _IF_ERROR(format_ex->cbSize!=(sizeof(WAVEFORMATEXTENSIBLE)-sizeof(WAVEFORMATEX)),4,;);

    GUID* subformat_tag=&format_ext->SubFormat;
    if(IsEqualGUID(subformat_tag,&_SUBTYPE_IEEE_FLOAT)) format |= KIT_AUDIO_FMT_MFLOAT|KIT_AUDIO_FMT_MSIGNED;
    else if(IsEqualGUID(subformat_tag,&_SUBTYPE_PCM)) format |= KIT_AUDIO_FMT_MSIGNED*(format>8);
    else _IS_ERROR(5,;);
  } else if(format_tag==WAVE_FORMAT_PCM){
    _IF_ERROR(format_ex->wBitsPerSample>256,3,;);
    format|=format_ex->wBitsPerSample-1;
  } else _IS_ERROR(2,;);

  spec.format=format;
  spec.frequency=format_ex->nSamplesPerSec;
  spec.channels=format_ex->nChannels;

  spec.buffer_len=spec.buffer_size=0;
  spec.callback=spec.userdata=0;
  _error_:
  if(returnStatus_p != NULL) *returnStatus_p=returnStatus;
  return spec;
}


WAVEFORMATEXTENSIBLE _kit_audioSpecToWaveFormat(kit_audioSpec* spec, int* returnStatus_p){ /*0 -> 5*/
  int returnStatus=0; WAVEFORMATEXTENSIBLE format={0}, null={0};
  _IF_ERROR(spec==NULL,1,;);

  //get kit_audioFormat data
  int bitsPerSample=(spec->format&KIT_AUDIO_FMT_MBITSIZE)+1;
  int isFloat      =(spec->format&KIT_AUDIO_FMT_MFLOAT  )!=0;
  int isBigEndian  =(spec->format&KIT_AUDIO_FMT_MENDIAN )!=0;
  int isSigned     =(spec->format&KIT_AUDIO_FMT_MSIGNED )!=0;
  _IF_ERROR(isBigEndian                 ,2,;);
  _IF_ERROR(isFloat&&(!isSigned)        ,3,;);
  _IF_ERROR(bitsPerSample<=8 && isSigned,4,;);

  //fill in WAVEFORMATEX info
  format.Format.wFormatTag=WAVE_FORMAT_EXTENSIBLE;
  format.Format.nChannels=spec->channels;
  format.Format.nSamplesPerSec=spec->frequency;
  format.Format.wBitsPerSample=(bitsPerSample>=8) ? ((bitsPerSample/8)*8) : 8;
  format.Format.nBlockAlign=spec->channels*(format.Format.wBitsPerSample/8);
  format.Format.nAvgBytesPerSec=spec->frequency*format.Format.nBlockAlign;
  format.Format.cbSize=sizeof(WAVEFORMATEXTENSIBLE)-sizeof(WAVEFORMATEX);

  //fill in WAVEFORMATEXTENSIBLE info
  format.Samples.wValidBitsPerSample=bitsPerSample;
   //set guid
  if(isFloat) memcpy(&format.SubFormat,&_SUBTYPE_IEEE_FLOAT,sizeof(GUID));
  else        memcpy(&format.SubFormat,&_SUBTYPE_PCM       ,sizeof(GUID));
   //set channel masks based on channel mapping
  switch(spec->channels){
  case 1: format.dwChannelMask=_KIT_AUDIO_MMONO;   break;
  case 2: format.dwChannelMask=_KIT_AUDIO_MSTEREO; break;
  case 3: format.dwChannelMask=_KIT_AUDIO_M2_1S;   break;
  case 4: format.dwChannelMask=_KIT_AUDIO_MQUAD;   break;
  case 5: format.dwChannelMask=_KIT_AUDIO_M4_1S;   break;
  case 6: format.dwChannelMask=_KIT_AUDIO_M5_1S;   break;
  case 7: format.dwChannelMask=_KIT_AUDIO_M6_1S;   break;
  case 8: format.dwChannelMask=_KIT_AUDIO_M7_1S;   break;
  default: _IS_ERROR(5,;); }

  _error_:
  if(returnStatus_p != NULL) *returnStatus_p=returnStatus;
  if(!returnStatus) return format;
  else              return null;
}


int _kit_audioQueryDevice(unsigned int index, int isCapture){ /*0 -> 4*/ //assumes globals are already locked
  int returnStatus=0; ULONG numRefs=1; UINT numDevices;

  //choose between capture and render
  _kit_audioGlobalsDevInfo* info;
  if(isCapture&1) info=&_kit_audioGlobals.i;
  else            info=&_kit_audioGlobals.o;

  //is given id greater than maximum valid index?
  _kit_audioCOM_IMMDeviceCollection_GetCount(info->devices, &numDevices);
  _IF_ERROR((index>=numDevices) && (index!=0xffffffff),1,;);

  //retrieve IMMDevice & IAudioClient, only if given index is different to the last one retrieved
  if(index!=info->device_index || info->device==NULL){
    //retrieve IMMDevice
     //clean up previous references
    _KIT_AUDIO_RELEASE(_kit_audioCOM_IMMDevice_Release,info->device);
    if(index != 0xffffffff){ // index!=-1
      _kit_audioCOM_IMMDeviceCollection_Item(info->devices, (UINT)index, &info->device);
    } else {
      _kit_audioCOM_IMMDeviceEnumerator_GetDefaultAudioEndpoint(_kit_audioGlobals.enumerator,
        info->data_flow, eConsole, &info->device);
    }
    info->device_index=index;

    //retrieve IAudioClient
     //clean up previous references
    _KIT_AUDIO_RELEASE(_kit_audioCOM_IAudioClient_Release,info->client);
    printf(""!A!last Win32 error=%lu\n"",GetLastError());
    switch(_kit_audioCOM_IMMDevice_Activate(info->device,
      &IID_IAudioClient, CLSCTX_ALL, NULL, (void**)&info->client)
    ){
    case AUDCLNT_E_DEVICE_INVALIDATED: _IS_ERROR(2,;);
    case E_NOINTERFACE:                _IS_ERROR(3,;);
    case E_OUTOFMEMORY:                _IS_ERROR(4,;);
    case S_OK:;
    }
    printf(""!B!last Win32 error=%lu\n"",GetLastError());
  }

  _error_: return returnStatus;
}


int _kit_audioQueryDeviceProps(unsigned int index, int isCapture){ /*0 -> 14*/ //assumes globals are already locked
  int returnStatus=0, property_init=0; ULONG numRefs=1;

  //choose between capture and render
  _kit_audioGlobalsDevInfo* info;
  if(isCapture&=1) info=&_kit_audioGlobals.i;
  else             info=&_kit_audioGlobals.o;

  int equal_to_last_index = index==info->device_index;
  returnStatus=_kit_audioQueryDevice(index,isCapture);
  if(returnStatus) goto _error_; //errors 1 -> 4

  //retrieve property store unless current one is identical
  if(!equal_to_last_index || info->props==NULL){
    //clean up previous references
    _KIT_AUDIO_RELEASE(_kit_audioCOM_IPropertyStore_Release,info->props);
    _IF_ERROR(_kit_audioCOM_IMMDevice_OpenPropertyStore(info->device,
      STGM_READ, &info->props) == E_OUTOFMEMORY,
    5,;);
  }

  //get WAVEFORMATEX(TENSIBLE) from device's property store
  PROPVARIANT property;
  _kit_audioCOM_IPropertyStore_GetValue(info->props, &PKEY_AudioEngine_DeviceFormat, &property);
  if(property.blob.pBlobData==NULL){
    PropVariantClear(&property);
    //try oem format instead
    _kit_audioCOM_IPropertyStore_GetValue(info->props, &PKEY_AudioEngine_OEMFormat, &property);
    _IF_ERROR(property.blob.pBlobData==NULL,6,;);
  }
  WORD format_tag=((WAVEFORMATEX*)property.blob.pBlobData)->wFormatTag; /* --> */ property_init=1;

  if(format_tag == WAVE_FORMAT_EXTENSIBLE){
    GUID* subformat_tag=&((WAVEFORMATEXTENSIBLE*)property.blob.pBlobData)->SubFormat;

    if(IsEqualGUID(subformat_tag,&_SUBTYPE_IEEE_FLOAT)) info->data_type=2;
    else if(IsEqualGUID(subformat_tag,&_SUBTYPE_PCM)) info->data_type=3;
    else { return returnStatus=8; goto _error_; }

    info->device_format_ext=*(WAVEFORMATEXTENSIBLE*)property.blob.pBlobData;
  } else if(format_tag == WAVE_FORMAT_PCM){ /* --> */ info->data_type=1;
    info->device_format=*(WAVEFORMATEX*)property.blob.pBlobData;
  }
  else{ returnStatus=7; goto _error_; }
  if(property_init) PropVariantClear(&property);
  property_init=0;

  //get whether device supports event-driven mode
  _kit_audioCOM_IPropertyStore_GetValue(info->props, &PKEY_AudioEndpoint_Supports_EventDriven_Mode, &property);
  info->event_driven_support=property.uintVal;
  PropVariantClear(&property);

  //get name of device
  _kit_audioCOM_IPropertyStore_GetValue(info->props, &PKEY_Device_FriendlyName, &property);
  _IF_ERROR(property.pwszVal==NULL,9,;); /* --> */ property_init=1;
  info->device_name_len=wcslen(property.pwszVal);
  info->device_name=_kit_audioRealloc(info->device_name,wchar_t,info->device_name_len+1);
  _IF_ERROR(info->device_name==NULL,10,;);
  wcscpy(info->device_name,property.pwszVal);
  PropVariantClear(&property); /* --> */ property_init=0;

  //get description of device
  _kit_audioCOM_IPropertyStore_GetValue(info->props, &PKEY_Device_DeviceDesc, &property);
  _IF_ERROR(property.pwszVal==NULL,11,;); /* --> */ property_init=1;
  info->device_desc_len=wcslen(property.pwszVal);
  info->device_desc=_kit_audioRealloc(info->device_desc,wchar_t,info->device_desc_len+1);
  _IF_ERROR(info->device_desc==NULL,12,;);
  wcscpy(info->device_desc,property.pwszVal);
  PropVariantClear(&property); /* --> */ property_init=0;

  //get interface name of device
  _kit_audioCOM_IPropertyStore_GetValue(info->props, &PKEY_DeviceInterface_FriendlyName, &property);
  _IF_ERROR(property.pwszVal==NULL,13,;); /* --> */ property_init=1;
  info->device_iname_len=wcslen(property.pwszVal);
  info->device_iname=_kit_audioRealloc(info->device_iname,wchar_t,info->device_iname_len+1);
  _IF_ERROR(info->device_iname==NULL,14,;);
  wcscpy(info->device_iname,property.pwszVal);
  PropVariantClear(&property); /* --> */ property_init=0;

  _error_:
  if(property_init) PropVariantClear(&property);
  return returnStatus;
}


int kit_audioQueryDevices(int isCapture, kit_audioDeviceStatus status){ /*0 -> 2*/
  int returnStatus=0; ULONG numRefs=1;
  _LOCK_GLOBALS_AUDIO;
  _IF_ERROR(!(status&ADStatusAll),1,;); //error if status is not a valid enum value

  //choose between capture and render
  _kit_audioGlobalsDevInfo* info;
  if(isCapture&1) info=&_kit_audioGlobals.i;
  else            info=&_kit_audioGlobals.o;

  //clean up previous references
  _KIT_AUDIO_RELEASE(_kit_audioCOM_IMMDeviceCollection_Release,info->devices);

  if(_kit_audioCOM_IMMDeviceEnumerator_EnumAudioEndpoints(_kit_audioGlobals.enumerator,
    info->data_flow, (DWORD)status, &info->devices) == E_OUTOFMEMORY
  ) returnStatus=2;

  _error_:
  _UNLOCK_GLOBALS_AUDIO;
  return returnStatus;
}


unsigned int kit_audioGetNumDevices(int isCapture){
  UINT numDevices;
  _LOCK_GLOBALS_AUDIO;
  IMMDeviceCollection* devices;
  if(isCapture&1) devices=_kit_audioGlobals.i.devices;
  else            devices=_kit_audioGlobals.o.devices;
  _kit_audioCOM_IMMDeviceCollection_GetCount(devices,&numDevices);
  _UNLOCK_GLOBALS_AUDIO;
  return (unsigned int)numDevices;
}


wchar_t* kit_audioGetDeviceName(unsigned int index, int isCapture,
                                int mode, int* returnStatus_p){ /*0 -> 14*/
  int returnStatus=0; wchar_t* deviceName=NULL;
  _LOCK_GLOBALS_AUDIO;

  //choose between capture and render
  _kit_audioGlobalsDevInfo* info;
  if(isCapture&=1) info=&_kit_audioGlobals.i;
  else             info=&_kit_audioGlobals.o;

  returnStatus=_kit_audioQueryDeviceProps(index,isCapture);
  if(returnStatus) goto _error_; //errors 1 -> 14

  switch(mode%3){
  case 0: deviceName=info->device_name;  break;
  case 1: deviceName=info->device_desc;  break;
  case 2: deviceName=info->device_iname; }

  _error_:
  _UNLOCK_GLOBALS_AUDIO;
  if(returnStatus_p != NULL) *returnStatus_p=returnStatus;
  return deviceName;
}


wchar_t* kit_audioGetDeviceID(unsigned int index, int isCapture, int* returnStatus_p){ /*0 -> 5*/
  int returnStatus=0; wchar_t* deviceID=NULL;
  _LOCK_GLOBALS_AUDIO;

  //choose between capture and render
  _kit_audioGlobalsDevInfo* info;
  if(isCapture&=1) info=&_kit_audioGlobals.i;
  else             info=&_kit_audioGlobals.o;

  int equal_to_last_index = index==info->device_index;
  returnStatus=_kit_audioQueryDevice(index,isCapture);
  if(returnStatus) goto _error_; //errors 1 -> 4

  //return already cached id if id is the same as the last
  _IF_ERROR(equal_to_last_index,0, deviceID=info->device_id);
  if(_kit_audioCOM_IMMDevice_GetId(info->device,(LPWSTR*)&deviceID) != E_OUTOFMEMORY){
    _KIT_AUDIO_FREE(_kit_audioFree,info->device_id);
    info->device_id=deviceID;
  } else returnStatus=5;

  _error_:
  _UNLOCK_GLOBALS_AUDIO;
  if(returnStatus_p != NULL) *returnStatus_p=returnStatus;
  return deviceID;
}


kit_audioDeviceStatus kit_audioGetDeviceStatus(unsigned int index, int isCapture, int* returnStatus_p){ /*0 -> 4*/
  int returnStatus=0; kit_audioDeviceStatus deviceStatus;
  _LOCK_GLOBALS_AUDIO;

  //choose between capture and render
  IMMDevice* device;
  if(isCapture) device=_kit_audioGlobals.i.device;
  else          device=_kit_audioGlobals.o.device;

  returnStatus=_kit_audioQueryDevice(index,isCapture&=1);
  if(returnStatus) goto _error_; //errors 1 -> 4

  _kit_audioCOM_IMMDevice_GetState(device, (DWORD*)&deviceStatus);

  _error_:
  _UNLOCK_GLOBALS_AUDIO;
  if(returnStatus){
    deviceStatus=ADStatusInvalid;
    if(returnStatus_p != NULL) *returnStatus_p=returnStatus;
  }
  return deviceStatus;
}


int kit_audioGetDeviceSpec(unsigned int index, int isCapture, kit_audioSpec* spec){ /*0 -> 20*/
  int returnStatus=0; //ULONG numRefs=1; //HRESULT hr;
  _LOCK_GLOBALS_AUDIO;
  _IF_ERROR(spec==NULL,1,;);

  //choose between capture and render
  WAVEFORMATEX* device_format;
  if(isCapture&=1) device_format=&_kit_audioGlobals.i.device_format;
  else             device_format=&_kit_audioGlobals.o.device_format;

  //retrieve relevant property store info
  returnStatus=_kit_audioQueryDeviceProps(index,isCapture); //calls _kit_audioQueryDevice
  if(returnStatus){ ++returnStatus; goto _error_; } //errors 2 -> 15

  //convert format info to kit_audioSpec
  kit_audioSpec _spec=_kit_audioWaveFormatToSpec(device_format, &returnStatus);
  if(returnStatus){ returnStatus+=15; goto _error_; } //errors 16 -> 20
  *spec=_spec;

  _error_:
  _UNLOCK_GLOBALS_AUDIO;
  return returnStatus;
}


int kit_audioIsSpecSupported(unsigned int index, int isCapture, /*int exclusive,*/ /*-1 -> 17*/
                             kit_audioSpec* spec, kit_audioSpec* closestMatch){
  int returnStatus=0;
  //AUDCLNT_SHAREMODE shareMode=(exclusive&1) ? AUDCLNT_SHAREMODE_EXCLUSIVE : AUDCLNT_SHAREMODE_SHARED;
  AUDCLNT_SHAREMODE shareMode=AUDCLNT_SHAREMODE_SHARED;
  WAVEFORMATEX* _closestMatch_WFE=NULL;
  _LOCK_GLOBALS_AUDIO;
  _IF_ERROR(spec==NULL,1,;);

  //choose between capture and render
  IAudioClient* client;
  if(isCapture&=1) client=_kit_audioGlobals.i.client;
  else             client=_kit_audioGlobals.o.client;

  //retrieve device (as well as the associated audio client)
  returnStatus=_kit_audioQueryDevice(index,isCapture);
  if(returnStatus){ ++returnStatus; goto _error_; } //errors 2 -> 5

  //convert specification to wave format struct
  WAVEFORMATEXTENSIBLE format=_kit_audioSpecToWaveFormat(spec,&returnStatus);
  if(returnStatus){ returnStatus+=5; goto _error_; } //errors 6 -> 10

  switch(_kit_audioCOM_IAudioClient_IsFormatSupported(client,
    shareMode, (WAVEFORMATEX*)&format, &_closestMatch_WFE)
  ){
  //case AUDCLNT_E_UNSUPPORTED_FORMAT: (only applicable in exclusive sharemode)
  //i don't get how this would realistically happen in practice
   //(like, the fundamental audio service isn't running at all?)
  case AUDCLNT_E_SERVICE_NOT_RUNNING: _IS_ERROR(11,;);
  case AUDCLNT_E_DEVICE_INVALIDATED:  _IS_ERROR(12,;);
  case S_FALSE: returnStatus=-1;
  case S_OK:;
  }

  _error_:
  _UNLOCK_GLOBALS_AUDIO;
  if(_closestMatch_WFE != NULL){
    kit_audioSpec _closestMatch=_kit_audioWaveFormatToSpec(_closestMatch_WFE,&returnStatus);
    if(returnStatus){ returnStatus+=12; goto free_wfe_; } //errors 13 -> 17
    *closestMatch=_closestMatch;
  }
  free_wfe_:
  _KIT_AUDIO_FREE(_kit_audioFree,_closestMatch_WFE);
  return returnStatus;
}


//this is more of a utility function, as everything used here is public anyway
unsigned int kit_audioGetDeviceIndexFromID(wchar_t* deviceID, int isCapture, int* returnStatus_p){ /*-1 -> 9*/
  int returnStatus=0, locked=0; unsigned int index=0xfffffffe; wchar_t *_deviceID=NULL, *deviceID2;
  _IF_ERROR(deviceID==NULL,1,;);

  //copy id to a temporary location, to make sure globals aren't tripped over
  _LOCK_GLOBALS_AUDIO; locked=1;
  int IDLen=wcslen(deviceID);
  _IF_ERROR(!IDLen,2,;);
  _deviceID=_kit_audioMalloc(wchar_t,IDLen);
  _IF_ERROR(_deviceID==NULL,3,;);
  wcscpy(_deviceID,deviceID);
  _UNLOCK_GLOBALS_AUDIO; locked=0;

  //do a linear search of ids
  unsigned int numDevices=kit_audioGetNumDevices(isCapture&=1);
  _IF_ERROR(!numDevices,4,;);
  for(unsigned int i=-1; (i==-1)||(i<numDevices); ++i){
    deviceID2=kit_audioGetDeviceID(i,isCapture,&returnStatus);
    if(returnStatus){ returnStatus+=4; goto _error_; } //errors 5 -> 9
    _LOCK_GLOBALS_AUDIO; locked=1;
    if(wcscmp(_deviceID,deviceID2)){ index=i; break; }
    _UNLOCK_GLOBALS_AUDIO; locked=0;
  }
  if(index == 0xfffffffe) returnStatus=-1; //index == -2

  _error_:
  if(locked) _UNLOCK_GLOBALS_AUDIO;
  _KIT_AUDIO_FREE(_kit_audioFree,_deviceID);
  if(returnStatus_p != NULL) *returnStatus_p=returnStatus;
  return index;
}



/* kit_audioDevice-RELATED FUNCTIONS */

int kit_audioDevicePlay(kit_audioDevice* device, kit_audioDevicePState playState){
  int returnStatus=0;
  //_error_:
  return returnStatus;
}


kit_audioDevicePState kit_audioGetDevicePlayState(kit_audioDevice* device){
  kit_audioDevicePState returnStatus=ADPStateInvalid;
  //_error_:
  return returnStatus;
}



/* (UN)INIT FUNCTIONS */

int kit_audioInit(int initCOM){
  int returnStatus=0, critical_section_init=0;
  //might cause race conditions, but i don't know how to structure this better
  _IF_ERROR(_kit_audioGlobals.init,1,;);
  InitializeCriticalSection(&_kit_audioGlobals.lock);
  critical_section_init=1;
  _LOCK_GLOBALS_AUDIO;
  memset(((void*)&_kit_audioGlobals)+sizeof(CRITICAL_SECTION),0,
         sizeof(_kit_audioGlobals)-sizeof(CRITICAL_SECTION));

  //set i and o's data_flow to eCapture and eRender respectively
  _kit_audioGlobals.i.data_flow=eCapture;
  _kit_audioGlobals.o.data_flow=eRender;

  //initialize com
  if(initCOM&1) CoInitializeEx(NULL,COINIT_MULTITHREADED);

  //create enumerator object
  HRESULT hr=CoCreateInstance(
    &CLSID_MMDeviceEnumerator,
    NULL, CLSCTX_ALL,
    &IID_IMMDeviceEnumerator,
    (void**)&_kit_audioGlobals.enumerator
  ); _IF_ERROR(FAILED(hr),2,;);

  //get input device collection
  hr=_kit_audioCOM_IMMDeviceEnumerator_EnumAudioEndpoints(_kit_audioGlobals.enumerator,
    eCapture, DEVICE_STATEMASK_ALL, &_kit_audioGlobals.i.devices
  ); _IF_ERROR(FAILED(hr),3,;);

  //get output device collection
  hr=_kit_audioCOM_IMMDeviceEnumerator_EnumAudioEndpoints(_kit_audioGlobals.enumerator,
    eRender, DEVICE_STATEMASK_ALL, &_kit_audioGlobals.o.devices
  ); _IF_ERROR(FAILED(hr),4,;);

  _kit_audioGlobals.init=1;
  _error_:
  if(critical_section_init) _UNLOCK_GLOBALS_AUDIO;
  return returnStatus;
}


int kit_audioQuit(int uninitCOM){
  int returnStatus=0; ULONG numRefs=1;
  _IF_ERROR(!_kit_audioGlobals.init,1,;);
  _LOCK_GLOBALS_AUDIO;

  //free last i/o device names (wchar_t*)
  _KIT_AUDIO_FREE(_kit_audioFree,_kit_audioGlobals.i.device_name);
  _KIT_AUDIO_FREE(_kit_audioFree,_kit_audioGlobals.i.device_desc);
  _KIT_AUDIO_FREE(_kit_audioFree,_kit_audioGlobals.i.device_iname);
  _KIT_AUDIO_FREE(_kit_audioFree,_kit_audioGlobals.o.device_name);
  _KIT_AUDIO_FREE(_kit_audioFree,_kit_audioGlobals.o.device_desc);
  _KIT_AUDIO_FREE(_kit_audioFree,_kit_audioGlobals.o.device_iname);

  //free last i/o device ids (wchar_t*)
  _KIT_AUDIO_FREE(_kit_audioFree,_kit_audioGlobals.i.device_id);
  _KIT_AUDIO_FREE(_kit_audioFree,_kit_audioGlobals.o.device_id);

  //release last i/o device audio clients
  _KIT_AUDIO_RELEASE(_kit_audioCOM_IAudioClient_Release,_kit_audioGlobals.i.client);
  _KIT_AUDIO_RELEASE(_kit_audioCOM_IAudioClient_Release,_kit_audioGlobals.o.client);

  //release last i/o device property stores
  _KIT_AUDIO_RELEASE(_kit_audioCOM_IPropertyStore_Release,_kit_audioGlobals.i.props);
  _KIT_AUDIO_RELEASE(_kit_audioCOM_IPropertyStore_Release,_kit_audioGlobals.o.props);

  //release last i/o devices
  _KIT_AUDIO_RELEASE(_kit_audioCOM_IMMDevice_Release,_kit_audioGlobals.i.device);
  _KIT_AUDIO_RELEASE(_kit_audioCOM_IMMDevice_Release,_kit_audioGlobals.o.device);

  //release i/o device collections
  _KIT_AUDIO_RELEASE(_kit_audioCOM_IMMDeviceCollection_Release,_kit_audioGlobals.i.devices);
  _KIT_AUDIO_RELEASE(_kit_audioCOM_IMMDeviceCollection_Release,_kit_audioGlobals.o.devices);

  //release enumerator
  _KIT_AUDIO_RELEASE(_kit_audioCOM_IMMDeviceEnumerator_Release,_kit_audioGlobals.enumerator);

  //todo: find out why CoUninitialize() makes GetLastError()=126 (ERROR_MOD_NOT_FOUND)
  if(uninitCOM&1) CoUninitialize();
  _kit_audioGlobals.init=0;
  _error_:
  _UNLOCK_GLOBALS_AUDIO;
  if(!returnStatus) DeleteCriticalSection(&_kit_audioGlobals.lock);
  return returnStatus;
}


kit_audioDevice* kit_audioDeviceOpen(kit_audioSpec* spec, unsigned int index,
                                     int isCapture, int* returnStatus_p){
  int returnStatus=0;
  _IF_ERROR(spec==NULL,1,;);

  _error_:
  if(returnStatus_p != NULL) *returnStatus_p=returnStatus;
  return NULL;
}


int kit_audioDeviceClose(kit_audioDevice** device_p){
  int returnStatus=0;
  _IF_ERROR(device_p==NULL,1,;);

  _error_:
  return returnStatus;
}
"
jsfJMKJ4,_kit_w32_audioCOM.cpp (scrapped),Kitomas,C++,Friday 14th of July 2023 03:40:54 AM CDT,"//used internally by kit_w32_audio to wrap c++ com interfaces for use in c
//(i'm making the api intentionally verbose here)
//interfaces implemented:
//IMMDeviceEnumerator
//IMMDeviceCollection
//IMMDevice
//IAudioClient
//IAudioRenderClient
//IPropertyStore
#include <_kit_w32_audioCOM.h>



//IMMDeviceEnumerator

HRESULT _kit_audioCOM_IMMDeviceEnumerator_EnumAudioEndpoints(IMMDeviceEnumerator* enumerator,
  EDataFlow dataFlow_i, DWORD stateMask_i, IMMDeviceCollection** devices_o)
{ return enumerator->EnumAudioEndpoints(dataFlow_i, stateMask_i, devices_o); }


HRESULT _kit_audioCOM_IMMDeviceEnumerator_GetDefaultAudioEndpoint(IMMDeviceEnumerator* enumerator,
  EDataFlow dataFlow_i, ERole role_i, IMMDevice** endpoint_o)
{ return enumerator->GetDefaultAudioEndpoint(dataFlow_i, role_i, endpoint_o); }


HRESULT _kit_audioCOM_IMMDeviceEnumerator_GetDevice(IMMDeviceEnumerator* enumerator,
  LPCWSTR strID_i, IMMDevice** device_o)
{ return enumerator->GetDevice(strID_i, device_o); }


HRESULT _kit_audioCOM_IMMDeviceEnumerator_RegisterEndpointNotificationCallback(IMMDeviceEnumerator* enumerator,
  IMMNotificationClient* client_i)
{ return enumerator->RegisterEndpointNotificationCallback(client_i); }


HRESULT _kit_audioCOM_IMMDeviceEnumerator_UnregisterEndpointNotificationCallback(IMMDeviceEnumerator* enumerator,
  IMMNotificationClient* client_i)
{ return enumerator->UnregisterEndpointNotificationCallback(client_i); }

//
HRESULT _kit_audioCOM_IMMDeviceEnumerator_QueryInterface(IMMDeviceEnumerator* enumerator,
  IMMDeviceEnumerator** enumerator_o)
{ return enumerator->QueryInterface(enumerator_o); }


ULONG _kit_audioCOM_IMMDeviceEnumerator_AddRef(IMMDeviceEnumerator* enumerator)
{ return enumerator->AddRef(); }


ULONG _kit_audioCOM_IMMDeviceEnumerator_Release(IMMDeviceEnumerator* enumerator)
{ return enumerator->Release(); }



//IMMDeviceCollection

HRESULT _kit_audioCOM_IMMDeviceCollection_GetCount(IMMDeviceCollection* deviceCollection,
  UINT* devices_o)
{ return deviceCollection->GetCount(devices_o); }


HRESULT _kit_audioCOM_IMMDeviceCollection_Item(IMMDeviceCollection* deviceCollection,
  UINT deviceNum_i, IMMDevice** device_o)
{ return deviceCollection->Item(deviceNum_i, device_o); }

//
HRESULT _kit_audioCOM_IMMDeviceCollection_QueryInterface(IMMDeviceCollection* deviceCollection,
  IMMDeviceCollection** deviceCollection_o)
{ return deviceCollection->QueryInterface(deviceCollection_o); }


ULONG _kit_audioCOM_IMMDeviceCollection_AddRef(IMMDeviceCollection* deviceCollection)
{ return deviceCollection->AddRef(); }


ULONG _kit_audioCOM_IMMDeviceCollection_Release(IMMDeviceCollection* deviceCollection)
{ return deviceCollection->Release(); }



//IMMDevice

HRESULT _kit_audioCOM_IMMDevice_Activate(IMMDevice* device,
  REFIID iid_i, DWORD clsCtx_i, PROPVARIANT* activationParams_i, void** interface_o)
{ return device->Activate(iid_i, clsCtx_i, activationParams_i, interface_o); }


HRESULT _kit_audioCOM_IMMDevice_GetId(IMMDevice* device,
  LPWSTR* strID_o)
{ return device->GetId(strID_o); }


HRESULT _kit_audioCOM_IMMDevice_GetState(IMMDevice* device,
  DWORD* state_o)
{ return device->GetState(state_o); }


HRESULT _kit_audioCOM_IMMDevice_OpenPropertyStore(IMMDevice* device,
  DWORD access_i, IPropertyStore** properties_o)
{ return device->OpenPropertyStore(access_i, properties_o); }


HRESULT _kit_audioCOM_IMMDevice_QueryInterface(IMMDevice* device,
  IMMDevice** device_o)
{ return device->QueryInterface(device_o); }


ULONG _kit_audioCOM_IMMDevice_AddRef(IMMDevice* device)
{ return device->AddRef(); }


ULONG _kit_audioCOM_IMMDevice_Release(IMMDevice* device)
{ return device->Release(); }



//IAudioClient

HRESULT _kit_audioCOM_IAudioClient_GetBufferSize(IAudioClient* audioClient,
  UINT32* numBufferFrames_o)
{ return audioClient->GetBufferSize(numBufferFrames_o); }


HRESULT _kit_audioCOM_IAudioClient_GetCurrentPadding(IAudioClient* audioClient,
  UINT32* numPaddingFrames_o)
{ return audioClient->GetCurrentPadding(numPaddingFrames_o); }


HRESULT _kit_audioCOM_IAudioClient_GetDevicePeriod(IAudioClient* audioClient,
  REFERENCE_TIME* defaultDevicePeriod_o, REFERENCE_TIME* minimumDevicePeriod_o)
{ return audioClient->GetDevicePeriod(defaultDevicePeriod_o, minimumDevicePeriod_o); }


HRESULT _kit_audioCOM_IAudioClient_GetMixFormat(IAudioClient* audioClient,
  WAVEFORMATEX** deviceFormat_o)
{ return audioClient->GetMixFormat(deviceFormat_o); }


HRESULT _kit_audioCOM_IAudioClient_GetService(IAudioClient* audioClient,
  REFIID riid_i, void** ppv_o)
{ return audioClient->GetService(riid_i, ppv_o); }


HRESULT _kit_audioCOM_IAudioClient_GetStreamLatency(IAudioClient* audioClient,
  REFERENCE_TIME* latency_o)
{ return audioClient->GetStreamLatency(latency_o); }


HRESULT _kit_audioCOM_IAudioClient_Initialize(IAudioClient* audioClient,
  AUDCLNT_SHAREMODE shareMode_i, DWORD streamFlags_i, REFERENCE_TIME bufferDuration_i,
  REFERENCE_TIME periodicity_i, const WAVEFORMATEX* format_i, LPCGUID audioSessionGUID_i)
{ return audioClient->Initialize(shareMode_i, streamFlags_i, bufferDuration_i, periodicity_i, format_i, audioSessionGUID_i); }


HRESULT _kit_audioCOM_IAudioClient_IsFormatSupported(IAudioClient* audioClient,
  AUDCLNT_SHAREMODE shareMode_i, const WAVEFORMATEX* format_i, WAVEFORMATEX** closestMatch_o)
{ return audioClient->IsFormatSupported(shareMode_i, format_i, closestMatch_o); }


HRESULT _kit_audioCOM_IAudioClient_Reset(IAudioClient* audioClient)
{ return audioClient->Reset(); }


HRESULT _kit_audioCOM_IAudioClient_SetEventHandle(IAudioClient* audioClient,
  HANDLE eventHandle_i)
{ return audioClient->SetEventHandle(eventHandle_i); }


HRESULT _kit_audioCOM_IAudioClient_Start(IAudioClient* audioClient)
{ return audioClient->Start(); }


HRESULT _kit_audioCOM_IAudioClient_Stop(IAudioClient* audioClient)
{ return audioClient->Stop(); }


HRESULT _kit_audioCOM_IAudioClient_QueryInterface(IAudioClient* audioClient,
  IAudioClient** audioClient_o)
{ return audioClient->QueryInterface(audioClient_o); }


ULONG _kit_audioCOM_IAudioClient_AddRef(IAudioClient* audioClient)
{ return audioClient->AddRef(); }


ULONG _kit_audioCOM_IAudioClient_Release(IAudioClient* audioClient)
{ return audioClient->Release(); }



//IAudioRenderClient

HRESULT _kit_audioCOM_IAudioRenderClient_GetBuffer(IAudioRenderClient* audioRenderClient,
  UINT32 numFramesRequested_i, BYTE** data)
{ return audioRenderClient->GetBuffer(numFramesRequested_i, data); }


HRESULT _kit_audioCOM_IAudioRenderClient_ReleaseBuffer(IAudioRenderClient* audioRenderClient,
  UINT32 numFramesWritten_i, DWORD flags_i)
{ return audioRenderClient->ReleaseBuffer(numFramesWritten_i, flags_i); }


HRESULT _kit_audioCOM_IAudioRenderClient_QueryInterface(IAudioRenderClient* audioRenderClient,
  IAudioRenderClient** audioRenderClient_o)
{ return audioRenderClient->QueryInterface(audioRenderClient_o); }


ULONG _kit_audioCOM_IAudioRenderClient_AddRef(IAudioRenderClient* audioRenderClient)
{ return audioRenderClient->AddRef(); }


ULONG _kit_audioCOM_IAudioRenderClient_Release(IAudioRenderClient* audioRenderClient)
{ return audioRenderClient->Release(); }



//IPropertyStore

HRESULT _kit_audioCOM_IPropertyStore_Commit(IPropertyStore* properties)
{ return properties->Commit(); }


HRESULT _kit_audioCOM_IPropertyStore_GetAt(IPropertyStore* properties,
  DWORD propertyKeyIndex_i, PROPERTYKEY* propertyKey_o)
{ return properties->GetAt(propertyKeyIndex_i, propertyKey_o); }


HRESULT _kit_audioCOM_IPropertyStore_GetCount(IPropertyStore* properties,
  DWORD* numProperties_o)
{ return properties->GetCount(numProperties_o); }


HRESULT _kit_audioCOM_IPropertyStore_GetValue(IPropertyStore* properties,
  REFPROPERTYKEY key_i, PROPVARIANT* propertyVariant_o)
{ return properties->GetValue(key_i, propertyVariant_o); }


HRESULT _kit_audioCOM_IPropertyStore_SetValue(IPropertyStore* properties,
  REFPROPERTYKEY key_i, REFPROPVARIANT propertyVariant_i)
{ return properties->SetValue(key_i, propertyVariant_i); }


HRESULT _kit_audioCOM_IPropertyStore_QueryInterface(IPropertyStore* properties,
  IPropertyStore** properties_o)
{ return properties->QueryInterface(properties_o); }


ULONG _kit_audioCOM_IPropertyStore_AddRef(IPropertyStore* properties)
{ return properties->AddRef(); }


ULONG _kit_audioCOM_IPropertyStore_Release(IPropertyStore* properties)
{ return properties->Release(); }"
e7eWk8Qa,Untitled,Terror_nisse,C#,Friday 14th of July 2023 03:39:52 AM CDT,"	public interface IPostwmClass
	{
		Task<Dictionary<ButtonBuilder, Embed>> PostWMMessage(SocketUser user, string? l = null);
		// Define other methods used by InteractionHandler or other classes if needed
	}
	public class PostwmClass : IPostwmClass
	{

		private readonly IConfiguration _configuration;
		private readonly IUserTranslationsHandler _userTranslationsHandler;

		public PostwmClass(IConfiguration config, IUserTranslationsHandler userTranslationsHandler)
		{
			_configuration = config;
			_userTranslationsHandler = userTranslationsHandler;
		}

		public async Task<Dictionary<ButtonBuilder, Embed>> PostWMMessage(SocketUser user, string? l = null)
		{
			var t = _userTranslationsHandler;
			var id = user.Id;

			var embed = new EmbedBuilder()
				.WithTitle($"":wave: {await t.T(""verification_hello"", id, l: l)}"")

				.AddField($""**\n{await t.T(""verification_whatoffer"", id, l: l)}**"",
				$"":white_check_mark: {await t.T(""verification_offer1"", id, l: l)}\n"" +
				$"":white_check_mark: {await t.T(""verification_offer2"", id, l: l)}\n"" +
				$"":white_check_mark: {await t.T(""verification_offer3"", id, l: l)}\n"" +
				$"":white_check_mark: {await t.T(""verification_offer4"", id, l: l)}\n\n"" +
				$"":exclamation: {await t.T(""verification_rules1"", id, l: l, v: new string[] { $""<#{_configuration[""rulesChannel""]}>"" })}\n\n"")

				.WithImageUrl(""https://i.imgur.com/B0udNXR.png"").WithColor(Color.Blue);

			var buttonBuilder = new ButtonBuilder()
				.WithLabel(await t.T(""verification_button"", id, l: l)).WithCustomId(""application_apply"").WithStyle(ButtonStyle.Success).WithEmote(Emoji.Parse("":envelope_with_arrow:""));
			try
			{
				var dictionary = new Dictionary<ButtonBuilder, Embed>
				{
					{ buttonBuilder, embed.Build() }
				};
				return dictionary;
			}
			catch (Exception ex)
			{
				Console.WriteLine(ex.ToString());
				return null!;
			}
		}
	}"
enGBXJyv,algorithm-d1,CR7CR7,C#,Friday 14th of July 2023 03:38:04 AM CDT,"using System;

namespace d1
{
    // Клас за представяне на изчислителен алгоритъм
    public class Algorithm
    {
        // Метод за сортиране на масив по метода на мехурчето
        public static void BubbleSort(int[] array)
        {
            // Проверяваме дали масивът е null или празен
            if (array == null || array.Length == 0)
            {
                return; // Ако е така, прекратяваме метода
            }

            bool swapped; // Променлива за проверка дали има размяна на елементи

            do
            {
                swapped = false; // Задаваме променливата на false

                for (int i = 0; i < array.Length - 1; i++) // Обхождаме всички елементи на масива, освен последния
                {
                    if (array[i] > array[i + 1]) // Ако текущият елемент е по-голям от следващия
                    {
                        Swap(array, i, i + 1); // Разменяме ги
                        swapped = true; // Задаваме променливата на true
                    }
                }
            } while (swapped); // Повтаряме цикъла докато има размяна на елементи
        }

        // Метод за размяна на два елемента в масив по индекси
        private static void Swap(int[] array, int i, int j)
        {
            int temp = array[i]; // Запазваме стойността на първия елемент в променлива
            array[i] = array[j]; // Задаваме стойността на първия елемент да бъде равна на стойността на втория елемент
            array[j] = temp; // Задаваме стойността на втория елемент да бъде равна на запазената стойност на първия елемент
        }

        // Метод за намиране на факториел от дадено число рекурсивно
        public static int Factorial(int n)
        {
            if (n < 0) // Ако числото е отрицателно
            {
                throw new ArgumentException(""Числото не може да бъде отрицателно.""); // Хвърляме изключение
            }

            if (n == 0 || n == 1) // Ако числото е 0 или 1
            {
                return 1; // Връщаме 1 като резултат от метода
            }

            return n * Factorial(n - 1); // Връщаме произведението на числото и факториела от предходното число като резултат от метода
        }
    }
}
"
aBcMi8M5,Untitled,Terror_nisse,C#,Friday 14th of July 2023 03:36:32 AM CDT,"	public class Program
	{
		private readonly IConfiguration _configuration;
		private readonly IServiceProvider _services;

		private readonly DiscordSocketConfig _socketConfig = new()
		{
			GatewayIntents = (GatewayIntents.AllUnprivileged | GatewayIntents.MessageContent | GatewayIntents.GuildMembers) ^ GatewayIntents.GuildBans,
			LogGatewayIntentWarnings = false,
			AlwaysDownloadUsers = true,
		};

		public Program()
		{

			_configuration = new ConfigurationBuilder()
		    .AddEnvironmentVariables(prefix: ""DC_"")
		    .AddJsonFile(""config.json"", optional: true)
		    .Build();

			_services = new ServiceCollection()
		    .AddSingleton(_configuration)
		    .AddSingleton(_socketConfig)
		    .AddSingleton<DiscordSocketClient>()
		    .AddSingleton(x => new InteractionService(x.GetRequiredService<DiscordSocketClient>()))
		    .AddSingleton<InteractionHandler>()
		    .AddSingleton<IUserSettingHandler, UserSettingHandler>()
		    .AddSingleton<IPostwmClass, PostwmClass>()
		    .AddSingleton<IUserTranslationsHandler, UserTranslationsHandler>()
		    .AddSingleton<UserSettingHandler>()
		    .AddSingleton<PostwmClass>()
		    .AddSingleton<UserTranslationsHandler>()
		    .BuildServiceProvider();
		}

		static void Main(string[] args)
		=> new Program().RunAsync()
		    .GetAwaiter()
		    .GetResult();

		public async Task RunAsync()
		{
			var client = _services.GetRequiredService<DiscordSocketClient>();

			client.Log += LogAsync;

			// Here we can initialize the service that will register and execute our commands
			await _services.GetRequiredService<InteractionHandler>()
			    .InitializeAsync();

			// Bot token can be provided from the Configuration object we set up earlier
			await client.LoginAsync(TokenType.Bot, _configuration[""botToken""]);
			await client.StartAsync();

			// Never quit the program until manually forced to.
			await Task.Delay(Timeout.Infinite);
		}

#pragma warning disable CS1998 // Async method lacks 'await' operators and will run synchronously
		private async Task LogAsync(LogMessage message)
#pragma warning restore CS1998 // Async method lacks 'await' operators and will run synchronously
		=> Console.WriteLine(message.ToString());

		public static bool IsDebug()
		{
#if DEBUG
			return true;
#else
            return false;
#endif
		}
	}"
9xgKTEDm,tree-d1,CR7CR7,C#,Friday 14th of July 2023 03:33:54 AM CDT,"using System;
using System.Collections.Generic;

namespace d1
{
    // Клас за представяне на възел от дървото
    public class Node<T>
    {
        // Поле за съхранение на стойността на възела
        public T Value { get; set; }

        // Поле за съхранение на връзки към децата на възела
        public List<Node<T>> Children { get; set; }

        // Конструктор с параметър за стойността на възела
        public Node(T value)
        {
            Value = value;
            Children = new List<Node<T>>();
        }
    }

    // Клас за представяне на дърво
    public class Tree<T>
    {
        // Поле за съхранение на корена на дървото
        private Node<T> root;

        // Конструктор без параметри
        public Tree()
        {
            root = null;
        }

        // Метод за проверка дали дървото е празно
        public bool IsEmpty()
        {
            return root == null;
        }

        // Метод за добавяне на корен на дървото
        public void AddRoot(T value)
        {
            if (IsEmpty()) // Ако дървото е празно
            {
                root = new Node<T>(value); // Създаваме нов възел с посочената стойност и го задаваме за корен
            }
            else // Ако дървото не е празно
            {
                throw new InvalidOperationException(""Дървото вече има корен.""); // Хвърляме изключение
            }
        }

        // Метод за добавяне на дете към даден родителски възел
        public void AddChild(Node<T> parent, T value)
        {
            if (parent == null) // Ако родителският възел е null
            {
                throw new ArgumentNullException(""Родителският възел не може да бъде null.""); // Хвърляме изключение
            }

            Node<T> child = new Node<T>(value); // Създаваме нов възел с посочената стойност

            parent.Children.Add(child); // Добавяме новия възел като дете към родителския възел
        }

        // Метод за премахване на корена на дървото
        public T RemoveRoot()
        {
            if (IsEmpty()) // Ако дървото е празно
            {
                throw new InvalidOperationException(""Дървото е празно.""); // Хвърляме изключение
            }

            T value = root.Value; // Запазваме стойността на корена в променлива

            root = null; // Задаваме корена да сочи към null, което означава, че дървото става празно

            return value; // Връщаме запазената стойност като резултат от метода
        }

        // Метод за премахване на дете от даден родителски възел по индекс
        public T RemoveChild(Node<T> parent, int index)
        {
            if (parent == null) // Ако родителският възел е null
            {
                throw new ArgumentNullException(""Родителският възел не може да бъде null.""); // Хвърляме изключение
            }

            if (index < 0 || index >= parent.Children.Count) // Ако индексът е извън границите на списъка с деца
            {
                throw new ArgumentOutOfRangeException(""Индексът е извън границите на списъка с деца.""); // Хвърляме изключение
            }

            T value = parent.Children[index].Value; // Запазваме стойността на детето в променлива

            parent.Children.RemoveAt(index); // Премахваме детето от списъка с деца

            return value; // Връщаме запазената стойност като резултат от метода
        }

        // Метод за връщане на корена на дървото без да го премахваме
        public Node<T> GetRoot()
        {
            if (IsEmpty()) // Ако дървото е празно
            {
                throw new InvalidOperationException(""Дървото е празно.""); // Хвърляме изключение
            }

            return root; // Връщаме корена като резултат от метода
        }

        // Метод за връщане на дете от даден родителски възел по индекс без да го премахваме
        public Node<T> GetChild(Node<T> parent, int index)
        {
            if (parent == null) // Ако родителският възел е null
            {
                throw new ArgumentNullException(""Родителският възел не може да бъде null.""); // Хвърляме изключение
            }

            if (index < 0 || index >= parent.Children.Count) // Ако индексът е извън границите на списъка с деца
            {
                throw new ArgumentOutOfRangeException(""Индексът е извън границите на списъка с деца.""); // Хвърляме изключение
            }

            return parent.Children[index]; // Връщаме детето като резултат от метода
        }
    }
}
"
02ggRZxZ,Dictionary -d1,CR7CR7,C#,Friday 14th of July 2023 03:28:58 AM CDT,"using System;
using System.Collections.Generic;

namespace d1
{
    // Клас за представяне на речник
    public class Dictionary<TKey, TValue>
    {
        // Поле за съхранение на елементите на речника в хеш-таблица
        private List<KeyValuePair<TKey, TValue>>[] table;

        // Поле за съхранение на броя на елементите в речника
        private int count;

        // Конструктор с параметър за капацитета на речника
        public Dictionary(int capacity)
        {
            // Създаваме нов масив от списъци с посочения капацитет
            table = new List<KeyValuePair<TKey, TValue>>[capacity];

            // Инициализираме всеки списък в масива
            for (int i = 0; i < capacity; i++)
            {
                table[i] = new List<KeyValuePair<TKey, TValue>>();
            }

            // Инициализираме броя на елементите с 0
            count = 0;
        }

        // Метод за проверка дали речникът е празен
        public bool IsEmpty()
        {
            return count == 0;
        }

        // Метод за проверка дали речникът е пълен
        public bool IsFull()
        {
            return count == table.Length;
        }

        // Метод за хеширане на ключове
        private int Hash(TKey key)
        {
            // Използваме стандартния метод GetHashCode на типа TKey и взимаме остатъка при деление на дължината на масива
            return Math.Abs(key.GetHashCode()) % table.Length;
        }

        // Метод за добавяне на двойка ключ-стойност в речника
        public void Add(TKey key, TValue value)
        {
            // Проверяваме дали речникът е пълен
            if (IsFull())
            {
                // Ако е пълен, хвърляме изключение
                throw new InvalidOperationException(""Речникът е пълен."");
            }

            // Хешираме ключа и получаваме индекс в масива
            int index = Hash(key);

            // Обхождаме списъка на този индекс
            foreach (var pair in table[index])
            {
                // Ако намерим двойка със същия ключ
                if (pair.Key.Equals(key))
                {
                    // Хвърляме изключение, защото не можем да имаме повтарящи се ключове в речника
                    throw new ArgumentException(""Вече съществува елемент с такъв ключ."");
                }
            }

            // Създаваме нова двойка ключ-стойност
            var newPair = new KeyValuePair<TKey, TValue>(key, value);

            // Добавяме я в края на списъка на този индекс
            table[index].Add(newPair);

            // Увеличаваме броя на елементите с 1
            count++;
        }

        // Метод за премахване на двойка ключ-стойност от речника по зададен ключ
        public void Remove(TKey key)
        {
            // Проверяваме дали речникът е празен
            if (IsEmpty())
            {
                // Ако е празен, хвърляме изключение
                throw new InvalidOperationException(""Речникът е празен."");
            }

            // Хешираме ключа и получаваме индекс в масива
            int index = Hash(key);

            // Обхождаме списъка на този индекс
            for (int i = 0; i < table[index].Count; i++)
            {
                // Ако намерим двойка със същия ключ
                if (table[index][i].Key.Equals(key))
                {
                    // Премахваме я от списъка
                    table[index].RemoveAt(i);

                    // Намаляваме броя на елементите с 1
                    count--;

                    // Прекратяваме метода
                    return;
                }
            }

            // Ако не сме намерили двойка със същия ключ
            throw new KeyNotFoundException(""Няма елемент с такъв ключ."");
        }

        // Метод за връщане на стойността на двойка ключ-стойност от речника по зададен ключ
        public TValue Get(TKey key)
        {
            // Проверяваме дали речникът е празен
            if (IsEmpty())
            {
                // Ако е празен, хвърляме изключение
                throw new InvalidOperationException(""Речникът е празен."");
            }

            // Хешираме ключа и получаваме индекс в масива
            int index = Hash(key);

            // Обхождаме списъка на този индекс
            foreach (var pair in table[index])
            {
                // Ако намерим двойка със същия ключ
                if (pair.Key.Equals(key))
                {
                    // Връщаме стойността на двойката като резултат от метода
                    return pair.Value;
                }
            }

            // Ако не сме намерили двойка със същия ключ
            throw new KeyNotFoundException(""Няма елемент с такъв ключ."");
        }
    }
}
"
6TUUGRwy,libraryD1-List,CR7CR7,C#,Friday 14th of July 2023 03:22:16 AM CDT,"using System;

namespace d1
{
    // Клас за представяне на елемент от списъка
    public class Node<T>
    {
        // Поле за съхранение на стойността на елемента
        public T Value { get; set; }

        // Поле за съхранение на връзка към следващия елемент
        public Node<T> Next { get; set; }

        // Конструктор с параметър за стойността на елемента
        public Node(T value)
        {
            Value = value;
            Next = null;
        }
    }

    // Клас за представяне на списък
    public class List<T>
    {
        // Поле за съхранение на първия елемент на списъка
        private Node<T> head;

        // Поле за съхранение на последния елемент на списъка
        private Node<T> tail;

        // Поле за съхранение на броя на елементите в списъка
        private int count;

        // Конструктор без параметри
        public List()
        {
            head = null;
            tail = null;
            count = 0;
        }

        // Метод за проверка дали списъкът е празен
        public bool IsEmpty()
        {
            return count == 0;
        }

        // Метод за добавяне на елемент в началото на списъка
        public void AddFirst(T value)
        {
            Node<T> node = new Node<T>(value); // Създаваме нов елемент с посочената стойност

            if (IsEmpty()) // Ако списъкът е празен
            {
                head = node; // Задаваме първия и последния елемент да сочат към новия елемент
                tail = node;
            }
            else // Ако списъкът не е празен
            {
                node.Next = head; // Задаваме новия елемент да сочи към първия елемент
                head = node; // Задаваме първия елемент да сочи към новия елемент
            }

            count++; // Увеличаваме броя на елементите с 1
        }

        // Метод за добавяне на елемент в края на списъка
        public void AddLast(T value)
        {
            Node<T> node = new Node<T>(value); // Създаваме нов елемент с посочената стойност

            if (IsEmpty()) // Ако списъкът е празен
            {
                head = node; // Задаваме първия и последния елемент да сочат към новия елемент
                tail = node;
            }
            else // Ако списъкът не е празен
            {
                tail.Next = node; // Задаваме последния елемент да сочи към новия елемент
                tail = node; // Задаваме последния елемент да сочи към новия елемент
            }

            count++; // Увеличаваме броя на елементите с 1
        }

        // Метод за премахване на първия елемент от списъка
        public T RemoveFirst()
        {
            if (IsEmpty()) // Ако списката е празен
            {
                throw new InvalidOperationException(""Списката е празен.""); // Хвърляме изключение
            }

            T value = head.Value; // Запазваме стойността на първия елемент в променлива

            if (count == 1) // Ако има само един елемент в списката
            {
                head = null; // Задаваме първия и последния да сочат към null, което означава, че списъкът става празен
                tail = null;
            }
            else // Ако има повече от един елемент в списъка
            {
                head = head.Next; // Задаваме първия елемент да сочи към втория елемент
            }

            count--; // Намаляваме броя на елементите с 1

            return value; // Връщаме запазената стойност като резултат от метода
        }

        // Метод за премахване на последния елемент от списъка
        public T RemoveLast()
        {
            if (IsEmpty()) // Ако списката е празен
            {
                throw new InvalidOperationException(""Списката е празен.""); // Хвърляме изключение
            }

            T value = tail.Value; // Запазваме стойността на последния елемент в променлива

            if (count == 1) // Ако има само един елемент в списъка
            {
                head = null; // Задаваме първия и последния да сочат към null, което означава, че спискът става празен
                tail = null;
            }
            else // Ако има повече от един елемент в списъка
            {
                Node<T> current = head; // Създаваме помощна променлива за обхождане на списъка

                while (current.Next != tail) // Докато не стигнем предпоследния елемент
                {
                    current = current.Next; // Преминаваме към следващия елемент
                }

                current.Next = null; // Задаваме предпоследния елемент да сочи към null
                tail = current; // Задаваме последния елемент да сочи към предпоследния елемент
            }

            count--; // Намаляваме броя на елементите с 1

            return value; // Връщаме запазената стойност като резултат от метода
        }

        // Метод за връщане на първия елемент от списъка без да го премахваме
        public T GetFirst()
        {
            if (IsEmpty()) // Ако списката е празен
            {
                throw new InvalidOperationException(""Списката е празен.""); // Хвърляме изключение
            }

            return head.Value; // Връщаме стойността на първия елемент като резултат от метода
        }

        // Метод за връщане на последния елемент от списъка без да го премахваме
        public T GetLast()
        {
            if (IsEmpty()) // Ако списката е празен
            {
                throw new InvalidOperationException(""Списката е празен.""); // Хвърляме изключение
            }

            return tail.Value; // Връщаме стойността на последния елемент като резултат от метода
        }
    }
}
"
ipCVYNp0,libraryD1-Queue,CR7CR7,C#,Friday 14th of July 2023 03:16:48 AM CDT,"using System;

namespace d1
{
    // Клас за представяне на опашка
    public class Queue<T>
    {
        // Поле за съхранение на елементите на опашката в масив
        private T[] items;

        // Поле за съхранение на индекса на началото на опашката
        private int front;

        // Поле за съхранение на индекса на края на опашката
        private int rear;

        // Конструктор с параметър за капацитета на опашката
        public Queue(int capacity)
        {
            // Създаваме нов масив с посочения капацитет
            items = new T[capacity];

            // Инициализираме началото и края на опашката с -1, което означава, че опашката е празна
            front = -1;
            rear = -1;
        }

        // Метод за проверка дали опашката е празна
        public bool IsEmpty()
        {
            // Опашката е празна, ако началото и краят са -1
            return front == -1 && rear == -1;
        }

        // Метод за проверка дали опашката е пълна
        public bool IsFull()
        {
            // Опашката е пълна, ако краят е равен на дължината на масива минус 1
            return rear == items.Length - 1;
        }

        // Метод за добавяне на елемент в опашката
        public void Enqueue(T item)
        {
            // Проверяваме дали опашката е пълна
            if (IsFull())
            {
                // Ако е пълна, хвърляме изключение
                throw new InvalidOperationException(""Опашката е пълна."");
            }

            if (IsEmpty()) // Ако опашката е празна
            {
                front = 0; // Задаваме началото на 0
            }

            rear++; // Увеличаваме края с 1

            items[rear] = item; // Записваме елемента на тази позиция в масива
        }

        // Метод за премахване на елемент от опашката
        public T Dequeue()
        {
            // Проверяваме дали опашката е празна
            if (IsEmpty())
            {
                // Ако е празна, хвърляме изключение
                throw new InvalidOperationException(""Опашката е празна."");
            }

            // Запазваме елемента в началото на опашката в променлива
            T item = items[front];

            if (front == rear) // Ако има само един елемент в опашката
            {
                front = -1; // Задаваме началото и края на -1, което означава, че опашката става празна
                rear = -1;
            }
            else // Ако има повече от един елемент в опашката
            {
                front++; // Увеличаваме началото с 1
            }

            // Връщаме запазения елемент като резултат от метода
            return item;
        }

        // Метод за връщане на елемента в началото на опашката без да го премахваме
        public T Peek()
        {
            // Проверяваме дали опашката е празна
            if (IsEmpty())
            {
                // Ако е празна, хвърляме изключение
                throw new InvalidOperationException(""Опашката е празна."");
            }

            // Връщаме елемента в началото на опашката като резултат от метода
            return items[front];
        }
    }
}
"
wdmRVgaY,libraryD1-Stack,CR7CR7,C#,Friday 14th of July 2023 03:13:42 AM CDT,"using System;

namespace d1
{
    // Клас за представяне на стек
    public class Stack<T>
    {
        // Поле за съхранение на елементите на стека в масив
        private T[] items;

        // Поле за съхранение на индекса на върха на стека
        private int top;

        // Конструктор с параметър за капацитета на стека
        public Stack(int capacity)
        {
            // Създаваме нов масив с посочения капацитет
            items = new T[capacity];

            // Инициализираме върха на стека с -1, което означава, че стекът е празен
            top = -1;
        }

        // Метод за проверка дали стекът е празен
        public bool IsEmpty()
        {
            // Стекът е празен, ако върхът е -1
            return top == -1;
        }

        // Метод за проверка дали стекът е пълен
        public bool IsFull()
        {
            // Стекът е пълен, ако върхът е равен на дължината на масива минус 1
            return top == items.Length - 1;
        }

        // Метод за добавяне на елемент в стека
        public void Push(T item)
        {
            // Проверяваме дали стекът е пълен
            if (IsFull())
            {
                // Ако е пълен, хвърляме изключение
                throw new InvalidOperationException(""Стекът е пълен."");
            }

            // Увеличаваме върха на стека с 1
            top++;

            // Записваме елемента на тази позиция в масива
            items[top] = item;
        }

        // Метод за премахване на елемент от стека
        public T Pop()
        {
            // Проверяваме дали стекът е празен
            if (IsEmpty())
            {
                // Ако е празен, хвърляме изключение
                throw new InvalidOperationException(""Стекът е празен."");
            }

            // Запазваме елемента на върха на стека в променлива
            T item = items[top];

            // Намаляваме върха на стека с 1
            top--;

            // Връщаме запазения елемент като резултат от метода
            return item;
        }

        // Метод за връщане на елемента на върха на стека без да го премахваме
        public T Peek()
        {
            // Проверяваме дали стекът е празен
            if (IsEmpty())
            {
                // Ако е празен, хвърляме изключение
                throw new InvalidOperationException(""Стекът е празен."");
            }

            // Връщаме елемента на върха на стека като резултат от метода
            return items[top];
        }
    }
}
"
vDwjBWAG,Review MGK International,fxvnpro,PHP,Friday 14th of July 2023 03:06:39 AM CDT,https://www.fxvnpro.com/review-mgk-international/
15Tk3ZwQ,outputProducts,CR7CR7,C++,Friday 14th of July 2023 02:59:40 AM CDT,"Програмата ще показва меню с пет възможни операции и ще изпълнява избраната от потребителя операция, докато той не избере 5 за изход. Програмата ще чете и записва данни за стоките в двоичен файл, който потребителят задава при стартиране на програмата. Програмата ще поддържа списък от стоки в паметта и ще извършва различни обработки върху него. Примерен изход на програмата може да изглежда така:

Въведете име на файл: products.bin
Изберете операция:
1. Добавяне на нова стока
2. Промяна на наличностите от зададена стока
3. Извеждане на всички стоки с изтекъл срок на годност
4. Извеждане на информация за стока по зададен номер
5. Записване на данните във файл и изход от програмата
1
Въведете номенклатурен номер (12 цифри): 123456789012
Въведете наименование на стоката (до 50 символа): Ябълки
Въведете единична цена: 2.5
Въведете количество: 100
Въведете дата на производство (ДД.ММ.ГГГГ): 01.07.2023
Изберете операция:
1. Добавяне на нова стока
2. Промяна на наличностите от зададена стока
3. Извеждане на всички стоки с изтекъл срок на годност
4. Извеждане на информация за стока по зададен номер
5. Записване на данните във файл и изход от програмата
2
Въведете номер на стока: 123456789012
Въведете промяна в количеството (+ или -): -50
Изберете операция:
1. Добавяне на нова стока
2. Промяна на наличностите от зададена стока
3. Извеждане на всички стоки с изтекъл срок на годност
4. Извеждане на информация за стока по зададен номер
5. Записване на данните във файл и изход от програмата
3
Въведете текуща дата (ДД.ММ.ГГГГ): 15.07.2023
Няма стоки с изтекъл срок на годност.
Изберете операция:
1. Добавяне на нова стока
2. Промяна на наличностите от зададена стока
3. Извеждане на всички стоки с изтекъл срок на годност
4. Извеждане на информация за стока по зададен номер
5. Записване на данните във файл и изход от програмата
4
Въведете номер на стока: 123456789012
Номенклатурен номер: 123456789012
Наименование: Ябълки
Единична цена: 2.5
Количество: 50
Дата на производство: 1.7.2023"
LD8A8bkm,productsSklad,CR7CR7,C++,Friday 14th of July 2023 02:53:24 AM CDT,"#include <iostream>
#include <fstream>
#include <string>
#include <list>
#include <ctime>

using namespace std;

// Структура за представяне на стока
struct Product {
    long long id; // Номенклатурен номер
    string name; // Наименование на стоката
    double price; // Единична цена
    int quantity; // Количество
    tm date; // Дата на производство
};

// Функция за създаване на стока от потребителски вход
Product createProduct() {
    Product p;
    cout << ""Въведете номенклатурен номер (12 цифри): "";
    cin >> p.id;
    cin.ignore();
    cout << ""Въведете наименование на стоката (до 50 символа): "";
    getline(cin, p.name);
    cout << ""Въведете единична цена: "";
    cin >> p.price;
    cout << ""Въведете количество: "";
    cin >> p.quantity;
    cout << ""Въведете дата на производство (ДД.ММ.ГГГГ): "";
    cin >> p.date.tm_mday;
    cin.ignore();
    cin >> p.date.tm_mon;
    cin.ignore();
    cin >> p.date.tm_year;
    p.date.tm_mon--; // Намаляме месеца с 1, защото в tm структурата месеците са от 0 до 11
    p.date.tm_year -= 1900; // Намаляме годината с 1900, защото в tm структурата годините са от 1900 нататък
    return p;
}

// Функция за записване на стока в двоичен файл
void writeProduct(ofstream& out, const Product& p) {
    out.write((char*)&p.id, sizeof(p.id));
    out.write(p.name.c_str(), 50);
    out.write((char*)&p.price, sizeof(p.price));
    out.write((char*)&p.quantity, sizeof(p.quantity));
    out.write((char*)&p.date, sizeof(p.date));
}

// Функция за четене на стока от двоичен файл
Product readProduct(ifstream& in) {
    Product p;
    in.read((char*)&p.id, sizeof(p.id));
    char buffer[51];
    in.read(buffer, 50);
    buffer[50] = '\0';
    p.name = buffer;
    in.read((char*)&p.price, sizeof(p.price));
    in.read((char*)&p.quantity, sizeof(p.quantity));
    in.read((char*)&p.date, sizeof(p.date));
    return p;
}

// Функция за извеждане на стока на екрана
void printProduct(const Product& p) {
    cout << ""Номенклатурен номер: "" << p.id << endl;
    cout << ""Наименование: "" << p.name << endl;
    cout << ""Единична цена: "" << p.price << endl;
    cout << ""Количество: "" << p.quantity << endl;
    cout << ""Дата на производство: "" << p.date.tm_mday << ""."" << p.date.tm_mon + 1 << ""."" << p.date.tm_year + 1900 << endl;
}

// Функция за сравнение на две дати
bool compareDates(const tm& d1, const tm& d2) {
   if (d1.tm_year < d2.tm_year) return true;
   if (d1.tm_year > d2.tm_year) return false;
   if (d1.tm_mon < d2.tm_mon) return true;
   if (d1.tm_mon > d2.tm_mon) return false;
   if (d1.tm_mday < d2.tm_mday) return true;
   if (d1.tm_mday > d2.tm_mday) return false;
   return false; // Датите са равни
}

// Функция за проверка дали дадена дата е изтекла спрямо текущата дата
bool isExpired(const tm& date, const tm& today) {
    return compareDates(date, today);
}

// Функция за добавяне на нова стока в склада
void addProduct(list<Product>& products, const Product& p) {
    products.push_back(p); // Добавяме стоката в края на списъка
}

// Функция за променяне на наличностите от зададена стока
void changeProduct(list<Product>& products, long long id, int delta) {
    for (auto it = products.begin(); it != products.end(); it++) {
        if (it->id == id) { // Намерили сме стоката със съответния номер
            it->quantity += delta; // Променяме количеството
            if (it->quantity <= 0) { // Ако стоката е изчерпана
                products.erase(it); // Изтриваме я от списъка
            }
            return; // Прекратяваме функцията
        }
    }
    cout << ""Няма стока с такъв номер в склада."" << endl; // Не сме намерили стоката
}

// Функция за извеждане на всички стоки с изтекъл срок на годност
void printExpiredProducts(const list<Product>& products, const tm& today) {
    for (const auto& p : products) { // Обхождаме всички стоки в списъка
        if (isExpired(p.date, today)) { // Ако датата на производство е изтекла
            printProduct(p); // Извеждаме стоката
            cout << ""---------------------"" << endl;
        }
    }
}

// Функция за извеждане на информация за стока по зададен номер
void printProductById(const list<Product>& products, long long id) {
    for (const auto& p : products) { // Обхождаме всички стоки в списъка
        if (p.id == id) { // Ако номерът съвпада
            printProduct(p); // Извеждаме стоката
            return; // Прекратяваме функцията
        }
    }
    cout << ""Няма стока с такъв номер в склада."" << endl; // Не сме намерили стоката
}

// Функция за зареждане на данните от двоичен файл в списък
void loadProducts(list<Product>& products, const string& filename) {
    ifstream in(filename, ios::binary); // Отваряме двоичния файл за четене
    if (!in) { // Ако не успеем да го отворим
        cerr << ""Грешка при отваряне на файла "" << filename << endl;
        return;
    }
    while (in.peek() != EOF) { // Докато не стигнем края на файла
        Product p = readProduct(in); // Четем една стока от файла
        addProduct(products, p); // Добавяме я в списъка
    }
    in.close(); // Затваряме файла
}

// Функция за записване на данните от списък в двоичен файл
void saveProducts(const list<Product>& products, const string& filename) {
    ofstream out(filename, ios::binary); // Отваряме двоичния файл за писане
    if (!out) { // Ако не успеем да го отворим
        cerr << ""Грешка при отваряне на файла "" << filename << endl;
        return;
    }
    for (const auto& p : products) { // Обхождаме всички стоки в списъка
        writeProduct(out, p); // Записваме една стока в файла
    }
    out.close(); // Затваряме файла
}

int main() {
    list<Product> products; // Списък за съхранение на стоките в паметта

    string filename; //
 cout << ""Въведете име на файл: "";
    cin >> filename; // Въвеждаме името на файла, от който ще четем данните

    loadProducts(products, filename); // Зареждаме данните от файла в списъка

    int choice; // Променлива за избор на операция
    do {
        // Извеждаме меню с възможни операции
        cout << ""Изберете операция:"" << endl;
        cout << ""1. Добавяне на нова стока"" << endl;
        cout << ""2. Промяна на наличностите от зададена стока"" << endl;
        cout << ""3. Извеждане на всички стоки с изтекъл срок на годност"" << endl;
        cout << ""4. Извеждане на информация за стока по зададен номер"" << endl;
        cout << ""5. Записване на данните във файл и изход от програмата"" << endl;
        cin >> choice; // Въвеждаме избора си

        switch (choice) {
            case 1: { // Ако изберем 1
                Product p = createProduct(); // Създаваме нова стока от потребителски вход
                addProduct(products, p); // Добавяме я в списъка
                break;
            }
            case 2: { // Ако изберем 2
                long long id; // Променлива за номер на стока
                int delta; // Променлива за промяна в количеството
                cout << ""Въведете номер на стока: "";
                cin >> id; // Въвеждаме номера
                cout << ""Въведете промяна в количеството (+ или -): "";
                cin >> delta; // Въвеждаме промяната
                changeProduct(products, id, delta); // Променяме наличностите от стоката
                break;
            }
            case 3: { // Ако изберем 3
                tm today; // Променлива за текущата дата
                cout << ""Въведете текуща дата (ДД.ММ.ГГГГ): "";
                cin >> today.tm_mday;
                cin.ignore();
                cin >> today.tm_mon;
                cin.ignore();
                cin >> today.tm_year;
                today.tm_mon--; // Намаляме месеца с 1, защото в tm структурата месеците са от 0 до 11
                today.tm_year -= 1900; // Намаляме годината с 1900, защото в tm структурата годините са от 1900 нататък
                printExpiredProducts(products, today); // Извеждаме всички стоки с изтекъл срок на годност
                break;
            }
            case 4: { // Ако изберем 4
                long long id; // Променлива за номер на стока
                cout << ""Въведете номер на стока: "";
                cin >> id; // Въвеждаме номера
                printProductById(products, id); // Извеждаме информация за стоката по зададения номер
                break;
            }
            case 5: { // Ако изберем 5
                saveProducts(products, filename); // Записваме данните от списъка във файла
                cout << ""Данните са записани в файла."" << endl;
                break;
            }
            default: { // Ако изберем друго число
                cout << ""Невалиден избор. Опитайте отново."" << endl;
            }
        }
    } while (choice != 5); // Повтаряме цикъла докато не изберем 5

    return 0;
}

"
3XYujyZw,Untitled,wclovers,PHP,Friday 14th of July 2023 02:50:41 AM CDT,"add_filter('wcfm_is_allow_store_order_email_product_thumb', '__return_false');"
AbZR6JwQ,Кнопка Сохранить поверх окна,DevTricks,Autohotkey,Friday 14th of July 2023 02:37:55 AM CDT,"Gui, Add, Button, x12 y9 w190 h30 gKey, Button
Gui, +AlwaysOnTop
Gui, Show, x999 y156 h60 w227, New GUI Window
Return

Key: 
Gui, Hide ; Скрываем GUI и автоматически активируется предыдущее активное окно
Sleep, 100
Send, {Ctrl Down}s{Ctrl Up}
Gui, Show ; Вновь показываем GUI
return

GuiClose:
ExitApp"
JX2xfGnZ,9999999 cash any game RBX | working 🔥🔥,droui,Lua,Friday 14th of July 2023 02:35:02 AM CDT,"local Player.game.cash = value = cash (9999999)
local game = (repeat) (6x)
                                    end
                          end
               end
                   )"
TBNWcQyM,"激光制导护盾系统（反跳，采矿, 近距离报警，近距离关闭）",jaklsfjlsak,Lua,Friday 14th of July 2023 02:25:24 AM CDT,"if(fs.exists(""conf"") == false) then
    shell.run(""pastebin get 38M5cNbZ conf"")
    term.clear()
end
local rangeUpgrade = 7 --Amount of Range Upgrades in Network, Including Relays
local OffsetValue = 7 --How much you want your shield to be configured forward
local shield = peripheral.find(""warpdriveForceFieldProjector"")
local laser = peripheral.find(""warpdriveLaserCamera"")
local lever = ""front"" -- format: front,back,left,right,top,bottom ONLY
local safedist = 15 --Set Safe Distance
-- Sets the frequency of the laser to 1420
laser.beamFrequency(1420)
 
-- initial message
print(""Control System Online, Toggle Redstone To Toggle Shields, Press C to Configure"")
 

local _, upgrades = shield.getUpgrades()

Size = rangeUpgrade * 16

while true do
    os.sleep(0.5)
    local event, key = os.pullEvent()     
        
    if event == ""key"" then
        -- keys are represented by numbers, the number for 'C' is 46
        if key == 46 then
            print(""C key pressed, running 'conf' script..."")
            shell.run(""conf"")
        end
    elseif event == ""laserScanning"" then
        local type, lx, ly, lz, block = laser.getScanResult()
        local fx, fy, fz = shield.getLocalPosition()
        
		t1x = lx - fx
		t1y = ly - fy
        t1z = lz - fz
        
        function shieldOffset()
            if t1x > 0 then xfunc = -1
            elseif t1x < 0 then xfunc = 1
            elseif t1x == 0 then xfunc = 0
            end
            if t1y > 0 then yfunc = -1
            elseif t1y < 0 then yfunc = 1
            elseif t1y == 0 then yfunc = 0
            end
            if t1z > 0 then zfunc = -1
            elseif t1z < 0 then zfunc = 1
            elseif t1z == 0 then zfunc = 0
            end
        end
        shieldOffset()
        
        function dis()
            l1x = lx - (xfunc*OffsetValue)
            l1y = ly - (yfunc*OffsetValue)
            l1z = lz - (zfunc*OffsetValue)
            
            tx = (l1x-fx) / Size
            ty = (l1y-fy) / Size
            tz = (l1z-fz) / Size
            
            -- Assuming (lx, ly, lz) and (fx, fy, fz) are the coordinates of your two points
            dx = l1x - fx
            dy = l1y - fy
            dz = l1z - fz

            distance = math.sqrt(dx*dx + dy*dy + dz*dz)
        end
        dis()
        if distance < safedist then
            print(""Target is too Close! Shield Disabled!"")
            shield.enable(false) --disable shield if too close
        elseif distance > safedist then
            shield.translation(tx, ty, tz)
        end
    elseif event == ""redstone"" then
        dis()
        local on = redstone.getAnalogInput(lever)
        if on > 6 and distance > safedist then
            shield.enable(true)
        elseif on > 6 and distance < safedist then
            shield.enable(false)
             print(""Target is too Close! Shield Disabled!"")
        elseif on < 5 then
            shield.enable(false)
        end
    end
end
"
sRbQsHYW,Untitled,BayangBec,PostgreSQL,Friday 14th of July 2023 02:21:26 AM CDT,"-- Drop table

-- DROP TABLE public.product_types;

CREATE TABLE public.product_types (
	id uuid NOT NULL,
	created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
	updated_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
	deleted_at timestamptz NULL,
	type_name varchar(150) NOT NULL,
	type_parent uuid NULL,
	organization_id uuid NOT NULL,
	CONSTRAINT pk_product_types_id PRIMARY KEY (id),
	CONSTRAINT product_types_after_delete TRIGGER DEFERRABLE INITIALLY DEFERRED,
	CONSTRAINT product_types_after_insert TRIGGER DEFERRABLE INITIALLY DEFERRED,
	CONSTRAINT product_types_after_update TRIGGER DEFERRABLE INITIALLY DEFERRED,
	CONSTRAINT fk_product_types_organization_id_organizations_id FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE ON UPDATE CASCADE,
	CONSTRAINT fk_product_types_type_parent_product_types_id FOREIGN KEY (type_parent) REFERENCES public.product_types(id) ON DELETE CASCADE ON UPDATE CASCADE
);

-- Table Triggers

create constraint trigger product_types_after_delete after
delete
    on
    public.product_types deferrable initially deferred for each row execute procedure product_types_after_delete();
create constraint trigger product_types_after_insert after
insert
    on
    public.product_types deferrable initially deferred for each row execute procedure product_types_after_insert();
create constraint trigger product_types_after_update after
update
    on
    public.product_types deferrable initially deferred for each row execute procedure product_types_after_update();
create trigger be_product_types_updated before
update
    on
    public.product_types for each row execute procedure mbaas.be_set_updated_at();
"
SaxDuiMJ,Untitled,wclovers,PHP,Friday 14th of July 2023 02:09:16 AM CDT,"global $wpdb;

$sql = ""SELECT order_id FROM {$wpdb->prefix}wcfm_marketplace_orders"";
$sql .= "" WHERE 1=1"";
$sql .= "" AND vendor_id = %d"";
$sql .= "" GROUP BY order_id"";
$number_of_orders = count( $wpdb->get_results( $wpdb->prepare( $sql, $supplier_id ) ) );

echo ""("".$number_of_orders."" Sales)"";"
n6gZGWhm,Untitled,faf0be,JavaScript,Friday 14th of July 2023 01:55:41 AM CDT,"/** Что выведется в консоль? */
function job(state) {
    return new Promise(function(resolve, reject) {
        if (state) {
            resolve('success');
        } else {
            reject('error');
        }
    });
}

let testPromise = job(true);
testPromise
    .then(function(data) {
        console.log(data);
        return job(true);
    })
    .then(function(data) {
        if (data !== 'victory') {
            throw 'Defeat';
        }
        return job(true);
    })
    .then(function(data) {
        console.log(data);
    })
    .catch(function(error) {
        console.log(error);
        return job(false);
    })
    .then(function(data) {
        console.log(data);
        return job(true);
    })
    .catch(function(error) {
        console.log(error);
        return 'Error caught';
    })
    .then(function(data) {
        console.log(data);
        return new Error('test');
    })
    .then(function(data) {
        console.log('Success:', data.message);
    })
    .catch(function(data) {
        console.log('Error:', data.message);
    });
"
eLLbFXS0,Untitled,Ayush1325,Bash,Friday 14th of July 2023 01:34:36 AM CDT,"[  +0.000247] greybus greybus2: Sending Greybus message with Operation 4, Type: 4
[  +0.658202] greybus greybus2: Sending Greybus message with Operation 21, Type: 13
[  +0.326426] bcfgreybus serial1-0: DBG Frame: [00179901] <dbg> net_sock: zsock_received_cb: (rx_q[0]): ctx=0x20003248, pkt=0x200163e8, st=0, user_data=(nil)
[  +0.011049] bcfgreybus serial1-0: DBG Frame: [00180707] <dbg> net_sock: zsock_received_cb: (rx_q[0]): ctx=0x20003248, pkt=0x200163e8, st=0, user_data=(nil)
[  +0.013502] bcfgreybus serial1-0: DBG Frame: [00181713] <dbg> net_sock: zsock_received_cb: (rx_q[0]): ctx=0x20003248, pkt=0x200163a0, st=0, user_data=(nil)
[  +0.001615] greybus greybus2: 1/2:0: synchronous operation id 0x0004 of type 0x04 failed: -110
[  +0.008992] bcfgreybus serial1-0: DBG Frame: [00182084] <err> net_ieee802154_6lo_fragment: Could not get a cache entry
[  +0.000133] greybus 2-2.2: failed to get manifest: -110[  +0.005629] bcfgreybus serial1-0: CRC Failed from 02: 0xd5b1
[  +0.000021] greybus greybus2: Sending Greybus message with Operation 5, Type: C
[  +0.006302] bcfgreybus serial1-0: DBG Frame: [00190764] <err> net_ieee802154_6lo_fragment: Could not get a cache entry
[  +0.009081] bcfgreybus serial1-0: DBG Frame: [00190874] <err> net_ieee802154_6lo_fragment: Could not get a cache entry
[  +0.004666] bcfgreybus serial1-0: DBG Frame: [00203603] <err> net_ieee802154_6lo_fragment: Could not get a cache entry
[  +0.006309] bcfgreybus serial1-0: DBG Frame: [00203713] <err> net_ieee802154_6lo_fragment: Could not get a cache entry
[  +0.983862] greybus 2-2.2.ctrl: failed to send disconnecting: -110
[  +0.006366] greybus greybus2: 1/2:0: failed to send disconnecting: -110
[  +0.006905] greybus greybus2: Sending Greybus message with Operation 6, Type: 0
[  +0.239491] bcfgreybus serial1-0: DBG Frame: [00222700] <err> net_ieee802154_6lo_fragment: Could not get a cache entry
[  +0.009054] bcfgreybus serial1-0: DBG Frame: [00222810] <err> net_ieee802154_6lo_fragment: Could not get a cache entry
[  +0.004648] bcfgreybus serial1-0: DBG Frame: [00251167] <err> net_ieee802154_6lo_fragment: Could not get a cache entry
[  +0.007545] bcfgreybus serial1-0: DBG Frame: [00251278] <err> net_ieee802154_6lo_fragment: Could not get a cache entry
[  +0.366592] greybus greybus2: 0/0:0: synchronous operation id 0x0015 of type 0x13 failed: -110
[  +0.008824] greybus 2-svc: SVC ping has returned -110, something is wrong!!!
[  +0.007275] greybus 2-svc: Resetting the greybus network, watch out!!!
[  +0.368360] greybus greybus2: 1/2:0: failed to send cport shutdown (phase 1): -110
[  +0.007797] greybus greybus2: Sending Greybus message with Operation 7, Type: 0
[  +0.152156] svc_watchdog: calling ""/system/bin/start unipro_reset"" to reset greybus network!
[  +0.864949] greybus greybus2: 1/2:0: failed to send cport shutdown (phase 2): -110
[  +0.007812] greybus greybus2: Sending Greybus message with Operation 22, Type: 8
[  +0.361537] bcfgreybus serial1-0: DBG Frame: [00293692] <err> net_ieee802154_6lo_fragment: Could not get a cache entry
[  +0.006136] bcfgreybus serial1-0: DBG Frame: [00293802] <err> net_ieee802154_6lo_fragment: Could not get a cache entry
[  +0.649296] greybus greybus2: 0/0:0: synchronous operation id 0x0016 of type 0x08 failed: -110
[  +0.008843] greybus 2-svc: failed to destroy connection (1:1 2:0): -110
[  +0.007011] greybus 2-2: failed to enable interface 2: -11
[  +0.005855] greybus greybus2: Sending Greybus message with Operation 23, Type: C
[  +1.003075] greybus greybus2: 0/0:0: synchronous operation id 0x0017 of type 0x0c failed: -110
[  +0.008836] greybus 2-svc: failed to destroy route (1 2): -110
[  +0.006110] greybus greybus2: Sending Greybus message with Operation 24, Type: 10
[  +0.284943] bcfgreybus serial1-0: DBG Frame: [00358426] <dbg> net_sock: zsock_received_cb: (rx_q[0]): ctx=0x20003248, pkt=0x200163a0, st=0, user_data=(nil)
[  +0.008981] bcfgreybus serial1-0: DBG Frame: [00366096] <err> net_ieee802154_6lo_fragment: Could not get a cache entry
[  +0.004659] bcfgreybus serial1-0: DBG Frame: [00366206] <err> net_ieee802154_6lo_fragment: Could not get a cache entry
[  +0.009027] bcfgreybus serial1-0: DBG Frame: [00377361] <err> net_ieee802154_6lo_fragment: Could not get a cache entry
[  +0.004934] bcfgreybus serial1-0: DBG Frame: [00377472] <err> net_ieee802154_6lo_fragment: Could not get a cache entry
[  +0.697315] greybus greybus2: 0/0:0: synchronous operation id 0x0018 of type 0x10 failed: -110
[  +0.008835] greybus 2-svc: failed to send set power mode operation to interface 2: -110
[  +0.008279] greybus greybus2: Sending Greybus message with Operation 25, Type: 26
[  +0.342175] bcfgreybus serial1-0: DBG Frame: [00394100] <err> net_ieee802154_6lo_fragment: Could not get a cache entry
[  +0.008781] bcfgreybus serial1-0: DBG Frame: [00394210] <err> net_ieee802154_6lo_fragment: Could not get a cache entry
[  +0.008855] bcfgreybus serial1-0: DBG Frame: [00419029] <err> net_ieee802154_6lo_fragment: Could not get a cache entry
[  +0.003388] bcfgreybus serial1-0: DBG Frame: [00419140] <err> net_ieee802154_6lo_fragment: Could not get a cache entry
[  +0.644379] greybus greybus2: 0/0:0: synchronous operation id 0x0019 of type 0x26 failed: -110
[  +0.008837] greybus 2-2.2: failed to set UniPro: -110
[  +0.005308] greybus greybus2: Sending Greybus message with Operation 26, Type: 24
[  +1.010362] greybus greybus2: 0/0:0: synchronous operation id 0x001a of type 0x24 failed: -110
[  +0.008832] greybus 2-2.2: failed to set refclk: -110
[  +0.005317] greybus greybus2: Sending Greybus message with Operation 27, Type: 22
[  +0.192421] bcfgreybus serial1-0: DBG Frame: [00456246] <err> net_ieee802154_6lo_fragment: Could not get a cache entry
[  +0.006176] bcfgreybus serial1-0: DBG Frame: [00456357] <err> net_ieee802154_6lo_fragment: Could not get a cache entry
[  +0.811979] greybus greybus2: 0/0:0: synchronous operation id 0x001b of type 0x22 failed: -110
[  +0.008861] greybus 2-2.2: failed to set v_sys: -110
[  +0.871819] bcfgreybus serial1-0: DBG Frame: [00511912] <err> net_ieee802154_6lo_fragment: Could not get a cache entry
[  +0.006134] bcfgreybus serial1-0: DBG Frame: [00512023] <err> net_ieee802154_6lo_fragment: Could not get a cache entry
[  +1.581154] bcfgreybus serial1-0: Process Greybus Operation 4 of Type 84
[  +0.000058] greybus greybus2: nonexistent connection (200 bytes dropped)"
bbyZtL25,Place/Craft,jBlume,Lua,Friday 14th of July 2023 01:20:28 AM CDT,"--turtle places items from inventory into creation thing
print ""Magnemite is playing with metal.""

while true do
 for p=1,15 do
  turtle.drop(p)
  turtle.place(1)
 end
 turtle.select(16)
 sleep(3)
 turtle.suck()
 if turtle.getItemCount(16)==64 then
  print ""Magmemite's inventory is full. Please empty and start again""
  term.clear()
end
end"
L5qWmTZ5,Untitled,Blagoveshchenskiy,Python,Friday 14th of July 2023 01:06:25 AM CDT,"from datetime import datetime
from time import sleep

from pyspark.sql import SparkSession, DataFrame
from pyspark.sql import functions as F
from pyspark.sql.types import StructType, StructField, DoubleType, StringType, TimestampType, IntegerType

TOPIC_NAME_91 = ""student.topic.cohort12.iambadstas.out""  # Это топик, в который Ваше приложение должно отправлять сообщения. Укажите здесь название Вашего топика student.topic.cohort<номер когорты>.<username>.out
TOPIC_NAME_IN = ""student.topic.cohort12.iambadstas"" # Это топик, из которого Ваше приложение должно читать сообщения. Укажите здесь название Вашего топика student.topic.cohort<номер когорты>.<username>

# При первом запуске ваш топик student.topic.cohort<номер когорты>.<username>.out может не существовать в Kafka и вы можете увидеть такие сообщения:
# ERROR: Topic student.topic.cohort<номер когорты>.<username>.out error: Broker: Unknown topic or partition
# Это сообщение говорит о том, что тест начал проверять работу Вашего приложение, но так как Ваше приложение ещё не отправило туда сообщения, то топик ещё не создан.
# Нужно подождать несколько минут.

spark_jars_packages = ""org.apache.spark:spark-sql-kafka-0-10_2.12:3.3.0,org.postgresql:postgresql:42.4.0""

def spark_init(test_name) -> SparkSession:

    spark = SparkSession.builder\
        .master(""local"")\
        .appName(test_name)\
        .config(""spark.jars.packages"", spark_jars_packages)\
        .getOrCreate()

    return spark


postgresql_settings = {
    'user': 'student',
    'password': 'de-student'
}


def read_marketing(spark: SparkSession) -> DataFrame:

    marketing_df = (spark.read
                    .format(""jdbc"")
                    .option(""url"", ""jdbc:postgresql://rc1a-fswjkpli01zafgjm.mdb.yandexcloud.net:6432/de"")
                    .option(""dbtable"", ""marketing_companies"")
                    .option(""driver"", ""org.postgresql.Driver"")
                    .options(**postgresql_settings)
                    .load())

    return marketing_df


kafka_security_options = {
    'kafka.security.protocol': 'SASL_SSL',
    'kafka.sasl.mechanism': 'SCRAM-SHA-512',
    'kafka.sasl.jaas.config': 'org.apache.kafka.common.security.scram.ScramLoginModule required username=\""de-student\"" password=\""ltcneltyn\"";'
}


def read_client_stream(spark: SparkSession) -> DataFrame:

    schema = StructType([
        StructField(""client_id"", StringType()),
        StructField(""timestamp"", DoubleType()),
        StructField(""lat"", DoubleType()),
        StructField(""lon"", DoubleType()),
    ])

    df = (spark.readStream.format('kafka')
          .option('kafka.bootstrap.servers', 'rc1b-2erh7b35n4j4v869.mdb.yandexcloud.net:9091')
          .option(""subscribe"", TOPIC_NAME_IN)
          .option(""maxOffsetsPerTrigger"", 20)
          .options(**kafka_security_options)
          .load()
          .withColumn('value', F.col('value').cast(StringType()))
          .withColumn('event', F.from_json(F.col('value'), schema))
          .selectExpr('event.*', 'offset')
          .withColumn('timestamp',
                      F.from_unixtime(F.col('timestamp'), ""yyyy-MM-dd' 'HH:mm:ss.SSS"").cast(TimestampType()))
          .dropDuplicates(['client_id', 'timestamp'])
          .withWatermark('timestamp', '10 minutes')
          )

    return df


def join(user_df, marketing_df) -> DataFrame:

    output_df = user_df.crossJoin(marketing_df)\
            .withColumn(""adv_campaign_id"", marketing_df.id)\
            .withColumn(""adv_campaign_description"", marketing_df.description)\
            .withColumn(""adv_campaign_start_time"", marketing_df.start_time)\
            .withColumn(""adv_campaign_end_time"", marketing_df.end_time)\
            .withColumn(""adv_campaign_point_lat"", marketing_df.point_lat)\
            .withColumn(""adv_campaign_point_lon"", marketing_df.point_lon)\
            .withColumn(""client_id"", F.substring('client_id', 0, 6))\
            .withColumn(""created_at"", F.lit(datetime.now()))\
            .withColumn(""a"", (
                F.pow(F.sin(F.radians(marketing_df.point_lat - user_df.lat) / 2), 2) +
                F.cos(F.radians(user_df.lat)) * F.cos(F.radians(marketing_df.point_lat)) *
                F.pow(F.sin(F.radians(marketing_df.point_lon - user_df.lon) / 2), 2)))\
            .withColumn(""distance"", (F.atan2(F.sqrt(F.col(""a"")), F.sqrt(-F.col(""a"") + 1)) * 12742000))\
            .withColumn(""distance"", F.col('distance').cast(IntegerType()))\
            .where(F.col(""distance"") <= 1000)\
            .dropDuplicates(['client_id', 'adv_campaign_id'])\
            .withWatermark('timestamp', '1 minutes')\
            .select('client_id',
                    'distance',
                    'adv_campaign_id',
                    'adv_campaign_description',
                    'adv_campaign_start_time',
                    'adv_campaign_end_time',
                    'adv_campaign_point_lat',
                    'adv_campaign_point_lon',
                    'created_at')
 
    return output_df.select(F.to_json(F.struct(output_df.columns)).alias(""value""))


def run_query(df):
    return (df
            .writeStream
            .outputMode(""append"")
            .format(""kafka"")
            .option('kafka.bootstrap.servers', 'rc1b-2erh7b35n4j4v869.mdb.yandexcloud.net:9091')
            .options(**kafka_security_options)
            .option(""topic"", TOPIC_NAME_91)
            .option(""checkpointLocation"", ""test_query"")
            .trigger(processingTime=""1 minute"")
            .start())


if __name__ == ""__main__"":
    spark = spark_init('join stream')
    client_stream = read_client_stream(spark)
    marketing_df = read_marketing(spark)
    output = join(client_stream, marketing_df)
    query = run_query(output)

    while query.isActive:
        print(f""query information: runId={query.runId}, ""
              f""status is {query.status}, ""
              f""recent progress={query.recentProgress}"")
        sleep(30)

    query.awaitTermination()
"
P7txCbCD,Disable nvim.hop when entering Command Line Window in Neovim,chriscoxtx,Lua,Thursday 13th of July 2023 11:49:13 PM CDT,"-- [[ Configure Hop ]]
function MapHop()
    local hop = require('hop')
    local directions = require('hop.hint').HintDirection
    vim.keymap.set('', 'f', function()
      hop.hint_char1({ direction = directions.AFTER_CURSOR, current_line_only = false, multi_windows = true })
    end, {remap=true})
    vim.keymap.set('', 'F', function()
      hop.hint_char1({ direction = directions.BEFORE_CURSOR, current_line_only = false, multi_windows = true })
    end, {remap=true})
    vim.keymap.set('', 't', function()
      hop.hint_char1({ direction = directions.AFTER_CURSOR, current_line_only = false, multi_windows = true, hint_offset = -1 })
    end, {remap=true})
    vim.keymap.set('', 'T', function()
      hop.hint_char1({ direction = directions.BEFORE_CURSOR, current_line_only = false, multi_windows = true, hint_offset = 1 })
    end, {remap=true})
end

MapHop()

local augroup_hop = vim.api.nvim_create_augroup('hop_autocmds', {clear = true})

vim.api.nvim_create_autocmd('CmdwinEnter', {
  group = augroup_hop,
  desc = 'Disable hop in cmdwin',
  callback = function()
    vim.keymap.del('', 'f', { silent = true })
    vim.keymap.del('', 'F', { silent = true })
    vim.keymap.del('', 't', { silent = true })
    vim.keymap.del('', 'T', { silent = true })
  end
})
vim.api.nvim_create_autocmd('CmdwinLeave', {
  group = augroup_hop,
  desc = 'Enable hop when leaving cmdwin',
  callback = function()
    MapHop()
  end
})
"
WAMwxAP2,Lava Plume (simple lava collection),jBlume,Lua,Thursday 13th of July 2023 10:51:59 PM CDT,"
--Not working. Need to troubleshoot.
--Used to place Blood Magic Ritual for lava in front into  tank on the top (note tunable to place in ender tank)

print ""Magmar used Lava Plume ... It was Super effective""

turtle.select(1)
while true do
 turtle.place()
 turtle.placeUp()
end
"
