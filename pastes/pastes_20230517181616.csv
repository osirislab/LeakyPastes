id,title,username,language,date,content
y287ebwt,Untitled,Sininerebane,C#,Wednesday 17th of May 2023 01:13:55 PM CDT,"namespace PeopleInQueue
{
    internal class Program
    {
        static void Main(string[] args)
        {
            {
                Console.OutputEncoding = Encoding.UTF8;
                int peopleInQueue;
                int appointmentLength = 10;
                int hourWait;
                int minutes = 60;
                int minutesWait;

                Console.Write(""Введите количество людей в очереди: "");
                peopleInQueue = Convert.ToInt32(Console.ReadLine());
                Console.WriteLine("" Учитывайте, что фиксированное время приема одного человека всегда равно 10 минутам"");

                hourWait = peopleInQueue * appointmentLength / minutes;
                minutesWait = peopleInQueue * appointmentLength % minutes;

                Console.WriteLine(""Вам ждать своей очереди {0} часов,  и {1} минут."", hourWait, minutesWait);
                Console.ReadKey(); //Ожидается нажание какой либо клавиши
            }
        }
    }
}"
7mkMmwe9,Untitled,libobil,C++,Wednesday 17th of May 2023 01:12:12 PM CDT,"#include <iostream>
using namespace std;
const int MAXN = 5e4 + 10;
const int MAXM = 51;
const int MOD = 1e9 + 7;

string dict[MAXM];
bool censured[MAXM][MAXM];
int selfix[MAXN][MAXM];
bool word[MAXN][MAXM];
long long ans[MAXM];
long long dplr[MAXN][MAXM], dprl[MAXN][MAXM];

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, m, k;
    cin >> n >> m >> k;
    string v;
    cin >> v;
    for (int i = 1; i <= m; i++) {
        cin >> dict[i];

        selfix[0][i] = 0;
        for (int j = 1; j < dict[i].size(); j++) {
            int curr = selfix[j - 1][i] + 1;
            while (dict[i][curr - 1] != dict[i][j]) {
                if (curr <= 1) {
                    curr = 0;
                    break;
                }
                curr = selfix[curr - 2][i] + 1;
            }
            selfix[j][i] = curr;
        }

        int curr = 0;
        for (int j = 0; j < n; j++) {
            while (v[j] != dict[i][curr]) {
                if (curr <= 0) {
                    curr = -1;
                    break;
                }
                curr = selfix[curr - 1][i];
            }
            curr++;
            if (curr == dict[i].size()) {
                word[j - curr + 1][i] = true;
//                cout << j - curr + 1 << '\n';
                curr = selfix[curr - 1][i];
            }
        }

    }
    for (int i = 0; i < k; i++) {
        int a, b;
        cin >> a >> b;
        censured[a][b] = true;
    }

    for (int i = 1; i <= m; i++) {
        if (word[0][i]) {
            dplr[dict[i].size()][i]++;
        }
    }
    for (int j = 1; j < n; j++) {
        for (int i = 1; i <= m; i++) {
            for (int h = 1; h <= m; h++) {
                if (!censured[i][h] && word[j][h] && j + dict[h].size() <= n) {
                    dplr[j + dict[h].size()][h] += dplr[j][i];
                    if (dplr[j + dict[h].size()][h] >= MOD) dplr[j + dict[h].size()][h] -= MOD;
                }
            }
        }
    }

    for (int i = 1; i <= m; i++) {
        if (word[n - dict[i].size()][i]) {
            dprl[n - dict[i].size()][i]++;
        }
    }
    for (int j = n - 1; j >= 0; j--) {
        for (int i = 1; i <= m; i++) {
            for (int h = 1; h <= m; h++) {
                if (!censured[i][h] && j >= dict[i].size() && word[j - dict[i].size()][i]) {
                    dprl[j - dict[i].size()][i] += dprl[j][h];
                    if (dprl[j - dict[i].size()][i] >= MOD) dprl[j - dict[i].size()][i] -= MOD;
                }
            }
        }
    }

    for (int j = 0; j < n; j++) {
        for (int i = 1; i <= m; i++) {
            if (word[j][i]) {
                long long suml = 0, sumr = 0;
                for (int h = 1; h <= m; h++) {
                    if (!censured[h][i] && j - 1 >= 0) {
                        suml += dplr[j][h];
                        if (suml >= MOD) suml -= MOD;
                    }
                    if (!censured[i][h] && j + dict[i].size() < n) {
                        sumr += dprl[j + dict[i].size()][h];
                        if (sumr >= MOD) sumr -= MOD;
                    }
                }
                if (j == 0) {
                    ans[i] += sumr;
                    if (ans[i] >= MOD) ans[i] -= MOD;
                } else if (j + dict[i].size() == n) {
                    ans[i] += suml;
                    if (ans[i] >= MOD) ans[i] -= MOD;
                } else {
                    ans[i] += suml * sumr % MOD;
                    if (ans[i] >= MOD) ans[i] -= MOD;
                }
            }
        }
    }

    for (int i = 1; i <= m; i++) {
        cout << ans[i] << '\n';
    }
    return 0;
}"
icp6QwK1,Untitled,Skos_Martren,C++,Wednesday 17th of May 2023 12:58:41 PM CDT,"#include <iostream>
#include <vector>
#include <algorithm>
#include <sstream>
#include <string>
#include <cctype>

using namespace std;

void ArrayToNumb(const string& Array, string& number) {

    for (const char ch : Array) {
        if (isdigit(ch)) { number += ch; }
    }
}

string addStrings(const string& num1, const string& num2) {
    int idx1 = num1.size() - 1, idx2 = num2.size() - 1;
    int carry(0);
    string ans;

    while (idx1 > -1 || idx2 > -1 || carry) {
        int d1 = (idx1 >= 0) ? num1[idx1] - '0' : 0;
        int d2 = (idx2 >= 0) ? num2[idx2] - '0' : 0;
        int sum = d1 + d2 + carry;
        carry = sum / 10;
        ans.insert(ans.begin(), sum % 10 + '0');
        idx1--; idx2--;
    }
    return ans;
}

int main() {

    string array_first, array_second;
    getline(cin, array_first);
    getline(cin, array_second);

    string number_first, number_second;
    ArrayToNumb(array_first, number_first);
    ArrayToNumb(array_second, number_second);

    string ans = addStrings(number_first, number_second);

    cout << '[';
    for (int i = 0; i < ans.size(); ++i) {

        cout << ans[i];
        if (i != ans.size() - 1) { cout << "", ""; }

    }
    cout << ']';
}
/*
[1, 2, 0, 0]
[2, 5, 5]
*/"
TgUjmRkR,10. Special Numbers,veronikaaa86,Java,Wednesday 17th of May 2023 12:57:42 PM CDT,"package dataTypes;

import java.util.Scanner;

public class P10SpecialNumbers {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int n = Integer.parseInt(scanner.nextLine());

        for (int i = 1; i <= n; i++) {

            int currentNum = i;

            int sum = 0;
            while (currentNum > 0) {
                sum = sum + (currentNum % 10);
                currentNum = currentNum / 10;
            }

            boolean isSpecial = sum == 5 || sum == 7 || sum == 11;

            if (isSpecial) {
                System.out.printf(""%d -> True%n"", i);
            } else {
                System.out.printf(""%d -> False%n"", i);
            }
        }
    }
}
"
19ckTQrF,Untitled,Seredenko-V,C++,Wednesday 17th of May 2023 12:54:37 PM CDT,"#include <iostream>
#include <set>
#include <vector>
#include <cassert>
#include <string>
#include <sstream>

using namespace std;

int ReadOnlyNumber(istream& in) {
    string empty;
    int value = 0;
    in >> value;
    getline(in, empty);
    return value;
}

vector<string> ReadWords(istream& in, int size) {
    vector<string> words(size);
    for (int i = 0; i < size; ++i) {
        getline(in, words[i]);
    }
    return words;
}

int GetNumUniqueWords(const vector<string>& words) {
    set<string> unique(words.begin(), words.end());
    return unique.size();
}


void TestGetNumUniqueWords() {
    vector<string> elements{ ""cat"", ""dog"", ""home"", ""cat"", ""dog"" };
    assert(GetNumUniqueWords(elements) == 3);
    elements.resize(300);
    for (int i = 0; i < elements.size(); ++i) {
        elements[i] = ""ok"";
    }
    assert(GetNumUniqueWords(elements) == 1);
    vector<string> empty{  };
    assert(GetNumUniqueWords(empty) == 0);
    cout << ""TestGetNumUniqueWords is passed"" << endl;
}

void TestReadWords() {
    {
        istringstream input{
            ""cat\n""
            ""dog\n""
            ""home\n""
            ""cat\n""
            ""dog\n""
        };
        vector<string> etalon{ ""cat"", ""dog"", ""home"", ""cat"", ""dog"" };
        assert(etalon == ReadWords(input, 5));
        //assert(GetNumUniqueWords(ReadWords(input, 5)) == 3);
    } {
        istringstream input{
            ""cat\n""
        };
        vector<string> etalon{ ""cat"" };
        assert(ReadWords(input, 1) == etalon);
    } {
        istringstream input;
        vector<string> etalon;
        assert(ReadWords(input, 0) == etalon);
    }
    cout << ""TestReadWords is passed"" << endl;
}

void AllTests() {
    TestGetNumUniqueWords();
    TestReadWords();
    cout << ""AllTests is passed"" << endl;
}

int main() {
    AllTests();
    return 0;
}"
tjXR0mtE,Google Apps Script Feedback Sender,HowToRoblox,Lua,Wednesday 17th of May 2023 12:54:15 PM CDT,"const email = ""YOUR EMAIL HERE"";

function doGet(e) {

  let userId = e.parameters[""UserId""].toString();
  let subject = e.parameters[""Subject""].toString();
  let description = e.parameters[""Body""].toString();

  let response = ""Invalid parameter length!"";

  if (userId.length > 0 && subject.length > 0 && description.length > 0) {

    let body = ""<h1>Sent by user id: "" + userId + ""</h1><br>"" + description;

    try {
      MailApp.sendEmail({
        to: email,
        subject: subject,
        htmlBody: body,
      });

      response = ""success"";

    } catch(err) {

      response = err;
    };
  }

  response = ContentService.createTextOutput(response);
  return response;
}"
DdateERn,Liner Probing,NeutronSlayer,C++,Wednesday 17th of May 2023 12:51:02 PM CDT,"#include <iostream>
using namespace std;
void insert(int hashtable[], int x, int num)
{
    int k = 0;
    int mod = 0, primod = 0;
    bool found = false;
    while (!found)
    {
        if (k == 0)
        {
            mod = x % num;
            primod = mod;
        }
        else
        {
            mod = (primod + k) % num;
        }

        if (hashtable[mod] == 0)
        {
            found = true;
            hashtable[mod] = x;
        }
        k++;
    }
}

void printHashTable(int array[], int hashtable[], int num)
{
    for (int i = 0; i < num; i++)
    {
        cout << array[i] << "" "";
    }
    cout << endl;

    for (int i = 0; i < num; i++)
    {
        cout << i << ""--> "" << hashtable[i] << endl;
    }
}

int main()
{
    bool run = true;
    int num = 0;
    while (run)
    {
        cout << ""enter the number of elements:"";
        cin >> num;
        if (num <= 0)
        {
            cout << ""pick a number greater than zero"" << endl;
        }
        else
            run = false;
    }

    int *array = (int *)malloc(num * sizeof(int));
    if (array == NULL)
    {
        cout << ""!!!!!unable to allocate memory for 'array'!!!!!"" << endl;
    }
    else
    {
        cout << ""array alloction successful"" << endl;

        int *hashtable = (int *)malloc(num * sizeof(int));
        if (hashtable == NULL)
        {
            cout << ""!!!!unable to allocate memory for 'hashtable'!!!!"" << endl;
        }
        else
        {
            for (int i = 0; i < num; i++)
            {
                hashtable[i] = 0;
            }

            cout << ""hashtable alloction successful"" << endl
                 << endl
                 << ""Start entering Numbers"" << endl;
            for (int i = 0; i < num; i++)
            {
                cout << i << "": "";
                cin >> array[i];
                insert(hashtable, array[i], num);
            }

            cout << endl
                 << endl
                 << ""================================"" << endl
                 << ""your hash table:"" << endl;
            printHashTable(array, hashtable, num);
            cout << ""================================"" << endl;
        }
    }
}"
KXW3vasq,Untitled,mick2k1,C++,Wednesday 17th of May 2023 12:25:40 PM CDT,"
class bitreader {
	uint8_t buffer_;
	uint8_t n_ = 0;
	std::istream& is_;

public:
	bitreader(std::istream& is) : is_(is) {}

	template <typename T>
	T read_bit() {
		if (n_ == 0) {
			raw_read(is_, buffer_);
			n_ = 8;
		}
		--n_;
		return (buffer_ >> n_) & 1;
	}

	template <typename T>
	T read(uint8_t n) {
		T u = 0;
		while (n-- > 0) {
			u = (u << 1) | read_bit<T>();
		}
		return u;
	}

	template <typename T>
	T operator()(uint8_t n) {
		return read(n);
	}

	bool fail() const {
		return is_.fail();
	}

	explicit operator bool() const {
		return !fail();
	}
};"
m0t65xqS,Untitled,Neolyt,Python,Wednesday 17th of May 2023 12:23:27 PM CDT,"import tkinter as tk
from tkinter import *
from random import choice
from datetime import datetime

def load_file(abcd_questions):
    """"""
    Loads file and returns it split into lines
    """"""
    file = open('abcd_questions.txt','r', encoding = 'utf-8')
    lines = file.read().splitlines()
    file.close()
    return lines

def load_abcd_questions(abcd_questions):
    """"""
    Returns list of questions where question contains:
    question[0]: text of question
    question[1]: letter of the correct answer
    question[2:6]
    """"""
    questions_file = load_file(abcd_questions)
    questions = []
    for i in range(0,len(questions_file),6):
        questions.append(questions_file[i:i+6]) 
    return questions

abcd = load_abcd_questions('abcd_questions')

def get_random_question(abcd):
    """"""
    Returns random question from questions passed in
    """"""
    return choice(abcd)

a = get_random_question(abcd)
question = a[0]
answers = a [2:6]


writing= (""Cosmic Sans MS "", 22)
window = Tk()
window.title(""Game for two players"")
window.geometry(""1000x500"")
lab_question = Label(window, text = question , font = writing )
lab_question.pack()
e_input = Entry (window, widt= 30, font=writing,)
e_input.insert(0,"""")
e_input.pack()
lab_answers = Label (window, text = answers , font = writing )
lab_answers.pack()

def onEntryKeyPressed(event): # event obsahuje informacie o 'udalosti' v nasom pripade o stlaceni klavesy
    if event.keysym == ""Num_Lock"":
        player1=0
        print (""Hra hrac dva "")
    elif event.keysym == ""Return"": # event.keysym nam povie aky je symbolicky nazov prave stlacenej klavesy. ""Return"" je symbolicka hodnota pre klavesu enter
           answer = e_input.get() 
       # change everything to lowercase to make comparions easier
           if answer.lower() == a[1].lower():
               lab_ans_true = Label(window, text = ""Odpovedal si spravne."" , font= writing)
               lab_ans_true.pack()
              
           else:
               lab_ans_false = Label(window, text=""Odpovedal si zle."", font= writing)
               lab_ans_false.pack()
    elif event.keysym == ""Tab"":
        player2=0       
        print(""Hra hrac jedna "")
    elif event.keysym == ""Return"": # event.keysym nam povie aky je symbolicky nazov prave stlacenej klavesy. ""Return"" je symbolicka hodnota pre klavesu enter
            answer = e_input.get() 
    # change everything to lowercase to make comparions easier
            if answer.lower() == a[1].lower():
                lab_ans_true = Label(window, text = ""Odpovedal si spravne."" , font= writing)
                lab_ans_true.pack()
                
               
            else:
                lab_ans_false = Label(window, text=""Odpovedal si zle."", font= writing)
                lab_ans_false.pack()
   
 



e_input.bind(""<Key>"", onEntryKeyPressed)



### main

# Load all files
abcd_questions = load_abcd_questions(""abcd_questions.txt"")




window.mainloop()




"
wgexkd7f,03. Exact Sum of Real Numbers,veronikaaa86,Java,Wednesday 17th of May 2023 12:21:46 PM CDT,"package dataTypes;

import java.math.BigDecimal;
import java.util.Scanner;

public class P03ExactSumOfRealNumbers {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int n = Integer.parseInt(scanner.nextLine());

        BigDecimal sum = new BigDecimal(0);
        for (int i = 0; i < n; i++) {
           BigDecimal currentNum = new BigDecimal(scanner.nextLine());

            sum = sum.add(currentNum);
        }

        System.out.println(sum);
    }
}
"
GHibstrQ,CC alarm reciever,ASRS_,Lua,Wednesday 17th of May 2023 12:07:55 PM CDT,"rednet.open(""bottom"")
 
while true do
    id, msg = rednet.receive(""alarm"")
    if (msg == true) then
        redstone.setOutput(""top"", true)
        sleep(.1)
        redstone.setOutput(""top"", false)
        sleep(.1)
    else
        redstone.setOutput(""top"", false)
    end
    msg = false
end"
R1dAJiQh,Untitled,dllbridge,C,Wednesday 17th of May 2023 12:04:36 PM CDT,"
#include  <stdio.h>
#include <stdlib.h>
#include <locale.h>

int M = 0,  // Строки
    N = 0;  // Столбцы 



//int arr[M][N];

 
int *pA;
 
 
//////////////////////////////////////////////////////////// 
int main()                                                //  
{
	
	setlocale(LC_ALL, ""rus"");
	
	printf(""Введите кол-во строк M и столбцов N: ""); scanf(""%d%d"", &M, &N); printf(""\n"");
	
	printf(""M = %d, N = %d\n"", M, N);
	
	int *a = (int*)malloc(M * N * 4);
	
	for(int i = 0; i < M*N; i++)
    {
		
		printf(""%d\n"", a[i]);
	}
	
	free(a);
}


























/*

#include <stdio.h>

#define SONY 77

int a = 1;



 
int *pA;
 
 
//////////////////////////////////////////////////////////// 
int main()                                                //  
{
	int  p[15];              // 123 * 4
	
	pA = p;
	
	printf(""%d\n"", p );
    printf(""%d\n"", pA);
    printf("" - - - - - - - - - \n"");
    for(int i = 0; i < 10; i++)
    {
		
		printf(""%10d - - - %10d\n"", pA[i], p[i]);
	}
}



*/











/*


#include <stdio.h>

#define SONY 77

int a = 1;

int  p[123];              // 123 * 4

 
int *pA;
 
 
//////////////////////////////////////////////////////////// 
int main()                                                //  
{
	
	
	pA = p;
	
	printf(""%d\n"", p );
    printf(""%d\n"", pA);
    printf("" - - - - - - - - - \n"");
    for(int i = 0; i < 10; i++)
    {
		
		printf(""%d\n"", pA[i] );
	}
}


*/





"
LNn1spZx,Untitled,Neolyt,Python,Wednesday 17th of May 2023 11:55:17 AM CDT,"import tkinter as tk
from tkinter import *
from random import choice
from datetime import datetime

def load_file(abcd_questions):
    """"""
    Loads file and returns it split into lines
    """"""
    file = open('abcd_questions.txt','r', encoding = 'utf-8')
    lines = file.read().splitlines()
    file.close()
    return lines

def load_abcd_questions(abcd_questions):
    """"""
    Returns list of questions where question contains:
    question[0]: text of question
    question[1]: letter of the correct answer
    question[2:6]
    """"""
    questions_file = load_file(abcd_questions)
    questions = []
    for i in range(0,len(questions_file),6):
        questions.append(questions_file[i:i+6]) 
    return questions

abcd = load_abcd_questions('abcd_questions')

def get_random_question(abcd):
    """"""
    Returns random question from questions passed in
    """"""
    return choice(abcd)

a = get_random_question(abcd)
question = a[0]
answers = a [2:6]


writing= (""Cosmic Sans MS "", 22)
window = Tk()
window.title(""Game for two players"")
window.geometry(""1000x500"")
lab_question = Label(window, text = question , font = writing )
lab_question.pack()
e_input = Entry (window, widt= 30, font=writing,)
e_input.insert(0,"""")
e_input.pack()
lab_answers = Label (window, text = answers , font = writing )
lab_answers.pack()

def onEntryKeyPressed(event): # event obsahuje informacie o 'udalosti' v nasom pripade o stlaceni klavesy
     if event.keysym == ""Num_Lock"":
        player1=0
        print (""Hra hrac dva "")
        if event.keysym == ""Return"": # event.keysym nam povie aky je symbolicky nazov prave stlacenej klavesy. ""Return"" je symbolicka hodnota pre klavesu enter
           answer = e_input.get() 
       # change everything to lowercase to make comparions easier
           if answer.lower() == a[1].lower():
               lab_ans_true = Label(window, text = ""Odpovedal si spravne."" , font= writing)
               lab_ans_true.pack()
               player+=1
               print(player1)
           else:
               lab_ans_false = Label(window, text=""Odpovedal si zle."", font= writing)
               lab_ans_false.pack()
     elif event.keysym == ""Tab"":
        player2=0
        print(""Hra hrac jedna "")
        if event.keysym == ""Return"": # event.keysym nam povie aky je symbolicky nazov prave stlacenej klavesy. ""Return"" je symbolicka hodnota pre klavesu enter
            answer = e_input.get() 
    # change everything to lowercase to make comparions easier
            if answer.lower() == a[1].lower():
                lab_ans_true = Label(window, text = ""Odpovedal si spravne."" , font= writing)
                lab_ans_true.pack()
                player2+=1
                print(player2)
            else:
                lab_ans_false = Label(window, text=""Odpovedal si zle."", font= writing)
                lab_ans_false.pack()
   
 



e_input.bind(""<Key>"", onEntryKeyPressed)



### main

# Load all files
abcd_questions = load_abcd_questions(""abcd_questions.txt"")


# Start game time
time_started = datetime.now()

window.mainloop()




"
iuPYh03k,show-hide-comments,studioart,PHP,Wednesday 17th of May 2023 11:39:13 AM CDT,"function agwp_footerarea()
{
?>
<script type=""text/javascript"">
jQuery(document).ready(function( $ ) {
var commentsDiv = $('#comments');
if (commentsDiv.length) {
$(commentsDiv).hide();
$('<button/>').attr('class', 'toggle-comments').attr('href', '#').html('Kommentare anzeigen <span class=""icon_comment""></span>').insertBefore(commentsDiv);
$('.toggle-comments').on('click', function(e) {
e.preventDefault();
$(commentsDiv).toggle('slow', function() {
var anchor = $('.toggle-comments');
var anchorText = anchor.html() == 'Kommentare anzeiten <span class=""icon_comment""></span>' ? 'Kommentare verbergen <span class=""icon_comment""></span>' : 'Kommentare anzeigen <span class=""icon_comment""></span>';
$(anchor).html(anchorText);
});
});
}
});
</script>
<?php
}
add_action('wp_footer', 'agwp_footerarea', 100);"
DHXJrz9r,Untitled,Neolyt,Python,Wednesday 17th of May 2023 11:37:38 AM CDT,"
import tkinter as tk
from tkinter import *
from random import choice
from datetime import datetime

def load_file(abcd_questions):
    """"""
    Loads file and returns it split into lines
    """"""
    file = open('abcd_questions.txt','r', encoding = 'utf-8')
    lines = file.read().splitlines()
    file.close()
    return lines

def load_abcd_questions(abcd_questions):
    """"""
    Returns list of questions where question contains:
    question[0]: text of question
    question[1]: letter of the correct answer
    question[2:6]
    """"""
    questions_file = load_file(abcd_questions)
    questions = []
    for i in range(0,len(questions_file),6):
        questions.append(questions_file[i:i+6]) 
    return questions

abcd = load_abcd_questions('abcd_questions')

def get_random_question(abcd):
    """"""
    Returns random question from questions passed in
    """"""
    return choice(abcd)

a = get_random_question(abcd)
question = a[0]
answers = a [2:6]


writing= (""Cosmic Sans MS "", 22)
window = Tk()
window.title(""Game for two players"")
window.geometry(""1000x500"")
lab_question = Label(window, text = question , font = writing )
lab_question.pack()
e_input = Entry (window, widt= 30, font=writing,)
e_input.insert(0,"""")
e_input.pack()
lab_answers = Label (window, text = answers , font = writing )
lab_answers.pack()

def onEntryKeyPressed(event): # event obsahuje informacie o 'udalosti' v nasom pripade o stlaceni klavesy
     if event.keysym == ""Return"":
        player1=0
        print (""Hra hrac dva "")
    elif event.keysym == ""Tab"":
        player2=0
        print(""Hra hrac jedna "")
    elif event.keysym == ""Return"": # event.keysym nam povie aky je symbolicky nazov prave stlacenej klavesy. ""Return"" je symbolicka hodnota pre klavesu enter
        answer = e_input.get() 
    # change everything to lowercase to make comparions easier
        if answer.lower() == a[1].lower():
            lab_ans_true = Label(window, text = ""Odpovedal si spravne."" , font= writing)
            lab_ans_true.pack()

        else:
            lab_ans_false = Label(window, text=""Odpovedal si zle."", font= writing)
            lab_ans_false.pack()
   




e_input.bind(""<Key>"", onEntryKeyPressed)



### main

# Load all files
abcd_questions = load_abcd_questions(""abcd_questions.txt"")


# Start game time
time_started = datetime.now()

window.mainloop()

"
7eRijsV2,Untitled,MeehoweCK,C++,Wednesday 17th of May 2023 11:30:17 AM CDT,"#include <iostream>

using namespace std;

const int N = 4;

bool operator<(string a, string b)
{
    unsigned a_size = a.size();     // pobranie długości pierwszego wyrazu do zmiennej
    unsigned b_size = b.size();     // pobranie długości drugiego wyrazu do zmiennej

    for(unsigned i = 0; i < a_size && i < b_size; ++i)
    {
        if(toupper(a[i]) < toupper(b[i]))       // toupper zwraca dużą literę jeśli podajemy do funkcji literę małą
            return true;
        if(toupper(a[i]) > toupper(b[i]))
            return false;
    }
    if(a_size < b_size)
        return true;
    return false;
}

void sortowanie(string tablica[])
{
    int min_index;
    for(int i = 0; i < N - 1; ++i)
    {
        min_index = i;
        for(int j = i + 1; j < N; ++j)
            if(tablica[j] < tablica[min_index])
                min_index = j;
        swap(tablica[i], tablica[min_index]);
    }
}

int main()
{
    string tablica[N] = {""Jan"", ""Mateusz"", ""Ania"", ""Matylda""};
    sortowanie(tablica);
    for(int i = 0; i < N; ++i)
        cout << tablica[i] << endl;
    return 0;
}
"
kULjGecA,Untitled,vvsvvs,C#,Wednesday 17th of May 2023 11:24:30 AM CDT,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace _10._Radioactive_Mutant_Vampire_Bunnies
{
	class RadioactiveMutantVampireBunnies
	{
		static void MultiplyRabbit(char[,] field, int row, int col)
		{
			const char Bunny = 'B';

			int maxRow = field.GetLength(0);
			int maxCol = field.GetLength(1);

			int currentRow = row - 1;
			int currentCol = 0;

			if (IsExitFromField(maxRow, maxCol, currentRow, col))
			{
				field[currentRow, col] = Bunny;
			}

			currentRow = row + 1;
			if (IsExitFromField(maxRow, maxCol, currentRow, col))
			{
				field[currentRow, col] = Bunny;
			}

			currentCol = col + 1;
			if (IsExitFromField(maxRow, maxCol, row, currentCol))
			{
				field[row, currentCol] = Bunny;
			}

			currentCol = col - 1;
			if (IsExitFromField(maxRow, maxCol, row, currentCol))
			{
				field[row, currentCol] = Bunny;
			}
		}// bool MultiplyRabbitOrKillPlayer(char[,] field, int row, int col)

		static bool IsExitFromField(int maxRow, int maxCol, int newRow, int newCol)
		{
			bool result = ((newRow >= 0) && (newCol >= 0));
			result = ((result) && (newRow < maxRow) && (newCol < maxCol));

			return result;
		}// bool IsExitFromField(int maxRow, int maxCol, int newRow, int newCol)

		static void PrintArray(char[,] field)
		{
			StringBuilder sb = new StringBuilder();

			for (int row = 0; row < field.GetLength(0); row++)
			{
				StringBuilder temp = new StringBuilder();

				for (int col = 0; col < field.GetLength(1); col++)
				{
					temp.Append($""{field[row, col]}"");
				}

				sb.AppendLine(temp.ToString().TrimEnd());
			}
			Console.Write(sb.ToString());
		}// void PrintArray(char[,] field, string title)

		static void Main(string[] args)
		{
			const char Free = '.';
			const char Bunny = 'B';
			const char Player = 'P';

			int[] dimention = Console.ReadLine().Split(' ', StringSplitOptions.RemoveEmptyEntries).Select(int.Parse).ToArray();

			int n = dimention[0];
			int m = dimention[1];

			char[,] field = new char[n, m];

			int playerRow = 0;
			int playerCol = 0;

			for (int row = 0; row < field.GetLength(0); row++)
			{
				char[] temp = Console.ReadLine().ToCharArray();

				for (int col = 0; col < field.GetLength(1); col++)
				{
					field[row, col] = temp[col];
					if (temp[col].Equals(Player))
					{
						playerRow = row;
						playerCol = col;
						field[row, col] = Free;
					}
				}
			}

			Queue<char> commands = new Queue<char>(Console.ReadLine().ToCharArray());

			bool isWin = false;
			bool isLostMove = false;
			bool isLostMultiply = false;

			while ((!isWin) && (!isLostMove) && (!isLostMultiply))
			{
				int colStep = 0;
				int rowStep = 0;

				if (commands.Count > 0)
				{
					char direction = commands.Dequeue();

					switch (direction)
					{
						case 'L':
							colStep--;
							break;
						case 'R':
							colStep++;
							break;
						case 'U':
							rowStep--;
							break;
						case 'D':
							rowStep++;
							break;
						default:
							break;
					}

					bool isValidIndex = IsExitFromField(field.GetLength(0), field.GetLength(1), playerRow + rowStep, playerCol + colStep);

					isWin = (!(isValidIndex));
					field[playerRow, playerCol] = Free;

					if (isValidIndex)
					{
						playerRow += rowStep;
						playerCol += colStep;

						if (field[playerRow, playerCol].Equals(Bunny))
						{
							isLostMove = true;
						}
					}
				}// if (commands.Count > 0) Player mov

				int row = 0;

				Queue<int> bunnies = new Queue<int>();

				do
				{
					int col = 0;

					do
					{
						if (field[row, col].Equals(Bunny))
						{
							bunnies.Enqueue(row);
							bunnies.Enqueue(col);
						}

						col++;
					} while (col < field.GetLength(1));

					row++;
				} while (row < field.GetLength(0));

				while (bunnies.Count > 0)
				{
					int r = bunnies.Dequeue();
					int c = bunnies.Dequeue();
					MultiplyRabbit(field, r, c);
				}

				if (field[playerRow, playerCol].Equals(Bunny))
				{
					isLostMultiply = true;
				}
			}// while ((!isWin) && (!isLost))

			StringBuilder sb = new StringBuilder();

			PrintArray(field);

			if (isWin)
			{
				sb.AppendLine($""won: {playerRow} {playerCol}"");
			}
			else if ((isLostMove) || (isLostMultiply))
			{
				sb.AppendLine($""dead: {playerRow} {playerCol}"");
			}

			Console.WriteLine(sb.ToString());
		}// static void Main(string[] args)
	}

	
	

	
}
//Browsing through GitHub, you come across an old JS Basics teamwork game. It is about very nasty bunnies that multiply extremely fast. There’s also a player that has to escape from their lair. You really like the game, so you decide to port it to C# because that’s your language of choice. The last thing that is left is the algorithm that decides if the player will escape the lair or not.
//First, you will receive a line holding integers N and M, which represent the rows and columns in the lair. Then you receive N strings that can only consist of ""."", ""B"", ""P"". The bunnies are marked with ""B"", the player is marked with ""P"", and everything else is free space, marked with a dot ""."". They represent the initial state of the lair. There will be only one player. Then you will receive a string with commands such as LLRRUUDD – where each letter represents the next move of the player (Left, Right, Up, Down).
//After each step of the player, each of the bunnies spread to the up, down, left and right (neighboring cells marked as ""."" changes their value to ""B""). If the player moves to a bunny cell or a bunny reaches the player, the player has died. If the player goes out of the lair without encountering a bunny, the player has won.
//When the player dies or wins, the game ends. All the activities for this turn continue (e.g. all the bunnies spread normally), but there are no more turns. There will be no stalemates where the moves of the player end before he dies or escapes.
//Finally, print the final state of the lair with every row on a separate line. On the last line, print either ""dead: {row} {col}"" or ""won: {row} {col}"". Row and col are the coordinates of the cell where the player has died or the last cell he has been in before escaping the lair.
//Input
//•	On the first line of input, the numbers N and M are received – the number of rows and columns in the lair
//•	On the next N lines, each row is received in the form of a string. The string will contain only ""."", ""B"", ""P"". All strings will be the same length. There will be only one ""P"" for all the input
//•	On the last line, the directions are received in the form of a string, containing ""R"", ""L"", ""U"", ""D""
//Output
//•	On the first N lines, print the final state of the bunny lair
//•	On the last line, print the outcome – ""won:"" or ""dead:"" + {row} { col}
//Constraints
//•	The dimensions of the lair are in range [3…20]
//•	The directions string length is in range [1…20]

//Преглеждайки GitHub, попадате на стара js basics игра за работа в екип. Става въпрос за много гадни зайчета, които се размножават изключително бързо.
//Има и играч, който трябва да избяга от лейбъристите си. Наистина харесваш играта, затова решаваш да я пристаниш на C# защото това е твоят език по избор.
//Последното нещо, което е останало, е алгоритъмът, който решава дали играчът ще избяга от леговището или не.
//Първо, ще получите линия, притежаваща цяло число N и M, които представляват редовете и колоните в лейбъра.
//След това получавате N низове, които могат да се състоят само от ""."", ""B"", ""P"".
//Зайчетата са маркирани с ""B"", играчът е маркиран с ""P"", а всичко останало е свободно пространство, маркирано с точка ""."". Те представляват първоначалното състояние на лейбъра.
//Ще има само един играч. След това ще получите низ с команди като LLRRUUDD – където всяка буква представлява следващия ход на играча (Left, Right, Up, Down).
//След всяка стъпка на играча, всяка от зайчетата се разпространи към нагоре, надолу, наляво и надясно (съседни клетки, маркирани като ""."" променя стойността си на ""B"").
//Ако играчът се премести в зайче клетка или зайче достигне играча, играчът е починал. Ако играчът излезе от стълбището, без да срещне зайче, играчът е спечелил.
//Когато играчът умре или спечели, играта приключва. Всички дейности за този завой продължават (напр. всички зайчета се разпространяват нормално), но вече няма завои.
//Няма да има застой, където движенията на играча да приключат преди да умре или да избяга.
//Накрая отпечатайте окончателното състояние на лейбъра с всеки ред на отделна линия. На последния ред отпечатайте или ""мъртъв: {ред} {col}"" или ""спечелен: {ред} {col}"".
//Ред и кол са координатите на клетката, където играчът е умрял или последната клетка, в която е бил, преди да избяга от лейбъристите.
//Въвеждане
//·         На първия ред на въвеждане се получават числата N и M – броят на редовете и колоните в лейбъра

//·         На следващите n линии всеки ред се получава под формата на низ. Низът ще съдържа само ""."", ""B"", ""P"". Всички струни ще бъдат с еднаква дължина. Ще има само един ""P"" за всички входни

//·         На последния ред посоките се получават под формата на низ, съдържащ ""R"", ""L"", ""U"", ""D""

//Изход
//·         На първите n линии отпечатайте окончателното състояние на лейбъра зайче

//·         На последния ред отпечатайте резултата – ""спечели:"" или ""мъртъв:"" + {ред} { col}

//Ограничения
//·         Размерите на лейбъра са в обхват [3... 20]

//·         Посоката дължина на низа е в обхват [1... 20]
"
wydmwJrW,Untitled,vvsvvs,C#,Wednesday 17th of May 2023 11:20:21 AM CDT,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace _8._Bombs
{
	class Bombs
	{
		static void Main(string[] args)
		{
			int n = int.Parse(Console.ReadLine());

			int[,] field = new int[n, n];

			for (int row = 0; row < field.GetLength(0); row++)
			{
				int[] temp = Console.ReadLine().Split(' ', StringSplitOptions.RemoveEmptyEntries).Select(int.Parse).ToArray();

				for (int col = 0; col < field.GetLength(1); col++)
				{
					field[row, col] = temp[col];
				}
			}
			char[] separator = { ' ', ',' };
			Queue<int> command = new Queue<int>(Console.ReadLine().Split(separator, StringSplitOptions.RemoveEmptyEntries).Select(int.Parse).ToArray());

			while (command.Count > 0)
			{
				int row = command.Dequeue();
				int col = command.Dequeue();
				ExplodingBomb(field, row, col);
			}

			int aliveCell = 0;
			int sumAllive = 0;

			StringBuilder sb = new StringBuilder();

			for (int row = 0; row < field.GetLength(0); row++)
			{
				StringBuilder temp = new StringBuilder();
				for (int col = 0; col < field.GetLength(1); col++)
				{
					if (field[row, col] > 0)
					{
						aliveCell++;
						sumAllive += field[row, col];
					}

					temp.Append($""{field[row, col]} "");
				}
				sb.AppendLine(temp.ToString().TrimEnd());
			}

			sb.Insert(0, $""Sum: {sumAllive}\n"");
			sb.Insert(0, $""Alive cells: {aliveCell}\n"");

			Console.WriteLine(sb.ToString());
		}// static void Main(string[] args)

		static void ExplodingBomb(int[,] field, int row, int col)
		{
			if (ValidCoordinates(field.GetLength(0), field.GetLength(1), row, col) && (field[row, col] > 0))
			{
				int bombPower = field[row, col];
				for (int r = row - 1; r <= row + 1; r++)
				{
					for (int c = col - 1; c <= col + 1; c++)
					{
						if (ValidCoordinates(field.GetLength(0), field.GetLength(1), r, c) && (field[r, c] > 0))
						{
							field[r, c] -= bombPower;
						}
					}
				}
			}
		}// void ExplodingBomb(int[,] field, int row, int col)

		static bool ValidCoordinates(int maxRow, int maxCol, int row, int col)
		{
			bool result = ((row >= 0) && (col >= 0));
			result = ((result) && (row < maxRow) && (col < maxCol));
			return result;
		}// bool ValidCoordinates(int maxRow, int maxCol, int row, int col)
	}
}
//You will be given a square matrix of integers, each integer separated by a single space, and each row on a new line.Then on the last line of input you will receive indexes - coordinates to several cells separated by a single space, in the following format: row1,column1 row2, column2  row3, column3… 
//On those cells there are bombs. You have to proceed every bomb, one by one in the order they were given. When a bomb explodes deals damage equal to its own integer value, to all the cells around it (in every direction and in all diagonals). One bomb can't explode more than once and after it does, its value becomes 0. When a cell’s value reaches 0 or below, it dies. Dead cells can't explode.
//You must print the count of all alive cells and their sum. Afterwards, print the matrix with all of its cells (including the dead ones). 
//Input
//•	On the first line, you are given the integer N – the size of the square matrix.
//•	The next N lines holds the values for every row – N numbers separated by a space.
//•	On the last line you will receive the coordinates of the cells with the bombs in the format described above.
//Output
//•	On the first line you need to print the count of all alive cells in the format: 
//""Alive cells: {aliveCells}""
//•	On the second line you need to print the sum of all alive cell in the format: 
//""Sum: {sumOfCells}""
//•	In the end print the matrix. The cells must be separated by a single space.
//Constraints
//•	The size of the matrix will be between [0…1000].
//•	The bomb coordinates will always be in the matrix.
//•	The bomb’s values will always be greater than 0.
//•	The integers of the matrix will be in range [1…10000].
//Ще ви бъде дадена квадратна матрица от цяло число, всяко цяло число, отделено с едно пространство, и всеки ред на нова линия.
//След това на последния ред на въвеждане ще получите индекси - координати на няколко клетки, разделени с едно пространство,
//в следния формат: ред1,колона1 ред2, колона2 ред3, колона3, колона3...

//На онези килии има бомби. Трябва да продължите всяка бомба- една по една в заповедта, която са им дадени. Когато една бомба експлодира сделки щети, равни на собствената си стойност цяло число , на всички клетки около нея (във всяка посока и във всички диагонали). Една бомба не може да избухне повече от веднъж и след като го направи, стойността й става 0. Когато стойността на клетката достигне 0 или по-долу, тя умира. Мъртвите клетки не могат да експлодират.

//Трябва да отпечатате броя на всички живи клетки и тяхната сума. След това отпечатайте матрицата с всичките й клетки (включително мъртвите).

//Въвеждане
//·         На първа линия ви се дава цяло число N – размерът на квадратната матрица.

//·         Следващите N редове задържат стойностите за всеки ред – N номера, разделени с интервал.

//·         На последната линия ще получите координатите на клетките с бомбите във формат, описан по-горе.

//Изход
//·         На първия ред трябва да отпечатате броя на всички живи клетки във формат:

//""Живи клетки: {живиКлетки}""

//·         На втория ред трябва да отпечатате сумата на всички живи клетки във формат:

//""Сума: {sumOfCells}""

//·         В крайна сметка отпечатайте матрицата. Клетките трябва да бъдат разделени с едно пространство.

//Ограничения
//·         Размерът на матрицата ще бъде между [0... 1000].

//·         Бомбените координати винаги ще са в матрицата.

//·         Ценностите на бомбата винаги ще бъдат по-големи от 0.

//·         Цяло число на матрицата ще бъде в обхват [1... 10000]."
mSeJehfk,Untitled,vvsvvs,C#,Wednesday 17th of May 2023 11:19:35 AM CDT,"using System;

namespace _7._Knight_Game
{
	class KnightGame
	{
		static void Main(string[] args)
		{
			int n = int.Parse(Console.ReadLine());

			byte[,] board = new byte[n, n];

			for (int row = 0; row < n; row++)
			{
				char[] input = Console.ReadLine().ToCharArray();

				for (int col = 0; col < input.Length; col++)
				{
					switch (input[col].ToString().ToLower())
					{
						case ""0"":
							board[row, col] = 0;
							break;
						case ""k"":
							board[row, col] = 1;
							break;
						default:
							break;
					}
				}
			}

			int currentMaxHit = -1;
			int countKnight = 0;

			while (currentMaxHit != 0)
			{
				currentMaxHit = 0;
				int currentMaxHitRow = 0;
				int currentMaxHitCol = 0;

				for (int row = 0; row < board.GetLength(0); row++)
				{
					for (int col = 0; col < board.GetLength(1); col++)
					{
						if (board[row, col].Equals(1))
						{
							int currentHit = 0;
							int currentHitRow = 0;
							int currentHitCol = 0;
							for (byte i = 1; i <= 8; i++)
							{
								if (IsHitKnight(board, row, col, i))
								{
									currentHit++;
									currentHitCol = col;
									currentHitRow = row;

								}
							}

							if (currentHit > currentMaxHit)
							{
								currentMaxHit = currentHit;
								currentMaxHitRow = currentHitRow;
								currentMaxHitCol = currentHitCol;
							}
						}
					}
				}

				if (currentMaxHit != 0)
				{
					board[currentMaxHitRow, currentMaxHitCol] = 0;
					countKnight++;
				}
			}// while (countKnight != 0)

			Console.WriteLine(countKnight);
		}

		static bool IsHitKnight(byte[,] board, int row, int col, byte indexJump)
		{
			bool result = false;

			switch (indexJump)
			{
				case 1:
					row -= 1;
					col -= 2;
					break;
				case 2:
					row -= 1;
					col += 2;
					break;
				case 3:
					row += 1;
					col += 2;
					break;
				case 4:
					row += 1;
					col -= 2;
					break;
				case 5:
					row -= 2;
					col -= 1;
					break;
				case 6:
					row -= 2;
					col += 1;
					break;
				case 7:
					row += 2;
					col += 1;
					break;
				case 8:
					row += 2;
					col -= 1;
					break;
				default:
					break;
			}

			result = ResultCheck(board.GetLength(0), board.GetLength(1), row, col);

			if (result)
			{
				result = false;
				if (board[row, col].Equals(1))
				{
					result = true;
				}
			}

			return result;
		}// bool ValidIndex(byte[,] board, int row, int col, byte indexJump)

		static bool ResultCheck(int maxRow, int maxCol, int row, int col)
		{
			bool result = true;

			result = ((result) && (row >= 0) && (col >= 0));
			result = ((result) && (row < maxRow) && (col < maxCol));

			return result;
		}// bool ResultCheck(int maxRow, int maxCol, int row, int col)
	}
}
//Chess is the oldest game, but it is still popular these days. For this task we will use only one chess piece – the Knight. 
//The knight moves to the nearest square but not on the same row, column, or diagonal. (This can be thought of as moving two squares horizontally, then one square vertically, or moving one square horizontally then two squares vertically— i.e. in an ""L"" pattern.) 
//The knight game is played on a board with dimensions N x N and a lot of chess knights 0 <= K <= N2. 
//You will receive a board with K for knights and '0' for empty cells. Your task is to remove a minimum of the knights, so there will be no knights left that can attack another knight. 
//Input
//On the first line, you will receive the N size of the board
//On the next N lines, you will receive strings with Ks and 0s.
//Output
//Print a single integer with the minimum number of knights that needs to be removed
//Constraints
//•	Size of the board will be 0 < N < 30
//•	Time limit: 0.3 sec.Memory limit: 16 MB.
"
nLhQhVqk,Untitled,Neolyt,Python,Wednesday 17th of May 2023 11:19:31 AM CDT,"import tkinter as tk
from tkinter import *
from random import choice
from datetime import datetime

def load_file(abcd_questions):
    """"""
    Loads file and returns it split into lines
    """"""
    file = open('abcd_questions.txt','r', encoding = 'utf-8')
    lines = file.read().splitlines()
    file.close()
    return lines

def load_abcd_questions(abcd_questions):
    """"""
    Returns list of questions where question contains:
    question[0]: text of question
    question[1]: letter of the correct answer
    question[2:6]
    """"""
    questions_file = load_file(abcd_questions)
    questions = []
    for i in range(0,len(questions_file),6):
        questions.append(questions_file[i:i+6]) 
    return questions

abcd = load_abcd_questions('abcd_questions')

def get_random_question(abcd):
    """"""
    Returns random question from questions passed in
    """"""
    return choice(abcd)

a = get_random_question(abcd)
question = a[0]
answers = a [2:6]


writing= (""Cosmic Sans MS "", 22)
window = Tk()
window.title(""Game for two players"")
window.geometry(""1000x500"")
lab_question = Label(window, text = question , font = writing )
lab_question.pack()
e_input = Entry (window, widt= 30, font=writing,)
e_input.insert(0,"""")
e_input.pack()
lab_answers = Label (window, text = answers , font = writing )
lab_answers.pack()

def onEntryKeyPressed(event): # event obsahuje informacie o 'udalosti' v nasom pripade o stlaceni klavesy
     if event.keysym == ""Return"": # event.keysym nam povie aky je symbolicky nazov prave stlacenej klavesy. ""Return"" je symbolicka hodnota pre klavesu enter
        answer = e_input.get() 
    # change everything to lowercase to make comparions easier
        if answer.lower() == a[1].lower():
            return True
            lab_ans_true = Label(window, text = answer , fotn= writing)
            lab_ans_true.place(x = 450 , y = 500)

        else:
            return False
            lab_ans_false = Label(window, text=""Odpovedal si zle."", fotn= writing)
            lab_ans_false.pack()
   




e_input.bind(""<Key>"", onEntryKeyPressed)



### main

# Load all files
abcd_questions = load_abcd_questions(""abcd_questions.txt"")


# Start game time
time_started = datetime.now()

window.mainloop()


"
0QNKFfA1,Untitled,vvsvvs,C#,Wednesday 17th of May 2023 11:18:43 AM CDT,"using System;
using System.Linq;
using System.Text;

namespace _5._Snake_Moves
{
	class SnakeMoves
	{
		static void Main(string[] args)
		{
			int[] inputDimention = Console.ReadLine().Split(' ', StringSplitOptions.RemoveEmptyEntries).Select(int.Parse).ToArray();

			int row = inputDimention[0];
			int col = inputDimention[1];

			char[,] matrix = new char[row, col];

			StringBuilder snake = new StringBuilder(Console.ReadLine());

			if (snake.Length > 0)
			{
				int r = 0;
				int c = 0;

				for (int i = 0; i < (row * col); i++)
				{
					char sh = snake[0];
					snake.Remove(0, 1);
					snake.Append(sh);

					matrix[r, c] = sh;

					if (r % 2 == 0)
					{
						c++;
					}
					else
					{
						c--;
					}

					if (c == col)
					{
						c--;
						r++;
					}

					if (c < 0)
					{
						c++;
						r++;
					}
				}
			}// if (snake.Length > 0

			StringBuilder temp = new StringBuilder();

			snake.Clear();
			for (int r = 0; r < row; r++)
			{
				temp.Clear();
				for (int c = 0; c < col; c++)
				{
					temp.Append($""{matrix[r, c]}"");
				}
				snake.AppendLine(temp.ToString());
			}

			Console.WriteLine(snake.ToString());
		}
	}
}
//You are walking in the park and you encounter a snake! You are terrified, and you start running zig-zag, so the snake starts following you. 
//You have a task to visualize the snake’s path in a square form. A snake is represented by a string. The isle is a rectangular matrix of size NxM. A snake starts going down from the top-left corner and slithers its way down. The first cell is filled with the first symbol of the snake, the second cell is filled with the second symbol, etc. The snake is as long as it takes in order to fill the stairs completely – if you reach the end of the string representing the snake, start again at the beginning. After you fill the matrix with the snake’s path, you should print it.
//Input
//•	The input data should be read from the console. It consists of exactly two lines
//•	On the first line, you’ll receive the dimensions of the stairs in format: ""N M"", where N is the number of rows, and M is the number of columns. They’ll be separated by a single space
//•	On the second line you’ll receive the string representing the snake
//Output
//•	The output should be printed on the console. It should consist of N lines
//•	Each line should contain a string representing the respective row of the matrix
//Constraints
//•	The dimensions N and M of the matrix will be integers in the range [1 … 12]
//•	The snake will be a string with length in the range [1 … 20] and will not contain any whitespace characters
//Разхождате се в парка и срещате змия! Вие сте ужасени, и започвате да тичате зиг-заг, така че змията започва да ви следва.

//Имате задача да визуализирате пътя на змията в квадратна форма. Змия е представена от низ. На исляма е правоъгълна матрица с размер NxM.
//Змия започва да слиза от горния ляв ъгъл и се плъзга по пътя надолу. Първата клетка е изпълнена с първия символ на змията, втората клетка се пълни с втория символ и т.н.
//Змията е толкова дълга, колкото е необходимо, за да запълни стълбите напълно – ако стигнете до края на струната, представляваща змията, започнете отново в началото.
//След като запълните матрицата с пътя на змията, трябва да я отпечатате.

//Въвеждане
//·         Входните данни трябва да се четат от конзолата. Състои се от точно две линии

//·         На първия ред ще получите размерите на стълбите във формат: ""NM"", където N е броят на редовете , а M е броят на колоните. Те ще бъдат разделени с едно пространство

//·         На втория ред ще получите низът, представляващ змията

//Изход
//·         Изходът трябва да бъде отпечатан на конзолата. Тя трябва да се състои от N линии

//·         Всеки ред трябва да съдържа низ, представляващ съответния ред на матрицата

//Ограничения
//Размерите N и M на матрицата ще бъдат цяло число в диапазона [1 ... 12]
//Змията ще бъде низ с дължина в диапазона [1 ... 20] и няма да съдържа никакви знаци от whitespace

"
L0f3PMXK,Untitled,vvsvvs,C#,Wednesday 17th of May 2023 11:17:16 AM CDT,"using System;
using System.Linq;
using System.Text;

namespace _6._Jagged_Array_Manipulator
{
	class JaggedArrayManipulator
	{
		static void Main(string[] args)
		{
			int n = int.Parse(Console.ReadLine());

			double[][] matrix = new double[n][];

			for (int i = 0; i < n; i++)
			{
				double[] temp = Console.ReadLine().Split(' ', StringSplitOptions.RemoveEmptyEntries).Select(double.Parse).ToArray();
				matrix[i] = temp;
			}

			for (int row = 0; row < matrix.Length - 1; row++)
			{
				if (matrix[row].Length.Equals(matrix[row + 1].Length))
				{
					double[] temp = matrix[row].Select(x => x *= 2).ToArray();
					matrix[row] = temp;
					temp = matrix[row + 1].Select(x => x *= 2).ToArray();
					matrix[row + 1] = temp;
				}
				else
				{
					double[] temp = matrix[row].Select(x => x /= 2).ToArray();
					matrix[row] = temp;
					temp = matrix[row + 1].Select(x => x /= 2).ToArray();
					matrix[row + 1] = temp;
				}
			}

			bool isExitLoop = false;

			while (!isExitLoop)
			{
				string input = Console.ReadLine();

				if (input.ToLower().Equals(""end""))
				{
					isExitLoop = true;
				}
				else
				{
					string[] commands = input.Split(' ', StringSplitOptions.RemoveEmptyEntries);
					string command = commands[0];
					int newRow = int.Parse(commands[1]);
					int newCol = int.Parse(commands[2]);
					double newValue = double.Parse(commands[3]);

					bool isValidIndexes = ((newRow >= 0) && (newRow < matrix.Length));
					isValidIndexes = ((isValidIndexes) && (newCol >= 0) && (newCol < matrix[newRow].Length));

					if (isValidIndexes)
					{
						switch (command.ToLower())
						{
							case ""add"":
								matrix[newRow][newCol] += newValue;
								break;
							case ""subtract"":
								matrix[newRow][newCol] -= newValue;
								break;
							default:
								break;
						}
					}
				}
			}// while (!isExitLoop)



			StringBuilder sb = new StringBuilder();

			for (int row = 0; row < matrix.Length; row++)
			{
				sb.AppendLine(string.Join("" "", matrix[row]));
			}

			Console.WriteLine(sb.ToString());
		}
	}
}
//Create a program that populates, analyzes and manipulates the elements of a matrix with unequal length of its rows.
//First you will receive an integer N equal to the number of rows in your matrix.
//On the next N lines, you will receive sequences of integers, separated by a single space. Each sequence is a row in the matrix.
//After populating the matrix, start analyzing it. If a row and the one below it have equal length, multiply each element in both of them by 2, otherwise - divide by 2.
//Then, you will receive commands. There are three possible commands:
//•	""Add {row} {column} {value}"" - add { value}
//to the element at the given indexes, if they are valid
//•	""Subtract {row} {column} {value}"" - subtract {value} from the element at the given indexes, if they are valid
//•	""End"" - print the final state of the matrix (all elements separated by a single space) and stop the program
//Input
//•	On the first line, you will receive the number of rows of the matrix - integer N
//•	On the next N lines, you will receive each row - sequence of integers, separated by a single space
//•	{value} will always be integer number
//•	Then you will be receiving commands until reading ""End""
//Output
//•	The output should be printed on the console and it should consist of N lines
//•	Each line should contain a string representing the respective row of the final matrix, elements separated by a single space
//Constraints
//•	The number of rows N of the matrix will be integer in the range [2 … 12]
//•	The input will always follow the format above
//•	Think about data types
//Създайте програма, която попълва, анализира и манипулира елементите на матрица с неравна дължина на редовете си.
//Първо ще получите цяло число N, равно на броя редове във вашата матрица.
//На следващите N линиище получите поредици от цяло число, разделени с едно пространство. Всяка последователност е ред в матрицата.
//След като населите матрицата, започнете да я анализирате.
//Ако един ред и този под него имат равна дължина, умножете всеки елемент и в двете от тях по 2, в противен случай - разделете на 2.
//След това ще получите команди. Има три възможни команди:

//·         "" Добавяне на {ред} {колона} {стойност}"" - добавете { стойност}
//към елемента при дадените индекси, ако те са валидни

//·         "" Изваждане на {ред} {колона} {стойност}"" - изваждане на {стойност} от елемента при дадените индекси, ако те са валидни

//·         "" Край"" - отпечатайте крайното състояние на матрицата (всички елементи, разделени с едно пространство) и спрете програмата

//Въвеждане

//·         На първия ред ще получите броя на редовете на матрицата - цяло число N

//·         На следващите n линии ще получите всеки ред - последователност от цяло число, разделени с едно пространство

//·         {стойност} винаги ще бъде цяло число

//·         След това ще получавате команди, докато прочетете ""Край ""

//Изход

//·         Изходът трябва да бъде отпечатан на конзолата и тя трябва да се състои от N линии

//·         Всяка линия следва да съдържа низ, представляващ съответния ред на крайната матрица— елементи, разделени с едно пространство

//Ограничения

//Броят на редовете N на матрицата ще бъде цяло число в диапазона [2 ... 12]
//Входът винаги ще следва формата по-горе
//Помислете за типове данни

"
5GgUftjP,JF_VendingMachine,kolevra,Java,Wednesday 17th of May 2023 11:14:53 AM CDT,"package f05_12_Bascs_Ex;

import java.util.Scanner;

public class f07VendingMachine {
    public static void main(String[] args) {

        Scanner scanner = new Scanner(System.in);

        String input = scanner.nextLine();

        double totalInserted = 0.0;
        double totalPurchased = 0.0;

        while (!input.equals(""Start"")) {

            double coins = Double.parseDouble(input);

            if (coins == 0.1 || coins == 0.2 || coins == 0.5 || coins == 1 || coins == 2) {
                totalInserted += coins;
            } else {
                System.out.printf(""%nCannot accept %.2f%n"", coins);
            }

            input = scanner.nextLine();

        }

        String product = scanner.nextLine();

        while (!product.equals(""End"")) {

            double currentBuy = 0.0;
            boolean isProductValid = true;

            switch (product) {
                case ""Nuts"":
                    currentBuy = 2;
                    break;
                case ""Water"":
                    currentBuy = 0.7;
                    break;
                case ""Crisps"":
                    currentBuy = 1.5;
                    break;
                case ""Soda"":
                    currentBuy = 0.8;
                    break;
                case ""Coke"":
                    currentBuy = 1;
                    break;
                default:
                    System.out.println(""Invalid product"");
                    isProductValid = false;
                    break;
            }

            totalPurchased += currentBuy;

            if(totalPurchased <= totalInserted && isProductValid){
                System.out.printf(""Purchased %s%n"", product);
            } else if (isProductValid) {
                System.out.println(""Sorry, not enough money"");
                totalPurchased -= currentBuy;
            }

            product = scanner.nextLine();

        }

        System.out.printf(""Change: %.2f"", totalInserted - totalPurchased);

    }
}
"
9hPF0m6A,KDTree,matthesinator,C++,Wednesday 17th of May 2023 11:10:02 AM CDT,"bool KDTree::hasNearestTriangle(Vector<FLOAT,3> eye, Vector<FLOAT,3> direction, Triangle<FLOAT> *  & nearest_triangle,
                                FLOAT &t, FLOAT &u, FLOAT &v, FLOAT minimum_t) {
  if (!this->box.intersects(eye, direction)) {
    return false;
  }

  bool childrenHaveNearest = false;

  if (this->left && this->left->hasNearestTriangle(eye, direction, nearest_triangle, t, u, v, minimum_t)) {
    childrenHaveNearest = true;
	minimum_t = t;
  }

  if (this->right && this->right->hasNearestTriangle(eye, direction, nearest_triangle, t, u, v, minimum_t)) {
    childrenHaveNearest = true;
	minimum_t = t;
  }

  FLOAT local_t, local_u, local_v;
  FLOAT min_u, min_v;

  for (auto & triangle : this->triangles) {
    stats.no_ray_triangle_intersection_tests++;
    bool intersect = triangle->intersects(eye, direction, local_t, local_u, local_v, minimum_t);

    if (intersect) {
      stats.no_ray_triangle_intersections_found++;
      if ((nearest_triangle == nullptr) || (local_t < minimum_t)) {
        minimum_t = local_t;
        min_u = local_u;
        min_v = local_v;
        nearest_triangle = triangle;
      }
    }
  }

  if (minimum_t != INFINITY) {
    t = minimum_t;
    u = min_u;
    v = min_v;
  }
  // printf(""t: %f, u: %f, v: %f, min_t: %f\n"", t, u, v, minimum_t);
  return (nearest_triangle != nullptr) || childrenHaveNearest;
}
"
L1a5TzRc,Thing,jordan83221,Lua,Wednesday 17th of May 2023 10:35:48 AM CDT,"-- Structure of the player profile
local PlayerProfile = {
  -- General information
  id = """", -- Unique id of the player
  title = """",
  firstName = """",
  lastName = """",
  race = """",
  class = """",
  
  -- Physical attributes
  height = """",
  bodyType = """",
  sex = """",
  
  -- Custom sections
  about = """",
  kinks = """",
  
  -- Profile picture
  picture = """",
  
  -- Options
  options = {
    showProfile = true, -- If false, the profile won't be visible to other players
    showPicture = true, -- If false, the picture won't be visible to other players
    showKinks = false, -- If false, the kinks section won't be visible to other players
  }
}

-- Function to create a new profile
function NewProfile(id, title, firstName, lastName, race, class, height, bodyType, sex, about, kinks, picture, options)
  local profile = PlayerProfile
  profile.id = id
  profile.title = title
  profile.firstName = firstName
  profile.lastName = lastName
  profile.race = race
  profile.class = class
  profile.height = height
  profile.bodyType = bodyType
  profile.sex = sex
  profile.about = about
  profile.kinks = kinks
  profile.picture = picture
  profile.options = options
  return profile
end

-- Function to edit an existing profile
function EditProfile(profile, field, newValue)
  if profile[field] then
    profile[field] = newValue
  end
end

-- Function to view a profile
function ViewProfile(profile)
  -- Here you would implement the code to view the profile based on its data and options
end

-- Function to change profile options
function ChangeProfileOptions(profile, option, newValue)
  if profile.options[option] then
    profile.options[option] = newValue
  end
end

-- Structure of the database
local PlayerDatabase = {}

-- Function to add a profile to the database
function AddProfileToDatabase(profile)
  PlayerDatabase[profile.id] = profile
end

-- Function to remove a profile from the database
function RemoveProfileFromDatabase(id)
  PlayerDatabase[id] = nil
end

-- Function to search profiles in the database
function SearchProfiles(query)
  local results = {}
  for id, profile in pairs(PlayerDatabase) do
    if string.match(profile.firstName, query) or string.match(profile.lastName, query) then
      table.insert(results, profile)
    end
  end
  return results
end

-- Function to view a profile based on the id
function ViewProfile(id)
  local profile = PlayerDatabase[id]
  if profile and profile.options.showProfile then
    -- Here you would implement the code to view the profile based on its data and options
  end
end

-- Function to edit the 'About' section of a profile
function EditAboutSection(profile, newAboutText)
  profile.about = newAboutText
end

-- Function to edit the 'Kinks' section of a profile
function EditKinksSection(profile, newKinksText)
  profile.kinks = newKinksText
end

-- Function to change visibility of the 'About' section
function ChangeAboutVisibility(profile, visibility)
  profile.options.showAbout = visibility
end

-- Function to change visibility of the 'Kinks' section
function ChangeKinksVisibility(profile, visibility)
  profile.options.showKinks = visibility
end

-- Function to view the 'About' section of a profile
function ViewAboutSection(id)
  local profile = PlayerDatabase[id]
  if profile and profile.options.showAbout then
    -- Display the 'About' section of the profile
    return profile.about
  else
    -- Return a message indicating that the 'About' section is not visible
    return ""This section is not visible.""
  end
end

-- Function to view the 'Kinks' section of a profile
function ViewKinksSection(id)
  local profile = PlayerDatabase[id]
  if profile and profile.options.showKinks then
    -- Display the 'Kinks' section of the profile
    return profile.kinks
  else
    -- Return a message indicating that the 'Kinks' section is not visible
    return ""This section is not visible.""
  end
end
"
BJvEUnD8,VBA code for Delaunay and ConvexHull,Ben_S,VBScript,Wednesday 17th of May 2023 10:26:41 AM CDT,"Option Explicit

' VBA code for Delaunay and ConvexHull
' Created by auadmin on http://www.audeser.com/vba-delaunay-convexhull/
'
' The VBA formatting was scrambled so this is my attempt to sort it out.
' Ben Sacherich - 5/17/2023
' https://pastebin.com/BJvEUnD8
'
' Constant EPSILON was not defined.
' Function fQuickSortArrayDbl() was missing.
' Function fDistance2DPoints() was missing.
'

Public Type tXYZ
    x As Double
    y As Double
    Z As Double
End Type

Private Type tTriangle
    V1 As Long 'vertex1 pointer
    V2 As Long 'vertex2 pointer
    V3 As Long 'vertex3 pointer
    T1 As Long 'neighbour1 pointer
    T2 As Long 'neighbour2 pointer
    T3 As Long 'neighbour3 pointer
    
    Xmin As Double
    Ymin As Double
    Xmax As Double
    Ymax As Double
    
    Center As tXYZ
    R² As Double
End Type

Dim oT() As tTriangle
Dim oP() As tXYZ
Dim oTTmp As tTriangle
Dim aStack() As Long
Dim aBlnk() As Long
' Dim myFrm As UserForm     ' This is not used and won't compile so Ben commented it out.

Private Const PI_8th As Double = 0.392699081698724
Private Const PI As Double = 3.14159265358979

'# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
Const EPSILON = 1       ' ### Placeholder for missing code ###
        
Function fDistance2DPoints(x As tXYZ, y As tXYZ)
    ' ### Placeholder for missing function ###
    Stop
End Function
        
Function fQuickSortArrayDbl(arry As Variant, i, j, k, bAscendent As Boolean) As Variant
    ' ### Placeholder for missing function ###
    Stop
End Function
'# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

Private Function fDrawTriangles() As Boolean
' # This function is not used #
    Dim lgT As Long

    For lgT = LBound(oT) To UBound(oT)
        'Draw triangle in userform
        Call fDrawTriangle(lgT)
    Next lgT
End Function

Private Function fDrawTriangle(ByVal lgT As Long) As Boolean
' # This function is not used #

    'Draw triangle in userform
    'Call fDrawLine(oP(oT(lgT).V1), oP(oT(lgT).V2))
    'Call fDrawLine(oP(oT(lgT).V2), oP(oT(lgT).V3))
    'Call fDrawLine(oP(oT(lgT).V3), oP(oT(lgT).V1))
End Function

Private Function fDrawLine(ByVal lgP1 As Long, ByVal lgP2 As Long) As Boolean
' # This function was missing but is not needed. #
End Function

Private Function fPointsSort(ByRef oP() As tXYZ, _
                             Optional ByRef bX As Boolean = True, _
                             Optional ByRef bAscendent As Boolean = True) As Boolean
    Dim oPtTmp() As tXYZ
    Dim arrPtr() As Double 'tPointer
    Dim lgP As Long

    ReDim arrPtr(LBound(oP) To UBound(oP), 1 To 2)
    If bX Then
    ' Sort by X
        For lgP = LBound(oP) To UBound(oP)
            arrPtr(lgP, 1) = VBA.CLng(lgP) 'Index
            arrPtr(lgP, 2) = oP(lgP).x     'Value
        Next lgP
    Else
    ' Sort by Y
        For lgP = LBound(oP) To UBound(oP)
            arrPtr(lgP, 1) = VBA.CLng(lgP) 'Index
            arrPtr(lgP, 2) = oP(lgP).y     'Value
        Next lgP
    End If
    Call fQuickSortArrayDbl(arrPtr(), -1, -1, 2, bAscendent)

    oPtTmp() = oP() ' copy source
    For lgP = LBound(oP) To UBound(oP)
        oP(lgP) = oPtTmp(arrPtr(lgP, 1))
    Next lgP
    Erase arrPtr()
    Erase oPtTmp()

End Function

Private Function fPoints(ByRef oP() As tXYZ) As Long
    If Not (Not oP) Then
        fPoints = UBound(oP) - LBound(oP) + 1
    Else
        fPoints = 0
    End If
End Function

Private Function fPointsFlip(ByRef oP() As tXYZ) As Boolean
    Dim oPTmp() As tXYZ
    Dim lgP As Long
    
    If Not (Not oP) Then
        oPTmp() = oP()
        ReDim Preserve oP(LBound(oP) To UBound(oP) - 1)
        For lgP = LBound(oP) To UBound(oP)
            oPTmp(UBound(oP) - lgP) = oP(lgP)
        Next lgP
        oP() = oPTmp()
        Erase oPTmp()
    End If
End Function

Private Function fPointRemove(ByRef oP() As tXYZ, ByVal lgP As Long) As Boolean
    Dim oPTmp() As tXYZ
    Dim lgRemove As Long
    
    If Not (Not oP) Then
        oPTmp() = oP()
        ReDim Preserve oPTmp(LBound(oP) To UBound(oP) - 1)
        For lgRemove = (UBound(oP) - 1) To lgP Step -1
            oPTmp(lgRemove) = oP(lgRemove + 1)
        Next lgRemove
        oP() = oPTmp()
        Erase oPTmp()
    End If
End Function

Private Function fPointAdd(ByRef oP() As tXYZ, ByRef oPt As tXYZ) As Boolean
    If Not (Not oP) Then
        ReDim Preserve oP(LBound(oP) To UBound(oP) + 1)
    Else
        ReDim Preserve oP(0)
    End If
    oP(UBound(oP)) = oPt
End Function

Private Function fConvexHull() As tXYZ()
' Graham-Scan
' https://www.geeksforgeeks.org/convex-hull-set-2-graham-scan/
' The algorithm can be adapted to a 3D space, considering these:
' - the four points A, B, C, D become eight
' - the quadrilateral becomes a polyhedron with eight vertices
' - the rectangle becomes a parallelepiped
    
    Dim oP´() As tXYZ
    Dim oP´´() As tXYZ
    Dim oPrun() As tXYZ
    Dim oPrun´() As tXYZ
    Dim oHull() As tXYZ
    Dim lgDecalageRGT As Long
    Dim lgP As Long
    Dim lgPts As Long
    Dim lgTop As Long
    Dim lgPrun´ As Long
    Dim lgPrun´´ As Long
    Dim bPrun As Boolean
    Dim bPrint As Boolean: bPrint = False
bPrint = False
    If fPoints(oP) = 0 Then
    ' Get list of points...
        Call sPointsRnd(100000000, 0, 1000, 0, 1000)
Call fPointsPrint(oP(), 1, 2, 1, -1, -1, bPrint)
    End If

Dim dtTimer As Date
dtTimer = VBA.Now()
    
    oPrun() = fPrunePolygon(oP())
Call fPointsPrint(oPrun(), 3, 4, 1, -1, -1, bPrint)
    
    ' Get rectangle R:
    ' X1 = Max(Dx, Ax)
    ' X2 = Min(Bx, Cx)
    ' Y1 = Max(By, Ay)
    ' Y2 = Min(Cy, Dy)
    ' Rectangle R with vertices: (x2, y1), (x2, y2), (x1, y2), (x1, y1)
    
    oPrun´() = oPrun()
    If oPrun(0).x < oPrun(3).x Then oPrun´(0).x = oPrun(3).x Else oPrun´(3).x = oPrun(0).x 'maxX A-D If oPrun(1).X > oPrun(2).X Then oPrun´(1).X = oPrun(2).X Else oPrun´(2).X = oPrun(1).X 'minX B-C
    If oPrun(0).y < oPrun(1).y Then oPrun´(0).y = oPrun(1).y Else oPrun´(1).y = oPrun(0).y 'maxY A-B If oPrun(2).Y > oPrun(3).Y Then oPrun´(2).Y = oPrun(3).Y Else oPrun´(3).Y = oPrun(2).Y 'minY C-D
Call fPointsPrint(oPrun´(), 5, 6, 1, -1, -1, bPrint)
    
    '#1st pass
    Erase oP´()
    oP´() = oP()
    oP´´() = oP()
    lgPrun´ = LBound(oP´´) - 1
    lgPrun´´ = LBound(oP´´) - 1
    For lgP = LBound(oP) To UBound(oP)
        bPrun = False
        If oPrun´(0).x > oP(lgP).x Then
            lgPrun´´ = lgPrun´´ + 1
            oP´´(lgPrun´´) = oP(lgP)
        ElseIf oPrun´(0).y > oP(lgP).y Then
            lgPrun´´ = lgPrun´´ + 1
            oP´´(lgPrun´´) = oP(lgP)
        ElseIf oPrun´(2).x < oP(lgP).x Then
            lgPrun´´ = lgPrun´´ + 1
            oP´´(lgPrun´´) = oP(lgP)
        ElseIf oPrun´(2).y < oP(lgP).y Then
            lgPrun´´ = lgPrun´´ + 1
            oP´´(lgPrun´´) = oP(lgP)
        Else
            lgPrun´ = lgPrun´ + 1
            oP´(lgPrun´) = oP(lgP)
        End If
    Next lgP
    ReDim Preserve oP´(0 To lgPrun´) ' outside R
    ReDim Preserve oP´´(0 To lgPrun´´) ' inside R
    Call fPointsPrint(oP´(), 7, 8, 1, -1, -1, bPrint)
    Call fPointsPrint(oP´´(), 9, 10, 1, -1, -1, bPrint) '#2nd pass
    lgPrun´´ = LBound(oP´´) - 1
    For lgP = LBound(oP´´) To UBound(oP´´)
    If Not fPointInsidePolygon(oP´´(lgP), oPrun()) Then
        lgPrun´´ = lgPrun´´ + 1
        oP´´(lgPrun´´) = oP´´(lgP)
    End If
    Next lgP
    ReDim Preserve oP´´(0 To lgPrun´´) ' outside Q
    Call fPointsPrint(oP´´(), 11, 12, 1, -1, -1, bPrint)
    Call fPointsSort(oP´´(), False, True)
    ReDim Preserve oHull(LBound(oP´´) To UBound(oP´´)) ' Pick the bottom-most (choose the left-most point in case of tie)
    oHull(LBound(oP)) = oP´´(LBound(oP´´))
    lgPts = LBound(oP´´) ' Right side hull
    
    For lgP = (LBound(oP´´) + 1) To UBound(oP´´)
    
    '!Do While (UBound(oHull) >= 1)
        Do While (lgPts >= 2)
            ' If two or more points make same angle with p0, remove all but the one that is farthest from p0
            ' (in above sorting our criteria was to keep the farthest point at the end)
            '!If CCW(oHull(UBound(oHull) - 1), oHull(UBound(oHull)), oP´´(lgP)) Then Exit Do
            If CCW(oHull(lgPts - 2), oHull(lgPts - 1), oP´´(lgP)) Then Exit Do
            
            'Remove UBound(oHull) point from oHull()
            '!ReDim Preserve oHull(LBound(oHull) To UBound(oHull) - 1)
            lgPts = lgPts - 1
        Loop
        
        'Add Point oP´´(lgP) to oHull()
        '!ReDim Preserve oHull(LBound(oHull) To UBound(oHull) + 1)
        '!oHull(UBound(oHull)) = oP´´(lgP)
        oHull(lgPts) = oP´´(lgP)
        lgPts = lgPts + 1
    Next lgP
    
    ' Left side hull
    lgTop = lgPts
    For lgP = (UBound(oP´´) - 1) To LBound(oP´´) Step -1
        '!Do While (UBound(oHullLFT) >= 1)
        Do While (lgPts > lgTop)
            '!If CCW(oHullLFT(UBound(oHullLFT) - 1), oHullLFT(UBound(oHullLFT)), oP´´(lgP)) Then Exit Do
            If CCW(oHull(lgPts - 2), oHull(lgPts - 1), oP´´(lgP)) Then Exit Do
        
            'Remove UBound(oHull) point from oHull()
            '!ReDim Preserve oHullLFT(LBound(oHullLFT) To UBound(oHullLFT) - 1)
            lgPts = lgPts - 1
        Loop
    
        'Add Point oP´´(lgP) to oHull()
        '!ReDim Preserve oHullLFT(LBound(oHullLFT) To UBound(oHullLFT) + 1)
        '!oHullLFT(UBound(oHullLFT)) = oP´´(lgP)
        oHull(lgPts) = oP´´(lgP)
        lgPts = lgPts + 1
    Next lgP
        
    ReDim Preserve oHull(LBound(oHull) To lgPts - 1)
Call fPointsPrint(oHull(), 13, 14, 1, -1, -1, bPrint)
    
    fConvexHull = oHull()
    'Erase oHull()
Call fPointsPrint(oHull(), 15, 16, 1, -1, -1, bPrint)
Debug.Print dtTimer & "" vs "" & VBA.Now()
End Function

Private Function fPointsPrint(ByRef oP() As tXYZ, _
                              Optional ByVal lC_X As Long = 1, _
                              Optional ByVal lC_Y As Long = 2, _
                              Optional ByVal lR_Start As Long = 1, _
                              Optional ByVal lgP_Start As Long = -1, _
                              Optional ByVal lgP_End As Long = -1, _
                              Optional ByVal bPrint = False) As Boolean
    Dim lgP As Long
    Dim lgR As Long
    
    If Not bPrint Then Exit Function
    
    If lgP_Start < LBound(oP) Then lgP_Start = LBound(oP)
    If lgP_End < LBound(oP) Then lgP_End = UBound(oP)
    lgR = lR_Start
    If lgP_Start <= lgP_End Then
        For lgP = lgP_Start To lgP_End
            Cells(lgR, lC_X).Value2 = oP(lgP).x
            Cells(lgR, lC_Y).Value2 = oP(lgP).y
            lgR = lgR + 1
        Next lgP
    Else 'descending
        For lgP = lgP_Start To lgP_End Step -1
            Cells(lgR, lC_X).Value2 = oP(lgP).x
            Cells(lgR, lC_Y).Value2 = oP(lgP).y
            lgR = lgR + 1
        Next lgP
    End If
End Function

Private Function fPointInsidePolygon(ByRef oPoint As tXYZ, ByRef oPolygon() As tXYZ) As Boolean
    Dim lgP As Long
    Dim iInside As Integer
    
    ' Avoid no segment (coincident points)
    For lgP = LBound(oPolygon) To UBound(oPolygon) - 1
        If oPolygon(lgP).x = oPolygon(lgP + 1).x And oPolygon(lgP).y = oPolygon(lgP + 1).y Then
            Call fPointRemove(oPolygon(), lgP)
        End If
    Next lgP
    
    iInside = fLineSide(oPoint, oPolygon(LBound(oPolygon)), oPolygon(LBound(oPolygon) + 1))
    For lgP = LBound(oPolygon) + 1 To UBound(oPolygon) - 1
        If iInside <> fLineSide(oPoint, oPolygon(lgP), oPolygon(lgP + 1)) Then Exit Function
    Next lgP
    If oPolygon(LBound(oPolygon)).x <> oPolygon(UBound(oPolygon)).x Or oPolygon(LBound(oPolygon)).y <> oPolygon(UBound(oPolygon)).y Then
        If iInside <> fLineSide(oPoint, oPolygon(UBound(oPolygon)), oPolygon(LBound(oPolygon))) Then Exit Function
    End If
    fPointInsidePolygon = True
End Function

Private Function NewPoint(Optional ByVal x As Double = 0, _
                          Optional ByVal y As Double = 0, _
                          Optional ByVal Z As Double = 0) As tXYZ
    With NewPoint
        .x = x
        .y = y
        .Z = Z
    End With
End Function

Private Function fPrunePolygon(ByRef oP() As tXYZ) As tXYZ()
'   A, B, C, D As Points
'   Q As Quadrilateral
'   R As Rectangle
'   DD As Diamond [(Xmid, Ymin)
'
'   for each Point p in oP
'         Update A, B, C, D --> Q
'   # First pass
'   Create R from Q
'   for each Point p in S
'      if p inside R
'         prune p from S
'   # Second pass
'   for each Point p in S
'      if p inside Q
'         prune p from S

'   ^         D    / +\
'   |           /....  + \
'   |        /  / Q x....   \ C
'   |     /    /---------....| \
'   |  /      /|   *     *   |    \
'   |  \     /x|*    R  *  * | +  /
'   |     \ /..|.....--------|  /
'   |      A \        ..x...|/ B
'   |           \ +  +   /
'   |              \  /
'   --------------------------->
'
'   * points inside R rectangle are prunable
'   x point inside Q are prunable but not until the end
'   + point outside Q are not prunable
'
    If fPoints(oP) = 0 Then
    ' Get list of points...
        Call sPointsRnd(300, 0, 100, 0, 100)
    End If
    
    Dim PtA As tXYZ, PtB As tXYZ, PtC As tXYZ, PtD As tXYZ
    Dim Q(0 To 3) As tXYZ 'Quadrilateral
    Dim R(0 To 3) As tXYZ 'Rectangle
    Dim DD(0 To 3) As tXYZ  'Diamond

    Dim lgP As Long

    Q(0) = oP(LBound(oP)): Q(1) = Q(0): Q(2) = Q(0): Q(3) = Q(0)
    For lgP = LBound(oP) To UBound(oP)
        With Q(0) ' Point A
            If (-.x - .y) < (-oP(lgP).x - oP(lgP).y) Then Q(0) = oP(lgP)
        End With
        With Q(1) ' Point B
            If (.x - .y) < (oP(lgP).x - oP(lgP).y) Then Q(1) = oP(lgP)
        End With
        With Q(2) ' Point C
            If (.x + .y) < (oP(lgP).x + oP(lgP).y) Then Q(2) = oP(lgP)
        End With
        With Q(3) ' Point D
            If (-.x + .y) < (-oP(lgP).x + oP(lgP).y) Then Q(3) = oP(lgP)
        End With
    Next lgP

    fPrunePolygon = Q()
End Function

Private Sub sPointsRnd(Optional ByVal lgPts As Long = 0, _
                       Optional ByVal Xmin As Double = 0, _
                       Optional ByVal Xmax As Double = 0, _
                       Optional ByVal Ymin As Double = 0, _
                       Optional ByVal Ymax As Double = 0)
    Dim lgP As Long
    Dim dbTmp As Long

    If Xmin = 0 Then Xmin = (Rnd() * 100) + 0
    If Xmax = 0 Then Xmax = (Rnd() * 100) + 0
    If Ymin = 0 Then Ymin = (Rnd() * 100) + 0
    If Ymax = 0 Then Ymax = (Rnd() * 100) + 0
    If Xmax < Xmin Then
        Xmax = dbTmp
        Xmax = Xmin
        Xmin = dbTmp
    End If
    If Ymax < Ymin Then
        Ymax = dbTmp
        Ymax = Ymin
        Ymin = dbTmp
    End If
    ReDim Preserve oP(0 To lgPts - 1)
    For lgP = LBound(oP) To UBound(oP)
        oP(lgP) = NewPoint((Rnd() * Xmax - Xmin) + Xmin, (Rnd() * Ymax - Ymin) + Ymin)
    Next lgP
End Sub

Private Sub sDelaunay()
    Dim oChrt As Excel.ChartObject
    Dim rgData As Excel.Range
    Dim aData As Variant
    Dim lgP As Long
    Dim lgT As Long
    Dim lgTs As Long ' total number of triangles
    Dim Xmin As Double, Ymin As Double
    Dim Xmax As Double, Ymax As Double
    Dim Xmid As Double, Ymid As Double
    Dim HSide As Double, VSide As Double
    Dim i12 As Integer, i23 As Integer, i31 As Integer
    Dim bDalaunay As Boolean
    
    ' Elements are sorted by X
    With ActiveSheet
        Call sPointsCreate(10)
        Set rgData = .Range(""A1"", .Range(""B1"", .Range(""B1"").End(xlDown)))
    End With
    aData = rgData.Value2
    'ReDim oP(0 To 2 + (UBound(aData, 1) - LBound(aData, 1) + 1))
    ReDim aStack(LBound(oP) To UBound(oP)) As Long
    ReDim aBlnk(LBound(oP) To UBound(oP)) As Long
    
    For lgP = LBound(oP) + 3 To UBound(oP)
        With oP(lgP)
            '.X = aData(lgP - 2, 1)
            '.Y = aData(lgP - 2, 2)
            If .x < Xmin Then Xmin = .x
            If .x > Xmax Then Xmax = .x
            If .y < Ymin Then Ymin = .y
            If .y > Ymax Then Ymax = .y
        End With
    Next lgP
    
    lgT = -1
    
    ' Generate the super-triangle
    Xmid = 0.5 * (Xmax + Xmin)
    Ymid = 0.5 * (Ymax + Ymin)
    HSide = 2 * (Xmid - Xmin)
    VSide = 2 * (Ymid - Ymin)
    With oP(LBound(oP) + 0)
        .x = Xmid - (3 * HSide)
        .y = Ymid - (3 * VSide)
    End With
    With oP(LBound(oP) + 1)
        .x = Xmid
        .y = Ymid + (3 * VSide)
    End With
    With oP(LBound(oP) + 2)
        .x = Xmid + (3 * HSide)
        .y = Ymid - (3 * VSide)
    End With
    
    Set oChrt = ActiveSheet.ChartObjects(""ChrtPts"")
    Call fChrtSeriesDelete(oChrt)

    ' Add supertriangle points
    Call fChrtTriangleAdd(oP(LBound(oP) + 0), _
                          oP(LBound(oP) + 1), _
                          oP(LBound(oP) + 2), _
                          oChrt)
    
    lgT = lgT + 1
    lgTs = lgT
    ReDim Preserve oT(0 To lgT)
    With oT(lgT)
        .T1 = -1
        .T2 = -2
        .T3 = -3
    
        .V1 = LBound(oP) + 0
        .V2 = LBound(oP) + 1
        .V3 = LBound(oP) + 2
    End With
    
    ' Get new max-min coordinates...
'    Call fTriangleParameters(lgT)

    ' Generate new triangles:
    For lgP = LBound(oP) + 3 To UBound(oP)
        Call fChrtPtHighlight(oChrt, 1, lgP - 3 + 1, True)
        'Call fChrtPtAdd(oP(lgP), oChrt)

        For lgT = LBound(oT) To UBound(oT)
            ' Discard point inside boundary
            If oP(lgP).x < oT(lgT).Xmax Then
            If oP(lgP).x > oT(lgT).Xmin Then
            If oP(lgP).y < oT(lgT).Ymax Then
            If oP(lgP).y > oT(lgT).Ymin Then
                ' Point is inside boundary of triangle, so check more intensively
                i12 = fLineSide(oP(lgP), oP(oT(lgT).V2), oP(oT(lgT).V1))
                i23 = fLineSide(oP(lgP), oP(oT(lgT).V3), oP(oT(lgT).V2))
                i31 = fLineSide(oP(lgP), oP(oT(lgT).V1), oP(oT(lgT).V3))
                
                If (i12 = i23 And i23 = i31) Then
                    ReDim Preserve oT(0 To lgTs + 2)
                    ' Always store points in Counter-clockwise order (last point is new point)
                    With oT(lgTs + 1)
                        .T1 = oT(lgT).T2
                        .T2 = lgTs + 2
                        .T3 = lgT
                    
                        .V1 = oT(lgT).V2
                        .V2 = oT(lgT).V3
                        .V3 = lgP
                    
                        ' Add supertriangle points
                        Call fChrtTriangleAdd(oP(.V1), _
                                              oP(.V2), _
                                              oP(.V3), _
                                              ActiveSheet.ChartObjects(""ChrtPts""))
                    End With
                    
                    With oT(lgTs + 2)
                        .T1 = oT(lgT).T3
                        .T2 = lgT
                        .T3 = lgTs + 1
                    
                        .V1 = oT(lgT).V3
                        .V2 = oT(lgT).V1
                        .V3 = lgP
                        
                        ' Add supertriangle points
                        Call fChrtTriangleAdd(oP(.V1), _
                                              oP(.V2), _
                                              oP(.V3), _
                                              ActiveSheet.ChartObjects(""ChrtPts""))
                    End With
                    
                    ' Reformat initial triangle
                    With oT(lgT)
                        '.T1 = oT(lgT).T1 ' this neighbour is not rewritten
                        .T2 = lgTs + 1
                        .T3 = lgTs + 2
                    
                        '.V1 = .V1 ' this vertex is not rewritten
                        '.V2 = .V2 ' this vertex is not rewritten
                        .V3 = lgP
                    End With
                    
                    ' Get new max-min coordinates for final triangles...
'                    Call fTriangleParameters(lgT)
'                    Call fTriangleParameters(lgTs + 1)
'                    Call fTriangleParameters(lgTs + 2)
                    
                    lgTs = lgTs + 2
    
                    ' Is the optimum delaunay?
                    ' Each new triangle has three neighbours that have to be checked for Delaunay condition
                    ' For Neighbour triangle 1
                    'call fDelaunay(lgT, oT(lgT).T1)
                    
                    ' For Neighbour triangle 2
                    'call fDelaunay(lgT, oT(lgT).T2)
                    
                    ' For Neighbour triangle 3
                    'Call fDelaunay(lgT, oT(lgT).T3)
                    
                    Exit For ' Goto NextTriangle
                End If
            End If
            End If
            End If
            End If
        Next lgT
        
        Call fChrtPtHighlight(oChrt, 1, lgP - 3, False)
    Next lgP

    ' Delete triangles on the supertriangle structure
    Dim oT_() As tTriangle: oT_() = oT()
    For lgT = LBound(oT) To UBound(oT)
        With oT(lgT)
            If .V1 >= 0 And _
               .V2 >= 0 And _
               .V3 >= 0 Then
               'lgT_ = lgT_ + 1
               'oT_(0 to lgT) = oT(lgT)
            End If
        End With
    Next lgT
    'Redim preserve oT_(0 to lgT_)
    'oT() = oT_()
    'Erase oT_()
Stop
End Sub

Private Function fDelaunay(ByVal lgT1 As Long, _
                           ByVal lgT2 As Long) As Boolean
    Dim bSwap            As Boolean
    Dim TPtrTmp          As Long

    ' Rotate vertices of both triangles so in both triangles vertices 3 are opposed
    If oT(lgT1).V1 = oT(lgT2).V2 And oT(lgT1).V2 = oT(lgT2).V1 Then
        ' Do nothing...
    ElseIf oT(lgT1).V1 = oT(lgT2).V1 And oT(lgT1).V2 = oT(lgT2).V3 Then
        ' rotate 2 clockwise
        Call fTriangleRotate(lgT2, False)
    ElseIf oT(lgT1).V1 = oT(lgT2).V3 And oT(lgT1).V2 = oT(lgT2).V2 Then
        ' rotate 2 counter-clockwise
        Call fTriangleRotate(lgT2, True)
        '--
    ElseIf oT(lgT1).V2 = oT(lgT2).V1 And oT(lgT1).V3 = oT(lgT2).V3 Then
        ' rotate 1 counter-clockwise
        Call fTriangleRotate(lgT1, True)
        ' rotate 2 clockwise
        Call fTriangleRotate(lgT2, False)
    ElseIf oT(lgT1).V2 = oT(lgT2).V2 And oT(lgT1).V3 = oT(lgT2).V1 Then
        ' rotate 1 counter-clockwise
        Call fTriangleRotate(lgT1, True)
    ElseIf oT(lgT1).V2 = oT(lgT2).V3 And oT(lgT1).V3 = oT(lgT2).V2 Then
        ' rotate 1 counter-clockwise
        Call fTriangleRotate(lgT1, True)
        ' rotate 2 counter-clockwise
        Call fTriangleRotate(lgT2, True)
        '--
    ElseIf oT(lgT1).V3 = oT(lgT2).V1 And oT(lgT1).V1 = oT(lgT2).V3 Then
        ' rotate 1 clockwise
        Call fTriangleRotate(lgT1, False)
        ' rotate 2 clockwise
        Call fTriangleRotate(lgT2, False)
    ElseIf oT(lgT1).V3 = oT(lgT2).V2 And oT(lgT1).V1 = oT(lgT2).V1 Then
        ' rotate 1 clockwise
        Call fTriangleRotate(lgT1, False)
    ElseIf oT(lgT1).V3 = oT(lgT2).V3 And oT(lgT1).V1 = oT(lgT2).V2 Then
        ' rotate 1 clockwise
        Call fTriangleRotate(lgT1, False)
        ' rotate 2 counter-clockwise
        Call fTriangleRotate(lgT2, True)
    End If

    If fDistance2DPoints(oP(oT(lgT2).V2), oT(lgT1).Center) < EPSILON Then
        bSwap = True
        TPtrTmp = oT(lgT1).T2    'Destroy oT(lgT1).T1 and oT(lgT2).T1
        oT(lgT1).T1 = oT(lgT2).T2
        oT(lgT1).T2 = lgT2 'oT(lgT1).T3 = does not change
        oT(lgT2).T1 = TPtrTmp
        oT(lgT2).T2 = lgT1 'oT(lgT2).T3 = does not change
        ' Swap vertices
        oT(lgT1).V2 = oT(lgT2).V3
        oT(lgT2).V2 = oT(lgT1).V3
    End If
    If bSwap Then
        Call fTriangleParameters(lgT1)
        Call fTriangleParameters(lgT2) '
        'Call fDelaunay(lgT1, oT(lgT1).T1) Then
        'Call fDelaunay(lgT1, oT(lgT1).T2) Then
        'Call fDelaunay(lgT1, oT(lgT1).T3) Then '
        'Call fDelaunay(lgT2, oT(lgT2).T1) Then
        'Call fDelaunay(lgT2, oT(lgT2).T2) Then
        'Call fDelaunay(lgT2, oT(lgT2).T3) Then
    Else
        fDelaunay = True
    End If
End Function
        
Private Function fTriangleRotate(ByRef lgT As Long, Optional ByVal bCCW As Boolean = True) As Boolean
' Given a triangle, rotate vertices oTTmp = oT(lgT)
        
    With oT(lgT)
        If bCCW Then ' counter-clockwise
            .V1 = oTTmp.V2
            .V2 = oTTmp.V3
            .V3 = oTTmp.V1
            .T1 = oTTmp.T2
            .T2 = oTTmp.T3
            .T3 = oTTmp.T1
        Else
            .V1 = oTTmp.V3
            .V2 = oTTmp.V1
            .V3 = oTTmp.V2
            .T1 = oTTmp.T3
            .T2 = oTTmp.T1
            .T3 = oTTmp.T2
        End If
    End With
End Function

Private Function fDelaunayDiagonal(ByRef lgT1 As Long, ByRef lgT2 As Long) As Boolean
' Given two triangles, find the opposed vertices
' Rotate triangles so the 3 vertices are opposed...
    Dim dX1 As Double, dY1 As Double
    Dim dX2 As Double, dY2 As Double
    dX1 = oP(oT(lgT1).V3).x - oP(oT(lgT2).V3).x
    dY1 = oP(oT(lgT1).V3).y - oP(oT(lgT2).V3).y
    dX2 = oP(oT(lgT1).V1).x - oP(oT(lgT2).V2).x
    dY2 = oP(oT(lgT1).V1).y - oP(oT(lgT2).V2).y
    If ((dX1 * dX1) + (dY1 * dY1)) > ((dX2 * dX2) + (dY2 * dY2)) Then
        Call fSwapDiagonal(lgT1, lgT2)
    End If
'    End If
End Function

Private Function fSwapDiagonal(ByRef lgT1 As Long, _
                               ByRef lgT2 As Long) As Boolean
' For given diagonal D1 on triangle T1 = diagonal D2 on triangle T2, will swap diagonals with opposed vertices
' Rotate triangles so the 3 vertices are opposed...
    Dim TPtrTmp As Long

    With oT(lgT1)
        TPtrTmp = .T2
        
        'Destroy oT(lgT1).T1 and oT(lgT2).T1
        .T1 = oT(lgT2).T2
        .T2 = lgT2
        '.T3 = does not change
    End With
    
    With oT(lgT2)
        .T1 = TPtrTmp
        .T2 = lgT1
        '.T3 = does not change
    End With
    
    ' Swap vertices
    oT(lgT1).V2 = oT(lgT2).V3
    oT(lgT2).V2 = oT(lgT1).V3

End Function

Private Function fNeigbourSide(ByRef iSide As Integer, _
                               ByRef lgT1 As Long, _
                               ByRef lgT2 As Long) As Integer
' For given iSide on triangle1, return neighbour side on triangle2.
' Both triangles turn the same: 1->2->3
    
    If iSide = 1 Then
        If oT(lgT1).V1 = oT(lgT2).V1 Then
'            fNeigbourSide = 3
        ElseIf oT(lgT1).V1 = oT(lgT2).V2 Then
'            fNeigbourSide = 2
        ElseIf oT(lgT1).V1 = oT(lgT2).V3 Then
'            fNeigbourSide = 1
        End If
    ElseIf iSide = 2 Then
        If oT(lgT1).V2 = oT(lgT2).V1 Then
'            fNeigbourSide = 3
        ElseIf oT(lgT1).V2 = oT(lgT2).V2 Then
'            fNeigbourSide = 2
        ElseIf oT(lgT1).V2 = oT(lgT2).V3 Then
'            fNeigbourSide = 1
        End If
    ElseIf iSide = 3 Then
        If oT(lgT1).V3 = oT(lgT2).V1 Then
'            fNeigbourSide = 3
        ElseIf oT(lgT1).V3 = oT(lgT2).V2 Then
'            fNeigbourSide = 2
        ElseIf oT(lgT1).V3 = oT(lgT2).V3 Then
'            fNeigbourSide = 1
        End If
    End If
End Function

Private Function fTriangleFromPoints(ByRef oP1 As tXYZ, _
                                     ByRef oP2 As tXYZ, _
                                     ByRef oP3 As tXYZ) As tTriangle
    With fTriangleFromPoints
        .V1 = 1
        .V2 = 2
        .V3 = 3
        
        .T1 = -1
        .T2 = -2
        .T3 = -3
        
        .Xmin = oP1.x
        .Xmax = oP1.x
        .Ymin = oP1.y
        .Ymax = oP1.y
    
        If .Xmin > oP2.x Then .Xmin = oP2.x
        If .Xmin > oP3.x Then .Xmin = oP3.x
        If .Xmax < oP2.x Then .Xmax = oP2.x
        If .Xmax < oP3.x Then .Xmax = oP3.x
        If .Ymin > oP2.y Then .Ymin = oP2.y
        If .Ymin > oP3.y Then .Ymin = oP3.y
        If .Ymax < oP2.y Then .Ymax = oP2.y
        If .Ymax < oP3.y Then .Ymax = oP3.y
        Dim B As tXYZ
        Dim C As tXYZ
        Dim D As Double
        Dim Bx² As Double
        Dim By² As Double
        Dim Cx² As Double
        Dim Cy² As Double
        
        B.x = oP2.x - oP1.x
        B.y = oP2.y - oP1.y
        C.x = oP3.x - oP1.x
        C.y = oP3.y - oP1.y
        Bx² = B.x * B.x: By² = B.y * B.y
        Cx² = C.x * C.x: Cy² = C.y * C.y
        D = 1 / (2 * (B.x * C.y - B.y * C.x))
        .Center.x = D * (C.y * (Bx² + By²) - B.y * (Cx² + Cy²))
        .Center.y = D * (B.x * (Cx² + Cy²) - C.x * (Bx² + By²))
        .R² = (.Center.x * .Center.x) + (.Center.y * .Center.y)
        .Center.x = .Center.x + oP1.x
        .Center.y = .Center.y + oP1.y
    End With
    
End Function

Private Function fTriangleParameters(ByRef lgT As Long) As Boolean
    With oT(lgT)
        .Xmin = oP(.V1).x
        .Xmax = oP(.V1).x
        .Ymin = oP(.V1).y
        .Ymax = oP(.V1).y
        If .Xmin > oP(.V2).x Then .Xmin = oP(.V2).x
        If .Xmin > oP(.V3).x Then .Xmin = oP(.V3).x
        If .Xmax < oP(.V2).x Then .Xmax = oP(.V2).x
        If .Xmax < oP(.V3).x Then .Xmax = oP(.V3).x
        If .Ymin > oP(.V2).y Then .Ymin = oP(.V2).y
        If .Ymin > oP(.V3).y Then .Ymin = oP(.V3).y
        If .Ymax < oP(.V2).y Then .Ymax = oP(.V2).y
        If .Ymax < oP(.V3).y Then .Ymax = oP(.V3).y
        
        .Center = Circumcenter(oP(.V1).x, oP(.V1).y, oP(.V2).x, oP(.V2).y, oP(.V3).x, oP(.V3).y)
        .R² = (.Center.x - oP(.V1).x) ^ 2 + (.Center.y - oP(.V1).y) ^ 2
        
        'Dim B As tXYZ
        'Dim C As tXYZ
        'Dim D As Double
        'Dim Bx² As Double
        'Dim By² As Double
        'Dim Cx² As Double
        'Dim Cy² As Double
        '
        'B.X = oP(.V2).X - oP(.V1).X
        'B.Y = oP(.V2).Y - oP(.V1).Y
        'C.X = oP(.V3).X - oP(.V1).X
        'C.Y = oP(.V3).Y - oP(.V1).Y
        'Bx² = B.X * B.X: By² = B.Y * B.Y
        'Cx² = C.X * C.X: Cy² = C.Y * C.Y
        'D = 1 / (2 * (B.X * C.Y - B.Y * C.X))
        '.Center.X = D * (C.Y * (Bx² + By²) - B.Y * (Cx² + Cy²))
        '.Center.Y = D * (B.X * (Cx² + Cy²) - C.X * (Bx² + By²))
        '.R² = (.Center.X * .Center.X) + (.Center.Y * .Center.Y)
        '.Center.X = .Center.X + oP(.V1).X
        '.Center.Y = .Center.Y + oP(.V1).Y
    End With
End Function

Private Function Circumcenter(ByVal x1 As Double, ByVal y1 As Double, _
                              ByVal x2 As Double, ByVal y2 As Double, _
                              ByVal x3 As Double, ByVal y3 As Double) As tXYZ
    Dim A As Double
    Dim B As Double
    Dim C As Double
    Dim D As Double

    A = x1 * x1 + y1 * y1
    B = x2 * x2 + y2 * y2
    C = x3 * x3 + y3 * y3
    D = 2 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))
    
    If D <> 0 Then
        With Circumcenter
            .x = (A * (y2 - y3) + B * (y3 - y1) + C * (y1 - y2)) / D
            .y = (A * (x3 - x2) + B * (x1 - x3) + C * (x2 - x1)) / D
        End With
    End If
End Function

Private Sub sLineSide()
    Dim oPoint As tXYZ, oPt1 As tXYZ, oPt2 As tXYZ

    With oPoint
        .x = 1
        .y = -1
    End With
    With oPt1
        .x = 0
        .y = 0
    End With
    With oPt2
        .x = 10
        .y = 0
    End With
    Debug.Print fLineSide(oPoint, oPt1, oPt2)
End Sub

Private Function CCW(ByRef oPt1 As tXYZ, _
                     ByRef oPt2 As tXYZ, _
                     ByRef oPt3 As tXYZ) As Boolean
' If counter clock-wise, then CCW is true
    CCW = ((oPt2.x - oPt1.x) * (oPt3.y - oPt1.y)) > ((oPt2.y - oPt1.y) * (oPt3.x - oPt1.x))
End Function

Private Function fLineSide(ByRef oPoint As tXYZ, _
                           ByRef oPt1 As tXYZ, _
                           ByRef oPt2 As tXYZ) As Integer
' Use the sign of the determinant of vectors (AB,AM), where M(X,Y) is the query point:
' Position = Sign((Bx - Ax) * (Y - Ay) - (By - Ay) * (X - Ax))
' It is 0 on the line, and -1 on right side, +1 on the left side.
    
    fLineSide = VBA.Sgn((oPt2.x - oPt1.x) * (oPoint.y - oPt1.y) - (oPt2.y - oPt1.y) * (oPoint.x - oPt1.x))

End Function

Private Function fChrtSeriesDelete(ByVal oChrt As Excel.ChartObject)
    Dim lgSeries As Long
    
    With oChrt
        With .Chart.SeriesCollection
            For lgSeries = .Count To 2 Step -1
                oChrt.Chart.SeriesCollection(lgSeries).Delete
            Next lgSeries
        End With
    End With
End Function

Private Function fChrtCircleAdd(ByRef oCenter As tXYZ, _
                                ByRef Radius As Double, _
                                Optional ByVal oChrt As Excel.ChartObject) As Boolean
    Dim oSeries As Excel.Series
    Dim lgAngle As Long
    Dim dbAngleRAD As Double
    Dim strX As String
    Dim strY As String
    
    With oChrt
        With .Chart
            Set oSeries = .SeriesCollection.NewSeries
            With oSeries
                For lgAngle = 0 To 17
                    dbAngleRAD = lgAngle * PI_8th
                    strX = strX & Replace(oCenter.x + Radius * Cos(dbAngleRAD), "","", ""."") & "",""
                    strY = strY & Replace(oCenter.y + Radius * Sin(dbAngleRAD), "","", ""."") & "",""
                Next lgAngle
                strX = VBA.Left$(strX, Len(strX) - 1)
                strY = VBA.Left$(strY, Len(strY) - 1)
                .XValues = ""={"" & strX & ""}""
                .Values = ""={"" & strY & ""}""
                With .Format.Line
                    .Visible = msoTrue
                    '.ForeColor.ObjectThemeColor = msoThemeColorAccent1
                    '.ForeColor.TintAndShade = 0
                    '.ForeColor.Brightness = 0
                    .Weight = 0.25
                    .Visible = msoTrue
                    .DashStyle = msoLineSysDash
                End With
            End With
        End With
    End With
End Function

Private Function fChrtTriangleAdd(ByRef oPt1 As tXYZ, _
                                  ByRef oPt2 As tXYZ, _
                                  ByRef oPt3 As tXYZ, _
                                  Optional ByVal oChrt As Excel.ChartObject) As Boolean
    Dim oSeries As Excel.Series
    
    With oChrt
        With .Chart
            Set oSeries = .SeriesCollection.NewSeries
            With oSeries
                .XValues = ""={"" & Replace(oPt1.x, "","", ""."") & "","" & Replace(oPt2.x, "","", ""."") & "","" & Replace(oPt3.x, "","", ""."") & "","" & Replace(oPt1.x, "","", ""."") & ""}""
                .Values = ""={"" & Replace(oPt1.y, "","", ""."") & "","" & Replace(oPt2.y, "","", ""."") & "","" & Replace(oPt3.y, "","", ""."") & "","" & Replace(oPt1.y, "","", ""."") & ""}""
                With .Format.Line
                    .Visible = msoTrue
                    .Weight = 0.25
                    .DashStyle = msoLineSysDash
                    '.ForeColor.ObjectThemeColor = msoThemeColorAccent1
                    '.ForeColor.TintAndShade = 0
                    '.ForeColor.Brightness = 0
                End With
            End With
        End With
    End With
End Function

Private Function fChrtPtAdd(ByRef oPt As tXYZ, _
                            Optional ByVal oChrt As Excel.ChartObject)
    Dim oSeries As Excel.Series
    
    With oChrt
        With .Chart
            Set oSeries = .SeriesCollection.NewSeries
            With oSeries
                .XValues = ""={"" & Replace(oPt.x, "","", ""."") & ""}""
                .Values = ""={"" & Replace(oPt.y, "","", ""."") & ""}""
                With .Format.Fill
                    .Visible = msoTrue
                    .ForeColor.RGB = RGB(255, 0, 0)
                    '.ForeColor.ObjectThemeColor = msoThemeColorAccent1
                    '.ForeColor.TintAndShade = 0
                    '.ForeColor.Brightness = 0
                End With
            End With
        End With
    End With
End Function

Private Function fChrtPtHighlight(ByVal oChrt As Excel.ChartObject, _
                                  ByVal lgSeries As Long, _
                                  ByVal lgData As Long, _
                                  Optional ByVal bActive As Boolean = False)
    With oChrt
        With .Chart.FullSeriesCollection(lgSeries).Points(lgData)
            With .Format
                With .Fill
                    .Visible = msoTrue
                    If bActive Then
                        .ForeColor.RGB = RGB(255, 0, 0)
                    Else
                        .ForeColor.ObjectThemeColor = msoThemeColorAccent1
                        '.ForeColor.TintAndShade = 0
                        '.ForeColor.Brightness = 0
                    End If
                    .Transparency = 0
                    .Solid
                End With
            End With
            
            '.ApplyDataLabels
        End With
    End With
End Function

Private Sub sPointsCreate(ByVal lgPoints As Long)
    Dim Xmin As Double, Ymin As Double
    Dim Xmax As Double, Ymax As Double
    Dim lgPoint As Long
    Dim dX As Double, dY As Double
    Dim lgR As Long
    Dim rgData As Excel.Range
    Dim XValue As Excel.Range
    Dim YValue As Excel.Range
    Dim oChrt As Excel.ChartObject

    ' Create points and print out to range
    With ActiveSheet
        Xmin = 0
        Xmax = 1000
        Ymin = 0
        Ymax = 1000
        dX = (Xmax - Xmin)
        dY = (Ymax - Ymin)
        ReDim oP(0 To 2 + lgPoints)
        
        For lgPoint = 3 To (lgPoints - 1) + 3
            oP(lgPoint).x = Xmin + (Rnd() * dX)
            oP(lgPoint).y = Ymin + (Rnd() * dY)
            lgR = lgPoint - 1 + 3
            .Cells(lgR, 1).Value2 = oP(lgPoint).x
            .Cells(lgR, 2).Value2 = oP(lgPoint).y
        Next lgPoint
        
        Set XValue = .Range(""A1"", .Range(""A1"", .Range(""A1"").End(xlDown)))
        'XValue.Select
        Set YValue = .Range(""B1"", .Range(""B1"", .Range(""B1"").End(xlDown)))
        'YValue.Select
        Set rgData = Union(XValue, YValue)
    
        ' Sort points by X
        Call fPointsSort(oP(), True, True)
        With .Sort
        '    .SortFields.Clear
        '    .SortFields.Add _
                Key:=rgData, _
                SortOn:=xlSortOnValues, _
                Order:=xlAscending, _
                DataOption:=xlSortNormal
            
        '    .SetRange rgData
        '    .Header = xlGuess
        '    .MatchCase = False
        '    .Orientation = xlTopToBottom
        '    .SortMethod = xlPinYin
        '    '.Apply
        End With
        
        ' Create chart
        'Set oChrt = .Shapes.AddChart2(240, xlXYScatter).ChartObject
        With .Shapes.AddChart2(240, xlXYScatter)
            .Name = ""ChrtPts""
            .Left = ActiveSheet.Range(""C1"").Left
            .Top = ActiveSheet.Range(""C1"").Top
            
            .Height = 800
            .Width = 800
            With .Chart
                With .PlotArea
                    '.Height = 700
                    '.Width = 700
                End With

                .SetSourceData Source:=rgData
                .ChartTitle.Delete
                With .Axes(xlValue)
                    '.MinimumScaleIsAuto = True
                    '.MaximumScaleIsAuto = True
                    .MinimumScale = 0
                    .MaximumScale = 1000
                    .MajorUnit = 250
                    .MinorUnit = 50
                End With
                With .Axes(xlCategory)
                    '.MinimumScaleIsAuto = True
                    '.MaximumScaleIsAuto = True
                    .MinimumScale = 0
                    .MaximumScale = 1000
                    .MajorUnit = 250
                    .MinorUnit = 50
                End With
            End With
        End With
    End With
End Sub

'-----------------------------------------
'   T E S T    F U N C T I O N S
'-----------------------------------------

Private Sub sTestPoint()
    Dim oTriangle1 As tTriangle
    Dim oTriangle2 As tTriangle
    Dim oP() As tXYZ
    Dim lgP As Long

    'Set oChrt = ActiveSheet.ChartObjects(""ChrtPts"")
    
    'Call sPointsCreate(4)
    
    ReDim oP(1 To 4)
    oP(1) = NewPoint(50, 1000)
    oP(2) = NewPoint(500, 3200)
    oP(3) = NewPoint(-2000, 3500)
    oP(4) = NewPoint(-2000, -3500)

    For lgP = LBound(oP) To UBound(oP)
        Cells(lgP, 1).Value2 = oP(lgP).x
        Cells(lgP, 2).Value2 = oP(lgP).y
    Next lgP

    oTriangle1 = fTriangleFromPoints(oP(1), oP(2), oP(3))
    With oTriangle1
        .V1 = 1
        .V2 = 2
        .V3 = 3
    End With
    
    Call fChrtTriangleAdd(oP(1), _
                          oP(2), _
                          oP(3), _
                          ActiveSheet.ChartObjects(""ChrtPts""))
    
    oTriangle2 = fTriangleFromPoints(oP(3), oP(2), oP(1))
    With oTriangle2
        .V1 = 3
        .V2 = 2
        .V3 = 4
    End With
    Call fChrtTriangleAdd(oP(3), _
                          oP(2), _
                          oP(4), _
                          ActiveSheet.ChartObjects(""ChrtPts""))
    
    'Call fChrtCircleAdd(oTriangle.Center, _
                        Sqr(oTriangle.R²), _
                        ActiveSheet.ChartObjects(""ChrtPts""))
Stop
End Sub

'----------------------------------------------
'    T E S T
'----------------------------------------------

Private Function xTriangle(ByRef oP1 As tXYZ, ByRef oP2 As tXYZ, ByRef oP3 As tXYZ) As tXYZ
    With xTriangle
        Dim B As tXYZ
        Dim C As tXYZ
        Dim D As Double
        Dim Bx² As Double
        Dim By² As Double
        Dim Cx² As Double
        Dim Cy² As Double
        
        B.x = oP2.x - oP1.x
        B.y = oP2.y - oP1.y
        C.x = oP3.x - oP1.x
        C.y = oP3.y - oP1.y
        Bx² = B.x * B.x: By² = B.y * B.y
        Cx² = C.x * C.x: Cy² = C.y * C.y
        D = (2 * (B.x * C.y - B.y * C.x))
        If D <> 0 Then
            D = 1 / D
            .x = D * (C.y * (Bx² + By²) - B.y * (Cx² + Cy²))
            .y = D * (B.x * (Cx² + Cy²) - C.x * (Bx² + By²))
            '.R² = (.Center.X * .Center.X) + (.Center.Y * .Center.Y)
            .x = .x + oP1.x
            .y = .y + oP1.y
        End If
    End With
End Function

Sub sTestingPerformance()
    Dim lgT As Long
    Dim dtDate As Date
    Dim oP1 As tXYZ, oP2 As tXYZ, oP3 As tXYZ
    Dim T As Single
    T = Timer

    oP1 = NewPoint(50, 1000)
    oP2 = NewPoint(500, 3200)
    oP3 = NewPoint(-2000, 3500)
    
    'dtDate = VBA.Now()
    For lgT = 1 To 1000000000
        Call xTriangle(oP1, oP2, oP3)
    Next lgT
    Debug.Print ""Completed processing "" & lgT - 1 & "" iterations in "" & Round(Timer - T, 2) & "" seconds.""
    'Debug.Print dtDate & ""  --- "" & VBA.Now()
    Debug.Print
    Beep
    
End Sub
"
cqVrMy6s,Untitled,vvsvvs,C#,Wednesday 17th of May 2023 10:23:38 AM CDT,"using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;

namespace _02._Armory
{
    public class Point : IComparable<Point>
    {
        public int Row { get; set; }
        public int Col { get; set; }

        public Point(int newRow, int newCol)
        {
            this.Row = newRow;
            this.Col = newCol;
        }// Point(int newRow, int NewCol)

        public int CompareTo(Point other)
        {
            int comp = this.Row.CompareTo(other.Row);

            if (comp == 0)
            {
                comp = this.Col.CompareTo(other.Col);
            }

            return comp;
        }// int CompareTo(Point other)
    }// class Point : IComparable<Point>

    public class Matrix<T> where T : IComparable<T>
    {
        private T[][] matrix;
        private Point startPoint;
        private Point currentPoint;
        private Point chekPoint;
        private T startElement;
        private int maxLengthRow;
        private int currentRowLength;
        private string spaceSeparator;

        public Point StartPoint
        {
            get => this.startPoint;

            private set
            {

            }
        }

        public Point CurrentPoint
        {
            get => this.currentPoint;

            set
            {
                bool isValid = ((value.Row >= 0) && (value.Row < this.MaxLengthRow));
                isValid = ((isValid) && (value.Col >= 0) && (value.Col < this.matrix[value.Row].Length));

                if (isValid)
                {
                    this.currentPoint = value;
                }
                else
                {
                    throw new IndexOutOfRangeException();
                }
            }
        }

        public Point ChekPoint
        {
            get => this.chekPoint;

            set
            {
                bool isValid = ((value.Row >= 0) && (value.Row < this.MaxLengthRow));
                isValid = ((isValid) && (value.Col >= 0) && (value.Col < this.matrix[value.Row].Length));

                if (isValid)
                {
                    this.chekPoint = value;
                }
                else
                {
                    throw new IndexOutOfRangeException();
                }
            }
        }

        public int MaxLengthRow
        {
            get => this.maxLengthRow;

            private set
            {

            }
        }

        public int CurrentRowLength
        {
            get => this.currentRowLength;
            private set
            {

            }
        }

        public Matrix(string newSpaceSeparator, int newRow, int newCol = 0)
        {
            this.CreateMatrix(null, newSpaceSeparator, newRow, newCol);
        }// Matrix(string newSpaceSeparator, int newRow, int newCol = 0)

        public Matrix(T[,] newMatrix, string newSpaceSeparator)
        {
            int newRow = newMatrix.GetLength(0);
            int newCol = newMatrix.GetLength(1);

            this.CreateMatrix(newMatrix, newSpaceSeparator, newRow, newCol);
        }// Matrix(T[,] newMatrix, string newSpaceSeparator)                 

        public void SetStartElement(T element)
        {
            this.startElement = element;
            this.SetStartPoint(this.startElement);
        }// void SetStartElement(T element)

        public void SetStartPoint(T newStartElement)
        {
            this.startElement = newStartElement;

            bool isLoopExit = false;
            int row = 0;

            while ((row < MaxLengthRow) && (!isLoopExit))
            {
                int col = 0;

                while ((col < this.matrix[row].Length) && (!isLoopExit))
                {
                    if (this.matrix[row][col].Equals(newStartElement))
                    {
                        this.startPoint = new Point(row, col);
                        isLoopExit = true;
                    }

                    col++;
                }

                row++;
            }

            this.SetStartToCurrentPoint();
        }// void SetStartPoint(T startElement)

        public void SetStartToCurrentPoint()
        {
            this.CurrentPoint = new Point(this.startPoint.Row, this.startPoint.Col);
        }// void SetCurrentPoint()

        public void SetMatrixRow(int row, T[] colArr)
        {
            this.matrix[row] = colArr;

            this.SetLength();
        }// void SetMatrixRow(int row, T[] colArr)

        public void SetCurrentElement(T element)
        {
            this.matrix[currentPoint.Row][currentPoint.Col] = element;
        }// void SetCurrentElement(T element)

        public T GetCurrentElement() => this.matrix[currentPoint.Row][currentPoint.Col];// T GetCurrentElement()

        public void SetElementAtPosition(T element, Point point)
        {
            this.matrix[point.Row][point.Col] = element;
        }// void SetElementAtPosition(T element, Point point)

        public T GetElementAtPosition(Point point) => this.matrix[point.Row][point.Col];// T GetElementAtPosition(Point point)

        public void SetSpaceSeparator(string newSpaceSeparator)
        {
            this.spaceSeparator = newSpaceSeparator;
        }// void SetSpaceSeparator(string newSpaceSeparator)

        public IEnumerable<Point> FoundAllElementPositions(T element)
        {
            Queue<Point> result = new Queue<Point>();

            for (int row = 0; row < this.matrix.Length; row++)
            {
                int maxCol = this.matrix[row].Length;

                for (int col = 0; col < maxCol; col++)
                {
                    if (this.matrix[row][col].Equals(element))
                    {
                        Point newPoint = new Point(row, col);
                        result.Enqueue(newPoint);
                    }
                }
            }

            return result;
        }// Queue<Point> FoundAllElementPositions(T element)

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();

            for (int row = 0; row < this.maxLengthRow; row++)
            {
                StringBuilder temp = new StringBuilder();

                int colLessOne = this.matrix[row].Length - 1;

                for (int col = 0; col < colLessOne + 1; col++)
                {
                    if (col == colLessOne)
                    {
                        temp.Append(this.matrix[row][col].ToString());
                    }
                    else
                    {
                        temp.Append(this.matrix[row][col].ToString() + this.spaceSeparator);
                    }
                }

                sb.AppendLine(temp.ToString());
            }

            return sb.ToString().TrimEnd();
        }// override string ToString()    

        public string GetChessCoordinates(Point position) => $""{((char)((int)'a' + position.Col)).ToString()}{position.Row + 1}"";//string GetChessCoordinates(Point position)

        public Point ChangeCurrentPosition(Point newPoint, int stepRow, int stepCol)
        {
            Point result = null;
            if (this.currentPoint.Row == newPoint.Row)
            {
                result = new Point(newPoint.Row, this.matrix[this.currentPoint.Row].Length + (-1) * newPoint.Col * stepCol);
            }
            else if (currentPoint.Col == newPoint.Col)
            {
                result = new Point(this.MaxLengthRow + (-1) * newPoint.Row * stepRow, newPoint.Col);
            }

            return result;
        }// Point ChangeCurrentPosition(Point newPoint)

        private void CreateMatrix(T[,] newMatrix, string newSpaceSeparator, int newRow, int newCol)
        {
            this.matrix = new T[newRow][];

            if (newMatrix == null)
            {
                for (int row = 0; row < newRow; row++)
                {
                    T[] temp = new T[newCol];
                    this.matrix[row] = temp;
                }
            }
            else
            {
                for (int row = 0; row < newRow; row++)
                {
                    T[] temp = new T[newCol];
                    this.matrix[row] = temp;

                    for (int col = 0; col < newCol; col++)
                    {
                        this.matrix[row][col] = newMatrix[row, col];
                    }
                }
            }

            this.SetLength();
            this.SetSpaceSeparator(newSpaceSeparator);
        }// void CreateMatrix(T[,] newMatrix, int newRow, int newCol, string newSpaceSeparator)

        private void SetLength()
        {
            this.maxLengthRow = this.matrix.Length;
        }// void SetLength()

        public int GetCurrentCol(int row)
        {
            this.SetCurrentCol(row);
            return this.CurrentRowLength;
        }// int GetCurrentCol(int row)

        private void SetCurrentCol(int row)
        {
            this.CurrentRowLength = this.matrix[row].Length;
        }// void SetCurrentCol(int row)
    }// class Matrix<T>


    class Armory
    {
        static void Main(string[] args)
        {
            const char FREE_SYMBOL = '-';
            const char MIRROR_SYMBOL = 'M';
            const char OFFICER_SYMBOL = 'A';

            int n = int.Parse(Console.ReadLine());

            Matrix<char> armory = new Matrix<char>(string.Empty, n, n);

            for (int row = 0; row < n; row++)
            {
                armory.SetMatrixRow(row, Console.ReadLine().ToCharArray());
            }

            Point mirrorPoint1 = new Point(-1, -1);
            Point mirrorPoint2 = new Point(-1, -1);
            int mirrorCount = 0;

            Queue<Point> mirrorPoints = armory.FoundAllElementPositions(MIRROR_SYMBOL) as Queue<Point>;

            while (mirrorPoints.Count > 0)
            {
                Point temp = mirrorPoints.Dequeue();
                if (mirrorCount == 0)
                {
                    mirrorPoint1 = new Point(temp.Row, temp.Col);
                    mirrorCount++;
                }
                else
                {
                    mirrorPoint2 = new Point(temp.Row, temp.Col);
                }
            }

            armory.SetStartElement(OFFICER_SYMBOL);

            bool isLoopExit = false;

            int currentSels = 0;

            StringBuilder sb = new StringBuilder();

            while (!isLoopExit)
            {
                string direction = Console.ReadLine();

                int stepRow = 0;
                int stepCol = 0;
                Point currentPoint = armory.CurrentPoint;

                switch (direction.ToLower())
                {
                    case ""up"":
                        stepRow = -1;
                        break;
                    case ""down"":
                        stepRow = 1;
                        break;
                    case ""left"":
                        stepCol = -1;
                        break;
                    case ""right"":
                        stepCol = 1;
                        break;
                    default:
                        continue;
                }

                try
                {
                    armory.SetCurrentElement(FREE_SYMBOL);
                    Point newPoint = new Point(currentPoint.Row + stepRow, currentPoint.Col + stepCol);
                    armory.CurrentPoint = newPoint;
                    currentPoint = armory.CurrentPoint;

                    if (currentPoint.CompareTo(mirrorPoint1) == 0)
                    {
                        armory.SetCurrentElement(FREE_SYMBOL);
                        armory.CurrentPoint = mirrorPoint2;
                        armory.SetCurrentElement(FREE_SYMBOL);
                        currentPoint = armory.CurrentPoint;

                        mirrorPoint1 = new Point(-1, -1);
                        mirrorPoint2 = new Point(-1, -1);


                    }
                    else if (currentPoint.CompareTo(mirrorPoint2) == 0)
                    {
                        armory.SetCurrentElement(FREE_SYMBOL);
                        armory.CurrentPoint = mirrorPoint1;
                        armory.SetCurrentElement(FREE_SYMBOL);
                        currentPoint = armory.CurrentPoint;

                        mirrorPoint1 = new Point(-1, -1);
                        mirrorPoint2 = new Point(-1, -1);
                    }

                    if (char.IsDigit(armory.GetCurrentElement()))
                    {
                        currentSels += int.Parse(armory.GetCurrentElement().ToString());
                        armory.SetCurrentElement(FREE_SYMBOL);

                        if (currentSels >= 65)
                        {
                            armory.SetCurrentElement(OFFICER_SYMBOL);
                            isLoopExit = true;
                            sb.AppendLine(""Very nice swords, I will come back for more!"");
                        }
                    }
                }

                catch (IndexOutOfRangeException)
                {
                    isLoopExit = true;
                    sb.AppendLine(""I do not need more swords!"");
                }

            }

            sb.AppendLine($""The king paid {currentSels} gold coins."");

            Console.WriteLine(sb.ToString().TrimEnd());

            Console.WriteLine(armory);
        }
    }
}"
NM74jYfU,pasztet by Jerzy Ulepszony,0lszowm,C++,Wednesday 17th of May 2023 10:16:48 AM CDT,"/*
 * Example of a basic FreeRTOS queue
 * https://www.freertos.org/Embedded-RTOS-Queues.html
 */

// Include Arduino FreeRTOS library
#include <Arduino_FreeRTOS.h>

// Include queue support
#include <queue.h>

// Define a struct
struct pinRead {
  int pin;
  int value;
};

// Define a struct for personal data
struct PersonalData {
  char firstName[50];
  char lastName[50];
  int birthYear;
};

/* 
 * Declaring a global variable of type QueueHandle_t 
 * 
 */
QueueHandle_t structQueue;

// Declare global variables
QueueHandle_t personalDataQueue;
QueueHandle_t ageQueue;

// Declare task function for personal data input
void TaskInputPersonalData(void *pvParameters);
void TaskCalculateAge(void *pvParameters);
void TaskPrintData(void *pvParameters);

void setup() {

  /**
   * Create a queue.
   * https://www.freertos.org/a00116.html
   */
  structQueue = xQueueCreate(10, // Queue length
                              sizeof(struct pinRead) // Queue item size
                              );
  // Create personal data queue
  personalDataQueue = xQueueCreate(1, sizeof(struct PersonalData));
  // Create age queue
  ageQueue = xQueueCreate(1, sizeof(int));
  
  if (personalDataQueue != NULL && ageQueue != NULL) {
    // Create task for inputting personal data
    xTaskCreate(TaskInputPersonalData, ""InputData"", 128, NULL, 1, NULL);
    // Create task for calculating age
    xTaskCreate(TaskCalculateAge, ""CalculateAge"", 128, NULL, 2, NULL);
    // Create task for printing data
    xTaskCreate(TaskPrintData, ""PrintData"", 128, NULL, 3, NULL);
  }
  
  if (structQueue != NULL) {
    
  }

}

void loop() {}



// Function for inputting personal data
void TaskInputPersonalData(void *pvParameters) {
  (void)pvParameters;

  // Initialize Arduino serial
  Serial.begin(9600);

  // Wait for serial port to connect
  while (!Serial) {
    vTaskDelay(1);
  }

  // Create a struct to hold the personal data
  struct PersonalData inputData;

  // Prompt the user to enter their first name
  Serial.println(""Enter your first name:"");
  while (Serial.available() == 0) {
    vTaskDelay(1);
  }
  // Read the input from Serial Monitor and store it in the struct
  String firstName = Serial.readString();
  firstName.toCharArray(inputData.firstName, sizeof(inputData.firstName));

  // Prompt the user to enter their last name
  Serial.println(""Enter your last name:"");
  while (Serial.available() == 0) {
    vTaskDelay(1);
  }
  // Read the input from Serial Monitor and store it in the struct
  String lastName = Serial.readString();
  lastName.toCharArray(inputData.lastName, sizeof(inputData.lastName));

  // Prompt the user to enter their birth year
  Serial.println(""Enter your birth year:"");
  while (Serial.available() == 0) {
    vTaskDelay(1);
  }
  // Read the input from Serial Monitor and store it in the struct
  String birthYearString = Serial.readString();
  inputData.birthYear = birthYearString.toInt();

  // Send the personal data struct to the queue
  xQueueSend(personalDataQueue, &inputData, portMAX_DELAY);

  // End the task
  vTaskDelete(NULL);
}

// Function for calculating age
void TaskCalculateAge(void *pvParameters) {
  (void)pvParameters;

  for (;;) {
    // Wait for personal data to be available in the queue
    struct PersonalData inputData;
    if (xQueueReceive(personalDataQueue, &inputData, portMAX_DELAY) == pdPASS) {
      // Calculate the age based on the birth year
      int currentYear = 2023;  // Change to the current year
      int age = currentYear - inputData.birthYear;

      // Send the calculated age to the age queue
      xQueueSend(ageQueue, &age, portMAX_DELAY);
    }
  }
}

// Function for printing data
void TaskPrintData(void *pvParameters) {
  (void)pvParameters;

  // Initialize Arduino serial
  Serial.begin(9600);

  // Wait for serial port to connect
  while (!Serial) {
    vTaskDelay(1);
  }

  for (;;) {
    // Wait for personal data and age to be available in the queues
    struct PersonalData inputData;
    int age;
    if (xQueueReceive(personalDataQueue, &inputData, portMAX_DELAY) == pdPASS &&
        xQueueReceive(ageQueue, &age, portMAX_DELAY) == pdPASS) {
      // Print the personal data and age
      Serial.print(""First Name: "");
      Serial.println(inputData.firstName);
      Serial.print(""Last Name: "");
      Serial.println(inputData.lastName);
      Serial.print(""Birth Year: "");
      Serial.println(inputData.birthYear);
      Serial.print(""Age: "");
      Serial.println(age);
    }
  }
}
"
75dNemgP,Untitled,vvsvvs,C#,Wednesday 17th of May 2023 10:15:00 AM CDT,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Beaver_Work
{
    public class Point : IComparable<Point>
    {
        public int Row { get; set; }
        public int Col { get; set; }

        public Point(int newRow, int newCol)
        {
            this.Row = newRow;
            this.Col = newCol;
        }

        public int CompareTo(Point other)
        {
            int comp = this.Row.CompareTo(other.Row);

            if (comp == 0)
            {
                comp = this.Col.CompareTo(other.Col);
            }

            return comp;
        }
    }

    public class Matrix<T> where T : IComparable<T>
    {
        private T[][] matrix;
        private Point startPoint;
        private Point currentPoint;
        private Point chekPoint;
        private T startElement;
        private int maxLengthRow;
        private int currentRowLength;
        private string spaceSeparator;
        public Point StartPoint
        {
            get => this.startPoint;

            private set
            {

            }
        }

        public Point CurrentPoint
        {
            get => this.currentPoint;

            set
            {
                if (this.IsValidIndex(value))
                {
                    this.currentPoint = value;
                }
                else
                {
                    throw new IndexOutOfRangeException();
                }
            }
        }

        public Point ChekPoint
        {
            get => this.chekPoint;

            set
            {
                if (this.IsValidIndex(value))
                {
                    this.chekPoint = value;
                }
                else
                {
                    throw new IndexOutOfRangeException();
                }
            }
        }

        public bool IsValidIndex(Point point)
        {
            bool isValid = ((point.Row >= 0) && (point.Row < this.MaxLengthRow));
            isValid = ((isValid) && (point.Col >= 0) && (point.Col < this.matrix[point.Row].Length));

            return isValid;
        }

        public int MaxLengthRow
        {
            get => this.maxLengthRow;

            private set
            {

            }
        }

        public int CurrentRowLength
        {
            get => this.currentRowLength;
            private set
            {

            }
        }

        public Matrix(string newSpaceSeparator, int newRow, int newCol = 0)
        {
            this.CreateMatrix(null, newSpaceSeparator, newRow, newCol);
        }

        public Matrix(T[,] newMatrix, string newSpaceSeparator)
        {
            int newRow = newMatrix.GetLength(0);
            int newCol = newMatrix.GetLength(1);

            this.CreateMatrix(newMatrix, newSpaceSeparator, newRow, newCol);
        }

        public void SetStartElement(T element)
        {
            this.startElement = element;
            this.SetStartPoint(this.startElement);
        }

        public void SetStartPoint(T newStartElement)
        {
            this.startElement = newStartElement;

            bool isLoopExit = false;
            int row = 0;

            while ((row < MaxLengthRow) && (!isLoopExit))
            {
                int col = 0;

                while ((col < this.matrix[row].Length) && (!isLoopExit))
                {
                    if (this.matrix[row][col].Equals(newStartElement))
                    {
                        this.startPoint = new Point(row, col);
                        isLoopExit = true;
                    }

                    col++;
                }

                row++;
            }

            this.SetStartToCurrentPoint();
        }

        public void SetStartToCurrentPoint()
        {
            this.CurrentPoint = new Point(this.startPoint.Row, this.startPoint.Col);
        }

        public void SetMatrixRow(int row, T[] colArr)
        {
            this.matrix[row] = colArr;

            this.SetLength();
        }

        public void SetCurrentElement(T element)
        {
            this.matrix[currentPoint.Row][currentPoint.Col] = element;
        }

        public T GetCurrentElement() => this.matrix[currentPoint.Row][currentPoint.Col];

        public void SetElementAtPosition(T element, Point point)
        {
            this.matrix[point.Row][point.Col] = element;
        }

        public T GetElementAtPosition(Point point) => this.matrix[point.Row][point.Col];

        public void SetSpaceSeparator(string newSpaceSeparator)
        {
            this.spaceSeparator = newSpaceSeparator;
        }

        public IEnumerable<Point> FoundAllElementPositions(T element)
        {
            Queue<Point> result = new Queue<Point>();

            for (int row = 0; row < this.matrix.Length; row++)
            {
                int maxCol = this.matrix[row].Length;

                for (int col = 0; col < maxCol; col++)
                {
                    if (this.matrix[row][col].Equals(element))
                    {
                        Point newPoint = new Point(row, col);
                        result.Enqueue(newPoint);
                    }
                }
            }

            return result as IEnumerable<Point>;
        }

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();

            for (int row = 0; row < this.maxLengthRow; row++)
            {
                StringBuilder temp = new StringBuilder();

                int colLessOne = this.matrix[row].Length - 1;

                for (int col = 0; col < colLessOne + 1; col++)
                {
                    if (col == colLessOne)
                    {
                        temp.Append(this.matrix[row][col].ToString());
                    }
                    else
                    {
                        temp.Append(this.matrix[row][col].ToString() + this.spaceSeparator);
                    }
                }

                sb.AppendLine(temp.ToString());
            }

            return sb.ToString().TrimEnd();
        }

        public string GetChessCoordinates(Point position) => $""{((char)((int)'a' + position.Col)).ToString()}{position.Row + 1}"";

        public Point ChangeCurrentPosition(Point newPoint, int stepRow, int stepCol)
        {
            Point result = null;
            if (this.currentPoint.Row == newPoint.Row)
            {
                result = new Point(newPoint.Row, this.matrix[this.currentPoint.Row].Length + (-1) * newPoint.Col * stepCol);
            }
            else if (currentPoint.Col == newPoint.Col)
            {
                result = new Point(this.MaxLengthRow + (-1) * newPoint.Row * stepRow, newPoint.Col);
            }

            this.CurrentPoint = result;

            return result;
        }

        private void CreateMatrix(T[,] newMatrix, string newSpaceSeparator, int newRow, int newCol)
        {
            this.matrix = new T[newRow][];

            if (newMatrix == null)
            {
                for (int row = 0; row < newRow; row++)
                {
                    T[] temp = new T[newCol];
                    this.matrix[row] = temp;
                }
            }
            else
            {
                for (int row = 0; row < newRow; row++)
                {
                    T[] temp = new T[newCol];
                    this.matrix[row] = temp;

                    for (int col = 0; col < newCol; col++)
                    {
                        this.matrix[row][col] = newMatrix[row, col];
                    }
                }
            }

            this.SetLength();
            this.SetSpaceSeparator(newSpaceSeparator);
        }

        private void SetLength()
        {
            this.maxLengthRow = this.matrix.Length;
        }

        public int GetCurrentCol(int row)
        {
            this.SetCurrentCol(row);
            return this.CurrentRowLength;
        }
        private void SetCurrentCol(int row)
        {
            this.CurrentRowLength = this.matrix[row].Length;
        }
    }

    class Program
	{
        const char BEAVER = 'B';
        const char FISH = 'F';
        const char FREE = '-';
        const char FIRST_WOOD = 'a';
        const char LAST_WOOD = 'z';

        static void Main(string[] args)
		{
            int n = int.Parse(Console.ReadLine());

            int countWoods = 0;

            Matrix<char> pond = new Matrix<char>("" "", n, n);

            for (int i = 0; i < n; i++)
            {
                char[] temp = Console.ReadLine().Split(' ').Select(char.Parse).ToArray();

                for (int j = 0; j < temp.Length; j++)
                {
                    if ((temp[j] >= FIRST_WOOD) && (temp[j] <= LAST_WOOD))
                    {
                        countWoods++;
                    }
                }

                pond.SetMatrixRow(i, temp);
            }

            pond.SetStartElement(BEAVER);
            Point beaverPosition = pond.StartPoint;

            List<char> collectedWool = new List<char>();

            bool isLoopExit = false;
            bool isCollectAllWood = false;

			while ((!isCollectAllWood) && (!isLoopExit))
			{
                string input = Console.ReadLine().ToLower();

				if (input.Equals(""end""))
				{
                    isLoopExit = true;
				}
				else
				{
                    int rowStep = 0;
                    int colStep = 0;

					switch (input)
					{
                        case ""up"":
                            rowStep--;
                            break;
                        case ""down"":
                            rowStep++;
                            break;
                        case ""left"":
                            colStep--;
                            break;
                        case ""right"":
                            colStep++;
                            break;
                        default:
							break;
					}

                    Point nextPosition = new Point(beaverPosition.Row + rowStep, beaverPosition.Col + colStep);

					if (pond.IsValidIndex(nextPosition))
					{
                        pond.SetElementAtPosition(FREE, beaverPosition);
                        beaverPosition = nextPosition;
                        pond.CurrentPoint = beaverPosition;

                        char charInBeaverPosition = pond.GetElementAtPosition(beaverPosition);                        

						if (charInBeaverPosition.Equals(FISH))
						{
                            pond.SetElementAtPosition(FREE, beaverPosition);

                            Point goUnderWater = new Point(beaverPosition.Row + rowStep, beaverPosition.Col + colStep);

                            if (pond.IsValidIndex(goUnderWater))
							{
                                int newRowIndex = beaverPosition.Row;
                                int newColIndex = beaverPosition.Col;

								if (rowStep == -1)
								{
                                    newRowIndex = 0;
								}
								else if (rowStep == 1)
								{
                                    newRowIndex = pond.CurrentRowLength;
								}
								else if (colStep == -1)
								{
                                    newColIndex = 0;
								}
								else
								{
                                    newColIndex = pond.GetCurrentCol(beaverPosition.Row);
								}

                                beaverPosition = new Point(newRowIndex, newColIndex);                                
							}
							else
							{
                                beaverPosition = pond.ChangeCurrentPosition(goUnderWater, rowStep, colStep);                                
							}

                            pond.CurrentPoint = beaverPosition;

                            
                        }

                        if (IsHasWood(charInBeaverPosition))
                        {
                            collectedWool.Add(charInBeaverPosition);
                            countWoods--;
                            pond.SetElementAtPosition(FREE, beaverPosition);

                            if (countWoods == 0)
                            {
                                isCollectAllWood = true;
                            }
                        }
                    }
                    else
					{
						if (collectedWool.Count > 0)
						{
                            collectedWool.RemoveAt(collectedWool.Count - 1);                            
						}
					}

                    pond.SetCurrentElement(BEAVER);
				}
			}

            StringBuilder sb = new StringBuilder();

			if (isCollectAllWood)
			{
                sb.AppendLine($""The Beaver successfully collect {collectedWool.Count} wood branches: {string.Join("", "", collectedWool)}."");
			}
			else
			{
                sb.AppendLine($""The Beaver failed to collect every wood branch. There are {countWoods} branches left."");

            }

            sb.AppendLine(pond.ToString());

            Console.WriteLine(sb);
        }

		private static bool IsHasWood(char ch)
		{
            
			if ((ch >= FIRST_WOOD) && (ch <= LAST_WOOD))
			{
                return true;
			}

            return false;
		}
	}
}
"
tfgh2cnr,Untitled,vvsvvs,C#,Wednesday 17th of May 2023 10:13:28 AM CDT,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Beaver_Work
{
    class Program
    {
        //деклариране на константите
        const char BEAVER = 'B';
        const char FISH = 'F';
        const char FREE = '-';
        const char FIRST_WOOD = 'a';
        const char LAST_WOOD = 'z';

        static void Main(string[] args)
        {
            int n = int.Parse(Console.ReadLine());
            //инициализиране на променливите и запълване на матрицата
            int countWoods = 0;

            char[,] pond = new char[n, n];

            int maxRowPond = pond.GetLength(0);
            int maxColPond = pond.GetLength(1);

            int currentBeaverRow = 0;
            int currentBeaverCol = 0;

            for (int r = 0; r < n; r++)
            {
                char[] temp = Console.ReadLine().Split(' ').Select(char.Parse).ToArray();

                for (int c = 0; c < temp.Length; c++)
                {
                    if (IsHasWood(temp[c]))
                    {
                        countWoods++;
                    }

                    if (temp[c] == BEAVER)
                    {
                        currentBeaverRow = r;
                        currentBeaverCol = c;
                    }
                    pond[r, c] = temp[c];
                }
            }

            List<char> collectedWool = new List<char>();

            bool isLoopExit = false;
            bool isCollectAllWood = false;

            // цикъл за обработка на командите за движение
            while ((!isCollectAllWood) && (!isLoopExit))
            {
                string input = Console.ReadLine().ToLower();

                if (input.Equals(""end""))
                {
                    isLoopExit = true;
                }
                else
                {
                    //начални стойности на стъпките
                    int rowStep = 0;
                    int colStep = 0;

                    //инициализиране на стойностите на стъпките съобразно подадените команди за посока
                    switch (input)
                    {
                        case ""up"":
                            rowStep--;
                            break;
                        case ""down"":
                            rowStep++;
                            break;
                        case ""left"":
                            colStep--;
                            break;
                        case ""right"":
                            colStep++;
                            break;
                        default:
                            break;
                    }
                    //изчисляване на новите координати на бобъра
                    int nextRowPosition = currentBeaverRow + rowStep;
                    int nextColPosition = currentBeaverCol + colStep;

                    //проверка за валидност на новите координати на бобъра
                    if (IsValidIndex(maxRowPond, maxColPond, nextRowPosition, nextColPosition))
                    {
                        // ако новите координати са валидни маркиране на старата позиция на бобъра като свободна и задаване на
                        //нови текущи координати за позиция на бобъра
                        pond[currentBeaverRow, currentBeaverCol] = FREE;

                        currentBeaverRow = nextRowPosition;
                        currentBeaverCol = nextColPosition;

                        char charInBeaverPosition = pond[currentBeaverRow, currentBeaverCol];

                        //ако на новата позиция на бобъра има риба
                        if (charInBeaverPosition.Equals(FISH))
                        {
                            pond[currentBeaverRow, currentBeaverCol] = FREE;

                            // придвижване с една позиция напред под вода
                            int goUnderWaterRow = currentBeaverRow + rowStep;
                            int goUnderWaterCol = currentBeaverCol + colStep;

                            // ако новата позоция е валидна, преместване на текущите координати на бобъра до края на езерото
                            //в същата посока
                            if (IsValidIndex(maxRowPond, maxColPond, goUnderWaterRow, goUnderWaterCol))
                            {
                                int newRowIndex = currentBeaverRow;
                                int newColIndex = currentBeaverCol;

                                if (rowStep == -1)
                                {
                                    newRowIndex = 0;
                                }
                                else if (rowStep == 1)
                                {
                                    newRowIndex = maxRowPond;
                                }
                                else if (colStep == -1)
                                {
                                    newColIndex = 0;
                                }
                                else
                                {
                                    newColIndex = maxColPond;
                                }

                                currentBeaverRow = newRowIndex;
                                currentBeaverCol = newColIndex;
                            }
                            else
                            {
                                // ако рибата е била на ръба преместване на новите координати на бобъра на отсрещния бряг на езерото

                                //ако преместването е по дължината на реда (преместване по хоризонтал)
                                if (goUnderWaterRow == currentBeaverRow)
                                {
                                    // преместване на текущите координати на бобъра на срещуположния край на реда
                                    currentBeaverRow = goUnderWaterRow;
                                    currentBeaverCol = maxColPond + (-1) * goUnderWaterCol * colStep;
                                }
                                // ако преместването е по височината на колоната (движение по вертикал) 
                                else if (goUnderWaterCol == currentBeaverCol)
                                {
                                    //преместване на срещуположния край на колоната
                                    currentBeaverRow = maxRowPond + (-1) * goUnderWaterRow * rowStep;
                                    currentBeaverCol = goUnderWaterCol;
                                }
                            }
                        }

                        // проверка дали на текущата позиция на бобъра има дърво
                        if (IsHasWood(charInBeaverPosition))
                        {
                            collectedWool.Add(charInBeaverPosition);
                            countWoods--;
                            pond[currentBeaverRow, currentBeaverCol] = FREE;

                            //Ако бобъра е събрал всички дървета установяване на флага за събрани всички дървета
                            if (countWoods == 0)
                            {
                                isCollectAllWood = true;
                            }
                        }
                    }

                    //ако бобъра се ""удари"" в ръба на езерото
                    else
                    {
                        //ако бобъра е събрал поне едно дърво, губи последното събрано дърво
                        if (collectedWool.Count > 0)
                        {
                            collectedWool.RemoveAt(collectedWool.Count - 1);
                        }
                    }

                    //маркиране на текущата позиция на бобъра
                    pond[currentBeaverRow, currentBeaverCol] = BEAVER;
                }
            }

            // отпечатване на резултатите
            StringBuilder sb = new StringBuilder();
            
            if (isCollectAllWood)
            {
                sb.AppendLine($""The Beaver successfully collect {collectedWool.Count} wood branches: {string.Join("", "", collectedWool)}."");
            }
            else
            {
                sb.AppendLine($""The Beaver failed to collect every wood branch. There are {countWoods} branches left."");

            }            

            for (int row = 0; row < maxRowPond; row++)
            {
                StringBuilder temp = new StringBuilder();

                int colLessOne = maxColPond - 1;

                for (int col = 0; col < colLessOne + 1; col++)
                {
                    if (col == colLessOne)
                    {
                        temp.Append(pond[row, col].ToString());
                    }
                    else
                    {
                        temp.Append(pond[row, col].ToString() + "" "");
                    }
                }

                sb.AppendLine(temp.ToString());
            }

            Console.WriteLine(sb.ToString().TrimEnd());
        }

        // помощен метод за проверка на валидността на координатите (индексите на матрицата) на позицията на бобъра
        private static bool IsValidIndex(int maxRowPond, int maxColPond, int nextRowPosition, int nextColPosition)
        {
            bool result = ((nextRowPosition >= 0) && (nextRowPosition < maxRowPond));
            result = ((result) && (nextColPosition >= 0) && (nextColPosition < maxColPond));
            return result;
        }

        //Помощен метод за определяне дали на текущата позиция на бобъра има дърво
        private static bool IsHasWood(char ch)
        {

            if ((ch >= FIRST_WOOD) && (ch <= LAST_WOOD))
            {
                return true;
            }

            return false;
        }
    }
}
"
5ustc7zj,Untitled,vvsvvs,C#,Wednesday 17th of May 2023 10:10:28 AM CDT,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Class_Matrix
{
	public class Point : IComparable<Point>
	{
		public int Row { get; set; }
		public int Col { get; set; }

		public Point(int newRow, int newCol)
		{
			this.Row = newRow;
			this.Col = newCol;
		}

		public int CompareTo(Point other)
		{
			int comp = this.Row.CompareTo(other.Row);

			if (comp == 0)
			{
				comp = this.Col.CompareTo(other.Col);
			}

			return comp;
		}
	}

	public class Matrix<T> where T : IComparable<T>
	{
		private T[][] matrix;
		private Point startPoint;
		private Point currentPoint;
		private Point chekPoint;
		private T startElement;
		private int maxLengthRow;
		private int currentRowLength;
		private string spaceSeparator;
		public Point StartPoint
		{
			get => this.startPoint;
		}

		public Point CurrentPoint
		{
			get => this.currentPoint;

			set
			{
				if (this.IsValidIndex(value))
				{
					this.currentPoint = value;
				}
				else
				{
					throw new IndexOutOfRangeException();
				}
			}
		}

		public Point ChekPoint
		{
			get => this.chekPoint;

			set
			{
				if (this.IsValidIndex(value))
				{
					this.chekPoint = value;
				}
				else
				{
					throw new IndexOutOfRangeException();
				}
			}
		}

		public bool IsValidIndex(Point point)
		{
			bool isValid = ((point.Row >= 0) && (point.Row < this.MaxLengthRow));
			isValid = ((isValid) && (point.Col >= 0) && (point.Col < this.matrix[point.Row].Length));

			return isValid;
		}

		public int MaxLengthRow
		{
			get => this.maxLengthRow;

			private set
			{

			}
		}

		public int CurrentRowLength
		{
			get => this.currentRowLength;
			private set
			{

			}
		}

		public Matrix(string newSpaceSeparator, int newRow, int newCol = 0)
		{
			this.CreateMatrix(null, newSpaceSeparator, newRow, newCol);
		}

		public Matrix(T[,] newMatrix, string newSpaceSeparator)
		{
			int newRow = newMatrix.GetLength(0);
			int newCol = newMatrix.GetLength(1);

			this.CreateMatrix(newMatrix, newSpaceSeparator, newRow, newCol);
		}

		public void SetStartElement(T element)
		{
			this.startElement = element;
			this.SetStartPoint(this.startElement);
		}

		public void SetStartPoint(T newStartElement)
		{
			this.startElement = newStartElement;

			bool isLoopExit = false;
			int row = 0;

			while ((row < MaxLengthRow) && (!isLoopExit))
			{
				int col = 0;

				while ((col < this.matrix[row].Length) && (!isLoopExit))
				{
					if (this.matrix[row][col].Equals(newStartElement))
					{
						this.startPoint = new Point(row, col);
						isLoopExit = true;
					}

					col++;
				}

				row++;
			}

			this.SetStartToCurrentPoint();
		}

		public void SetStartToCurrentPoint()
		{
			this.CurrentPoint = new Point(this.startPoint.Row, this.startPoint.Col);
		}

		public void SetMatrixRow(int row, T[] colArr)
		{
			this.matrix[row] = colArr;

			this.SetLength();
		}

		public void SetCurrentElement(T element)
		{
			this.matrix[currentPoint.Row][currentPoint.Col] = element;
		}

		public T GetCurrentElement() => this.matrix[currentPoint.Row][currentPoint.Col];

		public void SetElementAtPosition(T element, Point point)
		{
			this.matrix[point.Row][point.Col] = element;
		}

		public T GetElementAtPosition(Point point) => this.matrix[point.Row][point.Col];

		public void SetSpaceSeparator(string newSpaceSeparator)
		{
			this.spaceSeparator = newSpaceSeparator;
		}

		public IEnumerable<Point> FoundAllElementPositions(T element)
		{
			Queue<Point> result = new Queue<Point>();

			for (int row = 0; row < this.matrix.Length; row++)
			{
				int maxCol = this.matrix[row].Length;

				for (int col = 0; col < maxCol; col++)
				{
					if (this.matrix[row][col].Equals(element))
					{
						Point newPoint = new Point(row, col);
						result.Enqueue(newPoint);
					}
				}
			}

			return result as IEnumerable<Point>;
		}

		public override string ToString()
		{
			StringBuilder sb = new StringBuilder();

			for (int row = 0; row < this.maxLengthRow; row++)
			{
				StringBuilder temp = new StringBuilder();

				int colLessOne = this.matrix[row].Length - 1;

				for (int col = 0; col < colLessOne + 1; col++)
				{
					if (col == colLessOne)
					{
						temp.Append(this.matrix[row][col].ToString());
					}
					else
					{
						temp.Append(this.matrix[row][col].ToString() + this.spaceSeparator);
					}
				}

				sb.AppendLine(temp.ToString());
			}

			return sb.ToString().TrimEnd();
		}

		public string GetChessCoordinates(Point position) => $""{((char)((int)'a' + position.Col)).ToString()}{position.Row + 1}"";

		public Point ChangeCurrentPosition(Point newPoint, int stepRow, int stepCol)
		{
			Point result = null;
			if (this.currentPoint.Row == newPoint.Row)
			{
				result = new Point(newPoint.Row, this.matrix[this.currentPoint.Row].Length + (-1) * newPoint.Col * stepCol);
			}
			else if (currentPoint.Col == newPoint.Col)
			{
				result = new Point(this.MaxLengthRow + (-1) * newPoint.Row * stepRow, newPoint.Col);
			}

			try
			{
				this.CurrentPoint = result;
			}
			catch (IndexOutOfRangeException)
			{

				result = new Point(-1, -1);
			}

			return result;
		}

		private void CreateMatrix(T[,] newMatrix, string newSpaceSeparator, int newRow, int newCol)
		{
			this.matrix = new T[newRow][];

			if (newMatrix == null)
			{
				for (int row = 0; row < newRow; row++)
				{
					T[] temp = new T[newCol];
					this.matrix[row] = temp;
				}
			}
			else
			{
				for (int row = 0; row < newRow; row++)
				{
					T[] temp = new T[newCol];
					this.matrix[row] = temp;

					for (int col = 0; col < newCol; col++)
					{
						this.matrix[row][col] = newMatrix[row, col];
					}
				}
			}

			this.SetLength();
			this.SetSpaceSeparator(newSpaceSeparator);
		}

		private void SetLength()
		{
			this.maxLengthRow = this.matrix.Length;
		}

		public int GetCurrentCol(int row)
		{
			this.SetCurrentCol(row);
			return this.CurrentRowLength;
		}
		private void SetCurrentCol(int row)
		{
			this.CurrentRowLength = this.matrix[row].Length;
		}
	}

	class Program
	{
		static void Main(string[] args)
		{
			const char VANKO = 'V';
			const char HOLE = '*';
			const char RODS = 'R';
			const char CABLES = 'C';
			const char ELDIED = 'E';
			const char FREE = '-';

			int n = int.Parse(Console.ReadLine());

			Matrix<char> wall = new Matrix<char>(string.Empty, n, n);

			for (int i = 0; i < n; i++)
			{
				char[] temp = Console.ReadLine().ToCharArray();
				wall.SetMatrixRow(i, temp);
			}

			wall.SetStartElement(VANKO);
			wall.SetElementAtPosition(HOLE, wall.CurrentPoint);

			bool isLoopExit = false;
			int holeCount = 1;
			int countOfRods = 0;
			bool isDied = false;

			StringBuilder sb = new StringBuilder();

			while (!isLoopExit)
			{
				string input = Console.ReadLine();

				if (input.Equals(""End""))
				{
					isLoopExit = true;
				}
				else
				{
					int stepRow = 0;
					int stepCol = 0;

					switch (input)
					{
						case ""up"":
							stepRow--;
							break;
						case ""down"":
							stepRow++;
							break;
						case ""left"":
							stepCol--;
							break;
						case ""right"":
							stepCol++;
							break;
						default:
							break;
					}

					Point newPosition = new Point(wall.CurrentPoint.Row + stepRow, wall.CurrentPoint.Col + stepCol);

					if (wall.IsValidIndex(newPosition))
					{
						char ch = wall.GetElementAtPosition(newPosition);
						if (ch == CABLES)
						{
							isLoopExit = true;
							isDied = true;
							wall.SetElementAtPosition(ELDIED, newPosition);
							holeCount++;
						}
						else if (ch == FREE)
						{
							wall.CurrentPoint = newPosition;
							wall.SetElementAtPosition(HOLE, newPosition);
							holeCount++;
						}
						else if (ch == RODS)
						{
							countOfRods++;
							sb.AppendLine(""Vanko hit a rod!"");
						}
						else if (ch == HOLE)
						{
							wall.CurrentPoint = newPosition;
							sb.AppendLine($""The wall is already destroyed at position [{wall.CurrentPoint.Row}, {wall.CurrentPoint.Col}]!"");
						}
					}
				}
			}

			if (isDied)
			{
				sb.AppendLine($""Vanko got electrocuted, but he managed to make {holeCount} hole(s)."");
			}
			else
			{
				sb.AppendLine($""Vanko managed to make {holeCount} hole(s) and he hit only {countOfRods} rod(s)."");
				wall.SetElementAtPosition(VANKO, wall.CurrentPoint);
			}

			sb.AppendLine(wall.ToString().TrimEnd());

			Console.WriteLine(sb.ToString().TrimEnd());
		}
	}
}
"
47uK1xNZ,Untitled,Neolyt,Python,Wednesday 17th of May 2023 10:09:16 AM CDT,"import tkinter as tk
from tkinter import *
from random import choice
from datetime import datetime


def load_abcd_questions():
    """"""
    Returns list of questions where question contains:
    question[0]: text of question
    question[1]: letter of the correct answer
    question[2:6]
    """"""
    questions_abcd = open('abcd_questions.txt', 'r', encoding = 'utf-8')
    questions = []
    for i in range(0,len(questions_abcd),6):
        questions.append(questions_abcd[i:i+6]) 
    return questions

print(load_abcd_questions())

writing= (""Cosmic Sans MS "", 22)
window = Tk()
window.title(""Game for two players"")
window.geometry(""1000x500"")
lab_
e_input = Entry (window, widt= 30, font=writing,)
e_input.insert(0,"""")
e_input.pack()

def get_random_question(questions):
    """"""
    Returns random question from questions passed in
    """"""
    return choice(questions)



def is_answer_correct(question, answer):
    """"""
    Returns True if answer is correct, False otherwise
    """"""
    # change everything to lowercase to make comparions easier
    if answer.lower() == question[1].lower():
        return True
        lab_ans_true = Label(window, text=""Odpovedal si spravne."", fotn= writing)
        lab_ans_true.pack()
    else:
        return False
        lab_ans_false = Label(window, text=""Odpovedal si spravne."", fotn= writing)
        lab_ans_false.pack()
    


def onEntryKeyPressed(event):
    if  event.keysym == ""Return"":
        player1=0
        print (""Hra hrac dva "")
    elif event.keysym == ""Tab"":
        player2=0
        print(""Hra hrac jedna "")


e_input.bind(""<Key>"", onEntryKeyPressed)
e_input.bind(""<Key>"", onEntryKeyPressed)



window.mainloop()"
qPfki957,Untitled,vvsvvs,C#,Wednesday 17th of May 2023 10:07:29 AM CDT,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Miner
{
    public class Point : IComparable<Point>
    {
        public int Row { get; set; }
        public int Col { get; set; }

        public Point(int newRow, int newCol)
        {
            this.Row = newRow;
            this.Col = newCol;
        }

        public int CompareTo(Point other)
        {
            int comp = this.Row.CompareTo(other.Row);

            if (comp == 0)
            {
                comp = this.Col.CompareTo(other.Col);
            }

            return comp;
        }
    }

    public class Matrix<T> where T : IComparable<T>
    {
        private T[][] matrix;
        private Point startPoint;
        private Point currentPoint;
        private Point chekPoint;
        private T startElement;
        private int maxLengthRow;
        private int currentRowLength;
        private string spaceSeparator;
        public Point StartPoint
        {
            get => this.startPoint;

            private set
            {

            }
        }

        public Point CurrentPoint
        {
            get => this.currentPoint;

            set
            {
                if (this.IsValidIndex(value))
                {
                    this.currentPoint = value;
                }
                else
                {
                    throw new IndexOutOfRangeException();
                }
            }
        }

        public Point ChekPoint
        {
            get => this.chekPoint;

            set
            {
                if (this.IsValidIndex(value))
                {
                    this.chekPoint = value;
                }
                else
                {
                    throw new IndexOutOfRangeException();
                }
            }
        }

        public bool IsValidIndex(Point point)
        {
            bool isValid = ((point.Row >= 0) && (point.Row < this.MaxLengthRow));
            isValid = ((isValid) && (point.Col >= 0) && (point.Col < this.matrix[point.Row].Length));

            return isValid;
        }

        public int MaxLengthRow
        {
            get => this.maxLengthRow;

            private set
            {

            }
        }

        public int CurrentRowLength
        {
            get => this.currentRowLength;
            private set
            {

            }
        }

        public Matrix(string newSpaceSeparator, int newRow, int newCol = 0)
        {
            this.CreateMatrix(null, newSpaceSeparator, newRow, newCol);
        }

        public Matrix(T[,] newMatrix, string newSpaceSeparator)
        {
            int newRow = newMatrix.GetLength(0);
            int newCol = newMatrix.GetLength(1);

            this.CreateMatrix(newMatrix, newSpaceSeparator, newRow, newCol);
        }

        public void SetStartElement(T element)
        {
            this.startElement = element;
            this.SetStartPoint(this.startElement);
        }

        public void SetStartPoint(T newStartElement)
        {
            this.startElement = newStartElement;

            bool isLoopExit = false;
            int row = 0;

            while ((row < MaxLengthRow) && (!isLoopExit))
            {
                int col = 0;

                while ((col < this.matrix[row].Length) && (!isLoopExit))
                {
                    if (this.matrix[row][col].Equals(newStartElement))
                    {
                        this.startPoint = new Point(row, col);
                        isLoopExit = true;
                    }

                    col++;
                }

                row++;
            }

            this.SetStartToCurrentPoint();
        }

        public void SetStartToCurrentPoint()
        {
            this.CurrentPoint = new Point(this.startPoint.Row, this.startPoint.Col);
        }

        public void SetMatrixRow(int row, T[] colArr)
        {
            this.matrix[row] = colArr;

            this.SetLength();
        }

        public void SetCurrentElement(T element)
        {
            this.matrix[currentPoint.Row][currentPoint.Col] = element;
        }

        public T GetCurrentElement() => this.matrix[currentPoint.Row][currentPoint.Col];

        public void SetElementAtPosition(T element, Point point)
        {
            this.matrix[point.Row][point.Col] = element;
        }

        public T GetElementAtPosition(Point point) => this.matrix[point.Row][point.Col];

        public void SetSpaceSeparator(string newSpaceSeparator)
        {
            this.spaceSeparator = newSpaceSeparator;
        }

        public IEnumerable<Point> FoundAllElementPositions(T element)
        {
            Queue<Point> result = new Queue<Point>();

            for (int row = 0; row < this.matrix.Length; row++)
            {
                int maxCol = this.matrix[row].Length;

                for (int col = 0; col < maxCol; col++)
                {
                    if (this.matrix[row][col].Equals(element))
                    {
                        Point newPoint = new Point(row, col);
                        result.Enqueue(newPoint);
                    }
                }
            }

            return result as IEnumerable<Point>;
        }

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();

            for (int row = 0; row < this.maxLengthRow; row++)
            {
                StringBuilder temp = new StringBuilder();

                int colLessOne = this.matrix[row].Length - 1;

                for (int col = 0; col < colLessOne + 1; col++)
                {
                    if (col == colLessOne)
                    {
                        temp.Append(this.matrix[row][col].ToString());
                    }
                    else
                    {
                        temp.Append(this.matrix[row][col].ToString() + this.spaceSeparator);
                    }
                }

                sb.AppendLine(temp.ToString());
            }

            return sb.ToString().TrimEnd();
        }

        public string GetChessCoordinates(Point position) => $""{((char)((int)'a' + position.Col)).ToString()}{position.Row + 1}"";

        public Point ChangeCurrentPosition(Point newPoint, int stepRow, int stepCol)
        {
            Point result = null;
            if (this.currentPoint.Row == newPoint.Row)
            {
                result = new Point(newPoint.Row, this.matrix[this.currentPoint.Row].Length + (-1) * newPoint.Col * stepCol);
            }
            else if (currentPoint.Col == newPoint.Col)
            {
                result = new Point(this.MaxLengthRow + (-1) * newPoint.Row * stepRow, newPoint.Col);
            }

            this.CurrentPoint = result;

            return result;
        }

        private void CreateMatrix(T[,] newMatrix, string newSpaceSeparator, int newRow, int newCol)
        {
            this.matrix = new T[newRow][];

            if (newMatrix == null)
            {
                for (int row = 0; row < newRow; row++)
                {
                    T[] temp = new T[newCol];
                    this.matrix[row] = temp;
                }
            }
            else
            {
                for (int row = 0; row < newRow; row++)
                {
                    T[] temp = new T[newCol];
                    this.matrix[row] = temp;

                    for (int col = 0; col < newCol; col++)
                    {
                        this.matrix[row][col] = newMatrix[row, col];
                    }
                }
            }

            this.SetLength();
            this.SetSpaceSeparator(newSpaceSeparator);
        }

        private void SetLength()
        {
            this.maxLengthRow = this.matrix.Length;
        }

        public int GetCurrentCol(int row)
        {
            this.SetCurrentCol(row);
            return this.CurrentRowLength;
        }
        private void SetCurrentCol(int row)
        {
            this.CurrentRowLength = this.matrix[row].Length;
        }
    }

    class Program
	{
		static void Main(string[] args)
		{
            const char COAL = 'c';
            const char MINER = 's';
            const char FREE = '*';
            const char END = 'e';

            int n = int.Parse(Console.ReadLine());

            Matrix<char> mineGalleries = new Matrix<char>("" "", n, n);

            Queue<string> commands = new Queue<string>(Console.ReadLine().Split(' ', StringSplitOptions.RemoveEmptyEntries));
            
            for (int row = 0; row < n; row++)
            {
                char[] temp = Console.ReadLine().Split(' ', StringSplitOptions.RemoveEmptyEntries).Select(char.Parse).ToArray();

                mineGalleries.SetMatrixRow(row, temp);                
            }

            mineGalleries.SetStartElement(MINER);

            List<Point> coals = mineGalleries.FoundAllElementPositions(COAL).ToList();

            int countCoal = coals.Count;

            int minerRow = mineGalleries.StartPoint.Row;
            int minerCol = mineGalleries.StartPoint.Col;

            int collectedCoal = 0;
            bool isExitLoop = false;
            bool isGameOver = false;

            while ((commands.Count > 0) && (!isExitLoop))
            {
                int colStep = 0;
                int rowStep = 0;

                switch (commands.Dequeue().ToLower())
                {
                    case ""left"":
                        colStep--;
                        break;
                    case ""right"":
                        colStep++;
                        break;
                    case ""up"":
                        rowStep--;
                        break;
                    case ""down"":
                        rowStep++;
                        break;
                    default:
                        break;
                }

                Point newPosition = new Point(minerRow + rowStep, minerCol + colStep);

                if (mineGalleries.IsValidIndex(newPosition))
                {
                    mineGalleries.SetElementAtPosition(FREE, new Point(minerRow, minerCol));

                    char ch = mineGalleries.GetElementAtPosition(newPosition);
                    if (ch.Equals(COAL))
                    {
                        collectedCoal++;
                        countCoal--;
                    }

                    if (ch.Equals(END))
                    {
                        isGameOver = true;
                        isExitLoop = true;
                    }

                    if (countCoal.Equals(0))
                    {
                        isExitLoop = true;
                    }

                    minerRow = newPosition.Row;
                    minerCol = newPosition.Col;

                    mineGalleries.SetElementAtPosition(MINER, newPosition);
                }
            }// while (commands.Count > 0)

            if (countCoal.Equals(0))
            {
                Console.WriteLine($""You collected all coals! ({minerRow}, {minerCol})"");
            }
            else if (isGameOver)
            {
                Console.WriteLine($""Game over! ({minerRow}, {minerCol})"");
            }
            else
            {
                Console.WriteLine($""{countCoal} coals left. ({minerRow}, {minerCol})"");
            }
        }
	}
}
"
mPvTHZzd,Untitled,vvsvvs,C#,Wednesday 17th of May 2023 10:06:25 AM CDT,"using System;
using System.Numerics;
using System.Text;

namespace _01._Binomial_Coefficients
{
    class BinomialCoefficients
    {
        static void Main(string[] args)
        {
            int n = int.Parse(Console.ReadLine()) - 1;
            int k = n;

            BigInteger[][] coeff = new BigInteger[n + 1][];

            Binom(n, k, ref coeff);

            Console.WriteLine(ReturnMatrixInString(coeff));
        }

        static BigInteger Binom(int n, int k, ref BigInteger[][] coeff)
        {
            if (n == 0)
            {
                coeff[n] = new BigInteger[1] { 1 };
            }
			else if ((n == 1))
			{
				coeff[n] = new BigInteger[2] { 1, 1 };
                coeff[n - 1] = new BigInteger[1] { 1 };
            }
			else
            {
                if (coeff[n] == null)
                {
                    BigInteger[] newArray = new BigInteger[n + 1];

                    for (int i = 1; i < newArray.Length - 1; i++)
                    {
                        newArray[i] = 0;
                    }

                    newArray[0] = 1;
                    newArray[newArray.Length - 1] = 1;
                    coeff[n] = newArray;
                }
            }
            int j = coeff[n].Length - 2;
			while (j > 0)
			{
                if (coeff[n][j] == 0)
                {
                    coeff[n][j] = Binom(n - 1, j, ref coeff) + Binom(n - 1, j - 1, ref coeff);
                }

                j--;
            }			

			return coeff[n][k];
        }

        static string ReturnMatrixInString(BigInteger[][] binom)
        {
            StringBuilder sb = new StringBuilder();

            for (int row = 0; row < binom.Length; row++)
            {
                sb.AppendLine(string.Join("" "", binom[row]));
            }

            return sb.ToString().TrimEnd();
        }// override string ToString()   
    }
}"
V66r4kQU,Untitled,vvsvvs,C#,Wednesday 17th of May 2023 10:04:30 AM CDT,"using System;
using System.Text;

namespace Pascal_Triangle
{
	class PascalTriangle
	{
		static int IndexValue(int n)
		{
			int result;
			int a = 1;
			int b = n;
			if ((n % 2) == 0)
			{
				result = (a + b) * n / 2;
			}
			else
			{
				result = ((n - 1) / 2) * (a + (b - 1)) + b;
			}
			return result;
		}

		static void Main(string[] args)
		{
			int n = int.Parse(Console.ReadLine());

			int arrSize = 2;

			if (n > 1)
			{
				arrSize = IndexValue(n);
			}			

			ulong[] arr = new ulong[arrSize];
			
			arr[0] = 1;
			
			int indexSource;			
			int indexTarget;

			for (int row = 1; row <= n - 1; row++)
			{
				int k = row + 1;
				indexSource = IndexValue(row - 1);
				indexTarget = IndexValue(k - 1);
				
				for (int col = 0; col <= row - 1; col++)
				{
					arr[indexTarget + col] += arr[indexSource + col];
					arr[indexTarget + col + 1] += arr[indexSource + col];
				}
			}

			StringBuilder sb = new StringBuilder();

			for (int row = 1; row <= n; row++)
			{
				indexTarget = IndexValue(row - 1);
				sb.Clear();

				for (int col = 0; col <= row - 1; col++)
				{
					sb.Append($""{arr[indexTarget + col]} "");					
				}

				Console.WriteLine(sb.ToString().TrimEnd());
			}


			
		}
	}
}
//The triangle may be constructed in the following manner: In row 0 (the topmost row), there is a unique nonzero entry 1. Each entry of each subsequent row is constructed by adding the number above and to the left with the number above and to the right, treating blank entries as 0. For example, the initial number in the first (or any other) row is 1(the sum of 0 and 1), whereas the numbers 1 and 3 in the third row are added to produce the number 4 in the fourth row.
//If you want more info about it: https://en.wikipedia.org/wiki/Pascal's_triangle
//Print each row elements separated with whitespace.
//Триъгълникът може да бъде построен по следния начин: В ред 0 (най-горния ред) има уникален ненулев елемент 1. Всеки запис на всеки следващ ред се конструира чрез добавяне на числото по-горе и наляво с числото горе и надясно, като празните записи се третират като 0. Например, първоначалното число в първия ред (или друг) е 1(сумата от 0 и 1), докато числата 1 и 3 на третия ред се добавят, за да се получи числото 4 на четвъртия ред.
//Ако искате повече информация за това: https://bg.wikipedia.org/wiki/Pascal's_triangle
//Отпечатвайте всеки ред елементи, разделени с интервали.
"
nLRjfPrN,yes,Ninbo,JavaScript,Wednesday 17th of May 2023 10:04:30 AM CDT,"As flores são elementos encantadores da natureza, capazes de alegrar qualquer ambiente com suas cores vibrantes e aromas delicados. Em Portugal, encontramos uma grande diversidade de espécies florais, desde as típicas camélias até as exuberantes hortênsias dos Açores.

No Alentejo, as planícies ganham vida com o desabrochar dos girassóis, que se estendem em campos dourados ao sabor do vento. Já no Douro, os vinhedos são adornados por amendoeiras em flor, pintando a paisagem de branco e rosa durante a primavera.

O Jardim Botânico de Lisboa é um verdadeiro paraíso floral, abrigando variedades de orquídeas, azáleas e begónias, que exibem toda a sua beleza em estufas e canteiros bem cuidados.

As flores são também símbolos de afeto e admiração, sendo oferecidas em datas especiais como o Dia dos Namorados ou no Dia da Mãe. Elas expressam sentimentos sem a necessidade de palavras, transmitindo amor e carinho de forma singela e poética.

Em Portugal, as flores são protagonistas em festivais e tradições populares, como a Batalha das Flores, em Campo Maior, onde artistas locais elaboram magníficos tapetes florais, encantando moradores e visitantes.

Neste pequeno país à beira-mar plantado, as flores são uma expressão da sua riqueza natural e cultural, encantando a todos com sua delicadeza e beleza incomparáveis."
3kYPA01H,Untitled,Sininerebane,C#,Wednesday 17th of May 2023 10:02:13 AM CDT,"namespace Console_AppTry
{
    internal class Program
    {
        static void Main(string[] args)

        {
            int peopleInQueue;
            int appointmentLength = 10;
            int hour;
            int minutes;

            Console.WriteLine(""Введите количество людей в очереди"");
            peopleInQueue = Convert.ToInt32(Console.ReadLine());
            Console.WriteLine("" Учитывайте, что фиксированное время приема одного человека всегда равно 10 минутам"");

            hour = peopleInQueue * appointmentLength / 60;
            minutes = peopleInQueue * appointmentLength % 60;

            if (hour == 0)
            {
                Console.WriteLine(""Вам ждать своей очереди {0} минут."", minutes);
            }
            else
            {
                Console.WriteLine(""Вам ждать своей очереди {0} часов,  и {1} минут."", hour, minutes);
            }

            Console.ReadKey(); //Ожидается нажание какой либо клавиши

            }
        }
    }"
fvLrMjSj,Pasztet by Jerzy,0lszowm,C++,Wednesday 17th of May 2023 09:59:13 AM CDT,"/*
 * Example of a basic FreeRTOS queue
 * https://www.freertos.org/Embedded-RTOS-Queues.html
 */

// Include Arduino FreeRTOS library
#include <Arduino_FreeRTOS.h>

// Include queue support
#include <queue.h>

// Define a struct
struct pinRead {
  int pin;
  int value;
};

// Define a struct for personal data
struct PersonalData {
  char firstName[50];
  char lastName[50];
  int birthYear;
};

/* 
 * Declaring a global variable of type QueueHandle_t 
 * 
 */
QueueHandle_t structQueue;

// Declare global variables
QueueHandle_t personalDataQueue;
QueueHandle_t ageQueue;

// Declare task function for personal data input
void TaskInputPersonalData(void *pvParameters);
void TaskCalculateAge(void *pvParameters);
void TaskPrintData(void *pvParameters);

void setup() {

  /**
   * Create a queue.
   * https://www.freertos.org/a00116.html
   */
  structQueue = xQueueCreate(10, // Queue length
                              sizeof(struct pinRead) // Queue item size
                              );
  // Create personal data queue
  personalDataQueue = xQueueCreate(1, sizeof(struct PersonalData));
  // Create age queue
  ageQueue = xQueueCreate(1, sizeof(int));
  
  if (personalDataQueue != NULL && ageQueue != NULL) {
    // Create task for inputting personal data
    xTaskCreate(TaskInputPersonalData, ""InputData"", 128, NULL, 1, NULL);
    // Create task for calculating age
    xTaskCreate(TaskCalculateAge, ""CalculateAge"", 128, NULL, 2, NULL);
    // Create task for printing data
    xTaskCreate(TaskPrintData, ""PrintData"", 128, NULL, 3, NULL);
  }
  
  if (structQueue != NULL) {
    
    // Create task that consumes the queue if it was created.
    xTaskCreate(TaskSerial, // Task function
                ""Serial"", // A name just for humans
                128,  // This stack size can be checked & adjusted by reading the Stack Highwater
                NULL, 
                2, // Priority, with 3 (configMAX_PRIORITIES - 1) being the highest, and 0 being the lowest.
                NULL);


    // Create task that publish data in the queue if it was created.
    xTaskCreate(TaskAnalogReadPin0, // Task function
                ""AnalogReadPin0"", // Task name
                128,  // Stack size
                NULL, 
                1, // Priority
                NULL);

    // Create other task that publish data in the queue if it was created.
    xTaskCreate(TaskAnalogReadPin1, // Task function
                ""AnalogReadPin1"", // Task name
                128,  // Stack size
                NULL, 
                1, // Priority
                NULL);
    
  }


  xTaskCreate(TaskBlink, // Task function
              ""Blink"", // Task name
              128, // Stack size 
              NULL, 
              0, // Priority
              NULL );

}

void loop() {}


/**
 * Analog read task for Pin A0
 * Reads an analog input on pin 0 and send the readed value through the queue.
 * See Blink_AnalogRead example.
 */
void TaskAnalogReadPin0(void *pvParameters)
{
  (void) pvParameters;
  
  for (;;)
  {
    // Read the input on analog pin 0:
    struct pinRead currentPinRead;
    currentPinRead.pin = 0;
    currentPinRead.value = analogRead(A0);

    /**
     * Post an item on a queue.
     * https://www.freertos.org/a00117.html
     */
    xQueueSend(structQueue, &currentPinRead, portMAX_DELAY);

    // One tick delay (15ms) in between reads for stability
    vTaskDelay(1);
  }
}


/**
 * Analog read task for Pin A1
 * Reads an analog input on pin 1 and send the readed value through the queue.
 * See Blink_AnalogRead example.
 */
void TaskAnalogReadPin1(void *pvParameters)
{
  (void) pvParameters;
  
  for (;;)
  {
    // Read the input on analog pin 1:
    struct pinRead currentPinRead;
    currentPinRead.pin = 1;
    currentPinRead.value = analogRead(A1);

    /**
     * Post an item on a queue.
     * https://www.freertos.org/a00117.html
     */
    xQueueSend(structQueue, &currentPinRead, portMAX_DELAY);

    // One tick delay (15ms) in between reads for stability
    vTaskDelay(1);
  }
}

/**
 * Serial task.
 * Prints the received items from the queue to the serial monitor.
 */
void TaskSerial(void * pvParameters) {
  (void) pvParameters;

  // Init Arduino serial
  Serial.begin(9600);

  // Wait for serial port to connect. Needed for native USB, on LEONARDO, MICRO, YUN, and other 32u4 based boards.
  while (!Serial) {
    vTaskDelay(1);
  }
  
  for (;;) 
  {

    struct pinRead currentPinRead;

    /**
     * Read an item from a queue.
     * https://www.freertos.org/a00118.html
     */
    if (xQueueReceive(structQueue, &currentPinRead, portMAX_DELAY) == pdPASS) {
      Serial.print(""Pin: "");
      Serial.print(currentPinRead.pin);
      Serial.print("" Value: "");
      Serial.println(currentPinRead.value);
    }
  }
}

/* 
 * Blink task. 
 * See Blink_AnalogRead example. 
 */
void TaskBlink(void *pvParameters)
{
  (void) pvParameters;

  pinMode(LED_BUILTIN, OUTPUT);

  for (;;)
  {
    digitalWrite(LED_BUILTIN, HIGH);
    vTaskDelay( 250 / portTICK_PERIOD_MS );
    digitalWrite(LED_BUILTIN, LOW);
    vTaskDelay( 250 / portTICK_PERIOD_MS );
  }
}

// Function for inputting personal data
void TaskInputPersonalData(void *pvParameters) {
  (void)pvParameters;

  // Initialize Arduino serial
  Serial.begin(9600);

  // Wait for serial port to connect
  while (!Serial) {
    vTaskDelay(1);
  }

  // Create a struct to hold the personal data
  struct PersonalData inputData;

  // Prompt the user to enter their first name
  Serial.println(""Enter your first name:"");
  while (Serial.available() == 0) {
    vTaskDelay(1);
  }
  // Read the input from Serial Monitor and store it in the struct
  String firstName = Serial.readStringUntil('\n');
  firstName.toCharArray(inputData.firstName, sizeof(inputData.firstName));

  // Prompt the user to enter their last name
  Serial.println(""Enter your last name:"");
  while (Serial.available() == 0) {
    vTaskDelay(1);
  }
  // Read the input from Serial Monitor and store it in the struct
  String lastName = Serial.readStringUntil('\n');
  lastName.toCharArray(inputData.lastName, sizeof(inputData.lastName));

  // Prompt the user to enter their birth year
  Serial.println(""Enter your birth year:"");
  while (Serial.available() == 0) {
    vTaskDelay(1);
  }
  // Read the input from Serial Monitor and store it in the struct
  String birthYearString = Serial.readStringUntil('\n');
  inputData.birthYear = birthYearString.toInt();

  // Send the personal data struct to the queue
  xQueueSend(personalDataQueue, &inputData, portMAX_DELAY);

  // End the task
  vTaskDelete(NULL);
}

// Function for calculating age
void TaskCalculateAge(void *pvParameters) {
  (void)pvParameters;

  for (;;) {
    // Wait for personal data to be available in the queue
    struct PersonalData inputData;
    if (xQueueReceive(personalDataQueue, &inputData, portMAX_DELAY) == pdPASS) {
      // Calculate the age based on the birth year
      int currentYear = 2023;  // Change to the current year
      int age = currentYear - inputData.birthYear;

      // Send the calculated age to the age queue
      xQueueSend(ageQueue, &age, portMAX_DELAY);
    }
  }
}

// Function for printing data
void TaskPrintData(void *pvParameters) {
  (void)pvParameters;

  // Initialize Arduino serial
  Serial.begin(9600);

  // Wait for serial port to connect
  while (!Serial) {
    vTaskDelay(1);
  }

  for (;;) {
    // Wait for personal data and age to be available in the queues
    struct PersonalData inputData;
    int age;
    if (xQueueReceive(personalDataQueue, &inputData, portMAX_DELAY) == pdPASS &&
        xQueueReceive(ageQueue, &age, portMAX_DELAY) == pdPASS) {
      // Print the personal data and age
      Serial.print(""First Name: "");
      Serial.println(inputData.firstName);
      Serial.print(""Last Name: "");
      Serial.println(inputData.lastName);
      Serial.print(""Birth Year: "");
      Serial.println(inputData.birthYear);
      Serial.print(""Age: "");
      Serial.println(age);
    }
  }
}
"
JrSXGJrX,Untitled,Sininerebane,C#,Wednesday 17th of May 2023 09:58:40 AM CDT,"namespace CrystalTask
{
    internal class Program
    {
        static void Main(string[] args)
        {
            int gold;
            int crystals;
            int priceCrystal = 5;

            Console.Write(""Ввредите начальное количество золота: "");
            gold = Convert.ToInt32(Console.ReadLine());
            Console.WriteLine(""Предлагаем вам купить кристалы по цене 5 евро за штуку. Какое количество кристалов вы бы хотели 
            купить?"");
            crystals = Convert.ToInt32(Console.ReadLine());

            gold -= crystals * priceCrystal;

            Console.WriteLine(""У вас осталось {0} золота и {1} кристалов"", gold, crystals);
            Console.ReadKey();
        }
    }
}"
UMUhEG3t,SoLMISS Installer v2,Ocawesome101,Lua,Wednesday 17th of May 2023 09:33:24 AM CDT,"local mode = (select(1, ...) or ""--client""):sub(3)

local function color(...)
  for i, arg in ipairs({...}) do
    if type(arg) == ""number"" then
      term.setTextColor(arg)
    else
      write(arg)
    end
  end
end

term.clear()
term.setCursorPos(1,1)
color(colors.yellow, ""SoLMISS Installer\n"")
if mode ~= ""client"" and mode ~= ""server"" then
  printError(""invalid mode '""..mode..""'; must be 'client' or 'server'"")
  return
end
color(colors.white, ""Running in "", colors.lightBlue, mode, colors.white, "" mode\n"")

local url = ""https://raw.githubusercontent.com/ocawesome101/solmiss/primary/""

local function dl(f)
  local hand, err = http.get(url..f, nil, true)
  if not hand then
    return
  end

  local data = hand.readAll()
  hand.close()

  return data
end

color(colors.white, ""Downloading files... "")
local common = dl(""solmiss/common.lua"")
local special = dl(mode == 'server' and ""server.lua"" or ""client.lua"")
if not (common and special) then
  printError(""failed"")
  return
end

color(colors.lime, ""success\n"")

fs.makeDir(""/solmiss"")
io.open(""/solmiss/common.lua"", ""w""):write(common):close()
io.open(""/startup.lua"", ""w""):write(special):close()

local function at(x, y, c)
  term.setCursorPos(x, y)
  term.setTextColor(c)
  return term
end

local function progress(y, a, b)
  local progress = a/100
  if b then progress = a/b end

  local w = term.getSize()
  at(1, y, colors.yellow).write(""["")
  at(2, y, colors.white).write((""#""):rep(math.ceil(progress * (w - 2))))
  at(w, y, colors.yellow).write(""]"")
  term.setTextColor(colors.white)
end

color(colors.white, ""Done. Restarting into setup screen.\n"")
local finish = os.epoch(""utc"") + 3000
local _, y = term.getCursorPos()
while os.epoch(""utc"") < finish do
  sleep(0)
  progress(y, os.epoch(""utc"") - finish + 3000, 3000)
end

os.reboot()"
FbrHQHCL,myProfit Stock Details,pauloiankoski,JavaScript,Wednesday 17th of May 2023 09:21:50 AM CDT,"const excludeArray = ['ADA', 'BTC', 'BUSD', 'DOT', 'ETH', 'IJS', 'LCA', 'LCI', 'QQQ', 'QUAL', 'SCHP', 'SOL', 'Teso', 'TFLO', 'Trig', 'Vers', 'VOO'];

const items = Array.from(document.getElementById('tableStock').rows);
const filteredItems = items.slice(1, -1).filter(item => ! excludeArray.includes(item.cells[0].innerText.substring(0, 4).trim()));

const tabbedContent = filteredItems.map(item => {
    const [ticker, quantity, price] = item.cells;

    return `${ticker.innerText}\t${quantity.innerText}\t${price.innerText.replace('R$\xA0', '')}`;
});

console.log(tabbedContent.join(""\n""));"
HnsT2LxC,computercraft witherslayer,AL_O0,Lua,Wednesday 17th of May 2023 09:16:33 AM CDT,"local withers = 1

while true do
    while not rs.getInput(""back"") do
        print(""waiting for start signal..."")
        os.pullEvent(""redstone"")
    end
    while turtle.getItemDetail(1).count <= 4 do --wait for soul sand
        print(""waiting for soul sand..."")
        os.pullEvent(""turtle_inventory"")
    end 
    while turtle.getItemDetail(2).count <= 3 do 
        print(""waiting for wither skulls..."")
        os.pullEvent(""turtle_inventory"")
    end 

    print(""Summoning wither #"".. withers)
    withers=withers+1

    turtle.forward()
    turtle.forward()
    turtle.select(1)                    --select soul sand
    turtle.place()
    turtle.turnLeft()
    turtle.place()
    turtle.turnRight()
    turtle.turnRight()
    turtle.place()
    turtle.turnLeft()
    turtle.back()
    turtle.place()

    turtle.select(2)                         --select wither skulls
    turtle.turnLeft()
    turtle.place()
    turtle.turnRight()
    turtle.turnRight()
    turtle.place()
    turtle.turnLeft()
    turtle.back()
    turtle.place()
    turtle.forward()

    sleep(11) --wait for the wither to regenerate

    for i=1, 125 do 	--kill wither
        turtle.attack()
    end

    turtle.select(3)    --refuel
    turtle.refuel(1)
    
    turtle.back()
    turtle.select(4) --drop nether star
    turtle.dropDown()
    sleep(2)
end

"
nHM59fBQ,Untitled,supprucha,C,Wednesday 17th of May 2023 09:13:57 AM CDT,"#include <math.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#define ASCII_SIZE 256
#define MAX_HEIGHT 100
#define MAX_BUFFER_SIZE 1024

FILE* in;
FILE* out;

typedef struct HuffmanTreeNode {
    unsigned char data;
    unsigned frequency;
    struct HuffmanTreeNode* left;
    struct HuffmanTreeNode* right;
} Node;

typedef struct HuffmanCodes {
    int size[256];
    int matrix[256][100];
} Codes;

typedef struct PriorityQueue {
    int size;
    unsigned capacity;
    Node** array;
} Queue;

Node* newNode(unsigned char data, unsigned freq) {
    Node* temp = (Node*)malloc(sizeof(Node));
    temp->left = temp->right = NULL;
    temp->data = data;
    temp->frequency = freq;
    return temp;
}

Queue* createQueue(unsigned capacity) {
    Queue* queue = (Queue*)malloc(sizeof(Queue));
    queue->size = 0;
    queue->capacity = capacity;
    queue->array = (Node**)malloc(queue->capacity * sizeof(Node*));
    return queue;
}

void SwapNodes(Node** a, Node** b) {
    Node* t = *a;
    *a = *b;
    *b = t;
}

void Heapify(Queue* queue, int index) {
    int root = index;
    int left = 2 * index + 1;
    int right = 2 * index + 2;
    if (left < queue->size &&
        queue->array[left]->frequency < queue->array[root]->frequency)
        root = left;
    if (right < queue->size &&
        queue->array[right]->frequency < queue->array[root]->frequency)
        root = right;

    if (root != index) {
        SwapNodes(&queue->array[root], &queue->array[index]);
        Heapify(queue, root);
    }
}

int IsSingleNode(struct PriorityQueue* minHeap) {
    return (minHeap->size == 1);
}

Node* GetMinimumFreq(struct PriorityQueue* minHeap) {
    Node* temp = minHeap->array[0];
    minHeap->array[0] = minHeap->array[minHeap->size - 1];
    --minHeap->size;
    Heapify(minHeap, 0);
    return temp;
}

void InsertNode(Queue* queue, Node* new_node) {
    if (!queue) {
        return;
    }
    ++queue->size;
    int i = queue->size - 1;
    while (i && new_node->frequency < queue->array[(i - 1) / 2]->frequency) {
        queue->array[i] = queue->array[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->array[i] = new_node;
}

void Heapsort(struct PriorityQueue* minHeap) {
    int n = minHeap->size - 1;
    int i;
    for (i = (n - 1) / 2; i > -1; --i) {
        Heapify(minHeap, i);
    }
}

int IsLeaf(Node* root) {
    return (!(root->left) && !(root->right));
}

Queue* InitializeHeap(unsigned char data[], int freq[], int size) {
    Queue* queue = createQueue(size);
    for (int i = 0; i < size; ++i)
        queue->array[i] = newNode(data[i], freq[i]);
    queue->size = size;
    Heapsort(queue);
    return queue;
}

Node* BuildHuffmanTree(Queue* minHeap) {
    if (IsSingleNode(minHeap)) {
        Node* root = newNode(minHeap->array[0]->data, 0);
        return root;
    }
    Node* left;
    Node* right;
    while (!IsSingleNode(minHeap)) {
        left = GetMinimumFreq(minHeap);
        right = GetMinimumFreq(minHeap);
        Node* top;
        long long int left_frequency = 0;
        long long int right_frequency = 0;
        if (left) {
            left_frequency = left->frequency;
        }
        if (right) {
            right_frequency = right->frequency;
        }
        top = newNode('$', left_frequency + right_frequency);
        top->left = left;
        top->right = right;
        InsertNode(minHeap, top);
    }
    Node* root = GetMinimumFreq(minHeap);
    return root;
}

void GetCodes(Node* root,
              int temp_code[],
              int temp_code_size,
              Codes* alphabet) {
    if (root->left) {
        temp_code[temp_code_size] = 0;
        GetCodes(root->left, temp_code, temp_code_size + 1, alphabet);
    }
    if (root->right) {
        temp_code[temp_code_size] = 1;
        GetCodes(root->right, temp_code, temp_code_size + 1, alphabet);
    }
    if (IsLeaf(root)) {
        for (int i = 0; i < temp_code_size; ++i) {
            alphabet->matrix[root->data][i] = temp_code[i];
        }
        alphabet->size[root->data] = temp_code_size;
    }
}

Node* HuffmanCodes(Codes* codes_alphabet, Queue* minHeap) {
    Node* root = BuildHuffmanTree(minHeap);
    int temp_code[MAX_HEIGHT];
    int temp_code_size = 0;
    GetCodes(root, temp_code, temp_code_size, codes_alphabet);
    return root;
}

void WriteBit(unsigned char* bit_array, unsigned int index) {
    unsigned int byte = (index) / 8;
    char bit_position = (char)((index) % 8);
    bit_array[byte] |= (1 << (7 - bit_position));
}

void WriteZero(unsigned char* bit_array, unsigned int index) {
    unsigned int byte = (index) / 8;
    char bit_position = (char)((index) % 8);
    bit_array[byte] &= ~(1 << (7 - bit_position));
}

bool ReadBit(const unsigned char* bit_array, unsigned int index) {
    unsigned int byte = (index) / 8;
    unsigned char bit_position = (unsigned)((index) % 8);
    return bit_array[byte] & (1 << (7 - bit_position));
}

void CalcCompressedTreeSize(Node* root, int* tree_size) {
    if (!IsLeaf(root)) {
        *tree_size = *tree_size + 1;
        if (root->left) {
            CalcCompressedTreeSize(root->left, tree_size);
        }
        if (root->right) {
            CalcCompressedTreeSize(root->right, tree_size);
        }
    } else {
        *tree_size = *tree_size + 1;
        *tree_size += 8;
    }
}

void WriteCompressedTree(Node* root, unsigned char* bit_array, int* index) {
    if (!IsLeaf(root)) {
        WriteZero(bit_array, *index);
        *index = (*index + 1);
        if (root->left) {
            WriteCompressedTree(root->left, bit_array, index);
        }
        if (root->right) {
            WriteCompressedTree(root->right, bit_array, index);
        }
    } else {
        WriteBit(bit_array, *index);
        *index = (*index + 1);
        for (int i = 0; i < 8; ++i) {
            if (ReadBit(&root->data, i)) {
                WriteBit(bit_array, *index);
            } else {
                WriteZero(bit_array, *index);
            }
            *index = (*index + 1);
        }
    }
}

// Clear ""non-array"" tree
void FreeTree(Node* root) {
    if (!root)
        return;
    FreeTree(root->left);
    FreeTree(root->right);
    free(root);
}

void EncodeText(int unique_symbols, Codes codes_alphabet, const unsigned char* data) {
    unsigned char read_txt_byte = 0;
    int current_txt_byte = 0;
    unsigned char encoded_byte = 0;
    if (unique_symbols == 1) {
        codes_alphabet.size[data[0]] = 1;
        codes_alphabet.matrix[data[0]][0] = 0;
    }
    while (fread(&read_txt_byte, 1, 1, in)) {
        for (int i = 0; i < codes_alphabet.size[read_txt_byte]; i++) {
            int new_bit = codes_alphabet.matrix[read_txt_byte][i];
            if (new_bit) {
                WriteBit(&encoded_byte, current_txt_byte);
            } else {
                WriteZero(&encoded_byte, current_txt_byte);
            }
            current_txt_byte++;
            if (current_txt_byte == 8) {
                fprintf(out, ""%c"", encoded_byte);
                current_txt_byte = 0;
                encoded_byte = 0;
            }
        }
    }
    if (current_txt_byte) {
        fprintf(out, ""%c"", encoded_byte);
    }
    fseek(out, 0, SEEK_SET);
    fprintf(out, ""%c"", current_txt_byte + 1);
}

void FreeData(Node* root,
              Queue* minHeap,
              int* freq,
              unsigned char* data,
              unsigned char* compressed_tree) {
    FreeTree(root);
    for (int i = 0; i < minHeap->size; ++i) {
        free(minHeap->array[i]);
    }
    free(minHeap->array);
    free(minHeap);
    free(freq);
    free(data);
    free(compressed_tree);
}

void CountFreq(int temp_table[ASCII_SIZE], int* unique_symbols) {
    unsigned char symbol = 0;
    int read_symbol = (int)fread(&symbol, 1, 1, in);
    if (!read_symbol) {
        exit(0);
    }
    while (read_symbol) {
        if (!temp_table[(int)symbol])
            (*unique_symbols)++;
        temp_table[(int)symbol]++;
        read_symbol = (int)fread(&symbol, 1, 1, in);
    }
}

void TransferFreqNData(const int temp_table[], unsigned char* data, int* freq) {
    int current_unique_symbol = 0;
    for (int i = 0; i < ASCII_SIZE; ++i) {
        if (temp_table[i]) {
            data[current_unique_symbol] = (unsigned char)i;
            freq[current_unique_symbol] = temp_table[i];
            current_unique_symbol++;
        }
    }
}

void Encode() {
    int unique_symbols = 0;
    int temp_table[ASCII_SIZE] = {0};
    CountFreq(temp_table, &unique_symbols);

    unsigned char* data =
            (unsigned char*)malloc(sizeof(unsigned char) * unique_symbols);
    int* freq = (int*)malloc((sizeof(int) * unique_symbols));
    TransferFreqNData(temp_table, data, freq);

    Codes codes_alphabet;
    for (int i = 0; i < 256; ++i) {
        for (int j = 0; j < 100; ++j) {
            codes_alphabet.matrix[i][j] = -1;
        }
    }

    Queue* minHeap = InitializeHeap(data, freq, unique_symbols);
    Node* root = HuffmanCodes(&codes_alphabet, minHeap);

    int tree_size = 0;
    CalcCompressedTreeSize(root, &tree_size);
    tree_size = (tree_size + (8 - tree_size % 8) % 8) / 8;
    unsigned char* compressed_tree = calloc(tree_size + 1, 1);
    int index = 0;

    fseek(out, 1, SEEK_SET);
    WriteCompressedTree(root, compressed_tree, &index);
    for (int i = 0; i < tree_size; ++i) {
        fprintf(out, ""%c"", compressed_tree[i]);
    }

    fseek(in, 1, SEEK_SET);
    EncodeText(unique_symbols, codes_alphabet, data);

    FreeData(root, minHeap, freq, data, compressed_tree);
}

int ReadBuffer(unsigned char buffer[MAX_BUFFER_SIZE]) {
    return (int)fread(buffer, 1, MAX_BUFFER_SIZE, in);
}

Node* RecoverTree(unsigned char bitArray[MAX_BUFFER_SIZE], int* index) {
    if (ReadBit(bitArray, *index)) {
        (*index)++;
        unsigned char character = 0;
        character |= (char)(bitArray[(int)*index / 8] << (*index % 8));
        (*index) += 8;
        character |= (char)(bitArray[(int)*index / 8] >> (8 - (*index % 8)));
        Node* node = malloc(sizeof(Node));
        *node = (Node){character, character, NULL, NULL};
        return node;
    } else {
        (*index)++;
        Node* left = RecoverTree(bitArray, index);
        Node* right = RecoverTree(bitArray, index);

        Node* node = malloc(sizeof(Node));
        *node = (Node){'$', 0, left, right};

        return node;
    }
}

void DecodeText(Node* root, Node* currentNode, int extra_bits, int* index) {
    unsigned char read_byte, next_byte;
    if (!fscanf(in, ""%c"", &read_byte))
        return;
    if (!extra_bits) {
        extra_bits = 8;
    }
    bool read = true;
    while (read) {
        int bits_to_write;
        if (fscanf(in, ""%c"", &next_byte) != EOF) {
            bits_to_write = 8;
        } else {
            bits_to_write = extra_bits;
            read = false;
        }
        for (int i = 0; i < bits_to_write; (*index)++, i++) {
            if (IsLeaf(root)) {
                fprintf(out, ""%c"", currentNode->data);
            } else {
                if ((unsigned char)(read_byte << (*index % 8)) &
                    (unsigned char)(1 << 7)) {
                    currentNode = currentNode->right;
                } else {
                    currentNode = currentNode->left;
                }
                if (IsLeaf(currentNode)) {
                    fprintf(out, ""%c"", currentNode->data);
                    currentNode = root;
                }
            }
        }
        read_byte = next_byte;
    }
}

void Decode() {
    unsigned char buffer[MAX_BUFFER_SIZE];
    unsigned char extra_bits;
    if (!fread(&extra_bits, 1, 1, in)) {
        return;
    }

    extra_bits -= 1;

    int read_buffer = ReadBuffer(buffer);
    if (!read_buffer)
        return;
    int index = 0;
    Node* root = RecoverTree(buffer, &index);

    fseek(in, (long long int)(2 + ceil((double)index / 8)), SEEK_SET);

    index = 0;
    DecodeText(root, root, extra_bits, &index);
    FreeTree(root);
}

int main() {
    in = fopen(""in.txt"", ""r"");
    out = fopen(""out.txt"", ""w"");
    char mode;
    if (!fscanf(in, ""%c"", &mode)) {
        return 0;
    }
    if (mode == 'c') {
        Encode();
    }
    if (mode == 'd') {
        Decode();
    }
}"
qabnsFqW,avp-6,Kradar,C++,Wednesday 17th of May 2023 09:11:31 AM CDT,"#include <iostream>
#include <algorithm>
#include <memory>
#include <fstream>

#define STB_IMAGE_IMPLEMENTATION
#include ""stb/stb_image.h""

#define STB_IMAGE_WRITE_IMPLEMENTATION
#include ""stb/stb_image_write.h""

using namespace std;

#define CUDA_ASSERT(cudaError)                          \
  if (cudaError != cudaSuccess) {                       \
    throw runtime_error{cudaGetErrorString(cudaError)}; \
  }

[[nodiscard]]
__device__
inline void *rowPitched(void *rowPointer, size_t pitch, unsigned row) {
    return reinterpret_cast<void *>(reinterpret_cast<uint8_t *>(rowPointer) + row * pitch);
}

constexpr int PIXELS_PER_THREAD = 4;
constexpr dim3 BLOCK_DIM{16, 16};

template<typename T = uint8_t>
struct Pixel {
    T red;
    T green;
    T blue;
};

struct Image {
    explicit Image(std::string_view image) {
        const std::unique_ptr<Pixel<>> data{reinterpret_cast<Pixel<> *>(
                                                    stbi_load(image.data(), &width, &height, &channels, 0)
                                            )};
        if (!data) {
            throw runtime_error{""Failed to load "" + string{image}};
        }
        CUDA_ASSERT(cudaMallocPitch(&deviceData, &pitch, width * sizeof(Pixel<>), height))
        CUDA_ASSERT(cudaMemcpy2D(deviceData, pitch,
                                 data.get(), width * sizeof(Pixel<>),
                                 width * sizeof(Pixel<>), height,
                                 cudaMemcpyHostToDevice))
    }

    Image(int width, int height, int channels) : width{width},
                                                 height{height},
                                                 channels{channels} {
        CUDA_ASSERT(cudaMallocPitch(&deviceData, &pitch, width * sizeof(Pixel<>), height))
    }

    ~Image() noexcept(false) {
        CUDA_ASSERT(cudaFree(deviceData))
    }

    // Return false on failure
    [[nodiscard]]
    bool saveAsJpg(const std::string_view fileName) const {
        auto data = std::make_unique<Pixel<>[]>(width * height);
        CUDA_ASSERT(cudaMemcpy2D(data.get(), width * sizeof(Pixel<>),
                                 deviceData, pitch,
                                 width * sizeof(Pixel<>), height,
                                 cudaMemcpyDeviceToHost))
        return stbi_write_jpg(fileName.data(), width, height,
                              channels, reinterpret_cast<uint8_t *>(data.get()), 100);
    }

    int width{};
    int height{};
    int channels{};

    Pixel<> *deviceData{};
    size_t pitch{};
};

[[nodiscard]]
__device__
inline int calculateCircleRadius(const float x, const float y) {
    return static_cast<int>(round(sqrt(x * x + y * y)));
}

__global__
void findMarker(Pixel<> *sourceImage, const size_t sourceImagePitch,
                bool *markerImage, const size_t markerImagePitch,
                const int width, const int height,
                const Pixel<> markerColor, const Pixel<> threshold) {
    const unsigned x = (threadIdx.x + blockDim.x * blockIdx.x) * PIXELS_PER_THREAD;
    const unsigned y = threadIdx.y + blockDim.y * blockIdx.y;
    if (y >= height) {
        return;
    }
    const auto *sourceRow = static_cast<Pixel<> *>(rowPitched(sourceImage, sourceImagePitch, y));
    auto *markerRow = static_cast<bool *>(rowPitched(markerImage, markerImagePitch, y));
    for (int i = 0; i < PIXELS_PER_THREAD; ++i) {
        if ((x + i) >= width) {
            return;
        }
        const Pixel pixel{sourceRow[x + i]};
        const bool isMarked = abs(pixel.red - markerColor.red) <= threshold.red and
                              abs(pixel.green - markerColor.green) <= threshold.green and
                              abs(pixel.blue - markerColor.blue) <= threshold.blue;
        markerRow[x + i] = isMarked;
    }
}

__global__
void findRadius(bool *markerImage, const size_t markerImagePitch,
                const int width, const int height,
                int *radiusAccumulator, const int maxRadius, const float2 center) {
    const unsigned x = (threadIdx.x + blockDim.x * blockIdx.x) * PIXELS_PER_THREAD;
    const unsigned y = threadIdx.y + blockDim.y * blockIdx.y;
    if (y >= height) {
        return;
    }
    const bool *row = reinterpret_cast<bool *>(rowPitched(markerImage, markerImagePitch, y));
    for (int i = 0; i < PIXELS_PER_THREAD; ++i) {
        if ((x + i) >= width) {
            return;
        }
        if (row[x + i]) {
            const int estimatedRadius = calculateCircleRadius(static_cast<float>(x) - center.x,
                                                               static_cast<float>(y) - center.y);
            if (estimatedRadius <= maxRadius) {
                atomicAdd(radiusAccumulator + estimatedRadius, 1);
            }
        }
    }
}

struct MarkerImage {
    MarkerImage(const Image &image, const Pixel<> markerColor, const Pixel<> threshold)
            : width{image.width},
              height{image.height} {
        CUDA_ASSERT(cudaMallocPitch(&deviceData, &pitch, width * sizeof(bool), height))

        const dim3 GRID_DIM{
                (image.width + BLOCK_DIM.x * PIXELS_PER_THREAD - 1) / (BLOCK_DIM.x * PIXELS_PER_THREAD),
                (image.height + BLOCK_DIM.y - 1) / BLOCK_DIM.y
        };
        findMarker<<<GRID_DIM, BLOCK_DIM>>>(image.deviceData, image.pitch,
                                            deviceData, pitch,
                                            width, height,
                                            markerColor, threshold);
    }

    MarkerImage(const int width, const int height)
            : width{width},
              height{height} {
        CUDA_ASSERT(cudaMallocPitch(&deviceData, &pitch, width * sizeof(bool), height))
        CUDA_ASSERT(cudaMemset2D(deviceData, pitch, 0, width * sizeof(bool), height))
    }

    ~MarkerImage() noexcept(false) {
        CUDA_ASSERT(cudaFree(deviceData))
    }

    // Return false on failure
    [[nodiscard]]
    bool saveAsPbm(const string_view fileName) const {
        auto data = make_unique<bool[]>(width * height);
        CUDA_ASSERT(cudaMemcpy2D(data.get(), width * sizeof(bool),
                                 deviceData, pitch,
                                 width * sizeof(bool), height,
                                 cudaMemcpyDeviceToHost))
        ofstream file{fileName.data()};
        file << ""P1\n""
             << ""# Marker image\n""
             << width << ' ' << height << '\n';
        for (int i = 0; i < height; ++i) {
            for (int j = 0; j < width; ++j) {
                file << data[j + i * width] << ' ';
            }
            file << '\n';
        }
        return file.good();
    }

    int width;
    int height;

    bool *deviceData{};
    size_t pitch{};
};

struct MarkerCircle {
    explicit MarkerCircle(const MarkerImage &marker) {
        const int maxRadius = min(marker.width, marker.height) / 2;
        const float2 center{static_cast<float>(marker.width) / 2.0f/* - 0.5f*/,
                            static_cast<float>(marker.height) / 2.0f/* - 0.5f*/};

        int *radiusAccumulator;
        CUDA_ASSERT(cudaMallocManaged(&radiusAccumulator, (maxRadius + 1) * sizeof(int)))
        CUDA_ASSERT(cudaMemset(radiusAccumulator, 0, (maxRadius + 1) * sizeof(int)))

        const dim3 GRID_DIM{
                (marker.width + BLOCK_DIM.x * PIXELS_PER_THREAD - 1) / (BLOCK_DIM.x * PIXELS_PER_THREAD),
                (marker.height + BLOCK_DIM.y - 1) / BLOCK_DIM.y
        };
        findRadius<<<GRID_DIM, BLOCK_DIM>>>(marker.deviceData, marker.pitch,
                                            marker.width, marker.height,
                                            radiusAccumulator, maxRadius, center);
        CUDA_ASSERT(cudaDeviceSynchronize())

        const auto *maxElement = max_element(radiusAccumulator, radiusAccumulator + maxRadius + 1);
        const auto maxElementIndex = maxElement - radiusAccumulator;
        radius = static_cast<int>(maxElementIndex);

        CUDA_ASSERT(cudaFree(radiusAccumulator))
    }

    int radius{};
};

[[nodiscard]]
__host__ __device__
inline constexpr float normalizeValue(const float value, const float max) {
    return (value - (max - 1.0f) / 2.0f) * 2.0f / (max - 1.0f);
}

float calculateFisheyeCoefficient(const float width, const float height, const float radius) {
    const float2 normalizedSourceCirclePoint{
            normalizeValue(width / 2.0f + radius, width),
            normalizeValue(height / 2.0f, height)
    };
    const float normalizedSourceCircleRadius = sqrt(normalizedSourceCirclePoint.x * normalizedSourceCirclePoint.x +
                                                    normalizedSourceCirclePoint.y * normalizedSourceCirclePoint.y);
    const float2 normalizedTargetCirclePoint{
            normalizeValue(width / 2.0f + min(width, height) * 0.1f, width),
            normalizeValue(height / 2.0f, height)
    };
    const float normalizedTargetCircleRadius = sqrt(normalizedTargetCirclePoint.x * normalizedTargetCirclePoint.x +
                                                    normalizedTargetCirclePoint.y * normalizedTargetCirclePoint.y);
    return log(normalizedTargetCircleRadius) / log(normalizedSourceCircleRadius);
}

__global__
void fisheyeTransform(Pixel<> *sourceImage, const size_t sourceImagePitch,
                      Pixel<> *targetImage, const size_t targetImagePitch,
                      bool *interpolationMask, const size_t interpolationMaskPitch,
                      const int width, const int height,
                      const float coefficient) {
    const unsigned x = (threadIdx.x + blockDim.x * blockIdx.x) * PIXELS_PER_THREAD;
    const unsigned y = threadIdx.y + blockDim.y * blockIdx.y;
    if (y >= height) {
        return;
    }
    const auto *sourceRow = static_cast<Pixel<> *>(rowPitched(sourceImage, sourceImagePitch, y));
    for (int i = 0; i < PIXELS_PER_THREAD; ++i) {
        if ((x + i) >= width) {
            return;
        }
        const float2 normalized{normalizeValue(static_cast<float>(x + i), static_cast<float>(width)),
                                normalizeValue(static_cast<float>(y), static_cast<float>(height))};

        const float radius = sqrt(normalized.x * normalized.x + normalized.y * normalized.y);
        const float theta = atan2(normalized.y, normalized.x);

        constexpr float epsilon = 0.001f;
        const float scale = min(1.0f / abs(cos(theta) + epsilon), 1.0f / abs(sin(theta) + epsilon));

        const float newRadius = min(scale, 1.0f) * pow(radius, coefficient);
        const auto newX = static_cast<int>(round(
                (static_cast<float>(width) - 1.0f) / 2.0f * newRadius * cos(theta) +
                (static_cast<float>(width) - 1.0f) / 2.0f
        ));
        const auto newY = static_cast<int>(round(
                (static_cast<float>(height) - 1.0f) / 2.0f * newRadius * sin(theta) +
                (static_cast<float>(height) - 1.0f) / 2.0f
        ));
        auto *targetRow = static_cast<Pixel<> *>(rowPitched(targetImage, targetImagePitch, newY));
        auto *interpolationMaskRow =
                static_cast<bool *>(rowPitched(interpolationMask, interpolationMaskPitch, newY));
        if (0 <= newX and newX < width and
            0 <= newY and newY < height) {
            targetRow[newX] = sourceRow[x + i];
            interpolationMaskRow[newX] = true;
        }
    }
}

void fisheyeTransform(const Image &source, Image &target, MarkerImage &interpolationMask, const float coefficient) {
    const dim3 GRID_DIM{
            (source.width + BLOCK_DIM.x * PIXELS_PER_THREAD - 1) / (BLOCK_DIM.x * PIXELS_PER_THREAD),
            (source.height + BLOCK_DIM.y - 1) / BLOCK_DIM.y
    };
    fisheyeTransform<<<GRID_DIM, BLOCK_DIM>>>(source.deviceData, source.pitch,
                                              target.deviceData, target.pitch,
                                              interpolationMask.deviceData, interpolationMask.pitch,
                                              source.width, source.height,
                                              coefficient);
}

[[nodiscard]]
__device__
uint2 findTopLeftColoredPixel(bool *mask, const size_t maskPitch, const uint2 start) {
    const unsigned maxStep = min(start.x, start.y);
    for (unsigned step = 1; step < maxStep; ++step) {
        for (unsigned i = 0; i < step; ++i) {
            const unsigned x = start.x - step + i;
            const unsigned y = start.y - i - 1;
            const auto *maskRow = static_cast<bool *>(rowPitched(mask, maskPitch, y));
            if (maskRow[x]) {
                return {x, y};
            }
        }
    }
    return {0, 0};
}

[[nodiscard]]
__device__
uint2 findTopRightColoredPixel(bool *mask, const size_t maskPitch, const int width, const uint2 start) {
    const unsigned maxStep = min(width - start.x, start.y);
    for (unsigned step = 1; step < maxStep; ++step) {
        for (unsigned i = 0; i < step; ++i) {
            const unsigned x = start.x + step - i;
            const unsigned y = start.y - i - 1;
            const auto *maskRow = static_cast<bool *>(rowPitched(mask, maskPitch, y));
            if (maskRow[x]) {
                return {x, y};
            }
        }
    }
    return {static_cast<unsigned>(width - 1), 0};
}

[[nodiscard]]
__device__
uint2 findBottomLeftColoredPixel(bool *mask, const size_t maskPitch, const int height, const uint2 start) {
    const unsigned maxStep = min(start.x, height - start.y);
    for (unsigned step = 1; step < maxStep; ++step) {
        for (unsigned i = 0; i < step; ++i) {
            const unsigned x = start.x - step + i;
            const unsigned y = start.y + i + 1;
            const auto *maskRow = static_cast<bool *>(rowPitched(mask, maskPitch, y));
            if (maskRow[x]) {
                return {x, y};
            }
        }
    }
    return {0, static_cast<unsigned>(height - 1)};
}

[[nodiscard]]
__device__
uint2 findBottomRightColoredPixel(bool *mask, const size_t maskPitch,
                                  const int width, const int height, const uint2 start) {
    const unsigned maxStep = min(width - start.x, height - start.y);
    for (unsigned step = 1; step < maxStep; ++step) {
        for (int i = 0; i < step; ++i) {
            const unsigned x = start.x + step - i;
            const unsigned y = start.y + i + 1;
            const auto *maskRow = static_cast<bool *>(rowPitched(mask, maskPitch, y));
            if (maskRow[x]) {
                return {x, y};
            }
        }
    }
    return {static_cast<unsigned>(width - 1), static_cast<unsigned>(height - 1)};
}

[[nodiscard]]
__device__
inline float calculateScale(const float min, const float max, const unsigned value) {
    return (max - static_cast<float>(value)) / (max - min);
}

[[nodiscard]]
__device__
inline float calculateScale(const unsigned min, const unsigned max, const unsigned value) {
    return calculateScale(static_cast<float>(min), static_cast<float>(max), value);
}

[[nodiscard]]
__device__
inline float biLinearInterpolation(const float scale, const float firstColor, const float secondColor) {
    return scale * firstColor + (1.0f - scale) * secondColor;
}

[[nodiscard]]
__device__
inline float biLinearInterpolation(const float scale, const uint8_t firstColor, const uint8_t secondColor) {
    return biLinearInterpolation(scale, static_cast<float>(firstColor), static_cast<float>(secondColor));
}

[[nodiscard]]
__device__
inline Pixel<float> calculatePixelColor(const float scale, const Pixel<> firstPixel, const Pixel<> secondPixel) {
    return {biLinearInterpolation(scale, firstPixel.red, secondPixel.red),
            biLinearInterpolation(scale, firstPixel.green, secondPixel.green),
            biLinearInterpolation(scale, firstPixel.blue, secondPixel.blue),
    };
}

[[nodiscard]]
__device__
inline Pixel<> calculatePixelColor(const float scale, const Pixel<float> firstPixel, const Pixel<float> secondPixel) {
    return {static_cast<uint8_t>(biLinearInterpolation(scale, firstPixel.red, secondPixel.red)),
            static_cast<uint8_t>(biLinearInterpolation(scale, firstPixel.green, secondPixel.green)),
            static_cast<uint8_t>(biLinearInterpolation(scale, firstPixel.blue, secondPixel.blue)),
    };
}

[[nodiscard]]
__device__
inline float linearInterpolation(const uint2 point0, const uint2 point1, const unsigned x) {
    return (static_cast<float>(point0.y) * static_cast<float>(point1.x - x) +
            static_cast<float>(point1.y) * static_cast<float>(x - point0.x)) /
           static_cast<float>(point1.x - point0.x);
}

__global__
void interpolate(bool *mask, const size_t maskPitch,
                 Pixel<> *targetImage, const size_t targetImagePitch,
                 const int width, const int height) {
    const unsigned x = (threadIdx.x + blockDim.x * blockIdx.x) * PIXELS_PER_THREAD;
    const unsigned y = threadIdx.y + blockDim.y * blockIdx.y;
    if (y >= height) {
        return;
    }
    const auto *maskRow = static_cast<bool *>(rowPitched(mask, maskPitch, y));
    auto *targetRow = static_cast<Pixel<> *>(rowPitched(targetImage, targetImagePitch, y));
    for (int i = 0; i < PIXELS_PER_THREAD; ++i) {
        if ((x + i) >= width) {
            return;
        }
        if (maskRow[x + i]) {
            continue;
        }
        const uint2 topLeft{findTopLeftColoredPixel(mask, maskPitch, {x + i, y})};
        const uint2 topRight{findTopRightColoredPixel(mask, maskPitch, width, {x + i, y})};
        const uint2 bottomLeft{findBottomLeftColoredPixel(mask, maskPitch, height, {x + i, y})};
        const uint2 bottomRight{findBottomRightColoredPixel(mask, maskPitch, width, height, {x + i, y})};

        const auto topLeftPixel = static_cast<Pixel<> *>(
                rowPitched(targetImage, targetImagePitch, topLeft.y)
        )[topLeft.x];
        const auto topRightPixel = static_cast<Pixel<> *>(
                rowPitched(targetImage, targetImagePitch, topRight.y)
        )[topRight.x];
        const auto bottomLeftPixel = static_cast<Pixel<> *>(
                rowPitched(targetImage, targetImagePitch, bottomLeft.y)
        )[bottomLeft.x];
        const auto bottomRightPixel = static_cast<Pixel<> *>(
                rowPitched(targetImage, targetImagePitch, bottomRight.y)
        )[bottomRight.x];

        const float topScale = calculateScale(topLeft.x, topRight.x, x + i);
        const auto topPixel = calculatePixelColor(topScale, topLeftPixel, topRightPixel);

        const float bottomScale = calculateScale(bottomLeft.x, bottomRight.x, x + i);
        const auto bottomPixel = calculatePixelColor(bottomScale, bottomLeftPixel, bottomRightPixel);

        const float topY = linearInterpolation(topLeft, topRight, x + i);
        const float bottomY = linearInterpolation(bottomLeft, bottomRight, x + i);
        const float scale = calculateScale(topY, bottomY, y);

        targetRow[x + i] = calculatePixelColor(scale, topPixel, bottomPixel);
    }
}

void interpolate(const MarkerImage &mask, Image &target) {
    const dim3 GRID_DIM{
            (target.width + BLOCK_DIM.x * PIXELS_PER_THREAD - 1) / (BLOCK_DIM.x * PIXELS_PER_THREAD),
            (target.height + BLOCK_DIM.y - 1) / BLOCK_DIM.y
    };
    interpolate<<<GRID_DIM, BLOCK_DIM>>>(mask.deviceData, mask.pitch,
                                         target.deviceData, target.pitch,
                                         target.width, target.height);
}

int main() {
    const auto imagesDirectory = ""../files/""s;
    const Image source{imagesDirectory + ""morgen.jpg""};

    constexpr Pixel<> markerColor{255, 0, 255};
    constexpr Pixel<> threshold{50, 50, 50};
    const MarkerImage markerImage{source, markerColor, threshold};

    if (!markerImage.saveAsPbm(imagesDirectory + ""marker.pbm"")) {
        cerr << ""Failed to save marker.pbm"" << endl;
    }

    cout << ""Target radius is "" << static_cast<float>(min(markerImage.width, markerImage.height)) * 0.1f << endl;
    MarkerCircle circle{markerImage};
    cout << ""Circle radius is "" << circle.radius << endl;

    const float fisheyeCoefficient = calculateFisheyeCoefficient(static_cast<float>(markerImage.width),
                                                                 static_cast<float>(markerImage.height),
                                                                 static_cast<float>(circle.radius));
    cout << ""Fisheye coefficient is "" << fisheyeCoefficient << endl;

    Image result{source.width, source.height, source.channels};
    MarkerImage interpolationMask{result.width, source.height};
    fisheyeTransform(source, result, interpolationMask, fisheyeCoefficient);

    if (!result.saveAsJpg(imagesDirectory + ""result.jpg"")) {
        cerr << ""Failed to save result.jpg"" << endl;
    }
    if (!interpolationMask.saveAsPbm(imagesDirectory + ""interpolating.pbm"")) {
        cerr << ""Failed to save interpolating.pbm"" << endl;
    }

    interpolate(interpolationMask, result);

    if (!result.saveAsJpg(imagesDirectory + ""result.jpg"")) {
        cerr << ""Failed to save result.jpg"" << endl;
    }

    return 0;
}"
7VYQTvGv,Follower,noobHasan,C#,Wednesday 17th of May 2023 09:05:55 AM CDT,"// Follower.cs
using UnityEngine;

public class Follower : MonoBehaviour {
    private bool isFollowing = false;
    private Transform leader;
    private float followSpeed = 5f;
    private float minDistanceFromLeader = 1f;
    private float minDistanceBetweenFollowers = 1f;

    public bool IsFollowing()
    {
        return isFollowing;
    }

    public void SetFollowing(bool following)
    {
        isFollowing = following;
    }

    public void SetLeader(Transform newLeader)
    {
        leader = newLeader;
    }

    private void Update()
    {
        if (isFollowing && leader != null)
        {
            Vector3 direction = leader.position - transform.position;
            float distanceFromLeader = Vector3.Distance(transform.position, leader.position);

            // Keep a minimum distance from the leader (player)
            if (distanceFromLeader > minDistanceFromLeader)
            {
                transform.Translate(direction.normalized * followSpeed * Time.deltaTime);
            }

            // Keep a minimum distance from other followers
            Follower[] followers = FindObjectsOfType<Follower>();
            foreach (Follower otherFollower in followers)
            {
                if (otherFollower != this && otherFollower.IsFollowing())
                {
                    float distanceBetweenFollowers = Vector3.Distance(transform.position, otherFollower.transform.position);

                    if (distanceBetweenFollowers < minDistanceBetweenFollowers)
                    {
                        Vector3 separationDirection = transform.position - otherFollower.transform.position;
                        transform.Translate(separationDirection.normalized * followSpeed * Time.deltaTime);
                    }
                }
            }
        }
    }
}
"
NvLh03C4,Untitled,mikhailemv,C#,Wednesday 17th of May 2023 08:51:25 AM CDT,"using System;
using System.Linq;
using System.Reflection;
using System.Collections;
using System.Collections.Generic;

namespace Documentation
{
    public class Specifier<T> : ISpecifier
    {
        private Type type = typeof(T);
        public string GetApiDescription()
        {
            return type
            .GetCustomAttributes(false)
            .OfType<ApiDescriptionAttribute>()
            .FirstOrDefault()?.Description;
        }

        public string[] GetApiMethodNames()
        {
            return type.GetMethods()
            .Where(x => x.GetCustomAttributes<ApiMethodAttribute>()
            .Any())
            .Select(y => y.Name).ToArray();
        }

        public string GetApiMethodDescription(string methodName)
        {
            return type
            .GetMethod(methodName)?
            .GetCustomAttributes(false)
            .OfType<ApiDescriptionAttribute>()
            .FirstOrDefault()?.Description;
        }

        public string[] GetApiMethodParamNames(string methodName)
        {
            return type
            .GetMethod(methodName)?
            .GetParameters()
            .Select(x => x.Name)
            .ToArray();
        }

        public string GetApiMethodParamDescription(string methodName, string paramName)
        {
            return type
            .GetMethod(methodName)?
            .GetParameters()
            .Where(x => x.Name == paramName)
            .FirstOrDefault()?
            .GetCustomAttributes(false)
            .OfType<ApiDescriptionAttribute>()
            .FirstOrDefault()?
            .Description;
        }

        public ApiParamDescription GetApiMethodParamFullDescription(string methodName, string paramName)
        {
            var allResults = new ApiParamDescription();
            var aid = paramName;

            AssistentForWork(paramName, methodName, allResults, aid);
            allResults.ParamDescription = new CommonDescription(
                paramName, GetApiMethodParamDescription(methodName, paramName));

            return allResults;
        }

        public ApiMethodDescription GetApiMethodFullDescription(string methodName)
        {
            var met = type.GetMethod(methodName);
            var result = new ApiMethodDescription();
            var paramDescription = new ApiParamDescription
            { ParamDescription = new CommonDescription() };
            var validAttr = met?.ReturnParameter?
            .GetCustomAttributes(false)
            .OfType<ApiIntValidationAttribute>()
            .FirstOrDefault();
            var reqAttr = met?
            .ReturnParameter?
            .GetCustomAttributes(false)
            .OfType<ApiRequiredAttribute>()
            .FirstOrDefault();
            if (met != null && !met
                .GetCustomAttributes(false)
                .OfType<ApiMethodAttribute>()
                .Any()) return null;
            result = GetDescriptionAssist(methodName, methodName.Trim(), 
                paramDescription, validAttr, reqAttr);
            return result;
        }

        private void AssistentForWork(string param, string method, ApiParamDescription result, string assist)
        {
            var allInf = type.GetMethods()
            .FirstOrDefault(x => x.Name == method)?
            .GetParameters()
            .FirstOrDefault(y => y.Name == param);

            var validAttr = allInf?.GetCustomAttributes(false)
            .OfType<ApiIntValidationAttribute>()
            .FirstOrDefault();

            var reqAttr = allInf?.GetCustomAttributes(false)
            .OfType<ApiRequiredAttribute>()
            .FirstOrDefault();

            if (reqAttr != null && assist != null) 
                result.Required = reqAttr.Required;

            if (validAttr != null && assist != null)
            {
                result.MaxValue = validAttr.MaxValue;
                result.MinValue = validAttr.MinValue;
            }
        }

        private ApiMethodDescription GetDescriptionAssist
        (string methodName, string assist,
        ApiParamDescription paramDescr, ApiIntValidationAttribute validAttr, ApiRequiredAttribute reqAttr)
        {
            var result = new ApiMethodDescription();
            if (assist != null)
                result = new ApiMethodDescription
                {
                    MethodDescription = new CommonDescription(methodName, 
                    GetApiMethodDescription(methodName)),
                    ParamDescriptions = GetApiMethodParamNames(methodName)
                    .Select(x => GetApiMethodParamFullDescription(methodName, x))
                    .ToArray()
                };
            if (validAttr != null && assist != null)
            {
                paramDescr.MaxValue = validAttr.MaxValue;
                paramDescr.MinValue = validAttr.MinValue;
            }
            if (assist != null && reqAttr != null)
            {
                paramDescr.Required = reqAttr.Required;
                result.ReturnDescription = paramDescr;
            }
            return result;
        }
    }
}"
fnuWPbYP,Formato response,DesolatorMagno,JSON,Wednesday 17th of May 2023 08:51:23 AM CDT,"{
    ""data"": [
        {
            ""type"": ""Matter"",
            ""matterid"": 14798268,
            ""attributes"": {
                ""id"": 1,
            },
            ""relationships"": {
                ""calls"": [{
                    ""id"": 5,
                    ""callid"": ""11111183.65"",
                    ""date"": ""1684331183"",
                    ""duration"": ""83"",
                    ""note"": ""nothing note"",
                    ""disposition"": ""Bussy"",
                    ""from"": ""09001728888"",
                    ""to"": ""+2384697850"",
                    ""agentnumber"": 2001,
                    ""agentname"": ""daniel"",
                }],
                ""sms"": [{
                    ""id"": 5,
                    ""date"": ""1684331183"",
                    ""message"": ""thank you bla bla bla bla"",
                    ""from"": ""09001728888"",
                    ""to"": ""+1586478920"",
                    ""agentnumber"": 2001,
                    ""agentname"": ""daniel"",
                }],
                ""email"": [{
                    ""id"": 5,
                    ""date"": ""1684331183"",
                    ""from"": ""email.master@coresms.com"",
                    ""to"": ""persona.email@coresms.com"",
                    ""agentnumber"": 2001,
                    ""agentname"": ""daniel"",
                    ""subject"": ""your case dxxxxx"",
                    ""body"": ""your case its in the best hands :)""
                }] 
            }
        }
    ]
}"
4pmUeK6q,initials,elenamoskova,Java,Wednesday 17th of May 2023 08:37:17 AM CDT,"import java.util.Scanner;
public class InicijaliImePrezime {
     public static void inicijali(String name) {
    		System.out.print(Character.toUpperCase(
    		        name.charAt(0)));
    	 for(int i=0;i<name.length();i++) {
    		   if(name.charAt(i)==' ')
    		        System.out.print(Character.toUpperCase(
    	                                        name.charAt(i + 1)));
    	 }
     }
	public static void main(String[] args) {
		Scanner input=new Scanner(System.in);
		int n=input.nextInt();
		//nextInt method doesn't read the newline character of your input
		input.nextLine();
		
		for(int i=0;i<n;i++) {
			String name=input.nextLine();
			 inicijali(name);
		}
		

	}

}
"
eTfxeUgb,Untitled,robyhr,Winbatch,Wednesday 17th of May 2023 07:50:37 AM CDT,"ECHO OFF
CLS

:MENU
ECHO.
ECHO  0 - SHOW IP
ECHO.
ECHO 10 - LAN DHCP client
ECHO 11 - LAN 192.168.1.10/24 (192.168.1.1)
ECHO 12 - LAN 192.168.0.10/24 (192.168.0.1)
ECHO.
ECHO 20 - WLAN DHCP client
ECHO 21 - WLAN 192.168.1.10/24 (192.168.1.1)
ECHO 22 - WLAN 192.168.0.10/24 (192.168.0.1)
ECHO.
ECHO 30 - PING 192.168.1.1
ECHO 31 - PING 10.80.12.1
ECHO 32 - PING 8.8.8.8
ECHO.
ECHO 40 - PING -t 192.168.1.1
ECHO.
ECHO  9 - EXIT
ECHO.

SET /P M=Odaberi:
IF %M%==9 GOTO :EOF
GOTO %M%

:0
CLS
netsh interface ipv4 show address
GOTO MENU

:10
CLS
netsh interface ipv4 set address ""LAN"" dhcp
GOTO MENU

:11
CLS
netsh interface ipv4 set address ""LAN"" static 192.168.1.10 255.255.255.0 192.168.1.1
GOTO MENU

:12
CLS
netsh interface ipv4 set address ""LAN"" static 192.168.0.10 255.255.255.0 192.168.0.1
GOTO MENU

:20
CLS
netsh interface ipv4 set address ""WIFI"" dhcp
GOTO MENU

:21
CLS
netsh interface ipv4 set address ""WIFI"" static 192.168.1.10 255.255.255.0 192.168.1.1
GOTO MENU

:22
CLS
netsh interface ipv4 set address ""WIFI"" static 192.168.0.10 255.255.255.0 192.168.0.1
GOTO MENU

:30
CLS
ping -n 1 192.168.1.1
GOTO MENU

:31
CLS
ping -n 1 10.80.12.1
GOTO MENU

:32
CLS
ping -n 1 8.8.8.8
GOTO MENU

:40
CLS
ping -t 192.168.1.1
GOTO MENU"
0hnXDYQx,Kruskul,Kaseil,C++,Wednesday 17th of May 2023 07:48:22 AM CDT,"#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

class Graph {
private:
	struct Edge {
		int parent, child, weight;
		Edge(int p, int c, int w) {
			parent = p;
			child = c;
			weight = w;
		}
		bool operator <(Edge n) {
			return this->weight < n.weight;
		}
	};
	std::vector<Edge> edges;
	std::vector<int> ppt;
	int vertexCount, edgeCount;

public:
	Graph(int vertexCount, int edgeCount) {
		this->vertexCount = vertexCount;
		this->edgeCount = edgeCount;

		ppt = std::vector<int>(vertexCount);

		for (int i = 0; i < vertexCount; i++) {
			makeSet(i);
		}
	}

	void makeSet(int i) {
		ppt[i] = i;
	}

	int findSet(int i) {
		if (ppt[i] == i) return i;
		else {
			ppt[i] = findSet(ppt[i]);
			return ppt[i];
		}
	}

	void insertEdge(int u, int v, int w) {
		edges.push_back(Edge(u, v, w));
	}

	std::vector<int> kruskal() {
		std::vector<int> kruSequence;
		for (int i = 0; i < edgeCount; i++) {
			int u, v, w;
			std::cin >> u>>v>>w;
			--u;
			--v;
			if (u > v)std::swap(u, v);
			insertEdge(u, v, w);
		}

		std::sort(edges.begin(), edges.end());

		for (int i = 0; i < edgeCount; i++) {
			int ppIndex = findSet(edges[i].parent);
			int pcIndex = findSet(edges[i].child);
			if (ppIndex == pcIndex) continue;
			else {
				kruSequence.push_back(edges[i].weight);
				ppt[pcIndex] = ppIndex;
			}

		}

		return kruSequence;
	}
};

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(NULL);
	std::cout.tie(NULL);
	
	int n, m,i;
	std::vector<int> weightArr;

	std::cin >> n>> m>>i;
	Graph graph(n, m);
	weightArr = graph.kruskal();

	long long int cost = std::accumulate(weightArr.begin(), weightArr.end(), 0);

	std::cout << cost << ""\n"";
	std::cout << weightArr[--i];
}"
